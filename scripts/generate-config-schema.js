#!/usr/bin/env node
/* eslint-disable @typescript-eslint/no-var-requires */
// Generate JSON Schema from TypeScript types (src/types/config.ts â†’ VisorConfig)
// and emit a TypeScript module exporting the schema so it can be bundled.

const fs = require('fs');
const path = require('path');

async function generate() {
  let tjs;
  try {
    tjs = require('ts-json-schema-generator');
  } catch (e) {
    console.warn('[generate-config-schema] ts-json-schema-generator not installed; skipping');
    return;
  }

  // ts-json-schema-generator cannot represent function-typed fields in JSON Schema.
  // Our VisorConfig includes hooks?: VisorHooks with function members.
  // Generate a schema-friendly alias that omits 'hooks' (and replaces it with a generic object),
  // and point the generator at a tiny temporary file that declares that alias.
  const tmpDir = path.resolve(__dirname, '.schema-tmp');
  fs.mkdirSync(tmpDir, { recursive: true });
  const tmpFile = path.join(tmpDir, 'visor-config-alias.ts');
  const relImport = path.relative(tmpDir, path.resolve(__dirname, '..', 'src', 'types', 'config'))
    .replace(/\\/g, '/');
  const aliasSource = `
    import type { VisorConfig } from '${relImport}';
    export type VisorConfigSchema = Omit<VisorConfig, 'hooks'> & { hooks?: Record<string, unknown> };
  `;
  fs.writeFileSync(tmpFile, aliasSource, 'utf8');

  const config = {
    path: tmpFile,
    tsconfig: path.resolve(__dirname, '..', 'tsconfig.json'),
    type: 'VisorConfigSchema',
    expose: 'all',
    jsDoc: 'extended',
    skipTypeCheck: true,
    topRef: true,
  };

  const generator = tjs.createGenerator(config);
  const schema = generator.createSchema('VisorConfigSchema');

  // Post-process: lock objects and allow extension keys starting with x-
  function decorate(obj) {
    if (!obj || typeof obj !== 'object') return;
    if (obj.type === 'object' && obj.properties) {
      if (obj.additionalProperties === undefined) {
        obj.additionalProperties = false;
      }
      obj.patternProperties = obj.patternProperties || {};
      obj.patternProperties['^x-'] = {};
    }
    // Recurse common schema containers
    for (const key of ['definitions', '$defs', 'properties', 'items', 'anyOf', 'allOf', 'oneOf']) {
      const child = obj[key];
      if (Array.isArray(child)) child.forEach(decorate);
      else if (child && typeof child === 'object')
        Object.values(child).forEach(decorate);
    }
  }

  decorate(schema);

  const outDir = path.resolve(__dirname, '..', 'src', 'generated');
  const outFile = path.join(outDir, 'config-schema.ts');
  fs.mkdirSync(outDir, { recursive: true });
  const header = `// AUTO-GENERATED FILE. DO NOT EDIT.\n// Generated by scripts/generate-config-schema.js from src/types/config.ts \n`;
  const body = `export const configSchema = ${JSON.stringify(schema, null, 2)} as const;\nexport default configSchema;\n`;
  let content = header + body;
  try {
    const prettier = require('prettier');
    let options = { parser: 'typescript' };
    try {
      const resolved = await prettier.resolveConfig(outFile);
      if (resolved) options = { ...resolved, parser: 'typescript' };
    } catch {}
    const maybe = prettier.format(content, options);
    content = typeof maybe === 'string' ? maybe : await maybe;
  } catch (_) {
    // Prettier not available; write raw content
  }
  fs.writeFileSync(outFile, content, 'utf8');
  console.log(`[generate-config-schema] Wrote ${outFile}`);

  // Also emit a JSON copy into dist for visibility + direct load in runtime if needed
  try {
    const distGen = path.resolve(__dirname, '..', 'dist', 'generated');
    fs.mkdirSync(distGen, { recursive: true });
    const jsonOut = path.join(distGen, 'config-schema.json');
    fs.writeFileSync(jsonOut, JSON.stringify(schema, null, 2), 'utf8');
    console.log(`[generate-config-schema] Wrote ${jsonOut}`);
  } catch (e) {
    console.warn('[generate-config-schema] Could not write dist/generated/config-schema.json:', e && e.message ? e.message : e);
  }
}

try {
  generate().catch(e => {
    console.warn('[generate-config-schema] Failed:', e && e.message ? e.message : e);
  });
} catch (e) {
  console.warn('[generate-config-schema] Failed:', e && e.message ? e.message : e);
}
