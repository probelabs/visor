#!/usr/bin/env node
/* eslint-disable @typescript-eslint/no-var-requires */
// Generate JSON Schema from TypeScript types (src/types/config.ts â†’ VisorConfig)
// and emit a TypeScript module exporting the schema so it can be bundled.

const fs = require('fs');
const path = require('path');

function generate() {
  let tjs;
  try {
    tjs = require('ts-json-schema-generator');
  } catch (e) {
    console.warn('[generate-config-schema] ts-json-schema-generator not installed; skipping');
    return;
  }

  const config = {
    path: path.resolve(__dirname, '..', 'src', 'types', 'config.ts'),
    tsconfig: path.resolve(__dirname, '..', 'tsconfig.json'),
    type: 'VisorConfig',
    expose: 'all',
    jsDoc: 'extended',
    skipTypeCheck: true,
    topRef: true,
  };

  const generator = tjs.createGenerator(config);
  const schema = generator.createSchema('VisorConfig');

  // Post-process: lock objects and allow extension keys starting with x-
  function decorate(obj) {
    if (!obj || typeof obj !== 'object') return;
    if (obj.type === 'object' && obj.properties) {
      if (obj.additionalProperties === undefined) {
        obj.additionalProperties = false;
      }
      obj.patternProperties = obj.patternProperties || {};
      obj.patternProperties['^x-'] = {};
    }
    // Recurse common schema containers
    for (const key of ['definitions', '$defs', 'properties', 'items', 'anyOf', 'allOf', 'oneOf']) {
      const child = obj[key];
      if (Array.isArray(child)) child.forEach(decorate);
      else if (child && typeof child === 'object')
        Object.values(child).forEach(decorate);
    }
  }

  decorate(schema);

  const outDir = path.resolve(__dirname, '..', 'src', 'generated');
  const outFile = path.join(outDir, 'config-schema.ts');
  fs.mkdirSync(outDir, { recursive: true });
  const header = `// AUTO-GENERATED FILE. DO NOT EDIT.\n// Generated by scripts/generate-config-schema.js from src/types/config.ts \n`;
  const body = `export const configSchema = ${JSON.stringify(schema, null, 2)} as const;\nexport default configSchema;\n`;
  fs.writeFileSync(outFile, header + body, 'utf8');
  console.log(`[generate-config-schema] Wrote ${outFile}`);

  // Also emit a JSON copy into dist for visibility + direct load in runtime if needed
  try {
    const distGen = path.resolve(__dirname, '..', 'dist', 'generated');
    fs.mkdirSync(distGen, { recursive: true });
    const jsonOut = path.join(distGen, 'config-schema.json');
    fs.writeFileSync(jsonOut, JSON.stringify(schema, null, 2), 'utf8');
    console.log(`[generate-config-schema] Wrote ${jsonOut}`);
  } catch (e) {
    console.warn('[generate-config-schema] Could not write dist/generated/config-schema.json:', e && e.message ? e.message : e);
  }
}

try {
  generate();
} catch (e) {
  console.warn('[generate-config-schema] Failed:', e && e.message ? e.message : e);
}
