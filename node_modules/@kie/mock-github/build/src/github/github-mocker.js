"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockGithub = void 0;
const action_mocker_1 = require("../github/action/action-mocker");
const env_mocker_1 = require("../github/env/env-mocker");
const repository_mocker_1 = require("../github/repository/repository-mocker");
const github_1 = require("../github/schema/github");
const ajv_1 = __importDefault(require("ajv"));
const fs_extra_1 = require("fs-extra");
const path_1 = __importDefault(require("path"));
class MockGithub {
    constructor(config, setupPath = process.cwd()) {
        this.config = this.validateConfig(config);
        this.setupPath = setupPath.startsWith("/")
            ? setupPath
            : path_1.default.resolve(process.cwd(), setupPath);
        this.actionMocker = new action_mocker_1.ActionMocker(this.config.action, this.setupPath);
        this.envMocker = new env_mocker_1.EnvMocker(this.config.env);
        this.repoMocker = new repository_mocker_1.RepositoryMocker(this.config.repo, this.setupPath);
        this.setupDirCreated = false;
        this.hasCalledSetup = false;
    }
    async setup() {
        // create the setup dir if does not exist
        if (!(0, fs_extra_1.existsSync)(this.setupPath)) {
            (0, fs_extra_1.mkdirSync)(this.setupPath);
            this.setupDirCreated = true;
        }
        await Promise.all([this.repoMocker.setup(), this.envMocker.setup()]);
        // trigger after env has been setup so that any env vars needed in action mocker are not overriden by user env vars
        await this.actionMocker.setup();
        this.hasCalledSetup = true;
    }
    async teardown() {
        await Promise.all([
            this.repoMocker.teardown(),
            this.actionMocker.teardown(),
            this.envMocker.teardown(),
        ]);
        // rm the setup dir only if we had created it
        if (this.setupDirCreated) {
            (0, fs_extra_1.rmSync)(this.setupPath, { recursive: true });
        }
        this.hasCalledSetup = false;
    }
    get env() {
        if (!this.hasCalledSetup) {
            throw new Error("Env has not been setup");
        }
        return {
            update: this.envMocker.update.bind(this.envMocker),
            delete: this.envMocker.delete.bind(this.envMocker),
            get: this.envMocker.get.bind(this.envMocker),
        };
    }
    get repo() {
        if (!this.hasCalledSetup) {
            throw new Error("Repositories have not been setup");
        }
        return this.repoMocker.repositoryState;
    }
    get action() {
        if (!this.hasCalledSetup) {
            throw new Error("Action has not been setup");
        }
        return {
            input: this.actionMocker.input,
            archiver: this.actionMocker.archiver,
        };
    }
    validateConfig(config) {
        const rawJSON = typeof config === "string"
            ? JSON.parse((0, fs_extra_1.readFileSync)(config, "utf8"))
            : config;
        const ajv = new ajv_1.default({ allowUnionTypes: true });
        const validate = ajv.compile(github_1.GithubConfigSchema);
        if (validate(rawJSON)) {
            return rawJSON;
        }
        else {
            throw new Error(JSON.stringify(validate.errors));
        }
    }
}
exports.MockGithub = MockGithub;
