"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArchiveServer = void 0;
const express_1 = __importDefault(require("express"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const sync_1 = require("totalist/sync");
class ArchiveServer {
    constructor(store, port) {
        this.port = port;
        this.store = store;
        this.server = (0, express_1.default)();
        this.server.use(express_1.default.json());
        this.server.use(express_1.default.raw({
            type: "application/octet-stream",
            limit: "150mb",
        }));
        this.initDownload();
        this.initUpload();
    }
    initUpload() {
        this.server.post("/_apis/pipelines/workflows/:runId/artifacts", (req, res) => {
            const { runId } = req.params;
            const baseURL = `${req.protocol}://${req.get("host")}${req.baseUrl}`;
            res.json({ fileContainerResourceUrl: `${baseURL}/upload/${runId}` });
        });
        this.server.patch("/_apis/pipelines/workflows/:runId/artifacts", (_req, res) => {
            res.status(200).json({ message: "success" });
        });
        this.server.put("/upload/:runId", (req, res) => {
            let { itemPath } = req.query;
            const { runId } = req.params;
            if (req.get("Content-Encoding")) {
                itemPath += ".gz__";
            }
            const filename = path_1.default.join(this.store, runId, path_1.default.normalize(itemPath));
            fs_extra_1.default.ensureFileSync(filename);
            const contentRange = req.get("Content-Range");
            const mode = contentRange !== "" && !contentRange?.startsWith("bytes 0-")
                ? "a"
                : "w";
            const fd = fs_extra_1.default.openSync(filename, mode);
            fs_extra_1.default.writeSync(fd, req.body);
            res.status(200).json({ message: "success" });
        });
    }
    initDownload() {
        this.server.get("/_apis/pipelines/workflows/:runId/artifacts", (req, res) => {
            const { runId } = req.params;
            const artifacts = [];
            const baseURL = `${req.protocol}://${req.get("host")}${req.baseUrl}`;
            (0, sync_1.totalist)(path_1.default.join(this.store, runId), (name, _abs, _stats) => {
                name = name.replace("\\", "/");
                const fileDetails = {
                    name: name.split("/")[0],
                    fileContainerResourceUrl: `${baseURL}/download/${runId}`,
                };
                artifacts.push(fileDetails);
            });
            res.status(200).json({ count: artifacts.length, value: artifacts });
        });
        this.server.get("/download/:container", (req, res) => {
            const { container } = req.params;
            const baseURL = `${req.protocol}://${req.get("host")}${req.baseUrl}`;
            const files = [];
            (0, sync_1.totalist)(path_1.default.join(this.store, container), (name, _abs, _stats) => {
                files.push({
                    path: path_1.default.normalize(name),
                    itemType: "file",
                    contentLocation: `${baseURL}/download/${container}/${name.replace("\\", "/")}`,
                });
            });
            res.status(200).json({ value: files });
        });
        this.server.get("/download/:container/:path(*)", (req, res) => {
            const fileLocation = path_1.default.join(this.store, req.params.container, req.params.path);
            fs_extra_1.default.createReadStream(fileLocation, { encoding: "utf-8" }).pipe(res);
        });
    }
    start() {
        return new Promise((resolve, reject) => {
            const app = this.server.listen(this.port, () => {
                this.app = app;
                resolve();
            });
            app.on("error", err => {
                reject(err);
            });
        });
    }
    stop() {
        return new Promise((resolve, reject) => {
            if (this.app) {
                this.app.close(err => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve();
                    }
                });
            }
            else {
                reject(new Error("Server has not been started"));
            }
        });
    }
}
exports.ArchiveServer = ArchiveServer;
