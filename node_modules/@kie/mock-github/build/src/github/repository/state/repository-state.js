"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RepositoryState = void 0;
const fs_extra_1 = require("fs-extra");
const path_1 = __importDefault(require("path"));
const totalist_1 = require("totalist");
const repository_history_types_1 = require("../../../github/repository/history/repository-history.types");
const repository_constants_1 = require("../../../github/repository/repository.constants");
const simple_git_1 = __importDefault(require("simple-git"));
class RepositoryState {
    constructor(repositories, setupPath) {
        this.repositories = repositories;
        this.setupPath = setupPath;
    }
    async getState(repositoryName) {
        if (this.repositories[repositoryName]) {
            return {
                name: repositoryName,
                owner: this.getOwner(repositoryName),
                path: this.getPath(repositoryName),
                branches: this.getBranchState(repositoryName),
                files: await this.getFileSystemState(repositoryName),
                forkedFrom: this.getForkedFrom(repositoryName),
            };
        }
    }
    getForkedFrom(repositoryName) {
        return this.repositories[repositoryName]?.forkedFrom;
    }
    isFork(repositoryName) {
        return !!this.repositories[repositoryName]?.forkedFrom;
    }
    getPath(repositoryName) {
        if (this.repositories[repositoryName]) {
            return path_1.default.join(this.setupPath, repositoryName);
        }
    }
    getOwner(repositoryName) {
        if (this.repositories[repositoryName]) {
            return (this.repositories[repositoryName].owner ?? process.env.LOGNAME ?? "");
        }
    }
    getBranchState(repositoryName) {
        const repository = this.repositories[repositoryName];
        if (repository) {
            const currentBranch = repository.currentBranch ?? repository_constants_1.DEFAULT_BRANCH;
            const localBranches = repository.localBranches ?? [];
            const pushedBranches = [
                ...(repository.pushedBranches ?? []),
                repository_constants_1.DEFAULT_BRANCH,
            ];
            if (!localBranches.includes(currentBranch) &&
                !pushedBranches.includes(currentBranch)) {
                localBranches.push(currentBranch);
            }
            return {
                currentBranch,
                pushedBranches,
                localBranches,
            };
        }
    }
    async checkout(repositoryName, branch) {
        const repoPath = this.getPath(repositoryName);
        const currBranches = this.getBranchState(repositoryName);
        if (!repoPath) {
            throw new Error("Repository does not exist");
        }
        if (!currBranches?.localBranches.includes(branch) &&
            !currBranches?.pushedBranches.includes(branch)) {
            throw new Error("Branch does not exist");
        }
        await (0, simple_git_1.default)(repoPath).checkout(branch);
        this.repositories[repositoryName] = {
            ...this.repositories[repositoryName],
            currentBranch: branch
        };
    }
    async getFileSystemState(repositoryName) {
        const repository = this.repositories[repositoryName];
        if (!repository) {
            return;
        }
        return this.getFiles(repository.files, repository.history, repository.currentBranch);
    }
    async getFiles(files, gitActions, currentBranch) {
        const result = [];
        const promises = [];
        for (const file of files ?? []) {
            promises.push(this.getFile(file, currentBranch ?? repository_constants_1.DEFAULT_BRANCH));
        }
        let counter = 0;
        for (const action of gitActions ?? []) {
            if (action.action === repository_history_types_1.GitActionTypes.PUSH) {
                const pushAction = action;
                if (pushAction.files) {
                    for (const file of pushAction.files) {
                        promises.push(this.getFile(file, pushAction.branch));
                    }
                }
                else {
                    result.push({
                        path: `/${repository_constants_1.DUMMY_FILE_NAME}${counter}`,
                        branch: pushAction.branch,
                    });
                }
            }
            counter += 0;
        }
        (await Promise.all(promises)).forEach(res => result.push(...res));
        return result;
    }
    async getFile(file, branch) {
        const result = [];
        if ((0, fs_extra_1.lstatSync)(file.src).isDirectory()) {
            await (0, totalist_1.totalist)(file.src, (_name, abs, stats) => {
                if (stats.isFile()) {
                    const absSplit = abs.split(file.src);
                    result.push({
                        path: path_1.default.join(file.dest, absSplit[absSplit.length - 1]),
                        branch,
                    });
                }
            });
        }
        else {
            result.push({
                path: file.dest,
                branch,
            });
        }
        return result;
    }
}
exports.RepositoryState = RepositoryState;
