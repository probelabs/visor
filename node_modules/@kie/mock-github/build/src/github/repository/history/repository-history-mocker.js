"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RepositoryHistory = void 0;
const repository_history_types_1 = require("../../../github/repository/history/repository-history.types");
const repository_constants_1 = require("../../../github/repository/repository.constants");
const repository_file_system_1 = require("../../../github/repository/files/repository-file-system");
class RepositoryHistory {
    constructor(git, repoPath) {
        this.git = git;
        this.repoPath = repoPath;
        this.repofs = new repository_file_system_1.RepositoryFileSystem(this.repoPath);
    }
    async push(action, histIndex) {
        // checkout to branch
        await this.git.checkout(action.branch);
        // setup files
        if (!action.files) {
            await this.repofs.createFile(`${repository_constants_1.DUMMY_FILE_NAME}${histIndex}`, repository_constants_1.DUMMY_FILE_DATA);
        }
        else {
            await this.repofs.copyFiles(action.files);
        }
        // commit and push
        await this.git
            .add(".")
            .commit(action.commitMessage ?? (0, repository_constants_1.DEFAULT_COMMIT_MSG)(histIndex))
            .push(repository_constants_1.ORIGIN, action.branch);
    }
    async merge(action) {
        await this.git.checkout(action.base);
        await this.git.merge([
            action.head,
            "-m",
            action.commitMessage ??
                (0, repository_constants_1.DEFAULT_MERGE_COMMIT_MSG)(action.base, action.head),
        ]);
        await this.git.push(repository_constants_1.ORIGIN, action.base);
    }
    /**
     * Reconstruct git history
     * @returns Array of objects describing what files were created and on which branch
     */
    async setHistory(history) {
        let counter = 0;
        for (const hist of history ?? []) {
            switch (hist.action) {
                case repository_history_types_1.GitActionTypes.PUSH:
                    await this.push(hist, counter);
                    break;
                case repository_history_types_1.GitActionTypes.MERGE:
                    await this.merge(hist);
                    break;
                default:
                    throw new Error("Unknown action");
            }
            counter += 1;
        }
    }
}
exports.RepositoryHistory = RepositoryHistory;
