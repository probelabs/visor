"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RepositoryBranches = void 0;
const repository_constants_1 = require("../../../github/repository/repository.constants");
class RepositoryBranches {
    constructor(git) {
        this.git = git;
        this.localBranches = [];
        this.pushedBranches = [repository_constants_1.DEFAULT_BRANCH];
    }
    async setPushedBranches(branches) {
        for (const branch of branches ?? []) {
            if (!this.pushedBranches.includes(branch)) {
                await this.git.checkoutLocalBranch(branch).push(repository_constants_1.ORIGIN, branch);
                await this.git.checkout(repository_constants_1.DEFAULT_BRANCH);
                this.pushedBranches.push(branch);
            }
        }
        return this.pushedBranches;
    }
    async setLocalBranches(branches) {
        for (const branch of branches ?? []) {
            if (!this.localBranches.includes(branch)) {
                await this.git.checkoutLocalBranch(branch).checkout(repository_constants_1.DEFAULT_BRANCH);
                this.localBranches.push(branch);
            }
        }
        return this.localBranches;
    }
    async setCurrentBranch(branch) {
        // if branch wasn't defined checkout main branch
        if (!branch) {
            await this.git.checkout(repository_constants_1.DEFAULT_BRANCH);
            return repository_constants_1.DEFAULT_BRANCH;
        }
        // branch does not exist. create it first
        if (!this.localBranches.includes(branch) &&
            !this.pushedBranches.includes(branch)) {
            await this.git.branch([branch]);
            this.localBranches.push(branch);
        }
        await this.git.checkout(branch);
        return branch;
    }
}
exports.RepositoryBranches = RepositoryBranches;
