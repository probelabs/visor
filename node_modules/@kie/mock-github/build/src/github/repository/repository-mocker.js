"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RepositoryMocker = void 0;
const simple_git_1 = __importDefault(require("simple-git"));
const path_1 = __importDefault(require("path"));
const fs_extra_1 = require("fs-extra");
const repository_history_mocker_1 = require("../../github/repository/history/repository-history-mocker");
const repository_branches_1 = require("../../github/repository/branches/repository-branches");
const repository_constants_1 = require("../../github/repository/repository.constants");
const repository_file_system_1 = require("../../github/repository/files/repository-file-system");
const repository_state_1 = require("../../github/repository/state/repository-state");
class RepositoryMocker {
    constructor(repositories, setupPath) {
        this.repositories = repositories ?? {};
        this.setupPath = path_1.default.join(setupPath, "repo");
        this.setupDirCreated = !(0, fs_extra_1.existsSync)(this.setupPath);
        this._repositoryState = new repository_state_1.RepositoryState(this.repositories, this.setupPath);
    }
    /**
     * Loop through all the repositories and construct them according to the state specified in config file
     */
    async setup() {
        await Promise.all(Object.entries(this.repositories).map(([repoName, currentRepo]) => this.setupRepository(repoName, currentRepo)));
    }
    /**
     * Delete any created repositories
     */
    async teardown() {
        await Promise.all(this.setupDirCreated
            ? [(0, fs_extra_1.rm)(this.setupPath, { recursive: true, force: true })]
            : Object.keys(this.repositories).map(repoName => (0, fs_extra_1.rm)(this._repositoryState.getPath(repoName), {
                recursive: true,
                force: true,
            })));
    }
    /**
     * Exposes the interface used to produce just state info for all repositories
     */
    get repositoryState() {
        return this._repositoryState;
    }
    /**
     * Create and initialize repo
     * @param repoName name of the repo to initialize
     * @returns git instance and path to repo
     */
    async initRepo(repoName) {
        // get repository, remote, remote/origin and remote/upstream paths
        const repoPath = path_1.default.join(this.setupPath, repoName);
        const remotePath = path_1.default.join(repoPath, repository_constants_1.REMOTE);
        const originPath = path_1.default.join(remotePath, repository_constants_1.ORIGIN);
        const upstreamPath = path_1.default.join(remotePath, repository_constants_1.UPSTREAM);
        // create origin and upstream folders
        (0, fs_extra_1.mkdirSync)(originPath, { recursive: true });
        (0, fs_extra_1.mkdirSync)(upstreamPath, { recursive: true });
        // load git instances for the repository, origin and upstream
        const git = (0, simple_git_1.default)(repoPath);
        const originGit = (0, simple_git_1.default)(originPath);
        const upstreamGit = (0, simple_git_1.default)(upstreamPath);
        await Promise.all([
            originGit
                .init(true, ["-b", repository_constants_1.DEFAULT_BRANCH])
                .addConfig("user.name", "Github")
                .addConfig("user.email", "noreply@github.com"),
            upstreamGit
                .init(true, ["-b", repository_constants_1.DEFAULT_BRANCH])
                .addConfig("user.name", "Github")
                .addConfig("user.email", "noreply@github.com"),
            (0, fs_extra_1.writeFile)(path_1.default.join(repoPath, repository_constants_1.GITIGNORE), repository_constants_1.REMOTE), // add remote to gitignore of the repository so that upstream and origin aren't pushed,
        ]);
        // initialize the repository and add origin, upstream and perform first push on main
        await git
            .init(["-b", repository_constants_1.DEFAULT_BRANCH])
            .addConfig("user.name", "Github")
            .addConfig("user.email", "noreply@github.com")
            .addRemote(repository_constants_1.ORIGIN, originPath)
            .addRemote(repository_constants_1.UPSTREAM, upstreamPath)
            .add(".")
            .commit(repository_constants_1.DEFAULT_INIT_COMMIT_MSG)
            .push(repository_constants_1.ORIGIN, repository_constants_1.DEFAULT_BRANCH, ["--set-upstream"]);
        return {
            git,
            repoPath,
        };
    }
    /**
     * Uses the RepositoryFileSystem to copy files from given srcs to destination in the
     * repository which is to be created
     * @param git
     * @param repoPath
     * @param files
     */
    async setFiles(git, repoPath, files) {
        const repofs = new repository_file_system_1.RepositoryFileSystem(repoPath);
        const filesCreated = await repofs.copyFiles(files);
        if (filesCreated) {
            await git
                .add(".")
                .commit(repository_constants_1.DEFAULT_INIT_COMMIT_MSG)
                .push(repository_constants_1.ORIGIN, repository_constants_1.DEFAULT_BRANCH);
        }
    }
    /**
     * Sets local and pushed branches
     * @param git
     * @param localBranches
     * @param pushedBranches
     */
    async setBranches(git, localBranches, pushedBranches) {
        const gitBranches = new repository_branches_1.RepositoryBranches(git);
        await gitBranches.setLocalBranches(localBranches);
        await gitBranches.setPushedBranches(pushedBranches);
    }
    /**
     * Sets the current branch
     * @param git
     * @param currBranch
     * @returns
     */
    async setCurrentBranch(git, currBranch) {
        const gitBranch = new repository_branches_1.RepositoryBranches(git);
        return gitBranch.setCurrentBranch(currBranch);
    }
    /**
     * Reproduces the git history
     * @param git
     * @param repoPath
     * @param history
     * @returns
     */
    async setHistory(git, repoPath, history) {
        const gitHistory = new repository_history_mocker_1.RepositoryHistory(git, repoPath);
        return gitHistory.setHistory(history);
    }
    /**
     * Setups the given repository i.e. performs the following
     * 1. Initialize the repository
     * 2. Add any files to DEFAULT_BRANCH for initialization
     * 3. Set up local and pushed branches
     * 4. Recreate git history
     * 5. Set current branch
     * @param repoName
     * @param currentRepo
     */
    async setupRepository(repoName, currentRepo) {
        const { git, repoPath } = await this.initRepo(repoName);
        // create repository files
        await this.setFiles(git, repoPath, currentRepo.files);
        // create all local and remote branches
        await this.setBranches(git, currentRepo.localBranches, currentRepo.pushedBranches);
        // create the required history for the repo
        await this.setHistory(git, repoPath, currentRepo.history);
        // set the active branch if defined otherwise let it be main
        await this.setCurrentBranch(git, currentRepo.currentBranch);
    }
}
exports.RepositoryMocker = RepositoryMocker;
