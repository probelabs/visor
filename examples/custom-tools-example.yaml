version: "1.0"

# Custom Tool Definitions
# These tools can be used in any MCP block with transport: custom
tools:
  # Simple grep tool for finding patterns in files
  grep-pattern:
    name: grep-pattern
    description: Search for patterns in files using grep
    inputSchema:
      type: object
      properties:
        pattern:
          type: string
          description: Regular expression pattern to search for
        files:
          type: array
          items:
            type: string
          description: List of files to search in
      required: [pattern]
    exec: 'grep -n "{{ args.pattern }}" {{ args.files | join: " " }}'
    transform_js: |
      // Parse grep output into structured format
      const lines = output.trim().split('\n').filter(l => l);
      return lines.map(line => {
        const match = line.match(/^([^:]+):(\d+):(.*)$/);
        if (!match) return null;
        return {
          file: match[1],
          line: parseInt(match[2]),
          content: match[3].trim()
        };
      }).filter(Boolean);

  # Tool to count lines of code
  count-lines:
    name: count-lines
    description: Count lines of code in files
    inputSchema:
      type: object
      properties:
        files:
          type: array
          items:
            type: string
          description: Files to count lines in
        exclude_blank:
          type: boolean
          description: Exclude blank lines from count
    exec: |
      {% if args.exclude_blank %}
        cat {{ args.files | join: " " }} | grep -v "^$" | wc -l
      {% else %}
        cat {{ args.files | join: " " }} | wc -l
      {% endif %}
    transform_js: 'return parseInt(output.trim());'

  # Tool to check if a file contains sensitive data patterns
  check-secrets:
    name: check-secrets
    description: Check for potential secrets in files
    inputSchema:
      type: object
      properties:
        file:
          type: string
          description: File to check
      required: [file]
    exec: |
      grep -E "(api[_-]?key|secret|token|password|pwd|auth|credential)" -i "{{ args.file }}" || echo "No secrets found"
    transform_js: |
      if (output.includes("No secrets found")) {
        return { safe: true, issues: [] };
      }
      const lines = output.trim().split('\n');
      return {
        safe: false,
        issues: lines.map(line => ({
          type: 'potential_secret',
          content: line.substring(0, 100) // Truncate for safety
        }))
      };

  # Tool to analyze code complexity
  analyze-complexity:
    name: analyze-complexity
    description: Analyze code complexity metrics
    inputSchema:
      type: object
      properties:
        file:
          type: string
          description: Source code file to analyze
        language:
          type: string
          description: Programming language (js, py, go, etc.)
      required: [file]
    exec: |
      echo "Analyzing {{ args.file }}"
      # Count functions/methods
      {% if args.language == "js" or args.language == "ts" %}
        grep -c "function\|=>" "{{ args.file }}" || echo "0"
      {% elsif args.language == "py" %}
        grep -c "def " "{{ args.file }}" || echo "0"
      {% elsif args.language == "go" %}
        grep -c "func " "{{ args.file }}" || echo "0"
      {% else %}
        echo "0"
      {% endif %}
    transform_js: |
      const functionCount = parseInt(output.trim().split('\n').pop() || '0');
      return {
        file: args.file,
        language: args.language || 'unknown',
        metrics: {
          functionCount: functionCount,
          complexity: functionCount > 10 ? 'high' : functionCount > 5 ? 'medium' : 'low'
        }
      };

  # Tool to validate JSON/YAML files
  validate-config:
    name: validate-config
    description: Validate configuration file syntax
    inputSchema:
      type: object
      properties:
        file:
          type: string
          description: Configuration file to validate
        type:
          type: string
          enum: [json, yaml]
          description: File type to validate
      required: [file, type]
    exec: |
      {% if args.type == "json" %}
        python3 -m json.tool "{{ args.file }}" > /dev/null 2>&1 && echo "Valid JSON" || echo "Invalid JSON"
      {% else %}
        python3 -c "import yaml; yaml.safe_load(open('{{ args.file }}'))" 2>&1 && echo "Valid YAML" || echo "Invalid YAML"
      {% endif %}
    parseJson: false
    transform_js: |
      const isValid = output.includes("Valid");
      return {
        file: args.file,
        type: args.type,
        valid: isValid,
        message: output.trim()
      };

  # Tool to generate file statistics
  file-stats:
    name: file-stats
    description: Generate statistics about files
    inputSchema:
      type: object
      properties:
        pattern:
          type: string
          description: Glob pattern for files to analyze
    exec: |
      find . -name "{{ args.pattern }}" -type f | xargs wc -l | tail -1
    transform_js: |
      const parts = output.trim().split(/\s+/);
      return {
        totalLines: parseInt(parts[0] || '0'),
        fileCount: Math.max(0, parts.length - 2) // Subtract total line
      };

# Example usage of custom tools in checks
steps:
  # Use custom tool to find TODO comments
  find-todos:
    type: mcp
    transport: custom
    method: grep-pattern
    methodArgs:
      pattern: "TODO|FIXME|HACK"
      files: ["*.js", "*.ts", "*.py"]
    transform_js: |
      // Convert grep results to issues
      output.map(match => ({
        file: match.file,
        line: match.line,
        message: `Found comment: ${match.content}`,
        severity: match.content.includes('FIXME') ? 'warning' : 'info',
        category: 'documentation',
        ruleId: 'todo-comment'
      }))

  # Check for secrets using custom tool
  security-check:
    type: mcp
    transport: custom
    method: check-secrets
    forEach: "{{ files | map: 'filename' }}"
    methodArgs:
      file: "{{ item }}"
    transform_js: |
      if (!output.safe) {
        return output.issues.map(issue => ({
          file: args.file,
          line: 0,
          message: `Potential secret detected: ${issue.type}`,
          severity: 'critical',
          category: 'security',
          ruleId: 'potential-secret'
        }));
      }
      return [];

  # Analyze code complexity
  complexity-analysis:
    type: mcp
    transport: custom
    method: analyze-complexity
    forEach: "{{ files | where: 'filename', 'endsWith', '.js' }}"
    methodArgs:
      file: "{{ item.filename }}"
      language: "js"
    transform_js: |
      const complexity = output.metrics.complexity;
      if (complexity === 'high') {
        return [{
          file: output.file,
          line: 0,
          message: `High complexity detected: ${output.metrics.functionCount} functions`,
          severity: 'warning',
          category: 'performance',
          ruleId: 'high-complexity'
        }];
      }
      return [];

  # Validate all JSON config files
  validate-json-configs:
    type: mcp
    transport: custom
    method: validate-config
    forEach: "{{ files | where: 'filename', 'endsWith', '.json' }}"
    methodArgs:
      file: "{{ item.filename }}"
      type: "json"
    fail_if: "!output.valid"
    transform_js: |
      if (!output.valid) {
        return [{
          file: output.file,
          line: 0,
          message: output.message,
          severity: 'error',
          category: 'style',
          ruleId: 'invalid-json'
        }];
      }
      return [];

  # Get repository statistics
  repo-stats:
    type: mcp
    transport: custom
    method: file-stats
    methodArgs:
      pattern: "*.{js,ts,py,go}"
    transform_js: |
      // Create informational message about repo size
      [{
        file: 'repository',
        line: 0,
        message: `Repository contains ${output.fileCount} source files with ${output.totalLines} total lines`,
        severity: 'info',
        category: 'documentation',
        ruleId: 'repo-stats'
      }]

# Output configuration
output:
  format: table
  groupBy: severity