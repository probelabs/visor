version: "1.0"
# Example demonstrating the transform feature in Visor checks
# Transform allows you to reshape command output using Liquid templates

checks:
  # Example 1: Extract specific key from JSON output
  get-package-version:
    type: command
    exec: "cat package.json"
    transform: |
      {{ output.version }}
    group: info

  # Example 2: Extract array from nested object
  get-dependencies:
    type: command
    exec: "cat package.json"
    transform: |
      {{ output.dependencies | json }}
    forEach: true  # Now each dependency can be processed individually
    group: dependencies

  # Example 3: Transform object to array of specific fields
  list-dependency-names:
    type: command
    exec: "cat package.json"
    transform: |
      [
        {% for dep in output.dependencies %}
          "{{ dep[0] }}"{% unless forloop.last %},{% endunless %}
        {% endfor %}
      ]
    forEach: true
    group: dependencies

  # Example 4: Extract and reshape complex data
  analyze-git-log:
    type: command
    exec: |
      git log --format='{"hash":"%H","author":"%an","date":"%ad","message":"%s"}' -n 5 | jq -s '.'
    transform: |
      [
        {% for commit in output %}
        {
          "id": {{ commit.hash | slice: 0, 7 | json }},
          "author": {{ commit.author | json }},
          "summary": {{ commit.message | truncate: 50 | json }}
        }{% unless forloop.last %},{% endunless %}
        {% endfor %}
      ]
    group: git-analysis

  # Example 5: Filter array based on condition
  get-large-files:
    type: command
    exec: |
      find . -type f -name "*.js" -exec wc -l {} + | awk '{print "{\"file\":\"" $2 "\",\"lines\":" $1 "}"}'  | jq -s '.'
    transform: |
      [
        {% for file in output %}
          {% if file.lines > 100 %}
            {{ file.file | json }}
          {% endif %}
        {% endfor %}
      ]
    forEach: true  # Process each large file
    group: analysis

  # Example 6: Combine with forEach - extract array then process each
  get-test-files:
    type: command
    exec: |
      find . -name "*.test.js" -o -name "*.spec.js" | head -10
    transform: |
      {{ output | split: "\n" | json }}
    forEach: true
    group: testing

  run-each-test:
    type: command
    exec: |
      echo "Running test: {{ outputs.get-test-files }}"
      # npm test {{ outputs.get-test-files }}
    depends_on: [get-test-files]
    group: testing

  # Example 7: Extract nested array from API response
  fetch-pr-comments:
    type: http_client
    url: "https://api.github.com/repos/{{ pr.repo }}/pulls/{{ pr.number }}/comments"
    transform: |
      [
        {% for comment in output %}
        {
          "author": {{ comment.user.login | json }},
          "body": {{ comment.body | truncate: 100 | json }},
          "file": {{ comment.path | json }},
          "line": {{ comment.line }}
        }{% unless forloop.last %},{% endunless %}
        {% endfor %}
      ]
    group: review

  # Example 8: Create array from string output using filters
  parse-csv-output:
    type: command
    exec: |
      echo "file1.js,100,modified
      file2.py,200,added
      file3.ts,50,deleted"
    transform: |
      {% assign lines = output | split: "\n" %}
      [
        {% for line in lines %}
          {% assign parts = line | split: "," %}
          {% if parts.size == 3 %}
          {
            "file": {{ parts[0] | json }},
            "lines": {{ parts[1] }},
            "status": {{ parts[2] | json }}
          }{% unless forloop.last %},{% endunless %}
          {% endif %}
        {% endfor %}
      ]
    group: parsing

  # Example 9: Complex transformation with calculations
  aggregate-metrics:
    type: command
    exec: |
      echo '[{"name":"moduleA","size":1000,"complexity":5},
             {"name":"moduleB","size":2000,"complexity":8},
             {"name":"moduleC","size":500,"complexity":2}]'
    transform: |
      {% assign total_size = 0 %}
      {% assign total_complexity = 0 %}
      {% for module in output %}
        {% assign total_size = total_size | plus: module.size %}
        {% assign total_complexity = total_complexity | plus: module.complexity %}
      {% endfor %}
      {
        "modules": {{ output | size }},
        "totalSize": {{ total_size }},
        "totalComplexity": {{ total_complexity }},
        "averageSize": {{ total_size | divided_by: output.size }},
        "averageComplexity": {{ total_complexity | divided_by: output.size }},
        "details": {{ output | json }}
      }
    group: metrics

  # Example 10: Extract specific array from complex nested structure
  get-security-issues:
    type: command
    exec: |
      # Simulating a security scan output
      echo '{
        "scan_date": "2024-01-01",
        "results": {
          "vulnerabilities": [
            {"severity": "high", "file": "auth.js", "line": 42, "issue": "SQL Injection"},
            {"severity": "medium", "file": "config.js", "line": 10, "issue": "Hardcoded Secret"},
            {"severity": "low", "file": "utils.js", "line": 100, "issue": "Weak Random"}
          ],
          "summary": {"total": 3, "high": 1, "medium": 1, "low": 1}
        }
      }'
    transform: |
      {{ output.results.vulnerabilities | json }}
    forEach: true  # Each vulnerability will be processed separately
    group: security

  process-each-vulnerability:
    type: ai
    prompt: |
      Analyze this security issue and provide remediation:
      {{ outputs.get-security-issues | json }}

      Provide specific code fix suggestions.
    depends_on: [get-security-issues]
    group: security

# How transform works:
# 1. The command output is captured in the 'output' variable
# 2. The transform Liquid template has access to:
#    - output: The raw command output (parsed as JSON if possible)
#    - pr: Pull request context
#    - files: Changed files
#    - env: Environment variables
#    - outputs: Results from dependency checks
# 3. The transform template is rendered and the result replaces the original output
# 4. If the transformed result looks like JSON, it's parsed; otherwise kept as string
# 5. The final output is available to dependent checks via outputs.<check-name>
#
# Common patterns:
# - Extract field: {{ output.fieldName }}
# - Extract nested: {{ output.parent.child.field }}
# - Convert to JSON: {{ output | json }}
# - Filter array: {% for item in output %}{% if condition %}...{% endif %}{% endfor %}
# - Create new structure: { "key": {{ output.value | json }} }