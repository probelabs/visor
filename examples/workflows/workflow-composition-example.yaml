# Example demonstrating workflow composition and state isolation
# This config imports the calculator workflow and uses it as a step
# Demonstrates that:
# 1. Workflow tests are NOT auto-executed when imported
# 2. Workflow steps run in isolated context
# 3. State does not leak between workflow and parent config

version: "1.0"

# Import the calculator workflow
imports:
  - ./calculator-workflow.yaml

# Main checks/steps in this config
checks:
  # Step 1: Set some state in parent context
  parent_state_setup:
    type: memory
    operation: set
    key: parent_value
    value: "I am from parent context"

  # Step 2: Use the calculator workflow as an isolated step
  use_calculator:
    type: workflow
    workflow: calculator
    criticality: internal
    assume: "outputs.parent_state_setup"
    depends_on: [parent_state_setup]
    args:
      operation: multiply
      a: 7
      b: 6

  # Step 3: Verify calculator result is accessible
  verify_calculator_result:
    type: command
    depends_on: [use_calculator]
    exec: |
      #!/bin/bash
      result="{{ outputs.use_calculator.result }}"
      summary="{{ outputs.use_calculator.summary }}"

      echo "Calculator returned: $result"
      echo "Summary: $summary"

      if [ "$result" = "42" ]; then
        echo '{"validation": "passed", "result": '$result'}'
        exit 0
      else
        echo '{"validation": "failed", "expected": 42, "got": '$result'}'
        exit 1
      fi

  # Step 4: Verify parent state is still intact (not affected by workflow)
  verify_parent_state:
    type: memory
    operation: get
    key: parent_value
    depends_on: [use_calculator]

  # Step 5: Test state isolation - workflow should NOT have access to parent memory
  test_state_isolation:
    type: command
    depends_on: [verify_parent_state]
    exec: |
      #!/bin/bash
      parent_value="{{ outputs.verify_parent_state }}"

      echo "Parent state verification:"
      echo "  parent_value = $parent_value"

      if [ "$parent_value" = "I am from parent context" ]; then
        echo '{"isolation_test": "passed", "message": "Parent state intact"}'
        exit 0
      else
        echo '{"isolation_test": "failed", "message": "Parent state was modified"}'
        exit 1
      fi

  # Step 6: Use calculator again with different inputs (reusability test)
  use_calculator_again:
    type: workflow
    workflow: calculator
    criticality: internal
    assume: "outputs.test_state_isolation"
    depends_on: [test_state_isolation]
    args:
      operation: add
      a: 100
      b: 23

  # Step 7: Verify both calculator invocations produced correct results
  verify_multiple_invocations:
    type: command
    depends_on: [use_calculator_again]
    exec: |
      #!/bin/bash
      first_result="{{ outputs.use_calculator.result }}"
      second_result="{{ outputs.use_calculator_again.result }}"

      echo "Multiple invocation test:"
      echo "  First call (7 * 6): $first_result (expected 42)"
      echo "  Second call (100 + 23): $second_result (expected 123)"

      if [ "$first_result" = "42" ] && [ "$second_result" = "123" ]; then
        echo '{"multiple_invocations": "passed"}'
        exit 0
      else
        echo '{"multiple_invocations": "failed"}'
        exit 1
      fi

  # Final summary
  summary:
    type: log
    depends_on: [verify_multiple_invocations]
    message: |
      ========================================
      Workflow Composition Test Summary
      ========================================

      ✓ Calculator workflow imported successfully
      ✓ Workflow tests were NOT auto-executed
      ✓ Calculator step executed in isolation
      ✓ Results: {{ outputs.use_calculator.summary }}
      ✓ Parent state remained intact
      ✓ Multiple workflow invocations work correctly

      First calculation: {{ outputs.use_calculator.result }}
      Second calculation: {{ outputs.use_calculator_again.result }}

      All state isolation tests PASSED!
      ========================================
