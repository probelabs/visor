version: "1.0"

# on_init with Workflow Invocation Examples
# Demonstrates how on_init can invoke reusable workflows

# NOTE: Custom tools omitted for test compatibility
# In production, define tools like:
# tools:
#   mock-fetch:
#     exec: echo '{"source":"{{ args.source }}","data":"mock-data-123"}'
#     parseJson: true

steps:
  # Example 1: Simple workflow invocation in on_init
  test-workflow-invocation:
    type: command
    on_init:
      run:
        - workflow: data-enrichment
          with:
            data_source: "api-v1"
          as: enriched-data
    exec: |
      echo "Enriched data: {{ outputs['enriched-data'] | json }}"

  # Example 2: Multiple workflow invocations
  test-multiple-workflows:
    type: command
    on_init:
      run:
        - workflow: data-enrichment
          with:
            data_source: "source-1"
          as: data1
        - workflow: data-enrichment
          with:
            data_source: "source-2"
          as: data2
    exec: |
      echo "Data 1: {{ outputs.data1 | json }}"
      echo "Data 2: {{ outputs.data2 | json }}"

  # Example 3: Workflow with output_mapping
  test-workflow-mapping:
    type: command
    on_init:
      run:
        - workflow: multi-step-workflow
          with:
            input_value: "test"
          output_mapping:
            final_result: step2
          as: workflow-output
    exec: |
      echo "Workflow result: {{ outputs['workflow-output'] | json }}"

  # Example 4: Workflow with overrides
  test-workflow-overrides:
    type: command
    on_init:
      run:
        - workflow: data-enrichment
          with:
            data_source: "overridden-source"
          overrides:
            fetch-data:
              # Override specific check config
              timeout: 500
          as: overridden-data
    exec: |
      echo "{{ outputs['overridden-data'] | json }}"

  # Example 5: Mix tools, steps, and workflows
  test-mixed-invocations:
    type: command
    on_init:
      run:
        - tool: mock-fetch
          with:
            source: "tool-source"
          as: tool-data
        - workflow: data-enrichment
          with:
            data_source: "{{ outputs['tool-data'].source }}"
          as: workflow-data
        - step: process-data
          with:
            input: "{{ outputs['workflow-data'] }}"
          as: processed
    exec: |
      echo "Final: {{ outputs.processed | json }}"

  # Helper step for processing
  process-data:
    type: command
    exec: |
      echo '{"processed":true,"input":"{{ args.input }}"}'
    parseJson: true

  # Example 6: Dynamic workflow invocation with run_js
  test-dynamic-workflows:
    type: command
    on_init:
      run_js: |
        // Conditionally invoke different workflows
        const needsEnrichment = pr.title && pr.title.includes('[feature]');

        if (needsEnrichment) {
          return [
            {
              workflow: 'data-enrichment',
              with: { data_source: 'features-db' },
              as: 'feature-data'
            }
          ];
        }

        return [
          {
            workflow: 'simple-workflow',
            with: { mode: 'basic' },
            as: 'basic-data'
          }
        ];
    exec: |
      {% if outputs['feature-data'] %}
      echo "Feature mode: {{ outputs['feature-data'] | json }}"
      {% else %}
      echo "Basic mode: {{ outputs['basic-data'] | json }}"
      {% endif %}

  # Example 7: Nested workflows (workflow calls another workflow)
  test-nested-workflows:
    type: command
    on_init:
      run:
        - workflow: parent-workflow
          with:
            parent_input: "test"
          as: nested-result
    exec: |
      echo "Nested result: {{ outputs['nested-result'] | json }}"

# NOTE: Reusable workflows omitted for test compatibility
# In production, define workflows like:
#
# workflows:
#   data-enrichment:
#     inputs:
#       data_source: { type: string, required: true }
#     checks:
#       fetch-data: ...
#       transform-data: ...
#     output_mapping:
#       result: transform-data

output:
  format: json
  verbose: true

tests:
  defaults:
    strict: false
    fail_on_unexpected_calls: false
  fixtures: []

  cases:
    - name: simple-workflow-invocation
      description: Test basic workflow invocation in on_init
      event: manual
      fixture: gh.pr_open.minimal
      mocks:
        test-workflow-invocation: 'Enriched data: {"source":"api-v1","data":"mock-data-123"}'
      expect:
        calls:
          - step: test-workflow-invocation
            exactly: 1

    - name: multiple-workflow-invocations
      description: Test invoking multiple workflows in on_init
      event: manual
      fixture: gh.pr_open.minimal
      mocks:
        test-multiple-workflows: 'Data 1: {"source":"source-1"}\nData 2: {"source":"source-2"}'
      expect:
        calls:
          - step: test-multiple-workflows
            exactly: 1

    - name: workflow-with-output-mapping
      description: Test workflow invocation with output_mapping
      event: manual
      fixture: gh.pr_open.minimal
      mocks:
        test-workflow-mapping: 'Workflow result: {"step":2,"final":"completed"}'
      expect:
        calls:
          - step: test-workflow-mapping
            exactly: 1

    - name: mixed-invocations
      description: Test mixing tools, steps, and workflows in on_init
      event: manual
      fixture: gh.pr_open.minimal
      mocks:
        test-mixed-invocations: 'Final: {"processed":true}'
      expect:
        calls:
          - step: test-mixed-invocations
            exactly: 1
