version: "2.0"

# Visor "kitchen sink" example:
# This file is intentionally comment-heavy to show the core benefits of Visor
# vs. linear CI engines (all features are config-first, reproducible, and testable).

# Benefit: composition + override (share org standards without copy/paste).
extends:
  - default
  - ./examples/environments/visor.dev.yaml

# Benefit: built-in observability (traces + logs correlate with trace_id/span_id).
telemetry:
  enabled: true

# Benefit: stateful workflows without external storage.
memory:
  storage: memory
  namespace: visor-demo

# Benefit: first-class webhooks + schedules (not just CI events).
http_server:
  enabled: true
  port: 8080
  host: "0.0.0.0"
  endpoints:
    - path: "/deploy"
      name: "deploy-webhook"

# Benefit: multiple frontends share the same workflow (Slack + GitHub + webhook).
slack:
  threads: required
  telemetry:
    enabled: true

# Benefit: safe remediation loops and deterministic retries.
routing:
  max_loops: 6
  defaults:
    on_fail:
      retry: { max: 1, backoff: { mode: fixed, delay_ms: 300 } }

# Benefit: reusable workflows (import once, call as steps).
imports:
  - ./examples/workflows/calculator-workflow.yaml

# Benefit: custom tools and MCP tools (AI can call internal tooling safely).
tools:
  fetch-jira-issue:
    name: fetch-jira-issue
    description: Example tool that returns ticket context as JSON
    inputSchema:
      type: object
      properties:
        key: { type: string }
      required: [key]
    exec: 'echo "{\"key\":\"{{ args.key }}\",\"summary\":\"Example summary\"}"'
    parseJson: true

  git-diff-summary:
    name: git-diff-summary
    description: Summarize git diff for the repo under analysis
    inputSchema:
      type: object
      properties:
        base: { type: string }
        head: { type: string }
      required: [base, head]
    exec: 'git diff --stat {{ args.base }}..{{ args.head }}'
    parseJson: false

output:
  pr_comment:
    format: markdown
    group_by: check
    collapse: true

steps:
  # ---------------------------------------------------------------------------
  # 1) GitHub PR automation (structured outputs + schemas + templates)
  # ---------------------------------------------------------------------------
  pr-overview:
    type: ai
    on: [pr_opened, pr_updated]
    schema: overview
    prompt: |
      Summarize the PR in 5 bullets. Use the overview schema.
    tags: ["pr", "fast"]

  # Benefit: AI session reuse for multi-step reasoning.
  security-analysis:
    type: ai
    on: [pr_opened, pr_updated]
    schema: code-review
    template:
      file: "./examples/templates/security-report.liquid"
    prompt: |
      Identify security issues in the PR and return code-review schema JSON.

  security-remediation:
    type: ai
    on: [pr_opened, pr_updated]
    depends_on: [security-analysis]
    reuse_ai_session: true
    schema: plain
    prompt: |
      Based on the prior security analysis, propose remediation steps.

  # Benefit: MCP provider step (native integration with external tools).
  semgrep-security-scan:
    type: mcp
    on: [pr_opened, pr_updated]
    transport: stdio
    command: npx
    args: ["-y", "@semgrep/mcp"]
    method: scan
    methodArgs:
      paths: "{{ files | map: 'filename' | json }}"
      rules: ["security", "owasp-top-10"]

  # Benefit: Claude Code provider for tool-augmented reasoning.
  claude-architecture:
    type: claude-code
    on: [pr_opened, pr_updated]
    prompt: |
      Provide a quick architecture review of the PR changes.
    claude_code:
      allowedTools: [Read, Grep]
      maxTurns: 3

  # Benefit: native GitHub operations (labels/comments) without shelling out.
  apply-overview-labels:
    type: github
    depends_on: [pr-overview]
    on: [pr_opened, pr_updated]
    op: labels.add
    values:
      - "visor/overview"

  # Benefit: author permission gating for safe automation.
  trusted-only-note:
    type: github
    depends_on: [pr-overview]
    on: [pr_opened]
    if: "hasMinPermission('MEMBER')"
    op: comment.create
    values:
      - "Trusted contributor detected - running fast path automation."

  # Benefit: scheduled automation (not just CI events).
  nightly-security-audit:
    type: ai
    schedule: "0 2 * * *"
    schema: code-review
    prompt: |
      Run a nightly security audit and return code-review schema JSON.

  # ---------------------------------------------------------------------------
  # 2) Human-in-the-loop entry (Slack or CLI)
  # ---------------------------------------------------------------------------
  ask:
    type: human-input
    group: assistant
    criticality: info
    prompt: "What do you want to do?"

  # Benefit: deterministic intent routing with schema validation.
  route-intent:
    type: ai
    depends_on: [ask]
    criticality: internal
    guarantee:
      - "output?.intent != null"
    schema:
      type: object
      properties:
        intent:
          type: string
          enum: [review, answer]
        topic:
          type: string
      required: [intent]
    ai:
      disableTools: true
    prompt: |
      Classify the latest request:
      - review: run a code review pipeline
      - answer: answer a question directly
      Latest request: {{ outputs['ask'].text }}
    on_success:
      transitions:
        - when: "output.intent === 'review'"
          to: plan-repos
        - when: "output.intent === 'answer'"
          to: chat-answer

  # ---------------------------------------------------------------------------
  # 3) Cross-repo fan-out with forEach + git-checkout
  # ---------------------------------------------------------------------------
  plan-repos:
    type: script
    depends_on: [route-intent]
    criticality: internal
    forEach: true
    content: |
      // Benefit: dynamic fan-out, not a static matrix.
      return ["owner/service-a", "owner/service-b"];

  checkout-repo:
    type: git-checkout
    depends_on: [plan-repos]
    repository: "{{ outputs['plan-repos'] }}"
    ref: "main"
    tags: ["review"]

  # Benefit: pre-step enrichment with on_init (no extra orchestration glue).
  analyze-repo:
    type: ai
    depends_on: [checkout-repo]
    schema: code-review
    tags: ["review", "ai"]
    assume:
      - "outputs['checkout-repo']?.success === true"
    on_init:
      run:
        - tool: fetch-jira-issue
          with:
            key: "{{ outputs['route-intent'].topic | default: 'DEMO-1' }}"
          as: jira
    ai_mcp_servers:
      custom-tools:
        tools: [git-diff-summary]
    prompt: |
      You are reviewing: {{ outputs['checkout-repo'].repository }}
      Repo path: {{ outputs['checkout-repo'].path }}
      Jira context: {{ outputs['jira'] | json }}
      Use git-diff-summary if helpful.
      Return code-review schema JSON.
    if: "outputs['checkout-repo']?.success === true"
    on_fail:
      run: [lint-fix]
      retry: { max: 1 }

  # Benefit: policy gates that fail fast on critical findings.
  policy-gate:
    type: log
    depends_on: [analyze-repo]
    criticality: policy
    fail_if: |
      Array.isArray(outputs_raw['analyze-repo']) &&
      outputs_raw['analyze-repo'].some(r => (r?.criticalIssues || 0) > 0)
    message: "Policy gate passed (no critical issues)."

  lint-fix:
    type: command
    depends_on: [checkout-repo]
    fanout: map
    exec: "npm run lint -- --fix"
    working_directory: "{{ outputs['checkout-repo'].path }}"
    criticality: external
    tags: ["fix"]

  # Benefit: aggregated outputs with outputs_raw + deterministic summaries.
  review-summary:
    type: log
    depends_on: [policy-gate]
    message: |
      Reviewed repos: {{ outputs_raw['checkout-repo'] | size }}
      Issues found (all repos): {{ outputs_raw['analyze-repo'] | json }}

  # Benefit: full output history (cross-loop visibility).
  history-snapshot:
    type: log
    depends_on: [review-summary]
    message: |
      Analyze history size: {{ outputs_history['analyze-repo'] | size }}

  # ---------------------------------------------------------------------------
  # 4) Direct answer path (no extra pipeline needed)
  # ---------------------------------------------------------------------------
  chat-answer:
    type: ai
    depends_on: [route-intent]
    schema: plain
    prompt: |
      Answer the user directly:
      {{ outputs['ask'].text }}

  # ---------------------------------------------------------------------------
  # 5) Workflow reuse + stateful counters (memory)
  # ---------------------------------------------------------------------------
  calculator-demo:
    type: workflow
    workflow: calculator
    depends_on: [review-summary]
    args:
      operation: add
      a: 7
      b: 35

  bump-run-counter:
    type: memory
    operation: increment
    key: runs
    depends_on: [calculator-demo]

  # ---------------------------------------------------------------------------
  # 6) Webhook + HTTP automation (beyond GitHub events)
  # ---------------------------------------------------------------------------
  deploy-webhook:
    type: http_input
    endpoint: "/deploy"
    on: [webhook_received]

  deploy-analysis:
    type: ai
    depends_on: [deploy-webhook]
    schema: plain
    prompt: |
      Deployment: {{ outputs['deploy-webhook'] | json }}
      Provide a short risk assessment and next actions.

  # Benefit: outbound HTTP integrations.
  notify-ops:
    type: http
    depends_on: [deploy-analysis]
    url: "${OPS_WEBHOOK_URL}"
    method: POST
    headers:
      Content-Type: "application/json"
    body: |
      {
        "summary": {{ outputs['deploy-analysis'] | json }},
        "timestamp": "{{ timestamp }}"
      }

  # Benefit: http_client for data fetching (polling APIs on a schedule).
  health-check:
    type: http_client
    schedule: "*/30 * * * *"
    url: "${HEALTHCHECK_URL}"

  # ---------------------------------------------------------------------------
  # 7) Routing loops (goto) for safe self-healing
  # ---------------------------------------------------------------------------
  setup-env:
    type: command
    exec: "echo '[setup] preparing environment'"

  flaky-step:
    type: command
    depends_on: [setup-env]
    exec: |
      FLAG=".visor_demo_flaky"
      if [ ! -f "$FLAG" ]; then
        echo "first attempt failing" >&2
        touch "$FLAG"
        exit 1
      fi
      echo "second attempt OK"
    on_fail:
      goto: setup-env
