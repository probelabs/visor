version: "1.0"

# Reusable Tool Library
# This file contains only tool definitions that can be imported by other configs

tools:
  # Git tools
  git-status:
    name: git-status
    description: Get git repository status
    exec: 'git status --porcelain'
    transform_js: |
      const lines = output.trim().split('\n').filter(l => l);
      return lines.map(line => {
        const [status, ...pathParts] = line.trim().split(/\s+/);
        return {
          status: status,
          file: pathParts.join(' ')
        };
      });

  git-diff-stats:
    name: git-diff-stats
    description: Get statistics about changes
    inputSchema:
      type: object
      properties:
        base:
          type: string
          description: Base branch to compare against
    exec: 'git diff --stat {{ args.base }}..HEAD'
    transform_js: |
      const lines = output.trim().split('\n');
      const summary = lines[lines.length - 1];
      const match = summary.match(/(\d+) files? changed(?:, (\d+) insertions?)?(?:, (\d+) deletions?)?/);
      return {
        filesChanged: parseInt(match?.[1] || '0'),
        insertions: parseInt(match?.[2] || '0'),
        deletions: parseInt(match?.[3] || '0')
      };

  git-log-recent:
    name: git-log-recent
    description: Get recent commit messages
    inputSchema:
      type: object
      properties:
        count:
          type: number
          description: Number of commits to retrieve
    exec: 'git log --oneline -n {{ args.count | default: 5 }}'
    transform_js: |
      const lines = output.trim().split('\n').filter(l => l);
      return lines.map(line => {
        const [hash, ...messageParts] = line.split(/\s+/);
        return {
          hash: hash,
          message: messageParts.join(' ')
        };
      });

  # Docker tools
  docker-lint:
    name: docker-lint
    description: Lint Dockerfile for best practices
    inputSchema:
      type: object
      properties:
        file:
          type: string
          description: Dockerfile to lint
      required: [file]
    exec: 'hadolint {{ args.file }} --format json || echo "[]"'
    parseJson: true
    transform_js: |
      // Convert hadolint output to issues
      return output.map(issue => ({
        file: args.file,
        line: issue.line || 0,
        message: issue.message,
        severity: issue.level === 'error' ? 'error' : issue.level === 'warning' ? 'warning' : 'info',
        category: 'style',
        ruleId: issue.code || 'docker-lint'
      }));

  docker-scan:
    name: docker-scan
    description: Scan Docker image for vulnerabilities
    inputSchema:
      type: object
      properties:
        image:
          type: string
          description: Docker image to scan
      required: [image]
    exec: 'trivy image --format json --quiet {{ args.image }} || echo "{}"'
    parseJson: true
    timeout: 60000
    transform_js: |
      const vulnerabilities = [];
      if (output.Results) {
        for (const result of output.Results) {
          if (result.Vulnerabilities) {
            for (const vuln of result.Vulnerabilities) {
              vulnerabilities.push({
                file: result.Target || 'docker-image',
                line: 0,
                message: `${vuln.VulnerabilityID}: ${vuln.Title || vuln.Description}`,
                severity: vuln.Severity?.toLowerCase() || 'info',
                category: 'security',
                ruleId: vuln.VulnerabilityID
              });
            }
          }
        }
      }
      return vulnerabilities;

  # Package management tools
  npm-audit:
    name: npm-audit
    description: Run npm security audit
    exec: 'npm audit --json || echo "{}"'
    parseJson: true
    transform_js: |
      const issues = [];
      if (output.vulnerabilities) {
        for (const [pkg, vuln] of Object.entries(output.vulnerabilities)) {
          issues.push({
            file: 'package.json',
            line: 0,
            message: `${pkg}: ${vuln.severity} severity vulnerability`,
            severity: vuln.severity === 'high' || vuln.severity === 'critical' ? 'error' : 'warning',
            category: 'security',
            ruleId: `npm-${vuln.severity}`
          });
        }
      }
      return issues;

  check-outdated:
    name: check-outdated
    description: Check for outdated dependencies
    inputSchema:
      type: object
      properties:
        manager:
          type: string
          enum: [npm, pip, go]
          description: Package manager to use
    exec: |
      {% if args.manager == "npm" %}
        npm outdated --json || echo "{}"
      {% elsif args.manager == "pip" %}
        pip list --outdated --format json || echo "[]"
      {% elsif args.manager == "go" %}
        go list -u -m -json all || echo "{}"
      {% else %}
        echo "{}"
      {% endif %}
    parseJson: true
    transform_js: |
      const outdated = [];
      if (args.manager === 'npm' && typeof output === 'object') {
        for (const [pkg, info] of Object.entries(output)) {
          if (info.wanted !== info.current) {
            outdated.push({
              package: pkg,
              current: info.current,
              wanted: info.wanted,
              latest: info.latest
            });
          }
        }
      }
      // Add handlers for pip and go...
      return outdated;

  # Testing tools
  run-tests:
    name: run-tests
    description: Run test suite and parse results
    inputSchema:
      type: object
      properties:
        command:
          type: string
          description: Test command to run
        format:
          type: string
          enum: [jest, pytest, go]
          description: Test output format
      required: [command]
    exec: '{{ args.command }} 2>&1'
    timeout: 300000
    transform_js: |
      // Parse test output based on format
      const lines = output.split('\n');
      let passed = 0, failed = 0, skipped = 0;

      if (args.format === 'jest') {
        const summary = lines.find(l => l.includes('Tests:'));
        if (summary) {
          const match = summary.match(/(\d+) passed/);
          if (match) passed = parseInt(match[1]);
          const failMatch = summary.match(/(\d+) failed/);
          if (failMatch) failed = parseInt(failMatch[1]);
        }
      }

      return {
        passed: passed,
        failed: failed,
        skipped: skipped,
        success: failed === 0
      };

  # Code quality tools
  eslint-check:
    name: eslint-check
    description: Run ESLint on JavaScript/TypeScript files
    inputSchema:
      type: object
      properties:
        files:
          type: array
          items:
            type: string
          description: Files to lint
    exec: 'npx eslint --format json {{ args.files | join: " " }} || echo "[]"'
    parseJson: true
    transform_js: |
      const issues = [];
      for (const file of output) {
        for (const message of file.messages || []) {
          issues.push({
            file: file.filePath,
            line: message.line || 0,
            endLine: message.endLine,
            column: message.column,
            endColumn: message.endColumn,
            message: message.message,
            severity: message.severity === 2 ? 'error' : 'warning',
            category: 'style',
            ruleId: message.ruleId || 'eslint'
          });
        }
      }
      return issues;

  prettier-check:
    name: prettier-check
    description: Check code formatting with Prettier
    inputSchema:
      type: object
      properties:
        files:
          type: array
          items:
            type: string
          description: Files to check
    exec: 'npx prettier --check {{ args.files | join: " " }} 2>&1'
    transform_js: |
      const unformatted = [];
      const lines = output.split('\n');
      for (const line of lines) {
        if (line.includes('[warn]') && line.includes('Code style issues found')) {
          const match = line.match(/in (.+?)$/);
          if (match) {
            unformatted.push({
              file: match[1],
              line: 0,
              message: 'File needs formatting',
              severity: 'warning',
              category: 'style',
              ruleId: 'prettier'
            });
          }
        }
      }
      return unformatted;