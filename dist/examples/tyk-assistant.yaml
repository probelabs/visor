version: "1.0"

# Tyk Org Assistant â€” Slack router + shared workflows
#
# High-level behaviour:
#   - Slack thread message â†’ ask (human-input)
#   - route-intent (AI) classifies into:
#       * chat              â€“ general Q&A / small talk
#       * thread_summary    â€“ summarize current Slack thread
#       * project_help      â€“ status/deploy/owner flows (from slack-simple-chat)
#       * capabilities       â€“ "what can you do?"
#       * refine             â€“ run task-refinement-v2 workflow
#       * code_help          â€“ run code-question-helper workflow
#       * customer_insights  â€“ run customer-insights workflow
#       * release_notes      â€“ generate release notes from Jira fixVersion
#   - Leaf branches post into Slack and on_success â†’ ask (loop).
#
# This file reuses:
#   - defaults/task-refinement-v2.yaml
#   - defaults/code-question-helper.yaml
#   - defaults/customer-insights.yaml
#   - patterns from examples/slack-simple-chat.yaml

workspace:
  enabled: true
  # Use default /tmp/visor-workspaces unless overridden via VISOR_WORKSPACE_PATH.
  # This keeps Slack/code-helper runs in an isolated workspace that contains
  # symlinks to each checked-out Tyk project.
  cleanup_on_exit: true

slack:
  version: "v1"
  mentions: all
  threads: required
  show_raw_output: true
  telemetry:
    enabled: true

checks:
  ask:
    type: human-input
    group: tyk-assistant
    criticality: info
    prompt: |
      Hi there! What can I help you with for Tyk?
      (This prompt is only posted when the workflow is waiting.)

  # Log user info for debugging - uses criticality: internal so it only shows in logs, not Slack
  log-request:
    type: log
    group: tyk-assistant
    criticality: internal
    depends_on: [ask]
    assume:
      - "outputs['ask'] != null"
    level: info
    include_pr_context: false
    include_dependencies: false
    include_metadata: false
    message: |
      ðŸ“¥ Request from user: {{ conversation.attributes.user | default: conversation.current.user | default: 'unknown' }}
      Channel: {{ conversation.attributes.channel | default: 'unknown' }}
      Thread: {{ conversation.thread.url | default: 'unknown' }}
      Message: {{ outputs['ask'].text | truncate: 200 }}

  # Extract Jira ticket context from the user's message and conversation history
  # Uses the jira-context workflow to fetch TT-* tickets mentioned in text or URLs
  jira-context:
    type: workflow
    group: tyk-assistant
    criticality: info
    depends_on: [ask]
    config: defaults/jira-context.yaml
    workflow_inputs:
      # Include full conversation history (Slack/GitHub thread) so we can extract tickets
      # from the entire conversation, not just the current message
      text: |
        {% if conversation.messages %}{% for m in conversation.messages %}{{ m.text }}
        {% endfor %}{% endif %}{{ outputs['ask'].text }}
      ticket_prefixes: ["TT", "DX"]
      max_issues: 3

  # Extract Zendesk ticket context from the user's message and conversation history
  # Uses the zendesk-context workflow to fetch tickets mentioned via URLs or ticket IDs
  # Also downloads attachments from tickets for analysis
  zendesk-context:
    type: workflow
    group: tyk-assistant
    criticality: info
    depends_on: [ask]
    config: defaults/zendesk-context.yaml
    workflow_inputs:
      # Include full conversation history (Slack/GitHub thread) so we can extract tickets
      # from the entire conversation, not just the current message
      text: |
        {% if conversation.messages %}{% for m in conversation.messages %}{{ m.text }}
        {% endfor %}{% endif %}{{ outputs['ask'].text }}
      download_assets: true

  # Extract Confluence page context from the user's message and conversation history
  # Uses the confluence-context workflow to fetch pages mentioned via URLs
  confluence-context:
    type: workflow
    group: tyk-assistant
    criticality: info
    depends_on: [ask]
    config: defaults/confluence-context.yaml
    workflow_inputs:
      # Include full conversation history (Slack/GitHub thread) so we can extract pages
      # from the entire conversation, not just the current message
      text: |
        {% if conversation.messages %}{% for m in conversation.messages %}{{ m.text }}
        {% endfor %}{% endif %}{{ outputs['ask'].text }}
      max_pages: 3

  route-intent:
    type: ai
    group: tyk-assistant
    depends_on: [ask, jira-context, zendesk-context, confluence-context]
    criticality: internal
    # Explicitly disable session reuse - this is a stateless classifier
    reuse_ai_session: false
    assume:
      - "outputs['ask'] != null"
    guarantee: "output?.intent != null"
    schema:
      type: object
      additionalProperties: false
      properties:
        intent:
          type: string
          enum:
            - chat
            - thread_summary
            - capabilities
            - refine
            - code_help
            - customer_insights
            - evaluate_ticket
            - engineer
            - release_notes
        topic:
          type: string
          maxLength: 240
          pattern: "^[^`\\n]*\\?$"
      required: [intent, topic]
    ai:
      skip_code_context: true
      disableTools: true
      allowedTools: []
      system_prompt: |
        You are a router for Tyk assistants.
        Your ONLY job is to classify the user's intent and rewrite their request
        as a SHORT question (1-2 sentences).
        NEVER answer the question, speculate about root causes, or mention file paths.
        Output ONLY JSON that matches the schema.
    prompt: |
      <role>
      You are an internal assistant for Tyk API Management engineers.
      Your task is to classify the user's request and determine what automation should run.
      </role>

      <slack_context_instructions>
      The full Slack thread conversation is available in the <slack_context> element inside
      the <context> block. This XML contains:
        - <messages> â€” the complete conversation history from the thread (oldest to newest)
        - <current_message> â€” the latest message that triggered this classification

      IMPORTANT: Always use <slack_context> to understand what the user is really asking:
        - Look at <messages> to understand the evolving conversation and prior context
        - The <current_message> is the PRIMARY signal for determining intent
        - If the latest message is a follow-up, correction, or refers to something discussed earlier,
          use the message history to reconstruct the full context
      </slack_context_instructions>

      {% if outputs['jira-context'].issue_count > 0 %}
      <jira_tickets_referenced>
      {{ outputs['jira-context'].jira_context_xml }}
      </jira_tickets_referenced>
      {% endif %}

      {% if outputs['zendesk-context'].ticket_count > 0 %}
      <zendesk_tickets_referenced>
      {{ outputs['zendesk-context'].zendesk_context_xml }}
      </zendesk_tickets_referenced>
      {% endif %}

      {% if outputs['confluence-context'].page_count > 0 %}
      <confluence_pages_referenced>
      {{ outputs['confluence-context'].confluence_context_xml }}
      </confluence_pages_referenced>
      {% endif %}

      <classification_instructions>
      <intent_determination>
      Determine what the user wants based on:
        - The <current_message> in <slack_context> is the PRIMARY signal for intent
        - Use <messages> history to understand context that informs the current message
        - Consider any referenced Jira/Zendesk tickets or Confluence pages shown above
      </intent_determination>

      <intent_options>
        <option value="chat">general Q&A, follow-up questions, or small talk</option>
        <option value="thread_summary">user explicitly asks for a summary of the thread</option>
        <option value="capabilities">user asks what this assistant can do</option>
        <option value="code_help">user asks how something works in code, implementation details, or documentation. This includes:
          - Code/implementation questions ("how does X work in the gateway?")
          - Documentation questions ("where is X documented?")
          - Technical architecture questions ("how is X implemented?")</option>
        <option value="customer_insights">user asks about existing customers, their usage patterns, deployment architectures, or customer-specific knowledge. This includes:
          - Customer usage questions ("how do customers use X?", "what are common deployment patterns?", "who uses feature X?")
          - Customer-specific inquiries ("what do we know about customer Y?", "which customers have this problem?")
          - Deployment patterns ("what's the typical setup for X?", "how do customers configure Y?")
          - Cross-customer analysis ("what are common issues?", "trending problems?")</option>
        <option value="evaluate_ticket">user EXPLICITLY asks to evaluate/assess quality of a Jira ticket AND provides a ticket ID (e.g., "evaluate TT-123", "assess quality of TT-456", "is TT-789 ready for refinement?")</option>
        <option value="engineer">user EXPLICITLY asks to make code changes, create a PR, implement a feature, fix a bug, or modify code (e.g., "create a PR to fix...", "implement...", "add a new endpoint...", "fix the bug in...")</option>
        <option value="release_notes">user asks to generate release notes for a specific product version. Examples:
          - "Generate release notes for 5.11.0"
          - "Create release notes for Tyk Gateway 5.8.3"
          - "Release notes for Pump 1.13.2"
          IMPORTANT: For this intent, the topic MUST be ONLY the version identifier in format like "Tyk 5.11.0" or "Tyk Pump 1.13.2" or "Tyk Charts 5.0.0" - nothing else.</option>
      </intent_options>
      </classification_instructions>

      <topic_instructions>
      Always output a short, self-contained question (1-2 sentences).
      Do NOT answer the question or speculate about root causes.
      Only include details explicitly stated in the thread or ticket context.
      </topic_instructions>
    on_success:
      transitions:
        - when: "output.intent === 'thread_summary'"
          to: summarize-thread
        - when: "output.intent === 'capabilities'"
          to: capabilities-answer
#        - when: "output.intent === 'refine'"
#          to: refine-ticket
        - when: "output.intent === 'code_help'"
          to: code-help
        - when: "output.intent === 'customer_insights'"
          to: customer-insights
        - when: "output.intent === 'evaluate_ticket'"
          to: evaluate-ticket
        - when: "output.intent === 'engineer'"
          to: engineer-topic
        - when: "output.intent === 'release_notes'"
          to: release-notes-fetch
        - when: "output.intent === 'chat'"
          to: chat-answer

  engineer-topic:
    type: ai
    group: tyk-assistant
    depends_on: [route-intent, ask, jira-context, zendesk-context]
    criticality: internal
    if: "outputs['route-intent']?.intent === 'engineer'"
    guarantee: "output?.topic != null"
    schema:
      type: object
      additionalProperties: false
      properties:
        topic:
          type: string
      required: [topic]
    ai:
      skip_code_context: true
      disableTools: true
      allowedTools: []
      system_prompt: |
        You are preparing a detailed engineering task for a coding agent.
        Your output MUST be the full spec the engineer will implement.
        Only include facts from the thread and ticket context. No speculation.
        Output ONLY JSON that matches the schema.
    prompt: |
      Build a COMPREHENSIVE task description that captures EVERYTHING needed to implement the request.
      Do NOT invent file paths, root causes, or implementation details. Only include facts explicitly
      mentioned in the thread or ticket context.

      The topic is NOT a summary â€” it is the COMPLETE SPECIFICATION that will be
      passed directly to an AI coding agent. The agent will ONLY see this topic, so it must contain:

      <requirement name="problem_description">
        - What is broken/missing and how it manifests
        - Error messages, stack traces, or symptoms discussed
        - Steps to reproduce if mentioned
        - Root cause analysis from the conversation (only if explicitly stated)
      </requirement>

      <requirement name="implementation_details">
        - Specific file paths mentioned (if any)
        - Function or method names discussed
        - The proposed solution approach from the conversation
        - Code snippets or pseudocode if shared
        - Any alternative approaches that were rejected and WHY
      </requirement>

      <requirement name="technical_context">
        - Related Jira ticket IDs with their key details
        - API contracts, data structures, or interfaces involved
        - Concurrency/threading considerations
        - Performance requirements or constraints
        - Backward compatibility requirements
      </requirement>

      <requirement name="acceptance_criteria">
        - What tests should verify (if discussed)
        - Edge cases mentioned
        - How to validate the fix works
      </requirement>

      <requirement name="conversation_nuances">
        - Decisions made during the discussion
        - Concerns raised by team members
        - Trade-offs that were discussed
      </requirement>

      <context>
        <question>{{ outputs['ask'].text }}</question>
        {% if outputs['jira-context'].issue_count > 0 %}
        <jira_tickets_referenced>
        {{ outputs['jira-context'].jira_context_xml }}
        </jira_tickets_referenced>
        {% endif %}
        {% if outputs['zendesk-context'].ticket_count > 0 %}
        <zendesk_tickets_referenced>
        {{ outputs['zendesk-context'].zendesk_context_xml }}
        </zendesk_tickets_referenced>
        {% endif %}
      </context>

  route-intent-error:
    # Reply when intent classification fails (timeout/AI error) so users
    # get feedback instead of silence.
    type: log
    group: chat
    criticality: info
    depends_on: [route-intent]
    assume:
      - "outputs['route-intent'] != null"
      - "outputs['route-intent']?.intent == null"
    if: "outputs['route-intent'] != null && outputs['route-intent']?.intent == null"
    level: info
    include_pr_context: false
    include_dependencies: false
    include_metadata: false
    message: |
      Sorry â€” I couldn't classify your request (the routing step failed or timed out).
      Please try again in a moment. If it keeps happening, check the Visor logs for AI errors/timeouts.
    on_success:
      goto: ask

  chat-answer:
    type: ai
    group: tyk-assistant
    depends_on: [route-intent]
    criticality: info
    if: "outputs['route-intent']?.intent === 'chat'"
    guarantee: "(output?.text ?? '').length > 0"
    schema:
      type: object
      properties:
        text: { type: string }
      required: [text]
    ai:
      disableTools: true
      allowedTools: []
      system_prompt: "You are general assistant, follow user instructions."
    prompt: |
      {% if outputs['jira-context'].issue_count > 0 %}
      Jira tickets mentioned in this message:
      {{ outputs['jira-context'].jira_context_xml }}
      {% endif %}

      {% if outputs['zendesk-context'].ticket_count > 0 %}
      Zendesk tickets mentioned in this message:
      {{ outputs['zendesk-context'].zendesk_context_xml }}
      {% endif %}

      {% if outputs['confluence-context'].page_count > 0 %}
      Confluence pages mentioned in this message:
      {{ outputs['confluence-context'].confluence_context_xml }}
      {% endif %}

      <history>
      {% assign history = '' | chat_history: 'ask', 'chat-answer' %}
      {% for m in history %}
      {{ m.role | capitalize }}: {{ m.text }}
      {% endfor %}
      </history>


      You are a knowledgeable, friendly Tyk assistant.

      Latest user message:
      {{ outputs['ask'].text }}

      ## Response Guidelines

      **When the user asks specifically about a Jira or Zendesk ticket** (e.g., "What's TT-123 about?", "Tell me about ticket 456", "Summarize this issue"):
      - Provide a **comprehensive summary** including:
        - Title/summary of the ticket
        - Current status and priority
        - Description (key points, not verbatim)
        - Assignee and reporter
        - Related tickets (parent/subtasks) if any
        - Recent comments or updates (summarize key discussion points)
        - Labels/components that indicate the area affected
        - For Zendesk: include requester info, any attachments available
      - Be thorough â€” don't omit important details from the ticket context provided above
      - Structure the response clearly with the ticket ID as a header

      **When the user asks about a Confluence page** (e.g., shared a Confluence link, "What does this doc say?"):
      - Summarize the key points from the page content
      - Reference the page title and any relevant sections
      - If the page is documentation, highlight the most actionable information

      **For general chat or follow-up questions:**
      - Use direct, simple language
      - Include all relevant details â€” don't omit information to be brief
      - Reference ticket context when relevant to the conversation

      If Zendesk attachments were downloaded, mention that you have access to them for analysis.
    on_success:
      goto: ask

  capabilities-answer:
    type: ai
    group: tyk-assistant
    depends_on: [route-intent]
    criticality: info
    if: "outputs['route-intent']?.intent === 'capabilities'"
    guarantee: "(output?.text ?? '').length > 0"
    schema:
      type: object
      properties:
        text: { type: string }
      required: [text]
    ai:
      disableTools: true
      allowedTools: []
      system_prompt: "You explain clearly and concisely what this Tyk assistant can do."
    prompt: |
      Explain what this assistant can help with, including:
      - Refining tickets/stories using Tyk's refinement framework.
      - Answering code-level questions across Tyk repos (gateway, dashboard, pump, MDCB, storage, docs).
      - Summarising Slack threads.
      - Answering internal how-to questions.
      Keep it to 1â€“2 paragraphs plus a short bullet list.
    on_success:
      goto: ask

  # Thread summary stub (can later use slack.conversation)
  summarize-thread:
    type: ai
    group: tyk-assistant
    depends_on: [route-intent]
    criticality: info
    if: "outputs['route-intent']?.intent === 'thread_summary'"
    guarantee: "(output?.text ?? '').length > 0"
    schema:
      type: object
      properties:
        text: { type: string }
      required: [text]
    ai:
      disableTools: true
      allowedTools: []
      system_prompt: "You summarise Slack threads for Tyk engineers."
    prompt: |
      Summarise the current Slack thread for a Tyk engineer.
      Focus on the main question, proposed solutions, and any open decisions.

      {% if outputs['jira-context'].issue_count > 0 %}
      ## Jira Tickets Referenced
      {{ outputs['jira-context'].jira_context_xml }}

      For each Jira ticket mentioned, include in your summary:
      - **Ticket ID and title**
      - **Current status** and priority
      - **Key details** from the description
      - **Recent activity** (comments, status changes)
      - **How it relates** to the thread discussion
      {% endif %}

      {% if outputs['zendesk-context'].ticket_count > 0 %}
      ## Zendesk Tickets Referenced
      {{ outputs['zendesk-context'].zendesk_context_xml }}

      For each Zendesk ticket mentioned, include in your summary:
      - **Ticket ID and subject**
      - **Current status** and requester
      - **Problem description** and key details
      - **Recent comments** or updates
      - **Any attachments** available for analysis
      - **How it relates** to the thread discussion
      {% endif %}

      {% if outputs['confluence-context'].page_count > 0 %}
      ## Confluence Pages Referenced
      {{ outputs['confluence-context'].confluence_context_xml }}

      For each Confluence page mentioned, include in your summary:
      - **Page title** and space
      - **Key content** highlights
      - **How it relates** to the thread discussion
      {% endif %}

      Structure your summary with clear sections for:
      1. **Thread Overview** - Main topic and question
      2. **Ticket Context** - Details from referenced tickets (if any)
      3. **Documentation Context** - Details from referenced Confluence pages (if any)
      4. **Discussion Points** - Key points raised
      5. **Open Items** - Unresolved questions or next steps
    on_success:
      goto: ask

  refine-ticket:
    type: workflow
    group: tyk-assistant
    criticality: internal
    depends_on: [route-intent]
    if: "outputs['route-intent']?.intent === 'refine'"
    # Use the reusable task-refinement-v2 workflow from defaults
    config: defaults/task-refinement-v2.yaml
    workflow_inputs:
      # Use the latest Slack message as the seed ticket text
      question: "{{ outputs['ask'].text }}"
    on_success:
      goto: ask

  code-help:
    type: workflow
    group: tyk-assistant
    criticality: internal
    depends_on: [route-intent]
    if: "outputs['route-intent']?.intent === 'code_help'"
    # Reusable workflow that plans code/doc projects and synthesises an answer.
    # Path is resolved relative to the repository working directory.
    config: defaults/code-question-helper.yaml
    workflow_inputs:
      question: |
        {{ outputs['route-intent'].topic | default: outputs['ask'].text }}

        {% if outputs['jira-context']?.jira_context_xml %}
        Jira context:
        {{ outputs['jira-context'].jira_context_xml }}
        {% endif %}

        {% if outputs['confluence-context']?.confluence_context_xml %}
        Confluence context:
        {{ outputs['confluence-context'].confluence_context_xml }}
        {% endif %}

        {% if outputs['zendesk-context']?.zendesk_context_xml %}
        Zendesk context:
        {{ outputs['zendesk-context'].zendesk_context_xml }}
        {% endif %}
    # If the nested workflow failed to produce an answer, treat it as a
    # failure and route to a small error-notification step so Slack users
    # see a clear message instead of silence.
    fail_if: "output?.answer == null"
    on_fail:
      goto: code-help-error

  code-help-reply:
    # Bridge from the reusable workflow output into Slack: this log check
    # uses group=chat so the Slack frontend will post the answer text into
    # the originating thread.
    type: log
    group: chat
    criticality: info
    depends_on: [code-help]
    if: "outputs['code-help']?.answer?.text"
    level: info
    include_pr_context: false
    include_dependencies: false
    include_metadata: false
    message: "{{ outputs['code-help'].answer.text }}"
    on_success:
      goto: ask

  code-help-error:
    # Non-AI chat message to inform the user that code-help could not
    # produce a plan/answer. Slack frontend will post this log output
    # into the thread.
    type: log
    group: tyk-assistant
    criticality: info
    # No hard dependency on code-help to avoid re-running it when we
    # jump here via goto; we still read its outputs from history.
    depends_on: []
    assume:
      - "outputs['route-intent']?.intent === 'code_help'"
      - "outputs['code-help']?.answer == null"
    if: "outputs['code-help']?.answer == null"
    level: info
    include_pr_context: false
    include_dependencies: false
    include_metadata: false
    message: |
      I tried to analyze that code question but either couldn't build a clear code plan from the context,
      or hit an internal error while doing so.

      Please rephrase your question or narrow it down (for example, mention the specific repo,
      component, or behaviour you care about). If this keeps happening, someone on the team should
      check the Visor logs for details.
    on_success:
      goto: ask

  # Customer Insights workflow - handles questions about existing customers
  customer-insights:
    type: workflow
    group: tyk-assistant
    criticality: internal
    depends_on: [route-intent]
    if: "outputs['route-intent']?.intent === 'customer_insights'"
    # Reusable workflow that queries the customer insights knowledge base.
    config: defaults/customer-insights.yaml
    workflow_inputs:
      question: "{{ outputs['ask'].text }}"
    fail_if: "output?.answer == null"
    on_fail:
      goto: customer-insights-error

  customer-insights-reply:
    type: log
    group: chat
    criticality: info
    depends_on: [customer-insights]
    if: "outputs['customer-insights']?.answer?.text"
    level: info
    include_pr_context: false
    include_dependencies: false
    include_metadata: false
    message: "{{ outputs['customer-insights'].answer.text }}"
    on_success:
      goto: ask

  customer-insights-error:
    type: log
    group: tyk-assistant
    criticality: info
    depends_on: []
    assume:
      - "outputs['route-intent']?.intent === 'customer_insights'"
      - "outputs['customer-insights']?.answer == null"
    if: "outputs['customer-insights']?.answer == null"
    level: info
    include_pr_context: false
    include_dependencies: false
    include_metadata: false
    message: |
      I tried to search the customer insights knowledge base but couldn't find relevant information
      or hit an internal error while doing so.

      Please rephrase your question or be more specific about which customer or pattern you're
      interested in. If this keeps happening, someone on the team should check the Visor logs.
    on_success:
      goto: ask

  # Release Notes Generation flow
  # Step 1: Fetch Jira issues using JQL based on the version
  release-notes-fetch:
    type: workflow
    group: tyk-assistant
    criticality: internal
    depends_on: [route-intent]
    if: "outputs['route-intent']?.intent === 'release_notes'"
    config: defaults/jira-context.yaml
    workflow_inputs:
      # The topic is the version identifier like "Tyk 5.11.0" or "Tyk Pump 1.13.2"
      jql: 'fixVersion = "{{ outputs["route-intent"].topic }}"'
      max_issues: 100
    fail_if: "output?.issue_count === 0"
    on_fail:
      goto: release-notes-error

  # Step 2: Generate release notes from the Jira issues
  release-notes-generate:
    type: ai
    group: tyk-assistant
    criticality: internal
    depends_on: [release-notes-fetch]
    if: "outputs['release-notes-fetch']?.issue_count > 0"
    assume:
      - "outputs['release-notes-fetch']?.issue_count > 0"
    ai:
      skip_code_context: true
      disableTools: true
    schema:
      type: object
      properties:
        release_notes:
          type: string
          description: The generated release notes in markdown format
      required: [release_notes]
    prompt: |
      <role>
      You are a technical writer creating release notes for Tyk products.
      Your task is to transform Jira ticket information into user-focused release notes.
      </role>

      <version>{{ outputs['route-intent'].topic }}</version>

      <jira_issues>
      {{ outputs['release-notes-fetch'].jira_context_xml }}
      </jira_issues>

      <instructions>
      Generate release notes for the {{ outputs['route-intent'].topic }} release.

      ## Input Processing
      - Read the title and description from each Jira ticket
      - DO NOT read or use any "Release Notes" section inside the tickets
      - Never invent data not present in the tickets
      - Use neutral, concise language

      ## Grouping Rules
      Group issues in this order:
      1. **By Component** (Gateway, Dashboard, Pump, Charts, Portal, etc.)
      2. **Within each component, by Change Type:**
         - **Added** - New features and capabilities
         - **Changed** - Modifications to existing functionality
         - **Fixed** - Bug fixes and issue resolutions

      ## Format for Each Issue
      For every issue, produce:

      **Title:** A rewritten short title (one sentence) explaining the change from user perspective

      **Summary:** A user-focused description explaining the impact or effect, NOT implementation details.

      ## Output Format Example
      ```markdown
      # Release Notes for [Version]

      ## Gateway

      ### Added
      **Title:** Enhanced external service integration with proxy and mTLS support
      **Summary:** Added a new `external_services` section in the Gateway configuration...

      ### Changed
      **Title:** Go 1.24 Upgrade for Tyk Gateway
      **Summary:** The Tyk Gateway has been updated to Golang 1.24, improving security...

      ### Fixed
      **Title:** Fixed panic when an unexpected query parameter is provided
      **Summary:** Fixed an issue where sending certain unexpected query parameters...

      ## Dashboard

      ### Added
      ...
      ```

      ## Important Guidelines
      - Focus on USER IMPACT, not technical implementation
      - Be concise but informative
      - Group related changes together
      - If a ticket has both Gateway and Dashboard components, list it under both sections
      - Skip any tickets that are internal-only or have no user-facing impact
      </instructions>
    fail_if: "!output?.release_notes"
    on_fail:
      goto: release-notes-error

  release-notes-reply:
    type: log
    group: chat
    criticality: info
    depends_on: [release-notes-generate]
    if: "outputs['release-notes-generate']?.release_notes"
    level: info
    include_pr_context: false
    include_dependencies: false
    include_metadata: false
    message: "{{ outputs['release-notes-generate'].release_notes }}"
    on_success:
      goto: ask

  release-notes-error:
    type: log
    group: chat
    criticality: info
    depends_on: [route-intent, release-notes-fetch, release-notes-generate]
    if: >
      outputs['route-intent'] && outputs['route-intent'].intent === 'release_notes' &&
      (
        !outputs['release-notes-fetch'] ||
        outputs['release-notes-fetch'].issue_count === 0 ||
        !outputs['release-notes-generate'] ||
        outputs['release-notes-generate'].release_notes == null
      )
    level: info
    include_pr_context: false
    include_dependencies: false
    include_metadata: false
    message: |
      I couldn't generate release notes for "{{ outputs['route-intent'].topic }}".

      This could be because:
      - No issues were found with fixVersion = "{{ outputs['route-intent'].topic }}"
      - The version format might be incorrect (expected format: "Tyk 5.11.0", "Tyk Pump 1.13.2", "Tyk Charts 5.0.0")

      Please check the version identifier and try again. You can verify available versions at:
      https://tyktech.atlassian.net/projects/TT?selectedItem=com.atlassian.jira.jira-projects-plugin%3Arelease-page
    on_success:
      goto: ask

  # Evaluate Jira ticket quality using 3-amigos refinement workflow
  # Triggered when user explicitly asks to evaluate a specific Jira ticket
  evaluate-ticket:
    type: workflow
    group: tyk-assistant
    criticality: internal
    depends_on: [route-intent, ask, jira-context, zendesk-context]
    if: "outputs['route-intent']?.intent === 'evaluate_ticket' && outputs['jira-context']?.issue_count > 0"
    config: defaults/refinement.yaml
    workflow_inputs:
      context: |
        User request: {{ outputs['ask'].text }}

        Jira Context:
        {{ outputs['jira-context'].jira_context_xml }}

        {% if outputs['zendesk-context'].ticket_count > 0 %}
        Zendesk Context:
        {{ outputs['zendesk-context'].zendesk_context_xml }}
        {% endif %}

  evaluate-ticket-reply:
    type: log
    group: chat
    criticality: info
    depends_on: [evaluate-ticket]
    if: "outputs['evaluate-ticket']?.issues?.length > 0"
    level: info
    include_pr_context: false
    include_dependencies: false
    include_metadata: false
    message: |
      ## Ticket Evaluation: {{ outputs['jira-context'].issues[0].key }}

      {% if outputs['evaluate-ticket'].hasBlockers %}
      **Status: NOT READY** - There are blockers that must be addressed before implementation.
      {% else %}
      **Status: READY** - No blocking issues found.
      {% endif %}

      ### Issues Found ({{ outputs['evaluate-ticket'].issues | size }})

      {% for issue in outputs['evaluate-ticket'].issues %}
      - **[{{ issue.severity | upcase }}]** `{{ issue.ruleId }}`: {{ issue.message }}{% if issue.suggestion %}
        - *Suggestion*: {{ issue.suggestion }}{% endif %}
      {% endfor %}
    on_success:
      goto: ask

  evaluate-ticket-no-jira:
    type: log
    group: chat
    criticality: info
    depends_on: [route-intent]
    if: "outputs['route-intent']?.intent === 'evaluate_ticket' && outputs['jira-context']?.issue_count == 0"
    level: info
    include_pr_context: false
    include_dependencies: false
    include_metadata: false
    message: |
      I couldn't find a Jira ticket to evaluate. Please provide a valid Jira ticket ID (e.g., TT-123) in your message.

      Example: "Evaluate quality of TT-456" or "Is TT-789 ready for implementation?"
    on_success:
      goto: ask

  # Engineer workflow: Uses Claude Code to implement code changes, create PRs, fix bugs, etc.
  # Triggered when user explicitly asks to make code changes.
  engineer-task:
    type: workflow
    group: tyk-assistant
    criticality: internal
    depends_on: [route-intent, engineer-topic, ask, jira-context, zendesk-context]
    if: "outputs['route-intent']?.intent === 'engineer'"
    config: defaults/engineer.yaml
    workflow_inputs:
      task: |
        {{ outputs['engineer-topic'].topic | default: outputs['route-intent'].topic }}

        {% if outputs['jira-context'].issue_count > 0 %}
        Related Jira Tickets:
        {{ outputs['jira-context'].jira_context_xml }}
        {% endif %}

        {% if outputs['zendesk-context'].ticket_count > 0 %}
        Related Zendesk Tickets:
        {{ outputs['zendesk-context'].zendesk_context_xml }}
        {% endif %}
    on_success:
      goto: engineer-task-reply
    on_fail:
      goto: engineer-task-error

  engineer-task-reply:
    type: log
    group: chat
    criticality: info
    depends_on: [engineer-task]
    if: "outputs['engineer-task']?.result?.text"
    level: info
    include_pr_context: false
    include_dependencies: false
    include_metadata: false
    message: "{{ outputs['engineer-task'].result.text }}"
    on_success:
      goto: ask

  engineer-task-error:
    type: log
    group: tyk-assistant
    criticality: info
    depends_on: [engineer-task]
    if: "outputs['route-intent']?.intent === 'engineer' && outputs['engineer-task']?.result?.text == null"
    level: info
    include_pr_context: false
    include_dependencies: false
    include_metadata: false
    message: |
      I encountered an issue while trying to implement the requested changes.

      Please try rephrasing your request with more specific details about:
      - Which repository/component needs changes
      - What specific behavior you want to implement or fix
      - Any relevant file paths or function names

      If this keeps happening, please check the Visor logs for more details.
    on_success:
      goto: ask

tests:
  defaults:
    strict: true
    ai_provider: mock

  cases:
    - name: code-help-error-path
      description: When code-help returns no answer, route to code-help-error.
      flow:
        - name: code-help-error
          event: manual
          fixture: local.minimal
          routing:
            max_loops: 2
          mocks:
            ask[]:
              - text: "Explain how JWT validation works in Tyk."
            jira-context[]:
              - issue_count: 0
                jira_context_xml: "<jira_context><issue_count>0</issue_count></jira_context>"
            zendesk-context[]:
              - ticket_count: 0
                zendesk_context_xml: "<zendesk_context><ticket_count>0</ticket_count></zendesk_context>"
            route-intent[]:
              - { intent: code_help, topic: "How does JWT validation work in Tyk?" }
            code-help[]:
              - answer: null
          expect:
            calls:
              - step: ask
                exactly: 1
              - step: jira-context
                exactly: 1
              - step: zendesk-context
                exactly: 1
              - step: confluence-context
                exactly: 1
              - step: route-intent
                exactly: 1
              - step: code-help
                exactly: 1
              - step: code-help-error
                exactly: 1
              - step: code-help-reply
                exactly: 0
            strict_violation:
              for_step: code-help
              message_contains: "failed run(s) in strict mode"

    - name: route-to-refine
      description: Route to refinement workflow when intent=refine.
      flow:
        - name: refine
          event: manual
          fixture: local.minimal
          routing:
            max_loops: 0
          mocks:
            ask[]:
              - text: "Can you help refine a ticket about org-wide rate limiting?"
            jira-context[]:
              - issue_count: 0
                jira_context_xml: "<jira_context><issue_count>0</issue_count></jira_context>"
            zendesk-context[]:
              - ticket_count: 0
                zendesk_context_xml: "<zendesk_context><ticket_count>0</ticket_count></zendesk_context>"
            route-intent[]:
              - { intent: refine, topic: "Can you help refine a ticket about org-wide rate limiting?" }
            refine-ticket[]:
              - refinement:
                  context:
                    problem_statement: "Operators lack unified control over org-wide rate limits."
          expect:
            calls:
              - step: ask
                exactly: 1
              - step: jira-context
                exactly: 1
              - step: zendesk-context
                exactly: 1
              - step: confluence-context
                exactly: 1
              - step: route-intent
                exactly: 1
              - step: refine-ticket
                exactly: 1

    - name: route-to-code-help
      description: Route to code-question helper when intent=code_help.
      flow:
        - name: code-help-flow
          event: manual
          fixture: local.minimal
          routing:
            max_loops: 0
          mocks:
            ask[]:
              - text: "How is org-wide rate limiting implemented and documented?"
            jira-context[]:
              - issue_count: 0
                jira_context_xml: "<jira_context><issue_count>0</issue_count></jira_context>"
            zendesk-context[]:
              - ticket_count: 0
                zendesk_context_xml: "<zendesk_context><ticket_count>0</ticket_count></zendesk_context>"
            route-intent[]:
              - { intent: code_help, topic: "How is org-wide rate limiting implemented and documented?" }
            code-help[]:
              - answer:
                  text: "Org-wide rate limiting is implemented in the gateway and described in tyk-docs."
          expect:
            calls:
              - step: ask
                exactly: 1
              - step: jira-context
                exactly: 1
              - step: zendesk-context
                exactly: 1
              - step: confluence-context
                exactly: 1
              - step: route-intent
                exactly: 1
              - step: code-help
                exactly: 1

    - name: route-intent-env-prompt-type
      description: Route intent should still work when VISOR_PROMPT_TYPE is set in the environment.
      env:
        VISOR_PROMPT_TYPE: code-explorer
      flow:
        - name: route-intent-env
          event: manual
          fixture: local.minimal
          routing:
            max_loops: 0
          mocks:
            ask[]:
              - text: "How does JWT validation work in Tyk?"
            jira-context[]:
              - issue_count: 0
                jira_context_xml: "<jira_context><issue_count>0</issue_count></jira_context>"
            zendesk-context[]:
              - ticket_count: 0
                zendesk_context_xml: "<zendesk_context><ticket_count>0</ticket_count></zendesk_context>"
            route-intent[]:
              - { intent: code_help, topic: "How does JWT validation work in Tyk?" }
            code-help[]:
              - answer:
                  text: "JWT validation is implemented in the gateway and documented in tyk-docs."
          expect:
            calls:
              - step: ask
                exactly: 1
              - step: jira-context
                exactly: 1
              - step: zendesk-context
                exactly: 1
              - step: confluence-context
                exactly: 1
              - step: route-intent
                exactly: 1
              - step: code-help
                exactly: 1
              - step: route-intent-error
                exactly: 0

    - name: code-help-error-path-strict
      description: When code-help returns no answer, route to code-help-error (strict mode).
      strict: true
      flow:
        - name: code-help-error
          event: manual
          fixture: local.minimal
          routing:
            max_loops: 2
          mocks:
            ask[]:
              - text: "Explain how JWT validation works in Tyk."
            jira-context[]:
              - issue_count: 0
                jira_context_xml: "<jira_context><issue_count>0</issue_count></jira_context>"
            zendesk-context[]:
              - ticket_count: 0
                zendesk_context_xml: "<zendesk_context><ticket_count>0</ticket_count></zendesk_context>"
            route-intent[]:
              - { intent: code_help, topic: "How does JWT validation work in Tyk?" }
            code-help[]:
              - answer: null
          expect:
            calls:
              - step: ask
                exactly: 1
              - step: jira-context
                exactly: 1
              - step: zendesk-context
                exactly: 1
              - step: confluence-context
                exactly: 1
              - step: route-intent
                exactly: 1
              - step: code-help
                exactly: 1
              - step: code-help-error
                exactly: 1

    - name: transitive-outputs-access
      description: Verify that chat-answer can access jira-context outputs even without direct dependency.
      flow:
        - name: transitive-test
          event: manual
          fixture: local.minimal
          routing:
            max_loops: 0
          mocks:
            ask[]:
              - text: "What's the status of TT-102?"
            jira-context[]:
              - issue_count: 1
                jira_context_xml: |
                  <jira_context>
                    <issue_count>1</issue_count>
                    <issue key="TT-102">
                      <summary>Test ticket for transitive outputs</summary>
                      <status>Open</status>
                    </issue>
                  </jira_context>
            zendesk-context[]:
              - ticket_count: 0
                zendesk_context_xml: "<zendesk_context><ticket_count>0</ticket_count></zendesk_context>"
            route-intent[]:
              - { intent: chat, topic: "What is the status of TT-102?" }
            chat-answer[]:
              - text: "TT-102 is currently Open."
          expect:
            calls:
              - step: ask
                exactly: 1
              - step: jira-context
                exactly: 1
              - step: zendesk-context
                exactly: 1
              - step: confluence-context
                exactly: 1
              - step: route-intent
                exactly: 1
              - step: chat-answer
                exactly: 1
            # Verify the AI prompt for chat-answer contains jira context
            prompts:
              - step: chat-answer
                contains: ["jira_context"]

    - name: evaluate-ticket-with-jira
      description: Evaluate Jira ticket quality when user explicitly asks.
      flow:
        - name: evaluate-ticket-flow
          event: manual
          fixture: local.minimal
          routing:
            max_loops: 0
          mocks:
            ask[]:
              - text: "Evaluate quality of TT-1234"
            jira-context[]:
              - output:
                  issue_count: 1
                  issues:
                    - key: "TT-1234"
                      summary: "Add rate limiting dashboard"
                      description: "We need a dashboard for rate limiting"
                      status: "Open"
                      priority: "High"
                      labels: ["feature", "dashboard"]
                      components: ["dashboard"]
                  jira_context_xml: |
                    <jira_context>
                      <issue_count>1</issue_count>
                      <issue key="TT-1234">
                        <summary>Add rate limiting dashboard</summary>
                        <description>We need a dashboard for rate limiting</description>
                        <status>Open</status>
                        <priority>High</priority>
                      </issue>
                    </jira_context>
            zendesk-context[]:
              - output:
                  ticket_count: 0
                  zendesk_context_xml: "<zendesk_context><ticket_count>0</ticket_count></zendesk_context>"
            route-intent[]:
              - { intent: evaluate_ticket, topic: "Can you evaluate TT-1234?" }
            evaluate-ticket[]:
              - output:
                  issues:
                    - ruleId: "pm/unclear-scope"
                      message: "Scope needs clarification"
                      severity: "warning"
                    - ruleId: "qa/missing-criteria"
                      message: "No acceptance criteria defined"
                      severity: "error"
                  hasBlockers: true
          expect:
            calls:
              - step: ask
                exactly: 1
              - step: jira-context
                exactly: 1
              - step: zendesk-context
                exactly: 1
              - step: confluence-context
                exactly: 1
              - step: route-intent
                exactly: 1
              - step: evaluate-ticket
                exactly: 1
              - step: evaluate-ticket-reply
                exactly: 1
            # CRITICAL: Assert that the Jira context is actually passed to evaluate-ticket
            # This prevents regressions where depends_on is missing or template rendering fails
            prompts:
              - step: evaluate-ticket
                contains: ["jira_context", "TT-1234", "Add rate limiting dashboard"]

    - name: evaluate-ticket-no-jira-found
      description: Show error when user asks to evaluate but no Jira ticket found.
      flow:
        - name: no-jira-flow
          event: manual
          fixture: local.minimal
          routing:
            max_loops: 0
          mocks:
            ask[]:
              - text: "Evaluate the ticket quality"
            jira-context[]:
              - output:
                  issue_count: 0
                  jira_context_xml: "<jira_context><issue_count>0</issue_count></jira_context>"
            zendesk-context[]:
              - output:
                  ticket_count: 0
                  zendesk_context_xml: "<zendesk_context><ticket_count>0</ticket_count></zendesk_context>"
            route-intent[]:
              - { intent: evaluate_ticket, topic: "Can you evaluate the ticket quality?" }
          expect:
            calls:
              - step: ask
                exactly: 1
              - step: jira-context
                exactly: 1
              - step: zendesk-context
                exactly: 1
              - step: confluence-context
                exactly: 1
              - step: route-intent
                exactly: 1
              - step: evaluate-ticket
                exactly: 0
              - step: evaluate-ticket-no-jira
                exactly: 1

    - name: chat-with-jira-context
      description: Chat message mentioning a Jira ticket gets context from jira-context workflow.
      flow:
        - name: chat-with-jira
          event: manual
          fixture: local.minimal
          routing:
            max_loops: 0
          mocks:
            ask[]:
              - text: "What's the status of TT-9234?"
            jira-context[]:
              - issue_count: 1
                jira_context_xml: |
                  <jira_context>
                    <issue_count>1</issue_count>
                    <issue key="TT-9234">
                      <summary>Graceful shutdown of Gateway</summary>
                      <status>Closed</status>
                      <priority>Medium</priority>
                    </issue>
                  </jira_context>
            zendesk-context[]:
              - ticket_count: 0
                zendesk_context_xml: "<zendesk_context><ticket_count>0</ticket_count></zendesk_context>"
            route-intent[]:
              - { intent: chat, topic: "What is the status of TT-9234?" }
            chat-answer[]:
              - text: "TT-9234 (Graceful shutdown of Gateway) is currently Closed."
          expect:
            calls:
              - step: ask
                exactly: 1
              - step: jira-context
                exactly: 1
              - step: zendesk-context
                exactly: 1
              - step: confluence-context
                exactly: 1
              - step: route-intent
                exactly: 1
              - step: chat-answer
                exactly: 1

    - name: route-to-engineer
      description: Route to engineer workflow when user asks to make code changes.
      flow:
        - name: engineer-flow
          event: manual
          fixture: local.minimal
          routing:
            max_loops: 0
          mocks:
            ask[]:
              - text: "Create a PR to add a health check endpoint to the gateway"
            jira-context[]:
              - issue_count: 0
                jira_context_xml: "<jira_context><issue_count>0</issue_count></jira_context>"
            zendesk-context[]:
              - ticket_count: 0
                zendesk_context_xml: "<zendesk_context><ticket_count>0</ticket_count></zendesk_context>"
            route-intent[]:
              - { intent: engineer, topic: "Can you create a PR to add a /health endpoint to the gateway?" }
            engineer-topic[]:
              - topic: "Add a /health endpoint to the Tyk Gateway that returns HTTP 200 OK when the gateway is ready to accept traffic. The endpoint should be accessible without authentication and should verify basic gateway initialization is complete."
            engineer-task[]:
              - result:
                  text: "Added /health endpoint to gateway API. Files changed: gateway/api.go, gateway/api_test.go"
          expect:
            calls:
              - step: ask
                exactly: 1
              - step: jira-context
                exactly: 1
              - step: zendesk-context
                exactly: 1
              - step: confluence-context
                exactly: 1
              - step: route-intent
                exactly: 1
              - step: engineer-topic
                exactly: 1
              - step: engineer-task
                exactly: 1
              - step: engineer-task-reply
                exactly: 1

    - name: engineer-task-error-flow
      description: Test error handling when engineer-task returns null result.
      flow:
        - name: engineer-error
          event: manual
          fixture: local.minimal
          routing:
            max_loops: 2
          mocks:
            ask[]:
              - text: "Create a PR to fix the bug"
            jira-context[]:
              - issue_count: 0
                jira_context_xml: "<jira_context><issue_count>0</issue_count></jira_context>"
            zendesk-context[]:
              - ticket_count: 0
                zendesk_context_xml: "<zendesk_context><ticket_count>0</ticket_count></zendesk_context>"
            route-intent[]:
              - { intent: engineer, topic: "Can you create a PR to fix the bug in the gateway?" }
            engineer-topic[]:
              - topic: "Fix the bug in the gateway. Provide the root cause if explicitly stated, note any reproduction steps, and list the files to change."
            # Mock engineer-task returning null result to trigger error path
            engineer-task[]:
              - result: null
          expect:
            calls:
              - step: ask
                exactly: 1
              - step: jira-context
                exactly: 1
              - step: zendesk-context
                exactly: 1
              - step: confluence-context
                exactly: 1
              - step: route-intent
                exactly: 1
              - step: engineer-topic
                exactly: 1
              - step: engineer-task
                exactly: 1
              - step: engineer-task-reply
                exactly: 0
              - step: engineer-task-error
                exactly: 1
