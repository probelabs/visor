version: "1.0"

# Reusable workflow: code-question-helper
#
# Goal:
#   Answer detailed questions about Tyk code and docs, using:
#   - a project planner step (`ensure-code-plan`) to pick relevant Tyk projects (by id)
#   - per-project exploration (via git checkouts + delegate tools) to actually read code/docs
#
# Input contract (when used as a workflow step):
#   - inputs.question: string   (required)
#
# Output contract:
#   - answer:
#       text: string
#       per_project:
#         - project_id: string
#           summary: string
#           details: string

inputs:
  - name: question
    required: true
    schema:
      type: string

outputs:
  - name: answer
    value_js: |
      // Preferred path: use the answer from the project-code-query step.
      // In workflow value_js, `outputs[stepId]` is the latest visible output
      // for that step (i.e., ReviewSummary.output for AI steps).
      // Note: Use explicit null checks - sandbox && doesn't short-circuit properly.
      // Use separate if statements to avoid any short-circuit issues.
      var codeStep = null;
      if (outputs != null && typeof outputs === 'object') {
        codeStep = outputs['project-code-query'];
      }
      if (codeStep != null && typeof codeStep === 'object') {
        // Normal case: schema output already shaped as { answer: { … } }.
        if (codeStep.answer !== undefined) return codeStep.answer;
        // Fallback: some providers may still nest under .output.answer.
        var csOutput = codeStep.output;
        if (csOutput != null && typeof csOutput === 'object' && csOutput.answer !== undefined) {
          return csOutput.answer;
        }
      }

      // If there is no answer (e.g. routing failed early or the workflow
      // exited before project-code-query ran), expose no answer instead
      // of throwing so callers can handle the absence gracefully.
      return null;

  - name: code_plan
    value_js: |
      // Build a generic code_plan object directly from ensure-code-plan
      // outputs so other workflows (e.g., task-refinement-v2) can reuse the
      // same project routing logic. This step is intentionally tolerant:
      // if the planner did not run or failed, return an empty plan instead
      // of throwing.
      // Note: Use explicit null checks - sandbox && doesn't short-circuit properly.
      // Use separate if statements to avoid any short-circuit issues.
      var planStep = null;
      if (outputs != null && typeof outputs === 'object') {
        planStep = outputs['ensure-code-plan'];
      }
      var src = [];
      if (planStep != null && typeof planStep === 'object') {
        if (Array.isArray(planStep.projects)) {
          src = planStep.projects;
        }
      }

      // Map canonical project IDs from ensure-code-plan to concrete repos.
      // These keys must stay in sync with the enum in ensure-code-plan.
      const projectMap = {
        'tyk': {
          repo: 'TykTechnologies/tyk',
        },
        'tyk-analytics': {
          repo: 'TykTechnologies/tyk-analytics',
        },
        'tyk-analytics-ui': {
          repo: 'TykTechnologies/tyk-analytics-ui',
        },
        'tyk-pump': {
          repo: 'TykTechnologies/tyk-pump',
        },
        'tyk-sink': {
          repo: 'TykTechnologies/tyk-sink',
        },
        'storage': {
          repo: 'TykTechnologies/storage',
        },
        'tyk-docs': {
          repo: 'TykTechnologies/tyk-docs',
        },
        'portal': {
          repo: 'TykTechnologies/portal',
        },
      };

      const projects = [];
      if (Array.isArray(src)) {
        for (const p of src) {
          if (!p || typeof p !== 'object') continue;
          if (typeof p.project_id !== 'string' || !p.project_id) continue;
          const info = projectMap[p.project_id];
          if (info == null || typeof info !== 'object') continue;
          const repo = info.repo;
          if (typeof repo !== 'string' || !repo) continue;
          projects.push({
            id: p.project_id,
            repo: repo,
            ref: 'main',
          });
        }
      }

      return { projects };

steps:
  checkout-tyk-docs:
    type: git-checkout
    criticality: internal
    assume:
      - "true"
    # Always keep a fresh view of the docs; tests mock this provider.
    ref: "main"
    repository: "TykTechnologies/tyk-docs"
    fetch_depth: 1
    description: "Tyk Docs"

  # Plan which Tyk projects are relevant for the current question. This
  # step returns a lightweight list of project IDs (and optional roles),
  # without performing any code checkout itself.
  ensure-code-plan:
    type: ai
    criticality: info
    depends_on: [checkout-tyk-docs]
    # Design-by-contract: this step must always return at least one planned
    # project entry. If the model ever returns an empty list, treat it as a
    # failure so callers can see a clear issue instead of silently skipping
    # downstream steps.
    guarantee: "(output?.projects?.length ?? 0) > 0"
    fail_if: "(output?.projects?.length ?? 0) === 0"
    ai:
      skip_code_context: true
      # Use general prompt type (not code-explorer) because at this planning
      # stage only tyk-docs is checked out. The planner should decide which
      # projects to checkout based on the question context, not by exploring
      # code that isn't available yet. Code exploration happens later in
      # project-code-query after the relevant projects are checked out.
      prompt_type: general
      system_prompt: |
        You decide which parts of the Tyk stack are relevant for answering a question.
        Your job is to plan *which projects must be consulted*, not to answer the
        question directly.

        Slack context and question reconstruction
        - You have full Slack thread context in the <slack_context> element inside
          <context>. Always use it to understand what the user is really asking.
        - If the latest message is a correction or meta-comment (for example,
          "wrong intent it was code search question"), look back at earlier user
          messages to reconstruct the true question before planning projects.
        - The question may include appended ticket/page context; use it to
          capture issue-specific details that can impact which codebases
          are relevant.

        Inferring impacted projects from the question
        - Use your knowledge of Tyk architecture and the question context to
          determine which code projects are relevant.
        - Consider what components (gateway, dashboard, MDCB, portal, storage)
          would be involved in the behaviour or configuration the user cares about.
        - Do NOT add "tyk-docs" itself to the projects list; docs are used for
          context but are not a code project to plan.

        Known project IDs (use these exact strings in the output):
        - "tyk"              – Tyk Gateway
        - "tyk-analytics"    – Dashboard backend
        - "tyk-analytics-ui" – Dashboard UI
        - "tyk-pump"         – Analytics pipeline
        - "tyk-sink"         – MDCB
        - "storage"          – Shared storage library
        - "portal"           – Enterprise developer portal (the modern portal)

        Routing heuristics and coverage
        - Gateway-centric features (auth, JWT, HMAC, rate limiting, middleware):
          - The Gateway code lives in "tyk", but almost all customer-facing
            features are configured and surfaced through the Dashboard.
          - For general questions like "how does X work?" or "how do I configure X?",
            you should *usually* plan both "tyk" (Gateway) and "tyk-analytics"
            (Dashboard backend), and include "tyk-analytics-ui" when the question
            clearly involves UI flows or screenshots.
          - Only plan "tyk" alone when the docs clearly describe the feature as
            an internal, gateway-only concern with no Dashboard involvement.
        - Portal:
          - Tyk has two portal experiences: the Classic Portal and the Enterprise
            Developer Portal.
          - The "portal" project id refers to the Enterprise Developer Portal codebase.
          - If the user says "portal" without qualification, assume they mean the
            Enterprise Developer Portal and plan the "portal" project.
          - Only treat it as Classic Portal when the question explicitly says
            "Classic Portal" or clearly references the classic experience; in that
            case, rely on tyk-docs + gateway/dashboard projects, but do NOT add
            the "portal" project id unless Enterprise Developer Portal is actually
            in scope.
        - Cross-stack flows (for example: gateway + dashboard + MDCB, or
          gateway + portal) should include *all* clearly affected projects.
        - It is better to include a small superset of relevant projects than to
          miss an obviously-related one. Typical plans contain 1–3 projects,
          but you may include more when the docs make that necessary.
    schema:
      type: object
      additionalProperties: false
      properties:
        projects:
          type: array
          description: >
            Planned project queries. Each entry identifies a Tyk project and
            a focused sub-question for that project.
          items:
            type: object
            additionalProperties: false
            properties:
              project_id:
                type: string
                description: >
                  One of the known Tyk project IDs:
                  "tyk", "tyk-analytics", "tyk-analytics-ui",
                  "tyk-pump", "tyk-sink", "storage", "portal".
                enum:
                  - "tyk"
                  - "tyk-analytics"
                  - "tyk-analytics-ui"
                  - "tyk-pump"
                  - "tyk-sink"
                  - "storage"
                  - "portal"
              reason:
                type: string
                description: >
                  Short explanation of why this project is relevant to the question
                  (for example, which docs or concepts indicate it is involved).
            required: [project_id]
        notes:
          type: string
          description: Optional planner notes.
      required: [projects]
    prompt: |
      Question:
      {{ inputs.question }}

      Tyk docs checkout (always available for this decision step):
      - repo: {{ outputs['checkout-tyk-docs'].repository | default: 'unknown' }}
      - ref:  {{ outputs['checkout-tyk-docs'].ref | default: 'main' }}
      - path: {{ outputs['checkout-tyk-docs'].path | default: '(not available)' }}

      The full Slack conversation (thread) is available in <slack_context> inside
      the <context> block. If this latest message is a correction or follow-up,
      use the earlier user messages in <slack_context> to recover the real
      question before choosing projects.

      Before proposing a plan, skim the relevant parts of tyk-docs (using
      code-explorer tools) so you understand:
      - Which components the docs say are involved.
      - Which example configs or UI flows are shown (gateway, dashboard, portal, etc.).
      - Any NOTES / requirements lists that call out dependencies.

      Based on the reconstructed question and the docs context, infer a "projects"
      array of planned project entries:
      - Each entry MUST include:
        - "project_id": one of the known IDs listed above (never "tyk-docs").
        - Optional "reason": a short explanation of why this project is relevant
          (for example, "docs for JWT mention both gateway and dashboard config").
      - Detect all parts of the Tyk stack that this functionality can reasonably
        touch (gateway, dashboard BE/UI, pump, MDCB, storage, enterprise portal),
        then choose the smallest set that still covers the behaviour.
      - When in doubt, slightly over-approximate (include a project) rather than
        risk omitting a clearly related one.
      - Only use the allowed project IDs from the schema; do not invent new ids.
      Return JSON with a "projects" array per schema.

  # Normalize planner output into concrete project descriptors that can
  # drive both git checkouts and per-project code exploration. This step
  # runs once and returns an array; forEach then fans out items so that
  # dependents see one project at a time.
  project-items:
    type: script
    criticality: internal
    schema:
      type: array
    depends_on: [ensure-code-plan]
    guarantee:
      - "Array.isArray(output)"
    assume:
      - "Array.isArray(outputs['ensure-code-plan']?.projects)"
    content: |
      // Note: Use separate if statements to avoid sandbox short-circuit issues.
      var planner = null;
      if (outputs != null && typeof outputs === 'object') {
        planner = outputs['ensure-code-plan'];
      }
      var src = [];
      if (planner != null && typeof planner === 'object') {
        if (Array.isArray(planner.projects)) {
          src = planner.projects;
        }
      }

      // Map canonical project IDs to concrete repositories and human-readable
      // descriptions. Use only the canonical IDs defined in ensure-code-plan.
      const baseMap = {
        tyk: {
          repo: 'TykTechnologies/tyk',
          description: 'Tyk Gateway',
        },
        'tyk-analytics': {
          repo: 'TykTechnologies/tyk-analytics',
          description: 'Tyk Dashboard backend',
        },
        'tyk-analytics-ui': {
          repo: 'TykTechnologies/tyk-analytics-ui',
          description: 'Tyk Dashboard UI',
        },
        'tyk-pump': {
          repo: 'TykTechnologies/tyk-pump',
          description: 'Tyk Pump',
        },
        'tyk-sink': {
          repo: 'TykTechnologies/tyk-sink',
          description: 'Tyk MDCB',
        },
        storage: {
          repo: 'TykTechnologies/storage',
          description: 'Shared storage library',
        },
        'tyk-docs': {
          repo: 'TykTechnologies/tyk-docs',
          description: 'Tyk documentation',
        },
        portal: {
          repo: 'TykTechnologies/portal',
          description: 'Enterprise developer portal',
        },
      };

      const result = [];
      for (const p of src) {
        if (!p || typeof p !== 'object') continue;
        const id = p.project_id;
        if (!id || typeof id !== 'string') continue;
        const info = baseMap[id];
        if (info == null || typeof info !== 'object') continue;
        if (typeof info.repo !== 'string' || !info.repo) continue;

        result.push({
          project_id: id,
          reason: p.reason || '',
          repository: info.repo,
          description: info.description || id,
        });
      }

      return result;
    forEach: true

  # Checkout each selected Tyk project in its own worktree. These checkouts
  # are then made available to AI steps via allowedFolders so that the
  # code-explorer persona can actually read code and docs.
  checkout-projects:
    type: git-checkout
    criticality: internal
    depends_on: [project-items]
    assume:
      - "output != null"
    ref: "{{ outputs['project-items'].ref }}"
    repository: "{{ outputs['project-items'].repository }}"
    fetch_depth: 1
    description: "{{ outputs['project-items'].description }}"

  # Multi-project code exploration. This single step has access to all
  # planned projects and their checkouts, and can use code-explorer tools
  # (including delegate) per project as needed.
  project-code-query:
    type: ai
    criticality: internal
    depends_on: [ensure-code-plan, project-items, checkout-projects]
    # Treat dependencies on forEach parents in "reduce" mode so this check
    # runs once with aggregated project metadata instead of once per item.
    fanout: reduce
    assume:
      - "outputs['ensure-code-plan']?.projects?.length > 0"
    ai:
      # Use full code context across all checked-out projects.
      skip_code_context: true
      # Enable Probe's delegate tool so the agent can spin up
      # per-project sub-agents when exploring multiple repos.
      enableDelegate: true
      prompt_type: code-explorer
      # Enable bash commands for git operations (diff, log, checkout, etc.)
      allowBash: true
      bashConfig:
        allow:
          - "git:*"
          - "ls:*"
          - "find:*"
          - "cat:*"
          - "head:*"
          - "tail:*"
          - "wc:*"
          - "grep:*"
        timeout: 30000
      # Post-completion validation: ensure cross-project dependencies are verified
      completion_prompt: |
        Before finalizing your answer, trippel-check everything:
        1. Are there any dependencies or interactions between the projects you examined? Are their logical?
        2. Did you verify how data/config flows between gateway, dashboard, and other components?
        3. Are all code references accurate (file paths, function names, line numbers)?

        If you found any ambiguity or missed connections, fix it, and to a few more queries.

        You can also validate the facts with separate delegate tool, in case if your confidence is not high.

        When you finish ensure to answer again with all the details, 
        and pls in the end append a list of all the references to code and docs you had, with https://github.com... format, and pointing to the right lines.
    schema:
      type: object
      additionalProperties: false
      properties:
        answer:
          type: object
          additionalProperties: false
          properties:
            text: { type: string }
          required: [text]
      required: [answer]
    prompt: |
      <instructions>
      You are a Tyk code/doc explorer. Your goal is to answer a code-level
      question that can span multiple Tyk projects, using:
      - the checked-out Tyk code repositories
      - the checked-out tyk-docs repository
      - code-explorer tools (search, extract, query, listFiles, searchFiles)
      - delegate sub-agents when you need to dive deeply into a project
      - ensure that delegate sub agents return detailed referneces which point to files and line numbers

      Git bash commands:
      You are allowed to use git bash commands for deeper code investigation:
      - `git diff` to compare branches or commits
      - `git log` to see commit history and understand changes over time
      - `git show` to inspect specific commits
      - `git blame` to understand who changed what and when
      - `git checkout` to switch branches when comparing implementations
      - `git branch` to list available branches
      - `git fetch --tags` to fetch all tags from remote
      - `git tag -l` to list all available tags
      Use these tools when you need to understand how code evolved, compare
      different versions, or investigate recent changes related to the question.

      IMPORTANT bash tool usage rules:
      - Do NOT use shell operators like && or || or | (pipes) - they are blocked for security
      - Do NOT use `cd dir && command` - this will be rejected
      - INSTEAD, use the workingDirectory parameter to specify where to run commands
      - Example: To run `git tag -l "v5.8*"` in the tyk directory, call the bash tool with:
        - command: `git tag -l "v5.8*"`
        - workingDirectory: `/path/to/tyk`  (use the checkout path from project_checkouts)
      - Each bash call should be a single simple command with workingDirectory set appropriately

      Version-specific queries:
      - When asked about a specific version (e.g., "5.8", "v5.8.3", "Tyk 5.8"):
        1. First run `git fetch --tags` (with workingDirectory set to the project checkout path)
        2. Then run `git tag -l "v5.8*"` to find matching tags
        3. You may find tags like v5.8.0, v5.8.1, v5.8.10 - pick the most relevant one
        4. Checkout to that tag: `git checkout v5.8.10`
      - When asked about a specific branch (e.g., "release-5.8", "master", "main"):
        1. Run `git fetch origin <branch>` (with workingDirectory set)
        2. Checkout to that branch: `git checkout <branch>`
      - Always verify you're on the correct version/branch before investigating code.
      - Remember: always use workingDirectory parameter, never chain commands with &&

      High-level behaviour:
      - Use tyk-docs to understand the intended behaviour, configuration, and
        cross-component interactions for the feature in question.
      - If this run comes from Slack, the full thread is available in the outer
        <slack_context>. Use earlier user messages, follow-ups, and corrections
        to recover the real question and any constraints before you dive into code.
      - For each selected project, read the code and relevant docs to answer
        the engineer’s question as concretely as possible.
      - When multiple projects are involved (e.g., gateway + dashboard),
        deliberately follow data and control flow across them and explain the
        connections.
      - Always ground your answer in actual code/docs, not speculation.
      - When you see some dependency - proove it by code. You can ask multiple times different questions (try to use delegate tool).
      </instructions>

      <context>
        <question>
          {{ inputs.question }}
        </question>

        <planner_output>
          {{ outputs['ensure-code-plan'] | to_json }}
        </planner_output>

        {% assign docs_co = outputs.history['checkout-tyk-docs'] | last %}
        <docs_checkout>
          <repo>{{ docs_co.repository | default: 'TykTechnologies/tyk-docs' }}</repo>
          <ref>{{ docs_co.ref | default: 'main' }}</ref>
          <path>{{ docs_co.path | default: '(not available)' }}</path>
        </docs_checkout>

        {% assign items = outputs.history['project-items'] | last %}
        {% assign checkouts = outputs.history['checkout-projects'] %}
        {% if checkouts == nil or checkouts == empty %}
        {% assign checkouts = outputs['checkout-projects'].forEachItems %}
        {% endif %}
        <projects>
        {% if items and checkouts %}
        {% for p in items %}
        {% assign co = checkouts[forloop.index0] %}
          <project>
            <id>{{ p.project_id }}</id>
            <repo>{{ p.repository }}</repo>
            <ref>{{ p.ref }}</ref>
            <path>{{ co.path }}</path>
            <reason>{{ p.reason | default: 'not provided' }}</reason>
          </project>
        {% endfor %}
        {% endif %}
        </projects>
      </context>

      <task>
      For each project listed in &lt;projects&gt;:
      - Use code-explorer tools to:
        - listFiles/searchFiles to understand the structure and find relevant
          directories and files;
        - search/query/extract to locate and read the core implementation
          related to the question;
        - consult tyk-docs (see &lt;docs_checkout&gt;) to confirm semantics,
          configuration options, and cross-project responsibilities.
      - When multiple projects are involved, pay attention to:
        - how configuration flows from dashboard/docs into gateway;
        - how identity, auth, or data flows between services;
        - any shared libraries (e.g., storage) used by more than one project.
      - Use delegate tools per project when a deeper, focused investigation
        is needed (e.g., “understand JWT middleware in tyk”).

      Finally, synthesize everything you’ve learned into a single `answer.text`
      field that explains the behaviour to a Tyk engineer:
      - Be concrete and code/doc-grounded (mention key components, files, and
        configuration knobs when helpful).
      - Keep the explanation focused and coherent; the caller does not need
        per-project metadata, only a clear answer.
      - The JSON you return MUST match this step's schema: a single object
        with an `answer` object that has a `text` field. Do NOT include XML
        tags in the final JSON and do NOT add extra top-level fields.
      </task>

tests:
  defaults:
    strict: true
    ai_provider: mock

  cases:
    - name: docs-and-code-question
      event: manual
      fixture: local.minimal
      workflow_input:
        question: "How is org-wide rate limiting implemented and documented?"
      mocks:
        checkout-tyk-docs:
          path: "/tmp/visor/tyk-docs"
          repository: "TykTechnologies/tyk-docs"
          ref: "main"
        checkout-projects:
          path: "/tmp/visor/project"
          repository: "TykTechnologies/example"
          ref: "main"
        ensure-code-plan:
          projects:
            - { project_id: "tyk", reason: "Gateway implements org-wide rate limiting and docs describe its behaviour and configuration." }
        project-code-query:
          answer:
            text: "Org-wide rate limiting is implemented in the gateway and described in the docs."
      expect:
        calls:
          - step: checkout-tyk-docs
            exactly: 1
          - step: ensure-code-plan
            exactly: 1
          - step: project-items
            exactly: 1
          - step: checkout-projects
            exactly: 1
          - step: project-code-query
            exactly: 1
        workflow_output:
          - path: answer.text
            equals: "Org-wide rate limiting is implemented in the gateway and described in the docs."

    - name: docs-only-question
      event: manual
      fixture: local.minimal
      workflow_input:
        question: "Where are rate limiting settings documented?"
      mocks:
        checkout-tyk-docs:
          path: "/tmp/visor/tyk-docs"
          repository: "TykTechnologies/tyk-docs"
          ref: "main"
        checkout-projects:
          path: "/tmp/visor/project"
          repository: "TykTechnologies/example"
          ref: "main"
        ensure-code-plan:
          projects:
            - { project_id: "tyk", reason: "Rate limiting behaviour and configuration are documented for the gateway in tyk-docs." }
        project-code-query:
          answer:
            text: "Rate limiting settings are documented in the tyk-docs configuration sections."
      expect:
        calls:
          - step: checkout-tyk-docs
            exactly: 1
          - step: ensure-code-plan
            exactly: 1
          - step: project-items
            exactly: 1
          - step: checkout-projects
            exactly: 1
          - step: project-code-query
            exactly: 1
        workflow_output:
          - path: answer.text
            equals: "Rate limiting settings are documented in the tyk-docs configuration sections."

    - name: multi-project-partial-delegates
      event: manual
      fixture: local.minimal
      workflow_input:
        question: "How does authentication flow through gateway and dashboard?"
      mocks:
        checkout-tyk-docs:
          path: "/tmp/visor/tyk-docs"
          repository: "TykTechnologies/tyk-docs"
          ref: "main"
        checkout-projects:
          path: "/tmp/visor/project"
          repository: "TykTechnologies/example"
          ref: "main"
        ensure-code-plan:
          projects:
            - { project_id: "tyk",           reason: "Gateway handles authentication at the edge." }
            - { project_id: "tyk-analytics", reason: "Dashboard manages auth configuration and visibility." }
        project-code-query:
          answer:
            text: "Authentication is handled primarily in the gateway, with the dashboard orchestrating configuration and visibility."
      expect:
        calls:
          - step: checkout-tyk-docs
            exactly: 1
          - step: ensure-code-plan
            exactly: 1
          - step: project-items
            exactly: 1
          - step: checkout-projects
            exactly: 2
          - step: project-code-query
            exactly: 1
        workflow_output:
          - path: answer.text
            equals: "Authentication is handled primarily in the gateway, with the dashboard orchestrating configuration and visibility."

    - name: empty-project-plan-is-error
      # This case intentionally exercises a failure path (ensure-code-plan
      # returning an empty projects list). Keep strict off so we can observe
      # the behaviour without the harness treating the failure as a bug.
      strict: false
      event: manual
      fixture: local.minimal
      workflow_input:
        question: "Some vague question that should still pick a project"
      mocks:
        checkout-tyk-docs:
          path: "/tmp/visor/tyk-docs"
          repository: "TykTechnologies/tyk-docs"
          ref: "main"
        # Force the bad path: no projects selected
        ensure-code-plan:
          projects: []
      expect:
        calls:
          - step: ensure-code-plan
            exactly: 1

    - name: checkout-failure-propagates
      # Simulate a git-checkout failure in the nested workflow. We keep
      # strict=false so the suite stays green, but this case exercises the
      # same failure shape seen in Slack (checkout error + missing answer).
      strict: false
      event: manual
      fixture: local.minimal
      workflow_input:
        question: "How is HMAC implemented across gateway and dashboard?"
      mocks:
        # Simulate a failing git-checkout provider run with an error issue.
        checkout-tyk-docs:
          issues:
            - file: git-checkout
              line: 0
              ruleId: git-checkout/error
              message: "Failed to checkout code: branch already used by another worktree"
              severity: error
              category: logic
          output:
            success: false
            error: "Failed to checkout code: branch already used by another worktree"
      expect:
        calls:
          - step: checkout-tyk-docs
            exactly: 1

    - name: plain-text-plan-is-error
      # Simulate the model returning only prose for ensure-code-plan (no
      # projects array). The workflow should not crash; instead, it should
      # complete without producing a synthesized answer.
      strict: false
      event: manual
      fixture: local.minimal
      workflow_input:
        question: "Explain how JWT validation works in Tyk"
      mocks:
        checkout-tyk-docs:
          path: "/tmp/visor/tyk-docs"
          repository: "TykTechnologies/tyk-docs"
          ref: "main"
        ensure-code-plan:
          text: "In Tyk, JWT validation is handled by middleware in the gateway."
      expect:
        calls:
          - step: ensure-code-plan
            exactly: 1

    - name: empty-plan-from-plan-code-query
      # Reproduce the case where ensure-code-plan selects projects, but
      # plan-code-query returns an empty projects list. The workflow should
      # not crash; instead, it completes with no synthesized answer.
      strict: false
      event: manual
      fixture: local.minimal
      workflow_input:
        question: "Explain how JWT validation works in Tyk gateway and dashboard."
      mocks:
        checkout-tyk-docs:
          path: "/tmp/visor/tyk-docs"
          repository: "TykTechnologies/tyk-docs"
          ref: "main"
        ensure-code-plan:
          projects: []
      expect:
        calls:
          - step: ensure-code-plan
            exactly: 1
        workflow_output:
          - path: answer
            equals: null

    - name: empty-delegates-per-project
      # ensure-code-plan and plan-code-query both select projects, but the
      # delegates step returns an empty per_project array. With the current
      # guarantee/fail_if on per-project-delegates, this should be treated as
      # a failure and the workflow should not produce a synthesized answer.
      strict: false
      event: manual
      fixture: local.minimal
      workflow_input:
        question: "Explain how request logging works in the gateway."
      mocks:
        checkout-tyk-docs:
          path: "/tmp/visor/tyk-docs"
          repository: "TykTechnologies/tyk-docs"
          ref: "main"
        ensure-code-plan:
          projects:
            - { project_id: "tyk", reason: "Gateway implements request logging." }
        checkout-projects:
          path: "/tmp/visor/project"
          repository: "TykTechnologies/example"
          ref: "main"
        project-code-query:
          answer:
            text: "Fallback answer after empty per_project; details are not required for this test."
      expect:
        calls:
          - step: project-code-query
            exactly: 1
        # We only assert that the workflow ran; the mocked answer is accepted as-is.
