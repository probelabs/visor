{"version":3,"sources":["../../src/github-auth.ts"],"sourcesContent":["import { Octokit } from '@octokit/rest';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { logger } from './logger';\n\n/**\n * Options for GitHub authentication.\n * Supports both personal access token and GitHub App authentication.\n */\nexport interface GitHubAuthOptions {\n  /** Personal access token or fine-grained token */\n  token?: string;\n  /** GitHub App ID */\n  appId?: string;\n  /** GitHub App private key (PEM content or file path) */\n  privateKey?: string;\n  /** GitHub App installation ID (auto-detected if omitted) */\n  installationId?: string;\n  /** Repository owner (for auto-detecting installation ID) */\n  owner?: string;\n  /** Repository name (for auto-detecting installation ID) */\n  repo?: string;\n}\n\n/**\n * Result of successful GitHub authentication.\n */\nexport interface GitHubAuthResult {\n  /** Authenticated Octokit instance */\n  octokit: Octokit;\n  /** Authentication method used */\n  authType: 'github-app' | 'token';\n  /** Raw token string for environment propagation */\n  token: string;\n}\n\n/**\n * Create an authenticated Octokit instance.\n * Returns undefined if no credentials are provided (auth is optional in CLI mode).\n *\n * For token auth: uses the token directly.\n * For GitHub App auth: creates JWT-authenticated client, resolves installation ID,\n * then extracts an installation access token for environment propagation.\n */\nexport async function createAuthenticatedOctokit(\n  options: GitHubAuthOptions\n): Promise<GitHubAuthResult | undefined> {\n  const { token, appId, installationId, owner, repo } = options;\n  const privateKey = options.privateKey ? resolvePrivateKey(options.privateKey) : undefined;\n\n  // Prefer GitHub App authentication if app credentials are provided\n  if (appId && privateKey) {\n    const { createAppAuth } = await import('@octokit/auth-app');\n\n    let finalInstallationId: number | undefined;\n\n    if (installationId) {\n      finalInstallationId = parseInt(installationId, 10);\n      if (isNaN(finalInstallationId) || finalInstallationId <= 0) {\n        throw new Error('Invalid installation-id. It must be a positive integer.');\n      }\n    }\n\n    // Auto-detect installation ID if not provided\n    if (!finalInstallationId && owner && repo) {\n      const appOctokit = new Octokit({\n        authStrategy: createAppAuth,\n        auth: { appId, privateKey },\n      });\n\n      try {\n        const { data: installation } = await appOctokit.rest.apps.getRepoInstallation({\n          owner,\n          repo,\n        });\n        finalInstallationId = installation.id;\n      } catch {\n        throw new Error(\n          'GitHub App installation ID could not be auto-detected. ' +\n            'Provide --github-installation-id or ensure the app is installed on the repository.'\n        );\n      }\n    }\n\n    if (!finalInstallationId) {\n      throw new Error(\n        'GitHub App installation ID is required. Provide --github-installation-id or set owner/repo for auto-detection.'\n      );\n    }\n\n    // Create the authenticated Octokit instance\n    const octokit = new Octokit({\n      authStrategy: createAppAuth,\n      auth: {\n        appId,\n        privateKey,\n        installationId: finalInstallationId,\n      },\n    });\n\n    // Extract the installation access token for environment propagation\n    const authResult = (await octokit.auth({ type: 'installation' })) as { token: string };\n\n    return {\n      octokit,\n      authType: 'github-app',\n      token: authResult.token,\n    };\n  }\n\n  // Fall back to token authentication\n  if (token) {\n    return {\n      octokit: new Octokit({ auth: token }),\n      authType: 'token',\n      token,\n    };\n  }\n\n  // No credentials provided\n  return undefined;\n}\n\n/**\n * Resolve GitHub auth options from environment variables.\n * Used as fallback when no explicit CLI arguments are provided.\n */\nexport function resolveAuthFromEnvironment(): GitHubAuthOptions {\n  return {\n    token: process.env.GITHUB_TOKEN || process.env.GH_TOKEN,\n    appId: process.env.GITHUB_APP_ID,\n    privateKey: process.env.GITHUB_APP_PRIVATE_KEY,\n    installationId: process.env.GITHUB_APP_INSTALLATION_ID,\n    owner: process.env.GITHUB_REPOSITORY_OWNER || process.env.GITHUB_REPOSITORY?.split('/')[0],\n    repo: process.env.GITHUB_REPOSITORY?.split('/')[1],\n  };\n}\n\n/**\n * Resolve private key — supports both inline PEM content and file paths.\n */\nexport function resolvePrivateKey(keyOrPath: string): string {\n  if (keyOrPath.includes('-----BEGIN')) {\n    return keyOrPath;\n  }\n  const resolved = path.resolve(keyOrPath);\n  if (fs.existsSync(resolved)) {\n    return fs.readFileSync(resolved, 'utf8');\n  }\n  // Return as-is and let the auth library handle errors\n  return keyOrPath;\n}\n\n// Track our auth entries position so repeated calls replace instead of stacking.\n// _authBase: the GIT_CONFIG index where our 2 auth entries start.\n// _lastWrittenCount: what we last set GIT_CONFIG_COUNT to (detects external changes).\nlet _authBase: number | undefined;\nlet _lastWrittenCount: number | undefined;\n\n/**\n * Inject GitHub credentials into process.env for child processes.\n *\n * Sets GITHUB_TOKEN/GH_TOKEN for gh CLI, and configures git HTTPS auth\n * via GIT_CONFIG_COUNT/KEY/VALUE env vars so `git clone`, `git push`, etc.\n * work automatically against github.com without any local git config.\n *\n * Uses git's GIT_CONFIG_COUNT mechanism (git 2.31+, March 2021):\n * - No temp files or global config mutation\n * - Inherited by all child processes automatically\n * - Works regardless of local git configuration\n *\n * Safe to call multiple times (e.g. on token refresh) — replaces previous entries.\n */\nexport function injectGitHubCredentials(token: string): void {\n  // Set for gh CLI and general GitHub API usage\n  process.env.GITHUB_TOKEN = token;\n  process.env.GH_TOKEN = token;\n\n  const currentCount = parseInt(process.env.GIT_CONFIG_COUNT || '0', 10);\n\n  // Determine where to write our 2 auth entries:\n  // - First call: append after any pre-existing entries\n  // - Subsequent calls with unchanged count: overwrite at same position\n  // - If count changed externally: someone added entries, append after them\n  let base: number;\n  if (_authBase === undefined) {\n    base = currentCount;\n  } else if (_lastWrittenCount !== undefined && currentCount !== _lastWrittenCount) {\n    base = currentCount;\n  } else {\n    base = _authBase;\n  }\n  _authBase = base;\n\n  // Configure git HTTPS auth via url.<base>.insteadOf\n  const authUrl = `https://x-access-token:${token}@github.com/`;\n\n  // Rewrite HTTPS URLs\n  process.env[`GIT_CONFIG_KEY_${base}`] = `url.${authUrl}.insteadOf`;\n  process.env[`GIT_CONFIG_VALUE_${base}`] = 'https://github.com/';\n\n  // Rewrite SSH-style URLs (git@github.com:org/repo)\n  process.env[`GIT_CONFIG_KEY_${base + 1}`] = `url.${authUrl}.insteadOf`;\n  process.env[`GIT_CONFIG_VALUE_${base + 1}`] = 'git@github.com:';\n\n  const newCount = base + 2;\n  process.env.GIT_CONFIG_COUNT = String(newCount);\n  _lastWrittenCount = newCount;\n}\n\n/**\n * Mark the current token as freshly generated (for use after initial startup auth).\n * Prevents the first refreshGitHubCredentials() call from unnecessarily regenerating.\n */\nexport function markTokenFresh(): void {\n  const token = process.env.GITHUB_TOKEN || process.env.GH_TOKEN;\n  if (token) {\n    _cachedAppToken = { token, generatedAt: Date.now() };\n  }\n}\n\n// Cached token with generation timestamp for expiry checks\nlet _cachedAppToken: { token: string; generatedAt: number } | undefined;\n\n// Installation tokens live 1 hour; refresh after 45 minutes.\n// Using 45 min (not 50) leaves a 15-minute buffer for long-running tasks\n// that start right before a refresh cycle.\nconst TOKEN_REFRESH_MS = 45 * 60 * 1000;\n\n// Background refresh timer\nlet _refreshTimer: ReturnType<typeof setInterval> | undefined;\n\n// How often the background timer checks (30 minutes)\nconst TIMER_INTERVAL_MS = 30 * 60 * 1000;\n\n/**\n * Refresh GitHub App installation credentials if they are about to expire.\n *\n * No-op when:\n * - No GitHub App credentials are configured (GITHUB_APP_ID + GITHUB_APP_PRIVATE_KEY)\n * - The current token was generated less than 45 minutes ago\n *\n * Call this before each execution in long-running processes (Slack bot, scheduler)\n * to ensure child processes always have a valid token for git/gh operations.\n */\nexport async function refreshGitHubCredentials(): Promise<void> {\n  // Quick check: do we have App credentials?\n  const appId = process.env.GITHUB_APP_ID;\n  const privateKey = process.env.GITHUB_APP_PRIVATE_KEY;\n  if (!appId || !privateKey) return;\n\n  // Skip if cached token is still fresh\n  const now = Date.now();\n  if (_cachedAppToken && now - _cachedAppToken.generatedAt < TOKEN_REFRESH_MS) {\n    return;\n  }\n\n  try {\n    const opts = resolveAuthFromEnvironment();\n    const result = await createAuthenticatedOctokit(opts);\n    if (result && result.authType === 'github-app') {\n      injectGitHubCredentials(result.token);\n      _cachedAppToken = { token: result.token, generatedAt: now };\n      logger.debug('[github-auth] Refreshed GitHub App installation token');\n    }\n  } catch (err) {\n    const age = _cachedAppToken\n      ? `${Math.round((now - _cachedAppToken.generatedAt) / 60000)}min old`\n      : 'no cached token';\n    logger.warn(\n      `[github-auth] Failed to refresh GitHub App token (${age}): ${err instanceof Error ? err.message : String(err)}. ` +\n        'Child processes may fail with authentication errors.'\n    );\n  }\n}\n\n/**\n * Start a background timer that refreshes GitHub App tokens every 30 minutes.\n *\n * This ensures tokens stay fresh even during long-running tasks (e.g., an engineer\n * task that takes 40+ minutes). Without this, a token generated at startup could\n * expire mid-execution of a child process.\n *\n * The timer is unref'd so it doesn't prevent Node from exiting.\n * Call stopTokenRefreshTimer() on shutdown.\n */\nexport function startTokenRefreshTimer(): void {\n  if (_refreshTimer) return; // Already running\n\n  // Only start if we have App credentials\n  const appId = process.env.GITHUB_APP_ID;\n  const privateKey = process.env.GITHUB_APP_PRIVATE_KEY;\n  if (!appId || !privateKey) return;\n\n  _refreshTimer = setInterval(() => {\n    refreshGitHubCredentials().catch(err => {\n      logger.warn(\n        `[github-auth] Background token refresh failed: ${err instanceof Error ? err.message : String(err)}`\n      );\n    });\n  }, TIMER_INTERVAL_MS);\n\n  // Don't prevent Node from exiting\n  _refreshTimer.unref();\n\n  logger.debug('[github-auth] Background token refresh timer started (every 30 min)');\n}\n\n/**\n * Stop the background token refresh timer.\n */\nexport function stopTokenRefreshTimer(): void {\n  if (_refreshTimer) {\n    clearInterval(_refreshTimer);\n    _refreshTimer = undefined;\n    logger.debug('[github-auth] Background token refresh timer stopped');\n  }\n}\n\n/** Visible for testing: override the cached token state. */\nexport function _testSetCachedToken(token: string | undefined, generatedAt?: number): void {\n  if (token) {\n    _cachedAppToken = { token, generatedAt: generatedAt ?? Date.now() };\n  } else {\n    _cachedAppToken = undefined;\n  }\n}\n\n/** Visible for testing: get the current cached token info. */\nexport function _testGetCachedToken(): { token: string; generatedAt: number } | undefined {\n  return _cachedAppToken;\n}\n"],"mappings":";;;;;;;;;;AAAA,SAAS,eAAe;AACxB,YAAY,QAAQ;AACpB,YAAY,UAAU;AA0CtB,eAAsB,2BACpB,SACuC;AACvC,QAAM,EAAE,OAAO,OAAO,gBAAgB,OAAO,KAAK,IAAI;AACtD,QAAM,aAAa,QAAQ,aAAa,kBAAkB,QAAQ,UAAU,IAAI;AAGhF,MAAI,SAAS,YAAY;AACvB,UAAM,EAAE,cAAc,IAAI,MAAM,OAAO,mBAAmB;AAE1D,QAAI;AAEJ,QAAI,gBAAgB;AAClB,4BAAsB,SAAS,gBAAgB,EAAE;AACjD,UAAI,MAAM,mBAAmB,KAAK,uBAAuB,GAAG;AAC1D,cAAM,IAAI,MAAM,yDAAyD;AAAA,MAC3E;AAAA,IACF;AAGA,QAAI,CAAC,uBAAuB,SAAS,MAAM;AACzC,YAAM,aAAa,IAAI,QAAQ;AAAA,QAC7B,cAAc;AAAA,QACd,MAAM,EAAE,OAAO,WAAW;AAAA,MAC5B,CAAC;AAED,UAAI;AACF,cAAM,EAAE,MAAM,aAAa,IAAI,MAAM,WAAW,KAAK,KAAK,oBAAoB;AAAA,UAC5E;AAAA,UACA;AAAA,QACF,CAAC;AACD,8BAAsB,aAAa;AAAA,MACrC,QAAQ;AACN,cAAM,IAAI;AAAA,UACR;AAAA,QAEF;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,qBAAqB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,UAAU,IAAI,QAAQ;AAAA,MAC1B,cAAc;AAAA,MACd,MAAM;AAAA,QACJ;AAAA,QACA;AAAA,QACA,gBAAgB;AAAA,MAClB;AAAA,IACF,CAAC;AAGD,UAAM,aAAc,MAAM,QAAQ,KAAK,EAAE,MAAM,eAAe,CAAC;AAE/D,WAAO;AAAA,MACL;AAAA,MACA,UAAU;AAAA,MACV,OAAO,WAAW;AAAA,IACpB;AAAA,EACF;AAGA,MAAI,OAAO;AACT,WAAO;AAAA,MACL,SAAS,IAAI,QAAQ,EAAE,MAAM,MAAM,CAAC;AAAA,MACpC,UAAU;AAAA,MACV;AAAA,IACF;AAAA,EACF;AAGA,SAAO;AACT;AAMO,SAAS,6BAAgD;AAC9D,SAAO;AAAA,IACL,OAAO,QAAQ,IAAI,gBAAgB,QAAQ,IAAI;AAAA,IAC/C,OAAO,QAAQ,IAAI;AAAA,IACnB,YAAY,QAAQ,IAAI;AAAA,IACxB,gBAAgB,QAAQ,IAAI;AAAA,IAC5B,OAAO,QAAQ,IAAI,2BAA2B,QAAQ,IAAI,mBAAmB,MAAM,GAAG,EAAE,CAAC;AAAA,IACzF,MAAM,QAAQ,IAAI,mBAAmB,MAAM,GAAG,EAAE,CAAC;AAAA,EACnD;AACF;AAKO,SAAS,kBAAkB,WAA2B;AAC3D,MAAI,UAAU,SAAS,YAAY,GAAG;AACpC,WAAO;AAAA,EACT;AACA,QAAM,WAAgB,aAAQ,SAAS;AACvC,MAAO,cAAW,QAAQ,GAAG;AAC3B,WAAU,gBAAa,UAAU,MAAM;AAAA,EACzC;AAEA,SAAO;AACT;AAsBO,SAAS,wBAAwB,OAAqB;AAE3D,UAAQ,IAAI,eAAe;AAC3B,UAAQ,IAAI,WAAW;AAEvB,QAAM,eAAe,SAAS,QAAQ,IAAI,oBAAoB,KAAK,EAAE;AAMrE,MAAI;AACJ,MAAI,cAAc,QAAW;AAC3B,WAAO;AAAA,EACT,WAAW,sBAAsB,UAAa,iBAAiB,mBAAmB;AAChF,WAAO;AAAA,EACT,OAAO;AACL,WAAO;AAAA,EACT;AACA,cAAY;AAGZ,QAAM,UAAU,0BAA0B,KAAK;AAG/C,UAAQ,IAAI,kBAAkB,IAAI,EAAE,IAAI,OAAO,OAAO;AACtD,UAAQ,IAAI,oBAAoB,IAAI,EAAE,IAAI;AAG1C,UAAQ,IAAI,kBAAkB,OAAO,CAAC,EAAE,IAAI,OAAO,OAAO;AAC1D,UAAQ,IAAI,oBAAoB,OAAO,CAAC,EAAE,IAAI;AAE9C,QAAM,WAAW,OAAO;AACxB,UAAQ,IAAI,mBAAmB,OAAO,QAAQ;AAC9C,sBAAoB;AACtB;AAMO,SAAS,iBAAuB;AACrC,QAAM,QAAQ,QAAQ,IAAI,gBAAgB,QAAQ,IAAI;AACtD,MAAI,OAAO;AACT,sBAAkB,EAAE,OAAO,aAAa,KAAK,IAAI,EAAE;AAAA,EACrD;AACF;AA0BA,eAAsB,2BAA0C;AAE9D,QAAM,QAAQ,QAAQ,IAAI;AAC1B,QAAM,aAAa,QAAQ,IAAI;AAC/B,MAAI,CAAC,SAAS,CAAC,WAAY;AAG3B,QAAM,MAAM,KAAK,IAAI;AACrB,MAAI,mBAAmB,MAAM,gBAAgB,cAAc,kBAAkB;AAC3E;AAAA,EACF;AAEA,MAAI;AACF,UAAM,OAAO,2BAA2B;AACxC,UAAM,SAAS,MAAM,2BAA2B,IAAI;AACpD,QAAI,UAAU,OAAO,aAAa,cAAc;AAC9C,8BAAwB,OAAO,KAAK;AACpC,wBAAkB,EAAE,OAAO,OAAO,OAAO,aAAa,IAAI;AAC1D,aAAO,MAAM,uDAAuD;AAAA,IACtE;AAAA,EACF,SAAS,KAAK;AACZ,UAAM,MAAM,kBACR,GAAG,KAAK,OAAO,MAAM,gBAAgB,eAAe,GAAK,CAAC,YAC1D;AACJ,WAAO;AAAA,MACL,qDAAqD,GAAG,MAAM,eAAe,QAAQ,IAAI,UAAU,OAAO,GAAG,CAAC;AAAA,IAEhH;AAAA,EACF;AACF;AAYO,SAAS,yBAA+B;AAC7C,MAAI,cAAe;AAGnB,QAAM,QAAQ,QAAQ,IAAI;AAC1B,QAAM,aAAa,QAAQ,IAAI;AAC/B,MAAI,CAAC,SAAS,CAAC,WAAY;AAE3B,kBAAgB,YAAY,MAAM;AAChC,6BAAyB,EAAE,MAAM,SAAO;AACtC,aAAO;AAAA,QACL,kDAAkD,eAAe,QAAQ,IAAI,UAAU,OAAO,GAAG,CAAC;AAAA,MACpG;AAAA,IACF,CAAC;AAAA,EACH,GAAG,iBAAiB;AAGpB,gBAAc,MAAM;AAEpB,SAAO,MAAM,qEAAqE;AACpF;AAKO,SAAS,wBAA8B;AAC5C,MAAI,eAAe;AACjB,kBAAc,aAAa;AAC3B,oBAAgB;AAChB,WAAO,MAAM,sDAAsD;AAAA,EACrE;AACF;AAGO,SAAS,oBAAoB,OAA2B,aAA4B;AACzF,MAAI,OAAO;AACT,sBAAkB,EAAE,OAAO,aAAa,eAAe,KAAK,IAAI,EAAE;AAAA,EACpE,OAAO;AACL,sBAAkB;AAAA,EACpB;AACF;AAGO,SAAS,sBAA0E;AACxF,SAAO;AACT;AA3UA,IA4JI,WACA,mBAiEA,iBAKE,kBAGF,eAGE;AAzON;AAAA;AAGA;AAgOA,IAAM,mBAAmB,KAAK,KAAK;AAMnC,IAAM,oBAAoB,KAAK,KAAK;AAAA;AAAA;","names":[]}