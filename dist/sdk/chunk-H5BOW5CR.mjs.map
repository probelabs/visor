{"version":3,"sources":["../../src/utils/json-text-extractor.ts"],"sourcesContent":["/**\n * Utility for extracting text content from JSON-like output.\n *\n * When AI models return structured JSON with text/response/message fields,\n * but template rendering fails to unwrap them, this utility provides a\n * fallback to extract the actual text content.\n */\n\n/**\n * Extract text/response/message field from malformed JSON-like string using regex.\n * Handles cases where AI returns incomplete JSON like:\n * {\"text\": \"content here...\\n\\n## More content\" (missing closing brace)\n *\n * @param content - The malformed JSON-like string\n * @returns The extracted text content, or undefined if not found\n */\nfunction extractTextFieldFromMalformedJson(content: string): string | undefined {\n  // Try to match \"text\", \"response\", or \"message\" field at the start of JSON\n  // Pattern: {\"text\": \"...\" or { \"text\": \"...\" (with optional whitespace)\n  // The value can be a quoted string that we need to extract\n\n  // First, try to find a field like \"text\": \"value\" or \"text\": value\n  // We look for the field name followed by : and then extract everything after\n  const fieldPatterns = [\n    /^\\s*\\{\\s*\"text\"\\s*:\\s*\"/i,\n    /^\\s*\\{\\s*\"response\"\\s*:\\s*\"/i,\n    /^\\s*\\{\\s*\"message\"\\s*:\\s*\"/i,\n  ];\n\n  for (const pattern of fieldPatterns) {\n    const match = pattern.exec(content);\n    if (match) {\n      // Found a field, extract the value starting after the opening quote\n      const valueStart = match[0].length;\n      const remaining = content.substring(valueStart);\n\n      // Try to find the end of the string value by looking for unescaped quotes\n      // Handle escaped quotes (\\\") within the string\n      let value = '';\n      let i = 0;\n      while (i < remaining.length) {\n        const char = remaining[i];\n        if (char === '\\\\' && i + 1 < remaining.length) {\n          // Escape sequence - handle common ones\n          const nextChar = remaining[i + 1];\n          if (nextChar === 'n') {\n            value += '\\n';\n          } else if (nextChar === 'r') {\n            value += '\\r';\n          } else if (nextChar === 't') {\n            value += '\\t';\n          } else if (nextChar === '\"') {\n            value += '\"';\n          } else if (nextChar === '\\\\') {\n            value += '\\\\';\n          } else {\n            // Unknown escape, keep as-is\n            value += char + nextChar;\n          }\n          i += 2;\n        } else if (char === '\"') {\n          // End of string value (unescaped quote)\n          break;\n        } else {\n          value += char;\n          i++;\n        }\n      }\n\n      // If we extracted something meaningful, return it\n      if (value.trim().length > 0) {\n        return value.trim();\n      }\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Extract text from a JSON-like object or JSON string.\n * If the input is a string that looks like JSON with a text/response/message field,\n * extracts and returns that field. Otherwise returns the original content.\n *\n * @param content - The content to extract text from (can be string, object, or any)\n * @returns The extracted text, or undefined if no content\n */\nexport function extractTextFromJson(content: unknown): string | undefined {\n  if (content === undefined || content === null) return undefined;\n\n  let parsed = content;\n\n  // If it's a string, check if it looks like JSON\n  if (typeof content === 'string') {\n    const trimmed = content.trim();\n\n    // If it doesn't look like JSON, return as-is\n    if (!trimmed.startsWith('{') && !trimmed.startsWith('[')) {\n      return trimmed.length > 0 ? trimmed : undefined;\n    }\n\n    // Try to parse as JSON\n    try {\n      parsed = JSON.parse(trimmed);\n    } catch {\n      // JSON parsing failed - try to extract text field using regex\n      // This handles malformed JSON like: {\"text\": \"content...\\n\\n## More content\" (missing closing brace)\n      const extracted = extractTextFieldFromMalformedJson(trimmed);\n      if (extracted) {\n        return extracted;\n      }\n      // Couldn't extract, return as-is\n      return trimmed.length > 0 ? trimmed : undefined;\n    }\n  }\n\n  // Extract text field from parsed object\n  if (parsed && typeof parsed === 'object') {\n    const txt =\n      (parsed as Record<string, unknown>).text ||\n      (parsed as Record<string, unknown>).response ||\n      (parsed as Record<string, unknown>).message;\n    if (typeof txt === 'string' && txt.trim()) {\n      return txt.trim();\n    }\n  }\n\n  // If we got here with a string, return it\n  if (typeof content === 'string') {\n    const trimmed = content.trim();\n    return trimmed.length > 0 ? trimmed : undefined;\n  }\n\n  return undefined;\n}\n"],"mappings":";;;;;AAgBA,SAAS,kCAAkC,SAAqC;AAO9E,QAAM,gBAAgB;AAAA,IACpB;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,aAAW,WAAW,eAAe;AACnC,UAAM,QAAQ,QAAQ,KAAK,OAAO;AAClC,QAAI,OAAO;AAET,YAAM,aAAa,MAAM,CAAC,EAAE;AAC5B,YAAM,YAAY,QAAQ,UAAU,UAAU;AAI9C,UAAI,QAAQ;AACZ,UAAI,IAAI;AACR,aAAO,IAAI,UAAU,QAAQ;AAC3B,cAAM,OAAO,UAAU,CAAC;AACxB,YAAI,SAAS,QAAQ,IAAI,IAAI,UAAU,QAAQ;AAE7C,gBAAM,WAAW,UAAU,IAAI,CAAC;AAChC,cAAI,aAAa,KAAK;AACpB,qBAAS;AAAA,UACX,WAAW,aAAa,KAAK;AAC3B,qBAAS;AAAA,UACX,WAAW,aAAa,KAAK;AAC3B,qBAAS;AAAA,UACX,WAAW,aAAa,KAAK;AAC3B,qBAAS;AAAA,UACX,WAAW,aAAa,MAAM;AAC5B,qBAAS;AAAA,UACX,OAAO;AAEL,qBAAS,OAAO;AAAA,UAClB;AACA,eAAK;AAAA,QACP,WAAW,SAAS,KAAK;AAEvB;AAAA,QACF,OAAO;AACL,mBAAS;AACT;AAAA,QACF;AAAA,MACF;AAGA,UAAI,MAAM,KAAK,EAAE,SAAS,GAAG;AAC3B,eAAO,MAAM,KAAK;AAAA,MACpB;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAUO,SAAS,oBAAoB,SAAsC;AACxE,MAAI,YAAY,UAAa,YAAY,KAAM,QAAO;AAEtD,MAAI,SAAS;AAGb,MAAI,OAAO,YAAY,UAAU;AAC/B,UAAM,UAAU,QAAQ,KAAK;AAG7B,QAAI,CAAC,QAAQ,WAAW,GAAG,KAAK,CAAC,QAAQ,WAAW,GAAG,GAAG;AACxD,aAAO,QAAQ,SAAS,IAAI,UAAU;AAAA,IACxC;AAGA,QAAI;AACF,eAAS,KAAK,MAAM,OAAO;AAAA,IAC7B,QAAQ;AAGN,YAAM,YAAY,kCAAkC,OAAO;AAC3D,UAAI,WAAW;AACb,eAAO;AAAA,MACT;AAEA,aAAO,QAAQ,SAAS,IAAI,UAAU;AAAA,IACxC;AAAA,EACF;AAGA,MAAI,UAAU,OAAO,WAAW,UAAU;AACxC,UAAM,MACH,OAAmC,QACnC,OAAmC,YACnC,OAAmC;AACtC,QAAI,OAAO,QAAQ,YAAY,IAAI,KAAK,GAAG;AACzC,aAAO,IAAI,KAAK;AAAA,IAClB;AAAA,EACF;AAGA,MAAI,OAAO,YAAY,UAAU;AAC/B,UAAM,UAAU,QAAQ,KAAK;AAC7B,WAAO,QAAQ,SAAS,IAAI,UAAU;AAAA,EACxC;AAEA,SAAO;AACT;AAtIA;AAAA;AAAA;AAAA;AAAA;","names":[]}