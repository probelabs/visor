{"version":3,"sources":["../../src/slack/client.ts","../../src/slack/markdown.ts","../../src/frontends/slack-frontend.ts"],"sourcesContent":["// Lightweight Slack Web API wrapper implemented with fetch (no external deps).\n// Only methods needed by SlackFrontend are implemented.\n\nexport class SlackClient {\n  private token: string;\n\n  constructor(botToken: string) {\n    if (!botToken || typeof botToken !== 'string') {\n      throw new Error('SlackClient: botToken is required');\n    }\n    this.token = botToken;\n  }\n\n  public readonly reactions = {\n    add: async ({\n      channel,\n      timestamp,\n      name,\n    }: {\n      channel: string;\n      timestamp: string;\n      name: string;\n    }) => {\n      const resp: any = await this.api('reactions.add', { channel, timestamp, name });\n      if (!resp || resp.ok !== true) {\n        // Non-fatal in CLI/test runs ‚Äì log and continue\n        const err = (resp && resp.error) || 'unknown_error';\n        console.warn(`Slack reactions.add failed (non-fatal): ${err}`);\n        return { ok: false as const };\n      }\n      return { ok: true } as const;\n    },\n    remove: async ({\n      channel,\n      timestamp,\n      name,\n    }: {\n      channel: string;\n      timestamp: string;\n      name: string;\n    }) => {\n      const resp: any = await this.api('reactions.remove', { channel, timestamp, name });\n      if (!resp || resp.ok !== true) {\n        const err = (resp && resp.error) || 'unknown_error';\n        console.warn(`Slack reactions.remove failed (non-fatal): ${err}`);\n        return { ok: false as const };\n      }\n      return { ok: true } as const;\n    },\n  };\n\n  public readonly chat = {\n    postMessage: async ({\n      channel,\n      text,\n      thread_ts,\n    }: {\n      channel: string;\n      text: string;\n      thread_ts?: string;\n    }) => {\n      try {\n        const resp: any = await this.api('chat.postMessage', { channel, text, thread_ts });\n        if (!resp || resp.ok !== true) {\n          const err = (resp && resp.error) || 'unknown_error';\n          const warnings = Array.isArray(resp?.response_metadata?.warnings)\n            ? resp.response_metadata.warnings.join(',')\n            : '';\n          console.warn(\n            `Slack chat.postMessage failed (non-fatal): error=${err} channel=${channel} thread_ts=${\n              thread_ts || '-'\n            } text_len=${text.length}${warnings ? ` warnings=${warnings}` : ''}`\n          );\n          return {\n            ok: false as const,\n            ts: undefined,\n            message: undefined,\n            data: resp,\n            error: err,\n          };\n        }\n        // Normalize common fields for tests/frontend\n        return {\n          ok: true as const,\n          ts: resp.ts || (resp.message && resp.message.ts) || undefined,\n          message: resp.message,\n          data: resp,\n          error: undefined,\n        };\n      } catch (e) {\n        console.warn(\n          `Slack chat.postMessage threw (non-fatal): channel=${channel} thread_ts=${thread_ts || '-'} text_len=${\n            text.length\n          } error=${e instanceof Error ? e.message : String(e)}`\n        );\n        return {\n          ok: false as const,\n          ts: undefined,\n          message: undefined,\n          data: undefined,\n          error: e instanceof Error ? e.message : String(e),\n        };\n      }\n    },\n    update: async ({ channel, ts, text }: { channel: string; ts: string; text: string }) => {\n      try {\n        const resp: any = await this.api('chat.update', { channel, ts, text });\n        if (!resp || resp.ok !== true) {\n          const err = (resp && resp.error) || 'unknown_error';\n          const warnings = Array.isArray(resp?.response_metadata?.warnings)\n            ? resp.response_metadata.warnings.join(',')\n            : '';\n          console.warn(\n            `Slack chat.update failed (non-fatal): error=${err} channel=${channel} ts=${ts} text_len=${\n              text.length\n            }${warnings ? ` warnings=${warnings}` : ''}`\n          );\n          return { ok: false as const, ts, error: err, data: resp };\n        }\n        return { ok: true as const, ts: resp.ts || ts, error: undefined, data: resp };\n      } catch (e) {\n        console.warn(\n          `Slack chat.update threw (non-fatal): channel=${channel} ts=${ts} text_len=${text.length} error=${\n            e instanceof Error ? e.message : String(e)\n          }`\n        );\n        return {\n          ok: false as const,\n          ts,\n          error: e instanceof Error ? e.message : String(e),\n          data: undefined,\n        };\n      }\n    },\n  };\n\n  async getBotUserId(): Promise<string> {\n    const resp: any = await this.api('auth.test', {});\n    if (!resp || resp.ok !== true || !resp.user_id) {\n      console.warn('Slack auth.test failed (non-fatal); bot user id unavailable');\n      return 'UNKNOWN_BOT';\n    }\n    return String(resp.user_id);\n  }\n\n  /**\n   * Fetch user info from Slack API.\n   * Returns user profile including guest status flags, email, display name, and timezone.\n   */\n  async getUserInfo(userId: string): Promise<{\n    ok: boolean;\n    user?: {\n      id: string;\n      name?: string; // username\n      real_name?: string; // full name\n      email?: string; // requires users:read.email scope\n      is_restricted?: boolean; // Multi-channel guest\n      is_ultra_restricted?: boolean; // Single-channel guest\n      is_bot?: boolean;\n      is_app_user?: boolean;\n      deleted?: boolean;\n      tz?: string; // IANA timezone (e.g., \"America/New_York\")\n      tz_offset?: number; // Timezone offset in seconds from UTC\n    };\n  }> {\n    try {\n      const resp: any = await this.api('users.info', { user: userId });\n      if (!resp || resp.ok !== true || !resp.user) {\n        return { ok: false };\n      }\n      return {\n        ok: true,\n        user: {\n          id: resp.user.id,\n          name: resp.user.name,\n          real_name: resp.user.real_name || resp.user.profile?.real_name,\n          email: resp.user.profile?.email,\n          is_restricted: resp.user.is_restricted,\n          is_ultra_restricted: resp.user.is_ultra_restricted,\n          is_bot: resp.user.is_bot,\n          is_app_user: resp.user.is_app_user,\n          deleted: resp.user.deleted,\n          tz: resp.user.tz,\n          tz_offset: resp.user.tz_offset,\n        },\n      };\n    } catch (e) {\n      console.warn(`Slack users.info failed: ${e instanceof Error ? e.message : String(e)}`);\n      return { ok: false };\n    }\n  }\n\n  /**\n   * Open a DM channel with a user.\n   * Returns the DM channel ID.\n   */\n  async openDM(userId: string): Promise<{ ok: boolean; channel?: string }> {\n    try {\n      const resp: any = await this.api('conversations.open', { users: userId });\n      if (!resp || resp.ok !== true || !resp.channel?.id) {\n        console.warn(`Slack conversations.open failed: ${resp?.error || 'unknown_error'}`);\n        return { ok: false };\n      }\n      return { ok: true, channel: resp.channel.id };\n    } catch (e) {\n      console.warn(\n        `Slack conversations.open failed: ${e instanceof Error ? e.message : String(e)}`\n      );\n      return { ok: false };\n    }\n  }\n\n  async fetchThreadReplies(\n    channel: string,\n    thread_ts: string,\n    limit: number = 40\n  ): Promise<\n    Array<{\n      ts: string;\n      user?: string;\n      text?: string;\n      bot_id?: string;\n      thread_ts?: string;\n      files?: any[];\n    }>\n  > {\n    try {\n      // Use query-string GET semantics similar to Slack WebClient to avoid\n      // subtle JSON/form encoding issues that can cause invalid_arguments\n      const params = new URLSearchParams({\n        channel,\n        ts: thread_ts,\n        limit: String(limit),\n      });\n      const res = await fetch(`https://slack.com/api/conversations.replies?${params.toString()}`, {\n        method: 'GET',\n        headers: {\n          Authorization: `Bearer ${this.token}`,\n        },\n      });\n      const resp: any = await res.json();\n      if (!resp || resp.ok !== true || !Array.isArray(resp.messages)) {\n        const err = (resp && resp.error) || 'unknown_error';\n        console.warn(\n          `Slack conversations.replies failed (non-fatal): ${err} (channel=${channel}, ts=${thread_ts}, limit=${limit})`\n        );\n        return [];\n      }\n      return resp.messages.map((m: any) => ({\n        ts: String(m.ts || ''),\n        user: m.user,\n        text: m.text,\n        bot_id: m.bot_id,\n        thread_ts: m.thread_ts,\n        files: Array.isArray(m.files) ? m.files : undefined,\n      }));\n    } catch (e) {\n      console.warn(\n        `Slack conversations.replies failed (non-fatal): ${\n          e instanceof Error ? e.message : String(e)\n        } (channel=${channel}, ts=${thread_ts}, limit=${limit})`\n      );\n      return [];\n    }\n  }\n\n  public readonly files = {\n    /**\n     * Upload a file to Slack using files.uploadV2 API\n     * @param options Upload options including file content, filename, channel, and thread_ts\n     */\n    uploadV2: async ({\n      content,\n      filename,\n      channel,\n      thread_ts,\n      title,\n      initial_comment,\n    }: {\n      content: Buffer;\n      filename: string;\n      channel: string;\n      thread_ts?: string;\n      title?: string;\n      initial_comment?: string;\n    }): Promise<{ ok: boolean; file?: { id: string; permalink?: string } }> => {\n      try {\n        // Step 1: Get upload URL (uses form-urlencoded ‚Äî this endpoint rejects JSON bodies)\n        const getUrlResp: any = await this.apiForm('files.getUploadURLExternal', {\n          filename,\n          length: String(content.length),\n        });\n        if (!getUrlResp || getUrlResp.ok !== true || !getUrlResp.upload_url) {\n          console.warn(\n            `Slack files.getUploadURLExternal failed: ${getUrlResp?.error || 'unknown'}`\n          );\n          return { ok: false };\n        }\n\n        // Step 2: Upload file content to the URL\n        const uploadResp = await fetch(getUrlResp.upload_url, {\n          method: 'POST',\n          body: content,\n        });\n        if (!uploadResp.ok) {\n          console.warn(`Slack file upload to URL failed: ${uploadResp.status}`);\n          return { ok: false };\n        }\n\n        // Step 3: Complete the upload and share to channel\n        const completeResp: any = await this.api('files.completeUploadExternal', {\n          files: [{ id: getUrlResp.file_id, title: title || filename }],\n          channel_id: channel,\n          thread_ts,\n          initial_comment,\n        });\n        if (!completeResp || completeResp.ok !== true) {\n          console.warn(\n            `Slack files.completeUploadExternal failed: ${completeResp?.error || 'unknown'}`\n          );\n          return { ok: false };\n        }\n\n        return {\n          ok: true,\n          file: completeResp.files?.[0] || { id: getUrlResp.file_id },\n        };\n      } catch (e) {\n        console.warn(`Slack file upload failed: ${e instanceof Error ? e.message : String(e)}`);\n        return { ok: false };\n      }\n    },\n  };\n\n  getWebClient(): any {\n    return {\n      conversations: {\n        history: async ({ channel, limit }: { channel: string; limit?: number }) =>\n          (await this.api('conversations.history', { channel, limit })) as any,\n        open: async ({ users }: { users: string }) =>\n          (await this.api('conversations.open', { users })) as any,\n        replies: async ({ channel, ts, limit }: { channel: string; ts: string; limit?: number }) =>\n          (await this.api('conversations.replies', { channel, ts, limit })) as any,\n      },\n    };\n  }\n\n  private async api(method: string, body: Record<string, unknown>): Promise<unknown> {\n    // Node 18+ global fetch\n    const res = await fetch(`https://slack.com/api/${method}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json; charset=utf-8',\n        Authorization: `Bearer ${this.token}`,\n      },\n      body: JSON.stringify(body),\n    });\n    return (await res.json()) as unknown;\n  }\n\n  /** Send a Slack API request as application/x-www-form-urlencoded (required by some file methods). */\n  private async apiForm(method: string, params: Record<string, string>): Promise<unknown> {\n    const body = new URLSearchParams(params);\n    const res = await fetch(`https://slack.com/api/${method}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        Authorization: `Bearer ${this.token}`,\n      },\n      body: body.toString(),\n    });\n    return (await res.json()) as unknown;\n  }\n}\n","// Lightweight Markdown ‚Üí Slack mrkdwn formatter.\n// The goal is to make common Markdown output from AI steps look natural in Slack\n// without pulling in a full Markdown parser.\n//\n// Supported conversions:\n// - # Header / ## Header  ‚Üí *Header* (bold with visual separation)\n// - **bold** / __bold__   ‚Üí *bold*\n// - [label](url)          ‚Üí <url|label>\n// - ![alt](url)           ‚Üí <url|alt>\n// - *italic* (inline)     ‚Üí _italic_\n// - ```mermaid blocks     ‚Üí rendered to PNG and uploaded to Slack\n//\n// Everything else is passed through unchanged; Slack will still render many\n// Markdown-like constructs (lists, code fences, etc.) natively.\n\nimport { spawn } from 'child_process';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as os from 'os';\n\n/**\n * Represents an extracted mermaid diagram\n */\nexport interface MermaidDiagram {\n  /** The full match including ```mermaid and ``` */\n  fullMatch: string;\n  /** The mermaid code content */\n  code: string;\n  /** Start index in the original text */\n  startIndex: number;\n  /** End index in the original text */\n  endIndex: number;\n}\n\n/**\n * Extract all mermaid code blocks from text\n */\nexport function extractMermaidDiagrams(text: string): MermaidDiagram[] {\n  const diagrams: MermaidDiagram[] = [];\n  // Match ```mermaid followed by newline, content, and closing ```\n  const regex = /```mermaid\\s*\\n([\\s\\S]*?)```/g;\n  let match;\n  while ((match = regex.exec(text)) !== null) {\n    diagrams.push({\n      fullMatch: match[0],\n      code: match[1].trim(),\n      startIndex: match.index,\n      endIndex: match.index + match[0].length,\n    });\n  }\n  return diagrams;\n}\n\n/**\n * Render a mermaid diagram to PNG using mmdc CLI (@mermaid-js/mermaid-cli).\n *\n * Requirements:\n * - Node.js and npx must be available in PATH\n * - Network access on first run (npx downloads the package)\n * - Puppeteer/Chromium dependencies (mermaid-cli uses headless browser)\n *\n * On Linux, you may need to install chromium dependencies:\n *   apt-get install -y chromium-browser libatk-bridge2.0-0 libgtk-3-0\n *\n * On Docker/CI, consider using a base image with puppeteer support or\n * pre-installing @mermaid-js/mermaid-cli globally.\n *\n * @param mermaidCode The mermaid diagram code\n * @returns Buffer containing PNG data, or null if rendering failed\n */\nexport async function renderMermaidToPng(mermaidCode: string): Promise<Buffer | null> {\n  // Create temp files for input and output\n  const tmpDir = os.tmpdir();\n  const inputFile = path.join(\n    tmpDir,\n    `mermaid-${Date.now()}-${Math.random().toString(36).slice(2)}.mmd`\n  );\n  const outputFile = path.join(\n    tmpDir,\n    `mermaid-${Date.now()}-${Math.random().toString(36).slice(2)}.png`\n  );\n\n  try {\n    // Write mermaid code to temp file\n    fs.writeFileSync(inputFile, mermaidCode, 'utf-8');\n\n    // Detect system chromium for puppeteer (mermaid-cli dependency)\n    // Without this, puppeteer may hang trying to download its own chromium\n    const chromiumPaths = [\n      '/usr/bin/chromium',\n      '/usr/bin/chromium-browser',\n      '/usr/bin/google-chrome',\n      '/usr/bin/chrome',\n    ];\n    let chromiumPath: string | undefined;\n    for (const p of chromiumPaths) {\n      if (fs.existsSync(p)) {\n        chromiumPath = p;\n        break;\n      }\n    }\n\n    // Build environment with chromium path if found\n    const env = { ...process.env };\n    if (chromiumPath) {\n      env.PUPPETEER_EXECUTABLE_PATH = chromiumPath;\n    }\n\n    // Run mmdc to render PNG\n    const result = await new Promise<{ success: boolean; error?: string }>(resolve => {\n      const proc = spawn(\n        'npx',\n        [\n          '--yes',\n          '@mermaid-js/mermaid-cli',\n          '-i',\n          inputFile,\n          '-o',\n          outputFile,\n          '-e',\n          'png',\n          '-b',\n          'white',\n          '-w',\n          '1200',\n        ],\n        {\n          timeout: 60000, // 60 second timeout (first run may download packages)\n          stdio: ['pipe', 'pipe', 'pipe'],\n          env,\n        }\n      );\n\n      let stderr = '';\n      proc.stderr?.on('data', data => {\n        stderr += data.toString();\n      });\n\n      proc.on('close', code => {\n        if (code === 0) {\n          resolve({ success: true });\n        } else {\n          resolve({ success: false, error: stderr || `Exit code ${code}` });\n        }\n      });\n\n      proc.on('error', err => {\n        resolve({ success: false, error: err.message });\n      });\n    });\n\n    if (!result.success) {\n      console.warn(`Mermaid rendering failed: ${result.error}`);\n      return null;\n    }\n\n    // Read the output PNG\n    if (!fs.existsSync(outputFile)) {\n      console.warn('Mermaid output file not created');\n      return null;\n    }\n\n    const pngBuffer = fs.readFileSync(outputFile);\n    return pngBuffer;\n  } catch (e) {\n    console.warn(`Mermaid rendering error: ${e instanceof Error ? e.message : String(e)}`);\n    return null;\n  } finally {\n    // Cleanup temp files\n    try {\n      if (fs.existsSync(inputFile)) fs.unlinkSync(inputFile);\n      if (fs.existsSync(outputFile)) fs.unlinkSync(outputFile);\n    } catch {\n      // Ignore cleanup errors\n    }\n  }\n}\n\n/**\n * Replace mermaid blocks in text with a placeholder message\n * @param text Original text\n * @param diagrams Extracted diagrams\n * @param replacement Text to replace each diagram with (or a function that returns replacement for each index)\n */\nexport function replaceMermaidBlocks(\n  text: string,\n  diagrams: MermaidDiagram[],\n  replacement: string | ((index: number) => string) = '_(See diagram above)_'\n): string {\n  if (diagrams.length === 0) return text;\n\n  // Sort by start index descending to replace from end to start (preserves indices)\n  const sorted = [...diagrams].sort((a, b) => b.startIndex - a.startIndex);\n\n  let result = text;\n  sorted.forEach((diagram, sortedIndex) => {\n    // Calculate original index (since we sorted in reverse)\n    const originalIndex = diagrams.length - 1 - sortedIndex;\n    const rep = typeof replacement === 'function' ? replacement(originalIndex) : replacement;\n    result = result.slice(0, diagram.startIndex) + rep + result.slice(diagram.endIndex);\n  });\n\n  return result;\n}\n\nexport function markdownToSlack(text: string): string {\n  if (!text || typeof text !== 'string') return '';\n\n  let out = text;\n\n  // Images: ![alt](url) ‚Üí <url|alt>\n  // We intentionally keep only the URL + alt text; Slack will usually unfurl.\n  out = out.replace(\n    /!\\[([^\\]]*)\\]\\(([^)\\s]+)(?:\\s+\"[^\"]*\")?\\)/g,\n    (_m, alt: string, url: string) => `<${url}|${alt || 'image'}>`\n  );\n\n  // Links: [label](url) ‚Üí <url|label>\n  out = out.replace(\n    /\\[([^\\]]+)\\]\\(([^)\\s]+)(?:\\s+\"[^\"]*\")?\\)/g,\n    (_m, label: string, url: string) => `<${url}|${label}>`\n  );\n\n  // Bold: **text** or __text__ ‚Üí *text*\n  out = out.replace(/\\*\\*([^*]+)\\*\\*/g, (_m, inner: string) => `*${inner}*`);\n  out = out.replace(/__([^_]+)__/g, (_m, inner: string) => `*${inner}*`);\n\n  // Process lines for headers and bullet lists.\n  // Slack's mrkdwn handles \"‚Ä¢\" bullets more naturally than raw \"-\" Markdown.\n  const lines = out.split(/\\r?\\n/);\n  let inCodeBlock = false;\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const trimmed = line.trimStart();\n    // Track fenced code blocks and avoid rewriting inside them\n    if (/^```/.test(trimmed)) {\n      inCodeBlock = !inCodeBlock;\n      continue;\n    }\n    if (inCodeBlock) continue;\n\n    // Headers: # Header ‚Üí *Header* (Slack doesn't have native headers)\n    // Match 1-6 # at start of line, followed by space and text\n    const headerMatch = /^(#{1,6})\\s+(.+)$/.exec(trimmed);\n    if (headerMatch) {\n      const [, hashes, headerText] = headerMatch;\n      // For h1/h2, add extra emphasis with newline before (if not first line\n      // and previous line is not empty/header/code-fence)\n      const prevLine = i > 0 ? lines[i - 1].trim() : '';\n      const prevIsHeaderOrFence =\n        /^#{1,6}\\s+/.test(prevLine) || /^\\*[^*]+\\*$/.test(prevLine) || /^```/.test(prevLine);\n      if (hashes.length <= 2 && i > 0 && prevLine !== '' && !prevIsHeaderOrFence) {\n        lines[i] = `\\n*${headerText.trim()}*`;\n      } else {\n        lines[i] = `*${headerText.trim()}*`;\n      }\n      continue;\n    }\n\n    // Bullet lists: \"- item\" or \"* item\" ‚Üí \"‚Ä¢ item\" (preserve indentation)\n    const bulletMatch = /^(\\s*)([-*])\\s+(.+)$/.exec(line);\n    if (bulletMatch) {\n      const [, indent, , rest] = bulletMatch;\n      lines[i] = `${indent}‚Ä¢ ${rest}`;\n    }\n  }\n  out = lines.join('\\n');\n\n  return out;\n}\n\n/**\n * Represents an extracted file section delimited by --- filename.ext ---\n */\nexport interface FileSection {\n  /** Full match including delimiter(s) and content */\n  fullMatch: string;\n  /** Extracted filename (e.g., \"report.csv\") */\n  filename: string;\n  /** Content after the opening delimiter (trimmed) */\n  content: string;\n  /** Start index in the original text */\n  startIndex: number;\n  /** End index in the original text */\n  endIndex: number;\n}\n\n/**\n * Extract all file sections delimited by --- filename.ext --- from text.\n *\n * A section starts at a `--- filename.ext ---` line. It ends at:\n *   1. A closing delimiter with the same filename (optional, backward-compatible)\n *   2. The next `--- other.ext ---` delimiter (starts a new section)\n *   3. End of text\n */\nexport function extractFileSections(text: string): FileSection[] {\n  const sections: FileSection[] = [];\n\n  // Find all --- filename.ext --- delimiter lines\n  const delimRegex = /^--- ([\\w][\\w.\\-]*\\.\\w+) ---$/gm;\n  const delimiters: { filename: string; start: number; end: number }[] = [];\n  let m;\n  while ((m = delimRegex.exec(text)) !== null) {\n    delimiters.push({\n      filename: m[1],\n      start: m.index,\n      end: m.index + m[0].length,\n    });\n  }\n\n  if (delimiters.length === 0) return sections;\n\n  for (let i = 0; i < delimiters.length; i++) {\n    const open = delimiters[i];\n\n    // Content starts after the newline following the opening delimiter\n    const contentStart =\n      open.end < text.length && text[open.end] === '\\n' ? open.end + 1 : open.end;\n\n    // Section extends to the next delimiter or end of text\n    const sectionEnd = i + 1 < delimiters.length ? delimiters[i + 1].start : text.length;\n    const content = text.substring(contentStart, sectionEnd).trim();\n    if (content.length > 0) {\n      sections.push({\n        fullMatch: text.substring(open.start, sectionEnd),\n        filename: open.filename,\n        content,\n        startIndex: open.start,\n        endIndex: sectionEnd,\n      });\n    }\n  }\n\n  return sections;\n}\n\n/**\n * Replace file sections in text with placeholder messages.\n * Uses back-to-front replacement to preserve indices (same as replaceMermaidBlocks).\n */\nexport function replaceFileSections(\n  text: string,\n  sections: FileSection[],\n  replacement: string | ((index: number) => string) = idx =>\n    `_(See file: ${sections[idx].filename} above)_`\n): string {\n  if (sections.length === 0) return text;\n\n  const sorted = [...sections].sort((a, b) => b.startIndex - a.startIndex);\n\n  let result = text;\n  sorted.forEach((section, sortedIndex) => {\n    const originalIndex = sections.length - 1 - sortedIndex;\n    const rep = typeof replacement === 'function' ? replacement(originalIndex) : replacement;\n    result = result.slice(0, section.startIndex) + rep + result.slice(section.endIndex);\n  });\n\n  return result;\n}\n\nexport function formatSlackText(text: string): string {\n  return markdownToSlack(text);\n}\n","/**\n * Slack Frontend for Visor workflows.\n *\n * Features:\n * - Posts AI replies to Slack threads\n * - Converts Markdown to Slack mrkdwn format\n * - Renders mermaid diagrams to PNG and uploads as images\n * - Manages üëÄ/üëç reactions for acknowledgement\n * - Handles human input prompts via prompt-state\n *\n * Mermaid Diagram Rendering:\n * - Detects ```mermaid code blocks in AI responses\n * - Renders to PNG using @mermaid-js/mermaid-cli (mmdc)\n * - Uploads rendered images to Slack thread\n * - Replaces mermaid blocks with \"_(See diagram above)_\" placeholder\n *\n * Requirements for mermaid rendering:\n * - Node.js and npx in PATH\n * - Puppeteer/Chromium dependencies (mermaid-cli uses headless browser)\n * - On Linux: apt-get install chromium-browser libatk-bridge2.0-0 libgtk-3-0\n */\nimport type { Frontend, FrontendContext } from './host';\nimport { SlackClient } from '../slack/client';\nimport {\n  formatSlackText,\n  extractMermaidDiagrams,\n  renderMermaidToPng,\n  replaceMermaidBlocks,\n  extractFileSections,\n  replaceFileSections,\n} from '../slack/markdown';\nimport { context as otContext, trace } from '../telemetry/lazy-otel';\n\ntype SlackFrontendConfig = {\n  defaultChannel?: string;\n  groupChannels?: Record<string, string>;\n  debounceMs?: number;\n  maxWaitMs?: number;\n  showRawOutput?: boolean;\n  telemetry?: {\n    enabled?: boolean;\n  };\n};\n\nexport class SlackFrontend implements Frontend {\n  public readonly name = 'slack';\n  private subs: Array<{ unsubscribe(): void }> = [];\n  private cfg: SlackFrontendConfig;\n  // Reactions ack/done per run (inbound Slack events only)\n  private acked: boolean = false;\n  private ackRef: { channel: string; ts: string } | null = null;\n  private ackName: string = 'eyes';\n  private doneName: string = 'thumbsup';\n  private errorNotified: boolean = false;\n  private cachedTraceInfo: { traceId: string; spanId: string } | null = null;\n\n  constructor(config?: SlackFrontendConfig) {\n    this.cfg = config || {};\n  }\n\n  start(ctx: FrontendContext): void {\n    const bus = ctx.eventBus;\n\n    // Capture trace info now while the OTel span may still be active.\n    // EventBus handlers run in a different async context where the span is lost.\n    if (!this.cachedTraceInfo) {\n      this.cachedTraceInfo = this.getTraceInfo();\n    }\n    // Also check ctx.run.traceId which is injected by the execution engine\n    if (!this.cachedTraceInfo) {\n      const runTraceId = (ctx as any)?.run?.traceId;\n      if (typeof runTraceId === 'string' && runTraceId) {\n        this.cachedTraceInfo = { traceId: runTraceId, spanId: '' };\n      }\n    }\n\n    // Info-level boot log\n    try {\n      const hasClient = !!(\n        (ctx as any).slack ||\n        (ctx as any).slackClient ||\n        (this.cfg as any)?.botToken ||\n        process.env.SLACK_BOT_TOKEN\n      );\n      ctx.logger.info(`[slack-frontend] started; hasClient=${hasClient} defaultChannel=unset`);\n    } catch {}\n\n    // If this run was triggered by a Slack event, log key attributes\n    try {\n      const payload = this.getInboundSlackPayload(ctx);\n      if (payload) {\n        const ev: any = payload.event || {};\n        const ch = String(ev.channel || '-');\n        const ts = String(ev.ts || ev.event_ts || '-');\n        const user = String(ev.user || ev.bot_id || '-');\n        const type = String(ev.type || '-');\n        const thread = String(ev.thread_ts || '');\n        ctx.logger.info(\n          `[slack-frontend] inbound event received: type=${type} channel=${ch} ts=${ts}` +\n            (thread ? ` thread_ts=${thread}` : '') +\n            ` user=${user}`\n        );\n      }\n    } catch {}\n\n    // Listen to check lifecycle; we only post on completion/error (no queued placeholders)\n    this.subs.push(\n      bus.on('CheckCompleted', async (env: any) => {\n        const ev = (env && env.payload) || env;\n        // For chat-style AI checks, post direct replies into the Slack thread\n        await this.maybePostDirectReply(ctx, ev.checkId, ev.result).catch(() => {});\n        // Post execution failure notices when a check completes with fatal issues\n        await this.maybePostExecutionFailure(ctx, ev.checkId, ev.result).catch(() => {});\n      })\n    );\n    this.subs.push(\n      bus.on('CheckErrored', async (env: any) => {\n        const ev = (env && env.payload) || env;\n        const message = ev?.error?.message || 'Execution error';\n        await this.maybePostError(ctx, 'Check failed', message, ev?.checkId).catch(() => {});\n      })\n    );\n\n    // On terminal state, replace üëÄ with üëç if we acked an inbound Slack message\n    this.subs.push(\n      bus.on('StateTransition', async (env: any) => {\n        const ev = (env && env.payload) || env;\n        if (ev && (ev.to === 'Completed' || ev.to === 'Error')) {\n          await this.finalizeReactions(ctx).catch(() => {});\n        }\n      })\n    );\n    this.subs.push(\n      bus.on('Shutdown', async (env: any) => {\n        const ev = (env && env.payload) || env;\n        const message = ev?.error?.message || 'Fatal error';\n        await this.maybePostError(ctx, 'Run failed', message).catch(() => {});\n      })\n    );\n    // Add üëÄ acknowledgement as soon as first check is scheduled for Slack-driven runs\n    this.subs.push(\n      bus.on('CheckScheduled', async () => {\n        await this.ensureAcknowledgement(ctx).catch(() => {});\n      })\n    );\n\n    // Human-input requests: post prompt to Slack and mark waiting using prompt-state\n    this.subs.push(\n      bus.on('HumanInputRequested', async (env: any) => {\n        try {\n          const ev = (env && env.payload) || env;\n          if (!ev || typeof ev.prompt !== 'string' || !ev.checkId) return;\n          // Determine channel/thread (Slack SocketMode); if we can't, just ignore.\n          let channel = ev.channel as string | undefined;\n          let threadTs = ev.threadTs as string | undefined;\n          if (!channel || !threadTs) {\n            const payload = this.getInboundSlackPayload(ctx);\n            const e: any = payload?.event;\n            const derivedTs = String(e?.thread_ts || e?.ts || e?.event_ts || '');\n            const derivedCh = String(e?.channel || '');\n            if (derivedCh && derivedTs) {\n              channel = channel || derivedCh;\n              threadTs = threadTs || derivedTs;\n            }\n          }\n          if (!channel || !threadTs) return;\n\n          // Mark waiting in prompt-state without posting the prompt text to Slack.\n          const { getPromptStateManager } = await import('../slack/prompt-state');\n          const mgr = getPromptStateManager();\n          const prev = mgr.getWaiting(channel, threadTs);\n          const text = String(ev.prompt);\n          mgr.setWaiting(channel, threadTs, {\n            checkName: String(ev.checkId),\n            prompt: text,\n            promptMessageTs: prev?.promptMessageTs,\n            promptsPosted: ((prev?.promptsPosted || 0) + 1) as any,\n          });\n          try {\n            ctx.logger.info(\n              `[slack-frontend] registered human-input waiting state for ${channel} thread=${threadTs}`\n            );\n          } catch {}\n        } catch (e) {\n          try {\n            ctx.logger.warn(\n              `[slack-frontend] HumanInputRequested handling failed: ${\n                e instanceof Error ? e.message : String(e)\n              }`\n            );\n          } catch {}\n        }\n      })\n    );\n\n    // SnapshotSaved: attach snapshot path to waiting entry for this thread\n    this.subs.push(\n      bus.on('SnapshotSaved', async (env: any) => {\n        try {\n          const ev = (env && env.payload) || env;\n          const channel = String(ev?.channel || '');\n          const threadTs = String(ev?.threadTs || '');\n          const filePath = String(ev?.filePath || '');\n          if (!channel || !threadTs || !filePath) return;\n          const { getPromptStateManager } = await import('../slack/prompt-state');\n          const mgr = getPromptStateManager();\n          mgr.update(channel, threadTs, { snapshotPath: filePath });\n          try {\n            ctx.logger.info(\n              `[slack-frontend] snapshot path attached to waiting prompt: ${filePath}`\n            );\n          } catch {}\n        } catch {}\n      })\n    );\n  }\n\n  stop(): void {\n    for (const s of this.subs) s.unsubscribe();\n    this.subs = [];\n  }\n\n  private getSlack(ctx: FrontendContext): any | undefined {\n    // Prefer injected fake client in tests: ctx.slack or ctx.slackClient\n    const injected = (ctx as any).slack || (ctx as any).slackClient;\n    if (injected) return injected;\n    // Else try to lazy-create from env or frontend config\n    try {\n      const token = (this.cfg as any)?.botToken || process.env.SLACK_BOT_TOKEN;\n      if (typeof token === 'string' && token.trim()) {\n        return new SlackClient(token.trim());\n      }\n    } catch {}\n    return undefined;\n  }\n\n  private getInboundSlackPayload(ctx: FrontendContext): any | null {\n    try {\n      const anyCfg: any = ctx.config || {};\n      const slackCfg: any = anyCfg.slack || {};\n      const endpoint: string = slackCfg.endpoint || '/bots/slack/support';\n      const payload: any = (ctx as any).webhookContext?.webhookData?.get(endpoint);\n      return payload || null;\n    } catch {\n      return null;\n    }\n  }\n\n  private getInboundSlackEvent(ctx: FrontendContext): { channel: string; ts: string } | null {\n    try {\n      const payload = this.getInboundSlackPayload(ctx);\n      const ev: any = payload?.event;\n      const channel = String(ev?.channel || '');\n      const ts = String(ev?.ts || ev?.event_ts || '');\n      if (channel && ts) return { channel, ts };\n    } catch {}\n    return null;\n  }\n\n  private isTelemetryEnabled(ctx: FrontendContext): boolean {\n    try {\n      const anyCfg: any = ctx.config || {};\n      const slackCfg: any = anyCfg.slack || {};\n      const telemetryCfg = slackCfg.telemetry ?? (this.cfg as any)?.telemetry;\n      return (\n        telemetryCfg === true ||\n        (telemetryCfg && typeof telemetryCfg === 'object' && telemetryCfg.enabled === true)\n      );\n    } catch {\n      return false;\n    }\n  }\n\n  private async maybePostError(\n    ctx: FrontendContext,\n    title: string,\n    message: string,\n    checkId?: string\n  ): Promise<void> {\n    if (this.errorNotified) return;\n    const slack = this.getSlack(ctx);\n    if (!slack) return;\n    const payload = this.getInboundSlackPayload(ctx);\n    const ev: any = payload?.event;\n    const channel = String(ev?.channel || '');\n    const threadTs = String(ev?.thread_ts || ev?.ts || ev?.event_ts || '');\n    if (!channel || !threadTs) {\n      try {\n        ctx.logger.warn(\n          `[slack-frontend] skip posting error notice: missing channel/thread (channel=${\n            channel || '-'\n          } thread=${threadTs || '-'})`\n        );\n      } catch {}\n      return;\n    }\n\n    let text = `‚ùå ${title}`;\n    if (checkId) text += `\\nCheck: ${checkId}`;\n    if (message) text += `\\n${message}`;\n\n    if (this.isTelemetryEnabled(ctx)) {\n      const traceInfo = this.getTraceInfo() || this.cachedTraceInfo;\n      if (traceInfo?.traceId) {\n        text += `\\n\\n\\`trace_id: ${traceInfo.traceId}\\``;\n      }\n    }\n\n    const formattedText = formatSlackText(text);\n    const postResult = await slack.chat.postMessage({\n      channel,\n      text: formattedText,\n      thread_ts: threadTs,\n    });\n    if (!postResult?.ok) {\n      try {\n        ctx.logger.warn(\n          `[slack-frontend] failed to post error notice to ${channel} thread=${threadTs} check=${\n            checkId || 'run'\n          } error=${postResult?.error || 'unknown_error'}`\n        );\n      } catch {}\n      return;\n    }\n    try {\n      ctx.logger.info(\n        `[slack-frontend] posted error notice to ${channel} thread=${threadTs} check=${checkId || 'run'}`\n      );\n    } catch {}\n    this.errorNotified = true;\n  }\n\n  private isExecutionFailureIssue(issue: any): boolean {\n    const ruleId = String(issue?.ruleId || '');\n    const msg = String(issue?.message || '');\n    const msgLower = msg.toLowerCase();\n    return (\n      ruleId.endsWith('/error') ||\n      ruleId.includes('/execution_error') ||\n      ruleId.includes('timeout') ||\n      ruleId.includes('sandbox_runner_error') ||\n      msgLower.includes('timed out') ||\n      msg.includes('Command execution failed')\n    );\n  }\n\n  private async maybePostExecutionFailure(\n    ctx: FrontendContext,\n    checkId: string,\n    result: { issues?: any[] }\n  ): Promise<void> {\n    try {\n      if (this.errorNotified) return;\n      const cfg: any = ctx.config || {};\n      const checkCfg: any = cfg.checks?.[checkId];\n      if (!checkCfg) return;\n      if (checkCfg.type === 'human-input') return;\n      if (checkCfg.criticality === 'internal') return;\n      const issues = (result as any)?.issues;\n      if (!Array.isArray(issues) || issues.length === 0) return;\n\n      const failureIssue = issues.find(issue => this.isExecutionFailureIssue(issue));\n      if (!failureIssue) return;\n      if (\n        typeof failureIssue.message === 'string' &&\n        failureIssue.message.toLowerCase().includes('awaiting human input')\n      ) {\n        return;\n      }\n\n      const msg =\n        typeof failureIssue.message === 'string' && failureIssue.message.trim().length > 0\n          ? failureIssue.message.trim()\n          : `Execution failed (${String(failureIssue.ruleId || 'unknown')})`;\n      await this.maybePostError(ctx, 'Check failed', msg, checkId);\n    } catch {}\n  }\n\n  private async ensureAcknowledgement(ctx: FrontendContext): Promise<void> {\n    if (this.acked) return;\n    const ref = this.getInboundSlackEvent(ctx);\n    if (!ref) return;\n    const slack = this.getSlack(ctx);\n    if (!slack) return;\n    // Skip ack for our own bot messages to avoid loops (allow other bots)\n    try {\n      const payload = this.getInboundSlackPayload(ctx);\n      const ev: any = payload?.event;\n      // If we can resolve bot user id, skip if the sender is the bot\n      try {\n        const botId = await slack.getBotUserId?.();\n        if (botId && ev?.user && String(ev.user) === String(botId)) return;\n      } catch {}\n    } catch {}\n    // Allow overrides via config\n    try {\n      const anyCfg: any = ctx.config || {};\n      const slackCfg: any = anyCfg.slack || {};\n      if (slackCfg?.reactions?.enabled === false) return;\n      this.ackName = slackCfg?.reactions?.ack || this.ackName;\n      this.doneName = slackCfg?.reactions?.done || this.doneName;\n    } catch {}\n    await slack.reactions.add({ channel: ref.channel, timestamp: ref.ts, name: this.ackName });\n    try {\n      ctx.logger.info(\n        `[slack-frontend] added acknowledgement reaction :${this.ackName}: channel=${ref.channel} ts=${ref.ts}`\n      );\n    } catch {}\n    this.acked = true;\n    this.ackRef = ref;\n    // Capture trace info while span is active (event handlers lose OTel context)\n    if (!this.cachedTraceInfo) {\n      this.cachedTraceInfo = this.getTraceInfo();\n    }\n  }\n\n  private async finalizeReactions(ctx: FrontendContext): Promise<void> {\n    if (!this.acked || !this.ackRef) return;\n    const slack = this.getSlack(ctx);\n    if (!slack) return;\n    try {\n      try {\n        await slack.reactions.remove({\n          channel: this.ackRef.channel,\n          timestamp: this.ackRef.ts,\n          name: this.ackName,\n        });\n      } catch {}\n      await slack.reactions.add({\n        channel: this.ackRef.channel,\n        timestamp: this.ackRef.ts,\n        name: this.doneName,\n      });\n      try {\n        ctx.logger.info(\n          `[slack-frontend] replaced acknowledgement with completion reaction :${this.doneName}: channel=${this.ackRef.channel} ts=${this.ackRef.ts}`\n        );\n      } catch {}\n    } finally {\n      // Reset for safety\n      this.acked = false;\n      this.ackRef = null;\n    }\n  }\n\n  /**\n   * Post direct replies into the originating Slack thread when appropriate.\n   * This is independent of summary messages and is intended for chat-style flows\n   * (e.g., AI answers and explicit chat/notify steps).\n   */\n  private async maybePostDirectReply(\n    ctx: FrontendContext,\n    checkId: string,\n    result: { output?: any; content?: string }\n  ): Promise<void> {\n    try {\n      const cfg: any = ctx.config || {};\n      const checkCfg: any = cfg.checks?.[checkId];\n      if (!checkCfg) return;\n\n      // Per-workflow / per-frontend flag to allow posting raw JSON\n      // outputs for AI steps (useful for debugging router outputs).\n      const slackRoot: any = (cfg as any).slack || {};\n      const showRawOutput =\n        slackRoot.show_raw_output === true || (this.cfg as any)?.showRawOutput === true;\n      const telemetryCfg = slackRoot.telemetry ?? (this.cfg as any)?.telemetry;\n\n      const providerType = (checkCfg.type as string) || '';\n      const isAi = providerType === 'ai';\n      const isLogChat = providerType === 'log' && checkCfg.group === 'chat';\n      const isWorkflow = providerType === 'workflow';\n\n      // Allow ai, log-chat, and workflow types; skip everything else\n      if (!isAi && !isLogChat && !isWorkflow) return;\n\n      // Skip internal steps - they're intermediate processing and shouldn't post to Slack\n      if (checkCfg.criticality === 'internal') return;\n\n      // For AI checks, only post when using simple/unstructured schemas (or none).\n      if (isAi) {\n        const schema = checkCfg.schema;\n        // String schemas: allow only simple/plain ones\n        if (typeof schema === 'string') {\n          const simpleSchemas = ['code-review', 'markdown', 'text', 'plain'];\n          if (!simpleSchemas.includes(schema)) return;\n        }\n        // Object schemas (custom JSON): treat as structured; require output.text\n      }\n\n      const slack = this.getSlack(ctx);\n      if (!slack) return;\n\n      const payload = this.getInboundSlackPayload(ctx);\n      const ev: any = payload?.event;\n      const channel = String(ev?.channel || '');\n      const threadTs = String(ev?.thread_ts || ev?.ts || ev?.event_ts || '');\n      if (!channel || !threadTs) {\n        ctx.logger.warn(\n          `[slack-frontend] skip posting AI reply for ${checkId}: missing channel/thread (channel=${\n            channel || '-'\n          } thread=${threadTs || '-'})`\n        );\n        return;\n      }\n\n      // Prefer output.text; fall back to content ONLY for string/simple schemas.\n      const out: any = (result as any)?.output;\n      let text: string | undefined;\n      if (out && typeof out.text === 'string' && out.text.trim().length > 0) {\n        text = out.text.trim();\n      } else if (isAi && typeof checkCfg.schema === 'string') {\n        if (\n          typeof (result as any)?.content === 'string' &&\n          (result as any).content.trim().length > 0\n        ) {\n          text = (result as any).content.trim();\n        }\n      } else if (isLogChat && typeof (result as any)?.logOutput === 'string') {\n        // For log-based chat checks, render the formatted log output as the\n        // Slack message when no structured text field is present.\n        const raw = (result as any).logOutput;\n        if (raw.trim().length > 0) {\n          text = raw.trim();\n        }\n      } else if (isAi && showRawOutput && out !== undefined) {\n        try {\n          text = JSON.stringify(out, null, 2);\n        } catch {\n          text = String(out);\n        }\n      }\n      // Append raw output from DSL execute_plan (bypasses LLM rewriting chain)\n      if (out && typeof out._rawOutput === 'string' && out._rawOutput.trim().length > 0) {\n        text = (text || '') + '\\n\\n' + out._rawOutput.trim();\n      }\n\n      if (!text) {\n        ctx.logger.info(\n          `[slack-frontend] skip posting AI reply for ${checkId}: no renderable text in check output`\n        );\n        return;\n      }\n\n      // Extract and render mermaid diagrams before posting\n      const diagrams = extractMermaidDiagrams(text);\n      let processedText = text;\n\n      if (diagrams.length > 0) {\n        try {\n          ctx.logger.info(\n            `[slack-frontend] found ${diagrams.length} mermaid diagram(s) to render for ${checkId}`\n          );\n        } catch {}\n\n        // Render and upload each diagram\n        const uploadedCount: number[] = [];\n        for (let i = 0; i < diagrams.length; i++) {\n          const diagram = diagrams[i];\n          try {\n            ctx.logger.info(`[slack-frontend] rendering mermaid diagram ${i + 1}...`);\n            const pngBuffer = await renderMermaidToPng(diagram.code);\n            if (pngBuffer) {\n              ctx.logger.info(\n                `[slack-frontend] rendered diagram ${i + 1}, size=${pngBuffer.length} bytes, uploading...`\n              );\n              const filename = `diagram-${i + 1}.png`;\n              const uploadResult = await slack.files.uploadV2({\n                content: pngBuffer,\n                filename,\n                channel,\n                thread_ts: threadTs,\n                title: `Diagram ${i + 1}`,\n              });\n              if (uploadResult.ok) {\n                uploadedCount.push(i);\n                ctx.logger.info(`[slack-frontend] uploaded mermaid diagram ${i + 1} to ${channel}`);\n              } else {\n                ctx.logger.warn(`[slack-frontend] upload failed for diagram ${i + 1}`);\n              }\n            } else {\n              ctx.logger.warn(\n                `[slack-frontend] mermaid rendering returned null for diagram ${i + 1} (mmdc failed or not installed)`\n              );\n            }\n          } catch (e) {\n            ctx.logger.warn(\n              `[slack-frontend] failed to render/upload mermaid diagram ${i + 1}: ${\n                e instanceof Error ? e.message : String(e)\n              }`\n            );\n          }\n        }\n\n        // Replace mermaid blocks with placeholder text\n        if (uploadedCount.length > 0) {\n          processedText = replaceMermaidBlocks(text, diagrams, idx =>\n            uploadedCount.includes(idx) ? '_(See diagram above)_' : '_(Diagram rendering failed)_'\n          );\n        }\n      }\n\n      // Normalize literal \\n escape sequences from DSL output buffer before extraction.\n      // AI-generated DSL code often writes \"\\\\n\" producing literal backslash-n instead of\n      // actual newlines, which prevents the --- delimiter --- from matching on its own line.\n      processedText = processedText.replace(/\\\\n/g, '\\n');\n\n      // Extract and upload file sections (--- filename.ext --- delimiters)\n      const fileSections = extractFileSections(processedText);\n      if (fileSections.length > 0) {\n        const uploadedFileIndices: number[] = [];\n        for (let i = 0; i < fileSections.length; i++) {\n          const section = fileSections[i];\n          try {\n            const buffer = Buffer.from(section.content, 'utf-8');\n            const uploadResult = await slack.files.uploadV2({\n              content: buffer,\n              filename: section.filename,\n              channel,\n              thread_ts: threadTs,\n              title: section.filename,\n            });\n            if (uploadResult.ok) {\n              uploadedFileIndices.push(i);\n              ctx.logger.info(`[slack-frontend] uploaded file ${section.filename} to ${channel}`);\n            } else {\n              ctx.logger.warn(`[slack-frontend] upload failed for file ${section.filename}`);\n            }\n          } catch (e) {\n            ctx.logger.warn(\n              `[slack-frontend] failed to upload file ${section.filename}: ${\n                e instanceof Error ? e.message : String(e)\n              }`\n            );\n          }\n        }\n        processedText = replaceFileSections(processedText, fileSections, idx =>\n          uploadedFileIndices.includes(idx)\n            ? `_(See file: ${fileSections[idx].filename} above)_`\n            : `_(File upload failed: ${fileSections[idx].filename})_`\n        );\n      }\n\n      let decoratedText = processedText;\n      const telemetryEnabled =\n        telemetryCfg === true ||\n        (telemetryCfg && typeof telemetryCfg === 'object' && telemetryCfg.enabled === true);\n      if (telemetryEnabled) {\n        const traceInfo = this.getTraceInfo() || this.cachedTraceInfo;\n        if (traceInfo?.traceId) {\n          const suffix = `\\`trace_id: ${traceInfo.traceId}\\``;\n          decoratedText = `${decoratedText}\\n\\n${suffix}`;\n        }\n      }\n\n      const formattedText = formatSlackText(decoratedText);\n      const postResult = await slack.chat.postMessage({\n        channel,\n        text: formattedText,\n        thread_ts: threadTs,\n      });\n      if (!postResult?.ok) {\n        ctx.logger.warn(\n          `[slack-frontend] failed to post AI reply for ${checkId} to ${channel} thread=${threadTs} error=${\n            postResult?.error || 'unknown_error'\n          }`\n        );\n        return;\n      }\n      ctx.logger.info(\n        `[slack-frontend] posted AI reply for ${checkId} to ${channel} thread=${threadTs} ts=${\n          postResult.ts || '-'\n        }`\n      );\n\n      // Capture response for scheduled reminders (allows storing previousResponse)\n      const responseCapture = (ctx as any).responseCapture as ((text: string) => void) | undefined;\n      if (responseCapture && typeof responseCapture === 'function') {\n        try {\n          // Store the original text (before mrkdwn formatting) for continuity\n          responseCapture(processedText);\n        } catch {}\n      }\n    } catch (outerErr) {\n      // Log errors instead of silently swallowing them\n      try {\n        ctx.logger.warn(\n          `[slack-frontend] maybePostDirectReply failed for ${checkId}: ${\n            outerErr instanceof Error ? outerErr.message : String(outerErr)\n          }`\n        );\n      } catch {}\n    }\n  }\n\n  private getTraceInfo(): { traceId: string; spanId: string } | null {\n    try {\n      const span = trace.getSpan(otContext.active());\n      if (!span) return null;\n      const ctx = span.spanContext();\n      if (!ctx || !ctx.traceId) return null;\n      return { traceId: ctx.traceId, spanId: ctx.spanId };\n    } catch {\n      return null;\n    }\n  }\n}\n"],"mappings":"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","names":[]}