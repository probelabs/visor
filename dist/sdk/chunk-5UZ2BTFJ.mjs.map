{"version":3,"sources":["../../src/session-registry.ts","../../src/utils/diff-processor.ts","../../src/ai-review-service.ts","../../src/providers/check-provider.interface.ts","../../src/utils/env-resolver.ts","../../src/issue-filter.ts","../../src/telemetry/state-capture.ts","../../src/providers/ai-check-provider.ts","../../src/providers/http-check-provider.ts","../../src/providers/http-input-provider.ts","../../src/providers/http-client-provider.ts","../../src/providers/noop-check-provider.ts","../../src/providers/log-check-provider.ts","../../src/utils/sandbox.ts","../../src/test-runner/recorders/global-recorder.ts","../../src/providers/github-ops-provider.ts","../../src/providers/claude-code-types.ts","../../src/providers/claude-code-check-provider.ts","../../src/utils/command-executor.ts","../../src/utils/env-exposure.ts","../../src/providers/command-check-provider.ts","../../src/utils/template-context.ts","../../src/utils/script-memory-ops.ts","../../src/providers/memory-check-provider.ts","../../src/providers/custom-tool-executor.ts","../../src/providers/mcp-check-provider.ts","../../src/utils/interactive-prompt.ts","../../src/utils/stdin-reader.ts","../../src/providers/human-input-check-provider.ts","../../src/providers/script-check-provider.ts","../../src/workflow-executor.ts","../../src/state-machine/workflow-projection.ts","../../src/state-machine/states/init.ts","../../src/state-machine/states/plan-ready.ts","../../src/state-machine/states/wave-planning.ts","../../src/failure-condition-evaluator.ts","../../src/snapshot-store.ts","../../src/state-machine/states/routing.ts","../../src/state-machine/states/level-dispatch.ts","../../src/state-machine/states/check-running.ts","../../src/state-machine/states/completed.ts","../../src/state-machine/states/error.ts","../../src/state-machine/runner.ts","../../src/providers/workflow-check-provider.ts","../../src/providers/check-provider-registry.ts","../../src/github-comments.ts","../../src/footer.ts","../../src/reviewer.ts","../../src/git-repository-analyzer.ts","../../src/utils/file-exclusion.ts","../../src/pr-analyzer.ts","../../src/check-execution-engine.ts","../../src/github-check-service.ts","../../src/engine/on-finish/utils.ts","../../src/engine/on-finish/orchestrator.ts"],"sourcesContent":["import { ProbeAgent } from '@probelabs/probe';\n\n/**\n * Extended ProbeAgent interface that includes tracing properties\n */\ninterface TracedProbeAgent extends ProbeAgent {\n  tracer?: any; // AppTracer removed from probe\n  _telemetryConfig?: any; // TelemetryConfig removed from probe\n  _traceFilePath?: string;\n}\n\n/**\n * Registry to manage active ProbeAgent sessions for session reuse\n */\nexport class SessionRegistry {\n  private static instance: SessionRegistry;\n  private sessions: Map<string, TracedProbeAgent> = new Map();\n  private exitHandlerRegistered = false;\n\n  private constructor() {\n    // Register process exit handlers to cleanup sessions\n    this.registerExitHandlers();\n  }\n\n  /**\n   * Get the singleton instance of SessionRegistry\n   */\n  public static getInstance(): SessionRegistry {\n    if (!SessionRegistry.instance) {\n      SessionRegistry.instance = new SessionRegistry();\n    }\n    return SessionRegistry.instance;\n  }\n\n  /**\n   * Register a ProbeAgent session\n   */\n  public registerSession(sessionId: string, agent: TracedProbeAgent): void {\n    console.error(`üîÑ Registering AI session: ${sessionId}`);\n    this.sessions.set(sessionId, agent);\n  }\n\n  /**\n   * Get an existing ProbeAgent session\n   */\n  public getSession(sessionId: string): TracedProbeAgent | undefined {\n    const agent = this.sessions.get(sessionId);\n    if (agent) {\n      console.error(`‚ôªÔ∏è  Reusing AI session: ${sessionId}`);\n    }\n    return agent;\n  }\n\n  /**\n   * Remove a session from the registry\n   */\n  public unregisterSession(sessionId: string): void {\n    if (this.sessions.has(sessionId)) {\n      console.error(`üóëÔ∏è  Unregistering AI session: ${sessionId}`);\n      const agent = this.sessions.get(sessionId);\n      this.sessions.delete(sessionId);\n\n      // Cleanup the ProbeAgent instance to prevent hanging processes\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      if (agent && typeof (agent as any).cleanup === 'function') {\n        try {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (agent as any).cleanup();\n        } catch (error) {\n          console.error(`‚ö†Ô∏è  Warning: Failed to cleanup ProbeAgent: ${error}`);\n        }\n      }\n    }\n  }\n\n  /**\n   * Clear all sessions (useful for cleanup)\n   */\n  public clearAllSessions(): void {\n    console.error(`üßπ Clearing all AI sessions (${this.sessions.size} sessions)`);\n\n    // Cleanup each ProbeAgent instance before clearing\n    for (const [, agent] of this.sessions.entries()) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      if (agent && typeof (agent as any).cleanup === 'function') {\n        try {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (agent as any).cleanup();\n        } catch {\n          // Silent fail during bulk cleanup\n        }\n      }\n    }\n\n    this.sessions.clear();\n  }\n\n  /**\n   * Get all active session IDs\n   */\n  public getActiveSessionIds(): string[] {\n    return Array.from(this.sessions.keys());\n  }\n\n  /**\n   * Check if a session exists\n   */\n  public hasSession(sessionId: string): boolean {\n    return this.sessions.has(sessionId);\n  }\n\n  /**\n   * Clone a session with a new session ID using ProbeAgent's official clone() method\n   * This uses ProbeAgent's built-in cloning which automatically handles:\n   * - Intelligent filtering of internal messages (schema reminders, tool prompts, etc.)\n   * - Preserving system message for cache efficiency\n   * - Deep copying conversation history\n   * - Copying agent configuration\n   */\n  public async cloneSession(\n    sourceSessionId: string,\n    newSessionId: string,\n    checkName?: string\n  ): Promise<ProbeAgent | undefined> {\n    const sourceAgent = this.sessions.get(sourceSessionId);\n    if (!sourceAgent) {\n      console.error(`‚ö†Ô∏è  Cannot clone session: ${sourceSessionId} not found`);\n      return undefined;\n    }\n\n    try {\n      // Use ProbeAgent's official clone() method with options\n      // This handles intelligent message filtering automatically\n      const clonedAgent = (sourceAgent as any).clone({\n        sessionId: newSessionId,\n        stripInternalMessages: true, // Remove schema reminders, tool prompts, etc.\n        keepSystemMessage: true, // Keep for cache efficiency\n        deepCopy: true, // Safe deep copy of history\n      }) as TracedProbeAgent;\n\n      // Set up tracing for cloned session if debug mode is enabled\n      if ((sourceAgent as any).debug && checkName) {\n        try {\n          const { initializeTracer } = await import('./utils/tracer-init');\n          const tracerResult = await initializeTracer(newSessionId, checkName);\n          if (tracerResult) {\n            clonedAgent.tracer = tracerResult.tracer;\n            // Store telemetry config and trace file path for proper shutdown\n            clonedAgent._telemetryConfig = tracerResult.telemetryConfig;\n            clonedAgent._traceFilePath = tracerResult.filePath;\n          }\n        } catch (traceError) {\n          console.error(\n            '‚ö†Ô∏è  Warning: Failed to initialize tracing for cloned session:',\n            traceError\n          );\n        }\n      }\n\n      // Initialize MCP tools if the source agent had them initialized\n      if (\n        (sourceAgent as any)._mcpInitialized &&\n        typeof (clonedAgent as any).initialize === 'function'\n      ) {\n        try {\n          await (clonedAgent as any).initialize();\n          console.error(`üîß Initialized MCP tools for cloned session`);\n        } catch (initError) {\n          console.error(`‚ö†Ô∏è  Warning: Failed to initialize cloned agent: ${initError}`);\n        }\n      }\n\n      // Get history length for logging\n      const historyLength = (clonedAgent as any).history?.length || 0;\n\n      console.error(\n        `üìã Cloned session ${sourceSessionId} ‚Üí ${newSessionId} using ProbeAgent.clone() (${historyLength} messages, internal messages filtered)`\n      );\n\n      // Register the cloned session\n      this.registerSession(newSessionId, clonedAgent);\n\n      return clonedAgent;\n    } catch (error) {\n      console.error(`‚ö†Ô∏è  Failed to clone session ${sourceSessionId}:`, error);\n      return undefined;\n    }\n  }\n\n  /**\n   * Register process exit handlers to cleanup sessions on exit\n   */\n  private registerExitHandlers(): void {\n    if (this.exitHandlerRegistered) {\n      return;\n    }\n\n    const cleanupAndExit = (signal: string) => {\n      if (this.sessions.size > 0) {\n        console.error(`\\nüßπ [${signal}] Cleaning up ${this.sessions.size} active AI sessions...`);\n        this.clearAllSessions();\n      }\n    };\n\n    // Handle normal process exit\n    process.on('exit', () => {\n      if (this.sessions.size > 0) {\n        console.error(`üßπ [exit] Cleaning up ${this.sessions.size} active AI sessions...`);\n        // Note: async operations won't complete here, but sync cleanup methods will\n        for (const [, agent] of this.sessions.entries()) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          if (agent && typeof (agent as any).cleanup === 'function') {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              (agent as any).cleanup();\n            } catch {\n              // Silent fail on exit\n            }\n          }\n        }\n        this.sessions.clear();\n      }\n    });\n\n    // Handle SIGINT (Ctrl+C)\n    process.on('SIGINT', () => {\n      cleanupAndExit('SIGINT');\n      process.exit(0);\n    });\n\n    // Handle SIGTERM\n    process.on('SIGTERM', () => {\n      cleanupAndExit('SIGTERM');\n      process.exit(0);\n    });\n\n    this.exitHandlerRegistered = true;\n  }\n}\n","import { extract } from '@probelabs/probe';\nimport * as path from 'path';\n\n/**\n * Process diff content using the outline-diff format from @probelabs/probe\n * This extracts a structured outline from the diff without requiring a temporary file\n */\nexport async function processDiffWithOutline(diffContent: string): Promise<string> {\n  if (!diffContent || diffContent.trim().length === 0) {\n    return diffContent;\n  }\n\n  try {\n    // Set PROBE_PATH to use the bundled binary with outline-diff support\n    // The SDK by default may download an older binary that doesn't support outline-diff\n    const originalProbePath = process.env.PROBE_PATH;\n\n    // Try multiple possible locations for the probe binary\n    // When bundled with ncc, __dirname may not be reliable\n    const fs = require('fs');\n    const possiblePaths = [\n      // Relative to current working directory (most common in production)\n      path.join(process.cwd(), 'node_modules/@probelabs/probe/bin/probe-binary'),\n      // Relative to __dirname (for unbundled development)\n      path.join(__dirname, '../..', 'node_modules/@probelabs/probe/bin/probe-binary'),\n      // Relative to dist directory (for bundled CLI)\n      path.join(__dirname, 'node_modules/@probelabs/probe/bin/probe-binary'),\n    ];\n\n    let probeBinaryPath: string | undefined;\n    for (const candidatePath of possiblePaths) {\n      if (fs.existsSync(candidatePath)) {\n        probeBinaryPath = candidatePath;\n        break;\n      }\n    }\n\n    // Only process if binary exists, otherwise fall back to original diff\n    if (!probeBinaryPath) {\n      if (process.env.DEBUG === '1' || process.env.VERBOSE === '1') {\n        console.error('Probe binary not found. Tried:', possiblePaths);\n      }\n      return diffContent;\n    }\n\n    process.env.PROBE_PATH = probeBinaryPath;\n\n    // Use extract with content parameter (can be string or Buffer)\n    // The TypeScript types haven't been updated yet, but the runtime supports it\n    // Add timeout to avoid hanging\n    const extractPromise = (extract as any)({\n      content: diffContent,\n      format: 'outline-diff',\n      allowTests: true, // Allow test files and test code blocks in extraction results\n    });\n\n    const timeoutPromise = new Promise((_, reject) => {\n      setTimeout(() => reject(new Error('Extract timeout after 30s')), 30000);\n    });\n\n    const result = await Promise.race([extractPromise, timeoutPromise]);\n\n    // Restore original PROBE_PATH\n    if (originalProbePath !== undefined) {\n      process.env.PROBE_PATH = originalProbePath;\n    } else {\n      delete process.env.PROBE_PATH;\n    }\n\n    // Return the processed outline diff\n    return typeof result === 'string' ? result : JSON.stringify(result);\n  } catch (error) {\n    // If outline-diff processing fails, fall back to the original diff\n    // Use console.error instead of console.warn to avoid polluting JSON output\n    if (process.env.DEBUG === '1' || process.env.VERBOSE === '1') {\n      console.error('Failed to process diff with outline-diff format:', error);\n    }\n    return diffContent;\n  }\n}\n","import { ProbeAgent } from '@probelabs/probe';\nimport type { ProbeAgentOptions } from '@probelabs/probe';\nimport { PRInfo } from './pr-analyzer';\nimport { ReviewSummary, ReviewIssue } from './reviewer';\nimport { SessionRegistry } from './session-registry';\nimport { logger } from './logger';\nimport { initializeTracer } from './utils/tracer-init';\nimport { processDiffWithOutline } from './utils/diff-processor';\n\n/**\n * Helper function to log debug messages using the centralized logger\n */\nfunction log(...args: unknown[]): void {\n  logger.debug(args.join(' '));\n}\n\n/**\n * Extended ProbeAgent interface that includes tracing properties\n */\ninterface TracedProbeAgent extends ProbeAgent {\n  tracer?: unknown; // SimpleTelemetry tracer (probe removed AppTracer)\n  _telemetryConfig?: unknown; // SimpleTelemetry config (probe removed TelemetryConfig)\n  _traceFilePath?: string;\n}\n\n/**\n * Extended ProbeAgentOptions interface that includes tracing properties\n */\ninterface TracedProbeAgentOptions extends ProbeAgentOptions {\n  tracer?: unknown; // SimpleTelemetry tracer\n  _telemetryConfig?: unknown; // SimpleTelemetry config\n  _traceFilePath?: string;\n  customPrompt?: string;\n}\n\nexport interface AIReviewConfig {\n  apiKey?: string; // From env: GOOGLE_API_KEY, ANTHROPIC_API_KEY, OPENAI_API_KEY, CLAUDE_CODE_API_KEY, or AWS credentials\n  model?: string; // From env: MODEL_NAME (e.g., gemini-2.5-pro-preview-06-05)\n  timeout?: number; // Default: 600000ms (10 minutes)\n  provider?: 'google' | 'anthropic' | 'openai' | 'bedrock' | 'mock' | 'claude-code';\n  debug?: boolean; // Enable debug mode\n  tools?: Array<{ name: string; [key: string]: unknown }>; // (unused) Legacy tool listing\n  // Pass-through MCP server configuration for ProbeAgent\n  mcpServers?: Record<string, import('./types/config').McpServerConfig>;\n  // Enable delegate tool for task distribution to subagents\n  enableDelegate?: boolean;\n  // ProbeAgent persona/prompt family (e.g., 'engineer', 'code-review', 'architect')\n  promptType?: string;\n  // System prompt to prepend (baseline/preamble). Replaces legacy customPrompt\n  systemPrompt?: string;\n  // Backward-compat: legacy key still accepted internally\n  customPrompt?: string;\n  // Retry configuration for AI provider calls\n  retry?: import('./types/config').AIRetryConfig;\n  // Fallback configuration for provider failures\n  fallback?: import('./types/config').AIFallbackConfig;\n  // Enable Edit and Create tools for file modification\n  allowEdit?: boolean;\n  // Filter allowed tools - supports whitelist, exclusion (!prefix), or raw AI mode (empty array)\n  allowedTools?: string[];\n  // Disable all tools for raw AI mode (alternative to allowedTools: [])\n  disableTools?: boolean;\n  // Enable bash command execution (shorthand for bashConfig.enabled)\n  allowBash?: boolean;\n  // Advanced bash command execution configuration\n  bashConfig?: import('./types/config').BashConfig;\n}\n\nexport interface AIDebugInfo {\n  /** The prompt sent to the AI */\n  prompt: string;\n  /** Raw response from the AI service */\n  rawResponse: string;\n  /** Provider used (google, anthropic, openai) */\n  provider: string;\n  /** Model used */\n  model: string;\n  /** API key source (for privacy, just show which env var) */\n  apiKeySource: string;\n  /** Processing time in milliseconds */\n  processingTime: number;\n  /** Prompt length in characters */\n  promptLength: number;\n  /** Response length in characters */\n  responseLength: number;\n  /** Any errors encountered */\n  errors?: string[];\n  /** Whether JSON parsing succeeded */\n  jsonParseSuccess: boolean;\n  /** Schema used for response validation */\n  schema?: string;\n  /** Schema name/type requested */\n  schemaName?: string;\n  /** Checks executed during this review */\n  checksExecuted?: string[];\n  /** Whether parallel execution was used */\n  parallelExecution?: boolean;\n  /** Timestamp when request was made */\n  timestamp: string;\n  /** Total API calls made */\n  totalApiCalls?: number;\n  /** Details about API calls made */\n  apiCallDetails?: Array<{\n    checkName: string;\n    provider: string;\n    model: string;\n    processingTime: number;\n    success: boolean;\n  }>;\n}\n\n// REMOVED: ReviewFocus type - only use custom prompts from .visor.yaml\n\ninterface AIResponseFormat {\n  // Array of issues for code review\n  issues?: Array<{\n    file: string;\n    line: number;\n    endLine?: number;\n    ruleId: string;\n    message: string;\n    severity: 'info' | 'warning' | 'error' | 'critical';\n    category: 'security' | 'performance' | 'style' | 'logic' | 'documentation';\n    suggestion?: string;\n    replacement?: string;\n  }>;\n}\n\nexport class AIReviewService {\n  private config: AIReviewConfig;\n  private sessionRegistry: SessionRegistry;\n\n  constructor(config: AIReviewConfig = {}) {\n    this.config = {\n      timeout: 600000, // Increased timeout to 10 minutes for AI responses\n      ...config,\n    };\n\n    this.sessionRegistry = SessionRegistry.getInstance();\n\n    // If debug was not explicitly provided, honor standard env flags so tests/CLI\n    // can enable provider-level debug without modifying per-check configs.\n    if (typeof this.config.debug === 'undefined') {\n      try {\n        if (process.env.VISOR_PROVIDER_DEBUG === 'true' || process.env.VISOR_DEBUG === 'true') {\n          this.config.debug = true;\n        }\n      } catch {}\n    }\n\n    // Respect explicit provider if set (e.g., 'mock' during tests) ‚Äî do not override from env\n    const providerExplicit =\n      typeof this.config.provider === 'string' && this.config.provider.length > 0;\n\n    // Auto-detect provider and API key from environment only when provider not explicitly set\n    if (!providerExplicit) {\n      if (!this.config.apiKey) {\n        if (process.env.CLAUDE_CODE_API_KEY) {\n          this.config.apiKey = process.env.CLAUDE_CODE_API_KEY;\n          this.config.provider = 'claude-code';\n        } else if (process.env.GOOGLE_API_KEY) {\n          this.config.apiKey = process.env.GOOGLE_API_KEY;\n          this.config.provider = 'google';\n        } else if (process.env.ANTHROPIC_API_KEY) {\n          this.config.apiKey = process.env.ANTHROPIC_API_KEY;\n          this.config.provider = 'anthropic';\n        } else if (process.env.OPENAI_API_KEY) {\n          this.config.apiKey = process.env.OPENAI_API_KEY;\n          this.config.provider = 'openai';\n        } else if (\n          // Check for AWS Bedrock credentials\n          (process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY) ||\n          process.env.AWS_BEDROCK_API_KEY\n        ) {\n          // For Bedrock, we don't set apiKey as it uses AWS credentials\n          // ProbeAgent will handle the authentication internally\n          this.config.provider = 'bedrock';\n          // Set a placeholder to pass validation\n          this.config.apiKey = 'AWS_CREDENTIALS';\n        }\n      }\n    }\n\n    // Auto-detect model from environment\n    if (!this.config.model && process.env.MODEL_NAME) {\n      this.config.model = process.env.MODEL_NAME;\n    }\n  }\n\n  // NOTE: per request, no additional redaction/encryption helpers are used.\n\n  /**\n   * Execute AI review using probe agent\n   */\n  async executeReview(\n    prInfo: PRInfo,\n    customPrompt: string,\n    schema?: string | Record<string, unknown>,\n    checkName?: string,\n    sessionId?: string\n  ): Promise<ReviewSummary> {\n    const startTime = Date.now();\n    const timestamp = new Date().toISOString();\n\n    // Build prompt from custom instructions\n    // Respect provider-level skip_code_context by skipping PR context wrapper when requested\n    const prompt = await this.buildCustomPrompt(prInfo, customPrompt, schema, {\n      skipPRContext: (this.config as any)?.skip_code_context === true,\n    });\n\n    log(`Executing AI review with ${this.config.provider} provider...`);\n    log(`üîß Debug: Raw schema parameter: ${JSON.stringify(schema)} (type: ${typeof schema})`);\n    log(`Schema type: ${schema || 'none (no schema)'}`);\n\n    let debugInfo: AIDebugInfo | undefined;\n    if (this.config.debug) {\n      debugInfo = {\n        prompt,\n        rawResponse: '',\n        provider: this.config.provider || 'unknown',\n        model: this.config.model || 'default',\n        apiKeySource: this.getApiKeySource(),\n        processingTime: 0,\n        promptLength: prompt.length,\n        responseLength: 0,\n        errors: [],\n        jsonParseSuccess: false,\n        timestamp,\n        schemaName: typeof schema === 'object' ? 'custom' : schema,\n        schema: undefined, // Will be populated when schema is loaded\n      };\n    }\n\n    // Handle mock model/provider first (no API key needed)\n    if (this.config.model === 'mock' || this.config.provider === 'mock') {\n      log('üé≠ Using mock AI model/provider for testing - skipping API key validation');\n    } else {\n      // Hydrate API key from environment even when provider is explicitly set\n      if (!this.config.apiKey) {\n        try {\n          if (this.config.provider === 'google' && process.env.GOOGLE_API_KEY) {\n            this.config.apiKey = process.env.GOOGLE_API_KEY;\n          } else if (this.config.provider === 'anthropic' && process.env.ANTHROPIC_API_KEY) {\n            this.config.apiKey = process.env.ANTHROPIC_API_KEY;\n          } else if (this.config.provider === 'openai' && process.env.OPENAI_API_KEY) {\n            this.config.apiKey = process.env.OPENAI_API_KEY;\n          } else if (this.config.provider === 'claude-code' && process.env.CLAUDE_CODE_API_KEY) {\n            this.config.apiKey = process.env.CLAUDE_CODE_API_KEY;\n          }\n        } catch {}\n      }\n      // Check if API key is available for real AI models\n      if (!this.config.apiKey) {\n        const errorMessage =\n          'No API key configured. Please set GOOGLE_API_KEY, ANTHROPIC_API_KEY, OPENAI_API_KEY environment variable, or configure AWS credentials for Bedrock (AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY).';\n\n        // In debug mode, proceed to call the (mocked) provider so tests can assert prompt/session behavior\n        if (debugInfo) {\n          debugInfo.errors = [errorMessage];\n          debugInfo.rawResponse = 'API call attempted in debug without API key (test mode)';\n          // Continue without returning; ProbeAgent is typically mocked under tests.\n        } else {\n          throw new Error(errorMessage);\n        }\n      }\n    }\n\n    try {\n      const call = this.callProbeAgent(prompt, schema, debugInfo, checkName, sessionId);\n      const timeoutMs = Math.max(0, this.config.timeout || 0);\n      const { response, effectiveSchema } =\n        timeoutMs > 0 ? await this.withTimeout(call, timeoutMs, 'AI review') : await call;\n      const processingTime = Date.now() - startTime;\n\n      if (debugInfo) {\n        debugInfo.rawResponse = response;\n        debugInfo.responseLength = response.length;\n        debugInfo.processingTime = processingTime;\n      }\n\n      const result = this.parseAIResponse(response, debugInfo, effectiveSchema);\n\n      if (debugInfo) {\n        result.debug = debugInfo;\n      }\n\n      return result;\n    } catch (error) {\n      if (debugInfo) {\n        debugInfo.errors = [error instanceof Error ? error.message : String(error)];\n        debugInfo.processingTime = Date.now() - startTime;\n\n        // In debug mode, return a review with the error captured\n        return {\n          issues: [\n            {\n              file: 'system',\n              line: 0,\n              ruleId: 'system/ai-execution-error',\n              message: error instanceof Error ? error.message : String(error),\n              severity: 'error',\n              category: 'logic',\n            },\n          ],\n          debug: debugInfo,\n        };\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Execute AI review using session reuse - reuses an existing ProbeAgent session\n   * @param sessionMode - 'clone' (default) clones history, 'append' shares history\n   */\n  async executeReviewWithSessionReuse(\n    prInfo: PRInfo,\n    customPrompt: string,\n    parentSessionId: string,\n    schema?: string | Record<string, unknown>,\n    checkName?: string,\n    sessionMode: 'clone' | 'append' = 'clone'\n  ): Promise<ReviewSummary> {\n    const startTime = Date.now();\n    const timestamp = new Date().toISOString();\n\n    // Ensure API key is hydrated from environment for explicit providers\n    if (!this.config.apiKey) {\n      try {\n        if (this.config.provider === 'google' && process.env.GOOGLE_API_KEY) {\n          this.config.apiKey = process.env.GOOGLE_API_KEY;\n        } else if (this.config.provider === 'anthropic' && process.env.ANTHROPIC_API_KEY) {\n          this.config.apiKey = process.env.ANTHROPIC_API_KEY;\n        } else if (this.config.provider === 'openai' && process.env.OPENAI_API_KEY) {\n          this.config.apiKey = process.env.OPENAI_API_KEY;\n        } else if (this.config.provider === 'claude-code' && process.env.CLAUDE_CODE_API_KEY) {\n          this.config.apiKey = process.env.CLAUDE_CODE_API_KEY;\n        }\n      } catch {}\n    }\n    // Get the existing session\n    const existingAgent = this.sessionRegistry.getSession(parentSessionId);\n    if (!existingAgent) {\n      throw new Error(\n        `Session not found for reuse: ${parentSessionId}. Ensure the parent check completed successfully.`\n      );\n    }\n\n    // Build prompt from custom instructions\n    // When reusing session, skip PR context since it's already in the conversation history\n    const prompt = await this.buildCustomPrompt(prInfo, customPrompt, schema, {\n      skipPRContext: true,\n    });\n\n    // Determine which agent to use based on session mode\n    let agentToUse: typeof existingAgent;\n    let currentSessionId: string;\n\n    if (sessionMode === 'clone') {\n      // Clone the session - creates a new agent with copied history\n      // Include check name in the session ID for better tracing\n      currentSessionId = `${checkName}-session-${Date.now()}`;\n      log(\n        `üìã Cloning AI session ${parentSessionId} ‚Üí ${currentSessionId} for ${checkName} check...`\n      );\n\n      const clonedAgent = await this.sessionRegistry.cloneSession(\n        parentSessionId,\n        currentSessionId,\n        checkName // Pass checkName for tracing\n      );\n      if (!clonedAgent) {\n        throw new Error(`Failed to clone session ${parentSessionId}`);\n      }\n      agentToUse = clonedAgent;\n    } else {\n      // Append mode - use the same agent instance\n      log(`üîÑ Appending to AI session ${parentSessionId} (shared history)...`);\n      agentToUse = existingAgent;\n      currentSessionId = parentSessionId;\n    }\n\n    log(`üîß Debug: Raw schema parameter: ${JSON.stringify(schema)} (type: ${typeof schema})`);\n    log(`üìã Schema for this check: ${schema || 'none (no schema)'}`);\n    if (sessionMode === 'clone') {\n      log(`‚úÖ Cloned agent will use NEW schema (${schema}) - parent schema does not persist`);\n      log(`üîÑ Clone operation ensures fresh agent with copied history but new configuration`);\n    } else {\n      log(`üîÑ Append mode - using existing agent instance with shared history and configuration`);\n    }\n\n    let debugInfo: AIDebugInfo | undefined;\n    if (this.config.debug) {\n      debugInfo = {\n        prompt,\n        rawResponse: '',\n        provider: this.config.provider || 'unknown',\n        model: this.config.model || 'default',\n        apiKeySource: this.getApiKeySource(),\n        processingTime: 0,\n        promptLength: prompt.length,\n        responseLength: 0,\n        errors: [],\n        jsonParseSuccess: false,\n        timestamp,\n        schemaName: typeof schema === 'object' ? 'custom' : schema,\n        schema: undefined, // Will be populated when schema is loaded\n      };\n    }\n\n    try {\n      // Use the determined agent (cloned or original)\n      const call = this.callProbeAgentWithExistingSession(\n        agentToUse,\n        prompt,\n        schema,\n        debugInfo,\n        checkName\n      );\n      const timeoutMs = Math.max(0, this.config.timeout || 0);\n      const { response, effectiveSchema } =\n        timeoutMs > 0 ? await this.withTimeout(call, timeoutMs, 'AI review (session)') : await call;\n      const processingTime = Date.now() - startTime;\n\n      if (debugInfo) {\n        debugInfo.rawResponse = response;\n        debugInfo.responseLength = response.length;\n        debugInfo.processingTime = processingTime;\n      }\n\n      const result = this.parseAIResponse(response, debugInfo, effectiveSchema);\n\n      // Expose the session ID used for this call so the engine can clean it up\n      try {\n        (result as any).sessionId = currentSessionId;\n      } catch {}\n\n      if (debugInfo) {\n        result.debug = debugInfo;\n      }\n\n      // Include the session ID in the result for cleanup tracking\n      // Only include if we created a new cloned session\n      if (sessionMode === 'clone' && currentSessionId !== parentSessionId) {\n        result.sessionId = currentSessionId;\n      }\n\n      return result;\n    } catch (error) {\n      if (debugInfo) {\n        debugInfo.errors = [error instanceof Error ? error.message : String(error)];\n        debugInfo.processingTime = Date.now() - startTime;\n\n        // In debug mode, return a review with the error captured\n        return {\n          issues: [\n            {\n              file: 'system',\n              line: 0,\n              ruleId: 'system/ai-session-reuse-error',\n              message: error instanceof Error ? error.message : String(error),\n              severity: 'error',\n              category: 'logic',\n            },\n          ],\n          debug: debugInfo,\n        };\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Promise timeout helper that rejects after ms if unresolved\n   */\n  private async withTimeout<T>(p: Promise<T>, ms: number, label = 'operation'): Promise<T> {\n    let timer: NodeJS.Timeout | undefined;\n    try {\n      const timeout = new Promise<never>((_, reject) => {\n        timer = setTimeout(() => reject(new Error(`${label} timed out after ${ms}ms`)), ms);\n      });\n      return (await Promise.race([p, timeout])) as T;\n    } finally {\n      if (timer) clearTimeout(timer);\n    }\n  }\n\n  /**\n   * Register a new AI session in the session registry\n   */\n  registerSession(sessionId: string, agent: TracedProbeAgent): void {\n    this.sessionRegistry.registerSession(sessionId, agent);\n  }\n\n  /**\n   * Cleanup a session from the registry\n   */\n  cleanupSession(sessionId: string): void {\n    this.sessionRegistry.unregisterSession(sessionId);\n  }\n\n  /**\n   * Build a custom prompt for AI review with XML-formatted data\n   */\n  private async buildCustomPrompt(\n    prInfo: PRInfo,\n    customInstructions: string,\n    schema?: string | Record<string, unknown>,\n    options?: { skipPRContext?: boolean; checkName?: string }\n  ): Promise<string> {\n    // When reusing sessions, skip PR context to avoid sending duplicate diff data\n    const skipPRContext = options?.skipPRContext === true;\n\n    // Check if we're using the code-review schema\n    const isCodeReviewSchema = schema === 'code-review';\n\n    const prContext = skipPRContext ? '' : await this.formatPRContext(prInfo, isCodeReviewSchema);\n    const isIssue = (prInfo as PRInfo & { isIssue?: boolean }).isIssue === true;\n\n    if (isIssue) {\n      // Issue context - no code analysis needed\n      if (skipPRContext) {\n        // Session reuse: just send new instructions\n        return `<instructions>\n${customInstructions}\n</instructions>`;\n      }\n\n      return `<review_request>\n  <instructions>\n${customInstructions}\n  </instructions>\n\n  <context>\n${prContext}\n  </context>\n\n  <rules>\n    <rule>Understand the issue context and requirements from the XML data structure</rule>\n    <rule>Provide helpful, actionable guidance based on the issue details</rule>\n    <rule>Be constructive and supportive in your analysis</rule>\n    <rule>Consider project conventions and patterns when making recommendations</rule>\n    <rule>Suggest practical solutions or next steps that address the specific concern</rule>\n    <rule>Focus on addressing the specific concern raised in the issue</rule>\n    <rule>Reference relevant XML elements like metadata, description, labels, assignees when providing context</rule>\n  </rules>\n</review_request>`;\n    }\n\n    // Only add review_request wrapper and PR-specific rules for code-review schema\n    if (isCodeReviewSchema) {\n      // PR context with code-review schema - structured XML format\n      const analysisType = prInfo.isIncremental ? 'INCREMENTAL' : 'FULL';\n\n      if (skipPRContext) {\n        // Session reuse: just send new instructions without repeating the context\n        return `<instructions>\n${customInstructions}\n</instructions>\n\n<reminder>\n  <rule>The code context and diff were provided in the previous message</rule>\n  <rule>Focus on the new analysis instructions above</rule>\n  <rule>Only analyze code that appears with + (additions) or - (deletions) in the diff sections</rule>\n  <rule>STRICT OUTPUT POLICY: Report only actual problems, risks, or deficiencies</rule>\n  <rule>SEVERITY ASSIGNMENT: Assign severity ONLY to problems introduced or left unresolved by this change</rule>\n</reminder>`;\n      }\n\n      return `<review_request>\n  <analysis_type>${analysisType}</analysis_type>\n\n  <analysis_focus>\n    ${\n      analysisType === 'INCREMENTAL'\n        ? 'You are analyzing a NEW COMMIT added to an existing PR. Focus on the changes in the commit_diff section for this specific commit.'\n        : 'You are analyzing the COMPLETE PR. Review all changes in the full_diff section.'\n    }\n  </analysis_focus>\n\n  <instructions>\n${customInstructions}\n  </instructions>\n\n  <context>\n${prContext}\n  </context>\n\n  <rules>\n    <rule>Only analyze code that appears with + (additions) or - (deletions) in the diff sections</rule>\n    <rule>Ignore unchanged code unless directly relevant to understanding a change</rule>\n    <rule>Line numbers in your response should match actual file line numbers from the diff</rule>\n    <rule>Focus on real issues, not nitpicks or cosmetic concerns</rule>\n    <rule>Provide actionable, specific feedback with clear remediation steps</rule>\n    <rule>For INCREMENTAL analysis, ONLY review changes in commit_diff section</rule>\n    <rule>For FULL analysis, review all changes in full_diff section</rule>\n    <rule>Reference specific XML elements like files_summary, metadata when providing context</rule>\n    <rule>STRICT OUTPUT POLICY: Report only actual problems, risks, or deficiencies. Do not write praise, congratulations, or celebratory text. Do not create issues that merely restate improvements or say \"no action needed\".</rule>\n    <rule>SEVERITY ASSIGNMENT: Assign severity ONLY to problems introduced or left unresolved by this change (critical/error/warning/info as appropriate). Do NOT create issue entries solely to acknowledge improvements; if no problems exist, return zero issues.</rule>\n  </rules>\n</review_request>`;\n    }\n\n    // For non-code-review schemas, just provide instructions and context without review-specific wrapper\n    if (skipPRContext) {\n      // Session reuse: just send new instructions\n      return `<instructions>\n${customInstructions}\n</instructions>`;\n    }\n\n    return `<instructions>\n${customInstructions}\n</instructions>\n\n<context>\n${prContext}\n</context>`;\n  }\n\n  // REMOVED: Built-in prompts - only use custom prompts from .visor.yaml\n\n  // REMOVED: getFocusInstructions - only use custom prompts from .visor.yaml\n\n  /**\n   * Format PR or Issue context for the AI using XML structure\n   */\n  private async formatPRContext(prInfo: PRInfo, isCodeReviewSchema?: boolean): Promise<string> {\n    // Check if this is an issue (not a PR)\n    const prContextInfo = prInfo as PRInfo & {\n      isPRContext?: boolean;\n      includeCodeContext?: boolean;\n    };\n    const isIssue = prContextInfo.isIssue === true;\n\n    // Check if we should include code context (diffs)\n    const isPRContext = prContextInfo.isPRContext === true;\n    // In PR context, always include diffs. Otherwise check the flag.\n    const includeCodeContext = isPRContext || prContextInfo.includeCodeContext !== false;\n\n    // Log the decision for transparency (debug level)\n    if (isPRContext) {\n      log('üîç Including full code diffs in AI context (PR mode)');\n    } else if (!includeCodeContext) {\n      log('üìä Including only file summary in AI context (no diffs)');\n    } else {\n      log('üîç Including code diffs in AI context');\n    }\n\n    if (isIssue) {\n      // Format as issue context\n      let context = `<issue>\n  <!-- Core issue metadata including identification, status, and timeline information -->\n  <metadata>\n    <number>${prInfo.number}</number>\n    <title>${this.escapeXml(prInfo.title)}</title>\n    <author>${prInfo.author}</author>\n    <state>${(prInfo as PRInfo & { eventContext?: { issue?: { state?: string; created_at?: string; updated_at?: string; comments?: number } } }).eventContext?.issue?.state || 'open'}</state>\n    <created_at>${(prInfo as PRInfo & { eventContext?: { issue?: { state?: string; created_at?: string; updated_at?: string; comments?: number } } }).eventContext?.issue?.created_at || ''}</created_at>\n    <updated_at>${(prInfo as PRInfo & { eventContext?: { issue?: { state?: string; updated_at?: string; comments?: number } } }).eventContext?.issue?.updated_at || ''}</updated_at>\n    <comments_count>${(prInfo as PRInfo & { eventContext?: { issue?: { comments?: number } } }).eventContext?.issue?.comments || 0}</comments_count>\n  </metadata>`;\n\n      // Add issue body/description if available\n      if (prInfo.body) {\n        context += `\n  <!-- Full issue description and body text provided by the issue author -->\n  <description>\n${this.escapeXml(prInfo.body)}\n  </description>`;\n      }\n\n      // Add labels if available\n      const eventContext = prInfo as PRInfo & {\n        eventContext?: { issue?: { labels?: Array<{ name?: string } | string> } };\n      };\n      const labels = eventContext.eventContext?.issue?.labels;\n      if (labels && labels.length > 0) {\n        context += `\n  <!-- Applied labels for issue categorization and organization -->\n  <labels>`;\n        labels.forEach((label: { name?: string } | string) => {\n          const labelName = typeof label === 'string' ? label : label.name || 'unknown';\n          context += `\n    <label>${this.escapeXml(labelName)}</label>`;\n        });\n        context += `\n  </labels>`;\n      }\n\n      // Add assignees if available\n      const assignees = (\n        prInfo as PRInfo & {\n          eventContext?: { issue?: { assignees?: Array<{ login?: string } | string> } };\n        }\n      ).eventContext?.issue?.assignees;\n      if (assignees && assignees.length > 0) {\n        context += `\n  <!-- Users assigned to work on this issue -->\n  <assignees>`;\n        assignees.forEach((assignee: { login?: string } | string) => {\n          const assigneeName =\n            typeof assignee === 'string' ? assignee : assignee.login || 'unknown';\n          context += `\n    <assignee>${this.escapeXml(assigneeName)}</assignee>`;\n        });\n        context += `\n  </assignees>`;\n      }\n\n      // Add milestone if available\n      const milestone = (\n        prInfo as PRInfo & {\n          eventContext?: {\n            issue?: { milestone?: { title?: string; state?: string; due_on?: string } };\n          };\n        }\n      ).eventContext?.issue?.milestone;\n      if (milestone) {\n        context += `\n  <!-- Associated project milestone information -->\n  <milestone>\n    <title>${this.escapeXml(milestone.title || '')}</title>\n    <state>${milestone.state || 'open'}</state>\n    <due_on>${milestone.due_on || ''}</due_on>\n  </milestone>`;\n      }\n\n      // Add current/triggering comment if this is a comment event\n      const triggeringComment = (\n        prInfo as PRInfo & {\n          eventContext?: {\n            comment?: {\n              user?: { login?: string };\n              created_at?: string;\n              body?: string;\n              id?: number;\n            };\n          };\n        }\n      ).eventContext?.comment;\n      if (triggeringComment) {\n        context += `\n  <!-- The comment that triggered this analysis -->\n  <triggering_comment>\n    <author>${this.escapeXml(triggeringComment.user?.login || 'unknown')}</author>\n    <created_at>${triggeringComment.created_at || ''}</created_at>\n    <body>${this.escapeXml(triggeringComment.body || '')}</body>\n  </triggering_comment>`;\n      }\n\n      // Add comment history (excluding the current comment if it exists)\n      const issueComments = (\n        prInfo as PRInfo & {\n          comments?: Array<{ id?: number; author?: string; body?: string; createdAt?: string }>;\n        }\n      ).comments;\n      if (issueComments && issueComments.length > 0) {\n        // Filter out the triggering comment from history if present\n        let historicalComments = triggeringComment\n          ? issueComments.filter(c => c.id !== triggeringComment.id)\n          : issueComments;\n\n        // For code-review schema checks, filter out previous Visor code-review comments to avoid self-bias\n        // Comment IDs look like: <!-- visor-comment-id:pr-review-244-review -->\n        if (isCodeReviewSchema) {\n          historicalComments = historicalComments.filter(\n            c => !c.body || !c.body.includes('visor-comment-id:pr-review-')\n          );\n        }\n\n        if (historicalComments.length > 0) {\n          context += `\n  <!-- Previous comments in chronological order (excluding triggering comment) -->\n  <comment_history>`;\n          historicalComments.forEach(comment => {\n            context += `\n    <comment>\n      <author>${this.escapeXml(comment.author || 'unknown')}</author>\n      <created_at>${comment.createdAt || ''}</created_at>\n      <body>${this.escapeXml(comment.body || '')}</body>\n    </comment>`;\n          });\n          context += `\n  </comment_history>`;\n        }\n      }\n\n      // Close the issue tag\n      context += `\n</issue>`;\n\n      return context;\n    }\n\n    // Original PR context formatting\n    let context = `<pull_request>\n  <!-- Core pull request metadata including identification, branches, and change statistics -->\n  <metadata>\n    <number>${prInfo.number}</number>\n    <title>${this.escapeXml(prInfo.title)}</title>\n    <author>${prInfo.author}</author>\n    <base_branch>${prInfo.base}</base_branch>\n    <target_branch>${prInfo.head}</target_branch>\n    <total_additions>${prInfo.totalAdditions}</total_additions>\n    <total_deletions>${prInfo.totalDeletions}</total_deletions>\n    <files_changed_count>${prInfo.files.length}</files_changed_count>\n  </metadata>`;\n\n    // Include a small raw diff header snippet for compatibility with tools/tests\n    try {\n      const firstFile = (prInfo.files || [])[0];\n      if (firstFile && firstFile.filename) {\n        context += `\\n  <raw_diff_header>\\n${this.escapeXml(`diff --git a/${firstFile.filename} b/${firstFile.filename}`)}\\n  </raw_diff_header>`;\n      }\n    } catch {}\n\n    // Add PR description if available\n    if (prInfo.body) {\n      context += `\n  <!-- Full pull request description provided by the author -->\n  <description>\n${this.escapeXml(prInfo.body)}\n  </description>`;\n    }\n\n    // Add diffs only if includeCodeContext is true (or in PR mode)\n    if (includeCodeContext) {\n      // Add full diff if available (for complete PR review)\n      if (prInfo.fullDiff) {\n        // Process the diff with outline-diff format for better structure\n        const processedFullDiff = await processDiffWithOutline(prInfo.fullDiff);\n        context += `\n  <!-- Complete unified diff showing all changes in the pull request (processed with outline-diff) -->\n  <full_diff>\n${this.escapeXml(processedFullDiff)}\n  </full_diff>`;\n      }\n\n      // Add incremental commit diff if available (for new commit analysis)\n      if (prInfo.isIncremental) {\n        if (prInfo.commitDiff && prInfo.commitDiff.length > 0) {\n          // Process the commit diff with outline-diff format for better structure\n          const processedCommitDiff = await processDiffWithOutline(prInfo.commitDiff);\n          context += `\n  <!-- Diff of only the latest commit for incremental analysis (processed with outline-diff) -->\n  <commit_diff>\n${this.escapeXml(processedCommitDiff)}\n  </commit_diff>`;\n        } else {\n          // Process the fallback full diff with outline-diff format\n          const processedFallbackDiff = prInfo.fullDiff\n            ? await processDiffWithOutline(prInfo.fullDiff)\n            : '';\n          context += `\n  <!-- Commit diff could not be retrieved - falling back to full diff analysis (processed with outline-diff) -->\n  <commit_diff>\n${this.escapeXml(processedFallbackDiff)}\n  </commit_diff>`;\n        }\n      }\n    } else {\n      // When not including diffs, add a note about it\n      context += `\n  <!-- Code diffs excluded to reduce token usage (no code-review schema detected or disabled by flag) -->`;\n    }\n\n    // Add file summary for context\n    if (prInfo.files.length > 0) {\n      context += `\n  <!-- Summary of all files changed with statistics -->\n  <files_summary>`;\n      prInfo.files.forEach(file => {\n        context += `\n    <file>\n      <filename>${this.escapeXml(file.filename)}</filename>\n      <status>${file.status}</status>\n      <additions>${file.additions}</additions>\n      <deletions>${file.deletions}</deletions>\n    </file>`;\n      });\n      context += `\n  </files_summary>`;\n    }\n\n    // Add current/triggering comment if this is a comment event\n    const triggeringComment = (\n      prInfo as PRInfo & {\n        eventContext?: {\n          comment?: { user?: { login?: string }; created_at?: string; body?: string; id?: number };\n        };\n      }\n    ).eventContext?.comment;\n    if (triggeringComment) {\n      context += `\n  <!-- The comment that triggered this analysis -->\n  <triggering_comment>\n    <author>${this.escapeXml(triggeringComment.user?.login || 'unknown')}</author>\n    <created_at>${triggeringComment.created_at || ''}</created_at>\n    <body>${this.escapeXml(triggeringComment.body || '')}</body>\n  </triggering_comment>`;\n    }\n\n    // Add comment history (excluding the current comment if it exists)\n    const prComments = (\n      prInfo as PRInfo & {\n        comments?: Array<{ id?: number; author?: string; body?: string; createdAt?: string }>;\n      }\n    ).comments;\n    if (prComments && prComments.length > 0) {\n      // Filter out the triggering comment from history if present\n      let historicalComments = triggeringComment\n        ? prComments.filter(c => c.id !== triggeringComment.id)\n        : prComments;\n\n      // For code-review schema checks, filter out previous Visor code-review comments to avoid self-bias\n      // Comment IDs look like: <!-- visor-comment-id:pr-review-244-review -->\n      if (isCodeReviewSchema) {\n        historicalComments = historicalComments.filter(\n          c => !c.body || !c.body.includes('visor-comment-id:pr-review-')\n        );\n      }\n\n      if (historicalComments.length > 0) {\n        context += `\n  <!-- Previous PR comments in chronological order (excluding triggering comment) -->\n  <comment_history>`;\n        historicalComments.forEach(comment => {\n          context += `\n    <comment>\n      <author>${this.escapeXml(comment.author || 'unknown')}</author>\n      <created_at>${comment.createdAt || ''}</created_at>\n      <body>${this.escapeXml(comment.body || '')}</body>\n    </comment>`;\n        });\n        context += `\n  </comment_history>`;\n      }\n    }\n\n    context += `\n</pull_request>`;\n\n    return context;\n  }\n\n  /**\n   * No longer escaping XML - returning text as-is\n   */\n  private escapeXml(text: string): string {\n    return text;\n  }\n\n  /**\n   * Call ProbeAgent with an existing session\n   */\n  private async callProbeAgentWithExistingSession(\n    agent: TracedProbeAgent,\n    prompt: string,\n    schema?: string | Record<string, unknown>,\n    debugInfo?: AIDebugInfo,\n    _checkName?: string\n  ): Promise<{ response: string; effectiveSchema?: string }> {\n    // Handle mock model/provider for testing\n    if (this.config.model === 'mock' || this.config.provider === 'mock') {\n      log('üé≠ Using mock AI model/provider for testing (session reuse)');\n      const response = await this.generateMockResponse(prompt, _checkName, schema);\n      return { response, effectiveSchema: typeof schema === 'object' ? 'custom' : schema };\n    }\n\n    log('üîÑ Reusing existing ProbeAgent session for AI review...');\n    log(`üìù Prompt length: ${prompt.length} characters`);\n    log(`‚öôÔ∏è Model: ${this.config.model || 'default'}, Provider: ${this.config.provider || 'auto'}`);\n\n    try {\n      log('üöÄ Calling existing ProbeAgent with answer()...');\n\n      // Load and pass the actual schema content if provided (skip for plain schema)\n      let schemaString: string | undefined = undefined;\n      let effectiveSchema: string | undefined = typeof schema === 'object' ? 'custom' : schema;\n\n      if (schema && schema !== 'plain') {\n        try {\n          schemaString = await this.loadSchemaContent(schema);\n          log(`üìã Loaded schema content for: ${schema}`);\n          log(`üìÑ Raw schema JSON:\\n${schemaString}`);\n        } catch (error) {\n          log(`‚ö†Ô∏è Failed to load schema ${schema}, proceeding without schema:`, error);\n          schemaString = undefined;\n          effectiveSchema = undefined; // Schema loading failed, treat as no schema\n          if (debugInfo && debugInfo.errors) {\n            debugInfo.errors.push(`Failed to load schema: ${error}`);\n          }\n        }\n      } else if (schema === 'plain') {\n        log(`üìã Using plain schema - no JSON validation will be applied`);\n      }\n\n      // Pass schema in options object with 'schema' property\n      const schemaOptions = schemaString ? { schema: schemaString } : undefined;\n\n      // Store the exact schema options being passed to ProbeAgent in debug info\n      if (debugInfo && schemaOptions) {\n        debugInfo.schema = JSON.stringify(schemaOptions, null, 2);\n      }\n\n      // Log the schema options being passed to ProbeAgent\n      if (schemaOptions) {\n        log(`üéØ Schema options passed to ProbeAgent.answer() (session reuse):`);\n        log(JSON.stringify(schemaOptions, null, 2));\n      }\n\n      // Save prompt and debug info for session reuse too (only if debug enabled)\n      if (process.env.VISOR_DEBUG_AI_SESSIONS === 'true') {\n        try {\n          const fs = require('fs');\n          const path = require('path');\n          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n          const provider = this.config.provider || 'auto';\n          const model = this.config.model || 'default';\n\n          // Try to extract conversation history from ProbeAgent\n          let conversationHistory: any[] = [];\n          try {\n            // ProbeAgent stores history in different ways depending on version\n            const agentAny = agent as any;\n            if (agentAny.history) {\n              conversationHistory = agentAny.history;\n            } else if (agentAny.messages) {\n              conversationHistory = agentAny.messages;\n            } else if (agentAny._messages) {\n              conversationHistory = agentAny._messages;\n            }\n          } catch {\n            // Ignore if we can't access history\n          }\n\n          const debugData = {\n            timestamp: timestamp,\n            checkName: _checkName || 'unknown',\n            provider: provider,\n            model: model,\n            schema: effectiveSchema,\n            schemaOptions: schemaOptions || 'none',\n            sessionInfo: {\n              isSessionReuse: true,\n              historyMessageCount: conversationHistory.length,\n            },\n            currentPromptLength: prompt.length,\n            currentPrompt: prompt,\n            conversationHistory: conversationHistory,\n          };\n\n          const debugJson = JSON.stringify(debugData, null, 2);\n\n          // Also create a human-readable version with clear separators\n          let readableVersion = `=============================================================\\n`;\n          readableVersion += `VISOR DEBUG REPORT - SESSION REUSE\\n`;\n          readableVersion += `=============================================================\\n`;\n          readableVersion += `Timestamp: ${timestamp}\\n`;\n          readableVersion += `Check Name: ${_checkName || 'unknown'}\\n`;\n          readableVersion += `Provider: ${provider}\\n`;\n          readableVersion += `Model: ${model}\\n`;\n          readableVersion += `Schema: ${effectiveSchema}\\n`;\n          readableVersion += `Schema Options: ${schemaOptions ? 'provided' : 'none'}\\n`;\n          readableVersion += `History Messages: ${conversationHistory.length}\\n`;\n          readableVersion += `=============================================================\\n\\n`;\n\n          // Add schema details if provided\n          if (schemaOptions) {\n            readableVersion += `\\n${'='.repeat(60)}\\n`;\n            readableVersion += `SCHEMA CONFIGURATION\\n`;\n            readableVersion += `${'='.repeat(60)}\\n`;\n            readableVersion += JSON.stringify(schemaOptions, null, 2);\n            readableVersion += `\\n`;\n          }\n\n          // Add conversation history with clear separators\n          if (conversationHistory.length > 0) {\n            readableVersion += `\\n${'='.repeat(60)}\\n`;\n            readableVersion += `CONVERSATION HISTORY (${conversationHistory.length} messages)\\n`;\n            readableVersion += `${'='.repeat(60)}\\n`;\n            conversationHistory.forEach((msg: any, index: number) => {\n              readableVersion += `\\n${'-'.repeat(60)}\\n`;\n              readableVersion += `MESSAGE #${index + 1}\\n`;\n              readableVersion += `Role: ${msg.role || 'unknown'}\\n`;\n              if (msg.content) {\n                const contentStr =\n                  typeof msg.content === 'string'\n                    ? msg.content\n                    : JSON.stringify(msg.content, null, 2);\n                readableVersion += `Length: ${contentStr.length} characters\\n`;\n                readableVersion += `${'-'.repeat(60)}\\n`;\n                readableVersion += `${contentStr}\\n`;\n              }\n            });\n          }\n\n          // Add current prompt\n          readableVersion += `\\n${'='.repeat(60)}\\n`;\n          readableVersion += `CURRENT PROMPT (NEW MESSAGE)\\n`;\n          readableVersion += `${'='.repeat(60)}\\n`;\n          readableVersion += `Length: ${prompt.length} characters\\n`;\n          readableVersion += `${'-'.repeat(60)}\\n`;\n          readableVersion += `${prompt}\\n`;\n          readableVersion += `\\n${'='.repeat(60)}\\n`;\n          readableVersion += `END OF DEBUG REPORT\\n`;\n          readableVersion += `${'='.repeat(60)}\\n`;\n\n          const debugArtifactsDir =\n            process.env.VISOR_DEBUG_ARTIFACTS || path.join(process.cwd(), 'debug-artifacts');\n          if (!fs.existsSync(debugArtifactsDir)) {\n            fs.mkdirSync(debugArtifactsDir, { recursive: true });\n          }\n\n          // Save JSON version\n          const debugFile = path.join(\n            debugArtifactsDir,\n            `prompt-${_checkName || 'unknown'}-${timestamp}.json`\n          );\n          fs.writeFileSync(debugFile, debugJson, 'utf-8');\n\n          // Save readable version\n          const readableFile = path.join(\n            debugArtifactsDir,\n            `prompt-${_checkName || 'unknown'}-${timestamp}.txt`\n          );\n          fs.writeFileSync(readableFile, readableVersion, 'utf-8');\n\n          log(`\\nüíæ Full debug info saved to:`);\n          log(`   JSON: ${debugFile}`);\n          log(`   TXT:  ${readableFile}`);\n          log(`   - Includes: full conversation history, schema, current prompt`);\n        } catch (error) {\n          log(`‚ö†Ô∏è Could not save debug file: ${error}`);\n        }\n      }\n\n      // Use existing agent's answer method - this reuses the conversation context\n      // Wrap in a span for hierarchical tracing\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const agentAny = agent as any;\n      let response: string;\n      if (agentAny.tracer && typeof agentAny.tracer.withSpan === 'function') {\n        response = await agentAny.tracer.withSpan(\n          'visor.ai_check_reuse',\n          async () => {\n            return await agent.answer(prompt, undefined, schemaOptions);\n          },\n          {\n            'check.name': _checkName || 'unknown',\n            'check.mode': 'session_reuse',\n            'prompt.length': prompt.length,\n            'schema.type': effectiveSchema || 'none',\n          }\n        );\n      } else {\n        response = schemaOptions\n          ? await agent.answer(prompt, undefined, schemaOptions)\n          : await agent.answer(prompt);\n      }\n\n      log('‚úÖ ProbeAgent session reuse completed successfully');\n      log(`üì§ Response length: ${response.length} characters`);\n\n      // Save COMPLETE conversation history AFTER AI response (only if debug enabled)\n      if (process.env.VISOR_DEBUG_AI_SESSIONS === 'true') {\n        try {\n          const fs = require('fs');\n          const path = require('path');\n          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n\n          // Extract FULL conversation history AFTER the AI call\n          const agentAny = agent as any;\n          let fullHistory: any[] = [];\n\n          // Try multiple properties to get complete history\n          if (agentAny.history) {\n            fullHistory = agentAny.history;\n          } else if (agentAny.messages) {\n            fullHistory = agentAny.messages;\n          } else if (agentAny._messages) {\n            fullHistory = agentAny._messages;\n          }\n\n          const debugArtifactsDir =\n            process.env.VISOR_DEBUG_ARTIFACTS || path.join(process.cwd(), 'debug-artifacts');\n          // do not enforce directory perms here\n\n          // Save complete session history (all messages sent and received)\n          const sessionBase = path.join(\n            debugArtifactsDir,\n            `session-${_checkName || 'unknown'}-${timestamp}`\n          );\n          const sessionData = {\n            timestamp,\n            checkName: _checkName || 'unknown',\n            provider: this.config.provider || 'auto',\n            model: this.config.model || 'default',\n            schema: effectiveSchema,\n            totalMessages: fullHistory.length,\n          };\n          fs.writeFileSync(sessionBase + '.json', JSON.stringify(sessionData, null, 2), 'utf-8');\n\n          // Redacted textual summary\n          let readable = `=============================================================\n`;\n          readable += `COMPLETE AI SESSION HISTORY (AFTER RESPONSE)\n`;\n          readable += `=============================================================\n`;\n          readable += `Timestamp: ${timestamp}\n`;\n          readable += `Check: ${_checkName || 'unknown'}\n`;\n          readable += `Total Messages: ${fullHistory.length}\n`;\n          readable += `=============================================================\n\n`;\n          fullHistory.forEach((msg: any, idx: number) => {\n            const role = msg.role || 'unknown';\n            const content =\n              typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content, null, 2);\n            readable += `\n${'='.repeat(60)}\nMESSAGE ${idx + 1}/${fullHistory.length}\nRole: ${role}\n${'='.repeat(60)}\n`;\n            readable += content + '\\n';\n          });\n          fs.writeFileSync(sessionBase + '.summary.txt', readable, 'utf-8');\n\n          log(`üíæ Complete session history saved:`);\n          // (paths omitted)\n          log(`   - Contains ALL ${fullHistory.length} messages (prompts + responses)`);\n        } catch (error) {\n          log(`‚ö†Ô∏è Could not save complete session history: ${error}`);\n        }\n      }\n\n      // Save response if debug is enabled\n      if (process.env.VISOR_DEBUG_AI_SESSIONS === 'true') {\n        try {\n          const fs = require('fs');\n          const path = require('path');\n          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n\n          const debugArtifactsDir =\n            process.env.VISOR_DEBUG_ARTIFACTS || path.join(process.cwd(), 'debug-artifacts');\n\n          // Create a response file with the same timestamp pattern\n          const responseFile = path.join(\n            debugArtifactsDir,\n            `response-${_checkName || 'unknown'}-${timestamp}.txt`\n          );\n\n          let responseContent = `=============================================================\\n`;\n          responseContent += `VISOR AI RESPONSE - SESSION REUSE\\n`;\n          responseContent += `=============================================================\\n`;\n          responseContent += `Timestamp: ${timestamp}\\n`;\n          responseContent += `Check Name: ${_checkName || 'unknown'}\\n`;\n          responseContent += `Response Length: ${response.length} characters\\n`;\n          responseContent += `=============================================================\\n\\n`;\n          responseContent += `${'='.repeat(60)}\\n`;\n          responseContent += `AI RESPONSE\\n`;\n          responseContent += `${'='.repeat(60)}\\n`;\n          responseContent += response;\n          responseContent += `\\n${'='.repeat(60)}\\n`;\n          responseContent += `END OF RESPONSE\\n`;\n          responseContent += `${'='.repeat(60)}\\n`;\n\n          fs.writeFileSync(responseFile, responseContent, 'utf-8');\n          log(`üíæ Response saved to: ${responseFile}`);\n        } catch (error) {\n          log(`‚ö†Ô∏è Could not save response file: ${error}`);\n        }\n      }\n\n      // Finalize and save trace if this is a cloned session with tracing enabled\n      // Properly flush and shutdown OpenTelemetry to ensure all spans are exported\n      if (agentAny._traceFilePath && agentAny._telemetryConfig) {\n        try {\n          // First flush the tracer to export pending spans\n          if (agentAny.tracer && typeof agentAny.tracer.flush === 'function') {\n            await agentAny.tracer.flush();\n            log(`üîÑ Flushed tracer spans for cloned session`);\n          }\n\n          // Then shutdown the telemetry config to finalize all exporters\n          if (\n            agentAny._telemetryConfig &&\n            typeof agentAny._telemetryConfig.shutdown === 'function'\n          ) {\n            await agentAny._telemetryConfig.shutdown();\n            log(`üìä OpenTelemetry trace saved to: ${agentAny._traceFilePath}`);\n\n            // In GitHub Actions, also log file size for verification\n            if (process.env.GITHUB_ACTIONS) {\n              const fs = require('fs');\n              if (fs.existsSync(agentAny._traceFilePath)) {\n                const stats = fs.statSync(agentAny._traceFilePath);\n                console.log(\n                  `::notice title=AI Trace Saved::${agentAny._traceFilePath} (${stats.size} bytes)`\n                );\n              }\n            }\n          } else if (agentAny.tracer && typeof agentAny.tracer.shutdown === 'function') {\n            // Fallback for SimpleTelemetry\n            await agentAny.tracer.shutdown();\n            log(`üìä Trace saved to: ${agentAny._traceFilePath}`);\n          }\n        } catch (exportError) {\n          logger.warn(`‚ö†Ô∏è  Warning: Failed to export trace for cloned session: ${exportError}`);\n        }\n      }\n\n      return { response, effectiveSchema };\n    } catch (error) {\n      logger.error(\n        `‚ùå ProbeAgent session reuse failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n      throw new Error(\n        `ProbeAgent session reuse failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Call ProbeAgent SDK with built-in schema validation\n   */\n  private async callProbeAgent(\n    prompt: string,\n    schema?: string | Record<string, unknown>,\n    debugInfo?: AIDebugInfo,\n    _checkName?: string,\n    providedSessionId?: string\n  ): Promise<{ response: string; effectiveSchema?: string }> {\n    // Handle mock model/provider\n    if (this.config.model === 'mock' || this.config.provider === 'mock') {\n      const inJest = !!process.env.JEST_WORKER_ID;\n      log('üé≠ Using mock AI model/provider');\n      if (!inJest) {\n        // Fast path for CLI/integration: synthesize a mock response without invoking ProbeAgent\n        const response = await this.generateMockResponse(prompt, _checkName, schema);\n        return { response, effectiveSchema: typeof schema === 'object' ? 'custom' : schema };\n      }\n      // In unit tests, still invoke ProbeAgent so tests can assert on options (schema) passed in\n      // Fall through to normal flow below\n    }\n\n    // Create ProbeAgent instance with proper options\n    const sessionId =\n      providedSessionId ||\n      (() => {\n        const timestamp = new Date().toISOString();\n        return `visor-${timestamp.replace(/[:.]/g, '-')}-${_checkName || 'unknown'}`;\n      })();\n\n    log('ü§ñ Creating ProbeAgent for AI review...');\n    log(`üÜî Session ID: ${sessionId}`);\n    log(`üìù Prompt length: ${prompt.length} characters`);\n    log(`‚öôÔ∏è Model: ${this.config.model || 'default'}, Provider: ${this.config.provider || 'auto'}`);\n\n    // Store original env vars to restore later\n    const originalEnv: Record<string, string | undefined> = {\n      CLAUDE_CODE_API_KEY: process.env.CLAUDE_CODE_API_KEY,\n      GOOGLE_API_KEY: process.env.GOOGLE_API_KEY,\n      ANTHROPIC_API_KEY: process.env.ANTHROPIC_API_KEY,\n      OPENAI_API_KEY: process.env.OPENAI_API_KEY,\n    };\n\n    try {\n      // Set environment variables for ProbeAgent\n      // ProbeAgent SDK expects these to be in the environment\n      if (this.config.provider === 'claude-code' && this.config.apiKey) {\n        process.env.CLAUDE_CODE_API_KEY = this.config.apiKey;\n        // Also set ANTHROPIC_API_KEY as fallback since Claude Code uses Anthropic API\n        process.env.ANTHROPIC_API_KEY = this.config.apiKey;\n      } else if (this.config.provider === 'google' && this.config.apiKey) {\n        process.env.GOOGLE_API_KEY = this.config.apiKey;\n      } else if (this.config.provider === 'anthropic' && this.config.apiKey) {\n        process.env.ANTHROPIC_API_KEY = this.config.apiKey;\n      } else if (this.config.provider === 'openai' && this.config.apiKey) {\n        process.env.OPENAI_API_KEY = this.config.apiKey;\n      } else if (this.config.provider === 'bedrock') {\n        // For Bedrock, ProbeAgent will use AWS credentials from environment\n        // No need to set apiKey as it uses AWS SDK authentication\n        // ProbeAgent will check for AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, etc.\n      }\n      const explicitPromptType = (process.env.VISOR_PROMPT_TYPE || '').trim();\n      const options: TracedProbeAgentOptions = {\n        sessionId: sessionId,\n        // Prefer config promptType, then env override, else fallback to code-review when schema is set\n        promptType:\n          this.config.promptType && this.config.promptType.trim()\n            ? (this.config.promptType.trim() as any)\n            : explicitPromptType\n              ? (explicitPromptType as any)\n              : schema === 'code-review'\n                ? ('code-review-template' as any)\n                : undefined,\n        allowEdit: false, // We don't want the agent to modify files\n        debug: this.config.debug || false,\n        // Map systemPrompt to Probe customPrompt until SDK exposes a first-class field\n        customPrompt: this.config.systemPrompt || this.config.customPrompt,\n      };\n\n      // Enable tracing in debug mode for better diagnostics\n      // This uses SimpleTelemetry for lightweight tracing\n      let traceFilePath = '';\n      let telemetryConfig: unknown = null;\n      if (this.config.debug) {\n        const tracerResult = await initializeTracer(sessionId, _checkName);\n        if (tracerResult) {\n          options.tracer = tracerResult.tracer;\n          telemetryConfig = tracerResult.telemetryConfig;\n          traceFilePath = tracerResult.filePath;\n        }\n      }\n\n      // Wire MCP configuration when provided\n      if (this.config.mcpServers && Object.keys(this.config.mcpServers).length > 0) {\n        (options as any).enableMcp = true;\n        (options as any).mcpConfig = { mcpServers: this.config.mcpServers };\n      }\n\n      // Enable delegate tool if configured\n      if (this.config.enableDelegate !== undefined) {\n        (options as any).enableDelegate = this.config.enableDelegate;\n      }\n\n      // Pass retry configuration to ProbeAgent\n      if (this.config.retry) {\n        (options as any).retry = this.config.retry;\n      }\n\n      // Pass fallback configuration to ProbeAgent\n      if (this.config.fallback) {\n        (options as any).fallback = this.config.fallback;\n      }\n\n      // Enable Edit and Create tools if configured\n      if (this.config.allowEdit !== undefined) {\n        (options as any).allowEdit = this.config.allowEdit;\n      }\n\n      // Pass tool filtering options to ProbeAgent\n      if (this.config.allowedTools !== undefined) {\n        (options as any).allowedTools = this.config.allowedTools;\n      }\n      if (this.config.disableTools !== undefined) {\n        (options as any).disableTools = this.config.disableTools;\n      }\n\n      // Pass bash command execution configuration to ProbeAgent\n      // Pass allowBash and bashConfig separately (following allowEdit pattern)\n      if (this.config.allowBash !== undefined) {\n        (options as any).allowBash = this.config.allowBash;\n      }\n      if (this.config.bashConfig !== undefined) {\n        (options as any).bashConfig = this.config.bashConfig;\n      }\n\n      // Add provider-specific options if configured\n      if (this.config.provider) {\n        // Map claude-code to anthropic for ProbeAgent compatibility\n        // Map bedrock to anthropic temporarily until ProbeAgent adds bedrock type\n        const providerOverride: ProbeAgentOptions['provider'] | undefined =\n          this.config.provider === 'claude-code' || this.config.provider === 'bedrock'\n            ? 'anthropic'\n            : this.config.provider === 'anthropic' ||\n                this.config.provider === 'openai' ||\n                this.config.provider === 'google'\n              ? this.config.provider\n              : undefined;\n\n        if (providerOverride) {\n          options.provider = providerOverride;\n        }\n      }\n      if (this.config.model) {\n        options.model = this.config.model;\n      }\n\n      const agent = new ProbeAgent(options);\n\n      log('üöÄ Calling ProbeAgent...');\n      // Load and pass the actual schema content if provided (skip for plain schema)\n      let schemaString: string | undefined = undefined;\n      let effectiveSchema: string | undefined = typeof schema === 'object' ? 'custom' : schema;\n\n      if (schema && schema !== 'plain') {\n        try {\n          schemaString = await this.loadSchemaContent(schema);\n          log(`üìã Loaded schema content for: ${schema}`);\n          log(`üìÑ Raw schema JSON:\\n${schemaString}`);\n        } catch (error) {\n          log(`‚ö†Ô∏è Failed to load schema ${schema}, proceeding without schema:`, error);\n          schemaString = undefined;\n          effectiveSchema = undefined; // Schema loading failed, treat as no schema\n          if (debugInfo && debugInfo.errors) {\n            debugInfo.errors.push(`Failed to load schema: ${error}`);\n          }\n        }\n      } else if (schema === 'plain') {\n        log(`üìã Using plain schema - no JSON validation will be applied`);\n      }\n\n      // ProbeAgent now handles schema formatting internally!\n      // Pass schema in options object with 'schema' property\n      const schemaOptions = schemaString ? { schema: schemaString } : undefined;\n\n      // Store the exact schema options being passed to ProbeAgent in debug info\n      if (debugInfo && schemaOptions) {\n        debugInfo.schema = JSON.stringify(schemaOptions, null, 2);\n      }\n\n      // Log the schema options being passed to ProbeAgent\n      if (schemaOptions) {\n        log(`üéØ Schema options passed to ProbeAgent.answer():`);\n        log(JSON.stringify(schemaOptions, null, 2));\n      }\n\n      // Log the equivalent CLI command for local reproduction\n      const provider = this.config.provider || 'auto';\n      const model = this.config.model || 'default';\n\n      // Save prompt to a temp file AND debug artifacts for easier reproduction (only if debug enabled)\n      if (process.env.VISOR_DEBUG_AI_SESSIONS === 'true') {\n        try {\n          const fs = require('fs');\n          const path = require('path');\n          const os = require('os');\n          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n\n          // Prepare debug info with full details\n          const debugData = {\n            timestamp,\n            checkName: _checkName || 'unknown',\n            provider,\n            model,\n            schema: effectiveSchema,\n            schemaOptions: schemaOptions || 'none',\n            sessionInfo: {\n              isSessionReuse: false,\n              isNewSession: true,\n            },\n            promptLength: prompt.length,\n            prompt: prompt,\n          };\n\n          const debugJson = JSON.stringify(debugData, null, 2);\n\n          // Create human-readable version with clear separators\n          let readableVersion = `=============================================================\\n`;\n          readableVersion += `VISOR DEBUG REPORT - NEW SESSION\\n`;\n          readableVersion += `=============================================================\\n`;\n          readableVersion += `Timestamp: ${timestamp}\\n`;\n          readableVersion += `Check Name: ${_checkName || 'unknown'}\\n`;\n          readableVersion += `Provider: ${provider}\\n`;\n          readableVersion += `Model: ${model}\\n`;\n          readableVersion += `Schema: ${effectiveSchema}\\n`;\n          readableVersion += `Schema Options: ${schemaOptions ? 'provided' : 'none'}\\n`;\n          readableVersion += `Session Type: New Session (no history)\\n`;\n          readableVersion += `=============================================================\\n\\n`;\n\n          // Add schema details if provided\n          if (schemaOptions) {\n            readableVersion += `\\n${'='.repeat(60)}\\n`;\n            readableVersion += `SCHEMA CONFIGURATION\\n`;\n            readableVersion += `${'='.repeat(60)}\\n`;\n            readableVersion += JSON.stringify(schemaOptions, null, 2);\n            readableVersion += `\\n`;\n          }\n\n          // Add prompt\n          readableVersion += `\\n${'='.repeat(60)}\\n`;\n          readableVersion += `PROMPT\\n`;\n          readableVersion += `${'='.repeat(60)}\\n`;\n          readableVersion += `Length: ${prompt.length} characters\\n`;\n          readableVersion += `${'-'.repeat(60)}\\n`;\n          readableVersion += `${prompt}\\n`;\n          readableVersion += `\\n${'='.repeat(60)}\\n`;\n          readableVersion += `END OF DEBUG REPORT\\n`;\n          readableVersion += `${'='.repeat(60)}\\n`;\n\n          // Save to temp directory\n          const tempDir = os.tmpdir();\n          const promptFile = path.join(tempDir, `visor-prompt-${timestamp}.txt`);\n          fs.writeFileSync(promptFile, prompt, 'utf-8');\n          log(`\\nüíæ Prompt saved to: ${promptFile}`);\n\n          // Also save to debug-artifacts directory if available\n          const debugArtifactsDir =\n            process.env.VISOR_DEBUG_ARTIFACTS || path.join(process.cwd(), 'debug-artifacts');\n          try {\n            // do not enforce fs permissions here\n            const base = path.join(\n              debugArtifactsDir,\n              `prompt-${_checkName || 'unknown'}-${timestamp}`\n            );\n            fs.writeFileSync(base + '.json', debugJson, 'utf-8');\n            fs.writeFileSync(base + '.summary.txt', readableVersion, 'utf-8');\n            log(`\nüíæ Full debug info saved to directory: ${debugArtifactsDir}`);\n          } catch {\n            // Ignore if we can't write to debug-artifacts\n          }\n\n          log(`\\nüìù To reproduce locally, run:`);\n\n          let cliCommand = `npx @probelabs/probe@latest agent`;\n          cliCommand += ` --provider ${provider}`;\n          if (model !== 'default') {\n            cliCommand += ` --model ${model}`;\n          }\n          if (schema) {\n            cliCommand += ` --schema output/${schema}/schema.json`;\n          }\n          cliCommand += ` \"${promptFile}\"`;\n\n          log(`\\n$ ${cliCommand}\\n`);\n        } catch (error) {\n          log(`‚ö†Ô∏è Could not save prompt file: ${error}`);\n        }\n      }\n\n      // Wrap the agent.answer() call in a span for hierarchical tracing\n      // This creates a parent span that will contain all ProbeAgent's child spans\n      let response: string;\n      const tracer = options.tracer as {\n        withSpan?: (\n          name: string,\n          fn: () => Promise<string>,\n          attrs?: Record<string, unknown>\n        ) => Promise<string>;\n      };\n      if (tracer && typeof tracer.withSpan === 'function') {\n        response = await tracer.withSpan(\n          'visor.ai_check',\n          async () => {\n            return await agent.answer(prompt, undefined, schemaOptions);\n          },\n          {\n            'check.name': _checkName || 'unknown',\n            'check.session_id': sessionId,\n            'prompt.length': prompt.length,\n            'schema.type': effectiveSchema || 'none',\n          }\n        );\n      } else {\n        response = schemaOptions\n          ? await agent.answer(prompt, undefined, schemaOptions)\n          : await agent.answer(prompt);\n      }\n\n      log('‚úÖ ProbeAgent completed successfully');\n      log(`üì§ Response length: ${response.length} characters`);\n\n      // Save COMPLETE conversation history AFTER AI response (only if debug enabled)\n      if (process.env.VISOR_DEBUG_AI_SESSIONS === 'true') {\n        try {\n          const fs = require('fs');\n          const path = require('path');\n          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n\n          // Extract FULL conversation history AFTER the AI call\n          const agentAny = agent as any;\n          let fullHistory: any[] = [];\n\n          // Try multiple properties to get complete history\n          if (agentAny.history) {\n            fullHistory = agentAny.history;\n          } else if (agentAny.messages) {\n            fullHistory = agentAny.messages;\n          } else if (agentAny._messages) {\n            fullHistory = agentAny._messages;\n          }\n\n          const debugArtifactsDir =\n            process.env.VISOR_DEBUG_ARTIFACTS || path.join(process.cwd(), 'debug-artifacts');\n          // do not enforce fs permissions here\n\n          // Save complete session history (all messages sent and received)\n          const sessionBase = path.join(\n            debugArtifactsDir,\n            `session-${_checkName || 'unknown'}-${timestamp}`\n          );\n          const sessionData = {\n            timestamp,\n            checkName: _checkName || 'unknown',\n            provider: this.config.provider || 'auto',\n            model: this.config.model || 'default',\n            schema: effectiveSchema,\n            totalMessages: fullHistory.length,\n          };\n          fs.writeFileSync(sessionBase + '.json', JSON.stringify(sessionData, null, 2), 'utf-8');\n\n          // Redacted textual summary\n          let readable = `=============================================================\n`;\n          readable += `COMPLETE AI SESSION HISTORY (AFTER RESPONSE)\n`;\n          readable += `=============================================================\n`;\n          readable += `Timestamp: ${timestamp}\n`;\n          readable += `Check: ${_checkName || 'unknown'}\n`;\n          readable += `Total Messages: ${fullHistory.length}\n`;\n          readable += `=============================================================\n\n`;\n          fullHistory.forEach((msg: any, idx: number) => {\n            const role = msg.role || 'unknown';\n            const content =\n              typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content, null, 2);\n            readable += `\n${'='.repeat(60)}\nMESSAGE ${idx + 1}/${fullHistory.length}\nRole: ${role}\n${'='.repeat(60)}\n`;\n            readable += content + '\\n';\n          });\n          fs.writeFileSync(sessionBase + '.summary.txt', readable, 'utf-8');\n\n          log(`üíæ Complete session history saved:`);\n          // (paths omitted)\n          log(`   - Contains ALL ${fullHistory.length} messages (prompts + responses)`);\n        } catch (error) {\n          log(`‚ö†Ô∏è Could not save complete session history: ${error}`);\n        }\n      }\n\n      // Save response if debug is enabled\n      if (process.env.VISOR_DEBUG_AI_SESSIONS === 'true') {\n        try {\n          const fs = require('fs');\n          const path = require('path');\n          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n\n          const debugArtifactsDir =\n            process.env.VISOR_DEBUG_ARTIFACTS || path.join(process.cwd(), 'debug-artifacts');\n\n          // Create a response file\n          const responseFile = path.join(\n            debugArtifactsDir,\n            `response-${_checkName || 'unknown'}-${timestamp}.txt`\n          );\n\n          let responseContent = `=============================================================\\n`;\n          responseContent += `VISOR AI RESPONSE - NEW SESSION\\n`;\n          responseContent += `=============================================================\\n`;\n          responseContent += `Timestamp: ${timestamp}\\n`;\n          responseContent += `Check Name: ${_checkName || 'unknown'}\\n`;\n          responseContent += `Response Length: ${response.length} characters\\n`;\n          responseContent += `=============================================================\\n\\n`;\n          responseContent += `${'='.repeat(60)}\\n`;\n          responseContent += `AI RESPONSE\\n`;\n          responseContent += `${'='.repeat(60)}\\n`;\n          responseContent += response;\n          responseContent += `\\n${'='.repeat(60)}\\n`;\n          responseContent += `END OF RESPONSE\\n`;\n          responseContent += `${'='.repeat(60)}\\n`;\n\n          fs.writeFileSync(responseFile, responseContent, 'utf-8');\n          log(`üíæ Response saved to: ${responseFile}`);\n        } catch (error) {\n          log(`‚ö†Ô∏è Could not save response file: ${error}`);\n        }\n      }\n\n      // Finalize and save trace if enabled\n      // Properly flush and shutdown telemetry to ensure all spans are exported\n      if (traceFilePath && telemetryConfig) {\n        try {\n          // Cast telemetryConfig to have optional methods\n          const telemetry = telemetryConfig as {\n            flush?: () => Promise<void>;\n            shutdown?: () => Promise<void>;\n          };\n          const tracerWithMethods = tracer as {\n            flush?: () => Promise<void>;\n            shutdown?: () => Promise<void>;\n          };\n\n          // First flush the tracer to export pending spans\n          if (tracerWithMethods && typeof tracerWithMethods.flush === 'function') {\n            await tracerWithMethods.flush();\n            log(`üîÑ Flushed tracer spans`);\n          }\n\n          // Then shutdown the telemetry config to finalize all exporters\n          if (telemetry && typeof telemetry.shutdown === 'function') {\n            await telemetry.shutdown();\n            log(`üìä OpenTelemetry trace saved to: ${traceFilePath}`);\n\n            // In GitHub Actions, also log file size for verification\n            if (process.env.GITHUB_ACTIONS) {\n              const fs = require('fs');\n              if (fs.existsSync(traceFilePath)) {\n                const stats = fs.statSync(traceFilePath);\n                console.log(\n                  `::notice title=AI Trace Saved::OpenTelemetry trace file size: ${stats.size} bytes`\n                );\n              }\n            }\n          } else if (tracerWithMethods && typeof tracerWithMethods.shutdown === 'function') {\n            // Fallback for SimpleTelemetry\n            await tracerWithMethods.shutdown();\n            log(`üìä Trace saved to: ${traceFilePath}`);\n          }\n        } catch (exportError) {\n          logger.warn(`‚ö†Ô∏è  Warning: Failed to export trace: ${exportError}`);\n        }\n      }\n\n      // Register the session for potential reuse by dependent checks\n      if (_checkName) {\n        // ProbeAgent.clone() will handle history filtering when this session is cloned\n        this.registerSession(sessionId, agent);\n        log(`üîß Debug: Registered AI session for potential reuse: ${sessionId}`);\n      }\n\n      return { response, effectiveSchema };\n    } catch (error) {\n      console.error('‚ùå ProbeAgent failed:', error);\n      throw new Error(\n        `ProbeAgent execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    } finally {\n      // Restore original environment variables\n      Object.keys(originalEnv).forEach(key => {\n        if (originalEnv[key] === undefined) {\n          delete process.env[key];\n        } else {\n          process.env[key] = originalEnv[key];\n        }\n      });\n    }\n  }\n\n  /**\n   * Load schema content from schema files or inline definitions\n   */\n  private async loadSchemaContent(schema: string | Record<string, unknown>): Promise<string> {\n    const fs = require('fs').promises;\n    const path = require('path');\n\n    // Check if schema is already an object (inline definition from YAML)\n    if (typeof schema === 'object' && schema !== null) {\n      // It's already a schema object, convert to JSON string\n      log('üìã Using inline schema object from configuration');\n      return JSON.stringify(schema);\n    }\n\n    // Check if schema string is already a JSON schema (inline JSON string)\n    // This happens when a schema is passed directly as JSON instead of a reference\n    try {\n      const parsed = JSON.parse(schema);\n      if (typeof parsed === 'object' && parsed !== null) {\n        // It's already a valid JSON schema, return it as-is\n        log('üìã Using inline schema JSON string');\n        return schema;\n      }\n    } catch {\n      // Not JSON, treat as schema name reference or file path\n    }\n\n    // Check if it's a file path (starts with ./ or contains .json but not absolute paths)\n    if ((schema.startsWith('./') || schema.includes('.json')) && !path.isAbsolute(schema)) {\n      // It's a relative file path to a custom schema\n      // Validate the path to prevent traversal attacks\n      if (schema.includes('..') || schema.includes('\\x00')) {\n        throw new Error('Invalid schema path: path traversal not allowed');\n      }\n\n      try {\n        const schemaPath = path.resolve(process.cwd(), schema);\n        log(`üìã Loading custom schema from file: ${schemaPath}`);\n        const schemaContent = await fs.readFile(schemaPath, 'utf-8');\n        return schemaContent.trim();\n      } catch (error) {\n        throw new Error(\n          `Failed to load custom schema from ${schema}: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n      }\n    }\n\n    // Otherwise, treat as a built-in schema name\n    // Sanitize schema name to prevent path traversal attacks\n    const sanitizedSchemaName = schema.replace(/[^a-zA-Z0-9-]/g, '');\n    if (!sanitizedSchemaName || sanitizedSchemaName !== schema) {\n      throw new Error('Invalid schema name');\n    }\n\n    // Built-in schemas are bundled under dist/output when running as a GitHub Action.\n    // In local dev (ts-node/jest), schemas may live under project/output.\n    // Try dist-relative first, then fall back to CWD.\n    const candidatePaths = [\n      // GitHub Action bundle location\n      path.join(__dirname, 'output', sanitizedSchemaName, 'schema.json'),\n      // Historical fallback when src/output was inadvertently bundled as output1/\n      path.join(__dirname, 'output1', sanitizedSchemaName, 'schema.json'),\n      // Local dev (repo root)\n      path.join(process.cwd(), 'output', sanitizedSchemaName, 'schema.json'),\n    ];\n\n    for (const schemaPath of candidatePaths) {\n      try {\n        const schemaContent = await fs.readFile(schemaPath, 'utf-8');\n        return schemaContent.trim();\n      } catch {\n        // try next\n      }\n    }\n\n    // If neither path works, surface a helpful error\n    const distPath = path.join(__dirname, 'output', sanitizedSchemaName, 'schema.json');\n    const distAltPath = path.join(__dirname, 'output1', sanitizedSchemaName, 'schema.json');\n    const cwdPath = path.join(process.cwd(), 'output', sanitizedSchemaName, 'schema.json');\n    throw new Error(\n      `Failed to load schema '${sanitizedSchemaName}'. Tried: ${distPath}, ${distAltPath}, and ${cwdPath}. ` +\n        `Ensure build copies 'output/' into dist (build:cli), or provide a custom schema file/path.`\n    );\n  }\n\n  /**\n   * Parse AI response JSON\n   */\n  private parseAIResponse(\n    response: string,\n    debugInfo?: AIDebugInfo,\n    _schema?: string\n  ): ReviewSummary {\n    log('üîç Parsing AI response...');\n    log(`üìä Raw response length: ${response.length} characters`);\n\n    // Log first and last 200 chars for debugging\n    if (response.length > 400) {\n      log('üìã Response preview (first 200 chars):', response.substring(0, 200));\n      log('üìã Response preview (last 200 chars):', response.substring(response.length - 200));\n    } else {\n      log('üìã Full response preview:', response);\n    }\n\n    // Note: Removed overly aggressive Liquid template check that was causing false positives\n    // JSON parsing below will catch actual malformed responses\n\n    try {\n      // Handle different schema types differently\n      let reviewData: AIResponseFormat;\n\n      // Handle plain schema or no schema - no JSON parsing, return response as-is\n      if (_schema === 'plain' || !_schema) {\n        log(\n          `üìã ${_schema === 'plain' ? 'Plain' : 'No'} schema detected - returning raw response without JSON parsing`\n        );\n\n        // For plain schema, return the raw response as an issue\n\n        return {\n          issues: [\n            {\n              file: 'AI_RESPONSE',\n              line: 1,\n              ruleId: 'ai/raw_response',\n              message: response,\n              severity: 'info',\n              category: 'documentation',\n            },\n          ],\n          debug: debugInfo,\n        };\n      }\n\n      {\n        // For other schemas (code-review, etc.), extract and parse JSON with boundary detection\n        log('üîç Extracting JSON from AI response...');\n\n        // Try direct parsing first - if AI returned pure JSON\n        try {\n          reviewData = JSON.parse(response.trim());\n          log('‚úÖ Successfully parsed direct JSON response');\n          if (debugInfo) debugInfo.jsonParseSuccess = true;\n        } catch {\n          log('üîç Direct parsing failed, trying to extract JSON from response...');\n\n          // If the response starts with \"I cannot\" or similar, it's likely a refusal\n          if (\n            response.toLowerCase().includes('i cannot') ||\n            response.toLowerCase().includes('unable to')\n          ) {\n            console.error('üö´ AI refused to analyze - returning empty result');\n            return {\n              issues: [],\n            };\n          }\n\n          // Try to extract JSON using improved method with proper bracket matching\n          const jsonString = this.extractJsonFromResponse(response);\n\n          if (jsonString) {\n            try {\n              reviewData = JSON.parse(jsonString);\n              log('‚úÖ Successfully parsed extracted JSON');\n              if (debugInfo) debugInfo.jsonParseSuccess = true;\n            } catch {\n              log('üîß Extracted JSON parsing failed, falling back to plain text handling...');\n\n              // Check if response is plain text and doesn't contain structured data\n              if (!response.includes('{') && !response.includes('}')) {\n                log('üîß Plain text response detected, creating structured fallback...');\n\n                reviewData = {\n                  issues: [\n                    {\n                      file: 'AI_RESPONSE',\n                      line: 1,\n                      ruleId: 'ai/raw_response',\n                      message: response,\n                      severity: 'info',\n                      category: 'documentation',\n                    },\n                  ],\n                };\n              } else {\n                // Fallback: treat the entire response as an issue\n                log('üîß Creating fallback response from non-JSON content...');\n                reviewData = {\n                  issues: [\n                    {\n                      file: 'AI_RESPONSE',\n                      line: 1,\n                      ruleId: 'ai/raw_response',\n                      message: response,\n                      severity: 'info',\n                      category: 'documentation',\n                    },\n                  ],\n                };\n              }\n            }\n          } else {\n            // No JSON found at all - treat as plain text response\n            log('üîß No JSON found in response, treating as plain text...');\n            reviewData = {\n              issues: [\n                {\n                  file: 'AI_RESPONSE',\n                  line: 1,\n                  ruleId: 'ai/raw_response',\n                  message: response,\n                  severity: 'info',\n                  category: 'documentation',\n                },\n              ],\n            };\n          }\n        }\n      }\n\n      // Decide how to interpret the parsed JSON based on the effective schema and the shape of data\n      // Built-ins:\n      //  - 'code-review' ‚Üí expects { issues: [...] }\n      //  - 'overview' / assistants ‚Üí expects { text: string, ... }\n      //  - 'plain' ‚Üí handled earlier\n      //  - custom (object/file path) ‚Üí free-form object, ensure output.text fallback\n      const looksLikeTextOutput =\n        reviewData &&\n        typeof reviewData === 'object' &&\n        typeof (reviewData as any).text === 'string' &&\n        String((reviewData as any).text).trim().length > 0;\n\n      // Treat as custom/text-style when:\n      //  - explicit custom schema\n      //  - schema is any non code-review built-in like 'overview', 'issue-assistant', 'comment-assistant'\n      //  - or schema is unknown/undefined but the payload clearly contains a text field\n      const isCustomSchema =\n        _schema === 'custom' ||\n        (_schema && (_schema.startsWith('./') || _schema.endsWith('.json'))) ||\n        (_schema && _schema !== 'code-review' && !_schema.includes('output/')) ||\n        (!_schema && looksLikeTextOutput);\n\n      const _debugSchemaLogging =\n        this.config.debug === true || process.env.VISOR_DEBUG_AI_SESSIONS === 'true';\n      if (_debugSchemaLogging) {\n        const details = {\n          schema: _schema,\n          isCustomSchema,\n          isCustomLiteral: _schema === 'custom',\n          startsWithDotSlash: typeof _schema === 'string' ? _schema.startsWith('./') : false,\n          endsWithJson: typeof _schema === 'string' ? _schema.endsWith('.json') : false,\n          notCodeReview: _schema !== 'code-review',\n          noOutputPrefix: typeof _schema === 'string' ? !_schema.includes('output/') : false,\n        };\n        try {\n          log(`üîç Schema detection: ${JSON.stringify(details)}`);\n        } catch {\n          // Fallback if JSON.stringify throws on unexpected values\n          log(\n            `üîç Schema detection: _schema=\"${String(_schema)}\", isCustomSchema=${isCustomSchema}`\n          );\n        }\n      }\n\n      if (isCustomSchema) {\n        // For custom schemas, preserve ALL fields from the parsed JSON and make sure\n        // we always have something renderable in templates (e.g., output.text).\n        log('üìã Custom schema detected - preserving all fields from parsed JSON');\n        log(`üìä Schema: ${_schema}`);\n        try {\n          log(`üìä Custom schema keys: ${Object.keys(reviewData).join(', ')}`);\n        } catch {}\n\n        // Ensure \"output\" is an object and has a sensible text fallback for templates\n        const out: Record<string, unknown> =\n          reviewData && typeof reviewData === 'object' ? (reviewData as any) : ({} as any);\n\n        const hasText =\n          typeof (out as any).text === 'string' && String((out as any).text).trim().length > 0;\n        if (!hasText) {\n          // Build a fallback string from the raw response or issue messages if available\n          let fallbackText = '';\n          try {\n            if (\n              Array.isArray((reviewData as any)?.issues) &&\n              (reviewData as any).issues.length > 0\n            ) {\n              // Join issue messages into a readable block\n              fallbackText = (reviewData as any).issues\n                .map((i: any) => (i && (i.message || i.text || i.response)) as string)\n                .filter((s: any) => typeof s === 'string' && s.trim().length > 0)\n                .join('\\n');\n            }\n          } catch {}\n          if (!fallbackText && typeof response === 'string' && response.trim()) {\n            // Use raw provider response (trim and bound length for safety)\n            fallbackText = response.trim().slice(0, 60000);\n          }\n          if (fallbackText) {\n            (out as any).text = fallbackText;\n          }\n        }\n\n        const result: ReviewSummary & { output?: unknown } = {\n          // Keep issues empty for custom-schema rendering; consumers read from output.*\n          issues: [],\n          output: out,\n        };\n\n        log(\n          '‚úÖ Successfully created ReviewSummary with custom schema output (with fallback text when needed)'\n        );\n        return result;\n      }\n\n      // Standard code-review schema processing (only when schema is explicitly code-review\n      // or when the payload clearly has an issues array)\n      log('üîç Validating parsed review data...');\n      log(`üìä Overall score: ${0}`);\n      log(`üìã Total issues: ${reviewData.issues?.length || 0}`);\n      log(\n        `üö® Critical issues: ${reviewData.issues?.filter((i: { severity?: string }) => i.severity === 'critical').length || 0}`\n      );\n      log(`üí¨ Comments count: ${Array.isArray(reviewData.issues) ? reviewData.issues.length : 0}`);\n\n      // Process issues from the simplified format; if we don't have issues and the\n      // data looks like a text-style output, route through the custom path above.\n      const processedIssues = Array.isArray((reviewData as any).issues)\n        ? (reviewData as any).issues.map((issue: any, index: number) => {\n            log(`üîç Processing issue ${index + 1}:`, issue);\n            return {\n              file: issue.file || 'unknown',\n              line: issue.line || 1,\n              endLine: issue.endLine,\n              ruleId: issue.ruleId || `${issue.category || 'general'}/unknown`,\n              message: issue.message || '',\n              severity: issue.severity,\n              category: issue.category,\n              suggestion: issue.suggestion,\n              replacement: issue.replacement,\n            } as ReviewIssue;\n          })\n        : [];\n\n      // Validate and convert to ReviewSummary format\n      const result: ReviewSummary = {\n        issues: processedIssues,\n      };\n\n      // Log issue counts\n      const criticalCount = (result.issues || []).filter(i => i.severity === 'critical').length;\n      if (criticalCount > 0) {\n        log(`üö® Found ${criticalCount} critical severity issue(s)`);\n      }\n      log(`üìà Total issues: ${(result.issues || []).length}`);\n\n      log('‚úÖ Successfully created ReviewSummary');\n      return result;\n    } catch (error) {\n      const detailed = this.config.debug === true || process.env.VISOR_DEBUG_AI_SESSIONS === 'true';\n      const message = error instanceof Error ? error.message : String(error);\n\n      if (detailed) {\n        logger.debug(`‚ùå Failed to parse AI response: ${message}`);\n        logger.debug('üìÑ FULL RAW RESPONSE:');\n        logger.debug('='.repeat(80));\n        logger.debug(response);\n        logger.debug('='.repeat(80));\n        logger.debug(`üìè Response length: ${response.length} characters`);\n\n        if (error instanceof SyntaxError) {\n          logger.debug('üîç JSON parsing error - the response may not be valid JSON');\n          logger.debug(`üîç Error details: ${error.message}`);\n\n          const errorMatch = error.message.match(/position (\\d+)/);\n          if (errorMatch) {\n            const position = parseInt(errorMatch[1]);\n            logger.debug(`üîç Error at position ${position}:`);\n            const start = Math.max(0, position - 50);\n            const end = Math.min(response.length, position + 50);\n            logger.debug(`üîç Context: \"${response.substring(start, end)}\"`);\n            logger.debug(`üîç Response beginning: \"${response.substring(0, 100)}\"`);\n          }\n\n          if (response.includes('I cannot')) {\n            logger.debug('üîç Response appears to be a refusal/explanation rather than JSON');\n          }\n          if (response.includes('```')) {\n            logger.debug('üîç Response appears to contain markdown code blocks');\n          }\n          if (response.startsWith('<')) {\n            logger.debug('üîç Response appears to start with XML/HTML');\n          }\n        }\n      } else {\n        logger.error(`‚ùå Failed to parse AI response: ${message}`);\n      }\n\n      throw new Error(\n        `Invalid AI response format: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Extract JSON from a response that might contain surrounding text\n   * Uses proper bracket matching to find valid JSON objects or arrays\n   */\n  private extractJsonFromResponse(response: string): string | null {\n    const text = response.trim();\n\n    // Try to find JSON objects first (higher priority)\n    let bestJson = this.findJsonWithBracketMatching(text, '{', '}');\n\n    // If no object found, try arrays\n    if (!bestJson) {\n      bestJson = this.findJsonWithBracketMatching(text, '[', ']');\n    }\n\n    return bestJson;\n  }\n\n  /**\n   * Find JSON with proper bracket matching to avoid false positives\n   */\n  private findJsonWithBracketMatching(\n    text: string,\n    openChar: string,\n    closeChar: string\n  ): string | null {\n    const firstIndex = text.indexOf(openChar);\n    if (firstIndex === -1) return null;\n\n    let depth = 0;\n    let inString = false;\n    let escaping = false;\n\n    for (let i = firstIndex; i < text.length; i++) {\n      const char = text[i];\n\n      if (escaping) {\n        escaping = false;\n        continue;\n      }\n\n      if (char === '\\\\' && inString) {\n        escaping = true;\n        continue;\n      }\n\n      if (char === '\"' && !escaping) {\n        inString = !inString;\n        continue;\n      }\n\n      if (!inString) {\n        if (char === openChar) {\n          depth++;\n        } else if (char === closeChar) {\n          depth--;\n          if (depth === 0) {\n            // Found matching closing bracket\n            const candidate = text.substring(firstIndex, i + 1);\n            try {\n              JSON.parse(candidate); // Validate it's actually valid JSON\n              return candidate;\n            } catch {\n              // This wasn't valid JSON, keep looking\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Generate mock response for testing\n   */\n  private async generateMockResponse(\n    _prompt: string,\n    _checkName?: string,\n    _schema?: string | Record<string, unknown>\n  ): Promise<string> {\n    // Simulate some processing time\n    await new Promise(resolve => setTimeout(resolve, 500));\n\n    // Schema-accurate mocks for default flows\n    const name = (_checkName || '').toLowerCase();\n    if (name.includes('extract-facts')) {\n      const arr = Array.from({ length: 6 }, (_, i) => ({\n        id: `fact-${i + 1}`,\n        category: 'Feature',\n        claim: `claim-${i + 1}`,\n        verifiable: true,\n        refs: [{ path: 'src/check-execution-engine.ts', lines: '6400-6460' }],\n      }));\n      return JSON.stringify(arr);\n    }\n    if (name.includes('validate-fact')) {\n      const idMatch = _prompt.match(/Fact ID:\\s*([\\w\\-]+)/i);\n      const claimMatch = _prompt.match(/\\*\\*Claim:\\*\\*\\s*(.+)/i);\n      const attemptMatch = _prompt.match(/Attempt:\\s*(\\d+)/i);\n      const factId = idMatch ? idMatch[1] : 'fact-1';\n      const claim = claimMatch ? claimMatch[1].trim() : 'unknown-claim';\n      const n = Number(factId.split('-')[1] || '0');\n      const attempt = attemptMatch ? Number(attemptMatch[1]) : 0;\n      const isValid = attempt >= 1 ? true : !(n >= 1 && n <= 3);\n      return JSON.stringify({\n        fact_id: factId,\n        claim,\n        is_valid: isValid,\n        confidence: 'high',\n        evidence: isValid ? 'verified' : 'not found',\n        correction: isValid ? null : `correct ${claim}`,\n      });\n    }\n    if (name.includes('issue-assistant') || name.includes('comment-assistant')) {\n      const text = '### Assistant Reply';\n      const intent = name.includes('issue') ? 'issue_triage' : 'comment_reply';\n      return JSON.stringify({ text, intent });\n    }\n    // Fallback\n    const mockResponse = { content: JSON.stringify({ issues: [], summary: { totalIssues: 0 } }) };\n    return JSON.stringify(mockResponse);\n  }\n\n  /**\n   * Get the API key source for debugging (without revealing the key)\n   */\n  private getApiKeySource(): string {\n    if (process.env.CLAUDE_CODE_API_KEY && this.config.provider === 'claude-code') {\n      return 'CLAUDE_CODE_API_KEY';\n    }\n    if (process.env.GOOGLE_API_KEY && this.config.provider === 'google') {\n      return 'GOOGLE_API_KEY';\n    }\n    if (process.env.ANTHROPIC_API_KEY && this.config.provider === 'anthropic') {\n      return 'ANTHROPIC_API_KEY';\n    }\n    if (process.env.OPENAI_API_KEY && this.config.provider === 'openai') {\n      return 'OPENAI_API_KEY';\n    }\n    if (this.config.provider === 'bedrock') {\n      if (process.env.AWS_BEDROCK_API_KEY) {\n        return 'AWS_BEDROCK_API_KEY';\n      }\n      if (process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY) {\n        return 'AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY';\n      }\n    }\n    return 'unknown';\n  }\n}\n","import { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { EnvConfig, HumanInputRequest } from '../types/config';\n\n/**\n * Configuration for a check provider\n */\nexport interface CheckProviderConfig {\n  type: string;\n  prompt?: string;\n  eventContext?: Record<string, unknown>;\n  focus?: string;\n  command?: string; // For PR comment triggers\n  exec?: string; // For command execution (supports Liquid templates)\n  stdin?: string; // Optional stdin input (supports Liquid templates)\n  args?: string[] | Record<string, unknown>; // string[] deprecated for command args; Record for workflow inputs\n  command_args?: string[]; // MCP stdio command arguments\n  interpreter?: string;\n  url?: string;\n  method?: string;\n  headers?: Record<string, string>;\n  timeout?: number;\n  metadata?: Record<string, unknown>;\n  workingDirectory?: string;\n  env?: EnvConfig;\n  ai?: import('../types/config').AIProviderConfig;\n  /** AI model to use for this check - overrides global setting */\n  ai_model?: string;\n  /** AI provider to use for this check - overrides global setting */\n  ai_provider?: 'google' | 'anthropic' | 'openai' | string;\n  /** Check name for sessionID and logging purposes */\n  checkName?: string;\n  /** Session ID for AI session management */\n  sessionId?: string;\n  /** Script content for 'script' provider */\n  content?: string;\n  [key: string]: unknown;\n}\n\n/**\n * Execution context passed to check providers\n */\nexport interface ExecutionContext {\n  /** Session information for AI session reuse */\n  parentSessionId?: string;\n  reuseSession?: boolean;\n  /** CLI message value (from --message argument) */\n  cliMessage?: string;\n  /**\n   * Stage-local baseline of output history lengths per check name.\n   * When present, providers should expose an `outputs_history_stage` object in\n   * Liquid/JS contexts that slices the global history from this baseline.\n   * This enables stage-scoped assertions in the YAML test runner without\n   * relying on global execution history.\n   */\n  stageHistoryBase?: Record<string, number>;\n  /** Workflow inputs - available when executing within a workflow */\n  workflowInputs?: Record<string, unknown>;\n  /** SDK hooks for human input */\n  hooks?: {\n    onHumanInput?: (request: HumanInputRequest) => Promise<string>;\n    onPromptCaptured?: (info: { step: string; provider: string; prompt: string }) => void;\n    mockForStep?: (step: string) => unknown | undefined;\n  };\n  /**\n   * Optional execution mode hints. The core engine does not read environment\n   * variables directly; callers (CLI, test runner) can set these flags to\n   * request certain behaviors without polluting core logic with test-specific\n   * branches.\n   */\n  mode?: {\n    /** true when running under the YAML test runner */\n    test?: boolean;\n    /** post review comments from grouped execution paths (used by tests) */\n    postGroupedComments?: boolean;\n    /** reset per-run guard state before grouped execution */\n    resetPerRunState?: boolean;\n  };\n}\n\n/**\n * Abstract base class for all check providers\n * Implementing classes provide specific check functionality (AI, tool, script, etc.)\n */\nexport abstract class CheckProvider {\n  /**\n   * Get the unique name/type of this provider\n   */\n  abstract getName(): string;\n\n  /**\n   * Get a human-readable description of this provider\n   */\n  abstract getDescription(): string;\n\n  /**\n   * Validate provider-specific configuration\n   * @param config The configuration to validate\n   * @returns true if configuration is valid, false otherwise\n   */\n  abstract validateConfig(config: unknown): Promise<boolean>;\n\n  /**\n   * Execute the check on the given PR information\n   * @param prInfo Information about the pull request\n   * @param config Provider-specific configuration\n   * @param dependencyResults Optional results from dependency checks that this check depends on\n   * @param context Optional execution context with session info, hooks, and CLI state\n   * @returns Review summary with scores, issues, and comments\n   */\n  abstract execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    context?: ExecutionContext\n  ): Promise<ReviewSummary>;\n\n  /**\n   * Get the list of configuration keys this provider supports\n   * Used for documentation and validation\n   */\n  abstract getSupportedConfigKeys(): string[];\n\n  /**\n   * Check if this provider is available (e.g., has required API keys)\n   * @returns true if provider can be used, false otherwise\n   */\n  abstract isAvailable(): Promise<boolean>;\n\n  /**\n   * Get provider requirements (e.g., environment variables needed)\n   */\n  abstract getRequirements(): string[];\n\n  /**\n   * Set webhook context for providers that need access to webhook data\n   * This is optional and only used by http_input providers\n   * @param webhookContext Map of endpoint paths to webhook data\n   */\n  setWebhookContext?(webhookContext: Map<string, unknown>): void;\n}\n","/**\n * Environment variable resolution utilities\n * Supports GitHub Actions-like syntax for referencing environment variables\n */\n\nimport { EnvConfig } from '../types/config';\n\n/**\n * Resolves environment variables in configuration values\n * Supports the following syntaxes:\n * - ${{ env.VARIABLE_NAME }} (GitHub Actions style)\n * - ${VARIABLE_NAME} (shell style)\n * - $VARIABLE_NAME (simple shell style)\n * - Direct environment variable names\n */\nexport class EnvironmentResolver {\n  /**\n   * Resolves a single configuration value that may contain environment variable references\n   */\n  static resolveValue(value: string | number | boolean): string | number | boolean {\n    if (typeof value !== 'string') {\n      return value;\n    }\n\n    // GitHub Actions style: ${{ env.VARIABLE_NAME }}\n    let resolved = value.replace(/\\$\\{\\{\\s*env\\.([A-Z_][A-Z0-9_]*)\\s*\\}\\}/g, (match, envVar) => {\n      return process.env[envVar] || match;\n    });\n\n    // Shell style: ${VARIABLE_NAME}\n    resolved = resolved.replace(/\\$\\{([A-Z_][A-Z0-9_]*)\\}/g, (match, envVar) => {\n      return process.env[envVar] || match;\n    });\n\n    // Simple shell style: $VARIABLE_NAME\n    resolved = resolved.replace(/\\$([A-Z_][A-Z0-9_]*)/g, (match, envVar) => {\n      return process.env[envVar] || match;\n    });\n\n    return resolved;\n  }\n\n  /**\n   * Resolves all environment variables in an EnvConfig object\n   */\n  static resolveEnvConfig(envConfig: EnvConfig): EnvConfig {\n    const resolved: EnvConfig = {};\n\n    for (const [key, value] of Object.entries(envConfig)) {\n      resolved[key] = this.resolveValue(value);\n    }\n\n    return resolved;\n  }\n\n  /**\n   * Applies environment configuration to the process environment\n   * This allows checks to access their specific environment variables\n   */\n  static applyEnvConfig(envConfig: EnvConfig): void {\n    const resolved = this.resolveEnvConfig(envConfig);\n\n    for (const [key, value] of Object.entries(resolved)) {\n      if (value !== undefined) {\n        process.env[key] = String(value);\n      }\n    }\n  }\n\n  /**\n   * Creates a temporary environment for a specific check execution\n   * Returns a cleanup function to restore the original environment\n   */\n  static withTemporaryEnv<T>(envConfig: EnvConfig, callback: () => T | Promise<T>): T | Promise<T> {\n    const resolved = this.resolveEnvConfig(envConfig);\n    const originalValues: Record<string, string | undefined> = {};\n\n    // Store original values and apply new ones\n    for (const [key, value] of Object.entries(resolved)) {\n      originalValues[key] = process.env[key];\n      if (value !== undefined) {\n        process.env[key] = String(value);\n      }\n    }\n\n    try {\n      const result = callback();\n\n      // If callback returns a promise, handle cleanup after it resolves\n      if (result instanceof Promise) {\n        return result.finally(() => {\n          // Restore original values\n          for (const [key, originalValue] of Object.entries(originalValues)) {\n            if (originalValue === undefined) {\n              delete process.env[key];\n            } else {\n              process.env[key] = originalValue;\n            }\n          }\n        });\n      }\n\n      // Restore original values immediately for sync callbacks\n      for (const [key, originalValue] of Object.entries(originalValues)) {\n        if (originalValue === undefined) {\n          delete process.env[key];\n        } else {\n          process.env[key] = originalValue;\n        }\n      }\n\n      return result;\n    } catch (error) {\n      // Restore original values on error\n      for (const [key, originalValue] of Object.entries(originalValues)) {\n        if (originalValue === undefined) {\n          delete process.env[key];\n        } else {\n          process.env[key] = originalValue;\n        }\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Validates that all required environment variables are available\n   */\n  static validateRequiredEnvVars(envConfig: EnvConfig, requiredVars: string[]): string[] {\n    const resolved = this.resolveEnvConfig(envConfig);\n    const missing: string[] = [];\n\n    for (const varName of requiredVars) {\n      const value = resolved[varName] || process.env[varName];\n      if (!value) {\n        missing.push(varName);\n      }\n    }\n\n    return missing;\n  }\n\n  /**\n   * Resolves environment variables in HTTP headers\n   * Each header value is processed through resolveValue to replace env var references\n   */\n  static resolveHeaders(headers: Record<string, string>): Record<string, string> {\n    const resolved: Record<string, string> = {};\n    for (const [key, value] of Object.entries(headers)) {\n      resolved[key] = String(this.resolveValue(value));\n    }\n    return resolved;\n  }\n\n  /**\n   * Sanitizes headers for logging/telemetry by redacting sensitive values\n   * Headers like Authorization, API keys, and cookies are replaced with [REDACTED]\n   */\n  static sanitizeHeaders(headers: Record<string, string>): Record<string, string> {\n    const sensitiveHeaders = ['authorization', 'x-api-key', 'cookie', 'set-cookie'];\n    const sanitized: Record<string, string> = {};\n\n    for (const [key, value] of Object.entries(headers)) {\n      if (sensitiveHeaders.includes(key.toLowerCase())) {\n        sanitized[key] = '[REDACTED]';\n      } else {\n        sanitized[key] = value;\n      }\n    }\n\n    return sanitized;\n  }\n}\n","import * as fs from 'fs';\nimport * as path from 'path';\nimport { ReviewIssue } from './reviewer';\n\n/**\n * Filter for suppressing Visor issues based on special comments in code\n */\nexport class IssueFilter {\n  private fileCache: Map<string, string[]> = new Map();\n  private suppressionEnabled: boolean;\n\n  constructor(suppressionEnabled: boolean = true) {\n    this.suppressionEnabled = suppressionEnabled;\n  }\n\n  /**\n   * Filter out issues that have suppression comments\n   * @param issues Array of issues to filter\n   * @param workingDir Working directory for resolving file paths\n   * @returns Filtered array of issues with suppressed ones removed\n   */\n  public filterIssues(issues: ReviewIssue[], workingDir: string = process.cwd()): ReviewIssue[] {\n    if (!this.suppressionEnabled || !issues || issues.length === 0) {\n      return issues;\n    }\n\n    const filteredIssues: ReviewIssue[] = [];\n    const suppressedCount: { [file: string]: number } = {};\n\n    for (const issue of issues) {\n      if (this.shouldSuppressIssue(issue, workingDir)) {\n        // Track suppressed issues for logging\n        suppressedCount[issue.file] = (suppressedCount[issue.file] || 0) + 1;\n      } else {\n        filteredIssues.push(issue);\n      }\n    }\n\n    // Log suppression summary if any issues were suppressed\n    const totalSuppressed = Object.values(suppressedCount).reduce((sum, count) => sum + count, 0);\n    if (totalSuppressed > 0) {\n      console.log(`üîá Suppressed ${totalSuppressed} issue(s) via visor-disable comments:`);\n      for (const [file, count] of Object.entries(suppressedCount)) {\n        console.log(`   - ${file}: ${count} issue(s)`);\n      }\n    }\n\n    return filteredIssues;\n  }\n\n  /**\n   * Check if an issue should be suppressed based on comments in the file\n   */\n  private shouldSuppressIssue(issue: ReviewIssue, workingDir: string): boolean {\n    // Skip system-level issues or issues without file/line info\n    if (!issue.file || issue.file === 'system' || issue.file === 'webhook' || issue.line === 0) {\n      return false;\n    }\n\n    const lines = this.getFileLines(issue.file, workingDir);\n    if (!lines || lines.length === 0) {\n      return false;\n    }\n\n    // Check for file-level suppression (visor-disable-file in first 5 lines)\n    const firstFiveLines = lines.slice(0, 5).join('\\n').toLowerCase();\n    if (firstFiveLines.includes('visor-disable-file')) {\n      return true;\n    }\n\n    // Check for line-level suppression (visor-disable within ¬±2 lines)\n    const lineIndex = issue.line - 1; // Convert to 0-based index\n    const startLine = Math.max(0, lineIndex - 2);\n    const endLine = Math.min(lines.length - 1, lineIndex + 2);\n\n    for (let i = startLine; i <= endLine; i++) {\n      if (lines[i].toLowerCase().includes('visor-disable')) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Get file lines from cache or read from disk\n   */\n  private getFileLines(filePath: string, workingDir: string): string[] | null {\n    // Check cache first\n    if (this.fileCache.has(filePath)) {\n      return this.fileCache.get(filePath)!;\n    }\n\n    try {\n      // Resolve the file path\n      const resolvedPath = path.isAbsolute(filePath) ? filePath : path.join(workingDir, filePath);\n\n      if (!fs.existsSync(resolvedPath)) {\n        // Try without working directory if the file doesn't exist\n        if (fs.existsSync(filePath)) {\n          const content = fs.readFileSync(filePath, 'utf8');\n          const lines = content.split('\\n');\n          this.fileCache.set(filePath, lines);\n          return lines;\n        }\n        return null;\n      }\n\n      const content = fs.readFileSync(resolvedPath, 'utf8');\n      const lines = content.split('\\n');\n      this.fileCache.set(filePath, lines);\n      return lines;\n    } catch {\n      // Silently skip files that can't be read\n      return null;\n    }\n  }\n\n  /**\n   * Clear the file cache (useful for testing or long-running processes)\n   */\n  public clearCache(): void {\n    this.fileCache.clear();\n  }\n}\n","/**\n * Enhanced state capture for OTEL spans to enable interactive debugging.\n *\n * This module provides utilities to capture complete execution state in span\n * attributes, enabling time-travel debugging and full state inspection.\n */\n\nimport { Span } from './lazy-otel';\n\nconst MAX_ATTRIBUTE_LENGTH = 10000; // Truncate large values\nconst MAX_ARRAY_ITEMS = 100; // Limit array size in attributes\n\n/**\n * Safely serialize a value for OTEL span attributes.\n * Handles truncation, circular refs, and type conversions.\n */\nfunction safeSerialize(value: unknown, maxLength = MAX_ATTRIBUTE_LENGTH): string {\n  try {\n    if (value === undefined || value === null) return String(value);\n\n    // Detect circular references\n    const seen = new WeakSet();\n    const json = JSON.stringify(value, (key, val) => {\n      if (typeof val === 'object' && val !== null) {\n        if (seen.has(val)) return '[Circular]';\n        seen.add(val);\n      }\n      // Truncate long strings\n      if (typeof val === 'string' && val.length > maxLength) {\n        return val.substring(0, maxLength) + '...[truncated]';\n      }\n      return val;\n    });\n\n    if (json.length > maxLength) {\n      return json.substring(0, maxLength) + '...[truncated]';\n    }\n    return json;\n  } catch (err) {\n    return `[Error serializing: ${err instanceof Error ? err.message : String(err)}]`;\n  }\n}\n\n/**\n * Capture check input context (Liquid template variables) in span.\n */\nexport function captureCheckInputContext(span: Span, context: Record<string, unknown>): void {\n  try {\n    // Capture key context variables\n    const keys = Object.keys(context);\n    span.setAttribute('visor.check.input.keys', keys.join(','));\n    span.setAttribute('visor.check.input.count', keys.length);\n\n    // Capture full context as JSON (with size limit)\n    span.setAttribute('visor.check.input.context', safeSerialize(context));\n\n    // Capture specific important variables separately for easy querying\n    if (context.pr) {\n      span.setAttribute('visor.check.input.pr', safeSerialize(context.pr, 1000));\n    }\n    if (context.outputs) {\n      span.setAttribute('visor.check.input.outputs', safeSerialize(context.outputs, 5000));\n    }\n    if (context.env) {\n      span.setAttribute('visor.check.input.env_keys', Object.keys(context.env as object).join(','));\n    }\n  } catch (err) {\n    try {\n      span.setAttribute('visor.check.input.error', String(err));\n    } catch {\n      // Ignore if we can't even set the error attribute\n    }\n  }\n}\n\n/**\n * Capture check output in span.\n */\nexport function captureCheckOutput(span: Span, output: unknown): void {\n  try {\n    span.setAttribute('visor.check.output.type', typeof output);\n\n    if (Array.isArray(output)) {\n      span.setAttribute('visor.check.output.length', output.length);\n      // Store first few items for preview\n      const preview = output.slice(0, 10);\n      span.setAttribute('visor.check.output.preview', safeSerialize(preview, 2000));\n    }\n\n    // Full output (truncated if needed)\n    span.setAttribute('visor.check.output', safeSerialize(output));\n  } catch (err) {\n    try {\n      span.setAttribute('visor.check.output.error', String(err));\n    } catch {\n      // Ignore if we can't even set the error attribute\n    }\n  }\n}\n\n/**\n * Capture forEach iteration state.\n */\nexport function captureForEachState(\n  span: Span,\n  items: unknown[],\n  index: number,\n  currentItem: unknown\n): void {\n  try {\n    span.setAttribute('visor.foreach.total', items.length);\n    span.setAttribute('visor.foreach.index', index);\n    span.setAttribute('visor.foreach.current_item', safeSerialize(currentItem, 500));\n\n    // Store all items if not too large\n    if (items.length <= MAX_ARRAY_ITEMS) {\n      span.setAttribute('visor.foreach.items', safeSerialize(items));\n    } else {\n      span.setAttribute(\n        'visor.foreach.items.preview',\n        safeSerialize(items.slice(0, MAX_ARRAY_ITEMS))\n      );\n      span.setAttribute('visor.foreach.items.truncated', true);\n    }\n  } catch (err) {\n    span.setAttribute('visor.foreach.error', String(err));\n  }\n}\n\n/**\n * Capture Liquid template evaluation details.\n */\nexport function captureLiquidEvaluation(\n  span: Span,\n  template: string,\n  context: Record<string, unknown>,\n  result: string\n): void {\n  try {\n    span.setAttribute('visor.liquid.template', template.substring(0, 1000));\n    span.setAttribute('visor.liquid.template.length', template.length);\n    span.setAttribute('visor.liquid.result', result.substring(0, 2000));\n    span.setAttribute('visor.liquid.result.length', result.length);\n    span.setAttribute('visor.liquid.context', safeSerialize(context, 3000));\n  } catch (err) {\n    span.setAttribute('visor.liquid.error', String(err));\n  }\n}\n\n/**\n * Capture JavaScript transform execution.\n */\nexport function captureTransformJS(\n  span: Span,\n  code: string,\n  input: unknown,\n  output: unknown\n): void {\n  try {\n    // Truncate long code while keeping plain string (no JSON quoting)\n    const codePreview = code.length > 2000 ? code.substring(0, 2000) + '...[truncated]' : code;\n    span.setAttribute('visor.transform.code', codePreview);\n    span.setAttribute('visor.transform.code.length', code.length);\n    span.setAttribute('visor.transform.input', safeSerialize(input, 2000));\n    span.setAttribute('visor.transform.output', safeSerialize(output, 2000));\n  } catch (err) {\n    span.setAttribute('visor.transform.error', String(err));\n  }\n}\n\n/**\n * Capture provider request/response summary (safe, no raw AI content).\n */\nexport function captureProviderCall(\n  span: Span,\n  providerType: string,\n  request: { prompt?: string; model?: string; [key: string]: unknown },\n  response: { content?: string; tokens?: number; [key: string]: unknown }\n): void {\n  try {\n    span.setAttribute('visor.provider.type', providerType);\n\n    // Request summary\n    if (request.model) span.setAttribute('visor.provider.request.model', String(request.model));\n    if (request.prompt) {\n      span.setAttribute('visor.provider.request.prompt.length', request.prompt.length);\n      span.setAttribute('visor.provider.request.prompt.preview', request.prompt.substring(0, 500));\n    }\n\n    // Response summary\n    if (response.content) {\n      span.setAttribute('visor.provider.response.length', response.content.length);\n      span.setAttribute('visor.provider.response.preview', response.content.substring(0, 500));\n    }\n    if (response.tokens) {\n      span.setAttribute('visor.provider.response.tokens', response.tokens);\n    }\n  } catch (err) {\n    span.setAttribute('visor.provider.error', String(err));\n  }\n}\n\n/**\n * Capture conditional evaluation (if/fail_if).\n */\nexport function captureConditionalEvaluation(\n  span: Span,\n  condition: string,\n  result: boolean,\n  context: Record<string, unknown>\n): void {\n  try {\n    span.setAttribute('visor.condition.expression', condition.substring(0, 500));\n    span.setAttribute('visor.condition.result', result);\n    span.setAttribute('visor.condition.context', safeSerialize(context, 2000));\n  } catch (err) {\n    span.setAttribute('visor.condition.error', String(err));\n  }\n}\n\n/**\n * Capture routing decision (retry/goto/run).\n */\nexport function captureRoutingDecision(\n  span: Span,\n  action: 'retry' | 'goto' | 'run',\n  target: string | string[],\n  condition?: string\n): void {\n  try {\n    span.setAttribute('visor.routing.action', action);\n    span.setAttribute('visor.routing.target', Array.isArray(target) ? target.join(',') : target);\n    if (condition) {\n      span.setAttribute('visor.routing.condition', condition.substring(0, 500));\n    }\n  } catch (err) {\n    span.setAttribute('visor.routing.error', String(err));\n  }\n}\n\n/**\n * Create a snapshot of the entire execution state at a point in time.\n * This is added as a span event for time-travel debugging.\n */\nexport function captureStateSnapshot(\n  span: Span,\n  checkId: string,\n  outputs: Record<string, unknown>,\n  memory: Record<string, unknown>\n): void {\n  try {\n    span.addEvent('state.snapshot', {\n      'visor.snapshot.check_id': checkId,\n      'visor.snapshot.outputs': safeSerialize(outputs, 5000),\n      'visor.snapshot.memory': safeSerialize(memory, 5000),\n      'visor.snapshot.timestamp': new Date().toISOString(),\n    });\n  } catch (err) {\n    span.setAttribute('visor.snapshot.error', String(err));\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { AIReviewService, AIReviewConfig } from '../ai-review-service';\nimport { EnvironmentResolver } from '../utils/env-resolver';\nimport { IssueFilter } from '../issue-filter';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { trace, context as otContext } from '../telemetry/lazy-otel';\nimport {\n  captureCheckInputContext,\n  captureCheckOutput,\n  captureProviderCall,\n} from '../telemetry/state-capture';\n\n/**\n * AI-powered check provider using probe agent\n */\nexport class AICheckProvider extends CheckProvider {\n  private aiReviewService: AIReviewService;\n  private liquidEngine: Liquid;\n\n  constructor() {\n    super();\n    this.aiReviewService = new AIReviewService();\n    this.liquidEngine = createExtendedLiquid();\n  }\n\n  getName(): string {\n    return 'ai';\n  }\n\n  getDescription(): string {\n    return 'AI-powered code review using Google Gemini, Anthropic Claude, OpenAI GPT, or AWS Bedrock models';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'ai'\n    if (cfg.type !== 'ai') {\n      return false;\n    }\n\n    // Check for prompt or focus\n    const prompt = cfg.prompt || cfg.focus;\n    if (typeof prompt !== 'string') {\n      return false;\n    }\n\n    // Focus is now config-driven - any string value is acceptable\n    // No validation needed here as focus is just a hint to the AI\n\n    // Validate AI provider config if present\n    if (cfg.ai) {\n      if (\n        cfg.ai.provider &&\n        !['google', 'anthropic', 'openai', 'bedrock', 'mock'].includes(cfg.ai.provider as string)\n      ) {\n        return false;\n      }\n\n      // Validate mcpServers if present\n      if (cfg.ai.mcpServers) {\n        if (!this.validateMcpServers(cfg.ai.mcpServers)) {\n          return false;\n        }\n      }\n    }\n\n    // Validate check-level MCP servers if present\n    const checkLevelMcpServers = (cfg as CheckProviderConfig & { ai_mcp_servers?: unknown })\n      .ai_mcp_servers;\n    if (checkLevelMcpServers) {\n      if (!this.validateMcpServers(checkLevelMcpServers)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Validate MCP servers configuration\n   */\n  private validateMcpServers(mcpServers: unknown): boolean {\n    if (typeof mcpServers !== 'object' || mcpServers === null) {\n      return false;\n    }\n\n    for (const serverConfig of Object.values(mcpServers)) {\n      if (!serverConfig || typeof serverConfig !== 'object') {\n        return false;\n      }\n      const config = serverConfig as { command?: unknown; args?: unknown };\n      if (typeof config.command !== 'string') {\n        return false;\n      }\n      if (config.args !== undefined && !Array.isArray(config.args)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Group files by their file extension for template context\n   */\n  private groupFilesByExtension(\n    files: import('../pr-analyzer').PRFile[]\n  ): Record<string, import('../pr-analyzer').PRFile[]> {\n    const grouped: Record<string, import('../pr-analyzer').PRFile[]> = {};\n\n    files.forEach(file => {\n      const parts = file.filename.split('.');\n      const ext = parts.length > 1 ? parts.pop()?.toLowerCase() || 'noext' : 'noext';\n      if (!grouped[ext]) {\n        grouped[ext] = [];\n      }\n      grouped[ext].push(file);\n    });\n\n    return grouped;\n  }\n\n  /**\n   * Process prompt configuration to resolve final prompt string\n   */\n  private async processPrompt(\n    promptConfig: string,\n    prInfo: PRInfo,\n    eventContext?: Record<string, unknown>,\n    dependencyResults?: Map<string, ReviewSummary>,\n    outputHistory?: Map<string, unknown[]>\n  ): Promise<string> {\n    let promptContent: string;\n\n    // Auto-detect if it's a file path or inline content\n    if (await this.isFilePath(promptConfig)) {\n      promptContent = await this.loadPromptFromFile(promptConfig);\n    } else {\n      promptContent = promptConfig;\n    }\n\n    // Process Liquid templates in the prompt\n    return await this.renderPromptTemplate(\n      promptContent,\n      prInfo,\n      eventContext,\n      dependencyResults,\n      outputHistory\n    );\n  }\n\n  /**\n   * Detect if a string is likely a file path and if the file exists\n   */\n  private async isFilePath(str: string): Promise<boolean> {\n    // Quick checks to exclude obvious non-file-path content\n    if (!str || str.trim() !== str || str.length > 512) {\n      return false;\n    }\n\n    // Exclude strings that are clearly content (contain common content indicators)\n    // But be more careful with paths that might contain common words as directory names\n    if (\n      /\\s{2,}/.test(str) || // Multiple consecutive spaces\n      /\\n/.test(str) || // Contains newlines\n      /^(please|analyze|review|check|find|identify|look|search)/i.test(str.trim()) || // Starts with command words\n      str.split(' ').length > 8 // Too many words for a typical file path\n    ) {\n      return false;\n    }\n\n    // For strings with path separators, be more lenient about common words\n    // as they might be legitimate directory names\n    if (!/[\\/\\\\]/.test(str)) {\n      // Only apply strict English word filter to non-path strings\n      if (/\\b(the|and|or|but|for|with|by|from|in|on|at|as)\\b/i.test(str)) {\n        return false;\n      }\n    }\n\n    // Positive indicators for file paths\n    const hasFileExtension = /\\.[a-zA-Z0-9]{1,10}$/i.test(str);\n    const hasPathSeparators = /[\\/\\\\]/.test(str);\n    const isRelativePath = /^\\.{1,2}\\//.test(str);\n    const isAbsolutePath = path.isAbsolute(str);\n    const hasTypicalFileChars = /^[a-zA-Z0-9._\\-\\/\\\\:~]+$/.test(str);\n\n    // Must have at least one strong indicator\n    if (!(hasFileExtension || isRelativePath || isAbsolutePath || hasPathSeparators)) {\n      return false;\n    }\n\n    // Must contain only typical file path characters\n    if (!hasTypicalFileChars) {\n      return false;\n    }\n\n    // Additional validation for suspected file paths\n    try {\n      // Try to resolve and check if file exists\n      let resolvedPath: string;\n\n      if (path.isAbsolute(str)) {\n        resolvedPath = path.normalize(str);\n      } else {\n        // Resolve relative to current working directory\n        resolvedPath = path.resolve(process.cwd(), str);\n      }\n\n      // Check if file exists\n      const fs = require('fs').promises;\n      try {\n        const stat = await fs.stat(resolvedPath);\n        return stat.isFile();\n      } catch {\n        // File doesn't exist, but might still be a valid file path format\n        // Return true if it has strong file path indicators\n        return hasFileExtension && (isRelativePath || isAbsolutePath || hasPathSeparators);\n      }\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Load prompt content from file with security validation\n   */\n  private async loadPromptFromFile(promptPath: string): Promise<string> {\n    // Enforce .liquid file extension for all prompt files\n    if (!promptPath.endsWith('.liquid')) {\n      throw new Error('Prompt file must have .liquid extension');\n    }\n\n    let resolvedPath: string;\n\n    if (path.isAbsolute(promptPath)) {\n      // Absolute path - use as-is\n      resolvedPath = promptPath;\n    } else {\n      // Relative path - resolve relative to current working directory\n      resolvedPath = path.resolve(process.cwd(), promptPath);\n    }\n\n    // Security: For relative paths, ensure they don't escape the current directory\n    if (!path.isAbsolute(promptPath)) {\n      const normalizedPath = path.normalize(resolvedPath);\n      const currentDir = path.resolve(process.cwd());\n      if (!normalizedPath.startsWith(currentDir)) {\n        throw new Error('Invalid prompt file path: path traversal detected');\n      }\n    }\n\n    // Security: Check for obvious path traversal patterns\n    if (promptPath.includes('../..')) {\n      throw new Error('Invalid prompt file path: path traversal detected');\n    }\n\n    try {\n      const promptContent = await fs.readFile(resolvedPath, 'utf-8');\n      return promptContent;\n    } catch (error) {\n      throw new Error(\n        `Failed to load prompt from ${resolvedPath}: ${\n          error instanceof Error ? error.message : 'Unknown error'\n        }`\n      );\n    }\n  }\n\n  /**\n   * Render Liquid template in prompt with comprehensive event context\n   */\n  private async renderPromptTemplate(\n    promptContent: string,\n    prInfo: PRInfo,\n    eventContext?: Record<string, unknown>,\n    dependencyResults?: Map<string, ReviewSummary>,\n    outputHistory?: Map<string, unknown[]>\n  ): Promise<string> {\n    // Build outputs_raw from -raw keys (aggregate parent values)\n    const outputsRaw: Record<string, unknown> = {};\n    if (dependencyResults) {\n      for (const [k, v] of dependencyResults.entries()) {\n        if (typeof k !== 'string') continue;\n        if (k.endsWith('-raw')) {\n          const name = k.slice(0, -4);\n          const summary = v as ReviewSummary & { output?: unknown };\n          outputsRaw[name] = summary.output !== undefined ? summary.output : summary;\n        }\n      }\n    }\n\n    // Note: We intentionally do NOT expose any special `fact_validation` object\n    // in the template context. Templates should derive everything from\n    // outputs / outputs_history / memory helpers to avoid hidden magic.\n\n    // Create comprehensive template context with PR and event information\n    const templateContext = {\n      // PR Information\n      pr: {\n        number: prInfo.number,\n        title: prInfo.title,\n        body: prInfo.body,\n        author: prInfo.author,\n        baseBranch: prInfo.base,\n        headBranch: prInfo.head,\n        isIncremental: prInfo.isIncremental,\n        filesChanged: prInfo.files?.map(f => f.filename) || [],\n        totalAdditions: prInfo.files?.reduce((sum, f) => sum + f.additions, 0) || 0,\n        totalDeletions: prInfo.files?.reduce((sum, f) => sum + f.deletions, 0) || 0,\n        totalChanges: prInfo.files?.reduce((sum, f) => sum + f.changes, 0) || 0,\n        base: prInfo.base,\n        head: prInfo.head,\n      },\n\n      // File Details\n      files: prInfo.files || [],\n      description: prInfo.body || '',\n\n      // GitHub Event Context\n      event: eventContext\n        ? {\n            name: eventContext.event_name || 'unknown',\n            action: eventContext.action,\n            isPullRequest: !prInfo.isIssue, // Set based on whether this is a PR or an issue\n\n            // Repository Info\n            repository: eventContext.repository\n              ? {\n                  owner: (eventContext.repository as { owner?: { login?: string } })?.owner?.login,\n                  name: (eventContext.repository as { name?: string })?.name,\n                  fullName: eventContext.repository\n                    ? `${(eventContext.repository as { owner?: { login?: string } })?.owner?.login}/${(eventContext.repository as { name?: string })?.name}`\n                    : undefined,\n                }\n              : undefined,\n\n            // Comment Data (for comment events)\n            comment: eventContext.comment\n              ? {\n                  body: (eventContext.comment as { body?: string })?.body,\n                  author: (eventContext.comment as { user?: { login?: string } })?.user?.login,\n                }\n              : undefined,\n\n            // Issue Data (for issue events)\n            issue: eventContext.issue\n              ? {\n                  number: (eventContext.issue as { number?: number })?.number,\n                  title: (eventContext.issue as { title?: string })?.title,\n                  body: (eventContext.issue as { body?: string })?.body,\n                  state: (eventContext.issue as { state?: string })?.state,\n                  author: (eventContext.issue as { user?: { login?: string } })?.user?.login,\n                  labels: (eventContext.issue as { labels?: unknown[] })?.labels || [],\n                  assignees:\n                    (\n                      eventContext as { issue?: { assignees?: Array<{ login: string }> } }\n                    )?.issue?.assignees?.map(a => a.login) || [],\n                  createdAt: (eventContext.issue as { created_at?: string })?.created_at,\n                  updatedAt: (eventContext.issue as { updated_at?: string })?.updated_at,\n                  isPullRequest: !!(eventContext.issue as { pull_request?: unknown })?.pull_request,\n                }\n              : undefined,\n\n            // Pull Request Event Data\n            pullRequest: eventContext.pull_request\n              ? {\n                  number: (eventContext.pull_request as { number?: number })?.number,\n                  state: (eventContext.pull_request as { state?: string })?.state,\n                  draft: (eventContext.pull_request as { draft?: boolean })?.draft,\n                  headSha: (eventContext.pull_request as { head?: { sha?: string } })?.head?.sha,\n                  headRef: (eventContext.pull_request as { head?: { ref?: string } })?.head?.ref,\n                  baseSha: (eventContext.pull_request as { base?: { sha?: string } })?.base?.sha,\n                  baseRef: (eventContext.pull_request as { base?: { ref?: string } })?.base?.ref,\n                }\n              : undefined,\n\n            // Raw event payload for advanced use cases\n            payload: eventContext,\n          }\n        : undefined,\n\n      // Utility data for templates\n      utils: {\n        // Date/time helpers\n        now: new Date().toISOString(),\n        today: new Date().toISOString().split('T')[0],\n\n        // Dynamic file grouping by extension\n        filesByExtension: this.groupFilesByExtension(prInfo.files || []),\n\n        // File status categorizations\n        addedFiles: (prInfo.files || []).filter(f => f.status === 'added'),\n        modifiedFiles: (prInfo.files || []).filter(f => f.status === 'modified'),\n        removedFiles: (prInfo.files || []).filter(f => f.status === 'removed'),\n        renamedFiles: (prInfo.files || []).filter(f => f.status === 'renamed'),\n\n        // Change analysis\n        hasLargeChanges: (prInfo.files || []).some(f => f.changes > 50),\n        totalFiles: (prInfo.files || []).length,\n      },\n\n      // Previous check outputs (dependency results)\n      // Expose raw output directly if available, otherwise expose the result as-is\n      outputs: dependencyResults\n        ? Object.fromEntries(\n            Array.from(dependencyResults.entries()).map(([checkName, result]) => [\n              checkName,\n              (() => {\n                const summary = result as ReviewSummary & { output?: unknown };\n                return summary.output !== undefined ? summary.output : summary;\n              })(),\n            ])\n          )\n        : {},\n      // Alias for consistency with other providers\n      outputs_history: (() => {\n        const hist: Record<string, unknown[]> = {};\n        if (outputHistory) {\n          for (const [k, v] of outputHistory.entries()) hist[k] = v;\n        }\n        return hist;\n      })(),\n      // Stage-scoped history slice calculated from baseline captured by the flow runner.\n      outputs_history_stage: (() => {\n        const stage: Record<string, unknown[]> = {};\n        try {\n          const base = (eventContext as any)?.__stageHistoryBase as\n            | Record<string, number>\n            | undefined;\n          if (!outputHistory || !base) return stage;\n          for (const [k, v] of outputHistory.entries()) {\n            const start = base[k] || 0;\n            const arr = Array.isArray(v) ? (v as unknown[]) : [];\n            stage[k] = arr.slice(start);\n          }\n        } catch {}\n        return stage;\n      })(),\n      // New: outputs_raw exposes aggregate values (e.g., full arrays for forEach parents)\n      outputs_raw: outputsRaw,\n    };\n\n    try {\n      if (process.env.VISOR_DEBUG === 'true') {\n        console.error(\n          `[prompt-ctx] outputs.keys=${Object.keys((templateContext as any).outputs || {}).join(', ')} hist.validate-fact.len=${(() => {\n            try {\n              const h = (templateContext as any).outputs_history || {};\n              const v = h['validate-fact'];\n              return Array.isArray(v) ? v.length : 0;\n            } catch {\n              return 0;\n            }\n          })()}`\n        );\n      }\n    } catch {}\n\n    try {\n      return await this.liquidEngine.parseAndRender(promptContent, templateContext);\n    } catch (error) {\n      // Always show a helpful snippet with a caret, similar to YAML errors\n      const err: any = error || {};\n      const lines = String(promptContent || '').split(/\\r?\\n/);\n      const lineNum: number = Number(err.line || err?.token?.line || err?.location?.line || 0);\n      const colNum: number = Number(err.col || err?.token?.col || err?.location?.col || 0);\n      let snippet = '';\n      if (lineNum > 0) {\n        const start = Math.max(1, lineNum - 3);\n        const end = Math.max(lineNum + 2, lineNum);\n        const width = String(end).length;\n        for (let i = start; i <= Math.min(end, lines.length); i++) {\n          const ln = `${String(i).padStart(width, ' ')} | ${lines[i - 1] ?? ''}`;\n          snippet += ln + '\\n';\n          if (i === lineNum) {\n            const caretPad = ' '.repeat(Math.max(0, colNum > 1 ? colNum - 1 : 0) + width + 3);\n            snippet += caretPad + '^\\n';\n          }\n        }\n      } else {\n        // Fallback preview of the first 20 lines\n        const preview = lines\n          .slice(0, 20)\n          .map((l, i) => `${(i + 1).toString().padStart(3, ' ')} | ${l}`)\n          .join('\\n');\n        snippet = preview + '\\n';\n      }\n      const msg = `Failed to render prompt template: ${\n        error instanceof Error ? error.message : 'Unknown error'\n      }`;\n      // Print a clear, user-friendly error with context\n      try {\n        console.error('\\n[prompt-error] ' + msg + '\\n' + snippet);\n      } catch {}\n      throw new Error(msg);\n    }\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    _dependencyResults?: Map<string, ReviewSummary>,\n    sessionInfo?: { parentSessionId?: string; reuseSession?: boolean }\n  ): Promise<ReviewSummary> {\n    // Apply environment configuration if present\n    if (config.env) {\n      const result = EnvironmentResolver.withTemporaryEnv(config.env, () => {\n        // This will be executed with the temporary environment\n        return this.executeWithConfig(prInfo, config, _dependencyResults, sessionInfo);\n      });\n\n      if (result instanceof Promise) {\n        return result;\n      }\n      return result;\n    }\n\n    return this.executeWithConfig(prInfo, config, _dependencyResults, sessionInfo);\n  }\n\n  private async executeWithConfig(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    _dependencyResults?: Map<string, ReviewSummary>,\n    sessionInfo?: {\n      parentSessionId?: string;\n      reuseSession?: boolean;\n    } & import('./check-provider.interface').ExecutionContext\n  ): Promise<ReviewSummary> {\n    try {\n      if (process.env.VISOR_DEBUG === 'true') {\n        console.error(`[ai-exec] step=${String((config as any).checkName || 'unknown')}`);\n      }\n    } catch {}\n    // Extract AI configuration - only set properties that are explicitly provided\n    const aiConfig: AIReviewConfig = {};\n\n    // Check-level AI configuration (ai object)\n    if (config.ai) {\n      // Only set properties that are actually defined to avoid overriding env vars\n      if (config.ai.apiKey !== undefined) {\n        aiConfig.apiKey = config.ai.apiKey as string;\n      }\n      if (config.ai.model !== undefined) {\n        aiConfig.model = config.ai.model as string;\n      }\n      if (config.ai.timeout !== undefined) {\n        aiConfig.timeout = config.ai.timeout as number;\n      }\n      if (config.ai.provider !== undefined) {\n        aiConfig.provider = config.ai.provider as\n          | 'google'\n          | 'anthropic'\n          | 'openai'\n          | 'bedrock'\n          | 'mock';\n      }\n      if (config.ai.debug !== undefined) {\n        aiConfig.debug = config.ai.debug as boolean;\n      }\n      if (config.ai.enableDelegate !== undefined) {\n        aiConfig.enableDelegate = config.ai.enableDelegate as boolean;\n      }\n      if (config.ai.allowEdit !== undefined) {\n        aiConfig.allowEdit = config.ai.allowEdit as boolean;\n      }\n      if (config.ai.allowedTools !== undefined) {\n        aiConfig.allowedTools = config.ai.allowedTools as string[];\n      }\n      if (config.ai.disableTools !== undefined) {\n        aiConfig.disableTools = config.ai.disableTools as boolean;\n      }\n      if (config.ai.allowBash !== undefined) {\n        aiConfig.allowBash = config.ai.allowBash as boolean;\n      }\n      if (config.ai.bashConfig !== undefined) {\n        aiConfig.bashConfig = config.ai.bashConfig as import('../types/config').BashConfig;\n      }\n      if (config.ai.skip_code_context !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (aiConfig as any).skip_code_context = config.ai.skip_code_context as boolean;\n      }\n      if (config.ai.retry !== undefined) {\n        aiConfig.retry = config.ai.retry as import('../types/config').AIRetryConfig;\n      }\n      if (config.ai.fallback !== undefined) {\n        aiConfig.fallback = config.ai.fallback as import('../types/config').AIFallbackConfig;\n      }\n    }\n\n    // Check-level AI model and provider (top-level properties)\n    if (config.ai_model !== undefined) {\n      aiConfig.model = config.ai_model as string;\n    }\n    if (config.ai_provider !== undefined) {\n      aiConfig.provider = config.ai_provider as\n        | 'google'\n        | 'anthropic'\n        | 'openai'\n        | 'bedrock'\n        | 'mock';\n    }\n\n    // Get custom prompt from config - REQUIRED, no fallbacks\n    const customPrompt = config.prompt;\n\n    if (!customPrompt) {\n      throw new Error(\n        `No prompt defined for check. All checks must have prompts defined in .visor.yaml configuration.`\n      );\n    }\n\n    // Setup MCP tools from multiple configuration levels\n    const mcpServers: Record<string, import('../types/config').McpServerConfig> = {};\n\n    // 1. Start with global MCP servers (from visor config root)\n    const globalConfig = config as CheckProviderConfig & {\n      ai_mcp_servers?: Record<string, import('../types/config').McpServerConfig>;\n    };\n    if (globalConfig.ai_mcp_servers) {\n      Object.assign(mcpServers, globalConfig.ai_mcp_servers);\n    }\n\n    // 2. Add check-level MCP servers (overrides global)\n    if (config.ai_mcp_servers) {\n      Object.assign(mcpServers, config.ai_mcp_servers);\n    }\n\n    // 3. Add ai.mcpServers (overrides everything)\n    if (config.ai?.mcpServers) {\n      Object.assign(mcpServers, config.ai.mcpServers);\n    }\n\n    // Pass MCP server config directly to AI service (unless tools are disabled)\n    if (Object.keys(mcpServers).length > 0 && !config.ai?.disableTools) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (aiConfig as any).mcpServers = mcpServers;\n      // no noisy diagnostics here\n    } else if (config.ai?.disableTools) {\n      // silently skip MCP when tools disabled\n    }\n\n    // Build template context for state capture\n    const templateContext = {\n      pr: {\n        number: prInfo.number,\n        title: prInfo.title,\n        author: prInfo.author,\n        branch: prInfo.head,\n        base: prInfo.base,\n      },\n      files: prInfo.files,\n      outputs: _dependencyResults\n        ? Object.fromEntries(\n            Array.from(_dependencyResults.entries()).map(([checkName, result]) => [\n              checkName,\n              (result as any).output !== undefined ? (result as any).output : result,\n            ])\n          )\n        : {},\n    };\n\n    // Capture input context in active OTEL span\n    try {\n      const span = trace.getSpan(otContext.active());\n      if (span) {\n        captureCheckInputContext(span, templateContext);\n      }\n    } catch {\n      // Ignore telemetry errors\n    }\n    // Fallback NDJSON for input context (non-OTEL environments)\n    try {\n      const checkId = (config as any).checkName || (config as any).id || 'unknown';\n      const ctxJson = JSON.stringify(templateContext);\n      const { emitNdjsonSpanWithEvents } = require('../telemetry/fallback-ndjson');\n      emitNdjsonSpanWithEvents(\n        'visor.check',\n        { 'visor.check.id': checkId, 'visor.check.input.context': ctxJson },\n        []\n      );\n    } catch {}\n\n    // Process prompt with Liquid templates and file loading\n    // Do NOT strip event context on skip_code_context ‚Äî that flag only controls\n    // whether we embed PR diffs/large code context later in AIReviewService.\n    // Keep repository/comment metadata available for prompts and tests.\n    const eventContext = config.eventContext || {};\n    // Thread stageHistoryBase via eventContext for prompt rendering so\n    // Liquid templates can get outputs_history_stage (computed from baseline).\n    const ctxWithStage = {\n      ...(eventContext || {}),\n      __stageHistoryBase: (sessionInfo as any)?.stageHistoryBase as\n        | Record<string, number>\n        | undefined,\n    } as Record<string, unknown>;\n\n    const processedPrompt = await this.processPrompt(\n      customPrompt,\n      prInfo,\n      ctxWithStage,\n      _dependencyResults,\n      (config as any).__outputHistory as Map<string, unknown[]> | undefined\n    );\n\n    // Optional persona (vendor extension): ai.ai_persona or ai_persona.\n    // This is a light-weight preamble, not a rewriting of the user's prompt.\n    const aiAny = (config.ai || {}) as any;\n    // Persona (underscore only)\n    const persona = (aiAny?.ai_persona || (config as any).ai_persona || '').toString().trim();\n    const finalPrompt = persona ? `Persona: ${persona}\\n\\n${processedPrompt}` : processedPrompt;\n    // Expose promptType to AIReviewService via env (bridge until ProbeAgent supports it in our SDK surface)\n    try {\n      const pt = ((config.ai as any)?.promptType || (config as any).ai_prompt_type || '')\n        .toString()\n        .trim();\n      if (pt) process.env.VISOR_PROMPT_TYPE = pt;\n    } catch {}\n\n    // Test hook: capture the FINAL prompt (with PR context) before provider invocation\n    try {\n      const stepName = (config as any).checkName || 'unknown';\n      const serviceForCapture = new AIReviewService(aiConfig);\n      const finalPromptCapture = await (serviceForCapture as any).buildCustomPrompt(\n        prInfo,\n        finalPrompt,\n        config.schema,\n        {\n          checkName: (config as any).checkName,\n          skipPRContext: (config.ai as any)?.skip_code_context === true,\n        }\n      );\n      sessionInfo?.hooks?.onPromptCaptured?.({\n        step: String(stepName),\n        provider: 'ai',\n        prompt: finalPromptCapture,\n      });\n      // capture hook retained; no extra console diagnostics\n    } catch {}\n\n    // Test hook: mock output for this step (short-circuit provider)\n    try {\n      const stepName = (config as any).checkName || 'unknown';\n      const mock = sessionInfo?.hooks?.mockForStep?.(String(stepName));\n      if (mock !== undefined) {\n        return { issues: [], output: mock } as ReviewSummary & { output: unknown };\n      }\n    } catch {}\n\n    // Create AI service with config - environment variables will be used if aiConfig is empty\n    try {\n      const pt = (aiAny?.prompt_type || (config as any).ai_prompt_type || '').toString().trim();\n      if (pt) (aiConfig as any).promptType = pt;\n      // Prefer new system_prompt; fall back to legacy custom_prompt for backward compatibility\n      const sys = (aiAny?.system_prompt || (config as any).ai_system_prompt || '')\n        .toString()\n        .trim();\n      const legacy = (aiAny?.custom_prompt || (config as any).ai_custom_prompt || '')\n        .toString()\n        .trim();\n      if (sys) (aiConfig as any).systemPrompt = sys;\n      else if (legacy) (aiConfig as any).systemPrompt = legacy;\n    } catch {}\n    const service = new AIReviewService(aiConfig);\n\n    // Pass the custom prompt and schema - no fallbacks\n    const schema = config.schema as string | Record<string, unknown> | undefined;\n\n    // Removed verbose AICheckProvider console diagnostics; rely on logger.debug when needed\n\n    try {\n      // No extra console diagnostics here\n\n      let result: ReviewSummary;\n\n      // Check if we should use session reuse (only if explicitly enabled on this check)\n      // No extra reuse_ai_session console diagnostics\n      const reuseEnabled =\n        (config as any).reuse_ai_session === true ||\n        typeof (config as any).reuse_ai_session === 'string';\n      if (sessionInfo?.reuseSession && sessionInfo.parentSessionId && reuseEnabled) {\n        // Safety: only reuse if the parent session actually exists\n        try {\n          const { SessionRegistry } = require('../session-registry');\n          const reg = SessionRegistry.getInstance();\n          if (!reg.hasSession(sessionInfo.parentSessionId)) {\n            if (aiConfig.debug || process.env.VISOR_DEBUG === 'true') {\n              console.warn(\n                `‚ö†Ô∏è  Parent session ${sessionInfo.parentSessionId} not found; creating a new session for ${config.checkName}`\n              );\n            }\n            // Fall back to new session\n            const fresh = await service.executeReview(\n              prInfo,\n              processedPrompt,\n              schema,\n              config.checkName,\n              config.sessionId\n            );\n            return {\n              ...fresh,\n              issues: new IssueFilter(config.suppressionEnabled !== false).filterIssues(\n                fresh.issues || [],\n                process.cwd()\n              ),\n            };\n          }\n        } catch {}\n        // Get session_mode from config, default to 'clone'\n        const sessionMode = (config.session_mode as 'clone' | 'append') || 'clone';\n\n        if (aiConfig.debug) {\n          console.error(\n            `üîÑ Debug: Using session reuse with parent session: ${sessionInfo.parentSessionId} (mode: ${sessionMode})`\n          );\n        }\n        result = await service.executeReviewWithSessionReuse(\n          prInfo,\n          processedPrompt,\n          sessionInfo.parentSessionId,\n          schema,\n          config.checkName,\n          sessionMode\n        );\n      } else {\n        if (aiConfig.debug) {\n          console.error(`üÜï Debug: Creating new AI session for check: ${config.checkName}`);\n        }\n        result = await service.executeReview(\n          prInfo,\n          finalPrompt,\n          schema,\n          config.checkName,\n          config.sessionId\n        );\n      }\n\n      // Apply issue suppression filtering\n      const suppressionEnabled = config.suppressionEnabled !== false;\n      const issueFilter = new IssueFilter(suppressionEnabled);\n      const filteredIssues = issueFilter.filterIssues(result.issues || [], process.cwd());\n\n      const finalResult = {\n        ...result,\n        issues: filteredIssues,\n      };\n\n      // Capture AI provider call and output in active OTEL span\n      try {\n        const span = trace.getSpan(otContext.active());\n        if (span) {\n          captureProviderCall(\n            span,\n            'ai',\n            {\n              prompt: processedPrompt.substring(0, 500), // Preview only\n              model: aiConfig.model,\n            },\n            {\n              content: JSON.stringify(finalResult).substring(0, 500),\n              tokens: (result as any).usage?.totalTokens,\n            }\n          );\n          const outputForSpan = (finalResult as { output?: unknown }).output ?? finalResult;\n          captureCheckOutput(span, outputForSpan);\n        }\n      } catch {\n        // Ignore telemetry errors\n      }\n      // Fallback NDJSON for output (non-OTEL environments)\n      try {\n        const checkId = (config as any).checkName || (config as any).id || 'unknown';\n        const outJson = JSON.stringify((finalResult as any).output ?? finalResult);\n        const { emitNdjsonSpanWithEvents } = require('../telemetry/fallback-ndjson');\n        emitNdjsonSpanWithEvents(\n          'visor.check',\n          { 'visor.check.id': checkId, 'visor.check.output': outJson },\n          []\n        );\n      } catch {}\n\n      return finalResult;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n\n      // Log detailed error information\n      console.error(`‚ùå AI Check Provider Error for check: ${errorMessage}`);\n\n      // Check if this is a critical error (authentication, rate limits, etc)\n      const isCriticalError =\n        errorMessage.includes('API rate limit') ||\n        errorMessage.includes('403') ||\n        errorMessage.includes('401') ||\n        errorMessage.includes('authentication') ||\n        errorMessage.includes('API key');\n\n      if (isCriticalError) {\n        console.error(`üö® CRITICAL ERROR: AI provider authentication or rate limit issue detected`);\n        console.error(`üö® This check cannot proceed without valid API credentials`);\n      }\n\n      // Re-throw with more context\n      throw new Error(`AI analysis failed: ${errorMessage}`);\n    }\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'prompt',\n      'focus',\n      'schema',\n      'group',\n      'ai.provider',\n      'ai.model',\n      'ai.apiKey',\n      'ai.timeout',\n      'ai.mcpServers',\n      'ai.enableDelegate',\n      // legacy persona/prompt keys supported in config\n      'ai_persona',\n      'ai_prompt_type',\n      'ai_custom_prompt',\n      'ai_system_prompt',\n      // new provider resilience and tools toggles\n      'ai.retry',\n      'ai.fallback',\n      'ai.allowEdit',\n      'ai.allowedTools',\n      'ai.disableTools',\n      'ai.allowBash',\n      'ai.bashConfig',\n      'ai_model',\n      'ai_provider',\n      'ai_mcp_servers',\n      'env',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // Check if any AI API key is available\n    return !!(\n      process.env.GOOGLE_API_KEY ||\n      process.env.ANTHROPIC_API_KEY ||\n      process.env.OPENAI_API_KEY ||\n      // AWS Bedrock credentials check\n      (process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY) ||\n      process.env.AWS_BEDROCK_API_KEY\n    );\n  }\n\n  getRequirements(): string[] {\n    return [\n      'At least one of: GOOGLE_API_KEY, ANTHROPIC_API_KEY, OPENAI_API_KEY, or AWS credentials (AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY)',\n      'Optional: MODEL_NAME environment variable',\n      'Optional: AWS_REGION for Bedrock provider',\n      'Network access to AI provider APIs',\n    ];\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary, ReviewIssue } from '../reviewer';\nimport { IssueFilter } from '../issue-filter';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { trace, context as otContext } from '../telemetry/lazy-otel';\nimport {\n  captureCheckInputContext,\n  captureCheckOutput,\n  captureProviderCall,\n} from '../telemetry/state-capture';\nimport { EnvironmentResolver } from '../utils/env-resolver';\n\n/**\n * Check provider that sends data to an HTTP endpoint, typically used as an output/notification provider\n */\nexport class HttpCheckProvider extends CheckProvider {\n  private liquid: Liquid;\n\n  constructor() {\n    super();\n    this.liquid = createExtendedLiquid();\n  }\n  getName(): string {\n    return 'http';\n  }\n\n  getDescription(): string {\n    return 'Send data to external HTTP endpoint for notifications or integration';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'http'\n    if (cfg.type !== 'http') {\n      return false;\n    }\n\n    // Must have URL specified\n    if (typeof cfg.url !== 'string' || !cfg.url) {\n      return false;\n    }\n\n    // Must have body template specified\n    if (typeof cfg.body !== 'string' || !cfg.body) {\n      return false;\n    }\n\n    // Validate URL format\n    try {\n      new URL(cfg.url as string);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    _sessionInfo?: { parentSessionId?: string; reuseSession?: boolean }\n  ): Promise<ReviewSummary> {\n    const url = config.url as string;\n    const bodyTemplate = config.body as string;\n    const method = (config.method as string) || 'POST';\n    const headers = (config.headers as Record<string, string>) || {};\n    const timeout = (config.timeout as number) || 30000;\n\n    // Prepare template context with all available data\n    const templateContext = {\n      pr: {\n        number: prInfo.number,\n        title: prInfo.title,\n        body: prInfo.body,\n        author: prInfo.author,\n        base: prInfo.base,\n        head: prInfo.head,\n        totalAdditions: prInfo.totalAdditions,\n        totalDeletions: prInfo.totalDeletions,\n      },\n      files: prInfo.files.map(f => ({\n        filename: f.filename,\n        status: f.status,\n        additions: f.additions,\n        deletions: f.deletions,\n        changes: f.changes,\n        patch: f.patch,\n      })),\n      outputs: dependencyResults ? Object.fromEntries(dependencyResults) : {},\n      metadata: config.metadata || {},\n    };\n\n    // Capture input context in active OTEL span\n    try {\n      const span = trace.getSpan(otContext.active());\n      if (span) {\n        captureCheckInputContext(span, templateContext);\n      }\n    } catch {\n      // Ignore telemetry errors\n    }\n\n    // Render the body template\n    let payload: Record<string, unknown>;\n    try {\n      const renderedBody = await this.liquid.parseAndRender(bodyTemplate, templateContext);\n      // Try to parse as JSON, otherwise send as plain text\n      try {\n        payload = JSON.parse(renderedBody);\n      } catch {\n        payload = { message: renderedBody };\n      }\n    } catch (error) {\n      return this.createErrorResult(\n        url,\n        new Error(\n          `Template rendering failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n        )\n      );\n    }\n\n    try {\n      // Resolve environment variables in headers\n      const resolvedHeaders = EnvironmentResolver.resolveHeaders(headers);\n\n      // Send webhook request\n      const response = await this.sendWebhookRequest(\n        url,\n        method,\n        resolvedHeaders,\n        payload,\n        timeout\n      );\n\n      // Parse webhook response\n      const result = this.parseWebhookResponse(response, url);\n\n      // Apply issue suppression filtering\n      const suppressionEnabled = config.suppressionEnabled !== false;\n      const issueFilter = new IssueFilter(suppressionEnabled);\n      const filteredIssues = issueFilter.filterIssues(result.issues || [], process.cwd());\n\n      const finalResult = {\n        ...result,\n        issues: filteredIssues,\n      };\n\n      // Capture HTTP provider call and output in active OTEL span\n      try {\n        const span = trace.getSpan(otContext.active());\n        if (span) {\n          // Sanitize headers for telemetry to avoid exposing sensitive data\n          const sanitizedHeaders = EnvironmentResolver.sanitizeHeaders(resolvedHeaders);\n          captureProviderCall(\n            span,\n            'http',\n            {\n              url,\n              method,\n              headers: sanitizedHeaders,\n              body: JSON.stringify(payload).substring(0, 500),\n            },\n            {\n              content: JSON.stringify(response).substring(0, 500),\n            }\n          );\n          const outputForSpan = (finalResult as { output?: unknown }).output ?? finalResult;\n          captureCheckOutput(span, outputForSpan);\n        }\n      } catch {\n        // Ignore telemetry errors\n      }\n\n      return finalResult;\n    } catch (error) {\n      return this.createErrorResult(url, error);\n    }\n  }\n\n  private async sendWebhookRequest(\n    url: string,\n    method: string,\n    headers: Record<string, string>,\n    payload: Record<string, unknown>,\n    timeout: number\n  ): Promise<Record<string, unknown>> {\n    // Check if fetch is available (Node 18+)\n    if (typeof fetch === 'undefined') {\n      throw new Error('Webhook provider requires Node.js 18+ or node-fetch package');\n    }\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n    try {\n      const response = await fetch(url, {\n        method,\n        headers: {\n          'Content-Type': 'application/json',\n          ...headers,\n        },\n        body: JSON.stringify(payload),\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        throw new Error(`Webhook returned ${response.status}: ${response.statusText}`);\n      }\n\n      return (await response.json()) as Record<string, unknown>;\n    } catch (error: unknown) {\n      clearTimeout(timeoutId);\n\n      if (error instanceof Error && error.name === 'AbortError') {\n        throw new Error(`Webhook request timed out after ${timeout}ms`);\n      }\n\n      throw error;\n    }\n  }\n\n  private parseWebhookResponse(response: Record<string, unknown>, url: string): ReviewSummary {\n    // Validate and normalize the webhook response\n    if (!response || typeof response !== 'object') {\n      return this.createErrorResult(url, new Error('Invalid webhook response format'));\n    }\n\n    const issues: ReviewIssue[] = Array.isArray(response.comments)\n      ? (response.comments as Array<Record<string, unknown>>).map(c => ({\n          file: (c.file as string) || 'unknown',\n          line: (c.line as number) || 0,\n          endLine: c.endLine as number | undefined,\n          ruleId: (c.ruleId as string) || `webhook/${this.validateCategory(c.category)}`,\n          message: (c.message as string) || '',\n          severity: this.validateSeverity(c.severity),\n          category: this.validateCategory(c.category),\n          suggestion: c.suggestion as string | undefined,\n          replacement: c.replacement as string | undefined,\n        }))\n      : [];\n\n    return {\n      issues,\n    };\n  }\n\n  private createErrorResult(url: string, error: unknown): ReviewSummary {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\n    return {\n      issues: [\n        {\n          file: 'webhook',\n          line: 0,\n          endLine: undefined,\n          ruleId: 'webhook/error',\n          message: `Webhook execution error: ${errorMessage}`,\n          severity: 'error',\n          category: 'logic',\n          suggestion: undefined,\n          replacement: undefined,\n        },\n      ],\n    };\n  }\n\n  private validateSeverity(severity: unknown): 'info' | 'warning' | 'error' | 'critical' {\n    const valid = ['info', 'warning', 'error', 'critical'];\n    return valid.includes(severity as string)\n      ? (severity as 'info' | 'warning' | 'error' | 'critical')\n      : 'info';\n  }\n\n  private validateCategory(\n    category: unknown\n  ): 'security' | 'performance' | 'style' | 'logic' | 'documentation' {\n    const valid = ['security', 'performance', 'style', 'logic', 'documentation'];\n    return valid.includes(category as string)\n      ? (category as 'security' | 'performance' | 'style' | 'logic' | 'documentation')\n      : 'logic';\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'url',\n      'body',\n      'method',\n      'headers',\n      'timeout',\n      'metadata',\n      'depends_on',\n      'on',\n      'if',\n      'group',\n      'schedule',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // HTTP provider is available if fetch is available\n    return typeof fetch !== 'undefined';\n  }\n\n  getRequirements(): string[] {\n    return [\n      'Valid HTTP URL',\n      'Body template (Liquid) for payload construction',\n      'Network access to HTTP endpoint',\n      'Optional: Dependencies for accessing their outputs in templates',\n    ];\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { logger } from '../logger';\n\n/**\n * Check provider that receives input from HTTP webhooks and makes it available to dependent checks\n */\nexport class HttpInputProvider extends CheckProvider {\n  private liquid: Liquid;\n  private webhookContext?: Map<string, unknown>;\n\n  constructor() {\n    super();\n    this.liquid = createExtendedLiquid();\n  }\n\n  /**\n   * Set webhook context for accessing webhook data\n   */\n  setWebhookContext(webhookContext: Map<string, unknown>): void {\n    this.webhookContext = webhookContext;\n  }\n\n  getName(): string {\n    return 'http_input';\n  }\n\n  getDescription(): string {\n    return 'Receive and process HTTP webhook input data for use by dependent checks';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'http_input'\n    if (cfg.type !== 'http_input') {\n      return false;\n    }\n\n    // Must have endpoint specified\n    if (typeof cfg.endpoint !== 'string' || !cfg.endpoint) {\n      return false;\n    }\n\n    // Transform is optional but must be string if provided\n    if (cfg.transform !== undefined && typeof cfg.transform !== 'string') {\n      return false;\n    }\n\n    return true;\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    _dependencyResults?: Map<string, ReviewSummary>,\n    _sessionInfo?: { parentSessionId?: string; reuseSession?: boolean }\n  ): Promise<ReviewSummary> {\n    const endpoint = config.endpoint as string;\n    const transform = config.transform as string | undefined;\n\n    // In actual implementation, this would receive data from the webhook server\n    // For now, we'll check if there's webhook data in the execution context\n    const webhookData = this.getWebhookData(endpoint);\n\n    if (!webhookData) {\n      return {\n        issues: [],\n      };\n    }\n\n    // Apply transformation if specified\n    let processedData = webhookData;\n    if (transform) {\n      try {\n        const templateContext = {\n          webhook: webhookData,\n          pr: {\n            number: prInfo.number,\n            title: prInfo.title,\n            author: prInfo.author,\n            base: prInfo.base,\n            head: prInfo.head,\n          },\n        };\n        const rendered = await this.liquid.parseAndRender(transform, templateContext);\n        processedData = JSON.parse(rendered);\n        logger.verbose(`‚úì Applied webhook transform successfully`);\n      } catch (error) {\n        logger.error(\n          `‚úó Failed to transform webhook data: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n        return {\n          issues: [\n            {\n              file: 'webhook_input',\n              line: 0,\n              ruleId: 'webhook_input/transform_error',\n              message: `Failed to transform webhook data: ${error instanceof Error ? error.message : 'Unknown error'}`,\n              severity: 'error',\n              category: 'logic',\n            },\n          ],\n        };\n      }\n    }\n\n    // Return the processed data as a custom field for dependent checks to access\n    // This will be available in outputs for dependent checks\n    return {\n      issues: [],\n      // Add custom data field that will be passed through\n      data: processedData,\n    } as ReviewSummary & { data: unknown };\n  }\n\n  private getWebhookData(endpoint: string): Record<string, unknown> | null {\n    // Use webhook context if available (preferred method)\n    if (this.webhookContext) {\n      return (this.webhookContext.get(endpoint) as Record<string, unknown>) || null;\n    }\n\n    // Fallback to global store for backwards compatibility\n    // This should be removed once all usages are migrated\n    const globalWebhookStore = (global as Record<string, unknown>).__visor_webhook_data as\n      | Map<string, Record<string, unknown>>\n      | undefined;\n    if (globalWebhookStore && globalWebhookStore.get) {\n      console.warn(\n        'HttpInputProvider: Using deprecated global webhook store. Please use webhook context instead.'\n      );\n      return globalWebhookStore.get(endpoint) || null;\n    }\n\n    return null;\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return ['type', 'endpoint', 'transform', 'on', 'depends_on', 'if', 'group'];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // Available if webhook server is configured and running\n    return true;\n  }\n\n  getRequirements(): string[] {\n    return [\n      'HTTP server must be configured and running',\n      'Valid endpoint path specified',\n      'Optional: Transform template for data processing',\n    ];\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { EnvironmentResolver } from '../utils/env-resolver';\n\n/**\n * Check provider that fetches data from HTTP endpoints\n */\nexport class HttpClientProvider extends CheckProvider {\n  private liquid: Liquid;\n\n  constructor() {\n    super();\n    this.liquid = createExtendedLiquid();\n  }\n\n  getName(): string {\n    return 'http_client';\n  }\n\n  getDescription(): string {\n    return 'Fetch data from HTTP endpoints for use by dependent checks';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'http_client'\n    if (cfg.type !== 'http_client') {\n      return false;\n    }\n\n    // Must have URL specified\n    if (typeof cfg.url !== 'string' || !cfg.url) {\n      return false;\n    }\n\n    // Validate URL format\n    try {\n      new URL(cfg.url as string);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    context?: import('./check-provider.interface').ExecutionContext\n  ): Promise<ReviewSummary> {\n    const url = config.url as string;\n    const method = (config.method as string) || 'GET';\n    const headers = (config.headers as Record<string, string>) || {};\n    const timeout = (config.timeout as number) || 30000;\n    const transform = config.transform as string | undefined;\n    const bodyTemplate = config.body as string | undefined;\n\n    try {\n      // Prepare template context for URL and body\n      const templateContext = {\n        pr: {\n          number: prInfo.number,\n          title: prInfo.title,\n          body: prInfo.body,\n          author: prInfo.author,\n          base: prInfo.base,\n          head: prInfo.head,\n          totalAdditions: prInfo.totalAdditions,\n          totalDeletions: prInfo.totalDeletions,\n        },\n        outputs: dependencyResults ? Object.fromEntries(dependencyResults) : {},\n        env: process.env,\n      };\n\n      // Render URL with template if it contains liquid syntax\n      let renderedUrl = url;\n      if (url.includes('{{') || url.includes('{%')) {\n        renderedUrl = await this.liquid.parseAndRender(url, templateContext);\n      }\n\n      // Prepare request body if provided\n      let requestBody: string | undefined;\n      if (bodyTemplate) {\n        const renderedBody = await this.liquid.parseAndRender(bodyTemplate, templateContext);\n        requestBody = renderedBody;\n      }\n\n      // Resolve environment variables in headers\n      const resolvedHeaders = EnvironmentResolver.resolveHeaders(headers);\n\n      // Test hook: mock HTTP response for this step\n      const stepName = (config as any).checkName || 'unknown';\n      const mock = context?.hooks?.mockForStep?.(String(stepName));\n      const data =\n        mock !== undefined\n          ? mock\n          : await this.fetchData(renderedUrl, method, resolvedHeaders, requestBody, timeout);\n\n      // Apply transformation if specified\n      let processedData = data;\n      if (transform) {\n        try {\n          const transformContext = {\n            response: data,\n            pr: templateContext.pr,\n            outputs: templateContext.outputs,\n          };\n          const rendered = await this.liquid.parseAndRender(transform, transformContext);\n          // Try to parse as JSON if the transform result looks like JSON\n          if (rendered.trim().startsWith('{') || rendered.trim().startsWith('[')) {\n            processedData = JSON.parse(rendered);\n          } else {\n            processedData = rendered;\n          }\n        } catch (error) {\n          return {\n            issues: [\n              {\n                file: 'http_client',\n                line: 0,\n                ruleId: 'http_client/transform_error',\n                message: `Failed to transform response data: ${error instanceof Error ? error.message : 'Unknown error'}`,\n                severity: 'error',\n                category: 'logic',\n              },\n            ],\n          };\n        }\n      }\n\n      // Return the fetched data as a custom field for dependent checks to access\n      return {\n        issues: [],\n        // Add custom data field that will be passed through to dependent checks\n        data: processedData,\n      } as ReviewSummary & { data: unknown };\n    } catch (error) {\n      return {\n        issues: [\n          {\n            file: 'http_client',\n            line: 0,\n            ruleId: 'http_client/fetch_error',\n            message: `Failed to fetch from ${url}: ${error instanceof Error ? error.message : 'Unknown error'}`,\n            severity: 'error',\n            category: 'logic',\n          },\n        ],\n      };\n    }\n  }\n\n  private async fetchData(\n    url: string,\n    method: string,\n    headers: Record<string, string>,\n    body?: string,\n    timeout: number = 30000\n  ): Promise<unknown> {\n    // Check if fetch is available (Node 18+)\n    if (typeof fetch === 'undefined') {\n      throw new Error('HTTP client provider requires Node.js 18+ or node-fetch package');\n    }\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n    try {\n      const requestOptions: RequestInit = {\n        method,\n        headers: {\n          ...headers,\n        },\n        signal: controller.signal,\n      };\n\n      // Add body for non-GET requests\n      if (method !== 'GET' && body) {\n        requestOptions.body = body;\n        // Set Content-Type if not already set\n        if (!headers['Content-Type'] && !headers['content-type']) {\n          requestOptions.headers = {\n            ...requestOptions.headers,\n            'Content-Type': 'application/json',\n          };\n        }\n      }\n\n      const response = await fetch(url, requestOptions);\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      // Try to parse as JSON first\n      const contentType = response.headers.get('content-type');\n      if (contentType && contentType.includes('application/json')) {\n        return await response.json();\n      }\n\n      // Otherwise return as text\n      const text = await response.text();\n\n      // Try to parse as JSON if it looks like JSON\n      if (text.trim().startsWith('{') || text.trim().startsWith('[')) {\n        try {\n          return JSON.parse(text);\n        } catch {\n          // Not JSON, return as text\n          return text;\n        }\n      }\n\n      return text;\n    } catch (error: unknown) {\n      clearTimeout(timeoutId);\n\n      if (error instanceof Error && error.name === 'AbortError') {\n        throw new Error(`Request timed out after ${timeout}ms`);\n      }\n\n      throw error;\n    }\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'url',\n      'method',\n      'headers',\n      'body',\n      'transform',\n      'timeout',\n      'depends_on',\n      'on',\n      'if',\n      'group',\n      'schedule',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // HTTP client is available if fetch is available\n    return typeof fetch !== 'undefined';\n  }\n\n  getRequirements(): string[] {\n    return [\n      'Valid HTTP/HTTPS URL to fetch from',\n      'Network access to the endpoint',\n      'Optional: Transform template for processing response data',\n      'Optional: Body template for POST/PUT requests',\n    ];\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\n\n/**\n * No-operation check provider that doesn't perform any analysis.\n *\n * This provider is designed for command orchestration - it allows creating\n * checks that exist purely to trigger other checks through dependencies.\n *\n * Example use case: A \"/review\" command that triggers multiple analysis checks\n * without performing any analysis itself.\n */\nexport class NoopCheckProvider extends CheckProvider {\n  getName(): string {\n    return 'noop';\n  }\n\n  getDescription(): string {\n    return 'No-operation provider for command orchestration and dependency triggering';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'noop'\n    if (cfg.type !== 'noop') {\n      return false;\n    }\n\n    return true;\n  }\n\n  async execute(\n    _prInfo: PRInfo,\n    _config: CheckProviderConfig,\n    _dependencyResults?: Map<string, ReviewSummary>,\n    _sessionInfo?: { parentSessionId?: string; reuseSession?: boolean }\n  ): Promise<ReviewSummary> {\n    // Noop provider doesn't perform any analysis\n    // It exists purely for command orchestration and dependency triggering\n    return {\n      issues: [],\n    };\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return ['type', 'command', 'depends_on', 'on', 'if', 'group'];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // Noop provider is always available\n    return true;\n  }\n\n  getRequirements(): string[] {\n    return [\n      'No external dependencies required',\n      'Used for command orchestration and dependency triggering',\n    ];\n  }\n}\n","import { CheckProvider, CheckProviderConfig, ExecutionContext } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { logger } from '../logger';\n\n/**\n * Log levels supported by the log provider\n */\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\n/**\n * Check provider that outputs debugging and logging information.\n * Useful for troubleshooting check workflows and understanding execution flow.\n */\nexport class LogCheckProvider extends CheckProvider {\n  private liquid: Liquid;\n\n  constructor() {\n    super();\n    this.liquid = createExtendedLiquid({\n      strictVariables: false,\n      strictFilters: false,\n    });\n  }\n\n  getName(): string {\n    return 'log';\n  }\n\n  getDescription(): string {\n    return 'Output debugging and logging information for troubleshooting check workflows';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'log'\n    if (cfg.type !== 'log') {\n      return false;\n    }\n\n    // Message is required\n    if (!cfg.message || typeof cfg.message !== 'string') {\n      return false;\n    }\n\n    // Validate log level if provided\n    if (cfg.level && !['debug', 'info', 'warn', 'error'].includes(cfg.level as string)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    context?: ExecutionContext\n  ): Promise<ReviewSummary> {\n    const message = config.message as string;\n    const level = (config.level as LogLevel) || 'info';\n    const includePrContext = config.include_pr_context !== false;\n    const includeDependencies = config.include_dependencies !== false;\n    const includeMetadata = config.include_metadata !== false;\n\n    // Prepare template context\n    const templateContext = this.buildTemplateContext(\n      prInfo,\n      dependencyResults,\n      includePrContext,\n      includeDependencies,\n      includeMetadata,\n      config.__outputHistory as Map<string, unknown[]> | undefined,\n      context\n    );\n\n    // Render the log message template\n    const renderedMessage = await this.liquid.parseAndRender(message, templateContext);\n\n    // Build the log output\n    const logOutput = this.formatLogOutput(\n      level,\n      renderedMessage,\n      templateContext,\n      includePrContext,\n      includeDependencies,\n      includeMetadata\n    );\n\n    // Route through centralized logger to keep stdout clean in JSON/SARIF\n    if (level === 'error') logger.error(logOutput);\n    else if (level === 'warn') logger.warn(logOutput);\n    else if (level === 'debug') logger.debug(logOutput);\n    else logger.info(logOutput);\n\n    // Return with the log content as custom data for dependent checks\n    return {\n      issues: [],\n      // Add log output as custom field\n      logOutput,\n    } as ReviewSummary & { logOutput: string };\n  }\n\n  private buildTemplateContext(\n    prInfo: PRInfo,\n    dependencyResults?: Map<string, ReviewSummary>,\n    _includePrContext: boolean = true,\n    _includeDependencies: boolean = true,\n    includeMetadata: boolean = true,\n    outputHistory?: Map<string, unknown[]>,\n    executionContext?: ExecutionContext\n  ): Record<string, unknown> {\n    const context: Record<string, unknown> = {};\n\n    // Always provide pr context for template rendering\n    context.pr = {\n      number: prInfo.number,\n      title: prInfo.title,\n      body: prInfo.body,\n      author: prInfo.author,\n      base: prInfo.base,\n      head: prInfo.head,\n      totalAdditions: prInfo.totalAdditions,\n      totalDeletions: prInfo.totalDeletions,\n      files: prInfo.files.map(f => ({\n        filename: f.filename,\n        status: f.status,\n        additions: f.additions,\n        deletions: f.deletions,\n        changes: f.changes,\n      })),\n    };\n\n    // Add convenience data\n    context.filenames = prInfo.files.map(f => f.filename);\n    context.fileCount = prInfo.files.length;\n\n    // Always provide dependency data for template rendering\n    if (dependencyResults) {\n      const dependencies: Record<string, unknown> = {};\n      const outputs: Record<string, unknown> = {};\n      const outputsRaw: Record<string, unknown> = {};\n      const history: Record<string, unknown[]> = {};\n      context.dependencyCount = dependencyResults.size;\n\n      for (const [checkName, result] of dependencyResults.entries()) {\n        if (typeof checkName !== 'string') continue;\n        dependencies[checkName] = {\n          issueCount: result.issues?.length || 0,\n          suggestionCount: 0,\n          issues: result.issues || [],\n        };\n\n        // Add outputs namespace for accessing dependency results directly\n        const summary = result as import('../reviewer').ReviewSummary & { output?: unknown };\n        if (typeof checkName === 'string' && checkName.endsWith('-raw')) {\n          const name = checkName.slice(0, -4);\n          outputsRaw[name] = summary.output !== undefined ? summary.output : summary;\n        } else {\n          outputs[checkName] = summary.output !== undefined ? summary.output : summary;\n        }\n      }\n\n      // Add history for each check if available\n      if (outputHistory) {\n        for (const [checkName, historyArray] of outputHistory) {\n          history[checkName] = historyArray;\n        }\n      }\n\n      // Attach history to the outputs object\n      (outputs as any).history = history;\n\n      context.dependencies = dependencies;\n      context.outputs = outputs;\n      // Alias: outputs_history mirrors outputs.history for consistency\n      (context as any).outputs_history = history;\n      // New: outputs_raw exposes aggregate values (e.g., arrays) for forEach parents\n      (context as any).outputs_raw = outputsRaw;\n    }\n\n    if (includeMetadata) {\n      context.metadata = {\n        timestamp: new Date().toISOString(),\n        executionTime: Date.now(),\n        nodeVersion: process.version,\n        platform: process.platform,\n        workingDirectory: process.cwd(),\n      };\n    }\n\n    // Add workflow inputs if available\n    const workflowInputs = executionContext?.workflowInputs || {};\n    logger.debug(\n      `[LogProvider] Adding ${Object.keys(workflowInputs).length} workflow inputs to context`\n    );\n    context.inputs = workflowInputs;\n\n    return context;\n  }\n\n  private formatLogOutput(\n    level: LogLevel,\n    message: string,\n    templateContext: Record<string, unknown>,\n    includePrContext: boolean,\n    includeDependencies: boolean,\n    includeMetadata: boolean\n  ): string {\n    const sections: string[] = [];\n\n    // Log level and message\n    const levelEmoji = this.getLevelEmoji(level);\n    sections.push(`${levelEmoji} **${level.toUpperCase()}**: ${message}`);\n\n    // PR context section\n    if (includePrContext && templateContext.pr) {\n      const pr = templateContext.pr as Record<string, unknown>;\n      sections.push('');\n      sections.push('### PR Context');\n      sections.push(`- **PR #${pr.number}**: ${pr.title}`);\n      sections.push(`- **Author**: ${pr.author}`);\n      sections.push(`- **Base**: ${pr.base} ‚Üí **Head**: ${pr.head}`);\n      sections.push(`- **Changes**: +${pr.totalAdditions} -${pr.totalDeletions}`);\n      sections.push(`- **Files Modified**: ${templateContext.fileCount}`);\n    }\n\n    // Dependencies section\n    if (includeDependencies && templateContext.dependencies) {\n      const deps = templateContext.dependencies as Record<string, Record<string, unknown>>;\n      sections.push('');\n      sections.push('### Dependency Results');\n\n      if (Object.keys(deps).length === 0) {\n        sections.push('- No dependency results available');\n      } else {\n        for (const [checkName, result] of Object.entries(deps)) {\n          sections.push(\n            `- **${checkName}**: ${result.issueCount} issues, ${result.suggestionCount} suggestions`\n          );\n        }\n      }\n    }\n\n    // Metadata section\n    if (includeMetadata && templateContext.metadata) {\n      const meta = templateContext.metadata as Record<string, unknown>;\n      sections.push('');\n      sections.push('### Execution Metadata');\n      sections.push(`- **Timestamp**: ${meta.timestamp}`);\n      sections.push(`- **Node Version**: ${meta.nodeVersion}`);\n      sections.push(`- **Platform**: ${meta.platform}`);\n      sections.push(`- **Working Directory**: ${meta.workingDirectory}`);\n    }\n\n    return sections.join('\\n');\n  }\n\n  private getLevelEmoji(level: LogLevel): string {\n    switch (level) {\n      case 'debug':\n        return 'üêõ';\n      case 'info':\n        return '‚ÑπÔ∏è';\n      case 'warn':\n        return '‚ö†Ô∏è';\n      case 'error':\n        return '‚ùå';\n      default:\n        return '‚ÑπÔ∏è';\n    }\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'message',\n      'level',\n      'include_pr_context',\n      'include_dependencies',\n      'include_metadata',\n      'group',\n      'command',\n      'depends_on',\n      'on',\n      'if',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // Log provider is always available\n    return true;\n  }\n\n  getRequirements(): string[] {\n    return [\n      'No external dependencies required',\n      'Used for debugging and logging check execution flow',\n    ];\n  }\n}\n","import Sandbox from '@nyariv/sandboxjs';\n\n/**\n * Centralized helpers for creating and using SandboxJS instances consistently\n * across providers. The goal is to have one place to define allowed globals\n * and prototype whitelists, and to offer a small helper to inject a `log`\n * utility inside user-provided JS snippets.\n */\n\nexport interface CompileOptions {\n  injectLog?: boolean;\n  logPrefix?: string;\n  /** When true, wrap the code in a function and `return` its result */\n  wrapFunction?: boolean;\n}\n\n/**\n * Create a hardened Sandbox with a consistent set of globals and prototype\n * whitelists. This is a superset of the sets previously used by individual\n * providers, kept intentionally minimal and side‚Äëeffect free.\n */\nexport function createSecureSandbox(): Sandbox {\n  const globals = {\n    ...Sandbox.SAFE_GLOBALS,\n    Math,\n    JSON,\n    // Provide console with limited surface. Use trampolines so that any test\n    // spies (e.g., jest.spyOn(console, 'log')) see calls made inside the sandbox.\n    console: {\n      log: (...args: unknown[]) => {\n        try {\n          (console as any).log(...args);\n        } catch {}\n      },\n      warn: (...args: unknown[]) => {\n        try {\n          (console as any).warn(...args);\n        } catch {}\n      },\n      error: (...args: unknown[]) => {\n        try {\n          (console as any).error(...args);\n        } catch {}\n      },\n    },\n  } as Record<string, unknown>;\n\n  const prototypeWhitelist = new Map(Sandbox.SAFE_PROTOTYPES);\n\n  // Arrays ‚Äî union of methods used around the codebase\n  const arrayMethods = new Set<string>([\n    // Query/iteration\n    'some',\n    'every',\n    'filter',\n    'map',\n    'reduce',\n    'reduceRight',\n    'find',\n    'findIndex',\n    'findLast',\n    'findLastIndex',\n    'includes',\n    'indexOf',\n    'lastIndexOf',\n    'keys',\n    'values',\n    'entries',\n    'forEach',\n    // Non‚Äëmutating ES2023 additions\n    'toReversed',\n    'toSorted',\n    'toSpliced',\n    'with',\n    'at',\n    // Mutators and common ops\n    'slice',\n    'concat',\n    'join',\n    'push',\n    'pop',\n    'shift',\n    'unshift',\n    'sort',\n    'reverse',\n    'copyWithin',\n    'fill',\n    // Flattening\n    'flat',\n    'flatMap',\n    // Meta\n    'length',\n  ]);\n  prototypeWhitelist.set(Array.prototype, arrayMethods);\n\n  // Strings ‚Äî allow common, safe manipulation helpers\n  const stringMethods = new Set<string>([\n    'toLowerCase',\n    'toUpperCase',\n    'includes',\n    'indexOf',\n    'lastIndexOf',\n    'startsWith',\n    'endsWith',\n    'slice',\n    'substring',\n    'substr',\n    'trim',\n    'trimStart',\n    'trimEnd',\n    'split',\n    'replace',\n    'replaceAll',\n    'match',\n    'matchAll',\n    'charAt',\n    'charCodeAt',\n    'codePointAt',\n    'normalize',\n    'repeat',\n    'padStart',\n    'padEnd',\n    'at',\n    'length',\n  ]);\n  prototypeWhitelist.set(String.prototype, stringMethods);\n\n  // Objects ‚Äî keep to basic safe operations\n  const objectMethods = new Set<string>([\n    'hasOwnProperty',\n    'propertyIsEnumerable',\n    'toString',\n    'valueOf',\n  ]);\n  prototypeWhitelist.set(Object.prototype, objectMethods);\n\n  // Keep native constructors from SAFE_GLOBALS; rely on prototype whitelists above.\n\n  // Maps and Sets ‚Äî allow common, safe operations\n  const mapMethods = new Set<string>([\n    'get',\n    'set',\n    'has',\n    'delete',\n    'entries',\n    'keys',\n    'values',\n    'forEach',\n  ]);\n  // @ts-ignore - sandbox typings accept Map.prototype as a key\n  prototypeWhitelist.set((Map as any).prototype, mapMethods);\n\n  const setMethods = new Set<string>([\n    'add',\n    'has',\n    'delete',\n    'entries',\n    'keys',\n    'values',\n    'forEach',\n  ]);\n  // @ts-ignore\n  prototypeWhitelist.set((Set as any).prototype, setMethods);\n\n  // Date and RegExp ‚Äî read‚Äëonly helpers\n  const dateMethods = new Set<string>(['toISOString', 'toJSON', 'getTime']);\n  // @ts-ignore\n  prototypeWhitelist.set((Date as any).prototype, dateMethods);\n\n  const regexpMethods = new Set<string>(['test', 'exec']);\n  // @ts-ignore\n  prototypeWhitelist.set((RegExp as any).prototype, regexpMethods);\n\n  return new Sandbox({ globals, prototypeWhitelist });\n}\n\n/**\n * Compile and execute user-provided JS inside the sandbox with optional\n * helper injection. By default, code is wrapped in a function to keep the\n * global scope clean.\n */\nexport function compileAndRun<T = unknown>(\n  sandbox: Sandbox,\n  userCode: string,\n  scope: Record<string, unknown>,\n  opts: CompileOptions = { injectLog: true, wrapFunction: true, logPrefix: '[sandbox]' }\n): T {\n  const inject = opts?.injectLog === true;\n  let safePrefix = String(opts?.logPrefix ?? '[sandbox]');\n  // Sanitize prefix aggressively: drop control chars and risky tokens, limit length\n  safePrefix = safePrefix\n    .replace(/[\\r\\n\\t\\0]/g, '')\n    .replace(/[`$\\\\]/g, '') // strip backticks, dollar (template) and backslashes\n    .replace(/\\$\\{/g, '') // remove template openings if present\n    .slice(0, 64);\n  // Build a safe header without string concatenation inside user code\n  const header = inject\n    ? `const __lp = ${JSON.stringify(safePrefix)}; const log = (...a) => { try { console.log(__lp, ...a); } catch {} };\\n`\n    : '';\n  // When wrapping, execute user code inside an IIFE and return its value.\n  // This reliably captures the value of the last expression or any explicit\n  // return statements inside the script, without requiring the caller to\n  // manually `return` at top level.\n  // Wrapper heuristic:\n  // - If the snippet contains an explicit `return`, semicolons or newlines (likely a block),\n  //   run it inside an IIFE so `return` works:  (() => { code })()\n  // - Otherwise treat it as a pure expression and return its value directly.\n  const src = String(userCode);\n  const looksLikeBlock = /\\breturn\\b/.test(src) || /;/.test(src) || /\\n/.test(src);\n  // Heuristic: if the snippet itself looks like an IIFE/callable expression\n  // (e.g., `(() => { ... })()` or `(function(){ ... })()`), return its value\n  // directly to avoid swallowing the result by nesting it inside another block.\n  const looksLikeIife = /\\)\\s*\\(\\s*\\)\\s*;?$/.test(src.trim());\n  const body = opts.wrapFunction\n    ? looksLikeBlock\n      ? looksLikeIife\n        ? `return (\\n${src}\\n);\\n`\n        : `return (() => {\\n${src}\\n})();\\n`\n      : `return (\\n${src}\\n);\\n`\n    : `${src}`;\n  const code = `${header}${body}`;\n  let exec: ReturnType<typeof sandbox.compile>;\n  try {\n    exec = sandbox.compile(code);\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    throw new Error(`sandbox_compile_error: ${msg}`);\n  }\n\n  let out: any;\n  try {\n    out = exec(scope);\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    throw new Error(`sandbox_execution_error: ${msg}`);\n  }\n\n  if (out && typeof out.run === 'function') {\n    try {\n      return out.run();\n    } catch (e) {\n      const msg = e instanceof Error ? e.message : String(e);\n      throw new Error(`sandbox_runner_error: ${msg}`);\n    }\n  }\n  return out as T;\n}\n","import type { RecordingOctokit } from './github-recorder';\n\nlet __rec: RecordingOctokit | null = null;\n\nexport function setGlobalRecorder(r: RecordingOctokit | null): void {\n  __rec = r;\n}\n\nexport function getGlobalRecorder(): RecordingOctokit | null {\n  return __rec;\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport Sandbox from '@nyariv/sandboxjs';\nimport { createSecureSandbox, compileAndRun } from '../utils/sandbox';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { logger } from '../logger';\n\nexport class GitHubOpsProvider extends CheckProvider {\n  private sandbox?: Sandbox;\n\n  getName(): string {\n    return 'github';\n  }\n\n  getDescription(): string {\n    return 'Native GitHub operations (labels, comments, reviewers) executed via Octokit';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') return false;\n    const cfg = config as CheckProviderConfig & { op?: string };\n    return typeof cfg.op === 'string' && cfg.op.length > 0;\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return ['op', 'values', 'value', 'value_js'];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // Available when running in GitHub context or when a token is provided\n    return Boolean(\n      process.env.GITHUB_TOKEN || process.env['INPUT_GITHUB-TOKEN'] || process.env.GITHUB_REPOSITORY\n    );\n  }\n\n  getRequirements(): string[] {\n    return ['GITHUB_TOKEN or INPUT_GITHUB-TOKEN', 'GITHUB_REPOSITORY'];\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>\n  ): Promise<ReviewSummary> {\n    const cfg = config as CheckProviderConfig & {\n      op: string;\n      values?: string[] | string;\n      value?: string;\n      value_js?: string;\n    };\n\n    // IMPORTANT: Always prefer authenticated octokit from event context (GitHub App or token)\n    // This ensures proper bot identity in reactions, labels, and comments\n    let octokit: import('@octokit/rest').Octokit | undefined = config.eventContext?.octokit as\n      | import('@octokit/rest').Octokit\n      | undefined;\n    if (process.env.VISOR_DEBUG === 'true') {\n      try {\n        logger.debug(`[github-ops] pre-fallback octokit? ${!!octokit}`);\n      } catch {}\n    }\n    // Test runner fallback: use global recorder if eventContext is missing octokit\n    if (!octokit) {\n      try {\n        const { getGlobalRecorder } = require('../test-runner/recorders/global-recorder');\n        const rec = getGlobalRecorder && getGlobalRecorder();\n        if (rec) octokit = rec as any;\n      } catch {}\n    }\n\n    if (!octokit) {\n      if (process.env.VISOR_DEBUG === 'true') {\n        try {\n          console.error('[github-ops] missing octokit after fallback ‚Äî returning issue');\n        } catch {}\n      }\n      return {\n        issues: [\n          {\n            file: 'system',\n            line: 0,\n            ruleId: 'github/missing_octokit',\n            message:\n              'No authenticated Octokit instance available in event context. GitHub operations require proper authentication context.',\n            severity: 'error',\n            category: 'logic',\n          },\n        ],\n      };\n    }\n\n    const repoEnv = process.env.GITHUB_REPOSITORY || '';\n    let owner = '';\n    let repo = '';\n    if (repoEnv.includes('/')) {\n      [owner, repo] = repoEnv.split('/') as [string, string];\n    } else {\n      try {\n        const ec: any = config.eventContext || {};\n        owner = ec?.repository?.owner?.login || owner;\n        repo = ec?.repository?.name || repo;\n      } catch {}\n    }\n    try {\n      if (process.env.VISOR_DEBUG === 'true') {\n        logger.info(\n          `[github-ops] context octokit? ${!!octokit} repo=${owner}/${repo} pr#=${prInfo?.number}`\n        );\n      }\n    } catch {}\n    if (!owner || !repo || !prInfo?.number) {\n      return {\n        issues: [\n          {\n            file: 'system',\n            line: 0,\n            ruleId: 'github/missing_context',\n            message: 'Missing owner/repo or PR number; GitHub operations require Action context',\n            severity: 'error',\n            category: 'logic',\n          },\n        ],\n      };\n    }\n\n    // Build values list (allow string or array), render Liquid templates if present, and normalize\n    let valuesRaw: string[] = [];\n    if (Array.isArray(cfg.values)) valuesRaw = (cfg.values as unknown[]).map(v => String(v));\n    else if (typeof cfg.values === 'string') valuesRaw = [cfg.values];\n    else if (typeof cfg.value === 'string') valuesRaw = [cfg.value];\n    try {\n      if (process.env.VISOR_DEBUG === 'true') {\n        logger.info(`[github-ops] op=${cfg.op} valuesRaw(before)=${JSON.stringify(valuesRaw)}`);\n      }\n    } catch {}\n\n    // Liquid render helper for values\n    const renderValues = async (arr: string[]): Promise<string[]> => {\n      if (!arr || arr.length === 0) return [];\n      const liq = createExtendedLiquid({\n        cache: false,\n        strictFilters: false,\n        strictVariables: false,\n      });\n      const outputs: Record<string, unknown> = {};\n      if (dependencyResults) {\n        for (const [name, result] of dependencyResults.entries()) {\n          const summary = result as ReviewSummary & { output?: unknown };\n          outputs[name] = summary.output !== undefined ? summary.output : summary;\n        }\n      }\n      // Fallback: if outputs missing but engine provided history, use last output snapshot\n      try {\n        const hist = (config as any).__outputHistory as Map<string, unknown[]> | undefined;\n        if (hist) {\n          for (const [name, arr] of hist.entries()) {\n            if (!outputs[name] && Array.isArray(arr) && arr.length > 0) {\n              outputs[name] = arr[arr.length - 1];\n            }\n          }\n        }\n      } catch {}\n      const ctx = {\n        pr: {\n          number: prInfo.number,\n          title: prInfo.title,\n          author: prInfo.author,\n          branch: prInfo.head,\n          base: prInfo.base,\n          authorAssociation: prInfo.authorAssociation,\n        },\n        outputs,\n      };\n      try {\n        if (process.env.VISOR_DEBUG === 'true') {\n          logger.info(`[github-ops] deps keys=${Object.keys(outputs).join(', ')}`);\n          const ov = outputs['overview'] as any;\n          if (ov) {\n            logger.info(`[github-ops] outputs.overview.keys=${Object.keys(ov).join(',')}`);\n            if (ov.tags) {\n              logger.info(\n                `[github-ops] outputs.overview.tags keys=${Object.keys(ov.tags).join(',')}`\n              );\n              try {\n                logger.info(\n                  `[github-ops] outputs.overview.tags['review-effort']=${String(ov.tags['review-effort'])}`\n                );\n              } catch {}\n            }\n          }\n        }\n      } catch {}\n      const out: string[] = [];\n      for (const item of arr) {\n        if (typeof item === 'string' && (item.includes('{{') || item.includes('{%'))) {\n          try {\n            const rendered = await liq.parseAndRender(item, ctx);\n            out.push(rendered);\n          } catch (e) {\n            // If Liquid fails, surface as a provider error\n            const msg = e instanceof Error ? e.message : String(e);\n            if (process.env.VISOR_DEBUG === 'true') {\n              logger.warn(`[github-ops] liquid_render_error: ${msg}`);\n            }\n            return Promise.reject({\n              issues: [\n                {\n                  file: 'system',\n                  line: 0,\n                  ruleId: 'github/liquid_render_error',\n                  message: `Failed to render template: ${msg}`,\n                  severity: 'error',\n                  category: 'logic',\n                },\n              ],\n            } as ReviewSummary);\n          }\n        } else {\n          out.push(String(item));\n        }\n      }\n      return out;\n    };\n\n    let values: string[] = await renderValues(valuesRaw);\n\n    // Expose dependency outputs to value_js for convenience (generic map)\n    const depOutputs: Record<string, unknown> = {};\n    if (dependencyResults) {\n      for (const [name, result] of dependencyResults.entries()) {\n        const summary = result as ReviewSummary & { output?: unknown };\n        depOutputs[name] = summary.output !== undefined ? summary.output : summary;\n      }\n    }\n\n    if (cfg.value_js && cfg.value_js.trim()) {\n      try {\n        // Evaluate user-provided value_js in a restricted sandbox (no process/global exposure)\n        const sandbox = this.getSecureSandbox();\n\n        const res = compileAndRun<unknown>(\n          sandbox,\n          cfg.value_js,\n          { pr: prInfo, values, outputs: depOutputs },\n          { injectLog: true, wrapFunction: true, logPrefix: '[github:value_js]' }\n        );\n        if (typeof res === 'string') values = [res];\n        else if (Array.isArray(res)) values = (res as unknown[]).map(v => String(v));\n      } catch (e) {\n        // Generic fallback: keep pre-rendered values as-is (no hardcoded deps)\n        // Never hardcode a particular step like 'issue-assistant'.\n        const msg = e instanceof Error ? e.message : String(e);\n        if (process.env.VISOR_DEBUG === 'true') logger.warn(`[github-ops] value_js_error: ${msg}`);\n        // Normalize strings; leave empty if no values were provided.\n        values = Array.isArray(values)\n          ? values.map(v => String(v ?? '').trim()).filter(Boolean)\n          : [];\n      }\n    }\n\n    // Fallback: if values are still empty, try deriving from dependency outputs\n    // 1) Common pattern: outputs.<dep>.labels (e.g., from issue-assistant)\n    if (values.length === 0 && Object.keys(depOutputs).length > 0) {\n      try {\n        const lbls: string[] = [];\n        for (const obj of Object.values(depOutputs)) {\n          const labelsAny = (obj as any)?.labels;\n          if (Array.isArray(labelsAny)) {\n            for (const v of labelsAny) lbls.push(String(v ?? ''));\n          }\n        }\n        const norm = lbls\n          .map(s => s.trim())\n          .filter(Boolean)\n          .map(s => s.replace(/[^A-Za-z0-9:\\/\\- ]/g, '').replace(/\\/{2,}/g, '/'));\n        values = Array.from(new Set(norm));\n        if (process.env.VISOR_DEBUG === 'true') {\n          logger.info(`[github-ops] derived values from deps.labels: ${JSON.stringify(values)}`);\n        }\n      } catch {}\n    }\n\n    // 2) Fallback: outputs.<dep>.tags based derivation (overview-style)\n    // Fallback: if values are still empty, try deriving from dependency outputs (common pattern: outputs.<dep>.tags)\n    if (values.length === 0 && dependencyResults && dependencyResults.size > 0) {\n      try {\n        const derived: string[] = [];\n        for (const result of dependencyResults.values()) {\n          const out = (result as ReviewSummary & { output?: unknown })?.output ?? result;\n          const tags = (out as Record<string, unknown>)?.['tags'] as\n            | Record<string, unknown>\n            | undefined;\n          if (tags && typeof tags === 'object') {\n            const label = tags['label'];\n            const effort = (tags as Record<string, unknown>)['review-effort'];\n            if (label != null) derived.push(String(label));\n            if (effort !== undefined && effort !== null)\n              derived.push(`review/effort:${String(effort)}`);\n          }\n        }\n        values = derived;\n        if (process.env.VISOR_DEBUG === 'true') {\n          logger.info(`[github-ops] derived values from deps: ${JSON.stringify(values)}`);\n        }\n      } catch {}\n    }\n\n    // Trim, drop empty, and de-duplicate values regardless of source\n    values = values.map(v => v.trim()).filter(v => v.length > 0);\n    values = Array.from(new Set(values));\n\n    try {\n      // Minimal debug to help diagnose label flow under tests\n      if (process.env.NODE_ENV === 'test' || process.env.VISOR_DEBUG === 'true') {\n        logger.info(`[github-ops] ${cfg.op} resolved values: ${JSON.stringify(values)}`);\n      }\n    } catch {}\n\n    try {\n      switch (cfg.op) {\n        case 'labels.add': {\n          if (values.length === 0) break; // no-op if nothing to add\n          try {\n            if (process.env.VISOR_OUTPUT_FORMAT !== 'json')\n              logger.step(`[github-ops] labels.add -> ${JSON.stringify(values)}`);\n          } catch {}\n          await octokit.rest.issues.addLabels({\n            owner,\n            repo,\n            issue_number: prInfo.number,\n            labels: values,\n          });\n          break;\n        }\n        case 'labels.remove': {\n          for (const l of values) {\n            await octokit.rest.issues.removeLabel({\n              owner,\n              repo,\n              issue_number: prInfo.number,\n              name: l,\n            });\n          }\n          break;\n        }\n        case 'comment.create': {\n          const body = values.join('\\n').trim();\n          if (body)\n            await octokit.rest.issues.createComment({\n              owner,\n              repo,\n              issue_number: prInfo.number,\n              body,\n            });\n          break;\n        }\n        default:\n          return {\n            issues: [\n              {\n                file: 'system',\n                line: 0,\n                ruleId: 'github/unsupported_op',\n                message: `Unsupported GitHub op: ${cfg.op}`,\n                severity: 'error',\n                category: 'logic',\n              },\n            ],\n          };\n      }\n\n      return { issues: [] };\n    } catch (e) {\n      const msg = e instanceof Error ? e.message : String(e);\n      try {\n        logger.error(`[github-ops] op_failed ${cfg.op}: ${msg}`);\n      } catch {}\n      return {\n        issues: [\n          {\n            file: 'system',\n            line: 0,\n            ruleId: 'github/op_failed',\n            message: `GitHub operation failed (${cfg.op}): ${msg}`,\n            severity: 'error',\n            category: 'logic',\n          },\n        ],\n      };\n    }\n  }\n\n  /**\n   * Create a secure sandbox for evaluating small expressions without access to process/env\n   */\n  private getSecureSandbox(): Sandbox {\n    if (this.sandbox) return this.sandbox;\n    this.sandbox = createSecureSandbox();\n    return this.sandbox;\n  }\n}\n","/**\n * Type definitions for Claude Code SDK and MCP SDK\n * These are placeholder types for when the packages aren't installed\n */\n\n// Claude Code SDK types\nexport interface ClaudeCodeQuery {\n  query: string;\n  tools?: Array<{\n    name: string;\n    [key: string]: unknown;\n  }>;\n  subagent?: string;\n  maxTurns?: number;\n  systemPrompt?: string;\n  sessionId?: string;\n}\n\nexport interface ClaudeCodeResponse {\n  content: string;\n  usage?: {\n    input_tokens: number;\n    output_tokens: number;\n  };\n  turn_count?: number;\n  session_id?: string;\n}\n\nexport interface ClaudeCodeClient {\n  query(options: ClaudeCodeQuery): Promise<ClaudeCodeResponse>;\n}\n\n// MCP Server configuration interface\nexport interface McpServerConfig {\n  command: string;\n  args?: string[];\n  env?: Record<string, string>;\n}\n\n// MCP Tool interface\nexport interface McpTool {\n  name: string;\n  description?: string;\n  inputSchema?: Record<string, unknown>;\n  handler?: (args: Record<string, unknown>) => Promise<unknown>;\n}\n\n// MCP Server interface\nexport interface McpServer {\n  name: string;\n  command?: string;\n  args?: string[];\n  env?: Record<string, string>;\n  tools?: McpTool[];\n}\n\n// MCP Server Instance interface\nexport interface McpServerInstance {\n  name: string;\n  listTools(): Promise<McpTool[]>;\n  callTool(name: string, args: Record<string, unknown>): Promise<unknown>;\n  close(): Promise<void>;\n}\n\n// Claude Code configuration interface\nexport interface ClaudeCodeConfig {\n  allowedTools?: string[];\n  maxTurns?: number;\n  systemPrompt?: string;\n  mcpServers?: Record<string, McpServerConfig>;\n  subagent?: string;\n  hooks?: {\n    onStart?: string;\n    onEnd?: string;\n    onError?: string;\n  };\n}\n\n/**\n * Utility function to safely import optional dependencies\n */\nexport async function safeImport<T>(moduleName: string): Promise<T | null> {\n  try {\n    return await import(moduleName);\n  } catch {\n    return null;\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { EnvironmentResolver } from '../utils/env-resolver';\nimport { IssueFilter } from '../issue-filter';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport {\n  ClaudeCodeQuery,\n  ClaudeCodeResponse,\n  ClaudeCodeConfig,\n  ClaudeCodeClient,\n  safeImport,\n} from './claude-code-types';\n\ntype ClaudeCodeConstructor = new (options: { apiKey: string }) => ClaudeCodeClient;\n\nfunction isClaudeCodeConstructor(value: unknown): value is ClaudeCodeConstructor {\n  return typeof value === 'function';\n}\n\n/**\n * Error thrown when Claude Code SDK is not installed\n */\nexport class ClaudeCodeSDKNotInstalledError extends Error {\n  constructor() {\n    super(\n      'Claude Code SDK is not installed. Install with: npm install @anthropic/claude-code-sdk @modelcontextprotocol/sdk'\n    );\n    this.name = 'ClaudeCodeSDKNotInstalledError';\n  }\n}\n\n/**\n * Error thrown when Claude Code API key is not configured\n */\nexport class ClaudeCodeAPIKeyMissingError extends Error {\n  constructor() {\n    super(\n      'No API key found for Claude Code provider. Set CLAUDE_CODE_API_KEY or ANTHROPIC_API_KEY environment variable.'\n    );\n    this.name = 'ClaudeCodeAPIKeyMissingError';\n  }\n}\n\n/**\n * Claude Code check provider using the Claude Code TypeScript SDK\n * Supports MCP tools and streaming responses\n */\nexport class ClaudeCodeCheckProvider extends CheckProvider {\n  private liquidEngine: Liquid;\n  private claudeCodeClient: ClaudeCodeClient | null = null;\n\n  constructor() {\n    super();\n    this.liquidEngine = createExtendedLiquid();\n  }\n\n  getName(): string {\n    return 'claude-code';\n  }\n\n  getDescription(): string {\n    return 'AI-powered code review using Claude Code with MCP tools support';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'claude-code'\n    if (cfg.type !== 'claude-code') {\n      return false;\n    }\n\n    // Check for prompt\n    if (!cfg.prompt || typeof cfg.prompt !== 'string') {\n      return false;\n    }\n\n    // Validate Claude Code specific configuration\n    if (cfg.claude_code) {\n      const claudeCodeConfig = cfg.claude_code as ClaudeCodeConfig;\n\n      // Validate allowedTools if present\n      if (claudeCodeConfig.allowedTools && !Array.isArray(claudeCodeConfig.allowedTools)) {\n        return false;\n      }\n\n      // Validate maxTurns if present\n      if (claudeCodeConfig.maxTurns && typeof claudeCodeConfig.maxTurns !== 'number') {\n        return false;\n      }\n\n      // Validate systemPrompt if present\n      if (claudeCodeConfig.systemPrompt && typeof claudeCodeConfig.systemPrompt !== 'string') {\n        return false;\n      }\n\n      // Validate mcpServers if present\n      if (claudeCodeConfig.mcpServers) {\n        if (typeof claudeCodeConfig.mcpServers !== 'object') {\n          return false;\n        }\n\n        for (const serverConfig of Object.values(claudeCodeConfig.mcpServers)) {\n          if (!serverConfig.command || typeof serverConfig.command !== 'string') {\n            return false;\n          }\n          if (serverConfig.args && !Array.isArray(serverConfig.args)) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Initialize Claude Code SDK client\n   */\n  private async initializeClaudeCodeClient(): Promise<ClaudeCodeClient> {\n    if (this.claudeCodeClient) {\n      return this.claudeCodeClient;\n    }\n\n    // Use safe import to avoid TypeScript compilation errors\n    const claudeCodeModule = await safeImport<{\n      ClaudeCode?: unknown;\n      default?: { ClaudeCode?: unknown };\n    }>('@anthropic/claude-code-sdk');\n\n    if (!claudeCodeModule) {\n      throw new ClaudeCodeSDKNotInstalledError();\n    }\n\n    const ClaudeCodeCtor = claudeCodeModule.ClaudeCode || claudeCodeModule.default?.ClaudeCode;\n\n    if (!isClaudeCodeConstructor(ClaudeCodeCtor)) {\n      throw new Error('ClaudeCode class not found in @anthropic/claude-code-sdk');\n    }\n\n    // Initialize with API key from environment\n    const apiKey = process.env.CLAUDE_CODE_API_KEY || process.env.ANTHROPIC_API_KEY;\n    if (!apiKey) {\n      throw new ClaudeCodeAPIKeyMissingError();\n    }\n\n    try {\n      const client = new ClaudeCodeCtor({\n        apiKey,\n      }) as ClaudeCodeClient;\n\n      this.claudeCodeClient = client;\n      return client;\n    } catch (error) {\n      throw new Error(\n        `Failed to initialize Claude Code SDK: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Group files by their file extension for template context\n   */\n  private groupFilesByExtension(\n    files: import('../pr-analyzer').PRFile[]\n  ): Record<string, import('../pr-analyzer').PRFile[]> {\n    const grouped: Record<string, import('../pr-analyzer').PRFile[]> = {};\n\n    files.forEach(file => {\n      const parts = file.filename.split('.');\n      const ext = parts.length > 1 ? parts.pop()?.toLowerCase() || 'noext' : 'noext';\n      if (!grouped[ext]) {\n        grouped[ext] = [];\n      }\n      grouped[ext].push(file);\n    });\n\n    return grouped;\n  }\n\n  /**\n   * Process prompt configuration to resolve final prompt string\n   */\n  private async processPrompt(\n    promptConfig: string,\n    prInfo: PRInfo,\n    eventContext?: Record<string, unknown>,\n    dependencyResults?: Map<string, ReviewSummary>\n  ): Promise<string> {\n    let promptContent: string;\n\n    // Auto-detect if it's a file path or inline content\n    if (await this.isFilePath(promptConfig)) {\n      promptContent = await this.loadPromptFromFile(promptConfig);\n    } else {\n      promptContent = promptConfig;\n    }\n\n    // Process Liquid templates in the prompt\n    return await this.renderPromptTemplate(promptContent, prInfo, eventContext, dependencyResults);\n  }\n\n  /**\n   * Detect if a string is likely a file path and if the file exists\n   */\n  private async isFilePath(str: string): Promise<boolean> {\n    // Quick checks to exclude obvious non-file-path content\n    if (!str || str.trim() !== str || str.length > 512) {\n      return false;\n    }\n\n    // Exclude strings that are clearly content (contain common content indicators)\n    if (\n      /\\s{2,}/.test(str) || // Multiple consecutive spaces\n      /\\n/.test(str) || // Contains newlines\n      /^(please|analyze|review|check|find|identify|look|search)/i.test(str.trim()) || // Starts with command words\n      str.split(' ').length > 8 // Too many words for a typical file path\n    ) {\n      return false;\n    }\n\n    // For strings with path separators, be more lenient about common words\n    if (!/[\\/\\\\]/.test(str)) {\n      // Only apply strict English word filter to non-path strings\n      if (/\\b(the|and|or|but|for|with|by|from|in|on|at|as)\\b/i.test(str)) {\n        return false;\n      }\n    }\n\n    // Positive indicators for file paths\n    const hasFileExtension = /\\.[a-zA-Z0-9]{1,10}$/i.test(str);\n    const hasPathSeparators = /[\\/\\\\]/.test(str);\n    const isRelativePath = /^\\.{1,2}\\//.test(str);\n    const isAbsolutePath = path.isAbsolute(str);\n    const hasTypicalFileChars = /^[a-zA-Z0-9._\\-\\/\\\\:~]+$/.test(str);\n\n    // Must have at least one strong indicator\n    if (!(hasFileExtension || isRelativePath || isAbsolutePath || hasPathSeparators)) {\n      return false;\n    }\n\n    // Must contain only typical file path characters\n    if (!hasTypicalFileChars) {\n      return false;\n    }\n\n    // Additional validation for suspected file paths\n    try {\n      // Try to resolve and check if file exists\n      let resolvedPath: string;\n\n      if (path.isAbsolute(str)) {\n        resolvedPath = path.normalize(str);\n      } else {\n        // Resolve relative to current working directory\n        resolvedPath = path.resolve(process.cwd(), str);\n      }\n\n      // Check if file exists\n      try {\n        const stat = await fs.stat(resolvedPath);\n        return stat.isFile();\n      } catch {\n        // File doesn't exist, but might still be a valid file path format\n        return hasFileExtension && (isRelativePath || isAbsolutePath || hasPathSeparators);\n      }\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Load prompt content from file with security validation\n   */\n  private async loadPromptFromFile(promptPath: string): Promise<string> {\n    // Enforce .liquid file extension for all prompt files\n    if (!promptPath.endsWith('.liquid')) {\n      throw new Error('Prompt file must have .liquid extension');\n    }\n\n    let resolvedPath: string;\n\n    if (path.isAbsolute(promptPath)) {\n      // Absolute path - use as-is\n      resolvedPath = promptPath;\n    } else {\n      // Relative path - resolve relative to current working directory\n      resolvedPath = path.resolve(process.cwd(), promptPath);\n    }\n\n    // Security: For relative paths, ensure they don't escape the current directory\n    if (!path.isAbsolute(promptPath)) {\n      const normalizedPath = path.normalize(resolvedPath);\n      const currentDir = path.resolve(process.cwd());\n      if (!normalizedPath.startsWith(currentDir)) {\n        throw new Error('Invalid prompt file path: path traversal detected');\n      }\n    }\n\n    // Security: Check for obvious path traversal patterns\n    if (promptPath.includes('../..')) {\n      throw new Error('Invalid prompt file path: path traversal detected');\n    }\n\n    try {\n      const promptContent = await fs.readFile(resolvedPath, 'utf-8');\n      return promptContent;\n    } catch (error) {\n      throw new Error(\n        `Failed to load prompt from ${resolvedPath}: ${\n          error instanceof Error ? error.message : 'Unknown error'\n        }`\n      );\n    }\n  }\n\n  /**\n   * Render Liquid template in prompt with comprehensive context\n   */\n  private async renderPromptTemplate(\n    promptContent: string,\n    prInfo: PRInfo,\n    eventContext?: Record<string, unknown>,\n    dependencyResults?: Map<string, ReviewSummary>\n  ): Promise<string> {\n    // Create comprehensive template context with PR and event information\n    const templateContext = {\n      // PR Information\n      pr: {\n        number: prInfo.number,\n        title: prInfo.title,\n        body: prInfo.body,\n        author: prInfo.author,\n        baseBranch: prInfo.base,\n        headBranch: prInfo.head,\n        isIncremental: prInfo.isIncremental,\n        filesChanged: prInfo.files?.map(f => f.filename) || [],\n        totalAdditions: prInfo.files?.reduce((sum, f) => sum + f.additions, 0) || 0,\n        totalDeletions: prInfo.files?.reduce((sum, f) => sum + f.deletions, 0) || 0,\n        totalChanges: prInfo.files?.reduce((sum, f) => sum + f.changes, 0) || 0,\n        base: prInfo.base,\n        head: prInfo.head,\n      },\n\n      // File Details\n      files: prInfo.files || [],\n      description: prInfo.body || '',\n\n      // GitHub Event Context\n      event: eventContext\n        ? {\n            name: eventContext.event_name || 'unknown',\n            action: eventContext.action,\n            isPullRequest: !prInfo.isIssue,\n\n            // Repository Info\n            repository: eventContext.repository\n              ? {\n                  owner: (eventContext.repository as { owner?: { login?: string } })?.owner?.login,\n                  name: (eventContext.repository as { name?: string })?.name,\n                  fullName: eventContext.repository\n                    ? `${(eventContext.repository as { owner?: { login?: string } })?.owner?.login}/${(eventContext.repository as { name?: string })?.name}`\n                    : undefined,\n                }\n              : undefined,\n\n            // Comment Data (for comment events)\n            comment: eventContext.comment\n              ? {\n                  body: (eventContext.comment as { body?: string })?.body,\n                  author: (eventContext.comment as { user?: { login?: string } })?.user?.login,\n                }\n              : undefined,\n\n            // Raw event payload for advanced use cases\n            payload: eventContext,\n          }\n        : undefined,\n\n      // Utility data for templates\n      utils: {\n        // Date/time helpers\n        now: new Date().toISOString(),\n        today: new Date().toISOString().split('T')[0],\n\n        // Dynamic file grouping by extension\n        filesByExtension: this.groupFilesByExtension(prInfo.files || []),\n\n        // File status categorizations\n        addedFiles: (prInfo.files || []).filter(f => f.status === 'added'),\n        modifiedFiles: (prInfo.files || []).filter(f => f.status === 'modified'),\n        removedFiles: (prInfo.files || []).filter(f => f.status === 'removed'),\n        renamedFiles: (prInfo.files || []).filter(f => f.status === 'renamed'),\n\n        // Change analysis\n        hasLargeChanges: (prInfo.files || []).some(f => f.changes > 50),\n        totalFiles: (prInfo.files || []).length,\n      },\n\n      // Previous check outputs (dependency results)\n      // Expose raw output directly if available, otherwise expose the result as-is\n      outputs: dependencyResults\n        ? Object.fromEntries(\n            Array.from(dependencyResults.entries()).map(([checkName, result]) => [\n              checkName,\n              // If the result has a direct output field, use it directly\n              // Otherwise, expose the entire result\n              (() => {\n                const summary = result as ReviewSummary & { output?: unknown };\n                return summary.output !== undefined ? summary.output : summary;\n              })(),\n            ])\n          )\n        : {},\n    };\n\n    try {\n      return await this.liquidEngine.parseAndRender(promptContent, templateContext);\n    } catch (error) {\n      throw new Error(\n        `Failed to render prompt template: ${\n          error instanceof Error ? error.message : 'Unknown error'\n        }`\n      );\n    }\n  }\n\n  /**\n   * Parse structured response from Claude Code\n   */\n  private parseStructuredResponse(content: string): ReviewSummary {\n    try {\n      // Try to parse as JSON first\n      const parsed = JSON.parse(content);\n\n      // Convert to ReviewSummary format\n      return {\n        issues: parsed.issues || [],\n      };\n    } catch {\n      // If not JSON, treat as plain text comment\n      return {\n        issues: [],\n      };\n    }\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    sessionInfo?: { parentSessionId?: string; reuseSession?: boolean }\n  ): Promise<ReviewSummary> {\n    // Apply environment configuration if present\n    if (config.env) {\n      const result = EnvironmentResolver.withTemporaryEnv(config.env, () => {\n        return this.executeWithConfig(prInfo, config, dependencyResults, sessionInfo);\n      });\n\n      if (result instanceof Promise) {\n        return result;\n      }\n      return result;\n    }\n\n    return this.executeWithConfig(prInfo, config, dependencyResults, sessionInfo);\n  }\n\n  private async executeWithConfig(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    sessionInfo?: { parentSessionId?: string; reuseSession?: boolean }\n  ): Promise<ReviewSummary> {\n    // Extract Claude Code configuration\n    const claudeCodeConfig = (config.claude_code as ClaudeCodeConfig) || {};\n\n    // Get custom prompt from config - REQUIRED\n    const customPrompt = config.prompt;\n    if (!customPrompt) {\n      throw new Error(\n        `No prompt defined for check. All checks must have prompts defined in .visor.yaml configuration.`\n      );\n    }\n\n    // Process prompt with Liquid templates and file loading\n    const processedPrompt = await this.processPrompt(\n      customPrompt,\n      prInfo,\n      config.eventContext,\n      dependencyResults\n    );\n\n    const startTime = Date.now();\n\n    try {\n      // Initialize Claude Code client\n      const client = await this.initializeClaudeCodeClient();\n\n      // Prepare query object with MCP servers passed directly to SDK\n      const query: ClaudeCodeQuery = {\n        query: processedPrompt,\n        maxTurns: claudeCodeConfig.maxTurns || 5,\n        systemPrompt: claudeCodeConfig.systemPrompt,\n        subagent: claudeCodeConfig.subagent,\n      };\n\n      // Add allowed tools if specified\n      if (claudeCodeConfig.allowedTools && claudeCodeConfig.allowedTools.length > 0) {\n        query.tools = claudeCodeConfig.allowedTools.map(name => ({ name }));\n      }\n\n      // Pass MCP servers directly to the SDK - let it handle spawning and tool discovery\n      if (claudeCodeConfig.mcpServers && Object.keys(claudeCodeConfig.mcpServers).length > 0) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (query as any).mcpServers = claudeCodeConfig.mcpServers;\n      }\n\n      // Execute query with Claude Code\n      let response: ClaudeCodeResponse;\n\n      if (sessionInfo?.reuseSession && sessionInfo.parentSessionId) {\n        // Use session reuse if available\n        response = await client.query({\n          ...query,\n          sessionId: sessionInfo.parentSessionId,\n        });\n      } else {\n        // Create new session\n        response = await client.query(query);\n      }\n\n      // Parse the response\n      const result = this.parseStructuredResponse(response.content) as ReviewSummary & {\n        debug?: import('../ai-review-service').AIDebugInfo & {\n          sessionId?: string;\n          turnCount?: number;\n          usage?: unknown;\n          toolsUsed?: string[];\n        };\n      };\n\n      result.debug = {\n        prompt: processedPrompt,\n        rawResponse: response.content,\n        provider: 'claude-code',\n        model: 'claude-code',\n        apiKeySource: 'CLAUDE_CODE_API_KEY',\n        processingTime: Date.now() - startTime,\n        promptLength: processedPrompt.length,\n        responseLength: response.content.length,\n        jsonParseSuccess: true,\n        errors: [],\n        checksExecuted: [config.checkName || 'claude-code-check'],\n        parallelExecution: false,\n        timestamp: new Date().toISOString(),\n        // Claude Code specific debug info\n        sessionId: response.session_id,\n        turnCount: response.turn_count,\n        usage: response.usage,\n      };\n\n      // Apply issue suppression filtering\n      const suppressionEnabled = config.suppressionEnabled !== false;\n      const issueFilter = new IssueFilter(suppressionEnabled);\n      const filteredIssues = issueFilter.filterIssues(result.issues || [], process.cwd());\n\n      return {\n        ...result,\n        issues: filteredIssues,\n      };\n    } catch (error) {\n      // Re-throw setup/configuration errors that should terminate the application\n      if (\n        error instanceof ClaudeCodeSDKNotInstalledError ||\n        error instanceof ClaudeCodeAPIKeyMissingError\n      ) {\n        throw error;\n      }\n\n      const errorMessage = error instanceof Error ? error.message : String(error);\n\n      // Log detailed error information\n      console.error(`‚ùå Claude Code Check Provider Error: ${errorMessage}`);\n\n      // Check if this is a critical error\n      const isCriticalError =\n        errorMessage.includes('API rate limit') ||\n        errorMessage.includes('403') ||\n        errorMessage.includes('401') ||\n        errorMessage.includes('authentication');\n\n      if (isCriticalError) {\n        console.error(\n          `üö® CRITICAL ERROR: Claude Code provider authentication or setup issue detected`\n        );\n        console.error(\n          `üö® This check cannot proceed without valid API credentials and SDK installation`\n        );\n      }\n\n      // Re-throw with more context\n      throw new Error(`Claude Code analysis failed: ${errorMessage}`);\n    }\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'prompt',\n      'claude_code.allowedTools',\n      'claude_code.maxTurns',\n      'claude_code.systemPrompt',\n      'claude_code.mcpServers',\n      'claude_code.subagent',\n      'claude_code.hooks',\n      'env',\n      'checkName',\n      'sessionId',\n      'suppressionEnabled',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    try {\n      // Check if Claude Code API key is available\n      const hasApiKey = !!(process.env.CLAUDE_CODE_API_KEY || process.env.ANTHROPIC_API_KEY);\n\n      if (!hasApiKey) {\n        return false;\n      }\n\n      // Try to import the SDK to check if it's installed\n      const claudeCodeModule = await safeImport<{\n        ClaudeCode?: unknown;\n        default?: { ClaudeCode?: unknown };\n      }>('@anthropic/claude-code-sdk');\n      if (!claudeCodeModule) {\n        return false;\n      }\n      const ClaudeCode = claudeCodeModule.ClaudeCode || claudeCodeModule.default?.ClaudeCode;\n\n      return !!ClaudeCode;\n    } catch {\n      // If import fails, the SDK is not installed\n      return false;\n    }\n  }\n\n  getRequirements(): string[] {\n    return [\n      'CLAUDE_CODE_API_KEY or ANTHROPIC_API_KEY environment variable',\n      '@anthropic/claude-code-sdk npm package',\n      '@modelcontextprotocol/sdk npm package (for MCP support)',\n      'Network access to Claude Code API',\n    ];\n  }\n}\n","import { exec } from 'child_process';\nimport { promisify } from 'util';\nimport { logger } from '../logger';\n\nexport interface CommandExecutionOptions {\n  stdin?: string;\n  cwd?: string;\n  env?: Record<string, string>;\n  timeout?: number;\n}\n\nexport interface CommandExecutionResult {\n  stdout: string;\n  stderr: string;\n  exitCode: number;\n}\n\n/**\n * Shared utility for executing shell commands\n * Used by both CommandCheckProvider and CustomToolExecutor\n */\nexport class CommandExecutor {\n  private static instance: CommandExecutor;\n\n  private constructor() {}\n\n  static getInstance(): CommandExecutor {\n    if (!CommandExecutor.instance) {\n      CommandExecutor.instance = new CommandExecutor();\n    }\n    return CommandExecutor.instance;\n  }\n\n  /**\n   * Execute a shell command with optional stdin, environment, and timeout\n   */\n  async execute(\n    command: string,\n    options: CommandExecutionOptions = {}\n  ): Promise<CommandExecutionResult> {\n    const execAsync = promisify(exec);\n    const timeout = options.timeout || 30000;\n\n    // If stdin is provided, we need to handle it differently\n    if (options.stdin) {\n      return this.executeWithStdin(command, options);\n    }\n\n    // For commands without stdin, use the simpler promisified version\n    try {\n      const result = await execAsync(command, {\n        cwd: options.cwd,\n        env: options.env as NodeJS.ProcessEnv,\n        timeout,\n      });\n\n      return {\n        stdout: result.stdout || '',\n        stderr: result.stderr || '',\n        exitCode: 0,\n      };\n    } catch (error) {\n      return this.handleExecutionError(error, timeout);\n    }\n  }\n\n  /**\n   * Execute command with stdin input\n   */\n  private executeWithStdin(\n    command: string,\n    options: CommandExecutionOptions\n  ): Promise<CommandExecutionResult> {\n    return new Promise((resolve, reject) => {\n      const childProcess = exec(\n        command,\n        {\n          cwd: options.cwd,\n          env: options.env as NodeJS.ProcessEnv,\n          timeout: options.timeout || 30000,\n        },\n        (error, stdout, stderr) => {\n          // Check if the process was killed due to timeout\n          if (\n            error &&\n            error.killed &&\n            ((error as NodeJS.ErrnoException).code === 'ETIMEDOUT' || error.signal === 'SIGTERM')\n          ) {\n            reject(new Error(`Command timed out after ${options.timeout || 30000}ms`));\n          } else {\n            resolve({\n              stdout: stdout || '',\n              stderr: stderr || '',\n              exitCode: error ? error.code || 1 : 0,\n            });\n          }\n        }\n      );\n\n      // Write stdin and close\n      if (options.stdin && childProcess.stdin) {\n        childProcess.stdin.write(options.stdin);\n        childProcess.stdin.end();\n      }\n    });\n  }\n\n  /**\n   * Handle execution errors consistently\n   */\n  private handleExecutionError(error: unknown, timeout: number): CommandExecutionResult {\n    const execError = error as NodeJS.ErrnoException & {\n      stdout?: string;\n      stderr?: string;\n      killed?: boolean;\n      code?: string | number;\n      signal?: string;\n    };\n\n    // Check if the process was killed due to timeout\n    // Node.js sets killed: true and signal: 'SIGTERM' when timeout expires\n    if (execError.killed && (execError.code === 'ETIMEDOUT' || execError.signal === 'SIGTERM')) {\n      throw new Error(`Command timed out after ${timeout}ms`);\n    }\n\n    // Extract exit code - it might be a string or number\n    let exitCode = 1;\n    if (execError.code) {\n      exitCode = typeof execError.code === 'string' ? parseInt(execError.code, 10) : execError.code;\n    }\n\n    return {\n      stdout: execError.stdout || '',\n      stderr: execError.stderr || '',\n      exitCode,\n    };\n  }\n\n  /**\n   * Build safe environment variables by merging process.env with custom env\n   * Ensures all values are strings (no undefined)\n   */\n  buildEnvironment(\n    baseEnv: NodeJS.ProcessEnv = process.env,\n    ...customEnvs: Array<Record<string, string> | undefined>\n  ): Record<string, string> {\n    const result: Record<string, string> = {};\n\n    // Start with base environment, filtering out undefined values\n    for (const [key, value] of Object.entries(baseEnv)) {\n      if (value !== undefined) {\n        result[key] = value;\n      }\n    }\n\n    // Merge custom environments\n    for (const customEnv of customEnvs) {\n      if (customEnv) {\n        Object.assign(result, customEnv);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Log command execution for debugging\n   */\n  logExecution(command: string, options: CommandExecutionOptions): void {\n    const debugInfo = [\n      `Executing command: ${command}`,\n      options.cwd ? `cwd: ${options.cwd}` : null,\n      options.stdin ? 'with stdin' : null,\n      options.timeout ? `timeout: ${options.timeout}ms` : null,\n      options.env ? `env vars: ${Object.keys(options.env).length}` : null,\n    ]\n      .filter(Boolean)\n      .join(', ');\n\n    logger.debug(debugInfo);\n  }\n}\n\n// Export singleton instance for convenience\nexport const commandExecutor = CommandExecutor.getInstance();\n","export type EnvMap = Record<string, string>;\n\n// Default: expose all env vars except a conservative denylist.\n// If VISOR_ALLOW_ENV is set and not '*', restrict to that allowlist.\n// VISOR_DENY_ENV can further mask exact keys or prefix* patterns.\nexport function buildSandboxEnv(input: NodeJS.ProcessEnv): EnvMap {\n  const denyDefaults = [\n    'GITHUB_TOKEN',\n    'INPUT_GITHUB-TOKEN',\n    'ACTIONS_RUNTIME_TOKEN',\n    'ACTIONS_ID_TOKEN_REQUEST_TOKEN',\n    'AWS_ACCESS_KEY_ID',\n    'AWS_SECRET_ACCESS_KEY',\n    'AWS_SESSION_TOKEN',\n    'AZURE_CLIENT_SECRET',\n    'GOOGLE_APPLICATION_CREDENTIALS',\n    'OPENAI_API_KEY',\n    'ANTHROPIC_API_KEY',\n    'HUGGINGFACE_API_KEY',\n    'CLAUDE_CODE_API_KEY',\n    'PROBE_API_KEY',\n  ];\n\n  const denyExtra = (input.VISOR_DENY_ENV || '')\n    .split(',')\n    .map(s => s.trim())\n    .filter(Boolean);\n  const deny = Array.from(new Set([...denyDefaults, ...denyExtra]));\n  const allowSpec = (input.VISOR_ALLOW_ENV || '*').trim();\n\n  const denyMatch = (key: string): boolean => {\n    for (const pat of deny) {\n      if (!pat) continue;\n      if (pat.endsWith('*')) {\n        const prefix = pat.slice(0, -1);\n        if (key.startsWith(prefix)) return true;\n      } else if (key === pat) {\n        return true;\n      }\n    }\n    if (/(_TOKEN|_SECRET|_PASSWORD|_PRIVATE_KEY)$/i.test(key)) return true;\n    return false;\n  };\n\n  const out: EnvMap = {};\n  if (allowSpec !== '*') {\n    const allow = allowSpec\n      .split(',')\n      .map(s => s.trim())\n      .filter(Boolean);\n    for (const key of allow) {\n      const val = input[key];\n      if (key && val !== undefined && !denyMatch(key)) out[key] = String(val);\n    }\n    return out;\n  }\n\n  for (const [k, v] of Object.entries(input)) {\n    if (v === undefined || v === null) continue;\n    if (denyMatch(k)) continue;\n    out[k] = String(v);\n  }\n  return out;\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary, ReviewIssue } from '../reviewer';\nimport { Liquid } from 'liquidjs';\nimport Sandbox from '@nyariv/sandboxjs';\nimport { createSecureSandbox, compileAndRun } from '../utils/sandbox';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { logger } from '../logger';\nimport { commandExecutor } from '../utils/command-executor';\nimport {\n  createPermissionHelpers,\n  detectLocalMode,\n  resolveAssociationFromEvent,\n} from '../utils/author-permissions';\nimport { trace, context as otContext } from '../telemetry/lazy-otel';\nimport {\n  captureCheckInputContext,\n  captureCheckOutput,\n  captureTransformJS,\n} from '../telemetry/state-capture';\n\n/**\n * Check provider that executes shell commands and captures their output\n * Supports JSON parsing and integration with forEach functionality\n */\nexport class CommandCheckProvider extends CheckProvider {\n  private liquid: Liquid;\n  private sandbox?: Sandbox;\n\n  constructor() {\n    super();\n    this.liquid = createExtendedLiquid({\n      cache: false,\n      strictFilters: false,\n      strictVariables: false,\n    });\n    // Lazily create sandbox only when transform_js is used\n  }\n\n  private createSecureSandbox(): Sandbox {\n    return createSecureSandbox();\n  }\n\n  getName(): string {\n    return 'command';\n  }\n\n  getDescription(): string {\n    return 'Execute shell commands and capture output for processing';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Must have exec specified\n    if (!cfg.exec || typeof cfg.exec !== 'string') {\n      return false;\n    }\n\n    return true;\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    context?: import('./check-provider.interface').ExecutionContext\n  ): Promise<ReviewSummary> {\n    try {\n      logger.info(\n        `  command provider: executing check=${String((config as any).checkName || config.type)} hasTransformJs=${Boolean(\n          (config as any).transform_js\n        )}`\n      );\n    } catch {}\n    const command = config.exec as string;\n    const transform = config.transform as string | undefined;\n    const transformJs = config.transform_js as string | undefined;\n\n    // Prepare template context for Liquid rendering\n    const outputsObj = this.buildOutputContext(\n      dependencyResults,\n      config.__outputHistory as Map<string, unknown[]> | undefined\n    );\n\n    // Build outputs_raw from -raw keys in dependencyResults\n    const outputsRaw: Record<string, unknown> = {};\n    if (dependencyResults) {\n      for (const [key, value] of dependencyResults.entries()) {\n        if (typeof key !== 'string') continue;\n        if (key.endsWith('-raw')) {\n          const name = key.slice(0, -4);\n          const summary = value as ReviewSummary & { output?: unknown };\n          outputsRaw[name] = summary.output !== undefined ? summary.output : summary;\n        }\n      }\n    }\n\n    const templateContext = {\n      pr: {\n        number: prInfo.number,\n        title: prInfo.title,\n        author: prInfo.author,\n        branch: prInfo.head,\n        base: prInfo.base,\n      },\n      files: prInfo.files,\n      fileCount: prInfo.files.length,\n      outputs: outputsObj,\n      // Alias: outputs_history mirrors outputs.history for consistency\n      outputs_history: (outputsObj as any).history || {},\n      // Stage-scoped history slice based on baseline provided by runner\n      outputs_history_stage: (() => {\n        const stage: Record<string, unknown[]> = {};\n        try {\n          const base = (context as any)?.stageHistoryBase as Record<string, number> | undefined;\n          const histMap = (config as any).__outputHistory as Map<string, unknown[]> | undefined;\n          if (!base || !histMap) return stage;\n          for (const [k, v] of histMap.entries()) {\n            const start = base[k] || 0;\n            const arr = Array.isArray(v) ? (v as unknown[]) : [];\n            stage[k] = arr.slice(start);\n          }\n        } catch {}\n        return stage;\n      })(),\n      // New: outputs_raw exposes aggregate values (e.g., full arrays for forEach parents)\n      outputs_raw: outputsRaw,\n      // Workflow inputs (when executing within a workflow)\n      inputs: context?.workflowInputs || {},\n      env: this.getSafeEnvironmentVariables(),\n    };\n\n    logger.debug(\n      `üîß Debug: Template outputs keys: ${Object.keys(templateContext.outputs || {}).join(', ')}`\n    );\n\n    // Capture input context in active OTEL span\n    try {\n      const span = trace.getSpan(otContext.active());\n      if (span) {\n        captureCheckInputContext(span, templateContext);\n      }\n    } catch {\n      // Ignore telemetry errors\n    }\n    // Fallback NDJSON for input context (non-OTEL environments)\n    try {\n      const checkId = (config as any).checkName || (config as any).id || 'unknown';\n      const ctxJson = JSON.stringify(templateContext);\n      const { emitNdjsonSpanWithEvents } = require('../telemetry/fallback-ndjson');\n      // Emit both start and completion markers together for deterministic E2E assertions\n      emitNdjsonSpanWithEvents(\n        'visor.check',\n        { 'visor.check.id': checkId, 'visor.check.input.context': ctxJson },\n        [{ name: 'check.started' }, { name: 'check.completed' }]\n      );\n    } catch {}\n\n    // Test hook: mock output for this step (short-circuit execution)\n    try {\n      const stepName = (config as any).checkName || 'unknown';\n      const rawMock = context?.hooks?.mockForStep?.(String(stepName));\n      if (rawMock !== undefined) {\n        // Normalize primitive mocks into object form\n        let mock: any;\n        if (typeof rawMock === 'number') {\n          mock = { exit_code: Number(rawMock) };\n        } else if (typeof rawMock === 'string') {\n          mock = { stdout: String(rawMock) };\n        } else {\n          mock = rawMock as Record<string, unknown>;\n        }\n        const m = mock as { stdout?: string; stderr?: string; exit_code?: number; exit?: number };\n        let out: unknown = m.stdout ?? '';\n        try {\n          if (\n            typeof out === 'string' &&\n            (out.trim().startsWith('{') || out.trim().startsWith('['))\n          ) {\n            out = JSON.parse(out);\n          }\n        } catch {}\n        const code =\n          typeof m.exit_code === 'number' ? m.exit_code : typeof m.exit === 'number' ? m.exit : 0;\n        if (code !== 0) {\n          return {\n            issues: [\n              {\n                file: 'command',\n                line: 0,\n                ruleId: 'command/execution_error',\n                message: `Mocked command exited with code ${code}`,\n                severity: 'error',\n                category: 'logic',\n              },\n            ],\n            output: out,\n          } as any;\n        }\n        return { issues: [], output: out } as any;\n      }\n    } catch {}\n\n    try {\n      // Render the command with Liquid templates if needed\n      let renderedCommand = command;\n      if (command.includes('{{') || command.includes('{%')) {\n        renderedCommand = await this.renderCommandTemplate(command, templateContext);\n      }\n      logger.debug(`üîß Debug: Rendered command: ${renderedCommand}`);\n\n      // Prepare environment variables - convert all to strings\n      const scriptEnv: Record<string, string> = {};\n      for (const [key, value] of Object.entries(process.env)) {\n        if (value !== undefined) {\n          scriptEnv[key] = value;\n        }\n      }\n      if (config.env) {\n        for (const [key, value] of Object.entries(config.env)) {\n          if (value !== undefined && value !== null) {\n            scriptEnv[key] = String(value);\n          }\n        }\n      }\n\n      // Get timeout from config (in seconds) or use default (60 seconds)\n      const timeoutSeconds = (config.timeout as number) || 60;\n      const timeoutMs = timeoutSeconds * 1000;\n\n      // Normalize only the eval payload for `node -e|--eval` invocations that may contain\n      // literal newlines due to YAML processing (\"\\n\" -> newline). We re-escape newlines\n      // inside the quoted eval argument to keep JS string literals valid, without touching\n      // the rest of the command.\n      const normalizeNodeEval = (cmd: string): string => {\n        const re =\n          /^(?<prefix>\\s*(?:\\/usr\\/bin\\/env\\s+)?node(?:\\.exe)?\\s+(?:-e|--eval)\\s+)(['\"])([\\s\\S]*?)\\2(?<suffix>\\s|$)/;\n        const m = cmd.match(re) as\n          | (RegExpMatchArray & { groups?: { prefix: string; suffix?: string } })\n          | null;\n        if (!m || !m.groups) return cmd;\n        const prefix = m.groups.prefix;\n        const quote = m[2];\n        const code = m[3];\n        const suffix = m.groups.suffix || '';\n        if (!code.includes('\\n')) return cmd;\n        const escaped = code.replace(/\\n/g, '\\\\n');\n        return cmd.replace(re, `${prefix}${quote}${escaped}${quote}${suffix}`);\n      };\n\n      const safeCommand = normalizeNodeEval(renderedCommand);\n\n      // Use shared command executor\n      const execResult = await commandExecutor.execute(safeCommand, {\n        env: scriptEnv,\n        timeout: timeoutMs,\n      });\n\n      const { stdout, stderr, exitCode } = execResult;\n\n      if (stderr) {\n        logger.debug(`Command stderr: ${stderr}`);\n      }\n\n      // Check for non-zero exit code\n      if (exitCode !== 0) {\n        const errorMessage = stderr || `Command exited with code ${exitCode}`;\n        logger.error(`Command failed with exit code ${exitCode}: ${errorMessage}`);\n        return {\n          issues: [\n            {\n              file: 'command',\n              line: 0,\n              ruleId: 'command/execution_error',\n              message: `Command execution failed: ${errorMessage}`,\n              severity: 'error',\n              category: 'logic',\n            },\n          ],\n        };\n      }\n\n      // Keep raw output for transforms\n      const rawOutput = stdout.trim();\n\n      // Try to parse output as JSON for default behavior\n      // no debug\n      let output: unknown = rawOutput;\n      try {\n        // Attempt to parse as JSON\n        const parsed = JSON.parse(rawOutput);\n        output = parsed;\n        logger.debug(`üîß Debug: Parsed entire output as JSON successfully`);\n      } catch {\n        // Try to extract JSON from the end of output (for commands with debug logs)\n        const extractedTail = this.extractJsonFromEnd(rawOutput);\n        if (extractedTail) {\n          try {\n            output = JSON.parse(extractedTail);\n          } catch {\n            output = rawOutput;\n          }\n        } else {\n          // Try to extract any balanced JSON substring anywhere\n          const extractedAny = this.extractJsonAnywhere(rawOutput);\n          if (extractedAny) {\n            try {\n              output = JSON.parse(extractedAny);\n            } catch {\n              output = rawOutput;\n            }\n          } else {\n            // Last resort: detect common boolean flags like error:true or error=false for fail_if gating\n            const m = /\\berror\\b\\s*[:=]\\s*(true|false)/i.exec(rawOutput);\n            if (m) {\n              output = { error: m[1].toLowerCase() === 'true' } as any;\n            } else {\n              output = rawOutput;\n            }\n          }\n        }\n      }\n\n      // Log the parsed structure for debugging\n      // no debug\n\n      // Apply transform if specified (Liquid or JavaScript)\n      let finalOutput = output;\n\n      // First apply Liquid transform if present\n      if (transform) {\n        try {\n          const transformContext = {\n            ...templateContext,\n            output: output, // Use parsed output for Liquid (object if JSON, string otherwise)\n          };\n          const rendered = await this.liquid.parseAndRender(transform, transformContext);\n\n          // Try to parse the transformed result as JSON\n          try {\n            finalOutput = JSON.parse(rendered.trim());\n            logger.verbose(`‚úì Applied Liquid transform successfully (parsed as JSON)`);\n          } catch {\n            finalOutput = rendered.trim();\n            logger.verbose(`‚úì Applied Liquid transform successfully (string output)`);\n          }\n\n          // Capture Liquid transform in telemetry\n          try {\n            const span = trace.getSpan(otContext.active());\n            if (span) {\n              const { captureLiquidEvaluation } = require('../telemetry/state-capture');\n              captureLiquidEvaluation(span, transform, transformContext, rendered);\n            }\n          } catch {\n            // Ignore telemetry errors\n          }\n        } catch (error) {\n          logger.error(\n            `‚úó Failed to apply Liquid transform: ${error instanceof Error ? error.message : 'Unknown error'}`\n          );\n          return {\n            issues: [\n              {\n                file: 'command',\n                line: 0,\n                ruleId: 'command/transform_error',\n                message: `Failed to apply Liquid transform: ${error instanceof Error ? error.message : 'Unknown error'}`,\n                severity: 'error',\n                category: 'logic',\n              },\n            ],\n          };\n        }\n      }\n\n      // Then apply JavaScript transform if present\n      if (transformJs) {\n        try {\n          // For transform_js, provide a JSON-smart wrapper that:\n          //  - behaves like a string when coerced (so JSON.parse(output) still works)\n          //  - exposes parsed JSON properties if stdout is valid JSON (so output.key works)\n          const jsContext = {\n            output: this.makeJsonSmart(rawOutput),\n            pr: templateContext.pr,\n            files: templateContext.files,\n            outputs: this.makeOutputsJsonSmart(templateContext.outputs),\n            inputs: templateContext.inputs || {},\n            env: templateContext.env,\n            permissions: createPermissionHelpers(\n              resolveAssociationFromEvent((prInfo as any).eventContext, prInfo.authorAssociation),\n              detectLocalMode()\n            ),\n          };\n\n          // Compile and execute the JavaScript expression\n          // Use direct property access instead of destructuring to avoid syntax issues\n          const trimmedTransform = transformJs.trim();\n          // Build a safe function body that supports statements + implicit last-expression return.\n          const buildBodyWithReturn = (raw: string): string => {\n            const t = raw.trim();\n            // Find last non-empty line\n            const lines = t.split(/\\n/);\n            let i = lines.length - 1;\n            while (i >= 0 && lines[i].trim().length === 0) i--;\n            if (i < 0) return 'return undefined;';\n            const lastLine = lines[i].trim();\n            if (/^return\\b/i.test(lastLine)) {\n              return t;\n            }\n            const idx = t.lastIndexOf(lastLine);\n            const head = idx >= 0 ? t.slice(0, idx) : '';\n            const lastExpr = lastLine.replace(/;\\s*$/, '');\n            return `${head}\\nreturn (${lastExpr});`;\n          };\n          const bodyWithReturn = buildBodyWithReturn(trimmedTransform);\n\n          const code = `\n            const output = scope.output;\n            const pr = scope.pr;\n            const files = scope.files;\n            const outputs = scope.outputs;\n            const inputs = scope.inputs;\n            const env = scope.env;\n            const log = (...args) => { console.log('üîç Debug:', ...args); };\n            const hasMinPermission = scope.permissions.hasMinPermission;\n            const isOwner = scope.permissions.isOwner;\n            const isMember = scope.permissions.isMember;\n            const isCollaborator = scope.permissions.isCollaborator;\n            const isContributor = scope.permissions.isContributor;\n            const isFirstTimer = scope.permissions.isFirstTimer;\n            const __result = (function(){\n${bodyWithReturn}\n            })();\n            return __result;\n          `;\n\n          // Execute user code exclusively inside the sandbox\n          if (!this.sandbox) {\n            this.sandbox = this.createSecureSandbox();\n          }\n          // Try to serialize result to JSON string inside sandbox to preserve primitives like booleans\n          let parsedFromSandboxJson: any = undefined;\n          try {\n            const stringifyCode = `\n              const output = scope.output;\n              const pr = scope.pr;\n              const files = scope.files;\n              const outputs = scope.outputs;\n              const env = scope.env;\n              const log = (...args) => { console.log('üîç Debug:', ...args); };\n              const hasMinPermission = scope.permissions.hasMinPermission;\n              const isOwner = scope.permissions.isOwner;\n              const isMember = scope.permissions.isMember;\n              const isCollaborator = scope.permissions.isCollaborator;\n              const isContributor = scope.permissions.isContributor;\n              const isFirstTimer = scope.permissions.isFirstTimer;\n              const __ret = (function(){\n${bodyWithReturn}\n              })();\n              return typeof __ret === 'object' && __ret !== null ? JSON.stringify(__ret) : null;\n            `;\n            const stringifyExec = this.sandbox.compile(stringifyCode);\n            const jsonStr = stringifyExec({ scope: jsContext }).run();\n            if (typeof jsonStr === 'string' && jsonStr.trim().startsWith('{')) {\n              parsedFromSandboxJson = JSON.parse(jsonStr);\n            }\n          } catch {}\n\n          if (parsedFromSandboxJson !== undefined) {\n            finalOutput = parsedFromSandboxJson;\n          } else {\n            finalOutput = compileAndRun<unknown>(\n              this.sandbox,\n              code,\n              { scope: jsContext },\n              { injectLog: false, wrapFunction: false }\n            );\n          }\n\n          // Fallback: if sandbox could not preserve primitives (e.g., booleans lost),\n          // attempt to re-evaluate the transform in a locked Node VM context to get plain JS values.\n          try {\n            if (\n              finalOutput &&\n              typeof finalOutput === 'object' &&\n              !Array.isArray(finalOutput) &&\n              ((finalOutput as any).error === undefined ||\n                (finalOutput as any).issues === undefined)\n            ) {\n              const vm = await import('node:vm');\n              const vmContext = vm.createContext({ scope: jsContext });\n              const vmCode = `\n                (function(){\n                  const output = scope.output; const pr = scope.pr; const files = scope.files; const outputs = scope.outputs; const env = scope.env; const log = ()=>{};\n${bodyWithReturn}\n                })()\n              `;\n              const vmResult = vm.runInContext(vmCode, vmContext, { timeout: 1000 });\n              if (vmResult && typeof vmResult === 'object') {\n                finalOutput = vmResult;\n              }\n            }\n          } catch {}\n          // Create a plain JSON snapshot of the transform result to avoid proxy/getter surprises\n          // Prefer JSON stringify inside the sandbox realm (so it knows how to serialize its own objects),\n          // then fall back to host-side JSON clone and finally to a shallow copy of own enumerable properties.\n          let finalSnapshot: Record<string, unknown> | null = null;\n          try {\n            if (finalOutput && typeof finalOutput === 'object' && !Array.isArray(finalOutput)) {\n              // Try realm-local stringify first\n              try {\n                const stringifyExec = this.sandbox!.compile('return JSON.stringify(scope.obj);');\n                const jsonStr = stringifyExec({ obj: finalOutput }).run();\n                if (typeof jsonStr === 'string' && jsonStr.trim().startsWith('{')) {\n                  finalSnapshot = JSON.parse(jsonStr);\n                }\n              } catch {}\n              if (!finalSnapshot) {\n                try {\n                  finalSnapshot = JSON.parse(JSON.stringify(finalOutput));\n                } catch {}\n              }\n              if (!finalSnapshot) {\n                const tmp: Record<string, unknown> = {};\n                for (const k of Object.keys(finalOutput as Record<string, unknown>)) {\n                  (tmp as any)[k] = (finalOutput as any)[k];\n                }\n                finalSnapshot = tmp;\n              }\n            }\n          } catch {}\n          // @ts-ignore store for later extraction path\n          (this as any).__lastTransformSnapshot = finalSnapshot;\n          try {\n            const isObj =\n              finalOutput && typeof finalOutput === 'object' && !Array.isArray(finalOutput);\n            const keys = isObj\n              ? Object.keys(finalOutput as Record<string, unknown>).join(',')\n              : typeof finalOutput;\n            logger.debug(\n              `  transform_js: output typeof=${Array.isArray(finalOutput) ? 'array' : typeof finalOutput} keys=${keys}`\n            );\n            if (isObj && (finalOutput as any).issues) {\n              const mi: any = (finalOutput as any).issues;\n              logger.debug(\n                `  transform_js: issues typeof=${Array.isArray(mi) ? 'array' : typeof mi} len=${(mi && mi.length) || 0}`\n              );\n            }\n            try {\n              if (isObj)\n                logger.debug(`  transform_js: error value=${String((finalOutput as any).error)}`);\n            } catch {}\n          } catch {}\n\n          logger.verbose(`‚úì Applied JavaScript transform successfully`);\n          // Already normalized in sandbox result\n          // no debug\n        } catch (error) {\n          logger.error(\n            `‚úó Failed to apply JavaScript transform: ${error instanceof Error ? error.message : 'Unknown error'}`\n          );\n          return {\n            issues: [\n              {\n                file: 'command',\n                line: 0,\n                ruleId: 'command/transform_js_error',\n                message: `Failed to apply JavaScript transform: ${error instanceof Error ? error.message : 'Unknown error'}`,\n                severity: 'error',\n                category: 'logic',\n              },\n            ],\n          };\n        }\n      }\n\n      // Extract structured issues when the command returns them (skip for forEach parents)\n      // no debug\n      let issues: ReviewIssue[] = [];\n      let outputForDependents: unknown = finalOutput;\n      // Capture a shallow snapshot created earlier if available (within transform_js path)\n      // @ts-ignore - finalSnapshot is defined in the transform_js scope above when applicable\n      // @ts-ignore retrieve snapshot captured after transform_js (if any)\n      const snapshotForExtraction: Record<string, unknown> | null =\n        (this as any).__lastTransformSnapshot || null;\n      try {\n        if (snapshotForExtraction) {\n          logger.debug(`  provider: snapshot keys=${Object.keys(snapshotForExtraction).join(',')}`);\n        } else {\n          logger.debug(`  provider: snapshot is null`);\n        }\n      } catch {}\n      // Some shells may wrap JSON output inside a one-element array due to quoting.\n      // If we see a single-element array containing a JSON string or object, unwrap it.\n      try {\n        if (Array.isArray(outputForDependents) && (outputForDependents as unknown[]).length === 1) {\n          const first = (outputForDependents as unknown[])[0];\n          if (typeof first === 'string') {\n            try {\n              outputForDependents = JSON.parse(first);\n            } catch {}\n          } else if (first && typeof first === 'object') {\n            outputForDependents = first as unknown;\n          }\n        }\n      } catch {}\n\n      let content: string | undefined;\n      let extracted: { issues: ReviewIssue[]; remainingOutput: unknown } | null = null;\n\n      const trimmedRawOutput = typeof rawOutput === 'string' ? rawOutput.trim() : undefined;\n\n      const commandConfig = config as CheckProviderConfig & { forEach?: boolean };\n      const isForEachParent = commandConfig.forEach === true;\n\n      if (!isForEachParent) {\n        // Generic: if transform output is an object and contains an 'issues' field,\n        // expose all other fields to dependents regardless of whether we successfully\n        // normalized the issues array. This preserves flags like 'error' for fail_if.\n        try {\n          const baseObj = (snapshotForExtraction || (finalOutput as any)) as Record<\n            string,\n            unknown\n          >;\n          if (\n            baseObj &&\n            typeof baseObj === 'object' &&\n            Object.prototype.hasOwnProperty.call(baseObj, 'issues')\n          ) {\n            const remaining = { ...baseObj } as Record<string, unknown>;\n            delete (remaining as any).issues;\n            outputForDependents = Object.keys(remaining).length > 0 ? remaining : undefined;\n            try {\n              const k =\n                outputForDependents && typeof outputForDependents === 'object'\n                  ? Object.keys(outputForDependents as any).join(',')\n                  : String(outputForDependents);\n              logger.debug(`  provider: generic-remaining keys=${k}`);\n            } catch {}\n          }\n        } catch {}\n        // Fast path for transform_js objects that include an issues array (realm-agnostic)\n        const objForExtraction = (snapshotForExtraction || (finalOutput as any)) as Record<\n          string,\n          unknown\n        >;\n        if (objForExtraction && typeof objForExtraction === 'object') {\n          try {\n            const rec = objForExtraction;\n            const maybeIssues: any = (rec as any).issues;\n            const toPlainArray = (v: any): any[] | null => {\n              if (Array.isArray(v)) return v;\n              try {\n                if (v && typeof v === 'object' && typeof v[Symbol.iterator] === 'function') {\n                  return Array.from(v);\n                }\n              } catch {}\n              const len = Number((v || {}).length);\n              if (Number.isFinite(len) && len >= 0) {\n                const arr: any[] = [];\n                for (let i = 0; i < len; i++) arr.push(v[i]);\n                return arr;\n              }\n              try {\n                const cloned = JSON.parse(JSON.stringify(v));\n                return Array.isArray(cloned) ? cloned : null;\n              } catch {\n                return null;\n              }\n            };\n            try {\n              const ctor =\n                maybeIssues && (maybeIssues as any).constructor\n                  ? (maybeIssues as any).constructor.name\n                  : 'unknown';\n              logger.debug(\n                `  provider: issues inspect typeof=${typeof maybeIssues} Array.isArray=${Array.isArray(\n                  maybeIssues\n                )} ctor=${ctor} keys=${Object.keys((maybeIssues || {}) as any).join(',')}`\n              );\n            } catch {}\n            const arr = toPlainArray(maybeIssues);\n            if (arr) {\n              const norm = this.normalizeIssueArray(arr);\n              if (norm) {\n                issues = norm;\n                const remaining = { ...rec } as Record<string, unknown>;\n                delete (remaining as any).issues;\n                outputForDependents = Object.keys(remaining).length > 0 ? remaining : undefined;\n                try {\n                  const keys =\n                    outputForDependents && typeof outputForDependents === 'object'\n                      ? Object.keys(outputForDependents as any).join(',')\n                      : String(outputForDependents);\n                  logger.info(\n                    `  provider: fast-path issues=${issues.length} remaining keys=${keys}`\n                  );\n                } catch {}\n              } else {\n                try {\n                  logger.info('  provider: fast-path norm failed');\n                } catch {}\n              }\n            } else {\n              try {\n                logger.info('  provider: fast-path arr unavailable');\n              } catch {}\n            }\n          } catch {}\n        }\n        // Normalize extraction target: unwrap one-element arrays like [\"{...}\"] or [{...}]\n        let extractionTarget: unknown = snapshotForExtraction || finalOutput;\n        try {\n          if (Array.isArray(extractionTarget) && (extractionTarget as unknown[]).length === 1) {\n            const first = (extractionTarget as unknown[])[0];\n            if (typeof first === 'string') {\n              try {\n                extractionTarget = JSON.parse(first);\n              } catch {\n                extractionTarget = first;\n              }\n            } else if (first && typeof first === 'object') {\n              extractionTarget = first as unknown;\n            }\n          }\n        } catch {}\n        extracted = this.extractIssuesFromOutput(extractionTarget);\n        try {\n          if (extractionTarget !== (snapshotForExtraction || finalOutput)) {\n            finalOutput = extractionTarget;\n          }\n        } catch {}\n        // no debug\n        // Handle cross-realm Arrays from sandbox: issues may look like an array but fail Array.isArray\n        if (!extracted && finalOutput && typeof finalOutput === 'object') {\n          try {\n            const rec = finalOutput as Record<string, unknown>;\n            const maybeIssues: any = (rec as any).issues;\n            if (maybeIssues && typeof maybeIssues === 'object') {\n              let arr: any[] | null = null;\n              // Prefer iterator if present\n              try {\n                if (typeof maybeIssues[Symbol.iterator] === 'function') {\n                  arr = Array.from(maybeIssues);\n                }\n              } catch {}\n              // Fallback to length-based copy\n              if (!arr) {\n                const len = Number((maybeIssues as any).length);\n                if (Number.isFinite(len) && len >= 0) {\n                  arr = [];\n                  for (let i = 0; i < len; i++) arr.push(maybeIssues[i]);\n                }\n              }\n              // Last resort: JSON clone\n              if (!arr) {\n                try {\n                  arr = JSON.parse(JSON.stringify(maybeIssues));\n                } catch {}\n              }\n              if (arr && Array.isArray(arr)) {\n                const norm = this.normalizeIssueArray(arr);\n                if (norm) {\n                  issues = norm;\n                  const remaining = { ...rec } as Record<string, unknown>;\n                  delete (remaining as any).issues;\n                  outputForDependents = Object.keys(remaining).length > 0 ? remaining : undefined;\n                }\n              }\n            }\n          } catch {}\n        }\n        if (!extracted && typeof finalOutput === 'string') {\n          // Attempt to parse string output as JSON and extract issues again\n          try {\n            const parsed = JSON.parse(finalOutput);\n            extracted = this.extractIssuesFromOutput(parsed);\n            if (extracted) {\n              issues = extracted.issues;\n              outputForDependents = extracted.remainingOutput;\n              // If remainingOutput carries a content field, pick it up\n              if (\n                typeof extracted.remainingOutput === 'object' &&\n                extracted.remainingOutput !== null &&\n                typeof (extracted.remainingOutput as any).content === 'string'\n              ) {\n                const c = String((extracted.remainingOutput as any).content).trim();\n                if (c) content = c;\n              }\n            }\n          } catch {\n            // Try to salvage JSON from anywhere within the string (stripped logs/ansi)\n            try {\n              const any = this.extractJsonAnywhere(finalOutput);\n              if (any) {\n                const parsed = JSON.parse(any);\n                extracted = this.extractIssuesFromOutput(parsed);\n                if (extracted) {\n                  issues = extracted.issues;\n                  outputForDependents = extracted.remainingOutput;\n                  if (\n                    typeof extracted.remainingOutput === 'object' &&\n                    extracted.remainingOutput !== null &&\n                    typeof (extracted.remainingOutput as any).content === 'string'\n                  ) {\n                    const c = String((extracted.remainingOutput as any).content).trim();\n                    if (c) content = c;\n                  }\n                }\n              }\n            } catch {\n              // leave as-is\n            }\n          }\n        } else if (extracted) {\n          issues = extracted.issues;\n          outputForDependents = extracted.remainingOutput;\n          // Also propagate embedded content when remainingOutput is an object { content, ... }\n          if (\n            typeof extracted.remainingOutput === 'object' &&\n            extracted.remainingOutput !== null &&\n            typeof (extracted.remainingOutput as any).content === 'string'\n          ) {\n            const c = String((extracted.remainingOutput as any).content).trim();\n            if (c) content = c;\n          }\n        }\n\n        if (!issues.length && this.shouldTreatAsTextOutput(trimmedRawOutput)) {\n          content = trimmedRawOutput;\n        } else if (issues.length && typeof extracted?.remainingOutput === 'string') {\n          const trimmed = extracted.remainingOutput.trim();\n          if (trimmed) {\n            content = trimmed;\n          }\n        }\n\n        // Generic fallback: if issues are still empty, try to parse raw stdout as JSON and extract issues.\n        if (!issues.length && typeof trimmedRawOutput === 'string') {\n          try {\n            const tryParsed = JSON.parse(trimmedRawOutput);\n            const reextract = this.extractIssuesFromOutput(tryParsed);\n            if (reextract && reextract.issues && reextract.issues.length) {\n              issues = reextract.issues;\n              if (!outputForDependents && reextract.remainingOutput) {\n                outputForDependents = reextract.remainingOutput;\n              }\n            } else if (Array.isArray(tryParsed)) {\n              // Treat parsed array as potential issues array or array of { issues: [...] }\n              const first = tryParsed[0];\n              if (first && typeof first === 'object' && Array.isArray((first as any).issues)) {\n                const merged: unknown[] = [];\n                for (const el of tryParsed as unknown[]) {\n                  if (el && typeof el === 'object' && Array.isArray((el as any).issues)) {\n                    merged.push(...((el as any).issues as unknown[]));\n                  }\n                }\n                const flat = this.normalizeIssueArray(merged);\n                if (flat) issues = flat;\n              } else {\n                // Try to parse string elements into JSON objects and extract\n                const converted: unknown[] = [];\n                for (const el of tryParsed as unknown[]) {\n                  if (typeof el === 'string') {\n                    try {\n                      const obj = JSON.parse(el);\n                      converted.push(obj);\n                    } catch {\n                      // keep as-is\n                    }\n                  } else {\n                    converted.push(el);\n                  }\n                }\n                const flat = this.normalizeIssueArray(converted as unknown[]);\n                if (flat) issues = flat;\n              }\n            }\n          } catch {}\n          if (!issues.length) {\n            try {\n              const any = this.extractJsonAnywhere(trimmedRawOutput);\n              if (any) {\n                const tryParsed = JSON.parse(any);\n                const reextract = this.extractIssuesFromOutput(tryParsed);\n                if (reextract && reextract.issues && reextract.issues.length) {\n                  issues = reextract.issues;\n                  if (!outputForDependents && reextract.remainingOutput) {\n                    outputForDependents = reextract.remainingOutput;\n                  }\n                }\n              }\n            } catch {}\n          }\n        }\n\n        // Preserve all primitive flags (boolean/number/string) from original transform output\n        try {\n          const srcObj = (snapshotForExtraction || (finalOutput as any)) as Record<string, unknown>;\n          if (\n            outputForDependents &&\n            typeof outputForDependents === 'object' &&\n            srcObj &&\n            typeof srcObj === 'object'\n          ) {\n            for (const k of Object.keys(srcObj)) {\n              const v: any = (srcObj as any)[k];\n              if (typeof v === 'boolean' || typeof v === 'number' || typeof v === 'string') {\n                (outputForDependents as any)[k] = v;\n              }\n            }\n          }\n        } catch {}\n\n        // Normalize output object to a plain shallow object (avoid JSON stringify drop of false booleans)\n        try {\n          if (\n            outputForDependents &&\n            typeof outputForDependents === 'object' &&\n            !Array.isArray(outputForDependents)\n          ) {\n            const plain: Record<string, unknown> = {};\n            for (const k of Object.keys(outputForDependents as any)) {\n              (plain as any)[k] = (outputForDependents as any)[k];\n            }\n            outputForDependents = plain;\n          }\n        } catch {}\n      }\n\n      if (!content && this.shouldTreatAsTextOutput(trimmedRawOutput) && !isForEachParent) {\n        content = trimmedRawOutput;\n      }\n\n      // Normalize output object to plain JSON to avoid cross-realm proxy quirks\n      try {\n        if (outputForDependents && typeof outputForDependents === 'object') {\n          outputForDependents = JSON.parse(JSON.stringify(outputForDependents));\n        }\n      } catch {}\n\n      // Promote primitive flags from original transform output to top-level result fields (schema-agnostic)\n      const promoted: Record<string, unknown> = {};\n      try {\n        const srcObj = (snapshotForExtraction || (finalOutput as any)) as Record<string, unknown>;\n        if (srcObj && typeof srcObj === 'object') {\n          for (const k of Object.keys(srcObj)) {\n            const v: any = (srcObj as any)[k];\n            if (typeof v === 'boolean') {\n              if (v === true && promoted[k] === undefined) promoted[k] = true;\n            } else if (\n              (typeof v === 'number' || typeof v === 'string') &&\n              promoted[k] === undefined\n            ) {\n              promoted[k] = v;\n            }\n          }\n        }\n      } catch {}\n\n      // Return the output and issues as part of the review summary so dependent checks can use them\n      const result = {\n        issues,\n        output: outputForDependents,\n        ...(content ? { content } : {}),\n        ...promoted,\n      } as ReviewSummary;\n\n      // Capture output and transform details in active OTEL span\n      try {\n        const span = trace.getSpan(otContext.active());\n        if (span) {\n          captureCheckOutput(span, outputForDependents);\n          if (transformJs && output !== finalOutput) {\n            captureTransformJS(span, transformJs, output, finalOutput);\n          }\n        }\n      } catch {\n        // Ignore telemetry errors\n      }\n      // Fallback NDJSON for output (non-OTEL environments)\n      try {\n        const checkId = (config as any).checkName || (config as any).id || 'unknown';\n        const outJson = JSON.stringify((result as any).output ?? result);\n        const { emitNdjsonSpanWithEvents } = require('../telemetry/fallback-ndjson');\n        emitNdjsonSpanWithEvents(\n          'visor.check',\n          { 'visor.check.id': checkId, 'visor.check.output': outJson },\n          [{ name: 'check.started' }, { name: 'check.completed' }]\n        );\n      } catch {}\n\n      // Attach raw transform object only when transform_js was used (avoid polluting plain command outputs)\n      try {\n        if (transformJs) {\n          const rawObj = (snapshotForExtraction || (finalOutput as any)) as Record<string, unknown>;\n          if (rawObj && typeof rawObj === 'object') {\n            (result as any).__raw = rawObj;\n          }\n        }\n      } catch {}\n\n      // Final safeguard: ensure primitive flags from original transform output are present in result.output.\n      // Do this without dropping explicit false values (important for fail_if like `output.error`).\n      try {\n        const srcObj = (snapshotForExtraction || (finalOutput as any)) as Record<string, unknown>;\n        const srcErr = ((): boolean | undefined => {\n          try {\n            if (\n              snapshotForExtraction &&\n              typeof snapshotForExtraction === 'object' &&\n              (snapshotForExtraction as any).error !== undefined\n            ) {\n              return Boolean((snapshotForExtraction as any).error);\n            }\n            if (\n              finalOutput &&\n              typeof finalOutput === 'object' &&\n              (finalOutput as any).error !== undefined\n            ) {\n              return Boolean((finalOutput as any).error);\n            }\n          } catch {}\n          return undefined;\n        })();\n        const dst = (result as any).output;\n        if (srcObj && typeof srcObj === 'object' && dst && typeof dst === 'object') {\n          try {\n            logger.debug(\n              `  provider: safeguard src.error typeof=${typeof (srcObj as any).error} val=${String((srcObj as any).error)} dst.hasErrorBefore=${String((dst as any).error !== undefined)}`\n            );\n          } catch {}\n          for (const k of Object.keys(srcObj)) {\n            const v: any = (srcObj as any)[k];\n            if (typeof v === 'boolean' || typeof v === 'number' || typeof v === 'string') {\n              (dst as any)[k] = v;\n            }\n          }\n          // Explicitly normalize a common flag used in tests/pipelines\n          if (srcErr !== undefined && (dst as any).error === undefined) {\n            (dst as any).error = srcErr;\n            try {\n              const k = Object.keys(dst as any).join(',');\n              logger.debug(\n                `  provider: safeguard merged error -> output keys=${k} val=${String((dst as any).error)}`\n              );\n            } catch {}\n          }\n        }\n      } catch {}\n\n      try {\n        const out: any = (result as any).output;\n        if (out && typeof out === 'object') {\n          const k = Object.keys(out as Record<string, unknown>).join(',');\n          logger.debug(`  provider: return output keys=${k}`);\n        } else {\n          logger.debug(`  provider: return output type=${typeof out}`);\n        }\n      } catch {}\n\n      // no debug\n\n      return result;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\n      // Check if this is a timeout error\n      let isTimeout = false;\n      if (error && typeof error === 'object') {\n        const execError = error as { killed?: boolean; signal?: string; code?: string | number };\n        // Node's child_process sets killed=true and signal='SIGTERM' on timeout\n        if (execError.killed && execError.signal === 'SIGTERM') {\n          isTimeout = true;\n        }\n        // Some versions may also set code to 'ETIMEDOUT'\n        if (execError.code === 'ETIMEDOUT') {\n          isTimeout = true;\n        }\n      }\n\n      // Extract stderr from the error if available (child_process errors include stdout/stderr)\n      let stderrOutput = '';\n      if (error && typeof error === 'object') {\n        const execError = error as { stderr?: string; stdout?: string };\n        if (execError.stderr) {\n          stderrOutput = execError.stderr.trim();\n        }\n      }\n\n      // Construct detailed error message\n      let detailedMessage: string;\n      let ruleId: string;\n\n      if (isTimeout) {\n        const timeoutSeconds = (config.timeout as number) || 60;\n        detailedMessage = `Command execution timed out after ${timeoutSeconds} seconds`;\n        if (stderrOutput) {\n          detailedMessage += `\\n\\nStderr output:\\n${stderrOutput}`;\n        }\n        ruleId = 'command/timeout';\n      } else {\n        detailedMessage = stderrOutput\n          ? `Command execution failed: ${errorMessage}\\n\\nStderr output:\\n${stderrOutput}`\n          : `Command execution failed: ${errorMessage}`;\n        ruleId = 'command/execution_error';\n      }\n\n      logger.error(`‚úó ${detailedMessage}`);\n\n      return {\n        issues: [\n          {\n            file: 'command',\n            line: 0,\n            ruleId,\n            message: detailedMessage,\n            severity: 'error',\n            category: 'logic',\n          },\n        ],\n      };\n    }\n  }\n\n  private buildOutputContext(\n    dependencyResults?: Map<string, ReviewSummary>,\n    outputHistory?: Map<string, unknown[]>\n  ): Record<string, unknown> {\n    if (!dependencyResults) {\n      return {};\n    }\n\n    const outputs: Record<string, unknown> = {};\n    const history: Record<string, unknown[]> = {};\n\n    for (const [checkName, result] of dependencyResults) {\n      // If the result has a direct output field, use it directly\n      // Otherwise, expose the entire result as-is\n      const summary = result as ReviewSummary & { output?: unknown };\n      const value = summary.output !== undefined ? summary.output : summary;\n      outputs[checkName] = this.makeJsonSmart(value);\n    }\n\n    // Add history for each check if available\n    if (outputHistory) {\n      for (const [checkName, historyArray] of outputHistory) {\n        history[checkName] = historyArray.map(val => this.makeJsonSmart(val));\n      }\n    }\n\n    // Attach history to the outputs object\n    (outputs as any).history = history;\n\n    return outputs;\n  }\n\n  /**\n   * Wrap a value with JSON-smart behavior:\n   *  - If it's a JSON string, expose parsed properties via Proxy (e.g., value.key)\n   *  - When coerced to string (toString/valueOf/Symbol.toPrimitive), return the original raw string\n   *  - If parsing fails or value is not a string, return the value unchanged\n   *  - Attempts to extract JSON from the end of the output if full parse fails\n   */\n  private makeJsonSmart<T = unknown>(value: T): T | any {\n    if (typeof value !== 'string') {\n      return value;\n    }\n\n    const raw = value as unknown as string;\n    let parsed: any;\n\n    // First try: parse the entire string as JSON\n    try {\n      parsed = JSON.parse(raw);\n    } catch {\n      // Second try: extract JSON from the end of the output\n      // Look for { or [ at the start of a line and take everything after it\n      const jsonMatch = this.extractJsonFromEnd(raw);\n      if (jsonMatch) {\n        try {\n          parsed = JSON.parse(jsonMatch);\n          logger.debug(\n            `üîß Debug: Extracted JSON from end of output (${jsonMatch.length} chars from ${raw.length} total)`\n          );\n        } catch {\n          // Not valid JSON even after extraction, return original string\n          return raw;\n        }\n      } else {\n        // Not JSON, return original string\n        return raw;\n      }\n    }\n\n    // Use a boxed string so string methods still work via Proxy fallback\n    const boxed = new String(raw);\n    const handler: ProxyHandler<any> = {\n      get(target, prop, receiver) {\n        if (prop === 'toString' || prop === 'valueOf') {\n          return () => raw;\n        }\n        if (prop === Symbol.toPrimitive) {\n          return () => raw;\n        }\n        if (parsed != null && (typeof parsed === 'object' || Array.isArray(parsed))) {\n          if (prop in parsed) {\n            return (parsed as any)[prop as any];\n          }\n        }\n        return Reflect.get(target, prop, receiver);\n      },\n      has(_target, prop) {\n        if (parsed != null && (typeof parsed === 'object' || Array.isArray(parsed))) {\n          if (prop in parsed) return true;\n        }\n        return false;\n      },\n      ownKeys(_target) {\n        if (parsed != null && (typeof parsed === 'object' || Array.isArray(parsed))) {\n          try {\n            return Reflect.ownKeys(parsed);\n          } catch {\n            return [];\n          }\n        }\n        return [];\n      },\n      getOwnPropertyDescriptor(_target, prop) {\n        if (parsed != null && (typeof parsed === 'object' || Array.isArray(parsed))) {\n          const descriptor = Object.getOwnPropertyDescriptor(parsed, prop as any);\n          if (descriptor) return descriptor;\n        }\n        return {\n          configurable: true,\n          enumerable: true,\n          writable: false,\n          value: undefined,\n        };\n      },\n    };\n    return new Proxy(boxed, handler);\n  }\n\n  /**\n   * Extract JSON from the end of a string that may contain logs/debug output\n   * Looks for the last occurrence of { or [ and tries to parse from there\n   */\n  private extractJsonFromEnd(text: string): string | null {\n    // Robust strategy: find the last closing brace/bracket, then walk backwards to the matching opener\n    const lastBrace = Math.max(text.lastIndexOf('}'), text.lastIndexOf(']'));\n    if (lastBrace === -1) return null;\n    // Scan backwards to find matching opener with a simple counter\n    let open = 0;\n    for (let i = lastBrace; i >= 0; i--) {\n      const ch = text[i];\n      if (ch === '}' || ch === ']') open++;\n      else if (ch === '{' || ch === '[') open--;\n      if (open === 0 && (ch === '{' || ch === '[')) {\n        const candidate = text.slice(i, lastBrace + 1).trim();\n        try {\n          JSON.parse(candidate);\n          return candidate;\n        } catch {\n          return null;\n        }\n      }\n    }\n    return null;\n  }\n\n  // Extract any balanced JSON object/array substring from anywhere in the text\n  private extractJsonAnywhere(text: string): string | null {\n    const n = text.length;\n    let best: string | null = null;\n    for (let i = 0; i < n; i++) {\n      const start = text[i];\n      if (start !== '{' && start !== '[') continue;\n      let open = 0;\n      let inString = false;\n      let escape = false;\n      for (let j = i; j < n; j++) {\n        const ch = text[j];\n        if (escape) {\n          escape = false;\n          continue;\n        }\n        if (ch === '\\\\') {\n          escape = true;\n          continue;\n        }\n        if (ch === '\"') {\n          inString = !inString;\n          continue;\n        }\n        if (inString) continue;\n        if (ch === '{' || ch === '[') open++;\n        else if (ch === '}' || ch === ']') open--;\n        if (open === 0 && (ch === '}' || ch === ']')) {\n          const candidate = text.slice(i, j + 1).trim();\n          try {\n            JSON.parse(candidate);\n            best = candidate; // keep the last valid one we find\n          } catch {\n            // Try a loose-to-strict conversion (quote keys and barewords)\n            const strict = this.looseJsonToStrict(candidate);\n            if (strict) {\n              try {\n                JSON.parse(strict);\n                best = strict;\n              } catch {}\n            }\n          }\n          break;\n        }\n      }\n    }\n    return best;\n  }\n\n  // Best-effort conversion of object-literal-like strings to strict JSON\n  private looseJsonToStrict(candidate: string): string | null {\n    try {\n      let s = candidate.trim();\n      // Convert single quotes to double quotes conservatively\n      s = s.replace(/'/g, '\"');\n      // Quote unquoted keys: {key: ...} or ,key: ...\n      s = s.replace(/([\\{,]\\s*)([A-Za-z_][A-Za-z0-9_-]*)\\s*:/g, '$1\"$2\":');\n      // Quote bareword values except true/false/null and numbers\n      s = s.replace(/:\\s*([A-Za-z_][A-Za-z0-9_-]*)\\s*(?=[,}])/g, (m, word) => {\n        const lw = String(word).toLowerCase();\n        if (lw === 'true' || lw === 'false' || lw === 'null') return `:${lw}`;\n        return `:\"${word}\"`;\n      });\n      return s;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Recursively apply JSON-smart wrapper to outputs object values\n   */\n  private makeOutputsJsonSmart(outputs: Record<string, unknown>): Record<string, unknown> {\n    const wrapped: Record<string, unknown> = {};\n    for (const [k, v] of Object.entries(outputs || {})) {\n      wrapped[k] = this.makeJsonSmart(v);\n    }\n    return wrapped;\n  }\n\n  private getSafeEnvironmentVariables(): Record<string, string> {\n    const safeVars: Record<string, string> = {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const allowedPrefixes: string[] = []; // replaced by buildSandboxEnv\n\n    const { buildSandboxEnv } = require('../utils/env-exposure');\n    const merged = buildSandboxEnv(process.env);\n    for (const [key, value] of Object.entries(merged)) {\n      safeVars[key] = String(value);\n    }\n\n    // Add current working directory\n    safeVars['PWD'] = process.cwd();\n\n    return safeVars;\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'exec',\n      'transform',\n      'transform_js',\n      'env',\n      'timeout',\n      'depends_on',\n      'on',\n      'if',\n      'group',\n      'forEach',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // Command provider is always available as long as we can execute commands\n    return true;\n  }\n\n  getRequirements(): string[] {\n    return [\n      'Valid shell command to execute',\n      'Shell environment available',\n      'Optional: Transform template for processing output',\n    ];\n  }\n\n  private extractIssuesFromOutput(\n    output: unknown\n  ): { issues: ReviewIssue[]; remainingOutput: unknown } | null {\n    try {\n      logger.info(\n        `  extractIssuesFromOutput: typeof=${Array.isArray(output) ? 'array' : typeof output}`\n      );\n      if (typeof output === 'object' && output) {\n        const rec = output as Record<string, unknown>;\n        logger.info(\n          `  extractIssuesFromOutput: keys=${Object.keys(rec).join(',')} issuesIsArray=${Array.isArray(\n            (rec as any).issues\n          )}`\n        );\n      }\n    } catch {}\n    if (output === null || output === undefined) {\n      return null;\n    }\n\n    // If output is already a string, do not treat it as issues here (caller may try parsing JSON)\n    if (typeof output === 'string') {\n      return null;\n    }\n\n    if (Array.isArray(output)) {\n      // Two supported shapes:\n      //  1) Array<ReviewIssue-like>\n      //  2) Array<{ issues: Array<ReviewIssue-like> }>\n      const first = output[0];\n      if (\n        first &&\n        typeof first === 'object' &&\n        !Array.isArray((first as any).message) &&\n        Array.isArray((first as any).issues)\n      ) {\n        // flatten nested issues arrays\n        const merged: unknown[] = [];\n        for (const el of output as unknown[]) {\n          if (el && typeof el === 'object' && Array.isArray((el as any).issues)) {\n            merged.push(...((el as any).issues as unknown[]));\n          }\n        }\n        const flat = this.normalizeIssueArray(merged);\n        if (flat) return { issues: flat, remainingOutput: undefined };\n      } else {\n        const issues = this.normalizeIssueArray(output);\n        if (issues) {\n          return { issues, remainingOutput: undefined };\n        }\n      }\n      return null;\n    }\n\n    if (typeof output === 'object') {\n      const record = output as Record<string, unknown>;\n\n      if (Array.isArray(record.issues)) {\n        const issues = this.normalizeIssueArray(record.issues);\n        if (!issues) {\n          return null;\n        }\n\n        const remaining = { ...record };\n        delete (remaining as { issues?: unknown }).issues;\n\n        const remainingKeys = Object.keys(remaining);\n        const remainingOutput = remainingKeys.length > 0 ? remaining : undefined;\n\n        return {\n          issues,\n          remainingOutput,\n        };\n      }\n\n      const singleIssue = this.normalizeIssue(record);\n      if (singleIssue) {\n        return { issues: [singleIssue], remainingOutput: undefined };\n      }\n    }\n\n    return null;\n  }\n\n  private shouldTreatAsTextOutput(value?: string): value is string {\n    if (!value) {\n      return false;\n    }\n\n    const trimmed = value.trim();\n    if (!trimmed) {\n      return false;\n    }\n\n    // Heuristic: consider it JSON-like if it starts with { or [ and ends with } or ]\n    const startsJson =\n      (trimmed.startsWith('{') && trimmed.endsWith('}')) ||\n      (trimmed.startsWith('[') && trimmed.endsWith(']'));\n\n    return !startsJson;\n  }\n\n  private normalizeIssueArray(values: unknown[]): ReviewIssue[] | null {\n    const normalized: ReviewIssue[] = [];\n\n    for (const value of values) {\n      const issue = this.normalizeIssue(value);\n      if (!issue) {\n        return null;\n      }\n      normalized.push(issue);\n    }\n\n    return normalized;\n  }\n\n  private normalizeIssue(raw: unknown): ReviewIssue | null {\n    if (!raw || typeof raw !== 'object') {\n      return null;\n    }\n\n    const data = raw as Record<string, unknown>;\n\n    const message = this.toTrimmedString(\n      data.message || data.text || data.description || data.summary\n    );\n    if (!message) {\n      return null;\n    }\n\n    const allowedSeverities = new Set(['info', 'warning', 'error', 'critical']);\n    const severityRaw = this.toTrimmedString(data.severity || data.level || data.priority);\n    let severity: ReviewIssue['severity'] = 'warning';\n    if (severityRaw) {\n      const lower = severityRaw.toLowerCase();\n      if (allowedSeverities.has(lower)) {\n        severity = lower as ReviewIssue['severity'];\n      } else if (['fatal', 'high'].includes(lower)) {\n        severity = 'error';\n      } else if (['medium', 'moderate'].includes(lower)) {\n        severity = 'warning';\n      } else if (['low', 'minor'].includes(lower)) {\n        severity = 'info';\n      }\n    }\n\n    const allowedCategories = new Set([\n      'security',\n      'performance',\n      'style',\n      'logic',\n      'documentation',\n    ]);\n    const categoryRaw = this.toTrimmedString(data.category || data.type || data.group);\n    let category: ReviewIssue['category'] = 'logic';\n    if (categoryRaw && allowedCategories.has(categoryRaw.toLowerCase())) {\n      category = categoryRaw.toLowerCase() as ReviewIssue['category'];\n    }\n\n    const file = this.toTrimmedString(data.file || data.path || data.filename) || 'system';\n\n    const line = this.toNumber(data.line || data.startLine || data.lineNumber) ?? 0;\n    const endLine = this.toNumber(data.endLine || data.end_line || data.stopLine);\n\n    const suggestion = this.toTrimmedString(data.suggestion);\n    const replacement = this.toTrimmedString(data.replacement);\n\n    const ruleId =\n      this.toTrimmedString(data.ruleId || data.rule || data.id || data.check) || 'command';\n\n    return {\n      file,\n      line,\n      endLine: endLine ?? undefined,\n      ruleId,\n      message,\n      severity,\n      category,\n      suggestion: suggestion || undefined,\n      replacement: replacement || undefined,\n    };\n  }\n\n  private toTrimmedString(value: unknown): string | null {\n    if (typeof value === 'string') {\n      const trimmed = value.trim();\n      return trimmed.length > 0 ? trimmed : null;\n    }\n    if (value !== null && value !== undefined && typeof value.toString === 'function') {\n      const converted = String(value).trim();\n      return converted.length > 0 ? converted : null;\n    }\n    return null;\n  }\n\n  private toNumber(value: unknown): number | null {\n    if (value === null || value === undefined) {\n      return null;\n    }\n    const num = Number(value);\n    if (Number.isFinite(num)) {\n      return Math.trunc(num);\n    }\n    return null;\n  }\n\n  private async renderCommandTemplate(\n    template: string,\n    context: {\n      pr: Record<string, unknown>;\n      files: unknown[];\n      outputs: Record<string, unknown>;\n      env: Record<string, string>;\n    }\n  ): Promise<string> {\n    try {\n      // Best-effort compatibility: allow double-quoted bracket keys inside Liquid tags.\n      // e.g., {{ outputs[\"fetch-tickets\"].key }} ‚Üí {{ outputs['fetch-tickets'].key }}\n      let tpl = template;\n      if (tpl.includes('{{')) {\n        tpl = tpl.replace(/\\{\\{([\\s\\S]*?)\\}\\}/g, (_m, inner) => {\n          const fixed = String(inner).replace(/\\[\\\"/g, \"['\").replace(/\\\"\\]/g, \"']\");\n          return `{{ ${fixed} }}`;\n        });\n      }\n      let rendered = await this.liquid.parseAndRender(tpl, context);\n      // If Liquid left unresolved tags (common when users write JS expressions inside {{ }}),\n      // fall back to a safe JS-expression renderer for the remaining tags.\n      if (/\\{\\{[\\s\\S]*?\\}\\}/.test(rendered)) {\n        try {\n          rendered = this.renderWithJsExpressions(rendered, context);\n        } catch {\n          // keep Liquid-rendered result as-is\n        }\n      }\n      return rendered;\n    } catch (error) {\n      logger.debug(`üîß Debug: Liquid templating failed, trying JS-expression fallback: ${error}`);\n      try {\n        return this.renderWithJsExpressions(template, context);\n      } catch {\n        return template;\n      }\n    }\n  }\n\n  private renderWithJsExpressions(\n    template: string,\n    context: {\n      pr: Record<string, unknown>;\n      files: unknown[];\n      outputs: Record<string, unknown>;\n      env: Record<string, string>;\n    }\n  ): string {\n    const scope = {\n      pr: context.pr,\n      files: context.files,\n      outputs: context.outputs,\n      env: context.env,\n    };\n\n    const expressionRegex = /\\{\\{\\s*([^{}]+?)\\s*\\}\\}/g;\n    return template.replace(expressionRegex, (_match, expr) => {\n      const expression = String(expr).trim();\n      if (!expression) return '';\n      try {\n        const evalCode = `\n          const pr = scope.pr;\n          const files = scope.files;\n          const outputs = scope.outputs;\n          const env = scope.env;\n          return (${expression});\n        `;\n        if (!this.sandbox) this.sandbox = this.createSecureSandbox();\n        const evaluator = this.sandbox.compile(evalCode);\n        const result = evaluator({ scope }).run();\n        return result === undefined || result === null ? '' : String(result);\n      } catch {\n        return '';\n      }\n    });\n  }\n}\n","import type { PRInfo } from '../pr-analyzer';\nimport type { ReviewSummary } from '../reviewer';\nimport { MemoryStore } from '../memory-store';\n\n/**\n * Build a common provider template context with PR info, outputs (current),\n * outputs.history (all runs), outputs_raw (aggregate -raw deps) and an alias\n * outputs_history / outputs_history_stage. Optionally attaches read-only\n * memory helpers (get/has/list/getAll).\n */\nconst PR_CACHE_LIMIT = 16;\nconst prCache = new Map<string, any>();\n\nfunction prCacheKey(pr: PRInfo): string {\n  // Hash on stable fields + file list summary to avoid rebuilding the same structure repeatedly\n  let sum = 0;\n  for (const f of pr.files) sum += (f.additions || 0) + (f.deletions || 0) + (f.changes || 0);\n  return [pr.number, pr.title, pr.author, pr.base, pr.head, pr.files.length, sum].join('|');\n}\n\nexport function buildProviderTemplateContext(\n  prInfo: PRInfo,\n  dependencyResults?: Map<string, ReviewSummary>,\n  memoryStore?: MemoryStore,\n  outputHistory?: Map<string, unknown[]>,\n  stageHistoryBase?: Record<string, number>,\n  opts: { attachMemoryReadHelpers?: boolean } = { attachMemoryReadHelpers: true }\n): Record<string, unknown> {\n  const context: Record<string, unknown> = {};\n\n  // PR context with tiny cache\n  const key = prCacheKey(prInfo);\n  let prObj = prCache.get(key);\n  if (!prObj) {\n    prObj = {\n      number: prInfo.number,\n      title: prInfo.title,\n      body: prInfo.body,\n      author: prInfo.author,\n      base: prInfo.base,\n      head: prInfo.head,\n      totalAdditions: prInfo.totalAdditions,\n      totalDeletions: prInfo.totalDeletions,\n      files: prInfo.files.map(f => ({\n        filename: f.filename,\n        status: f.status,\n        additions: f.additions,\n        deletions: f.deletions,\n        changes: f.changes,\n      })),\n    };\n    prCache.set(key, prObj);\n    if (prCache.size > PR_CACHE_LIMIT) {\n      const first = prCache.keys().next();\n      if (!first.done) prCache.delete(first.value);\n    }\n  }\n  context.pr = prObj;\n\n  // outputs and history\n  const outputs: Record<string, unknown> = {};\n  const outputsRaw: Record<string, unknown> = {};\n  const history: Record<string, unknown[]> = {};\n\n  if (dependencyResults) {\n    for (const [checkName, result] of dependencyResults.entries()) {\n      if (typeof checkName !== 'string') continue;\n      const summary = result as ReviewSummary & { output?: unknown };\n      if (checkName.endsWith('-raw')) {\n        const name = checkName.slice(0, -4);\n        outputsRaw[name] = summary.output !== undefined ? summary.output : summary;\n      } else {\n        outputs[checkName] = summary.output !== undefined ? summary.output : summary;\n      }\n    }\n  }\n\n  if (outputHistory) {\n    for (const [checkName, historyArray] of outputHistory) {\n      history[checkName] = historyArray;\n    }\n  }\n\n  const historyStage: Record<string, unknown[]> = {};\n  try {\n    if (outputHistory && stageHistoryBase) {\n      for (const [checkName, historyArray] of outputHistory) {\n        const start = stageHistoryBase[checkName] || 0;\n        const arr = Array.isArray(historyArray) ? (historyArray as unknown[]) : [];\n        historyStage[checkName] = arr.slice(start);\n      }\n    }\n  } catch {}\n\n  (outputs as any).history = history;\n  context.outputs = outputs;\n  (context as any).outputs_history = history;\n  (context as any).outputs_history_stage = historyStage;\n  (context as any).outputs_raw = outputsRaw;\n\n  if (opts.attachMemoryReadHelpers && memoryStore) {\n    context.memory = {\n      get: (key: string, ns?: string) => memoryStore.get(key, ns),\n      has: (key: string, ns?: string) => memoryStore.has(key, ns),\n      list: (ns?: string) => memoryStore.list(ns),\n      getAll: (ns?: string) => memoryStore.getAll(ns),\n    } as Record<string, unknown>;\n  }\n\n  return context;\n}\n","import { MemoryStore } from '../memory-store';\n\n/**\n * Create synchronous memory helpers for sandboxed script execution. These mirror\n * the legacy behavior previously used for in-provider scripting: mutate in-memory state\n * synchronously and perform at most one save() afterward if needed.\n */\nexport function createSyncMemoryOps(store: MemoryStore): {\n  ops: {\n    get: (key: string, ns?: string) => unknown;\n    has: (key: string, ns?: string) => boolean;\n    list: (ns?: string) => string[];\n    getAll: (ns?: string) => Record<string, unknown>;\n    set: (key: string, value: unknown, ns?: string) => unknown;\n    append: (key: string, value: unknown, ns?: string) => unknown[];\n    increment: (key: string, amount?: number, ns?: string) => number;\n    delete: (key: string, ns?: string) => boolean;\n    clear: (ns?: string) => void;\n  };\n  needsSave: () => boolean;\n} {\n  let saveNeeded = false;\n\n  const ensureNs = (ns?: string) => {\n    const nsName = ns || store.getDefaultNamespace();\n    const anyStore = store as unknown as { data: Map<string, Map<string, unknown>> };\n    if (!anyStore['data'].has(nsName)) {\n      anyStore['data'].set(nsName, new Map());\n    }\n    return nsName;\n  };\n\n  const ops = {\n    get: (key: string, ns?: string) => store.get(key, ns),\n    has: (key: string, ns?: string) => store.has(key, ns),\n    list: (ns?: string) => store.list(ns),\n    getAll: (ns?: string) => store.getAll(ns),\n    set: (key: string, value: unknown, ns?: string) => {\n      const nsName = ensureNs(ns);\n      (store as any)['data'].get(nsName)!.set(key, value);\n      saveNeeded = true;\n      return value;\n    },\n    append: (key: string, value: unknown, ns?: string) => {\n      const existing = store.get(key, ns);\n      let newValue: unknown[];\n      if (existing === undefined) newValue = [value];\n      else if (Array.isArray(existing)) newValue = [...existing, value];\n      else newValue = [existing, value];\n      const nsName = ensureNs(ns);\n      (store as any)['data'].get(nsName)!.set(key, newValue);\n      saveNeeded = true;\n      return newValue;\n    },\n    increment: (key: string, amount = 1, ns?: string) => {\n      const nsName = ensureNs(ns);\n      const current = store.get(key, nsName);\n      const numCurrent = typeof current === 'number' ? (current as number) : 0;\n      const newValue = numCurrent + amount;\n      (store as any)['data'].get(nsName)!.set(key, newValue);\n      saveNeeded = true;\n      return newValue;\n    },\n    delete: (key: string, ns?: string) => {\n      const nsName = ensureNs(ns);\n      const d = (store as any)['data'].get(nsName)?.delete(key) || false;\n      if (d) saveNeeded = true;\n      return d;\n    },\n    clear: (ns?: string) => {\n      if (ns) (store as any)['data'].delete(ns);\n      else (store as any)['data'].clear();\n      saveNeeded = true;\n    },\n  } as const;\n\n  return { ops: ops as any, needsSave: () => saveNeeded };\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { MemoryStore } from '../memory-store';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { logger } from '../logger';\nimport Sandbox from '@nyariv/sandboxjs';\nimport { createSecureSandbox, compileAndRun } from '../utils/sandbox';\nimport { buildProviderTemplateContext } from '../utils/template-context';\nimport { createSyncMemoryOps } from '../utils/script-memory-ops';\n\n/**\n * Memory operation types\n */\nexport type MemoryOperation = 'get' | 'set' | 'append' | 'increment' | 'delete' | 'clear' | 'list';\n\n/**\n * Check provider for memory/state management\n * Supports in-memory and persistent storage with namespace isolation\n */\nexport class MemoryCheckProvider extends CheckProvider {\n  private liquid: Liquid;\n  private sandbox?: Sandbox;\n\n  constructor() {\n    super();\n    this.liquid = createExtendedLiquid({\n      strictVariables: false,\n      strictFilters: false,\n    });\n  }\n\n  /**\n   * Create a secure sandbox for JavaScript execution\n   */\n  private createSecureSandbox(): Sandbox {\n    return createSecureSandbox();\n  }\n\n  getName(): string {\n    return 'memory';\n  }\n\n  getDescription(): string {\n    return 'Memory/state management provider for persistent key-value storage across checks';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'memory'\n    if (cfg.type !== 'memory') {\n      return false;\n    }\n\n    // Operation is required\n    if (!cfg.operation || typeof cfg.operation !== 'string') {\n      return false;\n    }\n\n    const operation = cfg.operation as string;\n    const validOps = ['get', 'set', 'append', 'increment', 'delete', 'clear', 'list'];\n    if (!validOps.includes(operation)) {\n      return false;\n    }\n\n    // Key is required for get, set, append, increment, delete\n    if (['get', 'set', 'append', 'increment', 'delete'].includes(operation)) {\n      if (!cfg.key || typeof cfg.key !== 'string') {\n        return false;\n      }\n    }\n\n    // Value or value_js is required for set and append\n    if (['set', 'append'].includes(operation)) {\n      if (cfg.value === undefined && !cfg.value_js) {\n        return false;\n      }\n    }\n\n    // For custom scripting use the ScriptCheckProvider (type: 'script').\n\n    return true;\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    _sessionInfo?: {\n      parentSessionId?: string;\n      reuseSession?: boolean;\n    } & import('./check-provider.interface').ExecutionContext\n  ): Promise<ReviewSummary> {\n    const operation = config.operation as MemoryOperation | undefined;\n    const key = config.key as string | undefined;\n    const namespace = config.namespace as string | undefined;\n\n    // Get memory store instance\n    const memoryStore = MemoryStore.getInstance();\n\n    // Build template context for value computation\n    const templateContext = this.buildTemplateContext(\n      prInfo,\n      dependencyResults,\n      memoryStore,\n      config.__outputHistory as Map<string, unknown[]> | undefined,\n      (_sessionInfo as any)?.stageHistoryBase as Record<string, number> | undefined\n    );\n\n    let result: unknown;\n\n    // No implicit fallbacks; operation must be explicitly provided.\n\n    try {\n      switch (operation) {\n        case 'get':\n          result = await this.handleGet(memoryStore, key!, namespace);\n          break;\n        case 'set':\n          result = await this.handleSet(memoryStore, key!, config, namespace, templateContext);\n          break;\n        case 'append':\n          result = await this.handleAppend(memoryStore, key!, config, namespace, templateContext);\n          break;\n        case 'increment':\n          result = await this.handleIncrement(\n            memoryStore,\n            key!,\n            config,\n            namespace,\n            templateContext\n          );\n          break;\n        case 'delete':\n          result = await this.handleDelete(memoryStore, key!, namespace);\n          break;\n        case 'clear':\n          result = await this.handleClear(memoryStore, namespace);\n          break;\n        case 'list':\n          result = await this.handleList(memoryStore, namespace);\n          break;\n        default:\n          throw new Error(`Unknown memory operation: ${operation}`);\n      }\n\n      // Return result as output\n      return {\n        issues: [],\n        output: result,\n      } as ReviewSummary & { output: unknown };\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : 'Unknown error in memory operation';\n      logger.error(`Memory operation failed: ${errorMsg}`);\n\n      return {\n        issues: [],\n        output: null,\n        error: errorMsg,\n      } as ReviewSummary & { output: null; error: string };\n    }\n  }\n\n  private async handleGet(store: MemoryStore, key: string, namespace?: string): Promise<unknown> {\n    const value = store.get(key, namespace);\n    logger.debug(\n      `Memory GET: ${namespace || store.getDefaultNamespace()}.${key} = ${JSON.stringify(value)}`\n    );\n    return value;\n  }\n\n  private async handleSet(\n    store: MemoryStore,\n    key: string,\n    config: CheckProviderConfig,\n    namespace: string | undefined,\n    context: Record<string, unknown>\n  ): Promise<unknown> {\n    const value = await this.computeValue(config, context);\n    await store.set(key, value, namespace);\n    logger.debug(\n      `Memory SET: ${namespace || store.getDefaultNamespace()}.${key} = ${JSON.stringify(value)}`\n    );\n    return value;\n  }\n\n  private async handleAppend(\n    store: MemoryStore,\n    key: string,\n    config: CheckProviderConfig,\n    namespace: string | undefined,\n    context: Record<string, unknown>\n  ): Promise<unknown> {\n    const value = await this.computeValue(config, context);\n    await store.append(key, value, namespace);\n    const result = store.get(key, namespace);\n    logger.debug(\n      `Memory APPEND: ${namespace || store.getDefaultNamespace()}.${key} += ${JSON.stringify(value)} (now: ${JSON.stringify(result)})`\n    );\n    return result;\n  }\n\n  private async handleIncrement(\n    store: MemoryStore,\n    key: string,\n    config: CheckProviderConfig,\n    namespace: string | undefined,\n    context: Record<string, unknown>\n  ): Promise<number> {\n    // Compute amount - default to 1 if not specified\n    let amount = 1;\n    if (config.value !== undefined || config.value_js) {\n      const computedValue = await this.computeValue(config, context);\n      if (typeof computedValue === 'number') {\n        amount = computedValue;\n      } else {\n        throw new Error(`Increment amount must be a number, got ${typeof computedValue}`);\n      }\n    }\n\n    const result = await store.increment(key, amount, namespace);\n    logger.debug(\n      `Memory INCREMENT: ${namespace || store.getDefaultNamespace()}.${key} += ${amount} (now: ${result})`\n    );\n    return result;\n  }\n\n  private async handleDelete(\n    store: MemoryStore,\n    key: string,\n    namespace?: string\n  ): Promise<boolean> {\n    const deleted = await store.delete(key, namespace);\n    logger.debug(\n      `Memory DELETE: ${namespace || store.getDefaultNamespace()}.${key} (deleted: ${deleted})`\n    );\n    return deleted;\n  }\n\n  private async handleClear(store: MemoryStore, namespace?: string): Promise<void> {\n    await store.clear(namespace);\n    logger.debug(`Memory CLEAR: ${namespace ? `namespace ${namespace}` : 'all namespaces'}`);\n  }\n\n  private async handleList(store: MemoryStore, namespace?: string): Promise<string[]> {\n    const keys = store.list(namespace);\n    logger.debug(`Memory LIST: ${namespace || store.getDefaultNamespace()} (${keys.length} keys)`);\n    return keys;\n  }\n\n  // For custom JavaScript execution use ScriptCheckProvider.\n\n  /**\n   * Compute value from config using value, value_js, transform, or transform_js\n   */\n  private async computeValue(\n    config: CheckProviderConfig,\n    context: Record<string, unknown>\n  ): Promise<unknown> {\n    let value: unknown;\n\n    // Start with direct value or value_js\n    if (config.value_js && typeof config.value_js === 'string') {\n      value = this.evaluateJavaScript(config.value_js, context);\n    } else {\n      value = config.value;\n    }\n\n    // Apply transform template if provided\n    if (config.transform && typeof config.transform === 'string') {\n      const rendered = await this.liquid.parseAndRender(config.transform, {\n        ...context,\n        value,\n      });\n      value = rendered;\n    }\n\n    // Apply transform_js if provided\n    if (config.transform_js && typeof config.transform_js === 'string') {\n      value = this.evaluateJavaScript(config.transform_js, { ...context, value });\n    }\n\n    return value;\n  }\n\n  /**\n   * Evaluate JavaScript expression in context using SandboxJS for secure execution\n   */\n  private evaluateJavaScript(expression: string, context: Record<string, unknown>): unknown {\n    if (!this.sandbox) {\n      this.sandbox = this.createSecureSandbox();\n    }\n\n    try {\n      const scope: Record<string, unknown> = { ...context };\n      return compileAndRun<unknown>(this.sandbox, `return (${expression});`, scope, {\n        injectLog: true,\n        wrapFunction: false,\n        logPrefix: '[memory:value_js]',\n      });\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : 'Unknown error';\n      throw new Error(`Failed to evaluate value_js: ${errorMsg}`);\n    }\n  }\n\n  // No full-script execution in memory provider. Use ScriptCheckProvider.\n\n  /**\n   * Build template context for Liquid and JS evaluation\n   */\n  private buildTemplateContext(\n    prInfo: PRInfo,\n    dependencyResults?: Map<string, ReviewSummary>,\n    memoryStore?: MemoryStore,\n    outputHistory?: Map<string, unknown[]>,\n    stageHistoryBase?: Record<string, number>\n  ): Record<string, unknown> {\n    const base = buildProviderTemplateContext(\n      prInfo,\n      dependencyResults,\n      memoryStore,\n      outputHistory as Map<string, unknown[]> | undefined,\n      stageHistoryBase\n    );\n    if (memoryStore) {\n      const { ops } = createSyncMemoryOps(memoryStore);\n      (base as any).memory = ops;\n    }\n    return base;\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'operation',\n      'key',\n      'value',\n      'value_js',\n      'transform',\n      'transform_js',\n      'namespace',\n      'depends_on',\n      'group',\n      'command',\n      'on',\n      'if',\n      'fail_if',\n      'on_fail',\n      'on_success',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // Memory provider is always available\n    return true;\n  }\n\n  getRequirements(): string[] {\n    return [\n      'No external dependencies required',\n      'Used for state management and persistent storage across checks',\n    ];\n  }\n}\n","import { CustomToolDefinition } from '../types/config';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { createSecureSandbox, compileAndRun } from '../utils/sandbox';\nimport Sandbox from '@nyariv/sandboxjs';\nimport { logger } from '../logger';\nimport { commandExecutor } from '../utils/command-executor';\nimport Ajv from 'ajv';\n\n/**\n * Executes custom tools defined in YAML configuration\n * These tools can be used in MCP blocks as if they were native MCP tools\n */\nexport class CustomToolExecutor {\n  private liquid: Liquid;\n  private sandbox?: Sandbox;\n  private tools: Map<string, CustomToolDefinition>;\n  private ajv: Ajv;\n\n  constructor(tools?: Record<string, CustomToolDefinition>) {\n    this.liquid = createExtendedLiquid({\n      cache: false,\n      strictFilters: false,\n      strictVariables: false,\n    });\n    this.tools = new Map(Object.entries(tools || {}));\n    this.ajv = new Ajv({ allErrors: true, verbose: true });\n  }\n\n  /**\n   * Register a custom tool\n   */\n  registerTool(tool: CustomToolDefinition): void {\n    if (!tool.name) {\n      throw new Error('Tool must have a name');\n    }\n    this.tools.set(tool.name, tool);\n  }\n\n  /**\n   * Register multiple tools\n   */\n  registerTools(tools: Record<string, CustomToolDefinition>): void {\n    for (const [name, tool] of Object.entries(tools)) {\n      // Ensure tool has the correct name\n      tool.name = tool.name || name;\n      this.registerTool(tool);\n    }\n  }\n\n  /**\n   * Get all registered tools\n   */\n  getTools(): CustomToolDefinition[] {\n    return Array.from(this.tools.values());\n  }\n\n  /**\n   * Get a specific tool by name\n   */\n  getTool(name: string): CustomToolDefinition | undefined {\n    return this.tools.get(name);\n  }\n\n  /**\n   * Validate tool input against schema using ajv\n   */\n  private validateInput(tool: CustomToolDefinition, input: Record<string, unknown>): void {\n    if (!tool.inputSchema) {\n      return;\n    }\n\n    // Compile and cache the schema validator for this tool\n    const validate = this.ajv.compile(tool.inputSchema);\n\n    // Validate the input\n    const valid = validate(input);\n\n    if (!valid) {\n      // Format validation errors for better readability\n      const errors = validate.errors\n        ?.map(err => {\n          if (err.instancePath) {\n            return `${err.instancePath}: ${err.message}`;\n          }\n          return err.message;\n        })\n        .join(', ');\n\n      throw new Error(`Input validation failed for tool '${tool.name}': ${errors}`);\n    }\n  }\n\n  /**\n   * Execute a custom tool\n   */\n  async execute(\n    toolName: string,\n    args: Record<string, unknown>,\n    context?: {\n      pr?: {\n        number: number;\n        title: string;\n        author: string;\n        branch: string;\n        base: string;\n      };\n      files?: unknown[];\n      outputs?: Record<string, unknown>;\n      env?: Record<string, string>;\n    }\n  ): Promise<unknown> {\n    const tool = this.tools.get(toolName);\n    if (!tool) {\n      throw new Error(`Tool not found: ${toolName}`);\n    }\n\n    // Validate input\n    this.validateInput(tool, args);\n\n    // Build template context\n    const templateContext = {\n      ...context,\n      args,\n      input: args,\n    };\n\n    // Render command with Liquid\n    const command = await this.liquid.parseAndRender(tool.exec, templateContext);\n\n    // Render stdin if provided\n    let stdin: string | undefined;\n    if (tool.stdin) {\n      stdin = await this.liquid.parseAndRender(tool.stdin, templateContext);\n    }\n\n    // Execute the command using shared executor\n    const env = commandExecutor.buildEnvironment(process.env, tool.env, context?.env);\n    const result = await commandExecutor.execute(command, {\n      stdin,\n      cwd: tool.cwd,\n      env,\n      timeout: tool.timeout || 30000,\n    });\n\n    // Parse JSON if requested\n    let output: unknown = result.stdout;\n    if (tool.parseJson) {\n      try {\n        output = JSON.parse(result.stdout);\n      } catch (e) {\n        logger.warn(`Failed to parse tool output as JSON: ${e}`);\n      }\n    }\n\n    // Apply transform if specified\n    if (tool.transform) {\n      const transformContext = {\n        ...templateContext,\n        output,\n        stdout: result.stdout,\n        stderr: result.stderr,\n        exitCode: result.exitCode,\n      };\n      const transformed = await this.liquid.parseAndRender(tool.transform, transformContext);\n      // Try to parse as JSON if it looks like JSON\n      if (typeof transformed === 'string' && transformed.trim().startsWith('{')) {\n        try {\n          output = JSON.parse(transformed);\n        } catch {\n          output = transformed;\n        }\n      } else {\n        output = transformed;\n      }\n    }\n\n    // Apply JavaScript transform if specified\n    if (tool.transform_js) {\n      output = await this.applyJavaScriptTransform(tool.transform_js, output, {\n        ...templateContext,\n        stdout: result.stdout,\n        stderr: result.stderr,\n        exitCode: result.exitCode,\n      });\n    }\n\n    return output;\n  }\n\n  /**\n   * Apply JavaScript transform to output\n   */\n  private async applyJavaScriptTransform(\n    transformJs: string,\n    output: unknown,\n    context: Record<string, unknown>\n  ): Promise<unknown> {\n    if (!this.sandbox) {\n      this.sandbox = createSecureSandbox();\n    }\n\n    const code = `\n      const output = ${JSON.stringify(output)};\n      const context = ${JSON.stringify(context)};\n      const args = context.args || {};\n      const pr = context.pr || {};\n      const files = context.files || [];\n      const outputs = context.outputs || {};\n      const env = context.env || {};\n\n      ${transformJs}\n    `;\n\n    try {\n      return await compileAndRun(this.sandbox, code, { timeout: 5000 });\n    } catch (error) {\n      logger.error(`JavaScript transform error: ${error}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Convert custom tools to MCP tool format\n   */\n  toMcpTools(): Array<{\n    name: string;\n    description?: string;\n    inputSchema?: Record<string, unknown>;\n    handler: (args: Record<string, unknown>) => Promise<unknown>;\n  }> {\n    return Array.from(this.tools.values()).map(tool => ({\n      name: tool.name,\n      description: tool.description,\n      inputSchema: tool.inputSchema as Record<string, unknown>,\n      handler: async (args: Record<string, unknown>) => {\n        return this.execute(tool.name, args);\n      },\n    }));\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary, ReviewIssue } from '../reviewer';\nimport { logger } from '../logger';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { Client } from '@modelcontextprotocol/sdk/client/index.js';\nimport { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';\nimport { SSEClientTransport } from '@modelcontextprotocol/sdk/client/sse.js';\nimport { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js';\nimport Sandbox from '@nyariv/sandboxjs';\nimport { createSecureSandbox, compileAndRun } from '../utils/sandbox';\nimport { EnvironmentResolver } from '../utils/env-resolver';\nimport { CustomToolExecutor } from './custom-tool-executor';\nimport { CustomToolDefinition } from '../types/config';\n\n/**\n * MCP Check Provider Configuration\n */\nexport interface McpCheckConfig extends CheckProviderConfig {\n  /** Transport type: stdio (default), sse (legacy), http (streamable HTTP), or custom (YAML-defined tools) */\n  transport?: 'stdio' | 'sse' | 'http' | 'custom';\n  /** Command to execute (for stdio transport) */\n  command?: string;\n  /** Command arguments (for stdio transport) */\n  args?: string[];\n  /** Environment variables (for stdio transport) */\n  env?: Record<string, string>;\n  /** Working directory (for stdio transport) */\n  workingDirectory?: string;\n  /** URL for SSE/HTTP transport */\n  url?: string;\n  /** HTTP headers (for SSE/HTTP transport) */\n  headers?: Record<string, string>;\n  /** Session ID for HTTP transport (optional, server may generate one) */\n  sessionId?: string;\n  /** MCP method/tool to call */\n  method: string;\n  /** Arguments to pass to the MCP method (supports Liquid templates) */\n  methodArgs?: Record<string, unknown>;\n  /** Transform template for method arguments (Liquid) */\n  argsTransform?: string;\n  /** Transform template for output (Liquid) */\n  transform?: string;\n  /** Transform using JavaScript expressions */\n  transform_js?: string;\n  /** Timeout in seconds */\n  timeout?: number;\n}\n\n/**\n * Check provider that calls MCP tools directly\n * Supports stdio, SSE (legacy), Streamable HTTP transports, and custom YAML-defined tools\n */\nexport class McpCheckProvider extends CheckProvider {\n  private liquid: Liquid;\n  private sandbox?: Sandbox;\n  private customToolExecutor?: CustomToolExecutor;\n\n  constructor() {\n    super();\n    this.liquid = createExtendedLiquid({\n      cache: false,\n      strictFilters: false,\n      strictVariables: false,\n    });\n  }\n\n  /**\n   * Set custom tools for this provider\n   */\n  setCustomTools(tools: Record<string, CustomToolDefinition>): void {\n    if (!this.customToolExecutor) {\n      this.customToolExecutor = new CustomToolExecutor(tools);\n    } else {\n      this.customToolExecutor.registerTools(tools);\n    }\n  }\n\n  /**\n   * Create a secure sandbox for JavaScript execution\n   * - Uses Sandbox.SAFE_GLOBALS which excludes: Function, eval, require, process, etc.\n   * - Only allows explicitly whitelisted prototype methods\n   * - No access to filesystem, network, or system resources\n   */\n  private createSecureSandbox(): Sandbox {\n    return createSecureSandbox();\n  }\n\n  getName(): string {\n    return 'mcp';\n  }\n\n  getDescription(): string {\n    return 'Call MCP tools directly using stdio, SSE, HTTP, or custom YAML-defined tools';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as McpCheckConfig;\n\n    // Method is required\n    if (!cfg.method || typeof cfg.method !== 'string') {\n      logger.error('MCP check requires a method name');\n      return false;\n    }\n\n    const transport = cfg.transport || 'stdio';\n\n    // Validate transport-specific requirements\n    if (transport === 'stdio') {\n      if (!cfg.command || typeof cfg.command !== 'string') {\n        logger.error('MCP stdio transport requires a command');\n        return false;\n      }\n\n      // Basic command injection prevention - check for shell metacharacters\n      // Allow common safe commands like 'npx', 'node', 'python', etc.\n      if (/[;&|`$(){}[\\]]/.test(cfg.command)) {\n        logger.error('MCP stdio command contains potentially unsafe characters');\n        return false;\n      }\n    } else if (transport === 'sse' || transport === 'http') {\n      if (!cfg.url || typeof cfg.url !== 'string') {\n        logger.error(`MCP ${transport} transport requires a URL`);\n        return false;\n      }\n\n      // Validate URL format\n      try {\n        const parsedUrl = new URL(cfg.url);\n        // Only allow http and https protocols\n        if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {\n          logger.error(\n            `Invalid URL protocol for MCP ${transport} transport: ${parsedUrl.protocol}. Only http: and https: are allowed.`\n          );\n          return false;\n        }\n      } catch {\n        logger.error(`Invalid URL format for MCP ${transport} transport: ${cfg.url}`);\n        return false;\n      }\n    } else if (transport === 'custom') {\n      // For custom transport, validation is delegated to CustomToolExecutor\n      // The tool must exist in the configuration's tools section\n      // This will be validated at execution time when the tool is looked up\n      logger.debug(`MCP custom transport will validate tool '${cfg.method}' at execution time`);\n    } else {\n      logger.error(\n        `Invalid MCP transport: ${transport}. Must be 'stdio', 'sse', 'http', or 'custom'`\n      );\n      return false;\n    }\n\n    return true;\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>\n  ): Promise<ReviewSummary> {\n    const cfg = config as McpCheckConfig;\n\n    try {\n      // Prepare template context\n      const templateContext = {\n        pr: {\n          number: prInfo.number,\n          title: prInfo.title,\n          author: prInfo.author,\n          branch: prInfo.head,\n          base: prInfo.base,\n        },\n        files: prInfo.files,\n        fileCount: prInfo.files.length,\n        outputs: this.buildOutputContext(dependencyResults),\n        env: this.getSafeEnvironmentVariables(),\n      };\n\n      // Render method arguments if needed\n      let methodArgs = cfg.methodArgs || {};\n      if (cfg.argsTransform) {\n        const rendered = await this.liquid.parseAndRender(cfg.argsTransform, templateContext);\n        try {\n          methodArgs = JSON.parse(rendered);\n        } catch (error) {\n          logger.error(`Failed to parse argsTransform as JSON: ${error}`);\n          return {\n            issues: [\n              {\n                file: 'mcp',\n                line: 0,\n                ruleId: 'mcp/args_transform_error',\n                message: `Failed to parse argsTransform: ${error instanceof Error ? error.message : 'Unknown error'}`,\n                severity: 'error',\n                category: 'logic',\n              },\n            ],\n          };\n        }\n      }\n\n      // Create MCP client and execute method\n      const result = await this.executeMcpMethod(cfg, methodArgs, prInfo, dependencyResults);\n\n      // Apply transforms if specified\n      let finalOutput = result;\n\n      // Apply Liquid transform\n      if (cfg.transform) {\n        try {\n          const transformContext = {\n            ...templateContext,\n            output: result,\n          };\n          const rendered = await this.liquid.parseAndRender(cfg.transform, transformContext);\n          try {\n            finalOutput = JSON.parse(rendered.trim());\n          } catch {\n            finalOutput = rendered.trim();\n          }\n        } catch (error) {\n          logger.error(`Failed to apply Liquid transform: ${error}`);\n          return {\n            issues: [\n              {\n                file: 'mcp',\n                line: 0,\n                ruleId: 'mcp/transform_error',\n                message: `Failed to apply transform: ${error instanceof Error ? error.message : 'Unknown error'}`,\n                severity: 'error',\n                category: 'logic',\n              },\n            ],\n          };\n        }\n      }\n\n      // Apply JavaScript transform using secure sandbox\n      if (cfg.transform_js) {\n        try {\n          if (!this.sandbox) {\n            this.sandbox = this.createSecureSandbox();\n          }\n\n          // Build scope with all context variables\n          const scope = {\n            output: finalOutput,\n            pr: templateContext.pr,\n            files: templateContext.files,\n            outputs: templateContext.outputs,\n            env: templateContext.env,\n          };\n\n          // Compile and execute the transform in sandboxed environment\n          finalOutput = compileAndRun<unknown>(\n            this.sandbox,\n            `return (${cfg.transform_js});`,\n            scope,\n            { injectLog: true, wrapFunction: false, logPrefix: '[mcp:transform_js]' }\n          );\n        } catch (error) {\n          logger.error(`Failed to apply JavaScript transform: ${error}`);\n          return {\n            issues: [\n              {\n                file: 'mcp',\n                line: 0,\n                ruleId: 'mcp/transform_js_error',\n                message: `Failed to apply JavaScript transform: ${error instanceof Error ? error.message : 'Unknown error'}`,\n                severity: 'error',\n                category: 'logic',\n              },\n            ],\n          };\n        }\n      }\n\n      // Extract issues from output\n      const extracted = this.extractIssuesFromOutput(finalOutput);\n      if (extracted) {\n        return {\n          issues: extracted.issues,\n          ...(extracted.remainingOutput ? { output: extracted.remainingOutput } : {}),\n        } as ReviewSummary;\n      }\n\n      // Return output directly\n      return {\n        issues: [],\n        ...(finalOutput ? { output: finalOutput } : {}),\n      } as ReviewSummary;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      logger.error(`MCP check failed: ${errorMessage}`);\n\n      return {\n        issues: [\n          {\n            file: 'mcp',\n            line: 0,\n            ruleId: 'mcp/execution_error',\n            message: `MCP check failed: ${errorMessage}`,\n            severity: 'error',\n            category: 'logic',\n          },\n        ],\n      };\n    }\n  }\n\n  /**\n   * Execute an MCP method using the configured transport\n   */\n  private async executeMcpMethod(\n    config: McpCheckConfig,\n    methodArgs: Record<string, unknown>,\n    prInfo?: PRInfo,\n    dependencyResults?: Map<string, ReviewSummary>\n  ): Promise<unknown> {\n    const transport = config.transport || 'stdio';\n    const timeout = (config.timeout || 60) * 1000; // Convert to milliseconds\n\n    if (transport === 'custom') {\n      // Execute custom YAML-defined tool\n      if (!this.customToolExecutor) {\n        throw new Error(\n          'No custom tools available. Define tools in the \"tools\" section of your configuration.'\n        );\n      }\n\n      const tool = this.customToolExecutor.getTool(config.method);\n      if (!tool) {\n        throw new Error(\n          `Custom tool not found: ${config.method}. Available tools: ${this.customToolExecutor\n            .getTools()\n            .map(t => t.name)\n            .join(', ')}`\n        );\n      }\n\n      // Build context for custom tool execution\n      const context = {\n        pr: prInfo\n          ? {\n              number: prInfo.number,\n              title: prInfo.title,\n              author: prInfo.author,\n              branch: prInfo.head,\n              base: prInfo.base,\n            }\n          : undefined,\n        files: prInfo?.files,\n        outputs: this.buildOutputContext(dependencyResults),\n        env: this.getSafeEnvironmentVariables(),\n      };\n\n      return await this.customToolExecutor.execute(config.method, methodArgs, context);\n    } else if (transport === 'stdio') {\n      return await this.executeStdioMethod(config, methodArgs, timeout);\n    } else if (transport === 'sse') {\n      return await this.executeSseMethod(config, methodArgs, timeout);\n    } else if (transport === 'http') {\n      return await this.executeHttpMethod(config, methodArgs, timeout);\n    } else {\n      throw new Error(`Unsupported transport: ${transport}`);\n    }\n  }\n\n  /**\n   * Generic method to execute MCP method with any transport\n   */\n  private async executeWithTransport(\n    transport: StdioClientTransport | SSEClientTransport | StreamableHTTPClientTransport,\n    config: McpCheckConfig,\n    methodArgs: Record<string, unknown>,\n    timeout: number,\n    transportName: string\n  ): Promise<unknown> {\n    // Create client\n    const client = new Client(\n      {\n        name: 'visor-mcp-client',\n        version: '1.0.0',\n      },\n      {\n        capabilities: {},\n      }\n    );\n\n    try {\n      // Connect with timeout\n      let timeoutId: NodeJS.Timeout | undefined;\n      try {\n        await Promise.race([\n          client.connect(transport),\n          new Promise((_, reject) => {\n            timeoutId = setTimeout(() => reject(new Error('Connection timeout')), timeout);\n          }),\n        ]);\n      } finally {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n      }\n\n      logger.debug(`Connected to MCP server via ${transportName}`);\n\n      // Log session ID for HTTP transport\n      if (transport instanceof StreamableHTTPClientTransport && transport.sessionId) {\n        logger.debug(`MCP Session ID: ${transport.sessionId}`);\n      }\n\n      // List available tools (for debugging)\n      try {\n        const toolsResult = await client.listTools();\n        logger.debug(`Available MCP tools: ${JSON.stringify(toolsResult?.tools || [])}`);\n      } catch (error) {\n        logger.debug(`Could not list MCP tools: ${error}`);\n      }\n\n      // Call the tool with timeout\n      let callTimeoutId: NodeJS.Timeout | undefined;\n      try {\n        const result = await Promise.race([\n          client.callTool({\n            name: config.method,\n            arguments: methodArgs,\n          }),\n          new Promise((_, reject) => {\n            callTimeoutId = setTimeout(() => reject(new Error('Request timeout')), timeout);\n          }),\n        ]);\n\n        logger.debug(`MCP method result: ${JSON.stringify(result)}`);\n        return result;\n      } finally {\n        if (callTimeoutId) {\n          clearTimeout(callTimeoutId);\n        }\n      }\n    } finally {\n      try {\n        await client.close();\n      } catch (error) {\n        logger.debug(`Error closing MCP client: ${error}`);\n      }\n    }\n  }\n\n  /**\n   * Execute MCP method using stdio transport\n   */\n  private async executeStdioMethod(\n    config: McpCheckConfig,\n    methodArgs: Record<string, unknown>,\n    timeout: number\n  ): Promise<unknown> {\n    const transport = new StdioClientTransport({\n      command: config.command!,\n      args: config.command_args as string[] | undefined,\n      env: config.env,\n      cwd: config.workingDirectory,\n    });\n\n    return this.executeWithTransport(\n      transport,\n      config,\n      methodArgs,\n      timeout,\n      `stdio: ${config.command}`\n    );\n  }\n\n  /**\n   * Execute MCP method using SSE transport\n   */\n  private async executeSseMethod(\n    config: McpCheckConfig,\n    methodArgs: Record<string, unknown>,\n    timeout: number\n  ): Promise<unknown> {\n    const requestInit: RequestInit = {};\n    if (config.headers) {\n      requestInit.headers = EnvironmentResolver.resolveHeaders(config.headers);\n    }\n\n    const transport = new SSEClientTransport(new URL(config.url!), {\n      requestInit,\n    });\n\n    return this.executeWithTransport(transport, config, methodArgs, timeout, `SSE: ${config.url}`);\n  }\n\n  /**\n   * Execute MCP method using Streamable HTTP transport\n   */\n  private async executeHttpMethod(\n    config: McpCheckConfig,\n    methodArgs: Record<string, unknown>,\n    timeout: number\n  ): Promise<unknown> {\n    const requestInit: RequestInit = {};\n    if (config.headers) {\n      requestInit.headers = EnvironmentResolver.resolveHeaders(config.headers);\n    }\n\n    const transport = new StreamableHTTPClientTransport(new URL(config.url!), {\n      requestInit,\n      sessionId: config.sessionId,\n    });\n\n    return this.executeWithTransport(\n      transport,\n      config,\n      methodArgs,\n      timeout,\n      `Streamable HTTP: ${config.url}`\n    );\n  }\n\n  /**\n   * Build output context from dependency results\n   */\n  private buildOutputContext(\n    dependencyResults?: Map<string, ReviewSummary>\n  ): Record<string, unknown> {\n    if (!dependencyResults) {\n      return {};\n    }\n\n    const outputs: Record<string, unknown> = {};\n    for (const [checkName, result] of dependencyResults) {\n      const summary = result as ReviewSummary & { output?: unknown };\n      outputs[checkName] = summary.output !== undefined ? summary.output : summary;\n    }\n\n    return outputs;\n  }\n\n  /**\n   * Get safe environment variables\n   */\n  private getSafeEnvironmentVariables(): Record<string, string> {\n    const safeVars: Record<string, string> = {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const allowedPrefixes: string[] = []; // replaced by buildSandboxEnv\n\n    const { buildSandboxEnv } = require('../utils/env-exposure');\n    const merged = buildSandboxEnv(process.env);\n    for (const [key, value] of Object.entries(merged)) {\n      safeVars[key] = String(value);\n    }\n    safeVars['PWD'] = process.cwd();\n    return safeVars;\n  }\n\n  /**\n   * Extract issues from MCP output\n   */\n  private extractIssuesFromOutput(\n    output: unknown\n  ): { issues: ReviewIssue[]; remainingOutput: unknown } | null {\n    if (output === null || output === undefined) {\n      return null;\n    }\n\n    // If output is a string, try to parse as JSON\n    if (typeof output === 'string') {\n      try {\n        const parsed = JSON.parse(output);\n        return this.extractIssuesFromOutput(parsed);\n      } catch {\n        return null;\n      }\n    }\n\n    // If output is an array of issues\n    if (Array.isArray(output)) {\n      const issues = this.normalizeIssueArray(output);\n      if (issues) {\n        return { issues, remainingOutput: undefined };\n      }\n      return null;\n    }\n\n    // If output is an object with issues property\n    if (typeof output === 'object') {\n      const record = output as Record<string, unknown>;\n\n      if (Array.isArray(record.issues)) {\n        const issues = this.normalizeIssueArray(record.issues);\n        if (!issues) {\n          return null;\n        }\n\n        const remaining = { ...record };\n        delete (remaining as { issues?: unknown }).issues;\n\n        return {\n          issues,\n          remainingOutput: Object.keys(remaining).length > 0 ? remaining : undefined,\n        };\n      }\n\n      // Check if output itself is a single issue\n      const singleIssue = this.normalizeIssue(record);\n      if (singleIssue) {\n        return { issues: [singleIssue], remainingOutput: undefined };\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Normalize an array of issues\n   */\n  private normalizeIssueArray(values: unknown[]): ReviewIssue[] | null {\n    const normalized: ReviewIssue[] = [];\n\n    for (const value of values) {\n      const issue = this.normalizeIssue(value);\n      if (!issue) {\n        return null;\n      }\n      normalized.push(issue);\n    }\n\n    return normalized;\n  }\n\n  /**\n   * Normalize a single issue\n   */\n  private normalizeIssue(raw: unknown): ReviewIssue | null {\n    if (!raw || typeof raw !== 'object') {\n      return null;\n    }\n\n    const data = raw as Record<string, unknown>;\n\n    const message = this.toTrimmedString(\n      data.message || data.text || data.description || data.summary\n    );\n    if (!message) {\n      return null;\n    }\n\n    const allowedSeverities = new Set(['info', 'warning', 'error', 'critical']);\n    const severityRaw = this.toTrimmedString(data.severity || data.level || data.priority);\n    let severity: ReviewIssue['severity'] = 'warning';\n    if (severityRaw) {\n      const lower = severityRaw.toLowerCase();\n      if (allowedSeverities.has(lower)) {\n        severity = lower as ReviewIssue['severity'];\n      }\n    }\n\n    const allowedCategories = new Set([\n      'security',\n      'performance',\n      'style',\n      'logic',\n      'documentation',\n    ]);\n    const categoryRaw = this.toTrimmedString(data.category || data.type || data.group);\n    let category: ReviewIssue['category'] = 'logic';\n    if (categoryRaw && allowedCategories.has(categoryRaw.toLowerCase())) {\n      category = categoryRaw.toLowerCase() as ReviewIssue['category'];\n    }\n\n    const file = this.toTrimmedString(data.file || data.path || data.filename) || 'system';\n    const line = this.toNumber(data.line || data.startLine || data.lineNumber) ?? 0;\n    const endLine = this.toNumber(data.endLine || data.end_line || data.stopLine);\n    const suggestion = this.toTrimmedString(data.suggestion);\n    const replacement = this.toTrimmedString(data.replacement);\n    const ruleId = this.toTrimmedString(data.ruleId || data.rule || data.id || data.check) || 'mcp';\n\n    return {\n      file,\n      line,\n      endLine: endLine ?? undefined,\n      ruleId,\n      message,\n      severity,\n      category,\n      suggestion: suggestion || undefined,\n      replacement: replacement || undefined,\n    };\n  }\n\n  private toTrimmedString(value: unknown): string | null {\n    if (typeof value === 'string') {\n      const trimmed = value.trim();\n      return trimmed.length > 0 ? trimmed : null;\n    }\n    if (value !== null && value !== undefined && typeof value.toString === 'function') {\n      const converted = String(value).trim();\n      return converted.length > 0 ? converted : null;\n    }\n    return null;\n  }\n\n  private toNumber(value: unknown): number | null {\n    if (value === null || value === undefined) {\n      return null;\n    }\n    const num = Number(value);\n    if (Number.isFinite(num)) {\n      return Math.trunc(num);\n    }\n    return null;\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'transport',\n      'command',\n      'command_args',\n      'env',\n      'workingDirectory',\n      'url',\n      'headers',\n      'sessionId',\n      'method',\n      'methodArgs',\n      'argsTransform',\n      'transform',\n      'transform_js',\n      'timeout',\n      'depends_on',\n      'on',\n      'if',\n      'group',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // MCP SDK is now a required dependency, so always available\n    return true;\n  }\n\n  getRequirements(): string[] {\n    return ['MCP method name specified', 'Transport configuration (stdio: command, sse/http: url)'];\n  }\n}\n","/**\n * Interactive terminal prompting (minimal TTY UI)\n */\n\nimport * as readline from 'readline';\n\n// Global, process-wide guard to ensure we never open two readline prompts at once.\n// This is crucial because the engine may (due to routing) attempt to schedule\n// a second human-input step while the first is still waiting. Two concurrent\n// readline instances on the same TTY cause duplicated keystrokes and other\n// erratic behavior. We serialize prompts with a tiny async mutex.\nlet activePrompt = false;\nconst waiters: Array<() => void> = [];\n\nasync function acquirePromptLock(): Promise<void> {\n  if (!activePrompt) {\n    activePrompt = true;\n    return;\n  }\n  await new Promise<void>(resolve => waiters.push(resolve));\n  activePrompt = true;\n}\n\nfunction releasePromptLock(): void {\n  activePrompt = false;\n  const next = waiters.shift();\n  if (next) next();\n}\n\nexport interface PromptOptions {\n  /** The prompt text to display */\n  prompt: string;\n  /** Placeholder text (shown in dim color) */\n  placeholder?: string;\n  /** Allow multiline input (Ctrl+D to finish) */\n  multiline?: boolean;\n  /** Timeout in milliseconds */\n  timeout?: number;\n  /** Default value if timeout occurs */\n  defaultValue?: string;\n  /** Allow empty input */\n  allowEmpty?: boolean;\n}\n/**\n * Prompt user for input with a beautiful interactive UI\n */\nexport async function interactivePrompt(options: PromptOptions): Promise<string> {\n  await acquirePromptLock();\n  return new Promise((resolve, reject) => {\n    const dbg = process.env.VISOR_DEBUG === 'true';\n    try {\n      if (dbg) {\n        const counts: Record<string, number> = {\n          data: process.stdin.listenerCount('data'),\n          end: process.stdin.listenerCount('end'),\n          error: process.stdin.listenerCount('error'),\n          readable: process.stdin.listenerCount('readable'),\n          close: process.stdin.listenerCount('close'),\n        } as any;\n        console.error(\n          `[human-input] starting prompt: isTTY=${!!process.stdin.isTTY} active=${activePrompt} waiters=${waiters.length} listeners=${JSON.stringify(counts)}`\n        );\n      }\n    } catch {}\n    // Ensure stdin is in a sane state for a fresh interactive session\n    try {\n      if (process.stdin.isTTY && typeof (process.stdin as any).setRawMode === 'function') {\n        // We use line-based input; disable raw mode just in case\n        (process.stdin as any).setRawMode(false);\n      }\n      // Always resume stdin before creating the interface\n      process.stdin.resume();\n    } catch {}\n\n    // Ensure encoding is set for predictable behavior\n    try {\n      process.stdin.setEncoding('utf8');\n    } catch {}\n\n    let rl: readline.Interface | undefined;\n\n    const allowEmpty = options.allowEmpty ?? false;\n    const multiline = options.multiline ?? false;\n    const defaultValue = options.defaultValue;\n\n    let timeoutId: NodeJS.Timeout | undefined;\n    const cleanup = () => {\n      if (timeoutId) clearTimeout(timeoutId);\n      try {\n        rl?.removeAllListeners();\n      } catch {}\n      try {\n        rl?.close();\n      } catch {}\n      // Hardening: make sure no stray listeners remain on stdin between loops\n      // Do not blanket-remove listeners from process.stdin; a fresh readline\n      // instance will manage its own listeners. Over-removing here can leave\n      // the next interface in a bad state (no keypress events).\n      try {\n        if (process.stdin.isTTY && typeof (process.stdin as any).setRawMode === 'function') {\n          (process.stdin as any).setRawMode(false);\n        }\n      } catch {}\n      try {\n        process.stdin.pause();\n      } catch {}\n      // Release the global lock so a queued prompt (if any) may proceed\n      try {\n        releasePromptLock();\n      } catch {}\n      // If stdout/stderr were temporarily wrapped by the question handler, restore them now\n      try {\n        if ((process.stdout as any).__restoreWrites) {\n          (process.stdout as any).__restoreWrites();\n        }\n      } catch {}\n      try {\n        if ((process.stderr as any).__restoreWrites) {\n          (process.stderr as any).__restoreWrites();\n        }\n      } catch {}\n      try {\n        if (dbg) {\n          const counts: Record<string, number> = {\n            data: process.stdin.listenerCount('data'),\n            end: process.stdin.listenerCount('end'),\n            error: process.stdin.listenerCount('error'),\n            readable: process.stdin.listenerCount('readable'),\n            close: process.stdin.listenerCount('close'),\n          } as any;\n          console.error(\n            `[human-input] cleanup: isTTY=${!!process.stdin.isTTY} active=false waiters=${waiters.length} listeners=${JSON.stringify(counts)}`\n          );\n        }\n      } catch {}\n    };\n    const finish = (value: string) => {\n      cleanup();\n      resolve(value);\n    };\n\n    // Optional timeout (no default)\n    if (options.timeout && options.timeout > 0) {\n      timeoutId = setTimeout(() => {\n        cleanup();\n        if (defaultValue !== undefined) return resolve(defaultValue);\n        return reject(new Error('Input timeout'));\n      }, options.timeout);\n    }\n\n    // Print minimal header with dashed separators\n    const header: string[] = [];\n    if (options.prompt && options.prompt.trim()) header.push(options.prompt.trim());\n    if (multiline) header.push('(Ctrl+D to submit)');\n    if (options.placeholder && !multiline) header.push(options.placeholder);\n    const width = Math.max(\n      20,\n      Math.min((process.stdout && (process.stdout as any).columns) || 80, 100)\n    );\n    const dash = '-'.repeat(width);\n    try {\n      console.log('\\n' + dash);\n      if (header.length) console.log(header.join('\\n'));\n      console.log(dash);\n    } catch {}\n\n    // No echo-suppression hacks ‚Äî we fix the root cause below by using raw-mode\n    // input for single-line prompts, so the terminal never replays the line.\n\n    if (multiline) {\n      rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout,\n        terminal: true,\n      });\n      let buf = '';\n      process.stdout.write('> ');\n      rl.on('line', line => {\n        buf += (buf ? '\\n' : '') + line;\n        process.stdout.write('> ');\n      });\n      rl.on('close', () => {\n        const trimmed = buf.trim();\n        if (!trimmed && !allowEmpty && defaultValue === undefined) {\n          return reject(new Error('Empty input not allowed'));\n        }\n        return finish(trimmed || defaultValue || '');\n      });\n      rl.on('SIGINT', () => {\n        try {\n          // Print a clean newline and exit immediately with 130 (SIGINT)\n          process.stdout.write('\\n');\n        } catch {}\n        cleanup();\n        process.exit(130);\n      });\n    } else {\n      // Root cause fix: raw-mode single-line input without readline echo.\n      const readLineRaw = async (): Promise<string> => {\n        return new Promise<string>(resolveRaw => {\n          let buf = '';\n          const onData = (chunk: Buffer) => {\n            const s = chunk.toString('utf8');\n            for (let i = 0; i < s.length; i++) {\n              const ch = s[i];\n              const code = s.charCodeAt(i);\n              if (ch === '\\n' || ch === '\\r') {\n                try {\n                  process.stdout.write('\\n');\n                } catch {}\n                teardown();\n                resolveRaw(buf);\n                return;\n              }\n              if (ch === '\\b' || code === 127) {\n                if (buf.length > 0) {\n                  buf = buf.slice(0, -1);\n                  try {\n                    process.stdout.write('\\b \\b');\n                  } catch {}\n                }\n                continue;\n              }\n              if (code === 3) {\n                // Ctrl+C\n                try {\n                  process.stdout.write('\\n');\n                } catch {}\n                teardown();\n                process.exit(130);\n              }\n              if (code >= 32) {\n                buf += ch;\n                try {\n                  process.stdout.write(ch);\n                } catch {}\n              }\n            }\n          };\n          const teardown = () => {\n            try {\n              process.stdin.off('data', onData);\n            } catch {}\n            try {\n              if (process.stdin.isTTY && typeof (process.stdin as any).setRawMode === 'function') {\n                (process.stdin as any).setRawMode(false);\n              }\n            } catch {}\n          };\n          try {\n            if (process.stdin.isTTY && typeof (process.stdin as any).setRawMode === 'function') {\n              (process.stdin as any).setRawMode(true);\n            }\n          } catch {}\n          process.stdin.on('data', onData);\n          try {\n            process.stdout.write('> ');\n          } catch {}\n        });\n      };\n      (async () => {\n        const answer = await readLineRaw();\n        const trimmed = (answer || '').trim();\n        if (!trimmed && !allowEmpty && defaultValue === undefined) {\n          cleanup();\n          return reject(new Error('Empty input not allowed'));\n        }\n        return finish(trimmed || defaultValue || '');\n      })().catch(err => {\n        cleanup();\n        reject(err);\n      });\n    }\n  });\n}\n\n/**\n * Simple prompt without fancy UI (for non-TTY environments)\n */\nexport async function simplePrompt(prompt: string): Promise<string> {\n  return new Promise(resolve => {\n    const rl = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout,\n    });\n\n    rl.on('SIGINT', () => {\n      try {\n        process.stdout.write('\\n');\n      } catch {}\n      rl.close();\n      process.exit(130);\n    });\n\n    rl.question(`${prompt}\\n> `, answer => {\n      rl.close();\n      resolve(answer.trim());\n    });\n  });\n}\n","/**\n * Utilities for reading from stdin\n */\n\n/**\n * Check if stdin has data available (is being piped)\n */\nexport function isStdinAvailable(): boolean {\n  // Check if stdin is a TTY (interactive terminal)\n  // If it's not a TTY, it means data is being piped\n  return !process.stdin.isTTY;\n}\n\n/**\n * Read all data from stdin\n * @param timeout Optional timeout in milliseconds\n * @param maxSize Maximum size in bytes (default: 1MB)\n * @returns Promise that resolves with the stdin content\n */\nexport async function readStdin(timeout?: number, maxSize: number = 1024 * 1024): Promise<string> {\n  return new Promise((resolve, reject) => {\n    let data = '';\n    let timeoutId: NodeJS.Timeout | undefined;\n\n    if (timeout) {\n      timeoutId = setTimeout(() => {\n        cleanup();\n        reject(new Error(`Stdin read timeout after ${timeout}ms`));\n      }, timeout);\n    }\n\n    const cleanup = () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      process.stdin.removeListener('data', onData);\n      process.stdin.removeListener('end', onEnd);\n      process.stdin.removeListener('error', onError);\n      // Pause stdin to prevent resource leaks\n      process.stdin.pause();\n    };\n\n    const onData = (chunk: Buffer) => {\n      data += chunk.toString();\n      // Security: Prevent DoS through large input\n      if (data.length > maxSize) {\n        cleanup();\n        reject(new Error(`Input exceeds maximum size of ${maxSize} bytes`));\n      }\n    };\n\n    const onEnd = () => {\n      cleanup();\n      resolve(data.trim());\n    };\n\n    const onError = (err: Error) => {\n      cleanup();\n      reject(err);\n    };\n\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', onData);\n    process.stdin.on('end', onEnd);\n    process.stdin.on('error', onError);\n\n    // Resume stdin in case it's paused\n    process.stdin.resume();\n  });\n}\n\n/**\n * Try to read from stdin if available, otherwise return null\n * @param timeout Optional timeout in milliseconds\n * @param maxSize Maximum size in bytes (default: 1MB)\n * @returns Promise that resolves with stdin content or null if not available\n */\nexport async function tryReadStdin(\n  timeout?: number,\n  maxSize: number = 1024 * 1024\n): Promise<string | null> {\n  if (!isStdinAvailable()) {\n    return null;\n  }\n\n  try {\n    return await readStdin(timeout, maxSize);\n  } catch {\n    // If reading fails, return null\n    return null;\n  }\n}\n","import { CheckProvider, CheckProviderConfig, ExecutionContext } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { HumanInputRequest } from '../types/config';\nimport { interactivePrompt, simplePrompt } from '../utils/interactive-prompt';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { tryReadStdin } from '../utils/stdin-reader';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n/**\n * Human input check provider that pauses workflow to request user input.\n *\n * Supports four modes:\n * 1. CLI with --message argument (inline or file path)\n * 2. CLI with piped stdin\n * 3. CLI interactive mode (beautiful terminal UI)\n * 4. SDK mode with onHumanInput hook\n *\n * Example config:\n * ```yaml\n * checks:\n *   approval:\n *     type: human-input\n *     prompt: \"Do you approve? (yes/no)\"\n *     allow_empty: false\n *     timeout: 300000\n * ```\n */\nexport class HumanInputCheckProvider extends CheckProvider {\n  private liquid?: Liquid;\n  /**\n   * @deprecated Use ExecutionContext.cliMessage instead\n   * Kept for backward compatibility\n   */\n  private static cliMessage: string | undefined;\n\n  /**\n   * @deprecated Use ExecutionContext.hooks instead\n   * Kept for backward compatibility\n   */\n  private static hooks: { onHumanInput?: (request: HumanInputRequest) => Promise<string> } = {};\n\n  /**\n   * Set the CLI message value (from --message argument)\n   * @deprecated Use ExecutionContext.cliMessage instead\n   */\n  static setCLIMessage(message: string | undefined): void {\n    HumanInputCheckProvider.cliMessage = message;\n  }\n\n  /**\n   * Get the current CLI message value\n   * @deprecated Use ExecutionContext.cliMessage instead\n   */\n  static getCLIMessage(): string | undefined {\n    return HumanInputCheckProvider.cliMessage;\n  }\n\n  /**\n   * Set hooks for SDK mode\n   * @deprecated Use ExecutionContext.hooks instead\n   */\n  static setHooks(hooks: { onHumanInput?: (request: HumanInputRequest) => Promise<string> }): void {\n    HumanInputCheckProvider.hooks = hooks;\n  }\n\n  getName(): string {\n    return 'human-input';\n  }\n\n  getDescription(): string {\n    return 'Prompts for human input during workflow execution (CLI interactive or SDK hook)';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'human-input'\n    if (cfg.type !== 'human-input') {\n      return false;\n    }\n\n    // Prompt is required\n    if (!cfg.prompt || typeof cfg.prompt !== 'string') {\n      console.error('human-input check requires a \"prompt\" field');\n      return false;\n    }\n\n    return true;\n  }\n\n  /** Build a template context for Liquid rendering */\n  private buildTemplateContext(\n    prInfo: PRInfo,\n    dependencyResults?: Map<string, ReviewSummary>,\n    outputHistory?: Map<string, unknown[]>,\n    _context?: ExecutionContext\n  ): Record<string, unknown> {\n    const ctx: Record<string, unknown> = {};\n    // pr context\n    try {\n      ctx.pr = {\n        number: prInfo.number,\n        title: prInfo.title,\n        body: prInfo.body,\n        author: prInfo.author,\n        base: prInfo.base,\n        head: prInfo.head,\n        files: (prInfo.files || []).map(f => ({\n          filename: f.filename,\n          status: f.status,\n          additions: f.additions,\n          deletions: f.deletions,\n          changes: f.changes,\n        })),\n      };\n    } catch {}\n    // event + env\n    try {\n      const safeEnv = (() => {\n        try {\n          const { buildSandboxEnv } = require('../utils/env-exposure');\n          return buildSandboxEnv(process.env);\n        } catch {\n          return {} as Record<string, string>;\n        }\n      })();\n      (ctx as any).event = { event_name: (prInfo as any)?.eventType || 'manual' };\n      (ctx as any).env = safeEnv;\n    } catch {}\n    // utils helpers\n    (ctx as any).utils = {\n      now: new Date().toISOString(),\n      today: new Date().toISOString().split('T')[0],\n    };\n    // outputs: expose raw outputs from dependency results\n    const outputs: Record<string, unknown> = {};\n    const outputsRaw: Record<string, unknown> = {};\n    if (dependencyResults) {\n      for (const [name, res] of dependencyResults.entries()) {\n        const summary = res as ReviewSummary & { output?: unknown };\n        if (typeof name === 'string' && name.endsWith('-raw')) {\n          outputsRaw[name.slice(0, -4)] = summary.output !== undefined ? summary.output : summary;\n        } else {\n          outputs[name] = summary.output !== undefined ? summary.output : summary;\n        }\n      }\n    }\n    ctx.outputs = outputs;\n    (ctx as any).outputs_raw = outputsRaw;\n    // outputs_history: expose full history if available\n    const hist: Record<string, unknown[]> = {};\n    if (outputHistory) {\n      for (const [k, v] of outputHistory.entries()) hist[k] = Array.isArray(v) ? v : [];\n    }\n    (ctx as any).outputs_history = hist;\n    return ctx;\n  }\n\n  /**\n   * Check if a string looks like a file path\n   */\n  private looksLikePath(str: string): boolean {\n    return str.includes('/') || str.includes('\\\\');\n  }\n\n  /**\n   * Sanitize user input to prevent injection attacks in dependent checks\n   * Removes potentially dangerous characters while preserving useful input\n   */\n  private sanitizeInput(input: string): string {\n    // Heuristic: collapse accidental per-character duplication (\"stutter\") often caused by\n    // TTY echo races. We only apply this when most adjacent ASCII chars are doubled.\n    const collapseStutter = (s: string): string => {\n      if (!s || s.length < 4) return s;\n      let dupPairs = 0;\n      let pairs = 0;\n      for (let i = 0; i + 1 < s.length; i++) {\n        const a = s[i];\n        const b = s[i + 1];\n        if (/^[\\x20-\\x7E]$/.test(a) && /^[\\x20-\\x7E]$/.test(b)) {\n          pairs++;\n          if (a === b) dupPairs++;\n        }\n      }\n      const ratio = pairs > 0 ? dupPairs / pairs : 0;\n      if (ratio < 0.5) return s; // keep as-is unless roughly half of pairs are doubled\n      let out = '';\n      for (let i = 0; i < s.length; i++) {\n        const a = s[i];\n        const b = i + 1 < s.length ? s[i + 1] : '';\n        if (b && a === b) {\n          out += a;\n          i++; // skip the duplicate\n        } else {\n          out += a;\n        }\n      }\n      return out;\n    };\n\n    input = collapseStutter(input);\n    // Remove null bytes (C-string injection)\n    let sanitized = input.replace(/\\0/g, '');\n\n    // Remove control characters except newlines and tabs\n    sanitized = sanitized.replace(/[\\x00-\\x08\\x0B-\\x0C\\x0E-\\x1F\\x7F]/g, '');\n\n    // Limit length to prevent memory issues (100KB max)\n    const maxLength = 100 * 1024;\n    if (sanitized.length > maxLength) {\n      sanitized = sanitized.substring(0, maxLength);\n    }\n\n    return sanitized;\n  }\n\n  /**\n   * Try to read message from file if it exists\n   * Validates path to prevent directory traversal attacks\n   */\n  private async tryReadFile(filePath: string): Promise<string | null> {\n    try {\n      // Handle both absolute and relative paths\n      const absolutePath = path.isAbsolute(filePath)\n        ? filePath\n        : path.resolve(process.cwd(), filePath);\n\n      // Normalize path to resolve .. and . components\n      const normalizedPath = path.normalize(absolutePath);\n\n      // Security: Prevent path traversal attacks\n      // Only allow files within current working directory or its subdirectories\n      const cwd = process.cwd();\n      if (!normalizedPath.startsWith(cwd + path.sep) && normalizedPath !== cwd) {\n        // Path is outside working directory\n        return null;\n      }\n\n      // Use async file access check instead of sync existsSync\n      try {\n        await fs.promises.access(normalizedPath, fs.constants.R_OK);\n        const stats = await fs.promises.stat(normalizedPath);\n\n        // Only read regular files, not directories or special files\n        if (!stats.isFile()) {\n          return null;\n        }\n\n        const content = await fs.promises.readFile(normalizedPath, 'utf-8');\n        return content.trim();\n      } catch {\n        // File doesn't exist or isn't readable\n        return null;\n      }\n    } catch {\n      // If file read fails, treat as literal string\n    }\n    return null;\n  }\n\n  /**\n   * Get user input through various methods\n   */\n  private async getUserInput(\n    checkName: string,\n    config: CheckProviderConfig,\n    context?: ExecutionContext\n  ): Promise<string> {\n    // Test runner mock support: if a mock is provided for this step, use it\n    try {\n      const mockVal = context?.hooks?.mockForStep?.(checkName);\n      if (mockVal !== undefined && mockVal !== null) {\n        const s = String(mockVal);\n        return s;\n      }\n    } catch {}\n    const prompt = (config.prompt as string) || 'Please provide input:';\n    const placeholder = (config.placeholder as string | undefined) || 'Enter your response...';\n    const allowEmpty = (config.allow_empty as boolean | undefined) ?? false;\n    const multiline = (config.multiline as boolean | undefined) ?? false;\n    const timeout = config.timeout ? config.timeout * 1000 : undefined; // Convert to ms\n    const defaultValue = config.default as string | undefined;\n\n    // In test/CI modes, never block for input. Use default or empty string.\n    const testMode = String(process.env.VISOR_TEST_MODE || '').toLowerCase() === 'true';\n    const ciMode =\n      String(process.env.CI || '').toLowerCase() === 'true' ||\n      String(process.env.GITHUB_ACTIONS || '').toLowerCase() === 'true';\n    if (testMode || ciMode) {\n      const val = (config.default as string | undefined) || '';\n      return val;\n    }\n\n    // Get cliMessage from context (new way) or static property (backward compat)\n    const cliMessage = context?.cliMessage ?? HumanInputCheckProvider.cliMessage;\n\n    // Priority 1: Check for --message CLI argument\n    if (cliMessage !== undefined) {\n      const message = cliMessage;\n\n      // Check if it looks like a path and try to read the file\n      if (this.looksLikePath(message)) {\n        const fileContent = await this.tryReadFile(message);\n        if (fileContent !== null) {\n          return fileContent;\n        }\n      }\n\n      // Otherwise, use as literal message\n      return message;\n    }\n\n    // Priority 2: Check for piped stdin\n    const stdinInput = await tryReadStdin(timeout);\n    if (stdinInput !== null && stdinInput.length > 0) {\n      return stdinInput;\n    }\n\n    // Priority 3: SDK hook mode\n    // Get hooks from context (new way) or static property (backward compat)\n    const hooks = context?.hooks ?? HumanInputCheckProvider.hooks;\n\n    if (hooks?.onHumanInput) {\n      const request: HumanInputRequest = {\n        checkId: checkName,\n        prompt,\n        placeholder,\n        allowEmpty,\n        multiline,\n        timeout,\n        default: defaultValue,\n      };\n\n      try {\n        const result = await hooks.onHumanInput(request);\n        return result;\n      } catch (error) {\n        throw new Error(\n          `Hook onHumanInput failed: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    // Priority 4: Interactive terminal prompt (if TTY available)\n    if (process.stdin.isTTY) {\n      try {\n        const result = await interactivePrompt({\n          prompt,\n          placeholder,\n          multiline,\n          timeout,\n          defaultValue,\n          allowEmpty,\n        });\n        return result;\n      } catch (error) {\n        throw new Error(\n          `Interactive prompt failed: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    // Priority 5: Simple prompt (fallback for non-TTY)\n    try {\n      const result = await simplePrompt(prompt);\n      if (!result && !allowEmpty && !defaultValue) {\n        throw new Error('Empty input not allowed');\n      }\n      return result || defaultValue || '';\n    } catch (error) {\n      throw new Error(\n        `Simple prompt failed: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  async execute(\n    _prInfo: PRInfo,\n    config: CheckProviderConfig,\n    _dependencyResults?: Map<string, ReviewSummary>,\n    context?: ExecutionContext\n  ): Promise<ReviewSummary> {\n    const checkName = config.checkName || 'human-input';\n\n    try {\n      // Render Liquid templates in prompt/placeholder if any\n      try {\n        this.liquid =\n          this.liquid || createExtendedLiquid({ strictVariables: false, strictFilters: false });\n        const tctx = this.buildTemplateContext(\n          _prInfo,\n          _dependencyResults,\n          (config as any).__outputHistory as Map<string, unknown[]> | undefined,\n          context\n        );\n        if (typeof config.prompt === 'string') {\n          let rendered = await this.liquid.parseAndRender(config.prompt, tctx);\n          // If Liquid markers remain (e.g., due to nested/guarded templates), try a second pass\n          if (/\\{\\{|\\{%/.test(rendered)) {\n            try {\n              rendered = await this.liquid.parseAndRender(rendered, tctx);\n            } catch {}\n          }\n          // Expose the final rendered prompt to the test runner (like AI provider does)\n          try {\n            const stepName = (config as any).checkName || 'unknown';\n            context?.hooks?.onPromptCaptured?.({\n              step: String(stepName),\n              provider: 'human-input',\n              prompt: rendered,\n            });\n          } catch {}\n          config = { ...config, prompt: rendered };\n        }\n        if (typeof config.placeholder === 'string') {\n          let ph = await this.liquid.parseAndRender(config.placeholder as string, tctx);\n          if (/\\{\\{|\\{%/.test(ph)) {\n            try {\n              ph = await this.liquid.parseAndRender(ph, tctx);\n            } catch {}\n          }\n          (config as any).placeholder = ph;\n        }\n      } catch (e) {\n        // Always show Liquid errors with a helpful snippet and caret\n        const err: any = e || {};\n        const raw = String((config as any)?.prompt || '');\n        const lines = raw.split(/\\r?\\n/);\n        const lineNum: number = Number(err.line || err?.token?.line || err?.location?.line || 0);\n        const colNum: number = Number(err.col || err?.token?.col || err?.location?.col || 0);\n        let snippet = '';\n        if (lineNum > 0) {\n          const start = Math.max(1, lineNum - 3);\n          const end = Math.max(lineNum + 2, lineNum);\n          const width = String(end).length;\n          for (let i = start; i <= Math.min(end, lines.length); i++) {\n            const ln = `${String(i).padStart(width, ' ')} | ${lines[i - 1] ?? ''}`;\n            snippet += ln + '\\n';\n            if (i === lineNum) {\n              const caretPad = ' '.repeat(Math.max(0, colNum > 1 ? colNum - 1 : 0) + width + 3);\n              snippet += caretPad + '^\\n';\n            }\n          }\n        }\n        try {\n          console.error(\n            `‚ö†Ô∏è  human-input: Liquid render failed: ${\n              e instanceof Error ? e.message : String(e)\n            }\\n${snippet}`\n          );\n        } catch {}\n        // Continue with raw strings as a fallback\n      }\n      // Get user input (pass context for non-static state)\n      const userInput = await this.getUserInput(checkName, config, context);\n\n      // Sanitize input to prevent injection attacks in dependent checks\n      const sanitizedInput = this.sanitizeInput(userInput);\n\n      // Return structured output with timestamp for consistent history/merging\n      return {\n        issues: [],\n        output: { text: sanitizedInput, ts: Date.now() },\n      } as ReviewSummary & { output: { text: string; ts: number } };\n    } catch (error) {\n      // If there's an error getting input, return an error issue\n      return {\n        issues: [\n          {\n            file: '',\n            line: 0,\n            ruleId: 'human-input-error',\n            message: `Failed to get user input: ${\n              error instanceof Error ? error.message : String(error)\n            }`,\n            severity: 'error',\n            category: 'logic',\n          },\n        ],\n      };\n    }\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'prompt',\n      'placeholder',\n      'allow_empty',\n      'multiline',\n      'timeout',\n      'default',\n      'depends_on',\n      'on',\n      'if',\n      'group',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // Human input provider is always available\n    // It will fall back to simple prompts if interactive mode isn't available\n    return true;\n  }\n\n  getRequirements(): string[] {\n    return [\n      'No external dependencies required',\n      'Works in CLI mode with --message argument, piped stdin, or interactive prompts',\n      'SDK mode requires onHumanInput hook to be configured',\n    ];\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { Liquid } from 'liquidjs';\nimport Sandbox from '@nyariv/sandboxjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { logger } from '../logger';\nimport { MemoryStore } from '../memory-store';\nimport { createSecureSandbox, compileAndRun } from '../utils/sandbox';\nimport { buildProviderTemplateContext } from '../utils/template-context';\nimport { createSyncMemoryOps } from '../utils/script-memory-ops';\n\n/**\n * Provider that executes JavaScript in a secure sandbox using\n * a first-class step: `type: 'script'` + `content: | ...`.\n */\nexport class ScriptCheckProvider extends CheckProvider {\n  private liquid: Liquid;\n\n  constructor() {\n    super();\n    this.liquid = createExtendedLiquid({\n      strictVariables: false,\n      strictFilters: false,\n    });\n  }\n\n  private createSecureSandbox(): Sandbox {\n    return createSecureSandbox();\n  }\n\n  getName(): string {\n    return 'script';\n  }\n\n  getDescription(): string {\n    return 'Execute JavaScript with access to PR context, dependency outputs, and memory.';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') return false;\n    const cfg = config as CheckProviderConfig & { content?: string };\n    if (typeof cfg.content !== 'string') return false;\n    const trimmed = cfg.content.trim();\n    if (trimmed.length === 0) return false;\n    try {\n      const bytes = Buffer.byteLength(cfg.content, 'utf8');\n      if (bytes > 1024 * 1024) return false; // 1MB cap\n    } catch {}\n    if (cfg.content.indexOf('\\u0000') >= 0) return false;\n    return true;\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig & { content?: string },\n    dependencyResults?: Map<string, ReviewSummary>,\n    _sessionInfo?: {\n      parentSessionId?: string;\n      reuseSession?: boolean;\n    } & import('./check-provider.interface').ExecutionContext\n  ): Promise<ReviewSummary> {\n    const script = String(config.content || '');\n    const memoryStore = MemoryStore.getInstance();\n    const ctx = buildProviderTemplateContext(\n      prInfo,\n      dependencyResults,\n      memoryStore,\n      (config as any).__outputHistory as Map<string, unknown[]> | undefined,\n      (_sessionInfo as any)?.stageHistoryBase as Record<string, number> | undefined,\n      { attachMemoryReadHelpers: false }\n    );\n    try {\n      if (process.env.VISOR_DEBUG === 'true') {\n        const hist: any = (ctx as any).outputs_history || {};\n        const len = Array.isArray(hist['refine']) ? hist['refine'].length : 0;\n\n        console.error(`[script] history.refine.len=${len}`);\n      }\n    } catch {}\n\n    // Attach synchronous memory ops consistent with memory provider\n    const { ops, needsSave } = createSyncMemoryOps(memoryStore);\n    (ctx as any).memory = ops as unknown as Record<string, unknown>;\n\n    // Evaluate the script in a secure sandbox (per-execution instance)\n    const sandbox = this.createSecureSandbox();\n    let result: unknown;\n    try {\n      result = compileAndRun<unknown>(\n        sandbox,\n        script,\n        { ...ctx },\n        {\n          injectLog: true,\n          wrapFunction: true,\n          logPrefix: '[script]',\n        }\n      );\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : 'Unknown error';\n      logger.error(`[script] execution error: ${msg}`);\n      return {\n        issues: [\n          {\n            file: 'script',\n            line: 0,\n            ruleId: 'script/execution_error',\n            message: msg,\n            severity: 'error',\n            category: 'logic',\n          },\n        ],\n        output: null,\n      } as ReviewSummary;\n    }\n\n    // Persist file-backed memory once if needed\n    try {\n      if (\n        needsSave() &&\n        memoryStore.getConfig().storage === 'file' &&\n        memoryStore.getConfig().auto_save\n      ) {\n        await memoryStore.save();\n      }\n    } catch (e) {\n      logger.warn(`[script] memory save failed: ${e instanceof Error ? e.message : String(e)}`);\n    }\n\n    try {\n      if (process.env.VISOR_DEBUG === 'true') {\n        const name = String((config as any).checkName || '');\n        const t = typeof result;\n        console.error(\n          `[script-return] ${name} outputType=${t} hasArray=${Array.isArray(result)} hasObj=${result && typeof result === 'object'}`\n        );\n      }\n    } catch {}\n    const out: any = { issues: [], output: result } as ReviewSummary & { output: unknown };\n    try {\n      (out as any).__histTracked = true;\n    } catch {}\n    return out;\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'content',\n      'depends_on',\n      'group',\n      'on',\n      'if',\n      'fail_if',\n      'on_fail',\n      'on_success',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    return true;\n  }\n\n  getRequirements(): string[] {\n    return ['No external dependencies required'];\n  }\n\n  // No local buildTemplateContext; uses shared builder above\n}\n","/**\n * Workflow executor for running workflow definitions\n */\n\nimport {\n  WorkflowDefinition,\n  WorkflowExecutionContext,\n  WorkflowStep,\n  WorkflowInputMapping,\n  WorkflowExecutionOptions,\n} from './types/workflow';\nimport { PRInfo } from './pr-analyzer';\nimport { ReviewSummary } from './reviewer';\nimport { CheckProviderRegistry } from './providers/check-provider-registry';\nimport { CheckProviderConfig, ExecutionContext } from './providers/check-provider.interface';\nimport { DependencyResolver } from './dependency-resolver';\nimport { logger } from './logger';\nimport { createSecureSandbox, compileAndRun } from './utils/sandbox';\nimport { Liquid } from 'liquidjs';\n\n/**\n * Workflow execution result\n */\nexport interface WorkflowExecutionResult {\n  success: boolean;\n  score?: number;\n  confidence?: 'high' | 'medium' | 'low';\n  issues?: any[];\n  comments?: any[];\n  output?: Record<string, unknown>;\n  status: 'completed' | 'failed' | 'skipped';\n  duration?: number;\n  error?: string;\n  stepSummaries?: Array<{\n    stepId: string;\n    status: 'success' | 'failed' | 'skipped';\n    issues?: any[];\n    output?: unknown;\n  }>;\n}\n\n/**\n * Execution options passed to workflow executor\n */\ninterface WorkflowRunOptions {\n  prInfo: PRInfo;\n  dependencyResults?: Map<string, ReviewSummary>;\n  context?: ExecutionContext;\n  options?: WorkflowExecutionOptions;\n}\n\n/**\n * Executes workflow definitions\n */\nexport class WorkflowExecutor {\n  private providerRegistry: CheckProviderRegistry | null = null;\n  private liquid: Liquid;\n\n  constructor() {\n    // Don't call CheckProviderRegistry.getInstance() here to avoid circular dependency\n    // during registry initialization (since WorkflowCheckProvider is registered in the registry)\n    this.liquid = new Liquid();\n  }\n\n  /**\n   * Lazy-load the provider registry to avoid circular dependency during initialization\n   */\n  private getProviderRegistry(): CheckProviderRegistry {\n    if (!this.providerRegistry) {\n      this.providerRegistry = CheckProviderRegistry.getInstance();\n    }\n    return this.providerRegistry;\n  }\n\n  /**\n   * Execute a workflow\n   */\n  public async execute(\n    workflow: WorkflowDefinition,\n    executionContext: WorkflowExecutionContext,\n    runOptions: WorkflowRunOptions\n  ): Promise<WorkflowExecutionResult> {\n    const startTime = Date.now();\n    executionContext.metadata = {\n      startTime,\n      status: 'running',\n    };\n\n    try {\n      // Resolve step execution order\n      const executionOrder = this.resolveExecutionOrder(workflow);\n      logger.debug(`Workflow ${workflow.id} execution order: ${executionOrder.join(' -> ')}`);\n\n      // Execute steps in order\n      const stepResults = new Map<string, ReviewSummary>();\n      const stepSummaries: Array<{\n        stepId: string;\n        status: 'success' | 'failed' | 'skipped';\n        issues?: any[];\n        output?: unknown;\n      }> = [];\n\n      for (const stepId of executionOrder) {\n        const step = workflow.steps[stepId];\n\n        // Check if step should be executed (evaluate 'if' condition)\n        if (step.if) {\n          const shouldRun = this.evaluateCondition(step.if, {\n            inputs: executionContext.inputs,\n            outputs: Object.fromEntries(stepResults),\n            pr: runOptions.prInfo,\n          });\n\n          if (!shouldRun) {\n            logger.info(`Skipping step '${stepId}' due to condition: ${step.if}`);\n            stepSummaries.push({\n              stepId,\n              status: 'skipped',\n            });\n            continue;\n          }\n        }\n\n        // Prepare step configuration\n        const stepConfig = await this.prepareStepConfig(\n          step,\n          stepId,\n          executionContext,\n          stepResults,\n          workflow\n        );\n\n        // Execute the step\n        try {\n          logger.info(`Executing workflow step '${stepId}'`);\n          // Extend context with workflow inputs\n          const stepContext: ExecutionContext = {\n            ...runOptions.context,\n            workflowInputs: executionContext.inputs,\n          };\n          const result = await this.executeStep(\n            stepConfig,\n            runOptions.prInfo,\n            stepResults,\n            stepContext\n          );\n\n          stepResults.set(stepId, result);\n          stepSummaries.push({\n            stepId,\n            status: 'success',\n            issues: result.issues,\n            output: (result as any).output,\n          });\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : String(error);\n          logger.error(`Step '${stepId}' failed: ${errorMessage}`);\n\n          stepSummaries.push({\n            stepId,\n            status: 'failed',\n            output: { error: errorMessage },\n          });\n\n          if (!runOptions.options?.continueOnError) {\n            throw new Error(`Workflow step '${stepId}' failed: ${errorMessage}`);\n          }\n        }\n      }\n\n      // Compute workflow outputs\n      const outputs = await this.computeOutputs(\n        workflow,\n        executionContext,\n        stepResults,\n        runOptions.prInfo\n      );\n      executionContext.outputs = outputs;\n\n      // Aggregate results\n      const aggregated = this.aggregateResults(stepResults);\n\n      const endTime = Date.now();\n      executionContext.metadata.endTime = endTime;\n      executionContext.metadata.duration = endTime - startTime;\n      executionContext.metadata.status = 'completed';\n\n      return {\n        success: true,\n        score: aggregated.score,\n        confidence: aggregated.confidence,\n        issues: aggregated.issues,\n        comments: aggregated.comments,\n        output: outputs,\n        status: 'completed',\n        duration: endTime - startTime,\n        stepSummaries,\n      };\n    } catch (error) {\n      const endTime = Date.now();\n      executionContext.metadata.endTime = endTime;\n      executionContext.metadata.duration = endTime - startTime;\n      executionContext.metadata.status = 'failed';\n      executionContext.metadata.error = error instanceof Error ? error.message : String(error);\n\n      return {\n        success: false,\n        status: 'failed',\n        duration: endTime - startTime,\n        error: error instanceof Error ? error.message : String(error),\n      };\n    }\n  }\n\n  /**\n   * Resolve step execution order based on dependencies\n   */\n  private resolveExecutionOrder(workflow: WorkflowDefinition): string[] {\n    // Build dependency map\n    const dependencies: Record<string, string[]> = {};\n    for (const [stepId, step] of Object.entries(workflow.steps)) {\n      dependencies[stepId] = step.depends_on || [];\n    }\n\n    // Use static DependencyResolver\n    const graph = DependencyResolver.buildDependencyGraph(dependencies);\n\n    if (graph.hasCycles) {\n      throw new Error(\n        `Circular dependency detected in workflow steps: ${graph.cycleNodes?.join(' -> ')}`\n      );\n    }\n\n    // Flatten execution groups to get linear order\n    const order: string[] = [];\n    for (const group of graph.executionOrder) {\n      order.push(...group.parallel);\n    }\n\n    return order;\n  }\n\n  /**\n   * Prepare step configuration with input mappings\n   */\n  private async prepareStepConfig(\n    step: WorkflowStep,\n    stepId: string,\n    executionContext: WorkflowExecutionContext,\n    stepResults: Map<string, ReviewSummary>,\n    workflow: WorkflowDefinition\n  ): Promise<CheckProviderConfig> {\n    const config: CheckProviderConfig = {\n      ...step,\n      type: step.type || 'ai',\n      checkName: `${executionContext.instanceId}:${stepId}`,\n    };\n\n    // Process input mappings\n    if (step.inputs) {\n      for (const [inputName, mapping] of Object.entries(step.inputs)) {\n        const value = await this.resolveInputMapping(\n          mapping,\n          executionContext,\n          stepResults,\n          workflow\n        );\n        (config as any)[inputName] = value;\n      }\n    }\n\n    return config;\n  }\n\n  /**\n   * Resolve input mapping to actual value\n   */\n  private async resolveInputMapping(\n    mapping: string | WorkflowInputMapping,\n    executionContext: WorkflowExecutionContext,\n    stepResults: Map<string, ReviewSummary>,\n    _workflow: WorkflowDefinition\n  ): Promise<unknown> {\n    // Simple string mapping - treat as parameter reference\n    if (typeof mapping === 'string') {\n      return executionContext.inputs[mapping];\n    }\n\n    // Complex mapping\n    if (typeof mapping === 'object' && mapping !== null && 'source' in mapping) {\n      const typedMapping = mapping as WorkflowInputMapping;\n\n      switch (typedMapping.source) {\n        case 'param':\n          // Reference to workflow input parameter\n          return executionContext.inputs[String(typedMapping.value)];\n\n        case 'step':\n          // Reference to another step's output\n          if (!typedMapping.stepId) {\n            throw new Error('Step input mapping requires stepId');\n          }\n          const stepResult = stepResults.get(typedMapping.stepId);\n          if (!stepResult) {\n            throw new Error(`Step '${typedMapping.stepId}' has not been executed yet`);\n          }\n          const output = (stepResult as any).output;\n          if (typedMapping.outputParam && output) {\n            return output[typedMapping.outputParam];\n          }\n          return output;\n\n        case 'constant':\n          // Constant value\n          return typedMapping.value;\n\n        case 'expression':\n          // JavaScript expression\n          if (!typedMapping.expression) {\n            throw new Error('Expression mapping requires expression field');\n          }\n          const sandbox = createSecureSandbox();\n          return compileAndRun(\n            sandbox,\n            typedMapping.expression,\n            {\n              inputs: executionContext.inputs,\n              outputs: Object.fromEntries(stepResults),\n              steps: Object.fromEntries(\n                Array.from(stepResults.entries()).map(([id, result]) => [\n                  id,\n                  (result as any).output,\n                ])\n              ),\n            },\n            { injectLog: true, logPrefix: 'workflow.input.expression' }\n          );\n\n        default:\n          throw new Error(`Unknown input mapping source: ${typedMapping.source}`);\n      }\n    }\n\n    // Handle Liquid template in mapping\n    if (typeof mapping === 'object' && mapping !== null && 'template' in mapping) {\n      const typedMapping = mapping as WorkflowInputMapping;\n      if (typedMapping.template) {\n        return await this.liquid.parseAndRender(typedMapping.template, {\n          inputs: executionContext.inputs,\n          outputs: Object.fromEntries(stepResults),\n        });\n      }\n    }\n\n    // Return as-is\n    return mapping;\n  }\n\n  /**\n   * Execute a single step\n   */\n  private async executeStep(\n    config: CheckProviderConfig,\n    prInfo: PRInfo,\n    dependencyResults: Map<string, ReviewSummary>,\n    context?: ExecutionContext\n  ): Promise<ReviewSummary> {\n    const provider = await this.getProviderRegistry().getProvider(config.type);\n    if (!provider) {\n      throw new Error(`Provider '${config.type}' not found`);\n    }\n\n    return await provider.execute(prInfo, config, dependencyResults, context);\n  }\n\n  /**\n   * Compute workflow outputs\n   */\n  private async computeOutputs(\n    workflow: WorkflowDefinition,\n    executionContext: WorkflowExecutionContext,\n    stepResults: Map<string, ReviewSummary>,\n    prInfo: PRInfo\n  ): Promise<Record<string, unknown>> {\n    const outputs: Record<string, unknown> = {};\n\n    if (!workflow.outputs) {\n      return outputs;\n    }\n\n    for (const output of workflow.outputs) {\n      if (output.value_js) {\n        // JavaScript expression\n        const sandbox = createSecureSandbox();\n        outputs[output.name] = compileAndRun(\n          sandbox,\n          output.value_js,\n          {\n            inputs: executionContext.inputs,\n            steps: Object.fromEntries(\n              Array.from(stepResults.entries()).map(([id, result]) => [id, (result as any).output])\n            ),\n            outputs: Object.fromEntries(stepResults),\n            pr: prInfo,\n          },\n          { injectLog: true, logPrefix: `workflow.output.${output.name}` }\n        );\n      } else if (output.value) {\n        // Liquid template\n        outputs[output.name] = await this.liquid.parseAndRender(output.value, {\n          inputs: executionContext.inputs,\n          steps: Object.fromEntries(\n            Array.from(stepResults.entries()).map(([id, result]) => [id, (result as any).output])\n          ),\n          outputs: Object.fromEntries(stepResults),\n          pr: prInfo,\n        });\n      }\n    }\n\n    return outputs;\n  }\n\n  /**\n   * Aggregate results from all steps\n   */\n  private aggregateResults(stepResults: Map<string, ReviewSummary>): {\n    score: number;\n    confidence: 'high' | 'medium' | 'low';\n    issues: any[];\n    comments: any[];\n  } {\n    let totalScore = 0;\n    let scoreCount = 0;\n    const allIssues: any[] = [];\n    const allComments: any[] = [];\n    let minConfidence: 'high' | 'medium' | 'low' = 'high';\n\n    for (const result of stepResults.values()) {\n      const extResult = result as any;\n      if (typeof extResult.score === 'number') {\n        totalScore += extResult.score;\n        scoreCount++;\n      }\n\n      if (result.issues) {\n        allIssues.push(...result.issues);\n      }\n\n      if (extResult.comments) {\n        allComments.push(...extResult.comments);\n      }\n\n      if (extResult.confidence) {\n        if (\n          extResult.confidence === 'low' ||\n          (extResult.confidence === 'medium' && minConfidence === 'high')\n        ) {\n          minConfidence = extResult.confidence;\n        }\n      }\n    }\n\n    return {\n      score: scoreCount > 0 ? Math.round(totalScore / scoreCount) : 0,\n      confidence: minConfidence,\n      issues: allIssues,\n      comments: allComments,\n    };\n  }\n\n  /**\n   * Evaluate a condition expression\n   */\n  private evaluateCondition(condition: string, context: any): boolean {\n    try {\n      const sandbox = createSecureSandbox();\n      const result = compileAndRun(sandbox, condition, context, {\n        injectLog: true,\n        logPrefix: 'workflow.condition',\n      });\n      return Boolean(result);\n    } catch (error) {\n      logger.warn(`Failed to evaluate condition '${condition}': ${error}`);\n      return false;\n    }\n  }\n}\n","/**\n * Workflow Projection - Convert WorkflowDefinition to DependencyGraph\n *\n * This module handles projecting workflow definitions into dependency graphs\n * that can be executed by the state machine engine.\n */\n\nimport type { WorkflowDefinition } from '../types/workflow';\nimport type { CheckMetadata } from '../types/engine';\nimport type { VisorConfig } from '../types/config';\nimport { logger } from '../logger';\n\n/**\n * Project a workflow definition into a dependency graph structure\n * that can be executed by the state machine\n */\nexport function projectWorkflowToGraph(\n  workflow: WorkflowDefinition,\n  workflowInputs: Record<string, unknown>,\n  parentCheckId: string\n): {\n  config: VisorConfig;\n  checks: Record<string, CheckMetadata>;\n} {\n  if (!workflow.steps || Object.keys(workflow.steps).length === 0) {\n    throw new Error(`Workflow '${workflow.id}' has no steps`);\n  }\n\n  // Build a pseudo-config that represents the workflow as checks\n  const checks: Record<string, any> = {};\n  const checksMetadata: Record<string, CheckMetadata> = {};\n\n  for (const [stepId, step] of Object.entries(workflow.steps)) {\n    // Create a scoped check ID for this workflow step\n    const scopedCheckId = `${parentCheckId}:${stepId}`;\n\n    // Build check configuration from workflow step\n    checks[scopedCheckId] = {\n      type: step.type || 'ai',\n      ...step,\n      // Store workflow inputs in the check config so they're accessible\n      workflowInputs,\n      // Mark this as a workflow step\n      _workflowStep: true,\n      _workflowId: workflow.id,\n      _stepId: stepId,\n    };\n\n    // Build check metadata\n    checksMetadata[scopedCheckId] = {\n      tags: step.tags || workflow.tags || [],\n      triggers: step.on || workflow.on || [],\n      group: step.group,\n      providerType: step.type || 'ai',\n      dependencies: (step.depends_on || []).map(dep => `${parentCheckId}:${dep}`),\n    };\n  }\n\n  // Create a synthetic config for this workflow\n  const config: VisorConfig = {\n    checks,\n    version: '1.0',\n    output: {\n      pr_comment: {\n        format: 'table',\n        group_by: 'check',\n        collapse: false,\n      },\n    },\n  };\n\n  if ((logger as any).isDebugEnabled?.()) {\n    logger.debug(\n      `[WorkflowProjection] Projected workflow '${workflow.id}' with ${Object.keys(checks).length} steps`\n    );\n  }\n\n  return { config, checks: checksMetadata };\n}\n\n/**\n * Validate workflow depth to prevent infinite recursion\n */\nexport function validateWorkflowDepth(\n  currentDepth: number,\n  maxDepth: number,\n  workflowId: string\n): void {\n  if (currentDepth >= maxDepth) {\n    throw new Error(\n      `Workflow nesting depth limit exceeded (${maxDepth}) for workflow '${workflowId}'. ` +\n        `This may indicate a circular workflow reference or excessive nesting.`\n    );\n  }\n}\n\n/**\n * Build a scoped path for workflow steps\n */\nexport function buildWorkflowScope(\n  parentScope: Array<{ check: string; index: number }> | undefined,\n  workflowCheckId: string,\n  stepId: string,\n  foreachIndex?: number\n): Array<{ check: string; index: number }> {\n  const scope = parentScope ? [...parentScope] : [];\n  scope.push({\n    check: `${workflowCheckId}:${stepId}`,\n    index: foreachIndex ?? 0,\n  });\n  return scope;\n}\n\n/**\n * Extract parent scope from a scoped check ID\n */\nexport function extractParentScope(\n  scopedCheckId: string\n): { parentCheckId: string; stepId: string } | null {\n  const lastColonIndex = scopedCheckId.lastIndexOf(':');\n  if (lastColonIndex === -1) {\n    return null; // Not a scoped check\n  }\n\n  return {\n    parentCheckId: scopedCheckId.substring(0, lastColonIndex),\n    stepId: scopedCheckId.substring(lastColonIndex + 1),\n  };\n}\n\n/**\n * Check if a check ID represents a workflow step\n */\nexport function isWorkflowStep(checkId: string): boolean {\n  return checkId.includes(':');\n}\n\n/**\n * Get the workflow ID from a scoped check ID\n */\nexport function getWorkflowIdFromScope(scopedCheckId: string): string | null {\n  const parts = scopedCheckId.split(':');\n  if (parts.length >= 2) {\n    return parts[0]; // First part is the parent workflow check ID\n  }\n  return null;\n}\n","/**\n * Init State Handler\n *\n * Responsibilities:\n * - Validate configuration\n * - Initialize services (journal, memory, GitHub checks)\n * - Transition to PlanReady\n */\n\nimport type { EngineContext, RunState, EngineState } from '../../types/engine';\nimport { logger } from '../../logger';\n\nexport async function handleInit(\n  context: EngineContext,\n  state: RunState,\n  transition: (newState: EngineState) => void\n): Promise<void> {\n  if (context.debug) {\n    logger.info('[Init] Initializing state machine...');\n  }\n\n  // Validate configuration\n  if (!context.config) {\n    throw new Error('Configuration is required');\n  }\n\n  // Initialize memory store if needed\n  if (context.memory) {\n    await context.memory.initialize();\n  }\n\n  // Initialize GitHub checks if configured\n  if (context.gitHubChecks) {\n    // GitHub check initialization happens in the main engine\n    // We just validate it's available here\n    if (context.debug) {\n      logger.info('[Init] GitHub checks service available');\n    }\n  }\n\n  // Reset journal for this session\n  if (context.debug) {\n    logger.info(`[Init] Session ID: ${context.sessionId}`);\n  }\n\n  // Transition to PlanReady\n  transition('PlanReady');\n}\n","/**\n * PlanReady State Handler\n *\n * Responsibilities:\n * - Build dependency graph using DependencyResolver\n * - Validate graph (check for cycles)\n * - Compute check metadata (tags, sessions, triggers)\n * - Transition to WavePlanning\n */\n\nimport type { EngineContext, RunState, EngineState } from '../../types/engine';\nimport { DependencyResolver } from '../../dependency-resolver';\nimport { logger } from '../../logger';\n\nexport async function handlePlanReady(\n  context: EngineContext,\n  state: RunState,\n  transition: (newState: EngineState) => void\n): Promise<void> {\n  if (context.debug) {\n    logger.info('[PlanReady] Building dependency graph...');\n    if (context.requestedChecks) {\n      logger.info(`[PlanReady] Requested checks: ${context.requestedChecks.join(', ')}`);\n    }\n    if (context.config.tag_filter) {\n      logger.info(`[PlanReady] Tag filter: include=${JSON.stringify(context.config.tag_filter.include)}, exclude=${JSON.stringify(context.config.tag_filter.exclude)}`);\n    } else {\n      logger.info('[PlanReady] No tag filter specified - will include only untagged checks');\n    }\n  }\n\n  // Filter checks based on requested checks list, event triggers, and tags BEFORE building dependency graph\n  //\n  // Filtering order (matches legacy engine):\n  // 1. Explicit check list (requestedChecks) - if provided, expand with transitive dependencies first\n  // 2. Event filtering: Only include checks where:\n  //    - checkConfig.on is undefined (runs on any event), OR\n  //    - checkConfig.on includes context.event\n  // 3. Tag filtering (matches legacy engine behavior):\n  //    - When no tag filter is specified, include only untagged checks by default\n  //    - Tagged checks are opt-in unless tag_filter is provided\n  //    - If exclude tags specified, exclude checks with any matching tag\n  //    - If include tags specified, include checks with at least one matching tag OR untagged checks\n  const eventTrigger = context.event;\n  const tagFilter = context.config.tag_filter;\n\n  // Expand requested checks with transitive dependencies (matches legacy engine)\n  const expandWithTransitives = (rootChecks: string[]): Set<string> => {\n    const expanded = new Set<string>(rootChecks);\n\n    const allowByTags = (checkId: string): boolean => {\n      if (!tagFilter) return true;\n      const cfg = context.config.checks?.[checkId];\n      const tags: string[] = cfg?.tags || [];\n      if (tagFilter.exclude && tagFilter.exclude.some(t => tags.includes(t))) return false;\n      if (tagFilter.include && tagFilter.include.length > 0) {\n        return tagFilter.include.some(t => tags.includes(t));\n      }\n      return true;\n    };\n\n    const allowByEvent = (checkId: string): boolean => {\n      const cfg = context.config.checks?.[checkId];\n      const triggers = cfg?.on || [];\n      if (!triggers || triggers.length === 0) return true;\n      const current = eventTrigger || 'manual';\n      return triggers.includes(current as any);\n    };\n\n    const visit = (checkId: string) => {\n      const cfg = context.config.checks?.[checkId];\n      if (!cfg || !cfg.depends_on) return;\n\n      const depTokens = Array.isArray(cfg.depends_on) ? cfg.depends_on : [cfg.depends_on];\n      const expandDep = (tok: string): string[] => {\n        if (tok.includes('|')) {\n          return tok.split('|').map(s => s.trim()).filter(Boolean);\n        }\n        return [tok];\n      };\n\n      const deps = depTokens.flatMap(expandDep);\n      for (const depId of deps) {\n        if (!context.config.checks?.[depId]) continue;\n        if (!allowByTags(depId)) continue;\n        if (!allowByEvent(depId)) continue;\n        if (!expanded.has(depId)) {\n          expanded.add(depId);\n          visit(depId);\n        }\n      }\n    };\n\n    for (const checkId of rootChecks) {\n      visit(checkId);\n    }\n\n    return expanded;\n  };\n\n  const requestedChecksSet = context.requestedChecks\n    ? expandWithTransitives(context.requestedChecks)\n    : undefined;\n\n  if (context.debug && requestedChecksSet && context.requestedChecks) {\n    const added = Array.from(requestedChecksSet).filter(c => !context.requestedChecks!.includes(c));\n    if (added.length > 0) {\n      logger.info(`[PlanReady] Expanded requested checks with transitive dependencies: ${added.join(', ')}`);\n    }\n  }\n\n  const filteredChecks: Record<string, import('../../types/config').CheckConfig> = {};\n\n  for (const [checkId, checkConfig] of Object.entries(context.config.checks || {})) {\n    // 1. Filter by explicit check list (if provided, now includes transitive dependencies)\n    if (requestedChecksSet && !requestedChecksSet.has(checkId)) {\n      if (context.debug) {\n        logger.info(`[PlanReady] Skipping check '${checkId}': not in expanded requested checks list`);\n      }\n      continue;\n    }\n    // Check if event trigger matches (same logic as event-mapper.ts shouldRunCheck)\n    // If 'on' is not specified, the check can run on any event\n    if (checkConfig.on && eventTrigger && !checkConfig.on.includes(eventTrigger)) {\n      if (context.debug) {\n        logger.info(`[PlanReady] Skipping check '${checkId}': on=${JSON.stringify(checkConfig.on)}, event=${eventTrigger}`);\n      }\n      continue;\n    }\n\n    // Tag filtering (matches legacy CheckExecutionEngine.filterChecksByTags logic)\n    const checkTags = checkConfig.tags || [];\n    const isTagged = checkTags.length > 0;\n\n    if (tagFilter) {\n      // Check exclude tags first (if any exclude tag matches, skip the check)\n      if (tagFilter.exclude && tagFilter.exclude.length > 0) {\n        const hasExcludedTag = tagFilter.exclude.some(tag => checkTags.includes(tag));\n        if (hasExcludedTag) {\n          if (context.debug) {\n            logger.info(`[PlanReady] Skipping check '${checkId}': excluded by tag filter`);\n          }\n          continue;\n        }\n      }\n\n      // Check include tags (if specified, at least one must match OR check is untagged)\n      if (tagFilter.include && tagFilter.include.length > 0) {\n        const hasIncludedTag = tagFilter.include.some(tag => checkTags.includes(tag));\n        if (!hasIncludedTag && isTagged) {\n          if (context.debug) {\n            logger.info(`[PlanReady] Skipping check '${checkId}': not included by tag filter`);\n          }\n          continue;\n        }\n      }\n    } else {\n      // No tag filter specified: include only untagged checks by default\n      // Tagged checks are opt-in unless tag_filter is provided\n      if (isTagged) {\n        if (context.debug) {\n          logger.info(`[PlanReady] Skipping check '${checkId}': tagged but no tag filter specified`);\n        }\n        continue;\n      }\n    }\n\n    filteredChecks[checkId] = checkConfig;\n  }\n\n  if (context.debug) {\n    const totalChecks = Object.keys(context.config.checks || {}).length;\n    const filteredCount = Object.keys(filteredChecks).length;\n    logger.info(`[PlanReady] Filtered ${totalChecks} checks to ${filteredCount} based on event=${eventTrigger}`);\n  }\n\n  // Helper to check if dependencies are satisfied\n  // For OR dependencies (pipe syntax), at least one must be in filteredChecks\n  const areDependenciesSatisfied = (dependencies: string[]): boolean => {\n    for (const dep of dependencies) {\n      // Check for OR dependency (pipe syntax)\n      if (dep.includes('|')) {\n        const orOptions = dep.split('|').map(s => s.trim()).filter(Boolean);\n        // At least one option must exist in filtered checks\n        const hasAtLeastOne = orOptions.some(opt => filteredChecks[opt] !== undefined);\n        if (!hasAtLeastOne) {\n          return false;\n        }\n      } else {\n        // Regular dependency - must exist in filtered checks\n        if (filteredChecks[dep] === undefined) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  // Second pass: Remove checks whose dependencies are not satisfied\n  const finalChecks: Record<string, import('../../types/config').CheckConfig> = {};\n  for (const [checkId, checkConfig] of Object.entries(filteredChecks)) {\n    const dependencies = checkConfig.depends_on || [];\n    if (dependencies.length > 0 && !areDependenciesSatisfied(dependencies)) {\n      if (context.debug) {\n        logger.info(`[PlanReady] Skipping check '${checkId}': unsatisfied dependencies ${JSON.stringify(dependencies)}`);\n      }\n      continue;\n    }\n    finalChecks[checkId] = checkConfig;\n  }\n\n  if (context.debug && Object.keys(finalChecks).length !== Object.keys(filteredChecks).length) {\n    logger.info(`[PlanReady] Removed ${Object.keys(filteredChecks).length - Object.keys(finalChecks).length} checks due to unsatisfied dependencies`);\n  }\n\n  // Extract dependencies from final filtered check configurations\n  const checkDependencies: Record<string, string[]> = {};\n\n  for (const [checkId, checkConfig] of Object.entries(finalChecks)) {\n    // Expand OR groups (pipe syntax) for dependency resolution\n    // For OR groups, only include options that exist in finalChecks\n    // e.g., \"issue-assistant|comment-assistant\" becomes [\"comment-assistant\"] if issue-assistant was filtered out\n    const dependencies = (checkConfig.depends_on || []).flatMap((d: string) => {\n      if (typeof d === 'string' && d.includes('|')) {\n        // OR dependency - filter to only include available checks\n        const orOptions = d\n          .split('|')\n          .map(s => s.trim())\n          .filter(Boolean)\n          .filter(opt => finalChecks[opt] !== undefined); // Only include if check exists\n        return orOptions;\n      } else {\n        return [d];\n      }\n    });\n    checkDependencies[checkId] = dependencies;\n  }\n\n  // Build dependency graph\n  const graph = DependencyResolver.buildDependencyGraph(checkDependencies);\n\n  // Validate graph - check for cycles\n  if (graph.hasCycles) {\n    const cycleNodes = graph.cycleNodes?.join(' -> ') || 'unknown';\n    logger.error(`[PlanReady] Dependency cycle detected: ${cycleNodes}`);\n    throw new Error(`Dependency cycle detected: ${cycleNodes}`);\n  }\n\n  if (context.debug) {\n    logger.info(`[PlanReady] Graph built with ${graph.nodes.size} checks, ${graph.executionOrder.length} levels`);\n  }\n\n  // Store graph in context (mutate for now, can refactor later)\n  (context as any).dependencyGraph = graph;\n\n  // Initialize wave 0\n  state.wave = 0;\n\n  // Transition to WavePlanning\n  transition('WavePlanning');\n}\n","/**\n * WavePlanning State Handler\n *\n * Responsibilities:\n * - Inspect event queue for forward runs, goto events, etc.\n * - Determine next wave's execution levels\n * - Queue topological levels for execution\n * - Transition to LevelDispatch or Completed\n *\n * M2: Adds goto/on_finish/on_fail routing with deduplication\n */\n\nimport type { EngineContext, RunState, EngineState, EngineEvent } from '../../types/engine';\nimport { logger } from '../../logger';\nimport { DependencyResolver } from '../../dependency-resolver';\n\nexport async function handleWavePlanning(\n  context: EngineContext,\n  state: RunState,\n  transition: (newState: EngineState) => void\n): Promise<void> {\n  if (context.debug) {\n    logger.info(`[WavePlanning] Planning wave ${state.wave}...`);\n  }\n\n  // Check if we have a dependency graph\n  if (!context.dependencyGraph) {\n    throw new Error('Dependency graph not available');\n  }\n\n  // M3: Process bubbled events from child workflows\n  const bubbledEvents = (context as any)._bubbledEvents || [];\n  if (bubbledEvents.length > 0) {\n    if (context.debug) {\n      logger.info(`[WavePlanning] Processing ${bubbledEvents.length} bubbled events from child workflows`);\n    }\n\n    // Merge bubbled events into our event queue\n    for (const event of bubbledEvents) {\n      state.eventQueue.push(event);\n    }\n\n    // Clear bubbled events\n    (context as any)._bubbledEvents = [];\n  }\n\n  // M2: Process event queue for forward run requests\n  const forwardRunRequests = state.eventQueue.filter(\n    e => e.type === 'ForwardRunRequested'\n  ) as Array<Extract<EngineEvent, { type: 'ForwardRunRequested' }>>;\n\n  if (forwardRunRequests.length > 0) {\n    if (context.debug) {\n      logger.info(`[WavePlanning] Processing ${forwardRunRequests.length} forward run requests`);\n    }\n\n    // Clear processed events from queue\n    state.eventQueue = state.eventQueue.filter(e => e.type !== 'ForwardRunRequested');\n\n    // Build set of checks to execute with deduplication\n    const checksToRun = new Set<string>();\n    const eventOverrides = new Map<string, string>();\n\n    for (const request of forwardRunRequests) {\n      const { target, gotoEvent } = request;\n\n      // Deduplication: check if we've already requested this target in this wave\n      const dedupeKey = `${target}:${gotoEvent || 'default'}:${state.wave}`;\n      if (state.forwardRunGuards.has(dedupeKey)) {\n        if (context.debug) {\n          logger.info(`[WavePlanning] Skipping duplicate forward run: ${target}`);\n        }\n        continue;\n      }\n\n      // Add to dedupe guard\n      state.forwardRunGuards.add(dedupeKey);\n\n      // Add target to execution set\n      checksToRun.add(target);\n\n      // Store event override if specified\n      if (gotoEvent) {\n        eventOverrides.set(target, gotoEvent);\n      }\n\n      // Find all transitive dependencies (parents) of target\n      const dependencies = findTransitiveDependencies(target, context);\n      for (const dep of dependencies) {\n        checksToRun.add(dep);\n      }\n\n      // Find all transitive dependents (children) of target\n      const dependents = findTransitiveDependents(target, context, gotoEvent);\n      for (const dep of dependents) {\n        checksToRun.add(dep);\n      }\n    }\n\n    if (checksToRun.size > 0) {\n      // Build subgraph for checks to run\n      const subgraphChecks = Array.from(checksToRun);\n\n      // Build dependency map for subgraph\n      const subDeps: Record<string, string[]> = {};\n      for (const checkId of subgraphChecks) {\n        const checkConfig = context.config.checks?.[checkId];\n        if (!checkConfig) continue;\n\n        const deps = checkConfig.depends_on || [];\n        const depList = Array.isArray(deps) ? deps : [deps];\n\n        // Only include dependencies that are in our subgraph\n        subDeps[checkId] = depList.filter((d: string) => checksToRun.has(d));\n      }\n\n      // Build execution order for subgraph\n      const subGraph = DependencyResolver.buildDependencyGraph(subDeps);\n\n      // Queue levels for execution\n      state.levelQueue = [...subGraph.executionOrder];\n\n      if (context.debug) {\n        logger.info(\n          `[WavePlanning] Queued ${state.levelQueue.length} levels for ${checksToRun.size} checks (forward run)`\n        );\n      }\n\n      // Increment wave counter\n      state.wave++;\n\n      // Reset current wave completions for new wave\n      (state as any).currentWaveCompletions = new Set<string>();\n\n      // Clear forward run flag since we're processing them\n      state.flags.forwardRunRequested = false;\n\n      // Transition to LevelDispatch\n      transition('LevelDispatch');\n      return;\n    }\n  }\n\n  // M2: Check for WaveRetry events (from on_finish)\n  const waveRetryEvents = state.eventQueue.filter(e => e.type === 'WaveRetry');\n  if (waveRetryEvents.length > 0) {\n    if (context.debug) {\n      logger.info(`[WavePlanning] Processing wave retry requests`);\n    }\n\n    // Clear wave retry events\n    state.eventQueue = state.eventQueue.filter(e => e.type !== 'WaveRetry');\n\n    // Re-queue all execution levels\n    state.levelQueue = [...context.dependencyGraph.executionOrder];\n\n    if (context.debug) {\n      logger.info(`[WavePlanning] Queued ${state.levelQueue.length} levels (wave retry)`);\n    }\n\n    // Increment wave\n    state.wave++;\n\n    // Reset current wave completions for new wave\n    (state as any).currentWaveCompletions = new Set<string>();\n\n    // Transition to LevelDispatch\n    transition('LevelDispatch');\n    return;\n  }\n\n  // Initial wave: queue all execution levels\n  if (state.wave === 0 && state.levelQueue.length === 0) {\n    state.levelQueue = [...context.dependencyGraph.executionOrder];\n\n    if (context.debug) {\n      logger.info(`[WavePlanning] Queued ${state.levelQueue.length} levels for execution (initial wave)`);\n    }\n\n    // Increment wave to prevent re-queueing the same levels\n    state.wave++;\n\n    // Initialize current wave completions\n    (state as any).currentWaveCompletions = new Set<string>();\n  }\n\n  // Check if there are levels to execute\n  if (state.levelQueue.length > 0) {\n    // Transition to LevelDispatch\n    transition('LevelDispatch');\n  } else {\n    // No more work - check if we have pending events\n    if (state.eventQueue.length > 0) {\n      if (context.debug) {\n        logger.warn(\n          `[WavePlanning] Event queue not empty (${state.eventQueue.length} events) but no work scheduled`\n        );\n      }\n    }\n\n    // All work complete\n    if (context.debug) {\n      logger.info('[WavePlanning] All waves complete');\n    }\n    transition('Completed');\n  }\n}\n\n/**\n * Find all transitive dependencies (parents) of a check\n */\nfunction findTransitiveDependencies(\n  target: string,\n  context: EngineContext\n): Set<string> {\n  const dependencies = new Set<string>();\n  const checks = context.config.checks || {};\n  const visited = new Set<string>();\n\n  const dfs = (checkId: string) => {\n    if (visited.has(checkId)) return;\n    visited.add(checkId);\n\n    const checkConfig = checks[checkId];\n    if (!checkConfig) return;\n\n    const deps = checkConfig.depends_on || [];\n    const depList = Array.isArray(deps) ? deps : [deps];\n\n    for (const depId of depList) {\n      if (typeof depId !== 'string') continue;\n\n      // Handle OR dependencies (pipe syntax) - add all options\n      if (depId.includes('|')) {\n        const orOptions = depId.split('|').map(s => s.trim()).filter(Boolean);\n        for (const opt of orOptions) {\n          if (checks[opt]) {\n            dependencies.add(opt);\n            dfs(opt);\n          }\n        }\n      } else {\n        if (checks[depId]) {\n          dependencies.add(depId);\n          dfs(depId);\n        }\n      }\n    }\n  };\n\n  dfs(target);\n  return dependencies;\n}\n\n/**\n * Find all transitive dependents of a check that should run for a given event\n */\nfunction findTransitiveDependents(\n  target: string,\n  context: EngineContext,\n  gotoEvent?: string\n): Set<string> {\n  const dependents = new Set<string>();\n  const checks = context.config.checks || {};\n\n  // Helper to check if a check depends on another\n  const dependsOn = (checkId: string, depId: string): boolean => {\n    const visited = new Set<string>();\n\n    const dfs = (current: string): boolean => {\n      if (visited.has(current)) return false;\n      visited.add(current);\n\n      const checkConfig = checks[current];\n      if (!checkConfig) return false;\n\n      const deps = checkConfig.depends_on || [];\n      const depList = Array.isArray(deps) ? deps : [deps];\n\n      if (depList.includes(depId)) return true;\n\n      for (const d of depList) {\n        if (dfs(d)) return true;\n      }\n\n      return false;\n    };\n\n    return dfs(checkId);\n  };\n\n  // Find all checks that depend on target\n  for (const checkId of Object.keys(checks)) {\n    if (checkId === target) continue;\n\n    const checkConfig = checks[checkId];\n    if (!checkConfig) continue;\n\n    // Check if this check depends on target\n    if (!dependsOn(checkId, target)) continue;\n\n    // If gotoEvent specified, filter by event triggers\n    if (gotoEvent) {\n      const triggers = checkConfig.on;\n      if (Array.isArray(triggers) && triggers.length > 0) {\n        if (!triggers.includes(gotoEvent as any)) {\n          // This check doesn't run for the specified event\n          continue;\n        }\n      }\n    }\n\n    // Add to dependents\n    dependents.add(checkId);\n  }\n\n  return dependents;\n}\n","/**\n * Failure condition evaluation engine using SandboxJS for secure expression evaluation\n */\n\nimport { ReviewSummary } from './reviewer';\nimport { addEvent } from './telemetry/trace-helpers';\nimport { addFailIfTriggered } from './telemetry/metrics';\nimport {\n  FailureConditions,\n  FailureCondition,\n  FailureConditionContext,\n  FailureConditionResult,\n  FailureConditionSeverity,\n} from './types/config';\nimport Sandbox from '@nyariv/sandboxjs';\nimport { createSecureSandbox } from './utils/sandbox';\nimport { createPermissionHelpers, detectLocalMode } from './utils/author-permissions';\nimport { MemoryStore } from './memory-store';\n\n/**\n * Evaluates failure conditions using SandboxJS for secure evaluation\n */\nexport class FailureConditionEvaluator {\n  private sandbox?: Sandbox;\n\n  constructor() {}\n\n  /**\n   * Create a secure sandbox with whitelisted functions and globals\n   */\n  private createSecureSandbox(): Sandbox {\n    return createSecureSandbox();\n  }\n\n  /**\n   * Evaluate simple fail_if condition\n   */\n  async evaluateSimpleCondition(\n    checkName: string,\n    checkSchema: string,\n    checkGroup: string,\n    reviewSummary: ReviewSummary,\n    expression: string,\n    previousOutputs?: Record<string, ReviewSummary>,\n    authorAssociation?: string\n  ): Promise<boolean> {\n    const context = this.buildEvaluationContext(\n      checkName,\n      checkSchema,\n      checkGroup,\n      reviewSummary,\n      previousOutputs,\n      authorAssociation\n    );\n\n    try {\n      try {\n        const isObj = context.output && typeof context.output === 'object';\n        const keys = isObj ? Object.keys(context.output as any).join(',') : typeof context.output;\n        let errorVal: unknown = undefined;\n        if (isObj && (context.output as any).error !== undefined)\n          errorVal = (context.output as any).error;\n        require('./logger').logger.debug(\n          `  fail_if: evaluating '${expression}' with output keys=${keys} error=${String(errorVal)}`\n        );\n      } catch {}\n      const res = this.evaluateExpression(expression, context);\n      if (res === true) {\n        try {\n          addEvent('fail_if.triggered', {\n            check: checkName,\n            scope: 'check',\n            name: `${checkName}_fail_if`,\n            expression,\n            severity: 'error',\n          });\n        } catch {}\n        try {\n          const { emitNdjsonSpanWithEvents } = require('./telemetry/fallback-ndjson');\n          emitNdjsonSpanWithEvents(\n            'visor.fail_if',\n            { check: checkName, scope: 'check', name: `${checkName}_fail_if` },\n            [\n              {\n                name: 'fail_if.triggered',\n                attrs: {\n                  check: checkName,\n                  scope: 'check',\n                  name: `${checkName}_fail_if`,\n                  expression,\n                  severity: 'error',\n                },\n              },\n            ]\n          );\n        } catch {}\n      }\n      return res;\n    } catch (error) {\n      console.warn(`Failed to evaluate fail_if expression: ${error}`);\n      return false; // Don't fail on evaluation errors\n    }\n  }\n\n  /**\n   * Determine if the event is related to pull requests\n   */\n  private determineIfPullRequest(eventType?: string): boolean {\n    if (!eventType) return false;\n\n    const prEvents = ['pr_opened', 'pr_updated', 'pr_closed', 'pull_request'];\n    return prEvents.includes(eventType) || eventType.startsWith('pr_');\n  }\n\n  /**\n   * Determine if the event is related to issues\n   */\n  private determineIfIssue(eventType?: string): boolean {\n    if (!eventType) return false;\n\n    const issueEvents = ['issue_opened', 'issue_comment', 'issues'];\n    return issueEvents.includes(eventType) || eventType.startsWith('issue_');\n  }\n\n  /**\n   * Evaluate if condition to determine whether a check should run\n   */\n  async evaluateIfCondition(\n    checkName: string,\n    expression: string,\n    contextData?: {\n      branch?: string;\n      baseBranch?: string;\n      filesChanged?: string[];\n      event?: string;\n      environment?: Record<string, string>;\n      previousResults?: Map<string, ReviewSummary>;\n      authorAssociation?: string;\n      workflowInputs?: Record<string, unknown>;\n    }\n  ): Promise<boolean> {\n    // Build context for if evaluation\n    const context = {\n      // Check metadata\n      checkName,\n\n      // Git context\n      branch: contextData?.branch || 'unknown',\n      baseBranch: contextData?.baseBranch || 'main',\n      filesChanged: contextData?.filesChanged || [],\n      filesCount: contextData?.filesChanged?.length || 0,\n\n      // GitHub event context\n      event: {\n        event_name: contextData?.event || 'manual',\n        action: undefined, // Would be populated from actual GitHub context\n        repository: undefined, // Would be populated from actual GitHub context\n      },\n\n      // Environment variables\n      env: contextData?.environment || {},\n\n      // Previous check results (unwrap output field like templates do)\n      outputs: contextData?.previousResults\n        ? (() => {\n            const outputs: Record<string, unknown> = {};\n            for (const [checkName, result] of contextData.previousResults) {\n              // If the result has a direct output field, use it directly\n              // Otherwise, expose the entire result as-is\n              const summary = result as ReviewSummary & { output?: unknown };\n              outputs[checkName] = summary.output !== undefined ? summary.output : summary;\n            }\n            return outputs;\n          })()\n        : {},\n\n      // Workflow inputs (for workflows)\n      inputs: contextData?.workflowInputs || {},\n\n      // Required output property (empty for if conditions)\n      output: {\n        issues: [],\n      },\n      // Author association (used by permission helpers)\n      authorAssociation: contextData?.authorAssociation,\n\n      // Utility metadata\n      metadata: {\n        checkName,\n        schema: '',\n        group: '',\n        criticalIssues: 0,\n        errorIssues: 0,\n        warningIssues: 0,\n        infoIssues: 0,\n        totalIssues: 0,\n        hasChanges: (contextData?.filesChanged?.length || 0) > 0,\n        branch: contextData?.branch || 'unknown',\n        event: contextData?.event || 'manual',\n      },\n    };\n\n    try {\n      const res = this.evaluateExpression(expression, context);\n      try {\n        if (process.env.VISOR_DEBUG === 'true') {\n          const envMap = context.env || {};\n\n          console.error(\n            `[if-eval] check=${checkName} expr=\"${expression}\" env.ENABLE_FACT_VALIDATION=${String(\n              (envMap as any).ENABLE_FACT_VALIDATION\n            )} event=${context.event?.event_name} result=${String(res)}`\n          );\n        }\n      } catch {}\n      return res;\n    } catch (error) {\n      console.warn(`Failed to evaluate if expression for check '${checkName}': ${error}`);\n      // Fail-secure: do not run the check on evaluation errors\n      return false;\n    }\n  }\n\n  /**\n   * Evaluate all failure conditions for a check result\n   */\n  async evaluateConditions(\n    checkName: string,\n    checkSchema: string,\n    checkGroup: string,\n    reviewSummary: ReviewSummary,\n    globalConditions?: FailureConditions,\n    checkConditions?: FailureConditions,\n    previousOutputs?: Record<string, ReviewSummary>,\n    authorAssociation?: string\n  ): Promise<FailureConditionResult[]> {\n    const context = this.buildEvaluationContext(\n      checkName,\n      checkSchema,\n      checkGroup,\n      reviewSummary,\n      previousOutputs,\n      authorAssociation\n    );\n\n    const results: FailureConditionResult[] = [];\n\n    // Evaluate global conditions first\n    if (globalConditions) {\n      const globalResults = await this.evaluateConditionSet(globalConditions, context, 'global');\n      results.push(...globalResults);\n    }\n\n    // Evaluate check-specific conditions (these override global ones with same name)\n    if (checkConditions) {\n      const checkResults = await this.evaluateConditionSet(checkConditions, context, 'check');\n\n      // Remove global conditions that are overridden by check-specific ones\n      const overriddenConditions = new Set(Object.keys(checkConditions));\n      const filteredResults = results.filter(\n        result => !overriddenConditions.has(result.conditionName)\n      );\n\n      results.length = 0;\n      results.push(...filteredResults, ...checkResults);\n    }\n\n    try {\n      if (checkName === 'B') {\n        console.error(\n          `üîß Debug: fail_if results for ${checkName}: ${JSON.stringify(results)} context.output=${JSON.stringify(\n            context.output\n          )}`\n        );\n      }\n    } catch {}\n    return results;\n  }\n\n  /**\n   * Evaluate a set of failure conditions\n   */\n  private async evaluateConditionSet(\n    conditions: FailureConditions,\n    context: FailureConditionContext,\n    source: 'global' | 'check'\n  ): Promise<FailureConditionResult[]> {\n    const results: FailureConditionResult[] = [];\n\n    for (const [conditionName, condition] of Object.entries(conditions)) {\n      try {\n        addEvent('fail_if.evaluated', {\n          check: context.checkName,\n          scope: source,\n          name: conditionName,\n          expression: this.extractExpression(condition),\n        });\n      } catch {}\n\n      // File fallback: append an NDJSON span with the evaluation event\n      try {\n        const { emitNdjsonSpanWithEvents } = require('./telemetry/fallback-ndjson');\n        emitNdjsonSpanWithEvents(\n          'visor.fail_if',\n          { check: context.checkName || 'unknown', scope: source, name: conditionName },\n          [\n            {\n              name: 'fail_if.evaluated',\n              attrs: {\n                check: context.checkName,\n                scope: source,\n                name: conditionName,\n                expression: this.extractExpression(condition),\n              },\n            },\n          ]\n        );\n      } catch {}\n\n      try {\n        const result = await this.evaluateSingleCondition(conditionName, condition, context);\n        results.push(result);\n\n        if (result.failed) {\n          try {\n            addEvent('fail_if.triggered', {\n              check: context.checkName,\n              scope: source,\n              name: conditionName,\n              expression: result.expression,\n              severity: result.severity,\n              halt_execution: result.haltExecution,\n            });\n          } catch {}\n          try {\n            addFailIfTriggered(context.checkName || 'unknown', source);\n          } catch {}\n        }\n      } catch (error) {\n        // If evaluation fails, create an error result\n        results.push({\n          conditionName,\n          failed: false,\n          expression: this.extractExpression(condition),\n          severity: 'error',\n          haltExecution: false,\n          error: `Failed to evaluate ${source} condition '${conditionName}': ${\n            error instanceof Error ? error.message : String(error)\n          }`,\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Evaluate a single failure condition\n   */\n  private async evaluateSingleCondition(\n    conditionName: string,\n    condition: FailureCondition,\n    context: FailureConditionContext\n  ): Promise<FailureConditionResult> {\n    const expression = this.extractExpression(condition);\n    const config = this.extractConditionConfig(condition);\n\n    try {\n      const failed = this.evaluateExpression(expression, context);\n\n      return {\n        conditionName,\n        failed,\n        expression,\n        message: config.message,\n        severity: config.severity || 'error',\n        haltExecution: config.halt_execution || false,\n      };\n    } catch (error) {\n      throw new Error(\n        `Expression evaluation error: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Secure expression evaluation using SandboxJS\n   * Supports the same GitHub Actions-style functions as the previous implementation\n   */\n  private evaluateExpression(condition: string, context: FailureConditionContext): boolean {\n    try {\n      // Normalize multi-line or semicolon-separated expressions.\n      // Allows writing debug statements on separate lines, e.g.:\n      //   log(\"start\")\n      //   log(outputs)\n      //   outputs[\"fetch-tickets\"].issueType === 'Bug'\n      // We convert to a single expression using the comma operator so the\n      // final expression determines the boolean result.\n      const normalize = (expr: string): string => {\n        const trimmed = expr.trim();\n        // If it's already a single-line expression without semicolons, keep it.\n        if (!/[\\n;]/.test(trimmed)) return trimmed;\n\n        // Split on newlines/semicolons, drop empty and comment-only lines.\n        const parts = trimmed\n          .split(/[\\n;]+/)\n          .map(s => s.trim())\n          .filter(s => s.length > 0 && !s.startsWith('//'));\n\n        if (parts.length === 0) return 'true';\n\n        // Support an explicit return in the last statement.\n        const lastRaw = parts.pop() as string;\n        const last = lastRaw.replace(/^return\\s+/i, '').trim();\n\n        // Join leading statements with comma operator; last expression returns value.\n        if (parts.length === 0) return last;\n        return `(${parts.join(', ')}, ${last})`;\n      };\n\n      // note: normalization happens later only if raw compilation fails\n      // Helper functions for GitHub Actions-style expressions\n      const contains = (searchString: string, searchValue: string): boolean =>\n        String(searchString).toLowerCase().includes(String(searchValue).toLowerCase());\n\n      const startsWith = (searchString: string, searchValue: string): boolean =>\n        String(searchString).toLowerCase().startsWith(String(searchValue).toLowerCase());\n\n      const endsWith = (searchString: string, searchValue: string): boolean =>\n        String(searchString).toLowerCase().endsWith(String(searchValue).toLowerCase());\n\n      const length = (value: string | unknown[] | Record<string, unknown>): number => {\n        if (typeof value === 'string' || Array.isArray(value)) {\n          return value.length;\n        }\n        if (value && typeof value === 'object') {\n          return Object.keys(value).length;\n        }\n        return 0;\n      };\n\n      const always = (): boolean => true;\n      const success = (): boolean => true;\n      const failure = (): boolean => false;\n\n      // Debug logging function for printing to console\n      const log = (...args: unknown[]): void => {\n        console.log('üîç Debug:', ...args);\n      };\n\n      // Helper functions for array operations\n      const hasIssue = (issues: unknown[], field: string, value: unknown): boolean => {\n        if (!Array.isArray(issues)) return false;\n        return issues.some(issue => (issue as Record<string, unknown>)[field] === value);\n      };\n\n      const countIssues = (issues: unknown[], field: string, value: unknown): number => {\n        if (!Array.isArray(issues)) return 0;\n        return issues.filter(issue => (issue as Record<string, unknown>)[field] === value).length;\n      };\n\n      const hasFileMatching = (issues: unknown[], pattern: string): boolean => {\n        if (!Array.isArray(issues)) return false;\n        return issues.some(issue => (issue as { file?: string }).file?.includes(pattern));\n      };\n\n      // Backward compatibility aliases\n      const hasIssueWith = hasIssue;\n      const hasFileWith = hasFileMatching;\n\n      // Permission helper functions\n      const permissionHelpers = createPermissionHelpers(\n        context.authorAssociation,\n        detectLocalMode()\n      );\n      const hasMinPermission = permissionHelpers.hasMinPermission;\n      const isOwner = permissionHelpers.isOwner;\n      const isMember = permissionHelpers.isMember;\n      const isCollaborator = permissionHelpers.isCollaborator;\n      const isContributor = permissionHelpers.isContributor;\n      const isFirstTimer = permissionHelpers.isFirstTimer;\n\n      // Extract context variables\n      const output = context.output || {};\n      const issues = output.issues || [];\n\n      // Backward compatibility: provide metadata for transition period\n      // TODO: Remove after all configurations are updated\n      const metadata = context.metadata || {\n        checkName: context.checkName || '',\n        schema: context.schema || '',\n        group: context.group || '',\n        criticalIssues: issues.filter((i: { severity?: string }) => i.severity === 'critical')\n          .length,\n        errorIssues: issues.filter((i: { severity?: string }) => i.severity === 'error').length,\n        warningIssues: issues.filter((i: { severity?: string }) => i.severity === 'warning').length,\n        infoIssues: issues.filter((i: { severity?: string }) => i.severity === 'info').length,\n        totalIssues: issues.length,\n        hasChanges: context.hasChanges || false,\n      };\n\n      // Legacy variables for backward compatibility\n      const criticalIssues = metadata.criticalIssues;\n      const errorIssues = metadata.errorIssues;\n      const totalIssues = metadata.totalIssues;\n      const warningIssues = metadata.warningIssues;\n      const infoIssues = metadata.infoIssues;\n\n      // Additional context for 'if' conditions and some failure conditions\n      const checkName = context.checkName || '';\n      const schema = context.schema || '';\n      const group = context.group || '';\n      const branch = context.branch || 'unknown';\n      const baseBranch = context.baseBranch || 'main';\n      const filesChanged = context.filesChanged || [];\n      const filesCount = context.filesCount || 0;\n      const event = context.event || 'manual';\n      const env = context.env || {};\n      const outputs = context.outputs || {};\n      const debugData = context.debug || null;\n\n      // Get memory store and create accessor for fail_if expressions\n      const memoryStore = MemoryStore.getInstance();\n      const memoryAccessor = {\n        get: (key: string, ns?: string) => memoryStore.get(key, ns),\n        has: (key: string, ns?: string) => memoryStore.has(key, ns),\n        list: (ns?: string) => memoryStore.list(ns),\n        getAll: (ns?: string) => memoryStore.getAll(ns),\n      };\n\n      // Create scope with all context variables and helper functions\n      const scope = {\n        // Primary context variables\n        output,\n        outputs,\n        debug: debugData,\n        // Memory accessor for fail_if expressions\n        memory: memoryAccessor,\n        // Legacy compatibility variables\n        issues,\n        metadata,\n        criticalIssues,\n        errorIssues,\n        totalIssues,\n        warningIssues,\n        infoIssues,\n        // If condition context\n        checkName,\n        schema,\n        group,\n        branch,\n        baseBranch,\n        filesChanged,\n        filesCount,\n        event,\n        env,\n        // Helper functions\n        contains,\n        startsWith,\n        endsWith,\n        length,\n        always,\n        success,\n        failure,\n        log,\n        hasIssue,\n        countIssues,\n        hasFileMatching,\n        hasIssueWith,\n        hasFileWith,\n        // Permission helpers\n        hasMinPermission,\n        isOwner,\n        isMember,\n        isCollaborator,\n        isContributor,\n        isFirstTimer,\n      };\n\n      // Compile and execute the expression in the sandbox\n      const raw = condition.trim();\n      if (!this.sandbox) {\n        this.sandbox = this.createSecureSandbox();\n      }\n      let exec: ReturnType<typeof this.sandbox.compile>;\n      try {\n        // Try compiling the raw expression as-is first (supports multi-line logical expressions)\n        exec = this.sandbox.compile(`return (${raw});`);\n      } catch {\n        // Fallback: normalize multi-line statements into a comma-chain expression\n        const normalizedExpr = normalize(condition);\n        exec = this.sandbox.compile(`return (${normalizedExpr});`);\n      }\n      const result = exec(scope).run();\n      try {\n        require('./logger').logger.debug(`  fail_if: result=${Boolean(result)}`);\n      } catch {}\n      // Ensure we return a boolean\n      return Boolean(result);\n    } catch (error) {\n      console.error('‚ùå Failed to evaluate expression:', condition, error);\n      // Re-throw the error so it can be caught at a higher level for error reporting\n      throw error;\n    }\n  }\n\n  /**\n   * Extract the expression from a failure condition\n   */\n  private extractExpression(condition: FailureCondition): string {\n    if (typeof condition === 'string') {\n      return condition;\n    }\n    return condition.condition;\n  }\n\n  /**\n   * Extract configuration from a failure condition\n   */\n  private extractConditionConfig(condition: FailureCondition): {\n    message?: string;\n    severity?: FailureConditionSeverity;\n    halt_execution?: boolean;\n  } {\n    if (typeof condition === 'string') {\n      return {};\n    }\n    return {\n      message: condition.message,\n      severity: condition.severity,\n      halt_execution: condition.halt_execution,\n    };\n  }\n\n  /**\n   * Build the evaluation context for expressions\n   */\n  private buildEvaluationContext(\n    checkName: string,\n    checkSchema: string,\n    checkGroup: string,\n    reviewSummary: ReviewSummary,\n    previousOutputs?: Record<string, ReviewSummary>,\n    authorAssociation?: string\n  ): FailureConditionContext {\n    const { issues, debug } = reviewSummary;\n    const reviewSummaryWithOutput = reviewSummary as ReviewSummary & { output?: unknown };\n\n    // Extract output field to avoid nesting (output.output)\n    const {\n      output: extractedOutput,\n      // Exclude issues from otherFields since we handle it separately\n      issues: _issues, // eslint-disable-line @typescript-eslint/no-unused-vars\n      ...otherFields\n    } = reviewSummaryWithOutput as any;\n\n    // Build output object with safety for array-based outputs (forEach aggregation)\n    const aggregatedOutput: Record<string, unknown> = {\n      issues: (issues || []).map(issue => ({\n        file: issue.file,\n        line: issue.line,\n        endLine: issue.endLine,\n        ruleId: issue.ruleId,\n        message: issue.message,\n        severity: issue.severity,\n        category: issue.category,\n        group: issue.group,\n        schema: issue.schema,\n        suggestion: issue.suggestion,\n        replacement: issue.replacement,\n      })),\n      // Include additional schema-specific data from reviewSummary\n      ...otherFields,\n    };\n\n    if (Array.isArray(extractedOutput)) {\n      // Preserve items array and lift common flags for convenience (e.g., output.error)\n      aggregatedOutput.items = extractedOutput;\n      const anyError = extractedOutput.find(\n        it => it && typeof it === 'object' && (it as Record<string, unknown>).error\n      ) as Record<string, unknown> | undefined;\n      if (anyError && anyError.error !== undefined) {\n        aggregatedOutput.error = anyError.error;\n      }\n    } else if (extractedOutput && typeof extractedOutput === 'object') {\n      Object.assign(aggregatedOutput, extractedOutput as Record<string, unknown>);\n    }\n\n    // If provider attached a raw transform snapshot, merge its fields generically.\n    try {\n      const raw = (reviewSummaryWithOutput as any).__raw;\n      if (raw && typeof raw === 'object') {\n        Object.assign(aggregatedOutput, raw as Record<string, unknown>);\n      }\n    } catch {}\n\n    // If output is a string, try to parse JSON (full or from end) to enrich context,\n    // and also derive common boolean flags generically (e.g., key:true/false) for fail_if usage.\n    try {\n      if (typeof extractedOutput === 'string') {\n        const parsed =\n          this.tryExtractJsonFromEnd(extractedOutput) ??\n          (() => {\n            try {\n              return JSON.parse(extractedOutput);\n            } catch {\n              return null;\n            }\n          })();\n        if (parsed !== null) {\n          if (Array.isArray(parsed)) {\n            (aggregatedOutput as any).items = parsed;\n          } else if (typeof parsed === 'object') {\n            Object.assign(aggregatedOutput, parsed as Record<string, unknown>);\n          }\n        }\n        // Generic boolean key extraction for simple text outputs (no special provider cases)\n        const lower = extractedOutput.toLowerCase();\n        const boolFrom = (key: string): boolean | null => {\n          const reTrue = new RegExp(\n            `(?:^|[^a-z0-9_])${key}[^a-z0-9_]*[:=][^a-z0-9_]*true(?:[^a-z0-9_]|$)`\n          );\n          const reFalse = new RegExp(\n            `(?:^|[^a-z0-9_])${key}[^a-z0-9_]*[:=][^a-z0-9_]*false(?:[^a-z0-9_]|$)`\n          );\n          if (reTrue.test(lower)) return true;\n          if (reFalse.test(lower)) return false;\n          return null;\n        };\n        const keys = ['error'];\n        for (const k of keys) {\n          const v = boolFrom(k);\n          if (v !== null && (aggregatedOutput as any)[k] === undefined) {\n            (aggregatedOutput as any)[k] = v;\n          }\n        }\n      }\n    } catch {}\n\n    // Try to parse JSON from content as a last resort when no structured output is present\n    try {\n      const rsAny = reviewSummaryWithOutput as any;\n      const hasStructuredOutput = extractedOutput !== undefined && extractedOutput !== null;\n      if (!hasStructuredOutput && typeof rsAny?.content === 'string') {\n        const parsedFromContent = this.tryExtractJsonFromEnd(rsAny.content);\n        if (parsedFromContent !== null && parsedFromContent !== undefined) {\n          if (Array.isArray(parsedFromContent)) {\n            (aggregatedOutput as any).items = parsedFromContent;\n          } else if (typeof parsedFromContent === 'object') {\n            Object.assign(aggregatedOutput, parsedFromContent as Record<string, unknown>);\n          }\n        }\n      }\n    } catch {}\n\n    // Get memory store instance\n    const memoryStore = MemoryStore.getInstance();\n\n    const context: FailureConditionContext = {\n      output: aggregatedOutput,\n      outputs: (() => {\n        if (!previousOutputs) return {};\n        const outputs: Record<string, unknown> = {};\n        for (const [checkName, result] of Object.entries(previousOutputs)) {\n          // If the result has a direct output field, use it directly\n          // Otherwise, expose the entire result as-is\n          const summary = result as ReviewSummary & { output?: unknown };\n          outputs[checkName] = summary.output !== undefined ? summary.output : summary;\n        }\n        return outputs;\n      })(),\n      // Add memory accessor for fail_if expressions\n      memory: {\n        get: (key: string, ns?: string) => memoryStore.get(key, ns),\n        has: (key: string, ns?: string) => memoryStore.has(key, ns),\n        list: (ns?: string) => memoryStore.list(ns),\n        getAll: (ns?: string) => memoryStore.getAll(ns),\n      } as any,\n      // Add basic context info for failure conditions\n      checkName: checkName,\n      schema: checkSchema,\n      group: checkGroup,\n      authorAssociation: authorAssociation,\n    };\n\n    // Add debug information if available\n    if (debug) {\n      context.debug = {\n        errors: debug.errors || [],\n        processingTime: debug.processingTime || 0,\n        provider: debug.provider || 'unknown',\n        model: debug.model || 'unknown',\n      };\n    }\n\n    return context;\n  }\n\n  // Minimal JSON-from-end extractor for fail_if context fallback\n  private tryExtractJsonFromEnd(text: string): unknown | null {\n    try {\n      const lines = text.split('\\n');\n      for (let i = lines.length - 1; i >= 0; i--) {\n        const t = lines[i].trim();\n        if (t.startsWith('{') || t.startsWith('[')) {\n          const candidate = lines.slice(i).join('\\n').trim();\n          if (\n            (candidate.startsWith('{') && candidate.endsWith('}')) ||\n            (candidate.startsWith('[') && candidate.endsWith(']'))\n          ) {\n            return JSON.parse(candidate);\n          }\n        }\n      }\n    } catch {}\n    return null;\n  }\n\n  /**\n   * Check if any failure condition requires halting execution\n   */\n  static shouldHaltExecution(results: FailureConditionResult[]): boolean {\n    return results.some(result => result.failed && result.haltExecution);\n  }\n\n  /**\n   * Get all failed conditions\n   */\n  static getFailedConditions(results: FailureConditionResult[]): FailureConditionResult[] {\n    return results.filter(result => result.failed);\n  }\n\n  /**\n   * Group results by severity\n   */\n  static groupResultsBySeverity(results: FailureConditionResult[]): {\n    error: FailureConditionResult[];\n    warning: FailureConditionResult[];\n    info: FailureConditionResult[];\n  } {\n    return {\n      // Only 'error' severity now (no backward compatibility needed here as this is internal)\n      error: results.filter(r => r.severity === 'error'),\n      warning: results.filter(r => r.severity === 'warning'),\n      info: results.filter(r => r.severity === 'info'),\n    };\n  }\n\n  /**\n   * Format results for display\n   */\n  static formatResults(results: FailureConditionResult[]): string {\n    const failed = FailureConditionEvaluator.getFailedConditions(results);\n\n    if (failed.length === 0) {\n      return '‚úÖ All failure conditions passed';\n    }\n\n    const grouped = FailureConditionEvaluator.groupResultsBySeverity(failed);\n    const sections: string[] = [];\n\n    if (grouped.error.length > 0) {\n      sections.push(`‚ùå **Error severity conditions (${grouped.error.length}):**`);\n      grouped.error.forEach(result => {\n        sections.push(`  - ${result.conditionName}: ${result.message || result.expression}`);\n      });\n    }\n\n    if (grouped.warning.length > 0) {\n      sections.push(`‚ö†Ô∏è **Warning conditions (${grouped.warning.length}):**`);\n      grouped.warning.forEach(result => {\n        sections.push(`  - ${result.conditionName}: ${result.message || result.expression}`);\n      });\n    }\n\n    if (grouped.info.length > 0) {\n      sections.push(`‚ÑπÔ∏è **Info conditions (${grouped.info.length}):**`);\n      grouped.info.forEach(result => {\n        sections.push(`  - ${result.conditionName}: ${result.message || result.expression}`);\n      });\n    }\n\n    return sections.join('\\n');\n  }\n}\n","/*\n * Internal snapshot store for incremental adoption of snapshot+scope execution.\n * Phase 0: journal only ‚Äî no behavior change, used for future visibility work.\n */\n\nimport type { ReviewSummary } from './reviewer';\nimport type { EventTrigger } from './types/config';\n\nexport type ScopePath = Array<{ check: string; index: number }>;\n\nexport interface JournalEntry {\n  commitId: number;\n  sessionId: string;\n  scope: ScopePath;\n  checkId: string;\n  event: EventTrigger | undefined;\n  result: ReviewSummary & { output?: unknown; content?: string };\n}\n\nexport class ExecutionJournal {\n  private commit = 0;\n  private entries: JournalEntry[] = [];\n\n  beginSnapshot(): number {\n    return this.commit;\n  }\n\n  commitEntry(entry: {\n    sessionId: string;\n    scope: ScopePath;\n    checkId: string;\n    result: ReviewSummary & { output?: unknown; content?: string };\n    event?: EventTrigger;\n  }): JournalEntry {\n    const committed: JournalEntry = {\n      sessionId: entry.sessionId,\n      scope: entry.scope,\n      checkId: entry.checkId,\n      result: entry.result,\n      event: entry.event,\n      commitId: ++this.commit,\n    };\n    this.entries.push(committed);\n    return committed;\n  }\n\n  readVisible(sessionId: string, commitMax: number, event?: EventTrigger): JournalEntry[] {\n    return this.entries.filter(\n      e =>\n        e.sessionId === sessionId && e.commitId <= commitMax && (event ? e.event === event : true)\n    );\n  }\n\n  // Lightweight helpers for debugging/metrics\n  size(): number {\n    return this.entries.length;\n  }\n}\n\nexport class ContextView {\n  constructor(\n    private journal: ExecutionJournal,\n    private sessionId: string,\n    private snapshotId: number,\n    private scope: ScopePath,\n    private event?: EventTrigger\n  ) {}\n\n  /** Return the nearest result for a check in this scope (exact item ‚Üí ancestor ‚Üí latest). */\n  get(checkId: string): (ReviewSummary & { output?: unknown; content?: string }) | undefined {\n    const visible = this.journal\n      .readVisible(this.sessionId, this.snapshotId, this.event)\n      .filter(e => e.checkId === checkId);\n    if (visible.length === 0) return undefined;\n\n    // exact scope match\n    const exact = visible.find(e => this.sameScope(e.scope, this.scope));\n    if (exact) return exact.result;\n\n    // nearest ancestor (shortest distance)\n    let best: { entry: JournalEntry; dist: number } | undefined;\n    for (const e of visible) {\n      const dist = this.ancestorDistance(e.scope, this.scope);\n      if (dist >= 0 && (best === undefined || dist < best.dist)) {\n        best = { entry: e, dist };\n      }\n    }\n    if (best) return best.entry.result;\n\n    // fallback to latest committed result\n    return visible[visible.length - 1]?.result;\n  }\n\n  /** Return an aggregate (raw) result ‚Äì the shallowest scope for this check. */\n  getRaw(checkId: string): (ReviewSummary & { output?: unknown; content?: string }) | undefined {\n    const visible = this.journal\n      .readVisible(this.sessionId, this.snapshotId, this.event)\n      .filter(e => e.checkId === checkId);\n    if (visible.length === 0) return undefined;\n    let shallow = visible[0];\n    for (const e of visible) {\n      if (e.scope.length < shallow.scope.length) shallow = e;\n    }\n    return shallow.result;\n  }\n\n  /** All results for a check up to this snapshot. */\n  getHistory(checkId: string): Array<ReviewSummary & { output?: unknown; content?: string }> {\n    return this.journal\n      .readVisible(this.sessionId, this.snapshotId, this.event)\n      .filter(e => e.checkId === checkId)\n      .map(e => e.result);\n  }\n\n  private sameScope(a: ScopePath, b: ScopePath): boolean {\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (a[i].check !== b[i].check || a[i].index !== b[i].index) return false;\n    }\n    return true;\n  }\n\n  // distance from ancestor to current; -1 if not ancestor\n  private ancestorDistance(ancestor: ScopePath, current: ScopePath): number {\n    if (ancestor.length > current.length) return -1;\n    // Treat root scope ([]) as non-ancestor for unrelated branches\n    if (ancestor.length === 0 && current.length > 0) return -1;\n    for (let i = 0; i < ancestor.length; i++) {\n      if (ancestor[i].check !== current[i].check || ancestor[i].index !== current[i].index)\n        return -1;\n    }\n    return current.length - ancestor.length;\n  }\n}\n","/**\n * Routing State Handler\n *\n * Responsibilities:\n * - Evaluate fail_if conditions after check execution\n * - Process on_success, on_fail, on_finish triggers\n * - Enqueue ForwardRunRequested events for goto\n * - Enqueue WaveRetry events for routing loops\n * - Transition back to WavePlanning or Completed\n *\n * M2: Core routing logic implementation\n */\n\nimport type {\n  EngineContext,\n  RunState,\n  EngineState,\n  EngineEvent\n} from '../../types/engine';\nimport type { ReviewSummary, ReviewIssue } from '../../reviewer';\nimport type { CheckConfig, OnFailConfig } from '../../types/config';\nimport { logger } from '../../logger';\nimport { FailureConditionEvaluator } from '../../failure-condition-evaluator';\nimport { createSecureSandbox, compileAndRun } from '../../utils/sandbox';\n\n/**\n * Context for a check that just completed and needs routing evaluation\n */\ninterface RoutingContext {\n  checkId: string;\n  scope: Array<{ check: string; index: number }>;\n  result: ReviewSummary;\n  checkConfig: CheckConfig;\n  success: boolean; // true if no fatal issues\n}\n\n/**\n * Handle routing state - evaluate conditions and decide next actions\n */\nexport async function handleRouting(\n  context: EngineContext,\n  state: RunState,\n  transition: (newState: EngineState) => void,\n  emitEvent: (event: EngineEvent) => void,\n  routingContext: RoutingContext\n): Promise<void> {\n  const { checkId, scope, result, checkConfig, success } = routingContext;\n\n  if (context.debug) {\n    logger.info(`[Routing] Evaluating routing for check: ${checkId}, success: ${success}`);\n  }\n\n  // Step 1: Evaluate fail_if conditions\n  const failIfTriggered = await evaluateFailIf(\n    checkId,\n    result,\n    checkConfig,\n    context,\n    state\n  );\n\n  if (failIfTriggered) {\n    if (context.debug) {\n      logger.info(`[Routing] fail_if triggered for ${checkId}`);\n    }\n\n    // Treat as failure for routing purposes\n    await processOnFail(checkId, scope, result, checkConfig, context, state, emitEvent);\n  } else if (success) {\n    // Step 2: Process on_success routing\n    await processOnSuccess(checkId, scope, result, checkConfig, context, state, emitEvent);\n  } else {\n    // Step 3: Process on_fail routing\n    await processOnFail(checkId, scope, result, checkConfig, context, state, emitEvent);\n  }\n\n  // Step 4: Check if this is a forEach parent with on_finish\n  // M4: Basic on_finish support for loop budget enforcement\n  if (checkConfig.on_finish && checkConfig.forEach) {\n    await processOnFinish(checkId, scope, result, checkConfig, context, state, emitEvent);\n  }\n\n  // Transition back to WavePlanning to process queued events\n  transition('WavePlanning');\n}\n\n/**\n * Process on_finish routing\n */\nasync function processOnFinish(\n  checkId: string,\n  scope: Array<{ check: string; index: number }>,\n  result: ReviewSummary,\n  checkConfig: CheckConfig,\n  context: EngineContext,\n  state: RunState,\n  emitEvent: (event: EngineEvent) => void\n): Promise<void> {\n  const onFinish = checkConfig.on_finish;\n\n  if (!onFinish) {\n    return; // No on_finish configuration\n  }\n\n  if (context.debug) {\n    logger.info(`[Routing] Processing on_finish for ${checkId}`);\n  }\n\n  // Process on_finish.run\n  if (onFinish.run && onFinish.run.length > 0) {\n    for (const targetCheck of onFinish.run) {\n      // Check loop budget before scheduling\n      if (checkLoopBudget(context, state, 'on_finish', 'run')) {\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_finish run`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return;\n      }\n\n      if (context.debug) {\n        logger.info(`[Routing] on_finish.run: scheduling ${targetCheck}`);\n      }\n\n      // Increment loop count\n      state.routingLoopCount++;\n\n      emitEvent({\n        type: 'ForwardRunRequested',\n        target: targetCheck,\n        scope,\n      });\n    }\n  }\n\n  // Process on_finish.run_js\n  if (onFinish.run_js) {\n    const dynamicTargets = await evaluateRunJs(\n      onFinish.run_js,\n      checkId,\n      checkConfig,\n      result,\n      context,\n      state\n    );\n\n    for (const targetCheck of dynamicTargets) {\n      // Check loop budget before scheduling\n      if (checkLoopBudget(context, state, 'on_finish', 'run')) {\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_finish run`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return;\n      }\n\n      if (context.debug) {\n        logger.info(`[Routing] on_finish.run_js: scheduling ${targetCheck}`);\n      }\n\n      // Increment loop count\n      state.routingLoopCount++;\n\n      emitEvent({\n        type: 'ForwardRunRequested',\n        target: targetCheck,\n        scope,\n      });\n    }\n  }\n\n  // Process on_finish.goto / goto_js\n  const gotoTarget = onFinish.goto || null;\n\n  if (gotoTarget) {\n    // Check loop budget before scheduling goto\n    if (checkLoopBudget(context, state, 'on_finish', 'goto')) {\n      const errorIssue: ReviewIssue = {\n        file: 'system',\n        line: 0,\n        ruleId: `${checkId}/routing/loop_budget_exceeded`,\n        message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_finish goto`,\n        severity: 'error',\n        category: 'logic',\n      };\n      result.issues = [...(result.issues || []), errorIssue];\n      return;\n    }\n\n    if (context.debug) {\n      logger.info(`[Routing] on_finish.goto: ${gotoTarget}`);\n    }\n\n    // Increment loop count\n    state.routingLoopCount++;\n\n    // Enqueue forward run event\n    emitEvent({\n      type: 'ForwardRunRequested',\n      target: gotoTarget,\n      scope,\n    });\n\n    // Mark that we've seen a forward run\n    state.flags.forwardRunRequested = true;\n  }\n}\n\n/**\n * Evaluate fail_if conditions for a check\n */\nasync function evaluateFailIf(\n  checkId: string,\n  result: ReviewSummary,\n  checkConfig: CheckConfig,\n  context: EngineContext,\n  state: RunState\n): Promise<boolean> {\n  const config = context.config;\n\n  // Check for fail_if at global or check level\n  const globalFailIf = config.fail_if;\n  const checkFailIf = checkConfig.fail_if;\n\n  if (!globalFailIf && !checkFailIf) {\n    return false; // No fail_if conditions\n  }\n\n  const evaluator = new FailureConditionEvaluator();\n\n  // Build outputs record from state\n  const outputsRecord: Record<string, ReviewSummary> = {};\n  for (const [key] of state.stats.entries()) {\n    // Try to get the actual result from context.journal if available\n    try {\n      const snapshotId = context.journal.beginSnapshot();\n      const contextView = new (require('../../snapshot-store').ContextView)(\n        context.journal,\n        context.sessionId,\n        snapshotId,\n        [],\n        context.event\n      );\n      const journalResult = contextView.get(key);\n      if (journalResult) {\n        outputsRecord[key] = journalResult as ReviewSummary;\n      }\n    } catch {\n      // Fallback to empty result\n      outputsRecord[key] = { issues: [] };\n    }\n  }\n\n  const checkSchema = typeof checkConfig.schema === 'object' ? 'custom' : checkConfig.schema || '';\n  const checkGroup = checkConfig.group || '';\n\n  // Evaluate global fail_if\n  if (globalFailIf) {\n    try {\n      const failed = await evaluator.evaluateSimpleCondition(\n        checkId,\n        checkSchema,\n        checkGroup,\n        result,\n        globalFailIf,\n        outputsRecord\n      );\n\n      if (failed) {\n        logger.warn(`[Routing] Global fail_if triggered for ${checkId}: ${globalFailIf}`);\n\n        // Add fail_if issue to result\n        const failIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: 'global_fail_if',\n          message: `Global failure condition met: ${globalFailIf}`,\n          severity: 'error',\n          category: 'logic',\n        };\n\n        result.issues = [...(result.issues || []), failIssue];\n        return true;\n      }\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : String(error);\n      logger.error(`[Routing] Error evaluating global fail_if: ${msg}`);\n    }\n  }\n\n  // Evaluate check-specific fail_if\n  if (checkFailIf) {\n    try {\n      const failed = await evaluator.evaluateSimpleCondition(\n        checkId,\n        checkSchema,\n        checkGroup,\n        result,\n        checkFailIf,\n        outputsRecord\n      );\n\n      if (failed) {\n        logger.warn(`[Routing] Check fail_if triggered for ${checkId}: ${checkFailIf}`);\n\n        // Add fail_if issue to result\n        const failIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}_fail_if`,\n          message: `Check failure condition met: ${checkFailIf}`,\n          severity: 'error',\n          category: 'logic',\n        };\n\n        result.issues = [...(result.issues || []), failIssue];\n        return true;\n      }\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : String(error);\n      logger.error(`[Routing] Error evaluating check fail_if: ${msg}`);\n    }\n  }\n\n  return false;\n}\n\n/**\n * Check if routing loop budget is exceeded\n */\nfunction checkLoopBudget(\n  context: EngineContext,\n  state: RunState,\n  origin: 'on_success' | 'on_fail' | 'on_finish',\n  action: 'run' | 'goto'\n): boolean {\n  const maxLoops = context.config.routing?.max_loops ?? 10;\n\n  if (state.routingLoopCount >= maxLoops) {\n    const msg = `Routing loop budget exceeded (max_loops=${maxLoops}) during ${origin} ${action}`;\n    logger.error(`[Routing] ${msg}`);\n    return true; // Budget exceeded\n  }\n\n  return false; // Budget OK\n}\n\n/**\n * Process on_success routing\n */\nasync function processOnSuccess(\n  checkId: string,\n  scope: Array<{ check: string; index: number }>,\n  result: ReviewSummary,\n  checkConfig: CheckConfig,\n  context: EngineContext,\n  state: RunState,\n  emitEvent: (event: EngineEvent) => void\n): Promise<void> {\n  const onSuccess = checkConfig.on_success;\n\n  if (!onSuccess) {\n    return; // No on_success configuration\n  }\n\n  if (context.debug) {\n    logger.info(`[Routing] Processing on_success for ${checkId}`);\n  }\n\n  // Process on_success.run\n  if (onSuccess.run && onSuccess.run.length > 0) {\n    for (const targetCheck of onSuccess.run) {\n      // Check loop budget before scheduling\n      if (checkLoopBudget(context, state, 'on_success', 'run')) {\n        // Add error issue to result\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_success run`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return; // Stop processing\n      }\n\n      if (context.debug) {\n        logger.info(`[Routing] on_success.run: scheduling ${targetCheck}`);\n      }\n\n      // Increment loop count\n      state.routingLoopCount++;\n\n      // Enqueue the check to run in next wave\n      emitEvent({\n        type: 'ForwardRunRequested',\n        target: targetCheck,\n        scope,\n      });\n    }\n  }\n\n  // Process on_success.run_js\n  if (onSuccess.run_js) {\n    const dynamicTargets = await evaluateRunJs(\n      onSuccess.run_js,\n      checkId,\n      checkConfig,\n      result,\n      context,\n      state\n    );\n\n    for (const targetCheck of dynamicTargets) {\n      // Check loop budget before scheduling\n      if (checkLoopBudget(context, state, 'on_success', 'run')) {\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_success run`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return;\n      }\n\n      if (context.debug) {\n        logger.info(`[Routing] on_success.run_js: scheduling ${targetCheck}`);\n      }\n\n      // Increment loop count\n      state.routingLoopCount++;\n\n      emitEvent({\n        type: 'ForwardRunRequested',\n        target: targetCheck,\n        scope,\n      });\n    }\n  }\n\n  // Process on_success.goto / goto_js\n  const gotoTarget = await evaluateGoto(\n    onSuccess.goto_js,\n    onSuccess.goto,\n    checkId,\n    checkConfig,\n    result,\n    context,\n    state\n  );\n\n  if (gotoTarget) {\n    // Check loop budget before scheduling goto\n    if (checkLoopBudget(context, state, 'on_success', 'goto')) {\n      const errorIssue: ReviewIssue = {\n        file: 'system',\n        line: 0,\n        ruleId: `${checkId}/routing/loop_budget_exceeded`,\n        message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_success goto`,\n        severity: 'error',\n        category: 'logic',\n      };\n      result.issues = [...(result.issues || []), errorIssue];\n      return;\n    }\n\n    if (context.debug) {\n      logger.info(`[Routing] on_success.goto: ${gotoTarget}`);\n    }\n\n    // Increment loop count\n    state.routingLoopCount++;\n\n    // Enqueue forward run event with optional event override\n    emitEvent({\n      type: 'ForwardRunRequested',\n      target: gotoTarget,\n      gotoEvent: onSuccess.goto_event,\n      scope,\n    });\n\n    // Mark that we've seen a forward run\n    state.flags.forwardRunRequested = true;\n  }\n}\n\n/**\n * Process on_fail routing\n */\nasync function processOnFail(\n  checkId: string,\n  scope: Array<{ check: string; index: number }>,\n  result: ReviewSummary,\n  checkConfig: CheckConfig,\n  context: EngineContext,\n  state: RunState,\n  emitEvent: (event: EngineEvent) => void\n): Promise<void> {\n  // Merge defaults with check-specific on_fail\n  const defaults = context.config.routing?.defaults?.on_fail || {};\n  const onFail: OnFailConfig | undefined = checkConfig.on_fail\n    ? { ...defaults, ...checkConfig.on_fail }\n    : undefined;\n\n  if (!onFail) {\n    return; // No on_fail configuration\n  }\n\n  if (context.debug) {\n    logger.info(`[Routing] Processing on_fail for ${checkId}`);\n  }\n\n  // Process on_fail.run\n  if (onFail.run && onFail.run.length > 0) {\n    for (const targetCheck of onFail.run) {\n      // Check loop budget before scheduling\n      if (checkLoopBudget(context, state, 'on_fail', 'run')) {\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_fail run`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return;\n      }\n\n      if (context.debug) {\n        logger.info(`[Routing] on_fail.run: scheduling ${targetCheck}`);\n      }\n\n      // Increment loop count\n      state.routingLoopCount++;\n\n      emitEvent({\n        type: 'ForwardRunRequested',\n        target: targetCheck,\n        scope,\n      });\n    }\n  }\n\n  // Process on_fail.run_js\n  if (onFail.run_js) {\n    const dynamicTargets = await evaluateRunJs(\n      onFail.run_js,\n      checkId,\n      checkConfig,\n      result,\n      context,\n      state\n    );\n\n    for (const targetCheck of dynamicTargets) {\n      // Check loop budget before scheduling\n      if (checkLoopBudget(context, state, 'on_fail', 'run')) {\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_fail run`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return;\n      }\n\n      if (context.debug) {\n        logger.info(`[Routing] on_fail.run_js: scheduling ${targetCheck}`);\n      }\n\n      // Increment loop count\n      state.routingLoopCount++;\n\n      emitEvent({\n        type: 'ForwardRunRequested',\n        target: targetCheck,\n        scope,\n      });\n    }\n  }\n\n  // Process on_fail.goto / goto_js\n  const gotoTarget = await evaluateGoto(\n    onFail.goto_js,\n    onFail.goto,\n    checkId,\n    checkConfig,\n    result,\n    context,\n    state\n  );\n\n  if (gotoTarget) {\n    // Check loop budget before scheduling goto\n    if (checkLoopBudget(context, state, 'on_fail', 'goto')) {\n      const errorIssue: ReviewIssue = {\n        file: 'system',\n        line: 0,\n        ruleId: `${checkId}/routing/loop_budget_exceeded`,\n        message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_fail goto`,\n        severity: 'error',\n        category: 'logic',\n      };\n      result.issues = [...(result.issues || []), errorIssue];\n      return;\n    }\n\n    if (context.debug) {\n      logger.info(`[Routing] on_fail.goto: ${gotoTarget}`);\n    }\n\n    // Increment loop count\n    state.routingLoopCount++;\n\n    // Enqueue forward run event with optional event override\n    emitEvent({\n      type: 'ForwardRunRequested',\n      target: gotoTarget,\n      gotoEvent: onFail.goto_event,\n      scope,\n    });\n\n    // Mark that we've seen a forward run\n    state.flags.forwardRunRequested = true;\n  }\n}\n\n/**\n * Evaluate run_js expression to get dynamic check targets\n */\nasync function evaluateRunJs(\n  runJs: string,\n  checkId: string,\n  checkConfig: CheckConfig,\n  result: ReviewSummary,\n  context: EngineContext,\n  state: RunState\n): Promise<string[]> {\n  try {\n    const sandbox = createSecureSandbox();\n\n    // Build outputs record\n    const outputsRecord: Record<string, any> = {};\n    for (const [key] of state.stats.entries()) {\n      try {\n        const snapshotId = context.journal.beginSnapshot();\n        const contextView = new (require('../../snapshot-store').ContextView)(\n          context.journal,\n          context.sessionId,\n          snapshotId,\n          [],\n          context.event\n        );\n        const journalResult = contextView.get(key);\n        if (journalResult) {\n          outputsRecord[key] = journalResult;\n        }\n      } catch {\n        outputsRecord[key] = { issues: [] };\n      }\n    }\n\n    const scopeObj: any = {\n      step: {\n        id: checkId,\n        tags: checkConfig.tags || [],\n        group: checkConfig.group\n      },\n      outputs: outputsRecord,\n      output: (result as any)?.output,\n      event: {\n        name: context.event || 'manual'\n      },\n    };\n\n    const code = `\n      const step = scope.step;\n      const outputs = scope.outputs;\n      const output = scope.output;\n      const event = scope.event;\n      const log = (...args) => console.log('üîç Debug:', ...args);\n      const __fn = () => {\n        ${runJs}\n      };\n      const __res = __fn();\n      return Array.isArray(__res) ? __res.filter(x => typeof x === 'string' && x) : [];\n    `;\n\n    const evalResult = compileAndRun<string[]>(\n      sandbox,\n      code,\n      { scope: scopeObj },\n      { injectLog: false, wrapFunction: false }\n    );\n\n    return Array.isArray(evalResult) ? evalResult.filter(Boolean) : [];\n  } catch (error) {\n    const msg = error instanceof Error ? error.message : String(error);\n    logger.error(`[Routing] Error evaluating run_js: ${msg}`);\n    return [];\n  }\n}\n\n/**\n * Evaluate goto_js or return static goto target\n */\nasync function evaluateGoto(\n  gotoJs: string | undefined,\n  gotoStatic: string | undefined,\n  checkId: string,\n  checkConfig: CheckConfig,\n  result: ReviewSummary,\n  context: EngineContext,\n  state: RunState\n): Promise<string | null> {\n  // Evaluate goto_js first\n  if (gotoJs) {\n    try {\n      const sandbox = createSecureSandbox();\n\n      // Build outputs record\n      const outputsRecord: Record<string, any> = {};\n      for (const [key] of state.stats.entries()) {\n        try {\n          const snapshotId = context.journal.beginSnapshot();\n          const contextView = new (require('../../snapshot-store').ContextView)(\n            context.journal,\n            context.sessionId,\n            snapshotId,\n            [],\n            context.event\n          );\n          const journalResult = contextView.get(key);\n          if (journalResult) {\n            outputsRecord[key] = journalResult;\n          }\n        } catch {\n          outputsRecord[key] = { issues: [] };\n        }\n      }\n\n      const scopeObj: any = {\n        step: {\n          id: checkId,\n          tags: checkConfig.tags || [],\n          group: checkConfig.group\n        },\n        outputs: outputsRecord,\n        output: (result as any)?.output,\n        event: {\n          name: context.event || 'manual'\n        },\n      };\n\n      const code = `\n        const step = scope.step;\n        const outputs = scope.outputs;\n        const output = scope.output;\n        const event = scope.event;\n        const log = (...args) => console.log('üîç Debug:', ...args);\n        ${gotoJs}\n      `;\n\n      const evalResult = compileAndRun<string | null>(\n        sandbox,\n        code,\n        { scope: scopeObj },\n        { injectLog: false, wrapFunction: true }\n      );\n\n      if (typeof evalResult === 'string' && evalResult) {\n        return evalResult;\n      }\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : String(error);\n      logger.error(`[Routing] Error evaluating goto_js: ${msg}`);\n\n      // Fall back to static goto if available\n      if (gotoStatic) {\n        logger.info(`[Routing] Falling back to static goto: ${gotoStatic}`);\n        return gotoStatic;\n      }\n    }\n  }\n\n  // Return static goto\n  return gotoStatic || null;\n}\n","/**\n * LevelDispatch State Handler\n *\n * Responsibilities:\n * - Pop next topological level from queue\n * - Spawn tasks up to maxParallelism\n * - Handle session reuse barriers\n * - Support fail-fast\n * - Support debug pause\n * - Execute actual provider logic\n * - Transition back to WavePlanning or handle errors\n *\n * M2: Integrates actual provider execution and routing\n */\n\nimport type { EngineContext, RunState, EngineState, EngineEvent, DispatchRecord } from '../../types/engine';\nimport { logger } from '../../logger';\nimport type { ReviewSummary, ReviewIssue } from '../../reviewer';\nimport type { CheckExecutionStats } from '../../check-execution-engine';\nimport type { CheckProviderConfig } from '../../providers/check-provider.interface';\nimport type { CheckConfig } from '../../types/config';\nimport { handleRouting } from './routing';\nimport { withActiveSpan } from '../../telemetry/trace-helpers';\nimport { emitMermaidFromMarkdown } from '../../utils/mermaid-telemetry';\nimport { Liquid } from 'liquidjs';\nimport { emitNdjsonSpanWithEvents, emitNdjsonFallback } from '../../telemetry/fallback-ndjson';\nimport { FailureConditionEvaluator } from '../../failure-condition-evaluator';\n\n/**\n * Build output history Map from journal for template rendering\n * This matches the format expected by AI providers\n */\nfunction buildOutputHistoryFromJournal(context: EngineContext): Map<string, unknown[]> {\n  const outputHistory = new Map<string, unknown[]>();\n\n  try {\n    const snapshot = context.journal.beginSnapshot();\n    const allEntries = context.journal.readVisible(context.sessionId, snapshot, undefined);\n\n    // Group by checkId and extract outputs\n    for (const entry of allEntries) {\n      const checkId = entry.checkId;\n      if (!outputHistory.has(checkId)) {\n        outputHistory.set(checkId, []);\n      }\n      // Push the output if it exists\n      if (entry.result.output !== undefined) {\n        outputHistory.get(checkId)!.push(entry.result.output);\n      }\n    }\n  } catch (error) {\n    // Silently fail - return empty map\n    logger.debug(`[LevelDispatch] Error building output history: ${error}`);\n  }\n\n  return outputHistory;\n}\n\n/**\n * Evaluate 'if' condition for a check\n *\n * Note: For routing loops to work correctly, 'outputs' should only include\n * results from the CURRENT wave, not from previous waves. This allows\n * checks to re-execute after routing (goto/on_fail/on_success) triggers.\n */\nasync function evaluateIfCondition(\n  checkId: string,\n  checkConfig: CheckConfig,\n  context: EngineContext,\n  state: RunState\n): Promise<boolean> {\n  const ifExpression = checkConfig.if;\n  if (!ifExpression) {\n    return true; // No condition means always run\n  }\n\n  try {\n    const evaluator = new FailureConditionEvaluator();\n\n    // Build previous results from CURRENT WAVE ONLY\n    // This ensures that when routing creates a new wave via goto/on_fail,\n    // the 'outputs' context is reset and checks can re-execute\n    const previousResults = new Map<string, ReviewSummary>();\n\n    // Check if we're tracking wave-specific completions\n    const currentWaveCompletions = (state as any).currentWaveCompletions as Set<string> | undefined;\n\n    if (currentWaveCompletions) {\n      // Only include outputs from checks completed in the current wave\n      for (const key of currentWaveCompletions) {\n        try {\n          const snapshotId = context.journal.beginSnapshot();\n          const contextView = new (require('../../snapshot-store').ContextView)(\n            context.journal,\n            context.sessionId,\n            snapshotId,\n            [],\n            context.event\n          );\n          const journalResult = contextView.get(key);\n          if (journalResult) {\n            previousResults.set(key, journalResult as ReviewSummary);\n          }\n        } catch {\n          // Silently skip - will use empty result\n        }\n      }\n    }\n    // Fallback: if no wave tracking, use empty outputs (allows all checks to run)\n\n    // Build context data for if condition evaluation\n    const contextData = {\n      previousResults,\n      event: context.event || 'manual',\n      branch: (context.prInfo as any)?.branch,\n      baseBranch: (context.prInfo as any)?.baseBranch,\n      filesChanged: context.prInfo?.files?.map(f => f.filename),\n    };\n\n    const shouldRun = await evaluator.evaluateIfCondition(checkId, ifExpression, contextData);\n    return shouldRun;\n  } catch (error) {\n    const msg = error instanceof Error ? error.message : String(error);\n    logger.error(`[LevelDispatch] Error evaluating if condition for ${checkId}: ${msg}`);\n    // On error, default to running the check\n    return true;\n  }\n}\n\nexport async function handleLevelDispatch(\n  context: EngineContext,\n  state: RunState,\n  transition: (newState: EngineState) => void,\n  emitEvent: (event: EngineEvent) => void\n): Promise<void> {\n  // Pop next level from queue\n  const level = state.levelQueue.shift();\n\n  if (!level) {\n    // No more levels - go back to wave planning\n    if (context.debug) {\n      logger.info('[LevelDispatch] No more levels in queue');\n    }\n    transition('WavePlanning');\n    return;\n  }\n\n  if (context.debug) {\n    logger.info(`[LevelDispatch] Executing level ${level.level} with ${level.parallel.length} checks`);\n  }\n\n  // Update current level tracking\n  state.currentLevel = level.level;\n  state.currentLevelChecks = new Set(level.parallel);\n\n  // Emit level ready event\n  emitEvent({ type: 'LevelReady', level, wave: state.wave });\n\n  const maxParallelism = context.maxParallelism || 10;\n  const results: Array<{ checkId: string; result: ReviewSummary; error?: Error }> = [];\n\n  // Group checks by session provider to enforce session reuse barriers\n  const sessionGroups = groupBySession(level.parallel, context);\n\n  // Execute each session group sequentially, but checks within group in parallel\n  for (const group of sessionGroups) {\n    const groupResults = await executeCheckGroup(\n      group,\n      context,\n      state,\n      maxParallelism,\n      emitEvent,\n      transition\n    );\n    results.push(...groupResults);\n\n    // Check fail-fast\n    if (context.failFast && shouldFailFast(results)) {\n      logger.warn('[LevelDispatch] Fail-fast triggered');\n      state.flags.failFastTriggered = true;\n      break;\n    }\n  }\n\n  // Emit level depleted event\n  emitEvent({ type: 'LevelDepleted', level: level.level, wave: state.wave });\n\n  // Update stats\n  updateStats(results, state);\n\n  // Check if fail-fast was triggered\n  if (state.flags.failFastTriggered) {\n    // Skip remaining levels\n    state.levelQueue = [];\n    if (context.debug) {\n      logger.info('[LevelDispatch] Fail-fast triggered, clearing level queue');\n    }\n  }\n\n  // Clear current level tracking\n  state.currentLevelChecks.clear();\n\n  // Transition back to WavePlanning\n  transition('WavePlanning');\n}\n\n/**\n * Group checks by session provider to enforce sequential execution\n */\nfunction groupBySession(checks: string[], context: EngineContext): string[][] {\n  // M2: Group checks that share a session provider\n  const sessionProviderMap = new Map<string, string[]>();\n  const noSessionChecks: string[] = [];\n\n  for (const checkId of checks) {\n    const metadata = context.checks[checkId];\n    const sessionProvider = metadata?.sessionProvider;\n\n    if (sessionProvider) {\n      const group = sessionProviderMap.get(sessionProvider) || [];\n      group.push(checkId);\n      sessionProviderMap.set(sessionProvider, group);\n    } else {\n      noSessionChecks.push(checkId);\n    }\n  }\n\n  // Return groups: first all session groups (sequential), then independent checks\n  const groups: string[][] = [];\n\n  // Add session groups (each group runs sequentially relative to other session groups)\n  for (const group of sessionProviderMap.values()) {\n    groups.push(group);\n  }\n\n  // Add independent checks as one group (can run in parallel)\n  if (noSessionChecks.length > 0) {\n    groups.push(noSessionChecks);\n  }\n\n  return groups;\n}\n\n/**\n * Execute a group of checks in parallel (up to maxParallelism)\n */\nasync function executeCheckGroup(\n  checks: string[],\n  context: EngineContext,\n  state: RunState,\n  maxParallelism: number,\n  emitEvent: (event: EngineEvent) => void,\n  transition: (newState: EngineState) => void\n): Promise<Array<{ checkId: string; result: ReviewSummary; error?: Error }>> {\n  const results: Array<{ checkId: string; result: ReviewSummary; error?: Error }> = [];\n\n  // Execute with limited parallelism\n  const pool: Promise<void>[] = [];\n\n  for (const checkId of checks) {\n    // Wait if pool is full\n    if (pool.length >= maxParallelism) {\n      await Promise.race(pool);\n      // Remove completed promises\n      pool.splice(0, pool.length, ...pool.filter(p => {\n        const settled = (p as any)._settled;\n        return !settled;\n      }));\n    }\n\n    // Execute check\n    const promise = (async () => {\n      try {\n        const result = await executeSingleCheck(checkId, context, state, emitEvent, transition);\n        results.push({ checkId, result });\n      } catch (error) {\n        const err = error instanceof Error ? error : new Error(String(error));\n        logger.error(`[LevelDispatch] Error executing check ${checkId}: ${err.message}`);\n        results.push({ checkId, result: { issues: [] }, error: err });\n      }\n    })();\n\n    // Mark promise as settled when done\n    promise.then(() => {\n      (promise as any)._settled = true;\n    }).catch(() => {\n      (promise as any)._settled = true;\n    });\n\n    pool.push(promise);\n  }\n\n  // Wait for all remaining checks\n  await Promise.all(pool);\n\n  return results;\n}\n\n/**\n * Execute a check multiple times for forEach items\n */\nasync function executeCheckWithForEachItems(\n  checkId: string,\n  forEachParent: string,\n  forEachItems: unknown[],\n  context: EngineContext,\n  state: RunState,\n  emitEvent: (event: EngineEvent) => void,\n  transition: (newState: EngineState) => void\n): Promise<ReviewSummary> {\n  const checkConfig = context.config.checks?.[checkId];\n  if (!checkConfig) {\n    throw new Error(`Check configuration not found: ${checkId}`);\n  }\n\n  const allIssues: ReviewIssue[] = [];\n  const perItemResults: ReviewSummary[] = [];\n  const allOutputs: unknown[] = [];\n  const allContents: string[] = [];\n\n  // Execute check once per forEach item\n  for (let itemIndex = 0; itemIndex < forEachItems.length; itemIndex++) {\n    const scope: Array<{ check: string; index: number }> = [\n      { check: forEachParent, index: itemIndex }\n    ];\n\n    // Emit visor.foreach.item span for telemetry\n    try {\n      emitNdjsonSpanWithEvents(\n        'visor.foreach.item',\n        {\n          'visor.check.id': checkId,\n          'visor.foreach.index': itemIndex,\n          'visor.foreach.total': forEachItems.length,\n        },\n        []\n      );\n    } catch (error) {\n      logger.warn(`[LevelDispatch] Failed to emit foreach.item span: ${error}`);\n    }\n\n    // Emit scheduled event\n    emitEvent({ type: 'CheckScheduled', checkId, scope });\n\n    // Create dispatch record\n    const dispatch: DispatchRecord = {\n      id: `${checkId}-${itemIndex}-${Date.now()}`,\n      checkId,\n      scope,\n      provider: context.checks[checkId]?.providerType || 'unknown',\n      startMs: Date.now(),\n      attempts: 1,\n      foreachIndex: itemIndex,\n    };\n\n    state.activeDispatches.set(`${checkId}-${itemIndex}`, dispatch);\n\n    try {\n      // Get provider\n      const providerType = checkConfig.type || 'ai';\n      const providerRegistry = require('../../providers/check-provider-registry').CheckProviderRegistry.getInstance();\n      const provider = providerRegistry.getProviderOrThrow(providerType);\n\n      // Build output history for template rendering\n      const outputHistory = buildOutputHistoryFromJournal(context);\n\n      // Build provider configuration\n      const providerConfig: CheckProviderConfig = {\n        type: providerType,\n        checkName: checkId,\n        prompt: checkConfig.prompt,\n        exec: checkConfig.exec,\n        schema: checkConfig.schema,\n        group: checkConfig.group,\n        focus: checkConfig.focus,\n        transform: checkConfig.transform,\n        transform_js: checkConfig.transform_js,\n        env: checkConfig.env,\n        forEach: checkConfig.forEach,\n        ...checkConfig,\n        eventContext: (context.prInfo as any)?.eventContext || {},\n        __outputHistory: outputHistory,\n        ai: {\n          ...(checkConfig.ai || {}),\n          timeout: checkConfig.ai?.timeout || 600000,\n          debug: !!context.debug,\n        },\n      };\n\n      // Build dependency results with scope\n      const dependencyResults = buildDependencyResultsWithScope(checkId, checkConfig, context, scope);\n\n      // Build PR info (use real prInfo from context if available, otherwise use defaults)\n      const prInfo: any = context.prInfo || {\n        number: 1,\n        title: 'State Machine Execution',\n        author: 'system',\n        eventType: context.event || 'manual',\n        eventContext: {},\n        files: [],\n        commits: [],\n      };\n\n      // Build execution context\n      const executionContext = {\n        ...context.executionContext,\n        _engineMode: context.mode,\n        _parentContext: context,\n        _parentState: state,\n      };\n\n      // Emit provider telemetry\n      try {\n        emitNdjsonFallback('visor.provider', {\n          'visor.check.id': checkId,\n          'visor.provider.type': providerType,\n        });\n      } catch {}\n\n      // Execute provider with telemetry\n      const itemResult = await withActiveSpan(\n        `visor.check.${checkId}`,\n        {\n          'visor.check.id': checkId,\n          'visor.check.type': providerType,\n          'visor.foreach.index': itemIndex,\n        },\n        async () => provider.execute(prInfo, providerConfig, dependencyResults, executionContext)\n      );\n\n      // Enrich issues\n      const enrichedIssues = (itemResult.issues || []).map((issue: ReviewIssue) => ({\n        ...issue,\n        checkName: checkId,\n        ruleId: `${checkId}/${issue.ruleId || 'unknown'}`,\n        group: checkConfig.group,\n        schema: typeof checkConfig.schema === 'object' ? 'custom' : checkConfig.schema,\n        template: checkConfig.template,\n        timestamp: Date.now(),\n      }));\n\n      const enrichedResult: ReviewSummary = {\n        ...itemResult,\n        issues: enrichedIssues,\n      };\n\n      // Store per-item result\n      perItemResults.push(enrichedResult);\n      allIssues.push(...enrichedIssues);\n\n      // Track output\n      const output = (itemResult as any).output;\n      allOutputs.push(output);\n\n      // Track content\n      const content = (itemResult as any).content;\n      if (typeof content === 'string' && content.trim()) {\n        allContents.push(content.trim());\n      }\n\n      // Store in journal with scope\n      try {\n        context.journal.commitEntry({\n          sessionId: context.sessionId,\n          checkId,\n          result: enrichedResult as any,\n          event: context.event || 'manual',\n          scope,\n        });\n      } catch (error) {\n        logger.warn(`[LevelDispatch] Failed to commit to journal: ${error}`);\n      }\n\n      state.activeDispatches.delete(`${checkId}-${itemIndex}`);\n\n      // Emit completed event\n      emitEvent({\n        type: 'CheckCompleted',\n        checkId,\n        scope,\n        result: {\n          ...enrichedResult,\n          output,\n        },\n      });\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[LevelDispatch] Error executing check ${checkId} item ${itemIndex}: ${err.message}`);\n\n      state.activeDispatches.delete(`${checkId}-${itemIndex}`);\n\n      // Emit error event\n      emitEvent({\n        type: 'CheckErrored',\n        checkId,\n        scope,\n        error: {\n          message: err.message,\n          stack: err.stack,\n          name: err.name,\n        },\n      });\n\n      // Add error to results\n      const errorIssue: ReviewIssue = {\n        file: '',\n        line: 0,\n        ruleId: `${checkId}/error`,\n        message: err.message,\n        severity: 'error',\n        category: 'logic',\n      };\n\n      allIssues.push(errorIssue);\n      perItemResults.push({ issues: [errorIssue] });\n    }\n  }\n\n  // Mark as completed\n  state.completedChecks.add(checkId);\n\n  // Return aggregated result\n  const aggregatedResult: any = {\n    issues: allIssues,\n    isForEach: true,\n    forEachItems: allOutputs,\n    forEachItemResults: perItemResults,\n    // Include aggregated content from all iterations\n    ...(allContents.length > 0 ? { content: allContents.join('\\n') } : {}),\n  };\n\n  // Store aggregated result in journal (without scope - this is the parent-level result)\n  try {\n    context.journal.commitEntry({\n      sessionId: context.sessionId,\n      checkId,\n      result: aggregatedResult as any,\n      event: context.event || 'manual',\n      scope: [],\n    });\n  } catch (error) {\n    logger.warn(`[LevelDispatch] Failed to commit aggregated forEach result to journal: ${error}`);\n  }\n\n  // Emit completed event for aggregated result\n  emitEvent({\n    type: 'CheckCompleted',\n    checkId,\n    scope: [],\n    result: aggregatedResult,\n  });\n\n  return aggregatedResult;\n}\n\n/**\n * Execute a single check with provider integration\n */\nasync function executeSingleCheck(\n  checkId: string,\n  context: EngineContext,\n  state: RunState,\n  emitEvent: (event: EngineEvent) => void,\n  transition: (newState: EngineState) => void\n): Promise<ReviewSummary> {\n  // Check if this check depends on a forEach parent\n  const checkConfig = context.config.checks?.[checkId];\n\n  // Evaluate 'if' condition before execution\n  if (checkConfig?.if) {\n    const shouldRun = await evaluateIfCondition(checkId, checkConfig, context, state);\n\n    if (!shouldRun) {\n      if (context.debug) {\n        logger.info(`[LevelDispatch] Skipping check ${checkId}: if condition evaluated to false`);\n      }\n\n      // Return empty result and mark as completed\n      const emptyResult: ReviewSummary = {\n        issues: [],\n      };\n\n      state.completedChecks.add(checkId);\n\n      // Store empty result in journal\n      try {\n        context.journal.commitEntry({\n          sessionId: context.sessionId,\n          checkId,\n          result: emptyResult as any,\n          event: context.event || 'manual',\n          scope: [],\n        });\n      } catch (error) {\n        logger.warn(`[LevelDispatch] Failed to commit skipped result to journal: ${error}`);\n      }\n\n      // Emit completed event\n      emitEvent({\n        type: 'CheckCompleted',\n        checkId,\n        scope: [],\n        result: emptyResult,\n      });\n\n      return emptyResult;\n    }\n  }\n\n  const dependencies = checkConfig?.depends_on || [];\n  const depList = Array.isArray(dependencies) ? dependencies : [dependencies];\n\n  let forEachParent: string | undefined;\n  let forEachItems: unknown[] | undefined;\n\n  // Find if any dependency is a forEach parent with items\n  for (const depId of depList) {\n    if (!depId) continue;\n\n    try {\n      const snapshotId = context.journal.beginSnapshot();\n      const contextView = new (require('../../snapshot-store').ContextView)(\n        context.journal,\n        context.sessionId,\n        snapshotId,\n        [],\n        context.event\n      );\n      const depResult: any = contextView.get(depId);\n\n      if (context.debug) {\n        logger.info(`[LevelDispatch] Checking dependency ${depId} for ${checkId}: has forEachItems=${!!depResult?.forEachItems}, isArray=${Array.isArray(depResult?.forEachItems)}`);\n        if (depResult?.forEachItems) {\n          logger.info(`[LevelDispatch] forEachItems length: ${depResult.forEachItems.length}, items: ${JSON.stringify(depResult.forEachItems).substring(0, 200)}`);\n        }\n      }\n\n      if (depResult?.forEachItems && Array.isArray(depResult.forEachItems)) {\n        forEachParent = depId;\n        forEachItems = depResult.forEachItems;\n        if (context.debug && forEachItems) {\n          logger.info(`[LevelDispatch] Detected forEach parent ${depId} with ${forEachItems.length} items for check ${checkId}`);\n        }\n        break;\n      }\n    } catch (error) {\n      if (context.debug) {\n        logger.warn(`[LevelDispatch] Error checking forEach parent ${depId}: ${error}`);\n      }\n    }\n  }\n\n  // If there's a forEach parent, execute once per item (or skip if empty)\n  if (forEachParent && forEachItems !== undefined) {\n    if (forEachItems.length === 0) {\n      // forEach parent has zero items - skip this check entirely\n      if (context.debug) {\n        logger.info(`[LevelDispatch] Skipping check ${checkId}: forEach parent ${forEachParent} has zero items`);\n      }\n\n      // Return empty result\n      const emptyResult: ReviewSummary = {\n        issues: [],\n      };\n\n      // Mark as completed\n      state.completedChecks.add(checkId);\n\n      // Store empty result in journal\n      try {\n        context.journal.commitEntry({\n          sessionId: context.sessionId,\n          checkId,\n          result: emptyResult as any,\n          event: context.event || 'manual',\n          scope: [],\n        });\n      } catch (error) {\n        logger.warn(`[LevelDispatch] Failed to commit empty result to journal: ${error}`);\n      }\n\n      // Emit completed event\n      emitEvent({\n        type: 'CheckCompleted',\n        checkId,\n        scope: [],\n        result: emptyResult,\n      });\n\n      return emptyResult;\n    }\n\n    return await executeCheckWithForEachItems(\n      checkId,\n      forEachParent,\n      forEachItems,\n      context,\n      state,\n      emitEvent,\n      transition\n    );\n  }\n\n  // Normal execution without forEach\n  const scope: Array<{ check: string; index: number }> = [];\n\n  // Emit scheduled event\n  emitEvent({ type: 'CheckScheduled', checkId, scope });\n\n  // Create dispatch record\n  const dispatch: DispatchRecord = {\n    id: `${checkId}-${Date.now()}`,\n    checkId,\n    scope,\n    provider: context.checks[checkId]?.providerType || 'unknown',\n    startMs: Date.now(),\n    attempts: 1,\n  };\n\n  state.activeDispatches.set(checkId, dispatch);\n\n  try {\n    // Get check configuration\n    const checkConfig = context.config.checks?.[checkId];\n    if (!checkConfig) {\n      throw new Error(`Check configuration not found: ${checkId}`);\n    }\n\n    // Get provider\n    const providerType = checkConfig.type || 'ai';\n    const providerRegistry = require('../../providers/check-provider-registry').CheckProviderRegistry.getInstance();\n    const provider = providerRegistry.getProviderOrThrow(providerType);\n\n    // Build output history for template rendering\n    const outputHistory = buildOutputHistoryFromJournal(context);\n\n    // Build provider configuration\n    const providerConfig: CheckProviderConfig = {\n      type: providerType,\n      checkName: checkId,\n      prompt: checkConfig.prompt,\n      exec: checkConfig.exec,\n      schema: checkConfig.schema,\n      group: checkConfig.group,\n      focus: checkConfig.focus,\n      transform: checkConfig.transform,\n      transform_js: checkConfig.transform_js,\n      env: checkConfig.env,\n      forEach: checkConfig.forEach,\n      ...checkConfig,\n      eventContext: (context.prInfo as any)?.eventContext || {},\n      __outputHistory: outputHistory,\n      ai: {\n        ...(checkConfig.ai || {}),\n        timeout: checkConfig.ai?.timeout || 600000,\n        debug: !!context.debug,\n      },\n    };\n\n    // Build dependency results\n    const dependencyResults = buildDependencyResults(checkId, checkConfig, context, state);\n\n    // Build PR info (use real prInfo from context if available, otherwise use defaults)\n    const prInfo: any = context.prInfo || {\n      number: 1,\n      title: 'State Machine Execution',\n      author: 'system',\n      eventType: context.event || 'manual',\n      eventContext: {},\n      files: [],\n      commits: [],\n    };\n\n    // Build execution context with engine mode and parent context (M3: nested workflows)\n    const executionContext = {\n      ...context.executionContext,\n      _engineMode: context.mode,\n      _parentContext: context,\n      _parentState: state,\n    };\n\n    // Emit provider telemetry\n    try {\n      emitNdjsonFallback('visor.provider', {\n        'visor.check.id': checkId,\n        'visor.provider.type': providerType,\n      });\n    } catch {}\n\n    // Execute provider with telemetry\n    const result = await withActiveSpan(\n      `visor.check.${checkId}`,\n      { 'visor.check.id': checkId, 'visor.check.type': providerType },\n      async () => provider.execute(prInfo, providerConfig, dependencyResults, executionContext)\n    );\n\n    // Enrich issues with metadata\n    const enrichedIssues = (result.issues || []).map((issue: ReviewIssue) => ({\n      ...issue,\n      checkName: checkId,\n      ruleId: `${checkId}/${issue.ruleId || 'unknown'}`,\n      group: checkConfig.group,\n      schema: typeof checkConfig.schema === 'object' ? 'custom' : checkConfig.schema,\n      template: checkConfig.template,\n      timestamp: Date.now(),\n    }));\n\n    const enrichedResult: any = {\n      ...result,\n      issues: enrichedIssues,\n    };\n\n    // Handle forEach: true checks - convert output array to forEachItems\n    let isForEach = (result as any).isForEach;\n    let forEachItems = (result as any).forEachItems;\n\n    if (checkConfig.forEach === true) {\n      const output = (result as any).output;\n\n      // Validate forEach output (must not be undefined)\n      if (output === undefined) {\n        logger.error(`[LevelDispatch] forEach check \"${checkId}\" produced undefined output`);\n        const undefinedError: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: 'forEach/undefined_output',\n          message: `forEach check \"${checkId}\" produced undefined output. Verify your command outputs valid data and your transform_js returns a value.`,\n          severity: 'error',\n          category: 'logic',\n        };\n        enrichedResult.issues = [...(enrichedResult.issues || []), undefinedError];\n        // Mark as forEach with empty items to skip dependent iterations\n        isForEach = true;\n        forEachItems = [];\n        enrichedResult.isForEach = true;\n        enrichedResult.forEachItems = [];\n      } else if (Array.isArray(output)) {\n        isForEach = true;\n        forEachItems = output;\n        enrichedResult.isForEach = true;\n        enrichedResult.forEachItems = output;\n\n        if (context.debug) {\n          logger.info(`[LevelDispatch] Check ${checkId} is forEach parent with ${output.length} items`);\n        }\n      } else {\n        // forEach check but output is not an array - convert to single-item array\n        if (context.debug) {\n          logger.warn(`[LevelDispatch] Check ${checkId} has forEach:true but output is not an array: ${typeof output}, converting to single-item array`);\n        }\n        isForEach = true;\n        forEachItems = [output];\n        enrichedResult.isForEach = true;\n        enrichedResult.forEachItems = [output];\n      }\n    }\n\n    // Also preserve forEach metadata if already present (from provider)\n    if ((result as any).isForEach) {\n      enrichedResult.isForEach = true;\n    }\n    if ((result as any).forEachItems) {\n      enrichedResult.forEachItems = (result as any).forEachItems;\n    }\n    if ((result as any).forEachItemResults) {\n      enrichedResult.forEachItemResults = (result as any).forEachItemResults;\n    }\n    if ((result as any).forEachFatalMask) {\n      enrichedResult.forEachFatalMask = (result as any).forEachFatalMask;\n    }\n\n    // Render template content and emit Mermaid diagrams\n    let renderedContent: string | undefined;\n    try {\n      renderedContent = await renderTemplateContent(checkId, checkConfig, enrichedResult);\n      if (renderedContent) {\n        // Emit Mermaid diagram events from the rendered content\n        emitMermaidFromMarkdown(checkId, renderedContent, 'content');\n      }\n    } catch (error) {\n      logger.warn(`[LevelDispatch] Failed to render template for ${checkId}: ${error}`);\n    }\n\n    // Add timestamp to output if it exists\n    const outputWithTimestamp = (result as any).output !== undefined\n      ? { ...(result as any).output, ts: Date.now() }\n      : undefined;\n\n    const enrichedResultWithTimestamp = outputWithTimestamp\n      ? { ...enrichedResult, output: outputWithTimestamp }\n      : enrichedResult;\n\n    // Store in journal\n    try {\n      context.journal.commitEntry({\n        sessionId: context.sessionId,\n        checkId,\n        result: enrichedResultWithTimestamp as any,\n        event: context.event || 'manual',\n        scope,\n      });\n    } catch (error) {\n      logger.warn(`[LevelDispatch] Failed to commit to journal: ${error}`);\n    }\n\n    // If this is a forEach check, also commit per-item results\n    if (isForEach && forEachItems && Array.isArray(forEachItems)) {\n      for (let itemIndex = 0; itemIndex < forEachItems.length; itemIndex++) {\n        const itemScope: Array<{ check: string; index: number }> = [\n          { check: checkId, index: itemIndex }\n        ];\n        const item = forEachItems[itemIndex];\n\n        try {\n          context.journal.commitEntry({\n            sessionId: context.sessionId,\n            checkId,\n            result: { issues: [], output: item } as any,\n            event: context.event || 'manual',\n            scope: itemScope,\n          });\n        } catch (error) {\n          logger.warn(`[LevelDispatch] Failed to commit per-item journal for ${checkId} item ${itemIndex}: ${error}`);\n        }\n      }\n    }\n\n    // Record completion\n    state.completedChecks.add(checkId);\n    state.activeDispatches.delete(checkId);\n\n    // Track wave-specific completion for 'if' condition evaluation\n    const currentWaveCompletions = (state as any).currentWaveCompletions as Set<string> | undefined;\n    if (currentWaveCompletions) {\n      currentWaveCompletions.add(checkId);\n    }\n\n    // Emit completed event with full result\n    emitEvent({\n      type: 'CheckCompleted',\n      checkId,\n      scope,\n      result: {\n        ...enrichedResult,\n        output: (result as any).output,\n        content: renderedContent || (result as any).content,\n      },\n    });\n\n    // Process routing (fail_if, on_success, on_fail)\n    await handleRouting(\n      context,\n      state,\n      transition,\n      emitEvent,\n      {\n        checkId,\n        scope,\n        result: enrichedResult,\n        checkConfig: checkConfig as CheckConfig,\n        success: !hasFatalIssues(enrichedResult),\n      }\n    );\n\n    return enrichedResult;\n  } catch (error) {\n    const err = error instanceof Error ? error : new Error(String(error));\n    logger.error(`[LevelDispatch] Error executing check ${checkId}: ${err.message}`);\n\n    state.activeDispatches.delete(checkId);\n\n    // Emit error event\n    emitEvent({\n      type: 'CheckErrored',\n      checkId,\n      scope,\n      error: {\n        message: err.message,\n        stack: err.stack,\n        name: err.name,\n      },\n    });\n\n    // Return error result\n    const errorResult: ReviewSummary = {\n      issues: [\n        {\n          file: '',\n          line: 0,\n          ruleId: `${checkId}/error`,\n          message: err.message,\n          severity: 'error',\n          category: 'logic',\n        },\n      ],\n    };\n\n    return errorResult;\n  }\n}\n\n/**\n * Build dependency results for a check with scope\n */\nfunction buildDependencyResultsWithScope(\n  checkId: string,\n  checkConfig: any,\n  context: EngineContext,\n  scope: Array<{ check: string; index: number }>\n): Map<string, ReviewSummary> {\n  const dependencyResults = new Map<string, ReviewSummary>();\n\n  // Get dependencies from configuration\n  const dependencies = checkConfig.depends_on || [];\n  const depList = Array.isArray(dependencies) ? dependencies : [dependencies];\n\n  for (const depId of depList) {\n    if (!depId) continue;\n\n    // Try to get result from journal with scope\n    try {\n      const snapshotId = context.journal.beginSnapshot();\n      const contextView = new (require('../../snapshot-store').ContextView)(\n        context.journal,\n        context.sessionId,\n        snapshotId,\n        scope,\n        context.event\n      );\n      const journalResult = contextView.get(depId);\n      if (journalResult) {\n        dependencyResults.set(depId, journalResult as ReviewSummary);\n        continue;\n      }\n    } catch {\n      // Fall through to other sources\n    }\n\n    // Fall back to empty result\n    dependencyResults.set(depId, { issues: [] });\n  }\n\n  return dependencyResults;\n}\n\n/**\n * Build dependency results for a check\n */\nfunction buildDependencyResults(\n  checkId: string,\n  checkConfig: any,\n  context: EngineContext,\n  _state: RunState\n): Map<string, ReviewSummary> {\n  return buildDependencyResultsWithScope(checkId, checkConfig, context, []);\n}\n\n/**\n * Check if fail-fast should be triggered based on results\n */\nfunction shouldFailFast(results: Array<{ checkId: string; result: ReviewSummary; error?: Error }>): boolean {\n  // Fail-fast if any check has critical or error severity issues\n  for (const { result } of results) {\n    if (!result || !result.issues) continue;\n\n    if (hasFatalIssues(result)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Check if result has fatal issues\n */\nfunction hasFatalIssues(result: ReviewSummary): boolean {\n  if (!result.issues) {\n    return false;\n  }\n\n  return result.issues.some(\n    issue => issue.severity === 'critical' || issue.severity === 'error'\n  );\n}\n\n/**\n * Update execution stats\n */\nfunction updateStats(\n  results: Array<{ checkId: string; result: ReviewSummary; error?: Error }>,\n  state: RunState\n): void {\n  for (const { checkId, result, error } of results) {\n    const existing = state.stats.get(checkId);\n\n    const stats: CheckExecutionStats = existing || {\n      checkName: checkId,\n      totalRuns: 0,\n      successfulRuns: 0,\n      failedRuns: 0,\n      skipped: false,\n      totalDuration: 0,\n      issuesFound: 0,\n      issuesBySeverity: {\n        critical: 0,\n        error: 0,\n        warning: 0,\n        info: 0,\n      },\n    };\n\n    stats.totalRuns++;\n\n    if (error) {\n      stats.failedRuns++;\n      stats.errorMessage = error.message;\n    } else {\n      stats.successfulRuns++;\n\n      // Count issues\n      if (result.issues) {\n        stats.issuesFound += result.issues.length;\n\n        for (const issue of result.issues) {\n          if (issue.severity === 'critical') stats.issuesBySeverity.critical++;\n          else if (issue.severity === 'error') stats.issuesBySeverity.error++;\n          else if (issue.severity === 'warning') stats.issuesBySeverity.warning++;\n          else if (issue.severity === 'info') stats.issuesBySeverity.info++;\n        }\n      }\n    }\n\n    state.stats.set(checkId, stats);\n  }\n}\n\n/**\n * Render template content for a check\n * Similar to legacy engine's renderCheckContent method\n */\nasync function renderTemplateContent(\n  checkId: string,\n  checkConfig: any,\n  reviewSummary: ReviewSummary\n): Promise<string | undefined> {\n  // Check if check has a template configured\n  if (!checkConfig.template?.content) {\n    return undefined;\n  }\n\n  try {\n    const liquid = new Liquid();\n\n    // Build template data similar to legacy engine\n    const templateData: Record<string, unknown> = {\n      issues: reviewSummary.issues || [],\n      checkName: checkId,\n      output: (reviewSummary as any).output,\n    };\n\n    // Render template\n    const rendered = await liquid.parseAndRender(checkConfig.template.content, templateData);\n    return rendered.trim();\n  } catch (error) {\n    const msg = error instanceof Error ? error.message : String(error);\n    logger.error(`[LevelDispatch] Failed to render template for ${checkId}: ${msg}`);\n    throw error;\n  }\n}\n","/**\n * CheckRunning State Handler\n *\n * Responsibilities:\n * - Execute provider logic for a check\n * - Assemble CheckResult\n * - Transition to Routing state\n *\n * M1: This state is handled inline by LevelDispatch\n * M2: Will be a proper state when we add routing\n */\n\nimport type { EngineContext, RunState, EngineState, EngineEvent } from '../../types/engine';\n\nexport async function handleCheckRunning(\n  _context: EngineContext,\n  _state: RunState,\n  transition: (newState: EngineState) => void,\n  _emitEvent: (event: EngineEvent) => void\n): Promise<void> {\n  // M2: This state is not used yet - LevelDispatch handles execution inline with routing\n  // The routing happens directly in LevelDispatch after check execution\n  transition('WavePlanning');\n}\n","/**\n * Completed State Handler\n *\n * Responsibilities:\n * - Finalize stats\n * - Flush telemetry\n * - Update GitHub CheckRuns\n * - Terminal state\n */\n\nimport type { EngineContext, RunState } from '../../types/engine';\nimport { logger } from '../../logger';\n\nexport async function handleCompleted(\n  context: EngineContext,\n  state: RunState\n): Promise<void> {\n  if (context.debug) {\n    logger.info('[Completed] Execution complete');\n    logger.info(`[Completed] Total waves: ${state.wave + 1}`);\n    logger.info(`[Completed] Checks completed: ${state.completedChecks.size}`);\n    logger.info(`[Completed] Stats collected: ${state.stats.size}`);\n  }\n\n  // Finalize GitHub checks if configured\n  if (context.gitHubChecks) {\n    // GitHub check finalization happens in the main engine\n    if (context.debug) {\n      logger.info('[Completed] GitHub checks will be finalized by main engine');\n    }\n  }\n\n  // Flush telemetry\n  // M4: Will add structured event streaming to debug visualizer\n\n  // Terminal state - no transition\n}\n","/**\n * Error State Handler\n *\n * Responsibilities:\n * - Capture fatal errors\n * - Unwind gracefully\n * - Terminal state\n */\n\nimport type { EngineContext, RunState } from '../../types/engine';\nimport { logger } from '../../logger';\n\nexport async function handleError(\n  context: EngineContext,\n  state: RunState\n): Promise<void> {\n  logger.error('[Error] State machine entered error state');\n\n  // Check if there's an error in the event queue\n  const errorEvent = state.eventQueue.find(e => e.type === 'Shutdown' && e.error);\n  if (errorEvent && errorEvent.type === 'Shutdown' && errorEvent.error) {\n    logger.error(`[Error] Fatal error: ${errorEvent.error.message}`);\n    if (errorEvent.error.stack) {\n      logger.error(`[Error] Stack: ${errorEvent.error.stack}`);\n    }\n  }\n\n  // Log stats for debugging\n  if (context.debug) {\n    logger.info(`[Error] Completed ${state.completedChecks.size} checks before error`);\n    logger.info(`[Error] Active dispatches: ${state.activeDispatches.size}`);\n  }\n\n  // Terminal state - no transition\n}\n","/**\n * State Machine Runner - Core orchestration\n *\n * Implements the main event loop that drives state transitions.\n * Supports OTEL telemetry and debug visualizer event streaming (M4).\n */\n\nimport type {\n  EngineContext,\n  RunState,\n  EngineEvent,\n  EngineState,\n  SerializedError,\n} from '../types/engine';\nimport { logger } from '../logger';\nimport { ExecutionResult } from '../check-execution-engine';\nimport { GroupedCheckResults } from '../reviewer';\nimport { withActiveSpan, addEvent as addOtelEvent } from '../telemetry/trace-helpers';\nimport type { DebugVisualizerServer } from '../debug-visualizer/ws-server';\n\n// Import state handlers\nimport { handleInit } from './states/init';\nimport { handlePlanReady } from './states/plan-ready';\nimport { handleWavePlanning } from './states/wave-planning';\nimport { handleLevelDispatch } from './states/level-dispatch';\nimport { handleCheckRunning } from './states/check-running';\nimport { handleCompleted } from './states/completed';\nimport { handleError } from './states/error';\n\n/**\n * Main state machine runner\n */\nexport class StateMachineRunner {\n  private context: EngineContext;\n  private state: RunState;\n  private debugServer?: DebugVisualizerServer;\n\n  constructor(context: EngineContext, debugServer?: DebugVisualizerServer) {\n    this.context = context;\n    this.state = this.initializeState();\n    this.debugServer = debugServer;\n  }\n\n  /**\n   * Initialize the run state\n   */\n  private initializeState(): RunState {\n    return {\n      currentState: 'Init',\n      wave: 0,\n      levelQueue: [],\n      eventQueue: [],\n      activeDispatches: new Map(),\n      completedChecks: new Set(),\n      flags: {\n        failFastTriggered: false,\n        forwardRunRequested: false,\n        maxWorkflowDepth: 3, // Default maximum nesting depth\n        currentWorkflowDepth: 0, // Start at root level\n      },\n      stats: new Map(),\n      historyLog: [],\n      forwardRunGuards: new Set(),\n      currentLevelChecks: new Set(),\n      routingLoopCount: 0,\n    };\n  }\n\n  /**\n   * Execute the state machine\n   */\n  async run(): Promise<ExecutionResult> {\n    try {\n      // Emit initial state transition event\n      this.emitEvent({ type: 'StateTransition', from: 'Init', to: 'Init' });\n\n      // Main event loop\n      while (!this.isTerminalState(this.state.currentState)) {\n        const currentState = this.state.currentState;\n\n        if (this.context.debug) {\n          logger.info(`[StateMachine] State: ${currentState}, Wave: ${this.state.wave}`);\n        }\n\n        // Execute current state handler\n        await this.executeState(currentState);\n\n        // Check for errors\n        if (this.state.currentState === 'Error') {\n          break;\n        }\n      }\n\n      // Return final results\n      return this.buildExecutionResult();\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      logger.error(`[StateMachine] Fatal error: ${errorMsg}`);\n      const serializedError: SerializedError = {\n        message: error instanceof Error ? error.message : String(error),\n        stack: error instanceof Error ? error.stack : undefined,\n        name: error instanceof Error ? error.name : undefined,\n      };\n      this.emitEvent({ type: 'Shutdown', error: serializedError });\n      throw error;\n    }\n  }\n\n  /**\n   * Execute a specific state handler\n   * M4: Wraps each state execution in an OTEL span for observability\n   */\n  private async executeState(state: EngineState): Promise<void> {\n    // M4: Wrap state execution in OTEL span\n    return withActiveSpan(\n      `engine.state.${state.toLowerCase()}`,\n      {\n        state: state,\n        engine_mode: this.context.mode,\n        wave: this.state.wave,\n        session_id: this.context.sessionId,\n      },\n      async () => {\n        try {\n          switch (state) {\n            case 'Init':\n              await handleInit(this.context, this.state, this.transition.bind(this));\n              break;\n            case 'PlanReady':\n              await handlePlanReady(this.context, this.state, this.transition.bind(this));\n              break;\n            case 'WavePlanning':\n              await handleWavePlanning(this.context, this.state, this.transition.bind(this));\n              break;\n            case 'LevelDispatch':\n              await handleLevelDispatch(this.context, this.state, this.transition.bind(this), this.emitEvent.bind(this));\n              break;\n            case 'CheckRunning':\n              await handleCheckRunning(this.context, this.state, this.transition.bind(this), this.emitEvent.bind(this));\n              break;\n            case 'Routing':\n              // Routing is handled inline by CheckRunning for now\n              throw new Error('Routing state should be handled by CheckRunning');\n            case 'Completed':\n              await handleCompleted(this.context, this.state);\n              break;\n            case 'Error':\n              await handleError(this.context, this.state);\n              break;\n            default:\n              throw new Error(`Unknown state: ${state}`);\n          }\n        } catch (error) {\n          const errorMsg = error instanceof Error ? error.message : String(error);\n          logger.error(`[StateMachine] Error in state ${state}: ${errorMsg}`);\n          const serializedError: SerializedError = {\n            message: error instanceof Error ? error.message : String(error),\n            stack: error instanceof Error ? error.stack : undefined,\n            name: error instanceof Error ? error.name : undefined,\n          };\n          this.emitEvent({ type: 'Shutdown', error: serializedError });\n          this.state.currentState = 'Error';\n          throw error; // Re-throw to trigger span error recording\n        }\n      }\n    );\n  }\n\n  /**\n   * Transition to a new state\n   * M4: Emits OTEL span for the transition with state metadata\n   */\n  private transition(newState: EngineState): void {\n    const oldState = this.state.currentState;\n    this.state.currentState = newState;\n\n    // Emit state transition event\n    const transitionEvent = { type: 'StateTransition' as const, from: oldState, to: newState };\n    this.emitEvent(transitionEvent);\n\n    // M4: Emit OTEL event for state transition\n    try {\n      addOtelEvent('engine.state_transition', {\n        state_from: oldState,\n        state_to: newState,\n        engine_mode: this.context.mode,\n        wave: this.state.wave,\n        session_id: this.context.sessionId,\n      });\n    } catch (_err) {\n      // Ignore telemetry errors\n    }\n\n    if (this.context.debug) {\n      logger.info(`[StateMachine] Transition: ${oldState} -> ${newState}`);\n    }\n  }\n\n  /**\n   * Emit an engine event\n   * M4: Streams events to debug visualizer for time-travel debugging\n   */\n  private emitEvent(event: EngineEvent): void {\n    this.state.historyLog.push(event);\n\n    // Queue events that require processing by WavePlanning\n    if (event.type === 'ForwardRunRequested' || event.type === 'WaveRetry') {\n      this.state.eventQueue.push(event);\n    }\n\n    // M4: Stream event to debug visualizer for live monitoring\n    if (this.debugServer) {\n      try {\n        this.streamEventToDebugServer(event);\n      } catch (_err) {\n        // Ignore debug server errors\n      }\n    }\n\n    if (this.context.debug && event.type !== 'StateTransition') {\n      logger.debug(`[StateMachine] Event: ${event.type}`);\n    }\n  }\n\n  /**\n   * Stream an engine event to debug visualizer (M4)\n   * Converts EngineEvent to ProcessedSpan format for visualization\n   */\n  private streamEventToDebugServer(event: EngineEvent): void {\n    if (!this.debugServer) return;\n\n    // Convert EngineEvent to a ProcessedSpan-like structure\n    const timestamp = process.hrtime();\n    const span = {\n      traceId: this.context.sessionId,\n      spanId: `${event.type}-${Date.now()}`,\n      name: `engine.event.${event.type.toLowerCase()}`,\n      startTime: timestamp,\n      endTime: timestamp,\n      duration: 0,\n      attributes: {\n        event_type: event.type,\n        engine_mode: this.context.mode,\n        wave: this.state.wave,\n        session_id: this.context.sessionId,\n        ...this.extractEventAttributes(event),\n      },\n      events: [],\n      status: 'ok' as const,\n    };\n\n    this.debugServer.emitSpan(span);\n  }\n\n  /**\n   * Extract type-specific attributes from engine events\n   */\n  private extractEventAttributes(event: EngineEvent): Record<string, any> {\n    switch (event.type) {\n      case 'StateTransition':\n        return { state_from: event.from, state_to: event.to };\n      case 'CheckScheduled':\n      case 'CheckCompleted':\n      case 'CheckErrored':\n        return {\n          check_id: event.checkId,\n          scope: event.scope?.join('.') || '',\n        };\n      case 'ForwardRunRequested':\n        return {\n          target: event.target,\n          goto_event: event.gotoEvent,\n          scope: event.scope?.join('.') || '',\n        };\n      case 'WaveRetry':\n        return { reason: event.reason };\n      case 'Shutdown':\n        return {\n          error: event.error?.message,\n        };\n      default:\n        return {};\n    }\n  }\n\n  /**\n   * Check if a state is terminal\n   */\n  private isTerminalState(state: EngineState): boolean {\n    return state === 'Completed' || state === 'Error';\n  }\n\n  /**\n   * Build the final execution result\n   */\n  private buildExecutionResult(): ExecutionResult {\n    const stats = Array.from(this.state.stats.values());\n\n    // Build results from completed checks by reading from journal\n    const results: GroupedCheckResults = this.aggregateResultsFromJournal();\n\n    // Aggregate total duration\n    let totalDuration = 0;\n    for (const stat of stats) {\n      totalDuration = Math.max(totalDuration, stat.totalDuration);\n    }\n\n    return {\n      results,\n      statistics: {\n        totalChecksConfigured: this.state.stats.size,\n        totalExecutions: stats.reduce((sum, s) => sum + s.totalRuns, 0),\n        successfulExecutions: stats.reduce((sum, s) => sum + s.successfulRuns, 0),\n        failedExecutions: stats.reduce((sum, s) => sum + s.failedRuns, 0),\n        skippedChecks: stats.filter(s => s.skipped).length,\n        totalDuration,\n        checks: stats,\n      },\n    };\n  }\n\n  /**\n   * Aggregate results from journal into GroupedCheckResults format\n   * This matches the format returned by the legacy engine\n   */\n  private aggregateResultsFromJournal(): GroupedCheckResults {\n    const groupedResults: GroupedCheckResults = {};\n\n    // Read all journal entries for this session\n    const allEntries = this.context.journal.readVisible(\n      this.context.sessionId,\n      this.context.journal.beginSnapshot(),\n      undefined\n    );\n\n    // Group entries by check ID to handle forEach iterations\n    const checkEntries = new Map<string, typeof allEntries>();\n    for (const entry of allEntries) {\n      const existing = checkEntries.get(entry.checkId) || [];\n      existing.push(entry);\n      checkEntries.set(entry.checkId, existing);\n    }\n\n    // Process each check\n    for (const [checkId, entries] of checkEntries) {\n      const checkConfig = this.context.config.checks?.[checkId];\n      if (!checkConfig) continue;\n\n      // Determine group: use explicit group or fall back to check name\n      const group = checkConfig.group || checkId;\n\n      // For forEach checks, we aggregate all iterations\n      // For non-forEach, we take the latest entry\n      let content = '';\n      let output: unknown = undefined;\n      const allIssues: any[] = [];\n      let debug: any = undefined;\n\n      if (checkConfig.forEach && entries.length > 1) {\n        // Aggregate all forEach iterations\n        const contents: string[] = [];\n        for (const entry of entries) {\n          if (entry.result.content) {\n            contents.push(entry.result.content);\n          }\n          if (entry.result.issues) {\n            allIssues.push(...entry.result.issues);\n          }\n          if (entry.result.debug) {\n            debug = entry.result.debug;\n          }\n          // For forEach, output is typically an array from the last iteration\n          if (entry.result.output !== undefined) {\n            output = entry.result.output;\n          }\n        }\n        content = contents.join('\\n');\n      } else {\n        // For non-forEach or single-entry forEach, take the latest entry\n        const latestEntry = entries[entries.length - 1];\n        if (latestEntry) {\n          content = latestEntry.result.content || '';\n          output = latestEntry.result.output;\n          if (latestEntry.result.issues) {\n            allIssues.push(...latestEntry.result.issues);\n          }\n          debug = latestEntry.result.debug;\n        }\n      }\n\n      // Create CheckResult\n      const checkResult: import('../reviewer').CheckResult = {\n        checkName: checkId,\n        content,\n        group,\n        output,\n        debug,\n        issues: allIssues,\n      };\n\n      // Add to appropriate group\n      if (!groupedResults[group]) {\n        groupedResults[group] = [];\n      }\n      groupedResults[group].push(checkResult);\n    }\n\n    return groupedResults;\n  }\n\n  /**\n   * Get current run state (for debugging/testing)\n   */\n  getState(): RunState {\n    return this.state;\n  }\n\n  /**\n   * Bubble an event to parent context (nested workflows support)\n   * This allows nested workflows to trigger re-runs in parent workflows\n   */\n  bubbleEventToParent(event: EngineEvent): void {\n    if (this.state.parentContext && this.state.parentContext.mode === 'state-machine') {\n      // Emit event to parent's event queue\n      if (this.context.debug) {\n        logger.info(`[StateMachine] Bubbling event to parent: ${event.type}`);\n      }\n\n      // We need to access the parent runner to bubble events\n      // For now, we'll store events in a queue that can be retrieved\n      // The parent will poll for bubbled events after child execution\n      if (!this.state.parentContext._bubbledEvents) {\n        (this.state.parentContext as any)._bubbledEvents = [];\n      }\n      (this.state.parentContext as any)._bubbledEvents.push(event);\n    }\n  }\n}\n","/**\n * Workflow check provider - executes reusable workflows as checks\n */\n\nimport { CheckProvider, CheckProviderConfig, ExecutionContext } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { WorkflowRegistry } from '../workflow-registry';\nimport { WorkflowExecutor } from '../workflow-executor';\nimport { logger } from '../logger';\nimport { WorkflowDefinition, WorkflowExecutionContext } from '../types/workflow';\nimport { createSecureSandbox, compileAndRun } from '../utils/sandbox';\nimport { Liquid } from 'liquidjs';\n\n/**\n * Provider that executes workflows as checks\n */\nexport class WorkflowCheckProvider extends CheckProvider {\n  private registry: WorkflowRegistry;\n  private executor: WorkflowExecutor;\n  private liquid: Liquid;\n\n  constructor() {\n    super();\n    this.registry = WorkflowRegistry.getInstance();\n    this.executor = new WorkflowExecutor();\n    this.liquid = new Liquid();\n  }\n\n  getName(): string {\n    return 'workflow';\n  }\n\n  getDescription(): string {\n    return 'Executes reusable workflow definitions as checks';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    const cfg = config as CheckProviderConfig;\n\n    if (!cfg.workflow) {\n      logger.error('Workflow provider requires \"workflow\" field');\n      return false;\n    }\n\n    // Check if workflow exists in registry\n    if (!this.registry.has(cfg.workflow as string)) {\n      logger.error(`Workflow '${cfg.workflow}' not found in registry`);\n      return false;\n    }\n\n    return true;\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    context?: ExecutionContext\n  ): Promise<ReviewSummary> {\n    const workflowId = config.workflow as string;\n\n    // Get the workflow definition\n    const workflow = this.registry.get(workflowId);\n    if (!workflow) {\n      throw new Error(`Workflow '${workflowId}' not found in registry`);\n    }\n\n    logger.info(`Executing workflow '${workflowId}'`);\n\n    // Prepare inputs\n    const inputs = await this.prepareInputs(workflow, config, prInfo, dependencyResults);\n\n    // Validate inputs\n    const validation = this.registry.validateInputs(workflow, inputs);\n    if (!validation.valid) {\n      const errors = validation.errors?.map(e => `${e.path}: ${e.message}`).join(', ');\n      throw new Error(`Invalid workflow inputs: ${errors}`);\n    }\n\n    // Apply overrides to workflow steps if specified\n    const modifiedWorkflow = this.applyOverrides(workflow, config);\n\n    // M3: Check if we're in state-machine mode and should delegate to engine\n    const engineMode = (context as any)?._engineMode;\n    if (engineMode === 'state-machine') {\n      // Delegate to state machine engine for nested workflow execution\n      logger.info(`[WorkflowProvider] Delegating workflow '${workflowId}' to state machine engine`);\n      return await this.executeViaStateMachine(\n        modifiedWorkflow,\n        inputs,\n        config,\n        prInfo,\n        dependencyResults,\n        context\n      );\n    }\n\n    // Legacy mode: Execute the workflow using WorkflowExecutor\n    const executionContext: WorkflowExecutionContext = {\n      instanceId: `${workflowId}-${Date.now()}`,\n      parentCheckId: config.checkName,\n      inputs,\n      stepResults: new Map(),\n    };\n\n    const result = await this.executor.execute(modifiedWorkflow, executionContext, {\n      prInfo,\n      dependencyResults,\n      context,\n    });\n\n    // Map outputs\n    const outputs = this.mapOutputs(result, config.output_mapping as Record<string, string>);\n\n    // Return the review summary with extended fields\n    // Note: These extra fields are used by the execution engine but not part of the base interface\n    const summary: ReviewSummary = {\n      issues: result.issues || [],\n    };\n\n    // Add extended fields as needed by the engine\n    (summary as any).score = result.score || 0;\n    (summary as any).confidence = result.confidence || 'medium';\n    (summary as any).comments = result.comments || [];\n    (summary as any).output = outputs;\n    (summary as any).content = this.formatWorkflowResult(workflow, result, outputs);\n\n    return summary;\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return ['workflow', 'args', 'overrides', 'output_mapping', 'timeout', 'env', 'checkName'];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    return true; // Always available\n  }\n\n  getRequirements(): string[] {\n    return [];\n  }\n\n  /**\n   * Prepare inputs for workflow execution\n   */\n  private async prepareInputs(\n    workflow: WorkflowDefinition,\n    config: CheckProviderConfig,\n    prInfo: PRInfo,\n    dependencyResults?: Map<string, ReviewSummary>\n  ): Promise<Record<string, unknown>> {\n    const inputs: Record<string, unknown> = {};\n\n    // Start with default values from workflow definition\n    if (workflow.inputs) {\n      for (const param of workflow.inputs) {\n        if (param.default !== undefined) {\n          inputs[param.name] = param.default;\n        }\n      }\n    }\n\n    // Apply user-provided inputs (args)\n    const userInputs = config.args || config.workflow_inputs; // Support both for compatibility\n    if (userInputs) {\n      for (const [key, value] of Object.entries(userInputs)) {\n        // Process value if it's a template or expression\n        if (typeof value === 'string') {\n          // Check if it's a Liquid template\n          if (value.includes('{{') || value.includes('{%')) {\n            inputs[key] = await this.liquid.parseAndRender(value, {\n              pr: prInfo,\n              outputs: dependencyResults ? Object.fromEntries(dependencyResults) : {},\n              env: process.env,\n            });\n          } else {\n            inputs[key] = value;\n          }\n        } else if (typeof value === 'object' && value !== null && 'expression' in value) {\n          // JavaScript expression\n          const exprValue = value as { expression: string };\n          const sandbox = createSecureSandbox();\n          inputs[key] = compileAndRun(\n            sandbox,\n            exprValue.expression,\n            {\n              pr: prInfo,\n              outputs: dependencyResults ? Object.fromEntries(dependencyResults) : {},\n              env: process.env,\n            },\n            { injectLog: true, logPrefix: `workflow.input.${key}` }\n          );\n        } else {\n          inputs[key] = value;\n        }\n      }\n    }\n\n    return inputs;\n  }\n\n  /**\n   * Apply overrides to workflow steps\n   */\n  private applyOverrides(\n    workflow: WorkflowDefinition,\n    config: CheckProviderConfig\n  ): WorkflowDefinition {\n    const overrideConfig = config.overrides || config.workflow_overrides; // Support both for compatibility\n    if (!overrideConfig) {\n      return workflow;\n    }\n\n    // Deep clone the workflow\n    const modified = JSON.parse(JSON.stringify(workflow));\n\n    // Apply overrides\n    for (const [stepId, overrides] of Object.entries(overrideConfig)) {\n      if (modified.steps[stepId]) {\n        // Merge overrides with existing step config\n        modified.steps[stepId] = {\n          ...modified.steps[stepId],\n          ...overrides,\n        };\n      } else {\n        logger.warn(`Cannot override non-existent step '${stepId}' in workflow '${workflow.id}'`);\n      }\n    }\n\n    return modified;\n  }\n\n  /**\n   * Map workflow outputs to check outputs\n   */\n  private mapOutputs(result: any, outputMapping?: Record<string, string>): Record<string, unknown> {\n    if (!outputMapping) {\n      return result.output || {};\n    }\n\n    const mapped: Record<string, unknown> = {};\n    const workflowOutputs = result.output || {};\n\n    for (const [checkOutput, workflowOutput] of Object.entries(outputMapping)) {\n      if (workflowOutput in workflowOutputs) {\n        mapped[checkOutput] = workflowOutputs[workflowOutput];\n      } else if (workflowOutput.includes('.')) {\n        // Handle nested paths\n        const parts = workflowOutput.split('.');\n        let value = workflowOutputs;\n        for (const part of parts) {\n          value = value?.[part];\n          if (value === undefined) break;\n        }\n        mapped[checkOutput] = value;\n      }\n    }\n\n    return mapped;\n  }\n\n  /**\n   * Format workflow execution result for display\n   */\n  /**\n   * Execute workflow via state machine engine (M3: nested workflows)\n   */\n  private async executeViaStateMachine(\n    workflow: WorkflowDefinition,\n    inputs: Record<string, unknown>,\n    config: CheckProviderConfig,\n    prInfo: PRInfo,\n    dependencyResults?: Map<string, ReviewSummary>,\n    context?: ExecutionContext\n  ): Promise<ReviewSummary> {\n    // Import state machine components\n    const { projectWorkflowToGraph, validateWorkflowDepth } = require('../state-machine/workflow-projection');\n    const { StateMachineRunner } = require('../state-machine/runner');\n    const { ExecutionJournal } = require('../snapshot-store');\n    const { MemoryStore } = require('../memory-store');\n    const { v4: uuidv4 } = require('uuid');\n\n    // Extract parent context if available\n    const parentContext = (context as any)?._parentContext;\n    const parentState = (context as any)?._parentState;\n\n    // Validate workflow depth\n    const currentDepth = parentState?.flags?.currentWorkflowDepth || 0;\n    const maxDepth = parentState?.flags?.maxWorkflowDepth || 3;\n    validateWorkflowDepth(currentDepth, maxDepth, workflow.id);\n\n    // Project workflow to dependency graph\n    const { config: workflowConfig, checks: checksMetadata } = projectWorkflowToGraph(\n      workflow,\n      inputs,\n      config.checkName || workflow.id\n    );\n\n    // Build child engine context\n    const childContext = {\n      mode: 'state-machine' as const,\n      config: workflowConfig,\n      checks: checksMetadata,\n      journal: parentContext?.journal || new ExecutionJournal(),\n      memory: parentContext?.memory || MemoryStore.getInstance(),\n      workingDirectory: parentContext?.workingDirectory || process.cwd(),\n      sessionId: parentContext?.sessionId || uuidv4(),\n      event: parentContext?.event || prInfo.eventType,\n      debug: parentContext?.debug || false,\n      maxParallelism: parentContext?.maxParallelism,\n      failFast: parentContext?.failFast,\n    };\n\n    // Create child runner with inherited context\n    const runner = new StateMachineRunner(childContext);\n    const childState = runner.getState();\n\n    // Set workflow depth for child\n    childState.flags.currentWorkflowDepth = currentDepth + 1;\n    childState.flags.maxWorkflowDepth = maxDepth;\n\n    // Set parent references\n    childState.parentContext = parentContext;\n    childState.parentScope = parentState?.parentScope;\n\n    // Execute the child workflow\n    logger.info(`[WorkflowProvider] Executing nested workflow '${workflow.id}' at depth ${currentDepth + 1}`);\n    const result = await runner.run();\n\n    // M3: Check for bubbled events and propagate them to parent\n    const bubbledEvents = (childContext as any)._bubbledEvents || [];\n    if (bubbledEvents.length > 0 && parentContext) {\n      if (parentContext.debug) {\n        logger.info(`[WorkflowProvider] Bubbling ${bubbledEvents.length} events to parent context`);\n      }\n\n      // Propagate bubbled events to parent\n      if (!parentContext._bubbledEvents) {\n        (parentContext as any)._bubbledEvents = [];\n      }\n      (parentContext as any)._bubbledEvents.push(...bubbledEvents);\n    }\n\n    // Aggregate results from all workflow steps\n    const allIssues: any[] = [];\n    let totalScore = 0;\n    let scoreCount = 0;\n\n    for (const stepResult of Object.values(result.results)) {\n      const typedResult = stepResult as any;\n      if (typedResult.issues) {\n        allIssues.push(...typedResult.issues);\n      }\n      if (typedResult.score) {\n        totalScore += typedResult.score;\n        scoreCount++;\n      }\n    }\n\n    // Compute workflow outputs\n    const outputs = await this.computeWorkflowOutputsFromState(\n      workflow,\n      inputs,\n      result.results,\n      prInfo\n    );\n\n    // Map outputs if output_mapping is specified\n    const mappedOutputs = this.mapOutputs(\n      { output: outputs },\n      config.output_mapping as Record<string, string>\n    );\n\n    // Build aggregated summary\n    const summary: ReviewSummary = {\n      issues: allIssues,\n    };\n\n    (summary as any).score = scoreCount > 0 ? Math.round(totalScore / scoreCount) : 0;\n    (summary as any).confidence = 'medium';\n    (summary as any).output = mappedOutputs;\n    (summary as any).content = this.formatWorkflowResultFromStateMachine(\n      workflow,\n      result,\n      mappedOutputs\n    );\n\n    return summary;\n  }\n\n  /**\n   * Compute workflow outputs from state machine execution results\n   */\n  private async computeWorkflowOutputsFromState(\n    workflow: WorkflowDefinition,\n    inputs: Record<string, unknown>,\n    stepResults: Record<string, ReviewSummary>,\n    prInfo: PRInfo\n  ): Promise<Record<string, unknown>> {\n    const outputs: Record<string, unknown> = {};\n\n    if (!workflow.outputs) {\n      return outputs;\n    }\n\n    const sandbox = createSecureSandbox();\n\n    for (const output of workflow.outputs) {\n      if (output.value_js) {\n        // JavaScript expression\n        outputs[output.name] = compileAndRun(\n          sandbox,\n          output.value_js,\n          {\n            inputs,\n            steps: Object.fromEntries(\n              Object.entries(stepResults).map(([id, result]) => [\n                id.split(':').pop() || id,\n                (result as any).output,\n              ])\n            ),\n            outputs: stepResults,\n            pr: prInfo,\n          },\n          { injectLog: true, logPrefix: `workflow.output.${output.name}` }\n        );\n      } else if (output.value) {\n        // Liquid template\n        outputs[output.name] = await this.liquid.parseAndRender(output.value, {\n          inputs,\n          steps: Object.fromEntries(\n            Object.entries(stepResults).map(([id, result]) => [\n              id.split(':').pop() || id,\n              (result as any).output,\n            ])\n          ),\n          outputs: stepResults,\n          pr: prInfo,\n        });\n      }\n    }\n\n    return outputs;\n  }\n\n  /**\n   * Format workflow result from state machine execution\n   */\n  private formatWorkflowResultFromStateMachine(\n    workflow: WorkflowDefinition,\n    result: any,\n    outputs: Record<string, unknown>\n  ): string {\n    const lines: string[] = [];\n\n    lines.push(`Workflow: ${workflow.name}`);\n    if (workflow.description) {\n      lines.push(`Description: ${workflow.description}`);\n    }\n\n    lines.push('');\n    lines.push('Execution Summary (State Machine):');\n    lines.push(`- Total Steps: ${Object.keys(result.results || {}).length}`);\n    lines.push(`- Duration: ${result.statistics?.totalDuration || 0}ms`);\n\n    if (Object.keys(outputs).length > 0) {\n      lines.push('');\n      lines.push('Outputs:');\n      for (const [key, value] of Object.entries(outputs)) {\n        const formatted =\n          typeof value === 'object' ? JSON.stringify(value, null, 2) : String(value);\n        lines.push(`- ${key}: ${formatted}`);\n      }\n    }\n\n    return lines.join('\\n');\n  }\n\n  private formatWorkflowResult(\n    workflow: WorkflowDefinition,\n    result: any,\n    outputs: Record<string, unknown>\n  ): string {\n    const lines: string[] = [];\n\n    lines.push(`Workflow: ${workflow.name}`);\n    if (workflow.description) {\n      lines.push(`Description: ${workflow.description}`);\n    }\n\n    lines.push('');\n    lines.push('Execution Summary:');\n    lines.push(`- Status: ${result.status || 'completed'}`);\n    lines.push(`- Score: ${result.score || 0}`);\n    lines.push(`- Issues Found: ${result.issues?.length || 0}`);\n\n    if (result.duration) {\n      lines.push(`- Duration: ${result.duration}ms`);\n    }\n\n    if (Object.keys(outputs).length > 0) {\n      lines.push('');\n      lines.push('Outputs:');\n      for (const [key, value] of Object.entries(outputs)) {\n        const formatted =\n          typeof value === 'object' ? JSON.stringify(value, null, 2) : String(value);\n        lines.push(`- ${key}: ${formatted}`);\n      }\n    }\n\n    if (result.stepSummaries && result.stepSummaries.length > 0) {\n      lines.push('');\n      lines.push('Step Results:');\n      for (const summary of result.stepSummaries) {\n        lines.push(\n          `- ${summary.stepId}: ${summary.status} (${summary.issues?.length || 0} issues)`\n        );\n      }\n    }\n\n    return lines.join('\\n');\n  }\n}\n","import { CheckProvider } from './check-provider.interface';\nimport { AICheckProvider } from './ai-check-provider';\nimport { HttpCheckProvider } from './http-check-provider';\nimport { HttpInputProvider } from './http-input-provider';\nimport { HttpClientProvider } from './http-client-provider';\nimport { NoopCheckProvider } from './noop-check-provider';\nimport { LogCheckProvider } from './log-check-provider';\nimport { GitHubOpsProvider } from './github-ops-provider';\nimport { ClaudeCodeCheckProvider } from './claude-code-check-provider';\nimport { CommandCheckProvider } from './command-check-provider';\nimport { MemoryCheckProvider } from './memory-check-provider';\nimport { McpCheckProvider } from './mcp-check-provider';\nimport { HumanInputCheckProvider } from './human-input-check-provider';\nimport { ScriptCheckProvider } from './script-check-provider';\nimport { WorkflowCheckProvider } from './workflow-check-provider';\nimport { CustomToolDefinition } from '../types/config';\n\n/**\n * Registry for managing check providers\n */\nexport class CheckProviderRegistry {\n  private providers: Map<string, CheckProvider> = new Map();\n  private static instance: CheckProviderRegistry;\n  private customTools?: Record<string, CustomToolDefinition>;\n\n  private constructor() {\n    // Register default providers\n    this.registerDefaultProviders();\n  }\n\n  /**\n   * Get singleton instance\n   */\n  static getInstance(): CheckProviderRegistry {\n    if (!CheckProviderRegistry.instance) {\n      CheckProviderRegistry.instance = new CheckProviderRegistry();\n    }\n    return CheckProviderRegistry.instance;\n  }\n\n  /**\n   * Register default built-in providers\n   */\n  private registerDefaultProviders(): void {\n    // Register all built-in providers\n    this.register(new AICheckProvider());\n    this.register(new CommandCheckProvider());\n    this.register(new ScriptCheckProvider());\n    this.register(new HttpCheckProvider());\n    this.register(new HttpInputProvider());\n    this.register(new HttpClientProvider());\n    this.register(new NoopCheckProvider());\n    this.register(new LogCheckProvider());\n    this.register(new MemoryCheckProvider());\n    this.register(new GitHubOpsProvider());\n    this.register(new HumanInputCheckProvider());\n    this.register(new WorkflowCheckProvider());\n\n    // Try to register ClaudeCodeCheckProvider - it may fail if dependencies are missing\n    try {\n      this.register(new ClaudeCodeCheckProvider());\n    } catch (error) {\n      console.error(\n        `Warning: Failed to register ClaudeCodeCheckProvider: ${\n          error instanceof Error ? error.message : 'Unknown error'\n        }`\n      );\n    }\n\n    // Try to register McpCheckProvider - it may fail if dependencies are missing\n    try {\n      const mcpProvider = new McpCheckProvider();\n      // Set custom tools if available\n      if (this.customTools) {\n        mcpProvider.setCustomTools(this.customTools);\n      }\n      this.register(mcpProvider);\n    } catch (error) {\n      console.error(\n        `Warning: Failed to register McpCheckProvider: ${\n          error instanceof Error ? error.message : 'Unknown error'\n        }`\n      );\n    }\n  }\n\n  /**\n   * Register a check provider\n   */\n  register(provider: CheckProvider): void {\n    const name = provider.getName();\n    if (this.providers.has(name)) {\n      throw new Error(`Provider '${name}' is already registered`);\n    }\n    this.providers.set(name, provider);\n    // Only log provider registration in debug mode to avoid contaminating output\n    if (process.env.VISOR_DEBUG === 'true') {\n      console.error(`Registered check provider: ${name}`);\n    }\n  }\n\n  /**\n   * Unregister a check provider\n   */\n  unregister(name: string): void {\n    if (!this.providers.has(name)) {\n      throw new Error(`Provider '${name}' not found`);\n    }\n    this.providers.delete(name);\n    // Send provider unregistration messages to stderr to avoid contaminating JSON output\n    console.error(`Unregistered check provider: ${name}`);\n  }\n\n  /**\n   * Get a provider by name\n   */\n  getProvider(name: string): CheckProvider | undefined {\n    return this.providers.get(name);\n  }\n\n  /**\n   * Get provider or throw if not found\n   */\n  getProviderOrThrow(name: string): CheckProvider {\n    const provider = this.providers.get(name);\n    if (!provider) {\n      throw new Error(\n        `Check provider '${name}' not found. Available providers: ${this.getAvailableProviders().join(', ')}`\n      );\n    }\n    return provider;\n  }\n\n  /**\n   * Check if a provider exists\n   */\n  hasProvider(name: string): boolean {\n    return this.providers.has(name);\n  }\n\n  /**\n   * Get all registered provider names\n   */\n  getAvailableProviders(): string[] {\n    return Array.from(this.providers.keys());\n  }\n\n  /**\n   * Get all providers\n   */\n  getAllProviders(): CheckProvider[] {\n    return Array.from(this.providers.values());\n  }\n\n  /**\n   * Set custom tools that can be used by the MCP provider\n   */\n  setCustomTools(tools: Record<string, CustomToolDefinition>): void {\n    this.customTools = tools;\n\n    // Update MCP provider if already registered\n    const mcpProvider = this.providers.get('mcp') as McpCheckProvider | undefined;\n    if (mcpProvider) {\n      mcpProvider.setCustomTools(tools);\n    }\n  }\n\n  /**\n   * Get providers that are currently available (have required dependencies)\n   */\n  async getActiveProviders(): Promise<CheckProvider[]> {\n    const providers = this.getAllProviders();\n    const activeProviders: CheckProvider[] = [];\n\n    for (const provider of providers) {\n      if (await provider.isAvailable()) {\n        activeProviders.push(provider);\n      }\n    }\n\n    return activeProviders;\n  }\n\n  /**\n   * List provider information\n   */\n  async listProviders(): Promise<\n    Array<{\n      name: string;\n      description: string;\n      available: boolean;\n      requirements: string[];\n    }>\n  > {\n    const providers = this.getAllProviders();\n    const info = [];\n\n    for (const provider of providers) {\n      info.push({\n        name: provider.getName(),\n        description: provider.getDescription(),\n        available: await provider.isAvailable(),\n        requirements: provider.getRequirements(),\n      });\n    }\n\n    return info;\n  }\n\n  /**\n   * Reset registry (mainly for testing)\n   */\n  reset(): void {\n    this.providers.clear();\n    this.registerDefaultProviders();\n  }\n\n  /**\n   * Clear singleton instance (for testing)\n   */\n  static clearInstance(): void {\n    CheckProviderRegistry.instance = undefined!;\n  }\n}\n","import { Octokit } from '@octokit/rest';\nimport { v4 as uuidv4 } from 'uuid';\nimport { logger } from './logger';\nimport { generateFooter } from './footer';\n\nexport interface Comment {\n  id: number;\n  body: string;\n  user: {\n    login: string;\n  };\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface RetryConfig {\n  maxRetries: number;\n  baseDelay: number;\n  maxDelay: number;\n  backoffFactor: number;\n}\n\nexport interface CommentMetadata {\n  commentId: string;\n  lastUpdated: string;\n  triggeredBy: string;\n  commitSha?: string;\n}\n\ninterface GitHubApiError {\n  status?: number;\n  response?: {\n    status?: number;\n    data?: {\n      message?: string;\n    };\n  };\n}\n\n/**\n * Manages GitHub PR comments with dynamic updating capabilities\n */\nexport class CommentManager {\n  private octokit: Octokit;\n  private retryConfig: RetryConfig;\n\n  constructor(octokit: Octokit, retryConfig?: Partial<RetryConfig>) {\n    this.octokit = octokit;\n    this.retryConfig = {\n      maxRetries: 3,\n      baseDelay: 1000,\n      maxDelay: 10000,\n      backoffFactor: 2,\n      ...retryConfig,\n    };\n  }\n\n  /**\n   * Find existing Visor comment by comment ID marker\n   */\n  public async findVisorComment(\n    owner: string,\n    repo: string,\n    prNumber: number,\n    commentId?: string\n  ): Promise<Comment | null> {\n    try {\n      const comments = await this.octokit.rest.issues.listComments({\n        owner,\n        repo,\n        issue_number: prNumber,\n        per_page: 100, // GitHub default max\n      });\n\n      for (const comment of comments.data) {\n        if (comment.body && this.isVisorComment(comment.body, commentId)) {\n          return comment as Comment;\n        }\n      }\n\n      return null;\n    } catch (error) {\n      if (\n        this.isRateLimitError(\n          error as { status?: number; response?: { data?: { message?: string } } }\n        )\n      ) {\n        await this.handleRateLimit(error as { response?: { headers?: Record<string, string> } });\n        return this.findVisorComment(owner, repo, prNumber, commentId);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Update existing comment or create new one with collision detection\n   */\n  public async updateOrCreateComment(\n    owner: string,\n    repo: string,\n    prNumber: number,\n    content: string,\n    options: {\n      commentId?: string;\n      triggeredBy?: string;\n      allowConcurrentUpdates?: boolean;\n      commitSha?: string;\n    } = {}\n  ): Promise<Comment> {\n    const {\n      commentId = this.generateCommentId(),\n      triggeredBy = 'unknown',\n      allowConcurrentUpdates = false,\n      commitSha,\n    } = options;\n\n    return this.withRetry(async () => {\n      const existingComment = await this.findVisorComment(owner, repo, prNumber, commentId);\n\n      const formattedContent = this.formatCommentWithMetadata(content, {\n        commentId,\n        lastUpdated: new Date().toISOString(),\n        triggeredBy,\n        commitSha,\n      });\n\n      if (existingComment) {\n        // Check for collision if not allowing concurrent updates\n        if (!allowConcurrentUpdates) {\n          const currentComment = await this.octokit.rest.issues.getComment({\n            owner,\n            repo,\n            comment_id: existingComment.id,\n          });\n\n          if (currentComment.data.updated_at !== existingComment.updated_at) {\n            throw new Error(\n              `Comment collision detected for comment ${commentId}. Another process may have updated it.`\n            );\n          }\n        }\n\n        const updatedComment = await this.octokit.rest.issues.updateComment({\n          owner,\n          repo,\n          comment_id: existingComment.id,\n          body: formattedContent,\n        });\n\n        logger.info(\n          `‚úÖ Successfully updated comment (ID: ${commentId}, GitHub ID: ${existingComment.id}) on PR #${prNumber} in ${owner}/${repo}`\n        );\n\n        return updatedComment.data as Comment;\n      } else {\n        const newComment = await this.octokit.rest.issues.createComment({\n          owner,\n          repo,\n          issue_number: prNumber,\n          body: formattedContent,\n        });\n\n        logger.info(\n          `‚úÖ Successfully created comment (ID: ${commentId}, GitHub ID: ${newComment.data.id}) on PR #${prNumber} in ${owner}/${repo}`\n        );\n\n        return newComment.data as Comment;\n      }\n    });\n  }\n\n  /**\n   * Format comment content with metadata markers\n   */\n  public formatCommentWithMetadata(content: string, metadata: CommentMetadata): string {\n    const { commentId, lastUpdated, triggeredBy, commitSha } = metadata;\n\n    const footer = generateFooter({\n      includeMetadata: {\n        lastUpdated,\n        triggeredBy,\n        commitSha,\n      },\n    });\n\n    return `<!-- visor-comment-id:${commentId} -->\n${content}\n\n${footer}\n<!-- /visor-comment-id:${commentId} -->`;\n  }\n\n  /**\n   * Create collapsible sections for comment content\n   */\n  public createCollapsibleSection(\n    title: string,\n    content: string,\n    isExpanded: boolean = false\n  ): string {\n    const openAttribute = isExpanded ? ' open' : '';\n    return `<details${openAttribute}>\n<summary>${title}</summary>\n\n${content}\n\n</details>`;\n  }\n\n  /**\n   * Group review results by check type with collapsible sections\n   */\n  public formatGroupedResults(\n    results: Array<{ checkType: string; content: string; score?: number; issuesFound?: number }>,\n    groupBy: 'check' | 'severity' = 'check'\n  ): string {\n    const grouped = this.groupResults(results, groupBy);\n    const sections: string[] = [];\n\n    for (const [groupKey, items] of Object.entries(grouped)) {\n      const totalScore = items.reduce((sum, item) => sum + (item.score || 0), 0) / items.length;\n      const totalIssues = items.reduce((sum, item) => sum + (item.issuesFound || 0), 0);\n\n      const title = this.formatGroupTitle(groupKey, totalScore, totalIssues);\n\n      const sectionContent = items.map(item => item.content).join('\\n\\n');\n      sections.push(this.createCollapsibleSection(title, sectionContent, totalIssues > 0));\n    }\n\n    return sections.join('\\n\\n');\n  }\n\n  /**\n   * Generate unique comment ID\n   */\n  private generateCommentId(): string {\n    return uuidv4().substring(0, 8);\n  }\n\n  /**\n   * Check if comment is a Visor comment\n   */\n  private isVisorComment(body: string, commentId?: string): boolean {\n    if (commentId) {\n      // Check for the new format with exact matching - look for the exact ID followed by space or \" -->\"\n      if (\n        body.includes(`visor-comment-id:${commentId} `) ||\n        body.includes(`visor-comment-id:${commentId} -->`)\n      ) {\n        return true;\n      }\n      // Check for legacy format (visor-review-* pattern) for backwards compatibility\n      if (commentId.startsWith('pr-review-') && body.includes('visor-review-')) {\n        return true;\n      }\n      // If we have a specific commentId but no exact match, return false\n      return false;\n    }\n    // General Visor comment detection (only when no specific commentId provided)\n    return (\n      (body.includes('visor-comment-id:') && body.includes('<!-- /visor-comment-id:')) ||\n      body.includes('visor-review-')\n    );\n  }\n\n  /**\n   * Extract comment ID from comment body\n   */\n  public extractCommentId(body: string): string | null {\n    const match = body.match(/visor-comment-id:([a-f0-9-]+)/);\n    return match ? match[1] : null;\n  }\n\n  /**\n   * Handle rate limiting with exponential backoff\n   */\n  private async handleRateLimit(error: {\n    response?: { headers?: Record<string, string> };\n  }): Promise<void> {\n    const resetTime = error.response?.headers?.['x-ratelimit-reset'];\n    if (resetTime) {\n      const resetDate = new Date(parseInt(resetTime) * 1000);\n      const waitTime = Math.max(resetDate.getTime() - Date.now(), this.retryConfig.baseDelay);\n      console.log(`Rate limit exceeded. Waiting ${Math.round(waitTime / 1000)}s until reset...`);\n      await this.sleep(Math.min(waitTime, this.retryConfig.maxDelay));\n    } else {\n      await this.sleep(this.retryConfig.baseDelay);\n    }\n  }\n\n  /**\n   * Check if error is a rate limit error\n   */\n  private isRateLimitError(error: GitHubApiError): boolean {\n    return error.status === 403 && (error.response?.data?.message?.includes('rate limit') ?? false);\n  }\n\n  /**\n   * Check if error should not be retried (auth errors, not found, etc.)\n   */\n  private isNonRetryableError(error: GitHubApiError): boolean {\n    // Don't retry auth errors, not found, etc., but allow rate limit errors to be handled separately\n    const nonRetryableStatuses = [401, 404, 422]; // Unauthorized, Not Found, Unprocessable Entity\n    const status = error.status || error.response?.status;\n\n    // 403 is non-retryable unless it's a rate limit error\n    if (status === 403) {\n      return !this.isRateLimitError(error);\n    }\n\n    return status !== undefined && nonRetryableStatuses.includes(status);\n  }\n\n  /**\n   * Retry wrapper with exponential backoff\n   */\n  private async withRetry<T>(operation: () => Promise<T>): Promise<T> {\n    let lastError: Error = new Error('Unknown error');\n\n    for (let attempt = 0; attempt <= this.retryConfig.maxRetries; attempt++) {\n      try {\n        return await operation();\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n\n        if (attempt === this.retryConfig.maxRetries) {\n          break;\n        }\n\n        if (\n          this.isRateLimitError(\n            error as { status?: number; response?: { data?: { message?: string } } }\n          )\n        ) {\n          await this.handleRateLimit(error as { response?: { headers?: Record<string, string> } });\n        } else if (this.isNonRetryableError(error as GitHubApiError)) {\n          // Don't retry auth errors, not found errors, etc.\n          throw error;\n        } else {\n          const computed =\n            this.retryConfig.baseDelay * Math.pow(this.retryConfig.backoffFactor, attempt);\n          const delay =\n            computed > this.retryConfig.maxDelay\n              ? Math.max(0, this.retryConfig.maxDelay - 1)\n              : computed;\n          await this.sleep(delay);\n        }\n      }\n    }\n\n    throw lastError;\n  }\n\n  /**\n   * Sleep utility\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => {\n      const t = setTimeout(resolve, ms);\n      if (typeof (t as any).unref === 'function') {\n        try {\n          (t as any).unref();\n        } catch {}\n      }\n    });\n  }\n\n  /**\n   * Group results by specified criteria\n   */\n  private groupResults(\n    results: Array<{ checkType: string; content: string; score?: number; issuesFound?: number }>,\n    groupBy: 'check' | 'severity'\n  ): Record<\n    string,\n    Array<{ checkType: string; content: string; score?: number; issuesFound?: number }>\n  > {\n    const grouped: Record<\n      string,\n      Array<{ checkType: string; content: string; score?: number; issuesFound?: number }>\n    > = {};\n\n    for (const result of results) {\n      const key = groupBy === 'check' ? result.checkType : this.getSeverityGroup(result.score);\n      if (!grouped[key]) {\n        grouped[key] = [];\n      }\n      grouped[key].push(result);\n    }\n\n    return grouped;\n  }\n\n  /**\n   * Get severity group based on score\n   */\n  private getSeverityGroup(score?: number): string {\n    if (!score) return 'Unknown';\n    if (score >= 90) return 'Excellent';\n    if (score >= 75) return 'Good';\n    if (score >= 50) return 'Needs Improvement';\n    return 'Critical Issues';\n  }\n\n  // Emoji helper removed: plain titles are used in group headers\n\n  /**\n   * Format group title with score and issue count\n   */\n  private formatGroupTitle(groupKey: string, score: number, issuesFound: number): string {\n    const formattedScore = Math.round(score);\n    return `${groupKey} Review (Score: ${formattedScore}/100)${issuesFound > 0 ? ` - ${issuesFound} issues found` : ''}`;\n  }\n}\n","/**\n * Centralized footer generation for Visor comments and outputs\n */\n\nexport interface FooterOptions {\n  /**\n   * Include metadata like lastUpdated, triggeredBy, commitSha\n   */\n  includeMetadata?: {\n    lastUpdated: string;\n    triggeredBy: string;\n    commitSha?: string;\n  };\n  /**\n   * Include horizontal rule separator before footer\n   */\n  includeSeparator?: boolean;\n}\n\n/**\n * Generate a standard Visor footer with branding and optional tip\n */\nexport function generateFooter(options: FooterOptions = {}): string {\n  const { includeMetadata, includeSeparator = true } = options;\n\n  const parts: string[] = [];\n\n  // Add separator\n  if (includeSeparator) {\n    parts.push('---');\n    parts.push('');\n  }\n\n  // Add branding\n  parts.push(\n    '*Powered by [Visor](https://probelabs.com/visor) from [Probelabs](https://probelabs.com)*'\n  );\n\n  // Add metadata if provided\n  if (includeMetadata) {\n    const { lastUpdated, triggeredBy, commitSha } = includeMetadata;\n    const commitInfo = commitSha ? ` | Commit: ${commitSha.substring(0, 7)}` : '';\n    parts.push('');\n    parts.push(`*Last updated: ${lastUpdated} | Triggered by: ${triggeredBy}${commitInfo}*`);\n  }\n\n  // Add tip\n  parts.push('');\n  parts.push('üí° **TIP:** You can chat with Visor using `/visor ask <your question>`');\n\n  return parts.join('\\n');\n}\n\n/**\n * Check if a string contains a Visor footer\n */\nexport function hasVisorFooter(text: string): boolean {\n  return (\n    text.includes('*Powered by [Visor](https://probelabs.com/visor)') ||\n    text.includes('*Powered by [Visor](https://github.com/probelabs/visor)')\n  );\n}\n","import { Octokit } from '@octokit/rest';\nimport { PRInfo } from './pr-analyzer';\nimport { CommentManager } from './github-comments';\nimport { AIReviewService, AIDebugInfo } from './ai-review-service';\n\nexport interface ReviewIssue {\n  // Location\n  file: string;\n  line: number;\n  endLine?: number;\n  // Issue details\n  ruleId: string;\n  message: string;\n  severity: 'info' | 'warning' | 'error' | 'critical';\n  category: 'security' | 'performance' | 'style' | 'logic' | 'documentation';\n  // Check identification - which check created this issue\n  checkName?: string;\n  // Group and schema for comment separation\n  group?: string;\n  schema?: string;\n  // Timestamp when the issue was created (for ordering)\n  timestamp?: number;\n  // Optional enhancement\n  suggestion?: string;\n  replacement?: string;\n}\n\n// Legacy interface - ONLY for GitHub integration compatibility\nexport interface ReviewComment {\n  file: string;\n  line: number;\n  message: string;\n  severity: 'info' | 'warning' | 'error' | 'critical';\n  category: 'security' | 'performance' | 'style' | 'logic' | 'documentation';\n  suggestion?: string;\n  replacement?: string;\n  ruleId?: string;\n}\n\n// Individual check result - each check produces one of these\nexport interface CheckResult {\n  checkName: string;\n  content: string; // Rendered output for this specific check\n  group: string; // Which group this check belongs to\n  // Optional structured output for custom schemas (e.g., overview, issue-assistant)\n  output?: unknown;\n  debug?: AIDebugInfo;\n  issues?: ReviewIssue[]; // Structured issues alongside rendered content\n}\n\n// Results grouped by group name\nexport interface GroupedCheckResults {\n  [groupName: string]: CheckResult[];\n}\n\n// Legacy interface - only for backward compatibility\nexport interface ReviewSummary {\n  issues?: ReviewIssue[];\n  debug?: AIDebugInfo;\n  /** Session ID created for this check (for cleanup tracking) */\n  sessionId?: string;\n}\n\n// Test utility function - Convert old ReviewSummary to new GroupedCheckResults format\n// This is for backward compatibility with tests only\nexport function convertReviewSummaryToGroupedResults(\n  reviewSummary: ReviewSummary,\n  checkName: string = 'test-check',\n  groupName: string = 'default'\n): GroupedCheckResults {\n  // Create a simple content string from issues\n  let content = '';\n\n  if (reviewSummary.issues && reviewSummary.issues.length > 0) {\n    content += `## Issues Found (${reviewSummary.issues.length})\\n\\n`;\n    reviewSummary.issues.forEach(issue => {\n      content += `- **${issue.severity.toUpperCase()}**: ${issue.message} (${issue.file}:${issue.line})\\n`;\n    });\n    content += '\\n';\n  }\n\n  if (!content) {\n    content = 'No issues found.';\n  }\n\n  const checkResult: CheckResult = {\n    checkName,\n    content: content.trim(),\n    group: groupName,\n    debug: reviewSummary.debug,\n    issues: reviewSummary.issues, // Include structured issues\n  };\n\n  const groupedResults: GroupedCheckResults = {};\n  groupedResults[groupName] = [checkResult];\n\n  return groupedResults;\n}\n\n// Helper functions for GitHub checks - ONLY for structured schemas that have issues\n// These are the ONLY acceptable hardcoded schema dependencies, and only for GitHub integration\nexport function calculateTotalIssues(issues?: ReviewIssue[]): number {\n  return (issues || []).length;\n}\n\nexport function calculateCriticalIssues(issues?: ReviewIssue[]): number {\n  return (issues || []).filter(i => i.severity === 'critical').length;\n}\n\n// Legacy converter - ONLY for GitHub integration compatibility\nexport function convertIssuesToComments(issues: ReviewIssue[]): ReviewComment[] {\n  return issues.map(issue => ({\n    file: issue.file,\n    line: issue.line,\n    message: issue.message,\n    severity: issue.severity,\n    category: issue.category,\n    suggestion: issue.suggestion,\n    replacement: issue.replacement,\n    ruleId: issue.ruleId,\n  }));\n}\n\nexport interface ReviewOptions {\n  focus?: string;\n  format?: 'table' | 'json' | 'markdown' | 'sarif';\n  debug?: boolean;\n  config?: import('./types/config').VisorConfig;\n  checks?: string[];\n  parallelExecution?: boolean;\n  // Optional tag filter to include/exclude checks by tags when running via GitHub Action path\n  tagFilter?: import('./types/config').TagFilter;\n}\n\nexport class PRReviewer {\n  private commentManager: CommentManager;\n  private aiReviewService: AIReviewService;\n\n  constructor(private octokit: Octokit) {\n    this.commentManager = new CommentManager(octokit);\n    this.aiReviewService = new AIReviewService();\n  }\n\n  async reviewPR(\n    owner: string,\n    repo: string,\n    prNumber: number,\n    prInfo: PRInfo,\n    options: ReviewOptions = {}\n  ): Promise<GroupedCheckResults> {\n    const { debug = false, config, checks } = options;\n\n    if (config && checks && checks.length > 0) {\n      const { CheckExecutionEngine } = await import('./check-execution-engine');\n      const engine = new CheckExecutionEngine();\n      const { results } = await engine.executeGroupedChecks(\n        prInfo,\n        checks,\n        undefined,\n        config,\n        undefined,\n        debug,\n        undefined,\n        undefined,\n        options.tagFilter\n      );\n      return results;\n    }\n\n    throw new Error(\n      'No configuration provided. Please create a .visor.yaml file with check definitions. ' +\n        'Built-in prompts have been removed - all checks must be explicitly configured.'\n    );\n  }\n\n  /**\n   * Helper to check if a schema is comment-generating\n   * Comment-generating schemas include:\n   * - Built-in schemas: code-review, overview, plain, text\n   * - Custom schemas with a \"text\" field in properties\n   */\n  private async isCommentGeneratingSchema(\n    schema: string | Record<string, unknown>\n  ): Promise<boolean> {\n    try {\n      // Check for built-in comment-generating schemas\n      if (typeof schema === 'string') {\n        // Well-known comment-generating schemas\n        if (['code-review', 'overview', 'plain', 'text'].includes(schema)) {\n          return true;\n        }\n\n        // Try to load and check custom string schema\n        const fs = require('fs').promises;\n        const path = require('path');\n\n        // Sanitize schema name\n        const sanitizedSchemaName = schema.replace(/[^a-zA-Z0-9-]/g, '');\n        if (!sanitizedSchemaName || sanitizedSchemaName !== schema) {\n          return false;\n        }\n\n        // Locate built-in schema JSON. In Actions, schemas live under dist/output (relative to __dirname).\n        // In local dev/tests, schemas live under project/output (relative to CWD).\n        const candidatePaths = [\n          path.join(__dirname, 'output', sanitizedSchemaName, 'schema.json'),\n          path.join(process.cwd(), 'output', sanitizedSchemaName, 'schema.json'),\n        ];\n\n        for (const schemaPath of candidatePaths) {\n          try {\n            const schemaContent = await fs.readFile(schemaPath, 'utf-8');\n            const schemaObj = JSON.parse(schemaContent);\n\n            // Check if schema has a \"text\" field in properties\n            const properties = schemaObj.properties as Record<string, unknown> | undefined;\n            return !!(properties && 'text' in properties);\n          } catch {\n            // try next location\n          }\n        }\n        // Schema file not found in any known location, not comment-generating\n        return false;\n      } else {\n        // Inline schema object - check if it has a \"text\" field in properties\n        const properties = schema.properties as Record<string, unknown> | undefined;\n        return !!(properties && 'text' in properties);\n      }\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Filter check results to only include those that should post GitHub comments\n   */\n  private async filterCommentGeneratingChecks(\n    checkResults: CheckResult[],\n    config: import('./types/config').VisorConfig\n  ): Promise<CheckResult[]> {\n    const filtered: CheckResult[] = [];\n\n    for (const r of checkResults) {\n      const cfg = config.checks?.[r.checkName];\n      const type = cfg?.type || 'ai'; // Default to 'ai' if not specified\n      const schema = cfg?.schema;\n\n      // Determine if this check should generate a comment\n      // Include checks with:\n      // 1. type: 'ai' or 'claude-code' with no schema or comment-generating schemas\n      // 2. Other types ONLY if they have explicit comment-generating schemas\n      let shouldPostComment = false;\n\n      // AI-powered checks generate comments by default\n      const isAICheck = type === 'ai' || type === 'claude-code';\n\n      if (!schema || schema === '') {\n        // No schema specified - only AI checks generate comments by default\n        // Other types (github, command, http, etc.) without schema are for orchestration\n        shouldPostComment = isAICheck;\n      } else {\n        // Check if the schema is comment-generating (built-in or custom with text field)\n        shouldPostComment = await this.isCommentGeneratingSchema(schema);\n      }\n\n      if (shouldPostComment) {\n        filtered.push(r);\n      }\n    }\n\n    return filtered;\n  }\n\n  async postReviewComment(\n    owner: string,\n    repo: string,\n    prNumber: number,\n    groupedResults: GroupedCheckResults,\n    options: ReviewOptions & {\n      commentId?: string;\n      triggeredBy?: string;\n      commitSha?: string;\n      octokitOverride?: Octokit;\n    } = {}\n  ): Promise<void> {\n    // Post separate comments for each group\n    for (const [groupName, checkResults] of Object.entries(groupedResults)) {\n      // Only checks with comment-generating schemas should post PR comments\n      // AI checks (ai, claude-code) generate comments by default\n      // Other types need explicit comment-generating schemas\n      let filteredResults = options.config\n        ? await this.filterCommentGeneratingChecks(checkResults, options.config)\n        : checkResults;\n\n      // Collapse results to avoid concatenating mutually-exclusive or duplicate posts.\n      // For fact-validation flow, both 'post-verified-response' and 'post-unverified-warning'\n      // can appear across waves. Prefer the final intended output and drop earlier entries.\n      if (groupName === 'github-output' && filteredResults && filteredResults.length > 1) {\n        // Keep only the last occurrence per checkName.\n        const byName = new Map<string, any>();\n        for (const cr of filteredResults) byName.set(cr.checkName, cr);\n        let collapsed = Array.from(byName.values());\n        const hasVerified = collapsed.some((r: any) => r.checkName === 'post-verified-response');\n        if (hasVerified) {\n          collapsed = collapsed.filter((r: any) => r.checkName !== 'post-unverified-warning');\n        }\n        filteredResults = collapsed as any;\n      }\n\n      // If nothing to report after filtering, skip this group\n      if (!filteredResults || filteredResults.length === 0) {\n        continue;\n      }\n\n      const comment = await this.formatGroupComment(filteredResults, options, {\n        owner,\n        repo,\n        prNumber,\n        commitSha: options.commitSha,\n      });\n\n      // Generate comment ID - use unique ID for \"dynamic\" group\n      let commentId: string;\n      if (groupName === 'dynamic') {\n        // Dynamic group creates a new comment each time with timestamp-based ID\n        const timestamp = Date.now();\n        commentId = `visor-dynamic-${timestamp}`;\n      } else {\n        // Regular groups use static IDs that get updated\n        commentId = options.commentId\n          ? `${options.commentId}-${groupName}`\n          : `visor-review-${groupName}`;\n      }\n\n      // Do not post empty comments (possible if content is blank after fallbacks)\n      if (!comment || !comment.trim()) continue;\n\n      const manager = options.octokitOverride\n        ? new CommentManager(options.octokitOverride)\n        : this.commentManager;\n      await manager.updateOrCreateComment(owner, repo, prNumber, comment, {\n        commentId,\n        triggeredBy: options.triggeredBy || 'unknown',\n        allowConcurrentUpdates: false,\n        commitSha: options.commitSha,\n      });\n    }\n  }\n\n  private async formatGroupComment(\n    checkResults: CheckResult[],\n    _options: ReviewOptions,\n    _githubContext?: { owner: string; repo: string; prNumber: number; commitSha?: string }\n  ): Promise<string> {\n    // Concatenate all check outputs in this group; fall back to structured output fields\n    const normalize = (s: string) => s.replace(/\\\\n/g, '\\n');\n    const checkContents = checkResults\n      .map(result => {\n        const trimmed = result.content?.trim();\n        if (trimmed) return normalize(trimmed);\n        // Fallback: if provider returned structured output with a common text field\n        const out = (result as unknown as { debug?: unknown; issues?: unknown; output?: any })\n          .output;\n        if (out) {\n          if (typeof out === 'string' && out.trim()) return normalize(out.trim());\n          if (typeof out === 'object') {\n            const txt = (out.text || out.response || out.message) as unknown;\n            if (typeof txt === 'string' && txt.trim()) return normalize(txt.trim());\n          }\n        }\n        return '';\n      })\n      .filter(content => content && content.trim());\n\n    // Add debug info if any check has it\n    const debugInfo = checkResults.find(result => result.debug)?.debug;\n\n    // Only generate comment if there's actual content or debug info\n    if (checkContents.length === 0 && !debugInfo) {\n      return '';\n    }\n\n    let comment = '';\n    comment += `## üîç Code Analysis Results\\n\\n`;\n    comment += checkContents.join('\\n\\n');\n\n    if (debugInfo) {\n      comment += '\\n\\n' + this.formatDebugSection(debugInfo);\n      comment += '\\n\\n';\n    }\n\n    // Footer will be added by formatCommentWithMetadata in github-comments.ts\n    return comment;\n  }\n\n  private formatDebugSection(debug: AIDebugInfo): string {\n    const formattedContent = [\n      `**Provider:** ${debug.provider}`,\n      `**Model:** ${debug.model}`,\n      `**API Key Source:** ${debug.apiKeySource}`,\n      `**Processing Time:** ${debug.processingTime}ms`,\n      `**Timestamp:** ${debug.timestamp}`,\n      `**Prompt Length:** ${debug.promptLength} characters`,\n      `**Response Length:** ${debug.responseLength} characters`,\n      `**JSON Parse Success:** ${debug.jsonParseSuccess ? '‚úÖ' : '‚ùå'}`,\n    ];\n\n    if (debug.errors && debug.errors.length > 0) {\n      formattedContent.push('', '### Errors');\n      debug.errors.forEach(error => {\n        formattedContent.push(`- ${error}`);\n      });\n    }\n\n    const fullDebugContent = [\n      ...formattedContent,\n      '',\n      '### AI Prompt',\n      '```',\n      debug.prompt,\n      '```',\n      '',\n      '### Raw AI Response',\n      '```json',\n      debug.rawResponse,\n      '```',\n    ].join('\\n');\n\n    if (fullDebugContent.length > 60000) {\n      const artifactPath = this.saveDebugArtifact(debug);\n      formattedContent.push('');\n      formattedContent.push('### Debug Details');\n      formattedContent.push('‚ö†Ô∏è Debug information is too large for GitHub comments.');\n      if (artifactPath) {\n        formattedContent.push(\n          `üìÅ **Full debug information saved to artifact:** \\`${artifactPath}\\``\n        );\n        formattedContent.push('');\n        const runId = process.env.GITHUB_RUN_ID;\n        const repoUrl =\n          process.env.GITHUB_SERVER_URL && process.env.GITHUB_REPOSITORY\n            ? `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}`\n            : null;\n        if (runId && repoUrl) {\n          formattedContent.push(\n            `üîó **Download Link:** [visor-debug-${process.env.GITHUB_RUN_NUMBER || runId}](${repoUrl}/actions/runs/${runId})`\n          );\n        }\n        formattedContent.push(\n          'üí° Go to the GitHub Action run above and download the debug artifact to view complete prompts and responses.'\n        );\n      } else {\n        formattedContent.push('üìù **Prompt preview:** ' + debug.prompt.substring(0, 500) + '...');\n        formattedContent.push(\n          'üìù **Response preview:** ' + debug.rawResponse.substring(0, 500) + '...'\n        );\n      }\n    } else {\n      formattedContent.push('');\n      formattedContent.push('### AI Prompt');\n      formattedContent.push('```');\n      formattedContent.push(debug.prompt);\n      formattedContent.push('```');\n      formattedContent.push('');\n      formattedContent.push('### Raw AI Response');\n      formattedContent.push('```json');\n      formattedContent.push(debug.rawResponse);\n      formattedContent.push('```');\n    }\n\n    return this.commentManager.createCollapsibleSection(\n      'üêõ Debug Information',\n      formattedContent.join('\\n'),\n      false\n    );\n  }\n\n  private saveDebugArtifact(debug: AIDebugInfo): string | null {\n    try {\n      const fs = require('fs');\n      const path = require('path');\n      const debugDir = path.join(process.cwd(), 'debug-artifacts');\n      if (!fs.existsSync(debugDir)) {\n        fs.mkdirSync(debugDir, { recursive: true });\n      }\n\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n      const filename = `visor-debug-${timestamp}.md`;\n      const filepath = path.join(debugDir, filename);\n\n      const content = [\n        `# Visor Debug Information`,\n        ``,\n        `**Timestamp:** ${debug.timestamp}`,\n        `**Provider:** ${debug.provider}`,\n        `**Model:** ${debug.model}`,\n        `**Processing Time:** ${debug.processingTime}ms`,\n        ``,\n        `## AI Prompt`,\n        ``,\n        '```',\n        debug.prompt,\n        '```',\n        ``,\n        `## Raw AI Response`,\n        ``,\n        '```json',\n        debug.rawResponse,\n        '```',\n      ].join('\\n');\n\n      fs.writeFileSync(filepath, content, 'utf8');\n      return filename;\n    } catch (error) {\n      console.error('Failed to save debug artifact:', error);\n      return null;\n    }\n  }\n}\n","import { simpleGit, SimpleGit, type DefaultLogFields, type ListLogLine } from 'simple-git';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport { PRInfo, PRDiff } from './pr-analyzer';\nimport { FileExclusionHelper } from './utils/file-exclusion';\n\nexport interface GitFileChange {\n  filename: string;\n  status: 'added' | 'removed' | 'modified' | 'renamed';\n  additions: number;\n  deletions: number;\n  changes: number;\n  content?: string;\n  patch?: string;\n  truncated?: boolean;\n}\n\n// Maximum patch size in bytes (50KB) - helps prevent token limit issues\nconst MAX_PATCH_SIZE = 50 * 1024;\n\nexport interface GitRepositoryInfo {\n  title: string;\n  body: string;\n  author: string;\n  base: string;\n  head: string;\n  files: GitFileChange[];\n  totalAdditions: number;\n  totalDeletions: number;\n  isGitRepository: boolean;\n  workingDirectory: string;\n}\n\nexport class GitRepositoryAnalyzer {\n  private git: SimpleGit;\n  private cwd: string;\n  private fileExclusionHelper: FileExclusionHelper;\n\n  constructor(workingDirectory: string = process.cwd()) {\n    this.cwd = workingDirectory;\n    this.git = simpleGit(workingDirectory);\n    this.fileExclusionHelper = new FileExclusionHelper(workingDirectory);\n  }\n\n  /**\n   * Analyze the current git repository state and return data compatible with PRInfo interface\n   */\n  async analyzeRepository(\n    includeContext: boolean = true,\n    enableBranchDiff: boolean = false\n  ): Promise<GitRepositoryInfo> {\n    // Check if we're in a git repository\n    const isRepo = await this.isGitRepository();\n    if (!isRepo) {\n      return this.createEmptyRepositoryInfo('Not a git repository');\n    }\n\n    try {\n      // Get current branch and status\n      const [status, currentBranch, baseBranch] = await Promise.all([\n        this.git.status(),\n        this.getCurrentBranch(),\n        this.getBaseBranch(),\n      ]);\n\n      // Determine if we're on a feature branch\n      const isFeatureBranch =\n        currentBranch !== baseBranch && currentBranch !== 'main' && currentBranch !== 'master';\n\n      // Get uncommitted changes first\n      let uncommittedFiles = await this.getUncommittedChanges(includeContext);\n\n      // If branch diff is explicitly enabled, use branch diff (ignoring uncommitted changes)\n      // Otherwise, if on a feature branch with no uncommitted changes AND branch diff is enabled, get diff vs base branch\n      if (isFeatureBranch && includeContext && enableBranchDiff) {\n        if (uncommittedFiles.length > 0) {\n          console.error(`üìä Feature branch detected: ${currentBranch}`);\n          console.error(\n            `‚ö†Ô∏è  Ignoring ${uncommittedFiles.length} uncommitted file(s) due to --analyze-branch-diff flag`\n          );\n        } else {\n          console.error(`üìä Feature branch detected: ${currentBranch}`);\n        }\n        console.error(\n          `üìÇ Analyzing diff vs ${baseBranch} (${uncommittedFiles.length > 0 ? 'forced by --analyze-branch-diff' : 'auto-enabled for code-review schemas'})`\n        );\n        uncommittedFiles = await this.getBranchDiff(baseBranch, includeContext);\n      } else if (uncommittedFiles.length > 0) {\n        console.error(`üìù Analyzing uncommitted changes (${uncommittedFiles.length} files)`);\n      }\n\n      // Get recent commit info (handle repos with no commits)\n      let lastCommit: (ListLogLine & DefaultLogFields) | null = null;\n      try {\n        const recentCommits = await this.git.log({ maxCount: 1 });\n        lastCommit = recentCommits.latest;\n      } catch {\n        // Repository has no commits yet - this is OK\n        console.error('üìù Repository has no commits yet, analyzing uncommitted changes');\n      }\n\n      // Get author from git config if no commits exist\n      let author = lastCommit?.author_name;\n      if (!author) {\n        try {\n          // Read ONLY repository-local config to avoid leaking global user identity into tests\n          const [userName, userEmail] = await Promise.all([\n            this.git.raw(['config', '--local', 'user.name']).catch(() => null),\n            this.git.raw(['config', '--local', 'user.email']).catch(() => null),\n          ]);\n          author = userName?.trim() || userEmail?.trim() || 'unknown';\n        } catch {\n          author = 'unknown';\n        }\n      }\n\n      // Create repository info\n      const repositoryInfo: GitRepositoryInfo = {\n        title: this.generateTitle(status, currentBranch),\n        body: this.generateDescription(status, lastCommit),\n        author,\n        base: baseBranch,\n        head: currentBranch,\n        files: uncommittedFiles,\n        totalAdditions: uncommittedFiles.reduce((sum, file) => sum + file.additions, 0),\n        totalDeletions: uncommittedFiles.reduce((sum, file) => sum + file.deletions, 0),\n        isGitRepository: true,\n        workingDirectory: this.cwd,\n      };\n\n      return repositoryInfo;\n    } catch (error) {\n      // Don't log the full error object to avoid confusing stack traces\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      console.error('Error analyzing git repository:', errorMessage);\n      return this.createEmptyRepositoryInfo('Error analyzing git repository');\n    }\n  }\n\n  /**\n   * Convert GitRepositoryInfo to PRInfo format for compatibility with existing PRReviewer\n   */\n  toPRInfo(repositoryInfo: GitRepositoryInfo, includeContext: boolean = true): PRInfo {\n    const files = repositoryInfo.files.map(\n      (file): PRDiff => ({\n        filename: file.filename,\n        additions: file.additions,\n        deletions: file.deletions,\n        changes: file.changes,\n        patch: includeContext ? file.patch : undefined,\n        status: file.status,\n      })\n    );\n\n    // Generate fullDiff from patches if includeContext is true\n    let fullDiff: string | undefined;\n    if (includeContext) {\n      fullDiff = files\n        .filter(file => file.patch)\n        .map(file => `--- ${file.filename}\\n${file.patch}`)\n        .join('\\n\\n');\n    }\n\n    return {\n      number: 0, // Local analysis doesn't have PR number\n      title: repositoryInfo.title,\n      body: repositoryInfo.body,\n      author: repositoryInfo.author,\n      base: repositoryInfo.base,\n      head: repositoryInfo.head,\n      files,\n      totalAdditions: repositoryInfo.totalAdditions,\n      totalDeletions: repositoryInfo.totalDeletions,\n      fullDiff,\n    };\n  }\n\n  private async isGitRepository(): Promise<boolean> {\n    try {\n      await this.git.checkIsRepo();\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  private async getCurrentBranch(): Promise<string> {\n    try {\n      const branchSummary = await this.git.branch();\n      return branchSummary.current || 'unknown';\n    } catch {\n      return 'unknown';\n    }\n  }\n\n  private async getBaseBranch(): Promise<string> {\n    try {\n      // Try to get the default branch from remote\n      const branches = await this.git.branch(['-r']);\n      const mainBranches = ['origin/main', 'origin/master', 'origin/develop'];\n\n      for (const mainBranch of mainBranches) {\n        if (branches.all.includes(mainBranch)) {\n          return mainBranch.replace('origin/', '');\n        }\n      }\n\n      // Fallback to main/master\n      return 'main';\n    } catch {\n      return 'main';\n    }\n  }\n\n  /**\n   * Truncate a patch if it exceeds MAX_PATCH_SIZE\n   */\n  private truncatePatch(patch: string, filename: string): { patch: string; truncated: boolean } {\n    const patchSize = Buffer.byteLength(patch, 'utf8');\n\n    if (patchSize <= MAX_PATCH_SIZE) {\n      return { patch, truncated: false };\n    }\n\n    // Truncate to MAX_PATCH_SIZE and add a notice\n    const truncated = patch.substring(0, MAX_PATCH_SIZE);\n    const truncatedPatch = `${truncated}\\n\\n... [TRUNCATED: Diff too large (${(patchSize / 1024).toFixed(1)}KB), showing first ${(MAX_PATCH_SIZE / 1024).toFixed(0)}KB] ...`;\n\n    console.error(\n      `‚ö†Ô∏è  Truncated diff for ${filename} (${(patchSize / 1024).toFixed(1)}KB ‚Üí ${(MAX_PATCH_SIZE / 1024).toFixed(0)}KB)`\n    );\n\n    return { patch: truncatedPatch, truncated: true };\n  }\n\n  private async getRemoteInfo(): Promise<{ name: string; url: string } | null> {\n    try {\n      const remotes = await this.git.getRemotes(true);\n      const origin = remotes.find(r => r.name === 'origin');\n      return origin\n        ? { name: origin.name, url: origin.refs.fetch || origin.refs.push || '' }\n        : null;\n    } catch {\n      return null;\n    }\n  }\n\n  private async getUncommittedChanges(includeContext: boolean = true): Promise<GitFileChange[]> {\n    try {\n      const status = await this.git.status();\n      const changes: GitFileChange[] = [];\n\n      // Process different types of changes\n      const fileChanges = [\n        ...status.created.map(f => ({ file: f, status: 'added' as const })),\n        ...status.deleted.map(f => ({ file: f, status: 'removed' as const })),\n        ...status.modified.map(f => ({ file: f, status: 'modified' as const })),\n        ...status.renamed.map(f => ({\n          file: typeof f === 'string' ? f : f.to || f.from,\n          status: 'renamed' as const,\n        })),\n      ];\n\n      for (const { file, status } of fileChanges) {\n        // Skip files that should be excluded from analysis\n        // FileExclusionHelper uses .gitignore patterns, which is sufficient\n        if (this.fileExclusionHelper.shouldExcludeFile(file)) {\n          console.error(`‚è≠Ô∏è  Skipping excluded file: ${file}`);\n          continue;\n        }\n\n        const filePath = path.join(this.cwd, file);\n        const fileChange = await this.analyzeFileChange(file, status, filePath, includeContext);\n        changes.push(fileChange);\n      }\n\n      return changes;\n    } catch (error) {\n      console.error('Error getting uncommitted changes:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Get diff between current branch and base branch (for feature branch analysis)\n   */\n  private async getBranchDiff(\n    baseBranch: string,\n    includeContext: boolean = true\n  ): Promise<GitFileChange[]> {\n    try {\n      // Get the list of changed files between base and current branch\n      const diffSummary = await this.git.diffSummary([baseBranch]);\n      const changes: GitFileChange[] = [];\n\n      if (!diffSummary || !diffSummary.files) {\n        return [];\n      }\n\n      for (const file of diffSummary.files) {\n        // Skip files that should be excluded from analysis\n        // FileExclusionHelper uses .gitignore patterns, which is sufficient\n        if (this.fileExclusionHelper.shouldExcludeFile(file.file)) {\n          console.error(`‚è≠Ô∏è  Skipping excluded file: ${file.file}`);\n          continue;\n        }\n\n        // Handle different file types (binary files don't have insertions/deletions)\n        const isBinary = 'binary' in file && file.binary;\n        const insertions = 'insertions' in file ? file.insertions : 0;\n        const deletions = 'deletions' in file ? file.deletions : 0;\n        const fileChanges = 'changes' in file ? file.changes : 0;\n\n        // Determine status based on insertions/deletions\n        let status: 'added' | 'removed' | 'modified' | 'renamed';\n        if (isBinary) {\n          status = 'modified';\n        } else if (insertions > 0 && deletions === 0) {\n          status = 'added';\n        } else if (insertions === 0 && deletions > 0) {\n          status = 'removed';\n        } else {\n          status = 'modified';\n        }\n\n        // Get the actual diff patch if needed\n        let patch: string | undefined;\n        let truncated = false;\n        if (includeContext && !isBinary) {\n          try {\n            const rawPatch = await this.git.diff([baseBranch, '--', file.file]);\n            if (rawPatch) {\n              const result = this.truncatePatch(rawPatch, file.file);\n              patch = result.patch;\n              truncated = result.truncated;\n            }\n          } catch {\n            // Ignore diff errors for specific files\n          }\n        }\n\n        const fileChange: GitFileChange = {\n          filename: file.file,\n          additions: insertions,\n          deletions: deletions,\n          changes: fileChanges,\n          status,\n          patch,\n          truncated,\n        };\n\n        changes.push(fileChange);\n      }\n\n      return changes;\n    } catch (error) {\n      console.error('Error getting branch diff:', error);\n      return [];\n    }\n  }\n\n  private async analyzeFileChange(\n    filename: string,\n    status: 'added' | 'removed' | 'modified' | 'renamed',\n    filePath: string,\n    includeContext: boolean = true\n  ): Promise<GitFileChange> {\n    let additions = 0;\n    let deletions = 0;\n    let patch: string | undefined;\n    let content: string | undefined;\n    let truncated = false;\n\n    try {\n      // Get diff for the file if it exists and is not binary\n      if (includeContext && status !== 'added' && fs.existsSync(filePath)) {\n        const diff = await this.git.diff(['--', filename]).catch(() => '');\n        if (diff) {\n          const result = this.truncatePatch(diff, filename);\n          patch = result.patch;\n          truncated = result.truncated;\n          // Count additions and deletions from diff\n          const lines = diff.split('\\n');\n          additions = lines.filter(line => line.startsWith('+')).length;\n          deletions = lines.filter(line => line.startsWith('-')).length;\n        }\n      } else if (status !== 'added' && fs.existsSync(filePath)) {\n        // If not including context, still count changes for statistics\n        const diff = await this.git.diff(['--', filename]).catch(() => '');\n        if (diff) {\n          const lines = diff.split('\\n');\n          additions = lines.filter(line => line.startsWith('+')).length;\n          deletions = lines.filter(line => line.startsWith('-')).length;\n        }\n      }\n\n      // For added files\n      if (status === 'added' && fs.existsSync(filePath)) {\n        try {\n          const stats = fs.statSync(filePath);\n          if (stats.isFile() && stats.size < 1024 * 1024) {\n            // Skip files larger than 1MB\n            if (includeContext) {\n              content = fs.readFileSync(filePath, 'utf8');\n              const result = this.truncatePatch(content, filename);\n              patch = result.patch; // For new files, the entire content is the \"patch\"\n              truncated = result.truncated;\n            }\n            // Always count additions for statistics\n            const fileContent = includeContext ? content : fs.readFileSync(filePath, 'utf8');\n            additions = fileContent!.split('\\n').length;\n          }\n        } catch {\n          // Skip binary or unreadable files\n        }\n      }\n\n      // For removed files, we can't easily count the lines without the previous version\n      if (status === 'removed') {\n        deletions = 1; // Placeholder - in real git we'd need the previous version\n      }\n    } catch (error) {\n      console.error(`Error analyzing file change for ${filename}:`, error);\n    }\n\n    return {\n      filename,\n      status,\n      additions,\n      deletions,\n      changes: additions + deletions,\n      content,\n      patch,\n      truncated,\n    };\n  }\n\n  private generateTitle(status: import('simple-git').StatusResult, branch: string): string {\n    if (status.files.length === 0) {\n      return `Local Analysis: ${branch} (No changes)`;\n    }\n\n    const changeTypes = [];\n    if (status.created.length > 0) changeTypes.push(`${status.created.length} added`);\n    if (status.modified.length > 0) changeTypes.push(`${status.modified.length} modified`);\n    if (status.deleted.length > 0) changeTypes.push(`${status.deleted.length} deleted`);\n    if (status.renamed.length > 0) changeTypes.push(`${status.renamed.length} renamed`);\n\n    return `Local Analysis: ${branch} (${changeTypes.join(', ')})`;\n  }\n\n  private generateDescription(\n    status: import('simple-git').StatusResult,\n    lastCommit: import('simple-git').DefaultLogFields | null\n  ): string {\n    let description = `Analysis of local git repository working directory.\\n\\n`;\n\n    if (lastCommit) {\n      description += `**Last Commit:** ${lastCommit.message}\\n`;\n      description += `**Author:** ${lastCommit.author_name} <${lastCommit.author_email}>\\n`;\n      description += `**Date:** ${lastCommit.date}\\n\\n`;\n    }\n\n    if (status.files.length === 0) {\n      description += `**Status:** Working directory is clean - no uncommitted changes found.\\n`;\n    } else {\n      description += `**Changes Summary:**\\n`;\n      description += `- Files to be committed: ${status.staged.length}\\n`;\n      description += `- Modified files: ${status.modified.length}\\n`;\n      description += `- Untracked files: ${status.not_added.length}\\n`;\n\n      if (status.conflicted.length > 0) {\n        description += `- Conflicted files: ${status.conflicted.length}\\n`;\n      }\n    }\n\n    return description;\n  }\n\n  private createEmptyRepositoryInfo(reason: string): GitRepositoryInfo {\n    return {\n      title: `Local Analysis: ${reason}`,\n      body: `Unable to analyze repository: ${reason}`,\n      author: 'system',\n      base: 'main',\n      head: 'HEAD',\n      files: [],\n      totalAdditions: 0,\n      totalDeletions: 0,\n      isGitRepository: false,\n      workingDirectory: this.cwd,\n    };\n  }\n}\n","import ignore from 'ignore';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n/**\n * Default exclusion patterns for common build artifacts and dependencies.\n * These can be overridden by providing custom patterns to the constructor.\n */\nconst DEFAULT_EXCLUSION_PATTERNS = [\n  'dist/',\n  'build/',\n  '.next/',\n  'out/',\n  'node_modules/',\n  'coverage/',\n  '.turbo/',\n  'bundled/',\n];\n\n/**\n * Shared utility for filtering files based on .gitignore patterns\n *\n * Design Decision: Synchronous I/O in Constructor\n * ------------------------------------------------\n * This class intentionally uses synchronous file I/O in the constructor for the following reasons:\n *\n * 1. **Initialization Context**: The constructor is called once during application startup,\n *    not in request handling or performance-critical paths.\n *\n * 2. **Small File Sizes**: .gitignore files are typically <10KB. Even in large monorepos,\n *    they rarely exceed 100KB. Reading such small files synchronously has negligible impact.\n *\n * 3. **Immediate Availability**: The exclusion patterns must be ready immediately for use.\n *    Asynchronous initialization would require either:\n *    - Async factory method (adds API complexity)\n *    - Lazy loading (race conditions, repeated checks)\n *    - Promise-based initialization (complicates usage across codebase)\n *\n * 4. **Simplicity**: Synchronous loading keeps the API simple and prevents async contagion\n *    throughout the codebase. Methods like shouldExcludeFile() remain synchronous.\n *\n * 5. **No DoS Risk**: The file reading happens exactly once per instance during construction.\n *    Attackers cannot trigger repeated synchronous reads.\n *\n * 6. **Consistency**: This follows the same pattern as other configuration loaders in Node.js\n *    ecosystem (e.g., require(), cosmiconfig's sync mode).\n *\n * Alternative Considered: Async factory pattern would add complexity without meaningful benefit\n * given the usage patterns and file sizes involved.\n */\nexport class FileExclusionHelper {\n  private gitignore: ReturnType<typeof ignore> | null = null;\n  private workingDirectory: string;\n\n  /**\n   * @param workingDirectory - Directory to search for .gitignore\n   * @param additionalPatterns - Additional patterns to include (optional, defaults to common build artifacts)\n   */\n  constructor(\n    workingDirectory: string = process.cwd(),\n    additionalPatterns: string[] | null = DEFAULT_EXCLUSION_PATTERNS\n  ) {\n    // Validate and normalize workingDirectory to prevent path traversal\n    const normalizedPath = path.resolve(workingDirectory);\n\n    // Ensure path doesn't contain suspicious patterns after normalization\n    // Check for null bytes which could be used for injection\n    if (normalizedPath.includes('\\0')) {\n      throw new Error('Invalid workingDirectory: contains null bytes');\n    }\n\n    this.workingDirectory = normalizedPath;\n\n    // Load gitignore synchronously during construction\n    // This is acceptable because:\n    // 1. Constructor is called once during initialization\n    // 2. .gitignore files are typically small (<10KB)\n    // 3. Synchronous loading ensures patterns are ready immediately\n    // 4. Avoids async constructor complexity\n    this.loadGitignore(additionalPatterns);\n  }\n\n  /**\n   * Load .gitignore patterns from the working directory (called once in constructor)\n   * @param additionalPatterns - Additional patterns to add to gitignore rules\n   */\n  private loadGitignore(additionalPatterns: string[] | null): void {\n    // Resolve both paths to absolute, normalized forms\n    const gitignorePath = path.resolve(this.workingDirectory, '.gitignore');\n    const resolvedWorkingDir = path.resolve(this.workingDirectory);\n\n    try {\n      // Robust path validation using path.relative()\n      // This handles symlinks and edge cases better than string comparison\n      const relativePath = path.relative(resolvedWorkingDir, gitignorePath);\n\n      // Security check: ensure .gitignore is within working directory\n      // Reject if:\n      // - Starts with '..' (parent directory)\n      // - Is an absolute path (should be relative after path.relative())\n      if (relativePath.startsWith('..') || path.isAbsolute(relativePath)) {\n        throw new Error('Invalid gitignore path: path traversal detected');\n      }\n\n      // Additionally verify it's exactly '.gitignore' (no subdirectories)\n      if (relativePath !== '.gitignore') {\n        throw new Error('Invalid gitignore path: must be .gitignore in working directory');\n      }\n\n      this.gitignore = ignore();\n\n      // Add additional patterns first (lower priority)\n      if (additionalPatterns && additionalPatterns.length > 0) {\n        this.gitignore.add(additionalPatterns);\n      }\n\n      // Load and add .gitignore patterns (higher priority)\n      if (fs.existsSync(gitignorePath)) {\n        const rawContent = fs.readFileSync(gitignorePath, 'utf8');\n\n        // Comprehensive sanitization to prevent injection attacks\n        const gitignoreContent = rawContent\n          .replace(/[\\r\\n]+/g, '\\n') // Normalize line endings first\n          .replace(/[\\x00-\\x09\\x0B-\\x1F\\x7F]/g, '') // Remove control chars except \\n (0x0A)\n          .split('\\n')\n          .filter(line => line.length < 1000) // Reject extremely long lines that could cause DoS\n          .join('\\n')\n          .trim();\n\n        this.gitignore.add(gitignoreContent);\n        if (process.env.VISOR_DEBUG === 'true') {\n          console.error('‚úÖ Loaded .gitignore patterns for file filtering');\n        }\n      } else if (additionalPatterns && additionalPatterns.length > 0) {\n        // Always emit a user-visible warning so callers can assert this behavior in tests\n        console.error('No .gitignore found, using default exclusion patterns');\n        console.warn('No .gitignore found, using default exclusion patterns');\n      }\n    } catch (error) {\n      // Always emit a warning with the error for visibility and tests\n      console.warn('Failed to load .gitignore:', error instanceof Error ? error.message : error);\n    }\n  }\n\n  /**\n   * Check if a file should be excluded based on .gitignore patterns\n   */\n  shouldExcludeFile(filename: string): boolean {\n    // Check against .gitignore patterns if loaded\n    if (this.gitignore) {\n      return this.gitignore.ignores(filename);\n    }\n\n    return false;\n  }\n}\n","import { Octokit } from '@octokit/rest';\nimport * as path from 'path';\nimport { FileExclusionHelper } from './utils/file-exclusion';\n\nexport interface PRFile {\n  filename: string;\n  additions: number;\n  deletions: number;\n  changes: number;\n  patch?: string;\n  status: 'added' | 'removed' | 'modified' | 'renamed';\n}\n\nexport interface PRDiff {\n  filename: string;\n  additions: number;\n  deletions: number;\n  changes: number;\n  patch?: string;\n  status: 'added' | 'removed' | 'modified' | 'renamed';\n}\n\nexport interface PRComment {\n  id: number;\n  author: string;\n  body: string;\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface PRInfo {\n  number: number;\n  title: string;\n  body: string;\n  author: string;\n  authorAssociation?: string; // GitHub author_association: OWNER, MEMBER, COLLABORATOR, CONTRIBUTOR, etc.\n  base: string;\n  head: string;\n  files: PRDiff[];\n  totalAdditions: number;\n  totalDeletions: number;\n  eventType?: import('./types/config').EventTrigger;\n  fullDiff?: string;\n  commitDiff?: string;\n  isIncremental?: boolean; // Flag to indicate if this was intended as incremental analysis\n  isIssue?: boolean; // Flag to indicate this is an issue, not a PR\n  eventContext?: Record<string, unknown>; // GitHub event context for templates\n  comments?: PRComment[]; // Comments added dynamically\n  labels?: string[]; // Labels applied to the PR (for behavior overrides)\n}\n\ninterface NetworkError {\n  code?: string;\n  message?: string;\n  status?: number;\n}\n\nexport class PRAnalyzer {\n  private fileExclusionHelper: FileExclusionHelper;\n\n  constructor(\n    private octokit: Octokit,\n    private maxRetries: number = 3,\n    workingDirectory: string = path.resolve(process.cwd())\n  ) {\n    this.fileExclusionHelper = new FileExclusionHelper(workingDirectory);\n  }\n\n  /**\n   * Fetch commit diff for incremental analysis\n   */\n  async fetchCommitDiff(owner: string, repo: string, commitSha: string): Promise<string> {\n    try {\n      const { data: commit } = await this.withRetry(() =>\n        this.octokit.rest.repos.getCommit({\n          owner,\n          repo,\n          ref: commitSha,\n        })\n      );\n\n      // Extract patches from all files in the commit\n      const patches =\n        commit.files\n          ?.filter(file => file.patch)\n          .map(file => `--- ${file.filename}\\n${file.patch}`)\n          .join('\\n\\n') || '';\n\n      return patches;\n    } catch (error) {\n      console.warn(`Failed to fetch commit diff for ${commitSha}:`, error);\n      return '';\n    }\n  }\n\n  /**\n   * Generate unified diff for all PR files\n   */\n  private generateFullDiff(files: PRDiff[]): string {\n    return files\n      .filter(file => file.patch)\n      .map(file => `--- ${file.filename}\\n${file.patch}`)\n      .join('\\n\\n');\n  }\n\n  async fetchPRDiff(\n    owner: string,\n    repo: string,\n    prNumber: number,\n    commitSha?: string,\n    eventType?: import('./types/config').EventTrigger\n  ): Promise<PRInfo> {\n    const [prData, filesData] = await Promise.all([\n      this.withRetry(() =>\n        this.octokit.rest.pulls.get({\n          owner,\n          repo,\n          pull_number: prNumber,\n        })\n      ),\n      this.withRetry(() =>\n        this.octokit.rest.pulls.listFiles({\n          owner,\n          repo,\n          pull_number: prNumber,\n        })\n      ),\n    ]);\n\n    const pr = prData?.data;\n    const files = filesData?.data || [];\n\n    // Handle missing or malformed PR data gracefully\n    if (!pr) {\n      throw new Error('Invalid or missing pull request data');\n    }\n\n    // Validate critical fields and provide defaults for missing data\n    const title = typeof pr.title === 'string' ? pr.title : pr.title ? String(pr.title) : 'MISSING';\n    const body = typeof pr.body === 'string' ? pr.body : pr.body ? String(pr.body) : '';\n    const author =\n      pr.user && typeof pr.user === 'object' && pr.user.login\n        ? typeof pr.user.login === 'string'\n          ? pr.user.login\n          : String(pr.user.login)\n        : 'unknown';\n    const authorAssociation =\n      pr.author_association && typeof pr.author_association === 'string'\n        ? pr.author_association\n        : undefined;\n    const base =\n      pr.base && typeof pr.base === 'object' && pr.base.ref\n        ? typeof pr.base.ref === 'string'\n          ? pr.base.ref\n          : String(pr.base.ref)\n        : 'main';\n    const head =\n      pr.head && typeof pr.head === 'object' && pr.head.ref\n        ? typeof pr.head.ref === 'string'\n          ? pr.head.ref\n          : String(pr.head.ref)\n        : 'feature';\n\n    // Filter out malformed files and handle invalid data types\n    // Apply exclusion filtering early to avoid unnecessary processing\n    let skippedCount = 0;\n    const validFiles = files\n      ? files\n          .filter(file => file && typeof file === 'object' && file.filename)\n          .filter(file => {\n            // Early filtering: check exclusion before processing\n            const filename =\n              typeof file.filename === 'string'\n                ? file.filename\n                : String(file.filename || 'unknown');\n            if (!filename || this.fileExclusionHelper.shouldExcludeFile(filename)) {\n              skippedCount++;\n              return false;\n            }\n            return true;\n          })\n          .map(file => ({\n            filename:\n              typeof file.filename === 'string'\n                ? file.filename\n                : String(file.filename || 'unknown'),\n            additions: typeof file.additions === 'number' ? Math.max(0, file.additions) : 0,\n            deletions: typeof file.deletions === 'number' ? Math.max(0, file.deletions) : 0,\n            changes: typeof file.changes === 'number' ? Math.max(0, file.changes) : 0,\n            patch: typeof file.patch === 'string' ? file.patch : undefined,\n            status: (['added', 'removed', 'modified', 'renamed'].includes(file.status)\n              ? file.status\n              : 'modified') as 'added' | 'removed' | 'modified' | 'renamed',\n          }))\n      : [];\n\n    // Log skipped files summary\n    if (skippedCount > 0) {\n      console.log(`‚è≠Ô∏è  Skipped ${skippedCount} excluded file(s)`);\n    }\n\n    const prInfo: PRInfo = {\n      number: typeof pr.number === 'number' ? pr.number : parseInt(String(pr.number || 1), 10),\n      title,\n      body,\n      author,\n      authorAssociation,\n      base,\n      head,\n      files: validFiles,\n      totalAdditions: validFiles.reduce((sum, file) => sum + file.additions, 0),\n      totalDeletions: validFiles.reduce((sum, file) => sum + file.deletions, 0),\n      fullDiff: this.generateFullDiff(validFiles),\n      eventType,\n    };\n\n    // Fetch comment history for better context\n    try {\n      console.log(`üí¨ Fetching comment history for PR #${prInfo.number}`);\n      const comments = await this.fetchPRComments(owner, repo, prInfo.number);\n      (prInfo as PRInfo & { comments: PRComment[] }).comments = comments;\n      console.log(`‚úÖ Retrieved ${comments.length} comments`);\n    } catch (error) {\n      console.warn(\n        `‚ö†Ô∏è Could not fetch comments: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n      (prInfo as PRInfo & { comments: PRComment[] }).comments = [];\n    }\n\n    // Add commit diff for incremental analysis\n    if (commitSha) {\n      console.log(`üîß Fetching incremental diff for commit: ${commitSha}`);\n      prInfo.commitDiff = await this.fetchCommitDiff(owner, repo, commitSha);\n      prInfo.isIncremental = true;\n      if (!prInfo.commitDiff || prInfo.commitDiff.length === 0) {\n        console.warn(\n          `‚ö†Ô∏è No commit diff retrieved for ${commitSha}, will use full diff as fallback`\n        );\n      } else {\n        console.log(`‚úÖ Incremental diff retrieved (${prInfo.commitDiff.length} chars)`);\n      }\n    } else {\n      prInfo.isIncremental = false;\n    }\n\n    return prInfo;\n  }\n\n  async fetchPRComments(owner: string, repo: string, prNumber: number) {\n    const { data: comments } = await this.withRetry(() =>\n      this.octokit.rest.issues.listComments({\n        owner,\n        repo,\n        issue_number: prNumber,\n      })\n    );\n\n    return comments.map(comment => ({\n      id: comment.id,\n      author: comment.user?.login || 'unknown',\n      body: comment.body || '',\n      createdAt: comment.created_at,\n      updatedAt: comment.updated_at,\n    }));\n  }\n\n  private async withRetry<T>(operation: () => Promise<T>): Promise<T> {\n    let lastError: Error = new Error('Unknown error');\n\n    for (let attempt = 0; attempt <= this.maxRetries; attempt++) {\n      try {\n        return await operation();\n      } catch (error) {\n        // Preserve the original error object if possible\n        if (error instanceof Error) {\n          lastError = error;\n        } else if (typeof error === 'object' && error !== null) {\n          // For objects like {code: 'ETIMEDOUT', message: 'Network timeout'}\n          const errorObj = error as NetworkError;\n          const message = errorObj.message || errorObj.code || 'Unknown error';\n          lastError = new Error(String(message));\n          // Preserve important properties\n          Object.assign(lastError, error);\n        } else {\n          lastError = new Error(String(error));\n        }\n\n        // Don't retry on the last attempt\n        if (attempt === this.maxRetries) {\n          break;\n        }\n\n        // Check if this is a retryable error\n        if (this.isRetryableError(error)) {\n          const delay = Math.min(1000 * Math.pow(2, attempt), 5000); // Exponential backoff, max 5s\n          await new Promise(resolve => setTimeout(resolve, delay));\n        } else {\n          // Non-retryable error, fail immediately with original error\n          throw error;\n        }\n      }\n    }\n\n    throw lastError;\n  }\n\n  private isRetryableError(error: unknown): boolean {\n    // Retry on network timeouts, connection errors, and temporary server errors\n    const retryableErrors = ['ETIMEDOUT', 'ECONNRESET', 'ECONNREFUSED', 'ENOTFOUND', 'EAI_AGAIN'];\n    const retryableStatuses = [408, 429, 500, 502, 503, 504];\n\n    // Type guard for error objects\n    if (typeof error !== 'object' || error === null) {\n      return false;\n    }\n\n    const err = error as NetworkError & { response?: { status?: number } };\n\n    return (\n      (err.code !== undefined && retryableErrors.includes(err.code)) ||\n      (err.status !== undefined && retryableStatuses.includes(err.status)) ||\n      (err.response?.status !== undefined && retryableStatuses.includes(err.response.status))\n    );\n  }\n}\n","import {\n  PRReviewer,\n  ReviewSummary,\n  ReviewOptions,\n  GroupedCheckResults,\n  CheckResult,\n  ReviewIssue,\n} from './reviewer';\nimport { GitRepositoryAnalyzer, GitRepositoryInfo } from './git-repository-analyzer';\nimport { AnalysisResult } from './output-formatters';\nimport { PRInfo } from './pr-analyzer';\nimport { PRAnalyzer } from './pr-analyzer';\nimport { CheckProviderRegistry } from './providers/check-provider-registry';\nimport { CheckProviderConfig } from './providers/check-provider.interface';\nimport { DependencyResolver, DependencyGraph } from './dependency-resolver';\nimport { FailureConditionEvaluator } from './failure-condition-evaluator';\nimport { FailureConditionResult, CheckConfig } from './types/config';\nimport { GitHubCheckService, CheckRunOptions } from './github-check-service';\nimport { IssueFilter } from './issue-filter';\nimport { logger } from './logger';\nimport Sandbox from '@nyariv/sandboxjs';\nimport { ExecutionJournal, ScopePath, ContextView } from './snapshot-store';\nimport { createSecureSandbox, compileAndRun } from './utils/sandbox';\nimport {\n  projectOutputs as ofProject,\n  decideRouting as ofDecide,\n  computeAllValid as ofAllValid,\n  runOnFinishChildren as ofRunChildren,\n} from './engine/on-finish/orchestrator';\nimport { composeOnFinishContext as ofComposeCtx } from './engine/on-finish/utils';\nimport { VisorConfig, OnFailConfig, OnSuccessConfig, OnFinishConfig } from './types/config';\nimport {\n  createPermissionHelpers,\n  detectLocalMode,\n  resolveAssociationFromEvent,\n} from './utils/author-permissions';\nimport { MemoryStore } from './memory-store';\nimport { emitNdjsonSpanWithEvents, emitNdjsonFallback } from './telemetry/fallback-ndjson';\nimport { generateFooter } from './footer';\nimport { addEvent, withActiveSpan } from './telemetry/trace-helpers';\nimport { addFailIfTriggered } from './telemetry/metrics';\n\ntype ExtendedReviewSummary = ReviewSummary & {\n  output?: unknown;\n  content?: string;\n  isForEach?: boolean;\n  forEachItems?: unknown[];\n  // Preserve per-item results for forEach-dependent checks so children can gate per item\n  forEachItemResults?: ReviewSummary[];\n  // Per-item fatal mask: true means this item is fatal/should gate descendants\n  forEachFatalMask?: boolean[];\n};\n\n/**\n * Statistics for a single check execution\n */\nexport interface CheckExecutionStats {\n  checkName: string;\n  totalRuns: number; // How many times the check executed (1 or forEach iterations)\n  successfulRuns: number;\n  failedRuns: number;\n  skipped: boolean;\n  skipReason?: 'if_condition' | 'fail_fast' | 'dependency_failed';\n  skipCondition?: string; // The actual if condition text\n  totalDuration: number; // Total duration in milliseconds\n  // Provider/self time (excludes time spent running routed children/descendants)\n  providerDurationMs?: number;\n  perIterationDuration?: number[]; // Duration for each iteration (if forEach)\n  issuesFound: number;\n  issuesBySeverity: {\n    critical: number;\n    error: number;\n    warning: number;\n    info: number;\n  };\n  outputsProduced?: number; // Number of outputs for forEach checks\n  errorMessage?: string; // Error message if failed\n  forEachPreview?: string[]; // Preview of forEach items processed (first few)\n}\n\n/**\n * Overall execution statistics for all checks\n */\nexport interface ExecutionStatistics {\n  totalChecksConfigured: number;\n  totalExecutions: number; // Sum of all runs including forEach iterations\n  successfulExecutions: number;\n  failedExecutions: number;\n  skippedChecks: number;\n  totalDuration: number;\n  checks: CheckExecutionStats[];\n}\n\n/**\n * Result of executing checks, including both the grouped results and execution statistics\n */\nexport interface ExecutionResult {\n  results: GroupedCheckResults;\n  statistics: ExecutionStatistics;\n}\n\n/**\n * Filter environment variables to only include safe ones for sandbox evaluation\n */\nfunction getSafeEnvironmentVariables(): Record<string, string> {\n  const { buildSandboxEnv } = require('./utils/env-exposure');\n  return buildSandboxEnv(process.env);\n}\n\nexport interface MockOctokit {\n  rest: {\n    pulls: {\n      get: () => Promise<{ data: Record<string, unknown> }>;\n      listFiles: () => Promise<{ data: Record<string, unknown>[] }>;\n    };\n    issues: {\n      listComments: () => Promise<{ data: Record<string, unknown>[] }>;\n      createComment: () => Promise<{ data: Record<string, unknown> }>;\n    };\n  };\n  request: () => Promise<{ data: Record<string, unknown> }>;\n  graphql: () => Promise<Record<string, unknown>>;\n  log: {\n    debug: (...args: unknown[]) => void;\n    info: (...args: unknown[]) => void;\n    warn: (...args: unknown[]) => void;\n    error: (...args: unknown[]) => void;\n  };\n  hook: {\n    before: (...args: unknown[]) => void;\n    after: (...args: unknown[]) => void;\n    error: (...args: unknown[]) => void;\n    wrap: (...args: unknown[]) => void;\n  };\n  auth: () => Promise<{ token: string }>;\n}\n\nexport interface CheckExecutionOptions {\n  checks: string[];\n  workingDirectory?: string;\n  showDetails?: boolean;\n  timeout?: number;\n  maxParallelism?: number; // Maximum number of checks to run in parallel (default: 3)\n  failFast?: boolean; // Stop execution when any check fails (default: false)\n  outputFormat?: string;\n  config?: import('./types/config').VisorConfig;\n  debug?: boolean; // Enable debug mode to collect AI execution details\n  // Tag filter for selective check execution\n  tagFilter?: import('./types/config').TagFilter;\n  // Webhook context for passing webhook data to http_input providers\n  webhookContext?: {\n    webhookData: Map<string, unknown>;\n  };\n  // GitHub Check integration options\n  githubChecks?: {\n    enabled: boolean;\n    octokit?: import('@octokit/rest').Octokit;\n    owner?: string;\n    repo?: string;\n    headSha?: string;\n    prNumber?: number;\n  };\n}\n\nexport class CheckExecutionEngine {\n  private gitAnalyzer: GitRepositoryAnalyzer;\n  private mockOctokit: MockOctokit;\n  private reviewer: PRReviewer;\n  private providerRegistry: CheckProviderRegistry;\n  private failureEvaluator: FailureConditionEvaluator;\n  private githubCheckService?: GitHubCheckService;\n  private checkRunMap?: Map<string, { id: number; url: string }>;\n  private githubContext?: { owner: string; repo: string };\n  private workingDirectory: string;\n  private config?: import('./types/config').VisorConfig;\n  private webhookContext?: { webhookData: Map<string, unknown> };\n  private routingSandbox?: Sandbox;\n  private executionStats: Map<string, CheckExecutionStats> = new Map();\n  // Track history of all outputs for each check (useful for loops and goto)\n  private outputHistory: Map<string, unknown[]> = new Map();\n  // Track on_finish loop counts per forEach parent during a single execution run\n  private onFinishLoopCounts: Map<string, number> = new Map();\n  // Track how many times a forEach parent check has produced an array during this run (\"waves\")\n  private forEachWaveCounts: Map<string, number> = new Map();\n  // One-shot guards for post on_finish scheduling to avoid duplicate replies when\n  // multiple signals (aggregator, memory, history) agree. Keyed by session + parent check.\n  private postOnFinishGuards: Set<string> = new Set();\n  // Per-run execution cap counters (guard infinite loops). Keyed by check + scope.\n  private runCounters: Map<string, number> = new Map();\n  // Snapshot+Scope journal (Phase 0: commit only, no behavior changes yet)\n  private journal: ExecutionJournal = new ExecutionJournal();\n  private sessionId: string = `sess-${Date.now().toString(36)}-${Math.random()\n    .toString(36)\n    .slice(2, 8)}`;\n  // Dedup forward-run targets within a single grouped run (stage/event).\n  // Keyed by `${event}:${target}`.\n  private forwardRunGuards: Set<string> = new Set();\n  // Guard dependents scheduled via forward-run to avoid races with level tasks\n  // Store per-target scopes to support forEach item-specific routing (JSON-encoded ScopePath)\n  private forwardDependentsScheduled: Map<string, Set<string>> = new Map();\n  private forwardEventOverrides: Map<string, import('./types/config').EventTrigger> = new Map();\n  // Forward-run planning hints per routed target\n  // - includeDependents: whether to include DAG dependents for the next wave\n  // - excludeForEachDependents: when true, filter out dependents that are forEach parents\n  private forwardIncludeDependents: Map<string, boolean> = new Map();\n  private forwardExcludeForEachDependents: Map<string, boolean> = new Map();\n  // Marker for grouped wave rescheduling when on_fail forward-run occurred\n  private onFailForwardRunSeen: boolean = false;\n  // Marker for grouped wave rescheduling when on_finish routing occurred\n  private onFinishForwardRunSeen: boolean = false;\n  // Track per-grouped-run scheduling of specific steps we want to allow only once.\n  // Currently used to ensure 'validate-fact' is scheduled at most once per stage.\n  private oncePerRunScheduleGuards: Set<string> = new Set();\n  // Suppress on_success.goto for checks that are re-run only to satisfy\n  // dependency requirements in a forward-run planned wave\n  private gotoSuppressedChecks: Set<string> = new Set();\n  // Event override to simulate alternate event (used during routing goto)\n  private routingEventOverride?: import('./types/config').EventTrigger;\n  // Execution context for providers (CLI message, hooks, etc.)\n  private executionContext?: import('./providers/check-provider.interface').ExecutionContext;\n  // Cached GitHub context for context elevation when running in Actions\n  private actionContext?: {\n    owner: string;\n    repo: string;\n    octokit?: import('@octokit/rest').Octokit;\n  };\n  // Engine execution mode (legacy or state-machine)\n  private engineMode: import('./types/engine').EngineMode;\n\n  constructor(workingDirectory?: string, octokit?: import('@octokit/rest').Octokit, engineMode?: import('./types/engine').EngineMode) {\n    this.workingDirectory = workingDirectory || process.cwd();\n    this.gitAnalyzer = new GitRepositoryAnalyzer(this.workingDirectory);\n    this.providerRegistry = CheckProviderRegistry.getInstance();\n    this.failureEvaluator = new FailureConditionEvaluator();\n    this.engineMode = engineMode || 'legacy';\n\n    // If authenticated octokit is provided, cache it for provider use\n    if (octokit) {\n      const repoEnv = process.env.GITHUB_REPOSITORY || '';\n      const [owner, repo] = repoEnv.split('/') as [string, string];\n      if (owner && repo) {\n        this.actionContext = { owner, repo, octokit };\n      }\n    }\n\n    // Create a mock Octokit instance for local analysis\n    // This allows us to reuse the existing PRReviewer logic without network calls\n    this.mockOctokit = this.createMockOctokit();\n    // Prefer the provided authenticated/recording Octokit (from test runner or Actions)\n    // so that comment create/update operations are visible to recorders and assertions.\n    const reviewerOctokit =\n      (octokit as unknown as import('@octokit/rest').Octokit) ||\n      (this.mockOctokit as unknown as import('@octokit/rest').Octokit);\n    this.reviewer = new PRReviewer(reviewerOctokit);\n  }\n\n  private sessionUUID(): string {\n    return this.sessionId;\n  }\n\n  /**\n   * Reset per-run guard and statistics state. Callers that orchestrate grouped\n   * executions (e.g., the YAML test runner) can invoke this to ensure clean\n   * stage-local accounting without introducing test-specific branches in the\n   * core engine.\n   */\n  public resetPerRunState(): void {\n    try {\n      this.forwardRunGuards.clear();\n    } catch {}\n    try {\n      this.oncePerRunScheduleGuards.clear();\n    } catch {}\n    try {\n      this.onFinishLoopCounts.clear();\n      this.forEachWaveCounts.clear();\n    } catch {}\n    try {\n      // Fully reset stage-scoped state so flows don't leak across stages.\n      this['executionStats'].clear();\n      // Clear outputs history at the start of each grouped run to ensure\n      // per-stage coverage is isolated in flows. Intra-stage waves still\n      // have access to history because it accumulates during the run.\n      this.outputHistory.clear();\n      this.postOnFinishGuards.clear();\n      this.forwardDependentsScheduled.clear();\n      this.forwardIncludeDependents.clear();\n      this.gotoSuppressedChecks.clear();\n      this.forwardExcludeForEachDependents.clear();\n      this.runCounters.clear();\n      this.routingEventOverride = undefined;\n      // Start a fresh journal for snapshot-based dependency views\n      this.journal = new (require('./snapshot-store').ExecutionJournal)();\n    } catch {}\n  }\n\n  /** Build a stable key for counting executions per check and per scope (forEach items separated). */\n  private buildRunKey(checkId: string, scope?: ScopePath): string {\n    if (!scope || scope.length === 0) return checkId;\n    try {\n      const parts = scope.map(s => `${s.check}:${s.index}`);\n      return `${checkId}@${parts.join('/')}`;\n    } catch {\n      return checkId;\n    }\n  }\n\n  /** Resolve effective max runs for a check (step override > global default). */\n  private resolveMaxRuns(config: VisorConfig, checkId: string): number {\n    try {\n      const steps = (config.checks || (config as any).steps || {}) as Record<\n        string,\n        import('./types/config').CheckConfig\n      >;\n      const step = steps[checkId];\n      const perStep = (step as any)?.max_runs;\n      if (typeof perStep === 'number') return perStep;\n      // Default: cap forEach parents to 1 execution per grouped run unless overridden\n      if (step && step.forEach === true) return 1;\n    } catch {}\n    const global = (config.limits && (config.limits as any).max_runs_per_check) ?? 50;\n    return typeof global === 'number' && global > 0 ? Math.floor(global) : 50;\n  }\n\n  private commitJournal(\n    checkId: string,\n    result: ExtendedReviewSummary,\n    event?: import('./types/config').EventTrigger,\n    scopeOverride?: ScopePath\n  ): void {\n    try {\n      const scope: ScopePath = scopeOverride || [];\n      this.journal.commitEntry({\n        sessionId: this.sessionUUID(),\n        scope,\n        checkId,\n        event,\n        result,\n      });\n    } catch {\n      // best effort; never throw\n    }\n  }\n\n  /** Build dependencyResults from a snapshot of all committed results, optionally overlaying provided results. */\n  private buildSnapshotDependencyResults(\n    scope: ScopePath,\n    overlay: Map<string, ReviewSummary> | undefined,\n    event: import('./types/config').EventTrigger | undefined\n  ): Map<string, ReviewSummary> {\n    const snap = this.journal.beginSnapshot();\n    const view = new ContextView(this.journal, this.sessionUUID(), snap, scope, event);\n    const visible = new Map<string, ReviewSummary>();\n    try {\n      const entries = this.journal.readVisible(this.sessionUUID(), snap, event);\n      const ids = Array.from(new Set(entries.map(e => e.checkId)));\n      for (const id of ids) {\n        const v = view.get(id);\n        if (v) visible.set(id, v);\n        const raw = view.getRaw(id);\n        if (raw) visible.set(`${id}-raw`, raw);\n      }\n      // Overlay any provided results (e.g., per-item context) on top.\n      // Root-cause hardening: ignore non-string keys and log once.\n      if (overlay) {\n        for (const [k, v] of overlay.entries()) {\n          if (typeof k === 'string' && k) {\n            visible.set(k, v);\n          } else {\n            try {\n              require('./logger').logger.warn(\n                `sanitize: dropping non-string overlay key type=${typeof k}`\n              );\n            } catch {}\n          }\n        }\n      }\n    } catch {}\n    return visible;\n  }\n\n  /** Drop any non-string keys from a results-like map (root-cause guard). */\n  private sanitizeResultMapKeys(\n    m: Map<unknown, ReviewSummary> | undefined\n  ): Map<string, ReviewSummary> {\n    const out = new Map<string, ReviewSummary>();\n    if (!m) return out;\n    for (const [k, v] of m.entries()) {\n      if (typeof k === 'string' && k) out.set(k, v);\n      else {\n        try {\n          require('./logger').logger.warn(\n            `sanitize: dropping non-string results key type=${typeof k}`\n          );\n        } catch {}\n      }\n    }\n    return out;\n  }\n\n  /**\n   * Enrich event context with authenticated octokit instance\n   * @param eventContext - The event context to enrich\n   * @returns Enriched event context with octokit if available\n   */\n  private enrichEventContext(eventContext?: Record<string, unknown>): Record<string, unknown> {\n    const baseContext = eventContext || {};\n    const injected = this.actionContext?.octokit || (baseContext as any).octokit;\n    if (injected) {\n      return { ...baseContext, octokit: injected };\n    }\n    return baseContext;\n  }\n\n  /**\n   * Schedule a forward-run starting from `target` and continuing through all\n   * transitive dependents that declare a dependency (direct or indirect) on\n   * `target`. Execution honors optional `gotoEvent` by filtering dependents to\n   * only those steps whose `on` includes that event. The `target` itself is\n   * always executed first regardless of event filtering.\n   *\n   * This helper is used for goto across all origins (on_success, on_fail,\n   * on_finish) to ensure consistent semantics and avoid duplicating logic.\n   */\n  private async scheduleForwardRun(\n    target: string,\n    opts: {\n      origin: 'on_success' | 'on_fail' | 'on_finish' | 'inline';\n      gotoEvent?: import('./types/config').EventTrigger;\n      config: VisorConfig;\n      dependencyGraph: DependencyGraph;\n      prInfo: PRInfo;\n      resultsMap: Map<string, ReviewSummary>;\n      debug: boolean;\n      // When executing inside a forEach item, pass the scope for that item\n      foreachScope?: ScopePath;\n      // If not in a forEach item, but the source step was a map, we may need the\n      // source identity and items to produce per-item scopes.\n      sourceCheckName?: string;\n      sourceCheckConfig?: CheckConfig;\n      sourceOutputForItems?: unknown;\n    }\n  ): Promise<void> {\n    const {\n      origin,\n      gotoEvent,\n      config,\n      dependencyGraph,\n      prInfo,\n      resultsMap,\n      debug,\n      foreachScope,\n      sourceCheckName,\n      sourceCheckConfig,\n      sourceOutputForItems,\n    } = opts;\n\n    const cfgChecks = (config?.checks || {}) as Record<\n      string,\n      import('./types/config').CheckConfig\n    >;\n    if (!cfgChecks[target]) return;\n\n    // Build forward closure (target + transitive dependents of target)\n    const forwardSet = new Set<string>([target]);\n    const dependsOn = (name: string, root: string): boolean => {\n      const seen = new Set<string>();\n      const dfs = (n: string): boolean => {\n        if (seen.has(n)) return false;\n        seen.add(n);\n        const deps = cfgChecks[n]?.depends_on || [];\n        if (deps.includes(root)) return true;\n        return deps.some(d => dfs(d));\n      };\n      return dfs(name);\n    };\n    const ev = gotoEvent || prInfo.eventType || 'manual';\n    for (const name of Object.keys(cfgChecks)) {\n      if (name === target) continue;\n      const onArr = cfgChecks[name]?.on as any;\n      const eventMatches = !onArr || (Array.isArray(onArr) && onArr.includes(ev));\n      if (!eventMatches) continue;\n      if (dependsOn(name, target)) forwardSet.add(name);\n    }\n\n    // Topologically order the subset to run target before dependents respecting depends_on\n    const order: string[] = [];\n    const inSet = (n: string) => forwardSet.has(n);\n    const tempMarks = new Set<string>();\n    const permMarks = new Set<string>();\n    const stack: string[] = [];\n    const visit = (n: string) => {\n      if (permMarks.has(n)) return;\n      if (tempMarks.has(n)) {\n        const idx = stack.indexOf(n);\n        const cyclePath = idx >= 0 ? [...stack.slice(idx), n] : [n];\n        throw new Error(\n          `Cycle detected in forward-run dependency subset: ${cyclePath.join(' -> ')}`\n        );\n      }\n      tempMarks.add(n);\n      stack.push(n);\n      const deps = (cfgChecks[n]?.depends_on || []).filter(inSet);\n      for (const d of deps) visit(d);\n      stack.pop();\n      tempMarks.delete(n);\n      permMarks.add(n);\n      order.push(n);\n    };\n    for (const n of forwardSet) visit(n);\n\n    // Revert dependent auto-forwarding for correction cycles:\n    // - For origin on_fail/on_finish we only schedule the target and let the DAG\n    //   naturally execute dependents in the next wave. This avoids duplicate\n    //   inline runs of dependents (especially forEach dependents) and restores\n    //   stable execution counts expected by tests.\n    if (origin === 'on_fail' || origin === 'on_finish') {\n      order.splice(0, order.length, target);\n    }\n\n    const prevEventOverride = this.routingEventOverride;\n    // Ensure we only execute the target once per grouped run for a given event\n    const evKey = gotoEvent || prInfo.eventType || 'manual';\n    const guardKey = `${String(evKey)}:${String(target)}`;\n    const runTargetOnce = async (\n      scopeForRun: ScopePath,\n      guard: boolean\n    ): Promise<ReviewSummary | undefined> => {\n      // When guard=true we dedupe within a grouped run; when false we allow\n      // multiple re-executions (e.g., on_finish correction waves).\n      if (guard) {\n        if (this.forwardRunGuards.has(guardKey)) {\n          // Allow re-run if the last recorded result for target was fatal and the\n          // target did not opt into continue_on_failure (we need another attempt).\n          try {\n            const prior = resultsMap.get(target);\n            let hadFatal = prior && Array.isArray(prior.issues) && this.hasFatal(prior.issues);\n            const tcfgCont = (cfgChecks[target] as any)?.continue_on_failure === true;\n            if (tcfgCont) hadFatal = false;\n            if (!hadFatal) return undefined;\n          } catch {\n            return undefined;\n          }\n        }\n        this.forwardRunGuards.add(guardKey);\n      }\n      const res = await this.runNamedCheck(target, scopeForRun, {\n        origin,\n        config,\n        dependencyGraph,\n        prInfo,\n        resultsMap,\n        debug,\n        eventOverride: gotoEvent,\n      });\n      // Ensure resultsMap reflects the freshest result for gating\n      try {\n        resultsMap.set(target, res);\n      } catch {}\n      // Mark target as forward-scheduled AFTER inline execution so grouped\n      // runner can skip duplicates in subsequent waves without blocking inline.\n      try {\n        this.addForwardTarget(target, scopeForRun);\n        if (gotoEvent) this.forwardEventOverrides.set(target, gotoEvent);\n      } catch {}\n      return res;\n    };\n\n    // Decide whether to dedupe target in this grouped run.\n    // For on_finish correction waves we allow re-execution of the target.\n    // Additionally, respect a 'repeatable' tag on the target step which\n    // explicitly opts the step into re-execution within the same event/wave\n    // (useful for chat-style loops driven by fail_if + on_fail/on_success).\n    // Allow re-running the target within the same grouped run when routing originates from on_fail.\n    // This enables explicit correction loops without any special tags.\n    const guardTargetOnce = origin !== 'on_finish' && origin !== 'on_fail';\n    try {\n      if (origin === 'on_fail') {\n        (this as any).onFailForwardRunSeen = true;\n        if (debug)\n          (config?.output?.pr_comment ? console.error : console.log)(\n            'üîÅ Debug: on_fail forward-run seen; flag set'\n          );\n      }\n    } catch {}\n\n    if (gotoEvent) this.routingEventOverride = gotoEvent;\n\n    // Unified forward-run semantics header\n\n    // Do not execute target inline for on_fail-originated routing.\n    // Mark that a correction wave is needed; enqueue ONLY the target and allow\n    // the DAG to execute dependents in the next wave. This preserves\n    // dependency gating semantics (e.g., confirm-interpret ‚Üí run-commands).\n    if (origin === 'on_fail') {\n      try {\n        // Only mark the target for forward scheduling. Let the DAG naturally\n        // re-run transitive dependents in the next wave to preserve dependency\n        // gating semantics.\n        this.addForwardTarget(target, foreachScope);\n        this.forwardIncludeDependents.set(target, true);\n        const dependentsOnly = order.filter(n => n !== target);\n        const fwd = Array.from(forwardSet || []).join(', ');\n        const deps = dependentsOnly.join(', ');\n        (config?.output?.pr_comment ? console.error : console.log)(\n          `üîß Debug: on_fail forward-set=[${fwd}] dependents=[${deps}]`\n        );\n      } catch {}\n      (this as any).onFailForwardRunSeen = true;\n      return; // defer to next wave\n    }\n    // on_finish: schedule target for the next wave and return.\n    if (origin === 'on_finish') {\n      try {\n        this.addForwardTarget(target, foreachScope);\n        if (gotoEvent) this.forwardEventOverrides.set(target, gotoEvent);\n        // For on_finish correction waves, include non-forEach dependents only\n        // so lightweight actions (e.g., label application) can run again\n        // while heavy per-item validators are excluded.\n        this.forwardIncludeDependents.set(target, true);\n        this.forwardExcludeForEachDependents.set(target, true);\n      } catch {}\n      (this as any).onFinishForwardRunSeen = true;\n      return; // defer to next wave\n    }\n    // on_success: if dependencies of the routed target are already available,\n    // execute it inline now and do NOT schedule a new wave. Otherwise, schedule\n    // the target for the next wave and return.\n    if (origin === 'on_success') {\n      try {\n        this.addForwardTarget(target, foreachScope);\n      } catch {}\n      if (gotoEvent) this.forwardEventOverrides.set(target, gotoEvent);\n      try {\n        (this as any).onSuccessForwardRunSeen = true;\n      } catch {}\n      return;\n    }\n    try {\n      // Determine mapping mode for the target step\n      const tcfg = cfgChecks[target];\n      const mode =\n        tcfg?.fanout === 'map' ? 'map' : tcfg?.reduce ? 'reduce' : tcfg?.fanout || 'default';\n\n      const items = foreachScope\n        ? []\n        : sourceCheckConfig?.forEach && Array.isArray(sourceOutputForItems)\n          ? (sourceOutputForItems as unknown[])\n          : [];\n\n      let lastTargetHadFatal: boolean | undefined = undefined;\n      const runChainOnce = async (scopeForRun: ScopePath) => {\n        const tResMaybe = await runTargetOnce(scopeForRun, /*guard*/ guardTargetOnce);\n        const tRes = tResMaybe || resultsMap.get(target);\n        // If the target is a forEach parent, its dependents are executed per-item\n        // inside executeCheckInline. Avoid scheduling them again here to prevent\n        // an extra aggregated run (e.g., validate-fact √ó1 in addition to per-item runs).\n        const tcfgNow = cfgChecks[target];\n        const targetIsForEachParent = !!tcfgNow?.forEach;\n        if (targetIsForEachParent) return;\n        // If target failed, do not run any dependents in this forward-run wave\n        try {\n          if (debug) {\n            const ids = Array.isArray(tRes?.issues)\n              ? (tRes!.issues as any[]).map(i => i.ruleId).join(',')\n              : 'none';\n            (config?.output?.pr_comment ? console.error : console.log)(\n              `üîß Debug: forward-run: target '${target}' issues=[${ids}]`\n            );\n          }\n          // Treat skipped targets as non-executed for the purposes of forward-run.\n          // If a target was skipped (e.g., event mismatch), do NOT schedule dependents\n          // because prerequisites/side-effects didn't run.\n          const wasSkipped = Array.isArray(tRes?.issues)\n            ? (tRes!.issues as any[]).some(i => (i.ruleId || '').endsWith('/__skipped'))\n            : false;\n          if (wasSkipped) {\n            if (debug)\n              (config?.output?.pr_comment ? console.error : console.log)(\n                `üîß Debug: forward-run: target '${target}' skipped ‚Äî not running dependents`\n              );\n            return;\n          }\n\n          let hadFatal = tRes && Array.isArray(tRes.issues) && this.hasFatal(tRes.issues);\n          lastTargetHadFatal = hadFatal;\n          // Respect continue_on_failure on the target: allow dependents even when fatal\n          try {\n            const tcfgCont = (cfgChecks[target] as any)?.continue_on_failure === true;\n            if (tcfgCont) hadFatal = false;\n          } catch {}\n          if (hadFatal) {\n            if (debug)\n              (config?.output?.pr_comment ? console.error : console.log)(\n                `üîß Debug: forward-run: target '${target}' failed ‚Äî skipping dependents`\n              );\n            return;\n          }\n        } catch {}\n        // Do not inline-run dependents for forward-run; DAG handles subsequent steps in next wave\n        try {\n          /* intentionally no-op */\n        } catch {}\n      };\n\n      if (foreachScope && foreachScope.length > 0) {\n        await runChainOnce(foreachScope);\n      } else if (mode === 'map' && items.length > 0 && sourceCheckName) {\n        for (let i = 0; i < items.length; i++) {\n          const itemScope: ScopePath = [{ check: sourceCheckName, index: i }];\n          await runChainOnce(itemScope);\n        }\n      } else {\n        await runChainOnce([]);\n      }\n\n      // For on_fail-originated forward runs we already early-returned above.\n\n      // In test/grouped mode, rely on the DAG and per-level execution; avoid\n      // following static on_success.goto chains to prevent duplicate executions\n      // of steps that are already scheduled by the plan.\n      // Static goto chaining below applies regardless of origin; tests rely on wave scheduling.\n\n      // Follow explicit on_success.goto edges from the target, if present,\n      // to naturally support anchor-style chains (e.g., refine ‚Üí write ‚Üí validate ‚Üí test).\n      // Only follow when the target succeeded (no fatal issues post fail_if evaluation).\n      // We intentionally do not evaluate goto_js here to keep this deterministic\n      // in routing, but we do honor static goto + goto_event.\n      // Follow static goto chains with configurable hop budget and cycle detection\n      const maxHops = config?.routing?.max_loops ?? 10;\n      let hopCount = 0;\n      const visited = new Set<string>();\n      // Success check: if target produced fatal issues, skip static goto chaining\n      try {\n        const dbg = (msg: string) =>\n          (config?.output?.pr_comment ? console.error : console.log)(msg);\n        // Prefer the immediate result from runChainOnce if available\n        let hadFatal = typeof lastTargetHadFatal === 'boolean' ? lastTargetHadFatal : false;\n        if (typeof lastTargetHadFatal !== 'boolean') {\n          const tRes = resultsMap.get(target);\n          hadFatal = !!(tRes && Array.isArray(tRes.issues) && this.hasFatal(tRes.issues));\n        }\n        if (hadFatal) {\n          if (debug)\n            dbg(\n              `üîß Debug: forward-run: skipping on_success.goto chain for '${target}' due to fatal issues`\n            );\n          return; // do not follow chain from a failed target\n        }\n      } catch {}\n\n      let current: string | undefined = (\n        cfgChecks[target]?.on_success as OnSuccessConfig | undefined\n      )?.goto;\n      while (current && hopCount < maxHops) {\n        if (visited.has(current)) {\n          try {\n            logger.warn(\n              `‚ö†Ô∏è forward-run: detected goto cycle at '${current}' after ${hopCount} hop(s); aborting chain`\n            );\n          } catch {}\n\n          break;\n        }\n        visited.add(current);\n        const nextOnSuccess = (cfgChecks[current]?.on_success as OnSuccessConfig | undefined) || {};\n        const nextEvent = nextOnSuccess.goto_event || gotoEvent;\n        await this.scheduleForwardRun(current, {\n          origin: 'on_success',\n          gotoEvent: nextEvent,\n          config,\n          dependencyGraph,\n          prInfo,\n          resultsMap,\n          debug,\n          foreachScope,\n          sourceCheckName,\n          sourceCheckConfig,\n          sourceOutputForItems,\n        });\n        hopCount++;\n        // advance chain if there is a further goto from the just-executed step\n        current = (cfgChecks[current]?.on_success as OnSuccessConfig | undefined)?.goto;\n      }\n      if (hopCount >= maxHops && current) {\n        try {\n          logger.warn(\n            `‚ö†Ô∏è forward-run: hop budget exceeded (max_loops=${maxHops}); last unresolved goto='${current}'`\n          );\n        } catch {}\n      }\n    } finally {\n      this.routingEventOverride = prevEventOverride;\n    }\n  }\n\n  /**\n   * Set execution context for providers (CLI message, hooks, etc.)\n   * This allows passing state without using static properties\n   */\n  setExecutionContext(\n    context: import('./providers/check-provider.interface').ExecutionContext\n  ): void {\n    this.executionContext = context;\n  }\n\n  /**\n   * Get execution context (used by state machine to propagate hooks)\n   */\n  protected getExecutionContext(): import('./providers/check-provider.interface').ExecutionContext | undefined {\n    return this.executionContext;\n  }\n\n  /**\n   * Lazily create a secure sandbox for routing JS (goto_js, run_js)\n   */\n  private getRoutingSandbox(): Sandbox {\n    if (this.routingSandbox) return this.routingSandbox;\n    this.routingSandbox = createSecureSandbox();\n    return this.routingSandbox;\n  }\n\n  // Evaluate goto target from optional goto_js or static goto using a minimal scope\n  private async evaluateGotoTarget(\n    goto_js: string | undefined,\n    gotoStatic: string | undefined,\n    scope: { step: any; outputs: any; output: any; event: any },\n    debug?: boolean,\n    log?: (msg: string) => void\n  ): Promise<string | null> {\n    if (goto_js) {\n      try {\n        const sandbox = this.getRoutingSandbox();\n        const code = `const step=scope.step; const outputs=scope.outputs; const output=scope.output; const event=scope.event; ${goto_js}`;\n        const exec = sandbox.compile(code);\n        const res = exec({ scope }).run();\n        if (debug) log && log(`üîß Debug: goto_js evaluated ‚Üí ${this.redact(res)}`);\n        return typeof res === 'string' && res ? String(res) : null;\n      } catch (e) {\n        if (debug)\n          log &&\n            log(\n              `‚ö†Ô∏è Debug: goto_js evaluation failed: ${e instanceof Error ? e.message : String(e)}`\n            );\n        // fall through to static\n      }\n    }\n    return gotoStatic ? String(gotoStatic) : null;\n  }\n\n  // Schedule routing to a specific target using scheduleForwardRun with the given origin\n  private async scheduleGoto(\n    origin: 'on_success' | 'on_fail' | 'on_finish',\n    target: string,\n    gotoEvent: import('./types/config').EventTrigger | undefined,\n    sourceCheckName: string,\n    sourceCheckConfig: import('./types/config').CheckConfig,\n    foreachScope: ScopePath | undefined,\n    config: VisorConfig,\n    dependencyGraph: DependencyGraph,\n    prInfo: PRInfo,\n    resultsMap: Map<string, ReviewSummary>,\n    debug?: boolean\n  ): Promise<void> {\n    await this.scheduleForwardRun(target, {\n      origin,\n      gotoEvent,\n      config,\n      dependencyGraph,\n      prInfo,\n      resultsMap,\n      debug: debug || false,\n      foreachScope: foreachScope || [],\n      sourceCheckName,\n      sourceCheckConfig,\n    });\n  }\n\n  private redact(str: unknown, limit = 200): string {\n    try {\n      const s = typeof str === 'string' ? str : JSON.stringify(str);\n      return s.length > limit ? s.slice(0, limit) + '‚Ä¶' : s;\n    } catch {\n      return String(str).slice(0, limit);\n    }\n  }\n\n  private async sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  private deterministicJitter(baseMs: number, seedStr: string): number {\n    let h = 2166136261;\n    for (let i = 0; i < seedStr.length; i++) h = (h ^ seedStr.charCodeAt(i)) * 16777619;\n    const frac = ((h >>> 0) % 1000) / 1000; // 0..1\n    return Math.floor(baseMs * 0.15 * frac); // up to 15% jitter\n  }\n\n  /** Add a forward-run target with an optional item scope (forEach). */\n  private addForwardTarget(target: string, scope?: ScopePath): void {\n    try {\n      const key = JSON.stringify(scope && scope.length > 0 ? scope : []);\n      let set = this.forwardDependentsScheduled.get(target);\n      if (!set) {\n        set = new Set<string>();\n        this.forwardDependentsScheduled.set(target, set);\n      }\n      set.add(key);\n    } catch {}\n  }\n\n  // === on_finish helpers (extracted to reduce handleOnFinishHooks complexity) ===\n  private composeOnFinishContext(\n    checkName: string,\n    checkConfig: import('./types/config').CheckConfig,\n    outputsForContext: Record<string, unknown>,\n    outputsHistoryForContext: Record<string, unknown[]>,\n    forEachStats: any,\n    prInfo: PRInfo\n  ): {\n    step: { id: string; tags: string[]; group?: string };\n    attempt: number;\n    loop: number;\n    outputs: Record<string, unknown>;\n    outputs_history: Record<string, unknown[]>;\n    outputs_raw: Record<string, unknown>;\n    forEach: any;\n    memory: {\n      get: (key: string, ns?: string) => unknown;\n      has: (key: string, ns?: string) => boolean;\n      list: (ns?: string) => string[];\n      getAll: (ns?: string) => Record<string, unknown>;\n      set: (key: string, value: unknown, ns?: string) => void;\n      increment: (key: string, amount: number, ns?: string) => number;\n    };\n    pr: { number: number; title: string; author: string; branch: string; base: string };\n    files: PRInfo['files'];\n    env: Record<string, string>;\n    event: { name: string };\n  } {\n    const memoryStore = MemoryStore.getInstance(this.config?.memory);\n    const memoryHelpers = {\n      get: (key: string, ns?: string) => memoryStore.get(key, ns),\n      has: (key: string, ns?: string) => memoryStore.has(key, ns),\n      list: (ns?: string) => memoryStore.list(ns),\n      getAll: (ns?: string) => {\n        const keys = memoryStore.list(ns);\n        const result: Record<string, unknown> = {};\n        for (const key of keys) result[key] = memoryStore.get(key, ns);\n        return result;\n      },\n      set: (key: string, value: unknown, ns?: string) => {\n        const nsName = ns || memoryStore.getDefaultNamespace();\n        if (!memoryStore['data'].has(nsName)) memoryStore['data'].set(nsName, new Map());\n        memoryStore['data'].get(nsName)!.set(key, value);\n      },\n      increment: (key: string, amount: number, ns?: string) => {\n        const current = memoryStore.get(key, ns);\n        const numCurrent = typeof current === 'number' ? current : 0;\n        const newValue = numCurrent + amount;\n        const nsName = ns || memoryStore.getDefaultNamespace();\n        if (!memoryStore['data'].has(nsName)) memoryStore['data'].set(nsName, new Map());\n        memoryStore['data'].get(nsName)!.set(key, newValue);\n        return newValue;\n      },\n    };\n    const outputsRawForContext: Record<string, unknown> = {};\n    for (const [name, val] of Object.entries(outputsForContext)) {\n      if (name === 'history') continue;\n      outputsRawForContext[name] = val;\n    }\n    const outputsMergedForContext: Record<string, unknown> = {\n      ...outputsForContext,\n      history: outputsHistoryForContext,\n    };\n    return {\n      step: { id: checkName, tags: checkConfig.tags || [], group: checkConfig.group },\n      attempt: 1,\n      loop: 0,\n      outputs: outputsMergedForContext,\n      outputs_history: outputsHistoryForContext,\n      outputs_raw: outputsRawForContext,\n      forEach: forEachStats,\n      memory: memoryHelpers,\n      pr: {\n        number: prInfo.number,\n        title: prInfo.title,\n        author: prInfo.author,\n        branch: prInfo.head,\n        base: prInfo.base,\n      },\n      files: prInfo.files,\n      env: getSafeEnvironmentVariables(),\n      event: { name: prInfo.eventType || 'manual' },\n    };\n  }\n\n  private evaluateOnFinishGoto(\n    checkName: string,\n    onFinish: NonNullable<import('./types/config').CheckConfig['on_finish']>,\n    onFinishContext: any,\n    debug: boolean,\n    log: (msg: string) => void\n  ): string | null {\n    let gotoTarget: string | null = null;\n    if (onFinish.goto_js) {\n      logger.info(`‚ñ∂ on_finish.goto_js: evaluating for \"${checkName}\"`);\n      try {\n        const sandbox = this.getRoutingSandbox();\n        const scope = onFinishContext;\n        const code = `\n          const step = scope.step; const attempt = scope.attempt; const loop = scope.loop; const outputs = scope.outputs; const outputs_history = scope.outputs_history; const outputs_raw = scope.outputs_raw; const forEach = scope.forEach; const memory = scope.memory; const pr = scope.pr; const files = scope.files; const env = scope.env; const event = scope.event; const log = (...a)=> console.log('üîç Debug:',...a);\n          const __fn = () => {\\n${onFinish.goto_js}\\n};\n          const __res = __fn();\n          return (typeof __res === 'string' && __res) ? __res : null;\n        `;\n        const exec = sandbox.compile(code);\n        const result = exec({ scope }).run();\n        gotoTarget = typeof result === 'string' && result ? result : null;\n        if (debug) log(`üîß Debug: on_finish.goto_js evaluated ‚Üí ${this.redact(gotoTarget)}`);\n        logger.info(\n          `‚úì on_finish.goto_js: evaluated to '${gotoTarget || 'null'}' for \"${checkName}\"`\n        );\n      } catch (error) {\n        const errorMsg = error instanceof Error ? error.message : String(error);\n        logger.warn(`‚ö†Ô∏è on_finish.goto_js: evaluation failed for \"${checkName}\": ${errorMsg}`);\n        if (error instanceof Error && error.stack) logger.debug(`Stack trace: ${error.stack}`);\n        if (onFinish.goto) {\n          logger.info(`  ‚ö† Falling back to static goto: '${onFinish.goto}'`);\n          gotoTarget = onFinish.goto;\n        }\n      }\n    } else if (onFinish.goto) {\n      gotoTarget = onFinish.goto;\n      logger.info(`‚ñ∂ on_finish.goto: routing to '${gotoTarget}' for \"${checkName}\"`);\n    }\n    return gotoTarget;\n  }\n\n  private computeBackoffDelay(\n    attempt: number,\n    mode: 'fixed' | 'exponential',\n    baseMs: number,\n    seed: string\n  ): number {\n    const jitter = this.deterministicJitter(baseMs, seed);\n    if (mode === 'exponential') {\n      return baseMs * Math.pow(2, Math.max(0, attempt - 1)) + jitter;\n    }\n    return baseMs + jitter;\n  }\n\n  /**\n   * Execute a single named check inline (used by routing logic and on_finish)\n   * This is extracted from executeWithRouting to be reusable\n   */\n  private async executeCheckInline(\n    checkId: string,\n    event: import('./types/config').EventTrigger,\n    context: {\n      config: VisorConfig;\n      dependencyGraph: DependencyGraph;\n      prInfo: PRInfo;\n      resultsMap: Map<string, ReviewSummary>;\n      dependencyResults: Map<string, ReviewSummary>;\n      sessionInfo?: { parentSessionId?: string; reuseSession?: boolean };\n      debug: boolean;\n      eventOverride?: import('./types/config').EventTrigger;\n      scope?: ScopePath;\n      origin?: 'on_finish' | 'on_success' | 'on_fail' | 'foreach' | 'initial' | 'inline';\n    }\n  ): Promise<ReviewSummary> {\n    const {\n      config,\n      prInfo,\n      resultsMap,\n      dependencyResults,\n      sessionInfo,\n      debug,\n      eventOverride,\n      scope,\n    } = context;\n    const log = (msg: string) => (config?.output?.pr_comment ? console.error : console.log)(msg);\n    const origin = (context as any).origin || 'inline';\n\n    // Find the check configuration\n    const checkConfig = config?.checks?.[checkId];\n    if (!checkConfig) {\n      try {\n        const msg = `[on_finish] referenced unknown check '${checkId}', ignoring`;\n        (config?.output?.pr_comment ? console.error : console.log)(msg);\n      } catch {}\n      return { issues: [] };\n    }\n\n    // Respect event triggers when executing dependencies inline.\n    // If the check is not configured to run for the current event, skip executing it here.\n    try {\n      const triggers = Array.isArray(checkConfig.on) ? (checkConfig.on as string[]) : [];\n      if (triggers.length > 0) {\n        const evt = eventOverride || event || this.getCurrentEventType(prInfo);\n        const allowed = triggers.includes(evt as any);\n        if (!allowed) {\n          // Special case: manual-only checks are not auto-executed inline\n          const manualOnly = triggers.length === 1 && triggers[0] === 'manual';\n          if (manualOnly || !allowed) {\n            try {\n              const msg = `üîß Debug: Skipping inline execution of '${checkId}' for event '${evt}' (triggers=${JSON.stringify(\n                triggers\n              )})`;\n              (config?.output?.pr_comment ? console.error : console.log)(msg);\n            } catch {}\n            return { issues: [] };\n          }\n        }\n      }\n    } catch {}\n\n    // Helper to get all dependencies recursively from config, expanding OR-groups (\"a|b\")\n    const getAllDepsFromConfig = (name: string): string[] => {\n      const visited = new Set<string>();\n      const acc: string[] = [];\n      const expand = (t: unknown): string[] => {\n        const s = String(t ?? '').trim();\n        if (!s) return [];\n        if (s.includes('|'))\n          return s\n            .split('|')\n            .map(x => x.trim())\n            .filter(Boolean);\n        return [s];\n      };\n      const dfs = (n: string) => {\n        if (visited.has(n)) return;\n        visited.add(n);\n        const cfg = config?.checks?.[n];\n        const depsRaw = cfg?.depends_on || [];\n        for (const token of depsRaw) {\n          const expanded = expand(token);\n          for (const d of expanded) {\n            // Only accumulate known checks; ignore unknown OR branches\n            if (!config?.checks?.[d]) continue;\n            acc.push(d);\n            dfs(d);\n          }\n        }\n      };\n      dfs(name);\n      return Array.from(new Set(acc));\n    };\n\n    // Ensure all dependencies of target are available; execute missing ones in topological order\n    const allTargetDeps = getAllDepsFromConfig(checkId);\n    if (allTargetDeps.length > 0) {\n      // Build subgraph mapping for ordered execution\n      const subSet = new Set<string>(\n        [...allTargetDeps].filter(id => Boolean(config?.checks?.[id]))\n      );\n      const subDeps: Record<string, string[]> = {};\n      for (const id of subSet) {\n        const cfg = config?.checks?.[id];\n        const raw = cfg?.depends_on || [];\n        const expanded: string[] = [];\n        for (const token of raw) {\n          const parts = String(token ?? '')\n            .split('|')\n            .map(s => s.trim())\n            .filter(Boolean);\n          if (parts.length === 0) continue;\n          for (const p of parts) if (subSet.has(p)) expanded.push(p);\n        }\n        subDeps[id] = expanded;\n      }\n      const subGraph = DependencyResolver.buildDependencyGraph(subDeps);\n      for (const group of subGraph.executionOrder) {\n        for (const depId of group.parallel) {\n          // Skip if already have results\n          if (resultsMap?.has(depId) || dependencyResults.has(depId)) continue;\n          // Execute dependency inline (recursively ensures its deps are also present)\n          await this.executeCheckInline(depId, event, context);\n        }\n      }\n    }\n\n    // No legacy adapters; use configuration as-is\n    const adaptedConfig: any = { ...checkConfig };\n    const providerType = adaptedConfig.type || 'ai';\n    const provider = this.providerRegistry.getProviderOrThrow(providerType);\n    this.setProviderWebhookContext(provider);\n\n    // Build provider configuration\n    const provCfg: CheckProviderConfig = {\n      type: providerType,\n      prompt: adaptedConfig.prompt,\n      exec: adaptedConfig.exec,\n      focus: adaptedConfig.focus || this.mapCheckNameToFocus(checkId),\n      schema: adaptedConfig.schema,\n      group: adaptedConfig.group,\n      checkName: checkId,\n      eventContext: this.enrichEventContext(prInfo.eventContext),\n      transform: adaptedConfig.transform,\n      transform_js: adaptedConfig.transform_js,\n      env: adaptedConfig.env,\n      forEach: adaptedConfig.forEach,\n      // Pass output history for loop/goto scenarios\n      __outputHistory: this.outputHistory,\n      // no enriched history exposure; standard outputs_history only\n      // Include provider-specific keys (e.g., op/values for github)\n      ...adaptedConfig,\n      ai: {\n        ...(adaptedConfig.ai || {}),\n        timeout: adaptedConfig.ai?.timeout || 600000,\n        debug: !!debug,\n      },\n    };\n\n    // Build dependency results for this check using snapshot-based visibility (overlay per-scope results)\n    const depResults = this.buildSnapshotDependencyResults(\n      scope || [],\n      dependencyResults,\n      eventOverride || prInfo.eventType\n    );\n\n    // Debug: log key dependent outputs for visibility\n    if (debug) {\n      try {\n        const depPreview: Record<string, unknown> = {};\n        for (const [k, v] of depResults.entries()) {\n          const out = (v as any)?.output;\n          if (out !== undefined) depPreview[k] = out;\n        }\n        log(`üîß Debug: inline exec '${checkId}' deps output: ${JSON.stringify(depPreview)}`);\n      } catch {}\n    }\n\n    if (debug) {\n      const execStr = (provCfg as any).exec;\n      if (execStr) log(`üîß Debug: inline exec '${checkId}' command: ${execStr}`);\n    }\n\n    // If event override provided, clone prInfo with overridden eventType\n    let prInfoForInline = prInfo;\n    const prevEventOverride = this.routingEventOverride;\n    if (eventOverride) {\n      // Try to elevate to PR context when routing to PR events from issue threads\n      const elevated = await this.elevateContextToPullRequest(\n        { ...(prInfo as any), eventType: eventOverride } as PRInfo,\n        eventOverride,\n        log,\n        debug\n      );\n      if (elevated) {\n        prInfoForInline = elevated;\n      } else {\n        prInfoForInline = { ...(prInfo as any), eventType: eventOverride } as PRInfo;\n      }\n      this.routingEventOverride = eventOverride;\n      const msg = `‚Ü™ goto_event: inline '${checkId}' with event=${eventOverride}${\n        elevated ? ' (elevated to PR context)' : ''\n      }`;\n      if (debug) log(`üîß Debug: ${msg}`);\n      try {\n        require('./logger').logger.info(msg);\n      } catch {}\n    }\n\n    // Execute the check\n    let result: ReviewSummary;\n    try {\n      const __provStart = Date.now();\n      const inlineContext: import('./providers/check-provider.interface').ExecutionContext = {\n        ...sessionInfo,\n        ...this.executionContext,\n      } as any;\n      // dependency printout removed\n      result = await withActiveSpan(\n        `visor.check.${checkId}`,\n        { 'visor.check.id': checkId, 'visor.check.type': provCfg.type || 'ai' },\n        async () => provider.execute(prInfoForInline, provCfg, depResults, inlineContext)\n      );\n      this.recordProviderDuration(checkId, Date.now() - __provStart);\n    } catch (error) {\n      // Restore previous override before rethrowing\n      this.routingEventOverride = prevEventOverride;\n      throw error;\n    } finally {\n      // Always restore previous override\n      this.routingEventOverride = prevEventOverride;\n    }\n\n    // Enrich issues with metadata\n    const enrichedIssues = (result.issues || []).map(issue => ({\n      ...issue,\n      checkName: checkId,\n      ruleId: `${checkId}/${issue.ruleId}`,\n      group: checkConfig.group,\n      schema: typeof checkConfig.schema === 'object' ? 'custom' : checkConfig.schema,\n      template: checkConfig.template,\n      timestamp: Date.now(),\n    }));\n    let enriched = { ...result, issues: enrichedIssues } as ReviewSummary;\n\n    // Track output history for loop/goto scenarios (normalize default output shape)\n    const enrichedWithOutput = enriched as ReviewSummary & { output?: unknown };\n    if (enrichedWithOutput.output !== undefined) {\n      try {\n        const outVal: any = enrichedWithOutput.output as any;\n        let histVal: any = outVal;\n        if (Array.isArray(outVal)) {\n          histVal = outVal;\n        } else if (outVal !== null && typeof outVal === 'object') {\n          histVal = { ...outVal };\n          if ((histVal as any).ts === undefined) (histVal as any).ts = Date.now();\n        } else {\n          histVal = { text: String(outVal), ts: Date.now() };\n        }\n        this.trackOutputHistory(checkId, histVal);\n        try {\n          (enriched as any).__histTracked = true;\n        } catch {}\n      } catch {\n        // best effort history tracking\n        try {\n          this.trackOutputHistory(checkId, enrichedWithOutput.output);\n        } catch {}\n      }\n    }\n\n    // Handle forEach iteration for this check if it returned an array\n    if (checkConfig.forEach && Array.isArray(enrichedWithOutput.output)) {\n      const forEachItems = enrichedWithOutput.output;\n      // Always log forEach detection (not just in debug mode) for visibility\n      const wave = (this.forEachWaveCounts.get(checkId) || 0) + 1;\n      this.forEachWaveCounts.set(checkId, wave);\n      log(\n        `üîÑ forEach check '${checkId}' returned ${forEachItems.length} items - starting iteration (wave #${wave}, origin=${origin})`\n      );\n      if (debug) {\n        log(\n          `üîß Debug: forEach item preview: ${JSON.stringify(forEachItems[0] || {}).substring(0, 200)}`\n        );\n      }\n\n      // Store the array output with forEach metadata\n      const forEachResult = {\n        ...enriched,\n        forEachItems,\n        forEachItemResults: forEachItems.map(item => ({\n          issues: [],\n          output: item,\n        })),\n      };\n      enriched = forEachResult as ReviewSummary;\n\n      // Make the parent result visible to dependency resolution BEFORE scheduling dependents\n      // so that recursive dependency checks do not re-execute this forEach parent in the same wave.\n      try {\n        resultsMap?.set(checkId, enriched);\n      } catch {}\n\n      // Phase 4: commit aggregate parent result early (root scope) so outputs_raw is visible\n      this.commitJournal(\n        checkId,\n        enriched as ExtendedReviewSummary,\n        prInfoForInline.eventType || prInfo.eventType,\n        []\n      );\n\n      // Wave guard: if waves exceed routing.max_loops, stop scheduling dependents to prevent runaway loops\n      const maxLoops = config?.routing?.max_loops ?? 10;\n      if (wave > maxLoops) {\n        try {\n          logger.warn(\n            `‚õî forEach wave guard: '${checkId}' exceeded max_loops=${maxLoops} (wave #${wave}); skipping dependents and routing`\n          );\n        } catch {}\n        // Store and return aggregated result\n        resultsMap?.set(checkId, enriched);\n        return enriched;\n      }\n\n      // Find checks that depend on this forEach check\n      const dependentChecks = Object.keys(config?.checks || {}).filter(name => {\n        const cfg = config?.checks?.[name];\n        return cfg?.depends_on?.includes(checkId);\n      });\n\n      // Always log dependents for visibility\n      try {\n        if (dependentChecks.length > 0) {\n          log(\n            `üîÑ forEach check '${checkId}' has ${dependentChecks.length} dependents: ${dependentChecks.join(', ')}`\n          );\n        } else {\n          log(`‚ö†Ô∏è  forEach check '${checkId}' has NO dependents - nothing to iterate`);\n        }\n      } catch {}\n\n      // Execute each dependent check once per forEach item (scope-based; no per-item map cloning)\n      for (const depCheckName of dependentChecks) {\n        const depCheckConfig = config?.checks?.[depCheckName];\n        if (!depCheckConfig) continue;\n\n        // Always (re)run dependents during inline reruns (on_finish.goto to parent).\n        // We intentionally do not short-circuit on existing results here so stats/history\n        // reflect multiple waves.\n        // Skip if no items to iterate over\n        if (forEachItems.length === 0) {\n          if (debug) {\n            log(`üîß Debug: Skipping forEach dependent '${depCheckName}' - no items to iterate`);\n          }\n          // Store empty result\n          resultsMap?.set(depCheckName, { issues: [] });\n          continue;\n        }\n\n        // Always log iteration start\n        try {\n          const wave = this.forEachWaveCounts.get(checkId) || 1;\n          log(\n            `üîÑ Executing forEach dependent '${depCheckName}' for ${forEachItems.length} items (wave #${wave})`\n          );\n        } catch {}\n\n        const depResults: ReviewSummary[] = [];\n\n        // Execute once per forEach item\n        for (let itemIndex = 0; itemIndex < forEachItems.length; itemIndex++) {\n          const item = forEachItems[itemIndex];\n          const wave = this.forEachWaveCounts.get(checkId) || 1;\n          log(\n            `  üîÑ Iteration ${itemIndex + 1}/${forEachItems.length} f|| '${depCheckName}' (wave #${wave})`\n          );\n\n          // Phase 4: Commit per-item entry for parent in journal under item scope\n          const itemScope: ScopePath = [{ check: checkId, index: itemIndex }];\n          try {\n            this.commitJournal(\n              checkId,\n              { issues: [], output: item } as ExtendedReviewSummary,\n              prInfoForInline.eventType || prInfo.eventType,\n              itemScope\n            );\n          } catch (error) {\n            const msg = error instanceof Error ? error.message : String(error);\n            logger.error(`Failed to commit per-item journal for ${checkId}: ${msg}`);\n            // Non-fatal: journal is best-effort; continue without retry.\n          }\n\n          try {\n            // Build provider + config for dependent and execute with full routing semantics\n            const depProviderType = depCheckConfig.type || 'ai';\n            const depProvider = this.providerRegistry.getProviderOrThrow(depProviderType);\n            this.setProviderWebhookContext(depProvider);\n\n            // Build dependency results from snapshot at item scope (no cloning)\n            const snapshotDeps = this.buildSnapshotDependencyResults(\n              itemScope,\n              undefined,\n              prInfoForInline.eventType || prInfo.eventType\n            );\n\n            // Use unified helper to ensure stats and history are tracked for each item run\n            const res = await this.runNamedCheck(depCheckName, itemScope, {\n              origin: 'foreach',\n              config: config!,\n              dependencyGraph: context.dependencyGraph,\n              prInfo,\n              resultsMap: resultsMap || new Map(),\n              debug: !!debug,\n              eventOverride: prInfoForInline.eventType || prInfo.eventType,\n              overlay: snapshotDeps,\n            });\n            depResults.push(res);\n          } catch (error) {\n            // Store error result for this iteration\n            const errorMsg = error instanceof Error ? error.message : String(error);\n            const errorIssue: ReviewIssue = {\n              file: '',\n              line: 0,\n              ruleId: `${depCheckName}/forEach/iteration_error`,\n              message: `forEach iteration ${itemIndex + 1} failed: ${errorMsg}`,\n              severity: 'error',\n              category: 'logic',\n            };\n            depResults.push({\n              issues: [errorIssue],\n            });\n          }\n        }\n\n        // Aggregate results from all iterations\n        const aggregatedResult: ReviewSummary = {\n          issues: depResults.flatMap(r => r.issues || []),\n        };\n\n        // Store in results map\n        resultsMap?.set(depCheckName, aggregatedResult);\n\n        if (debug) {\n          log(\n            `üîß Debug: Completed forEach dependent '${depCheckName}' with ${depResults.length} iterations`\n          );\n        }\n      }\n    }\n\n    // Store result in results map\n    resultsMap?.set(checkId, enriched);\n    // Commit to journal with provided scope (or root). Avoid double-commit if we already committed aggregate above.\n    const isForEachAggregate = checkConfig.forEach && Array.isArray(enrichedWithOutput.output);\n    if (!isForEachAggregate) {\n      this.commitJournal(\n        checkId,\n        enriched as ExtendedReviewSummary,\n        prInfoForInline.eventType || prInfo.eventType,\n        scope || []\n      );\n    }\n\n    if (debug) log(`üîß Debug: inline executed '${checkId}', issues: ${enrichedIssues.length}`);\n\n    return enriched;\n  }\n\n  /**\n   * Phase 3: Unified scheduling helper\n   * Runs a named check in the current session/scope and records results.\n   * Used by on_success/on_fail/on_finish routing and internal inline execution.\n   */\n  private async runNamedCheck(\n    target: string,\n    scope: ScopePath,\n    opts: {\n      config: VisorConfig;\n      dependencyGraph: DependencyGraph;\n      prInfo: PRInfo;\n      resultsMap: Map<string, ReviewSummary>;\n      debug: boolean;\n      sessionInfo?: { parentSessionId?: string; reuseSession?: boolean };\n      eventOverride?: import('./types/config').EventTrigger;\n      overlay?: Map<string, ReviewSummary>;\n      origin?: 'on_finish' | 'on_success' | 'on_fail' | 'foreach' | 'initial' | 'inline';\n    }\n  ): Promise<ReviewSummary> {\n    const {\n      config,\n      dependencyGraph,\n      prInfo,\n      resultsMap,\n      debug,\n      sessionInfo,\n      eventOverride,\n      overlay,\n    } = opts;\n    try {\n      if (debug && opts.origin === 'on_finish') {\n        console.error(`[runNamedCheck] origin=on_finish step=${target}`);\n      }\n    } catch {}\n\n    // Evaluate 'if' condition for checks executed via routing (run/goto).\n    try {\n      const tcfg = opts.config.checks?.[target] as import('./types/config').CheckConfig | undefined;\n      if (tcfg && tcfg.if) {\n        const gate = await this.shouldRunCheck(\n          target,\n          tcfg.if,\n          opts.prInfo,\n          opts.resultsMap || new Map<string, ReviewSummary>(),\n          !!debug,\n          opts.eventOverride,\n          /* failSecure */ true\n        );\n        if (!gate.shouldRun) {\n          // Record a skipped marker compatible with summary rendering\n          const skipped: ReviewSummary = {\n            issues: [\n              {\n                file: '',\n                line: 0,\n                ruleId: `${target}/__skipped`,\n                message: `Skipped by if condition: ${tcfg.if}`,\n                severity: 'info',\n                category: 'logic',\n              },\n            ],\n          } as ReviewSummary;\n          try {\n            this.recordSkip(target, 'if_condition', tcfg.if);\n            logger.info(`‚è≠  Skipped (if: ${this.truncate(tcfg.if, 40)})`);\n          } catch (error) {\n            const msg = error instanceof Error ? error.message : String(error);\n            logger.error(`Failed to record skip for ${target}: ${msg}`);\n          }\n          // Commit a minimal journal entry to make downstream visibility consistent\n          this.commitJournal(\n            target,\n            skipped as any,\n            opts.eventOverride || opts.prInfo.eventType,\n            scope || []\n          );\n          opts.resultsMap?.set(target, skipped);\n          return skipped;\n        }\n      }\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : String(error);\n      logger.error(`Failed to evaluate if condition for ${target}: ${msg}`);\n      // Fail secure: if condition evaluation fails, skip execution\n      const skipped: ReviewSummary = {\n        issues: [\n          {\n            file: '',\n            line: 0,\n            ruleId: `${target}/__skipped`,\n            message: `Skipped due to condition evaluation error`,\n            severity: 'info',\n            category: 'logic',\n          },\n        ],\n      } as ReviewSummary;\n      try {\n        const cond =\n          (opts.config.checks?.[target] as import('./types/config').CheckConfig | undefined)?.if ||\n          '';\n        this.recordSkip(target, 'if_condition', cond);\n      } catch {}\n      this.commitJournal(\n        target,\n        skipped as any,\n        opts.eventOverride || opts.prInfo.eventType,\n        scope || []\n      );\n      opts.resultsMap?.set(target, skipped);\n      return skipped;\n    }\n\n    // Enforce max-runs guard (after 'if' passes). Count per scope (forEach items separated).\n    try {\n      const limit = this.resolveMaxRuns(config, target);\n      if (typeof limit === 'number' && limit > 0) {\n        const k = this.buildRunKey(target, scope);\n        const soFar = this.runCounters.get(k) || 0;\n        if (soFar >= limit) {\n          const issue: ReviewIssue = {\n            file: '',\n            line: 0,\n            ruleId: `${target}/limits/max_runs_exceeded`,\n            message: `Run limit exceeded for '${target}' in scope ${k} (attempt ${soFar + 1} > ${limit}).`,\n            severity: 'error',\n            category: 'logic',\n          };\n          const capped: ReviewSummary = { issues: [issue] };\n          try {\n            resultsMap.set(target, capped);\n          } catch {}\n          logger.warn(`‚ö†Ô∏è  Max runs exceeded for '${target}' in scope ${k} (limit=${limit}).`);\n          return capped;\n        }\n        this.runCounters.set(k, soFar + 1);\n      }\n    } catch {}\n\n    // Build context overlay from current results; prefer snapshot visibility for scope (Phase 4)\n    const depOverlay = overlay ? new Map(overlay) : new Map(resultsMap);\n    const depOverlaySanitized = this.sanitizeResultMapKeys(depOverlay);\n    // For event overrides, avoid leaking cross-event results via overlay; rely on snapshot-only view\n    const overlayForExec =\n      eventOverride && eventOverride !== (prInfo.eventType || 'manual')\n        ? new Map<string, ReviewSummary>()\n        : depOverlaySanitized;\n    if (!this.executionStats.has(target)) this.initializeCheckStats(target);\n    const startTs = this.recordIterationStart(target);\n    try {\n      let res = await this.executeCheckInline(\n        target,\n        eventOverride || prInfo.eventType || 'manual',\n        {\n          config,\n          dependencyGraph,\n          prInfo,\n          resultsMap,\n          // Use snapshot-only deps when eventOverride is set\n          dependencyResults: overlayForExec,\n          sessionInfo,\n          debug,\n          eventOverride,\n          scope,\n          origin: opts.origin || 'inline',\n        }\n      );\n      // Evaluate fail_if for inline-executed checks (parity with grouped path)\n      let postFailTriggered = false;\n      if (config && (config.fail_if || (config.checks as any)?.[target]?.fail_if)) {\n        try {\n          const failureResults = await this.evaluateFailureConditions(\n            target,\n            res,\n            config,\n            prInfo,\n            resultsMap\n          );\n          if (failureResults.length > 0) {\n            const failureIssues = failureResults\n              .filter(f => f.failed)\n              .map(f => ({\n                file: 'system',\n                line: 0,\n                ruleId: f.conditionName,\n                message: f.message || `Failure condition met: ${f.expression}`,\n                severity: (f.severity || 'error') as 'info' | 'warning' | 'error' | 'critical',\n                category: 'logic' as const,\n              }));\n            if (failureIssues.length > 0) {\n              res = {\n                ...(res || { issues: [] }),\n                issues: [...(res.issues || []), ...failureIssues],\n              } as ReviewSummary;\n              // Update resultsMap immediately so downstream forward-run gating sees fail_if as fatal\n              try {\n                resultsMap.set(target, res);\n              } catch {}\n              // Post-fail_if routing: honor on_fail.goto for inline path\n              const checkCfg = (config.checks as any)?.[target] as\n                | import('./types/config').CheckConfig\n                | undefined;\n              const ofCfg: OnFailConfig | undefined = checkCfg?.on_fail\n                ? { ...(config?.routing?.defaults?.on_fail || {}), ...checkCfg.on_fail }\n                : undefined;\n              postFailTriggered = failureResults.some(r => r.failed === true);\n              // One-bounce guard: if this inline execution was itself triggered from an on_fail\n              // forward-run wave, suppress further on_fail.goto inside the same wave to avoid\n              // tight ask‚Üîrefine loops. Let the grouped runner resume control.\n              // One-bounce guard: when this inline execution was triggered from a routing\n              // origin (on_success/on_fail/foreach), avoid performing another inline\n              // on_fail.goto to prevent tight recursion. In this case we signal the\n              // grouped runner to start another wave so the target step is picked up\n              // at level 0 naturally.\n              const __suppressFailGoto = !!(opts.origin && opts.origin !== 'initial');\n              if (\n                postFailTriggered &&\n                !__suppressFailGoto &&\n                ofCfg &&\n                (ofCfg.goto || ofCfg.goto_js)\n              ) {\n                let pfTarget: string | null = null;\n                if (ofCfg.goto_js) {\n                  try {\n                    const sandbox = this.getRoutingSandbox();\n                    const scopeObj = {\n                      step: { id: target, tags: checkCfg?.tags || [], group: checkCfg?.group },\n                      outputs: Object.fromEntries(resultsMap.entries()),\n                      output: (res as any)?.output,\n                      event: { name: prInfo.eventType || 'manual' },\n                    };\n                    const code = `const step=scope.step; const outputs=scope.outputs; const output=scope.output; const event=scope.event; ${ofCfg.goto_js}`;\n                    const r = compileAndRun<string | null>(\n                      sandbox,\n                      code,\n                      { scope: scopeObj },\n                      { injectLog: false, wrapFunction: true }\n                    );\n                    pfTarget = typeof r === 'string' && r ? r : null;\n                  } catch {}\n                }\n                if (!pfTarget && ofCfg.goto) pfTarget = ofCfg.goto;\n                if (pfTarget) {\n                  try {\n                    logger.info(\n                      `‚Ü™ on_fail.goto(post-fail_if/inline): jumping to '${pfTarget}' from '${target}'`\n                    );\n                  } catch {}\n                  await this.scheduleForwardRun(pfTarget, {\n                    origin: 'on_fail',\n                    gotoEvent: ofCfg.goto_event,\n                    config,\n                    dependencyGraph,\n                    prInfo,\n                    resultsMap,\n                    debug,\n                  });\n                }\n              } else if (postFailTriggered) {\n                // No inline goto scheduled (either suppressed or no goto configured):\n                // flag the outer wave loop so we execute another pass.\n                try {\n                  (this as any).onFailForwardRunSeen = true;\n                  if (debug)\n                    (config?.output?.pr_comment ? console.error : console.log)(\n                      `üîÅ Debug: inline fail_if triggered for '${target}', scheduling next wave`\n                    );\n                } catch {}\n              }\n            }\n          }\n        } catch {}\n      }\n      // Success path (inline): honor on_success.run/goto for the inline-executed target\n      try {\n        const checkCfg = (config.checks as any)?.[target] as\n          | import('./types/config').CheckConfig\n          | undefined;\n        const onSucc: OnSuccessConfig | undefined = checkCfg?.on_success;\n        // When this inline execution originates from a forward-run:\n        //  - origin === 'on_success': scheduleForwardRun will already handle dependents and\n        //    static goto chains. Suppress inline on_success entirely to avoid duplicates.\n        //  - origin === 'on_fail': we want corrective side-effects from on_success.run (e.g.,\n        //    increment a memory counter), but we must NOT follow goto to avoid immediate loops.\n        const originTag = opts.origin || 'inline';\n        const suppressAllOnSuccess = originTag === 'on_success';\n        const suppressGotoOnly = originTag === 'on_fail' || this.gotoSuppressedChecks.has(target);\n        if (onSucc && !postFailTriggered && !suppressAllOnSuccess) {\n          // Compute run list (static + dynamic)\n          const dynamicRun = await (async () => {\n            if (!onSucc.run_js) return [] as string[];\n            try {\n              const scopeObj = {\n                step: { id: target, tags: checkCfg?.tags || [], group: checkCfg?.group },\n                outputs: Object.fromEntries(resultsMap.entries()),\n                output: (res as any)?.output,\n                event: { name: prInfo.eventType || 'manual' },\n              };\n              const code = `const step=scope.step; const outputs=scope.outputs; const output=scope.output; const event=scope.event; ${onSucc.run_js}`;\n              const r = compileAndRun<string[] | string | null>(\n                this.getRoutingSandbox(),\n                code,\n                { scope: scopeObj },\n                { injectLog: false, wrapFunction: true }\n              );\n              const arr = Array.isArray(r) ? r : typeof r === 'string' && r ? [r] : [];\n              return arr.filter(Boolean) as string[];\n            } catch {\n              return [] as string[];\n            }\n          })();\n          let runList = [...(onSucc.run || []), ...dynamicRun].filter(Boolean);\n          // Dedup within this call\n          runList = Array.from(new Set(runList));\n          if (runList.length > 0) {\n            for (const stepId of runList) {\n              // One-shot guard similar to grouped path\n              try {\n                const tcfg = (config.checks || {})[stepId] as\n                  | import('./types/config').CheckConfig\n                  | undefined;\n                const tags = (tcfg?.tags || []) as string[];\n                const isOneShot = Array.isArray(tags) && tags.includes('one_shot');\n                if (isOneShot && (this.executionStats.get(stepId)?.totalRuns || 0) > 0) {\n                  continue;\n                }\n              } catch {}\n              await this.runNamedCheck(stepId, scope || [], {\n                config,\n                dependencyGraph,\n                prInfo,\n                resultsMap,\n                debug,\n                overlay: resultsMap,\n              });\n            }\n          }\n          // Optional on_success.goto for inline path\n          let succTarget: string | null = null;\n          try {\n            if (!suppressGotoOnly && !succTarget && onSucc.goto_js) {\n              const scopeObj = {\n                step: { id: target, tags: checkCfg?.tags || [], group: checkCfg?.group },\n                outputs: Object.fromEntries(resultsMap.entries()),\n                output: (res as any)?.output,\n                event: { name: prInfo.eventType || 'manual' },\n              };\n              const code = `const step=scope.step; const outputs=scope.outputs; const output=scope.output; const event=scope.event; ${onSucc.goto_js}`;\n              const r = compileAndRun<string | null>(\n                this.getRoutingSandbox(),\n                code,\n                { scope: scopeObj },\n                { injectLog: false, wrapFunction: true }\n              );\n              succTarget = typeof r === 'string' && r ? r : null;\n            }\n          } catch {}\n          if (!suppressGotoOnly && !succTarget && onSucc.goto) succTarget = onSucc.goto;\n          if (!suppressGotoOnly && succTarget) {\n            // If this is comment-assistant retriggering overview, proactively\n            // post the assistant reply so flows record a createComment before\n            // we jump to overview.\n            try {\n              // Generic: when an assistant-style check (schema contains a 'text' field)\n              // triggers a goto to a different event (e.g., pr_updated), proactively post\n              // the assistant reply so flows record a createComment before jumping.\n              const isAssistantSchema = async () => {\n                try {\n                  const sc = (config.checks as any)[target]?.schema;\n                  if (!sc) return false;\n                  if (typeof sc === 'string') {\n                    const name = String(sc);\n                    const builtins = new Set([\n                      'issue-assistant',\n                      'overview',\n                      'plain',\n                      'text',\n                      'code-review',\n                    ]);\n                    if (builtins.has(name)) return true;\n                    try {\n                      const fs = require('fs');\n                      const path = require('path');\n                      const candidates = [\n                        path.join(__dirname, 'output', name, 'schema.json'),\n                        path.join(process.cwd(), 'output', name, 'schema.json'),\n                      ];\n                      for (const p of candidates) {\n                        try {\n                          const txt = fs.readFileSync(p, 'utf8');\n                          const obj = JSON.parse(txt);\n                          const props = obj && obj.properties;\n                          if (props && Object.prototype.hasOwnProperty.call(props, 'text'))\n                            return true;\n                        } catch {}\n                      }\n                    } catch {}\n                    return false;\n                  }\n                  const props = (sc && (sc as any).properties) || {};\n                  return Boolean(props && Object.prototype.hasOwnProperty.call(props, 'text'));\n                } catch {\n                  return false;\n                }\n              };\n              const shouldProactivelyPost = await isAssistantSchema();\n              if (shouldProactivelyPost && (onSucc.goto || onSucc.goto_event)) {\n                const out = (res as any)?.output;\n                const hasText =\n                  out &&\n                  typeof out === 'object' &&\n                  typeof out.text === 'string' &&\n                  out.text.trim().length > 0;\n                if (hasText) {\n                  // One-shot guard: post once per run per target\n                  try {\n                    const key = `post:${target}`;\n                    if (this.oncePerRunScheduleGuards.has(key)) {\n                      // already posted\n                    } else {\n                      this.oncePerRunScheduleGuards.add(key);\n                    }\n                  } catch {}\n                  const miniSummary: any = {\n                    issues: [],\n                    __outputs: { [target]: out },\n                    __contents: {},\n                    __executed: [target],\n                  };\n                  // Resolve owner/repo\n                  let owner: string | undefined = this.actionContext?.owner;\n                  let repo: string | undefined = this.actionContext?.repo;\n                  if (!owner || !repo) {\n                    try {\n                      const anyInfo = prInfo as any;\n                      owner = anyInfo?.eventContext?.repository?.owner?.login || owner;\n                      repo = anyInfo?.eventContext?.repository?.name || repo;\n                    } catch {}\n                  }\n                  owner = owner || (process.env.GITHUB_REPOSITORY || 'owner/repo').split('/')[0];\n                  repo = repo || (process.env.GITHUB_REPOSITORY || 'owner/repo').split('/')[1];\n                  try {\n                    const oc = (prInfo as any)?.eventContext?.octokit;\n                    if (oc && owner && repo && prInfo.number) {\n                      // Render minimal content via template for consistent formatting\n                      let rendered: string | undefined = undefined;\n                      try {\n                        rendered = await this.renderCheckContent(\n                          target,\n                          { issues: [], output: out } as any,\n                          (config.checks as any)[target],\n                          prInfo\n                        );\n                      } catch {}\n                      const body = `${(rendered && rendered.trim()) || String(out.text || '')}\\n\\n${generateFooter()}`;\n                      const api: any =\n                        (oc as any).rest?.issues?.createComment ||\n                        (oc as any).issues?.createComment;\n                      if (typeof api === 'function') {\n                        await api({ owner, repo, issue_number: prInfo.number, body });\n                      } else if (this.reviewer) {\n                        const grouped = await this.convertReviewSummaryToGroupedResults(\n                          miniSummary,\n                          [target],\n                          config,\n                          prInfo\n                        );\n                        await this.reviewer.postReviewComment(owner, repo, prInfo.number, grouped, {\n                          config: config as any,\n                          triggeredBy: prInfo.eventType || 'manual',\n                          octokitOverride: oc as any,\n                        });\n                      }\n                    } else if (this.reviewer && owner && repo && prInfo.number) {\n                      // Fallback to grouped posting path if recorder is not available\n                      const grouped = await this.convertReviewSummaryToGroupedResults(\n                        miniSummary,\n                        ['comment-assistant'],\n                        config,\n                        prInfo\n                      );\n                      await this.reviewer.postReviewComment(owner, repo, prInfo.number, grouped, {\n                        config: config as any,\n                        triggeredBy: prInfo.eventType || 'manual',\n                        octokitOverride: (prInfo as any)?.eventContext?.octokit,\n                      });\n                    }\n                  } catch {}\n                }\n              }\n            } catch {}\n\n            await this.scheduleForwardRun(succTarget, {\n              origin: 'on_success',\n              gotoEvent: onSucc.goto_event,\n              config,\n              dependencyGraph,\n              prInfo,\n              resultsMap,\n              debug,\n            });\n            // Opportunistic inline execution: if the routed target has its\n            // dependencies satisfied by current results, run it once now so\n            // simple producer‚Üíconsumer chains complete without another wave.\n            try {\n              const childCfg = (config.checks || {})[succTarget] as\n                | import('./types/config').CheckConfig\n                | undefined;\n              const deps = Array.isArray(childCfg?.depends_on)\n                ? (childCfg!.depends_on as string[])\n                : childCfg?.depends_on\n                  ? [String(childCfg.depends_on)]\n                  : [];\n              const depsSatisfied = deps.every(d => resultsMap.has(d));\n              if (depsSatisfied) {\n                // Suppress further goto on dependencies during this opportunistic run\n                try {\n                  for (const d of deps) this.gotoSuppressedChecks.add(d);\n                } catch {}\n                try {\n                  if (!this.executionStats.has(succTarget)) this.initializeCheckStats(succTarget);\n                } catch {}\n                await this.runNamedCheck(succTarget, scope || [], {\n                  config,\n                  dependencyGraph,\n                  prInfo,\n                  resultsMap,\n                  debug,\n                  overlay: resultsMap,\n                });\n                // Clear scheduled marker for this target to avoid redundant next-wave run\n                try {\n                  this.forwardDependentsScheduled.delete(succTarget);\n                } catch {}\n              }\n            } catch {}\n          }\n        }\n      } catch {}\n      // Ensure resultsMap reflects any fail_if augmentation before downstream gating/routing\n      try {\n        resultsMap.set(target, res);\n      } catch {}\n      const issues = (res.issues || []).map(i => ({ ...i }));\n      const success = !this.hasFatal(issues);\n      const out: unknown = (res as { output?: unknown }).output;\n      const isForEachParent =\n        (res as any)?.isForEach === true ||\n        Array.isArray((res as any)?.forEachItems) ||\n        Array.isArray(out);\n      this.recordIterationComplete(\n        target,\n        startTs,\n        success,\n        issues,\n        isForEachParent ? undefined : out\n      );\n      // Output history is already tracked inside executeCheckInline when a check\n      // produces an output. Avoid tracking again here to prevent double-counting\n      // (particularly for forward-run goto chains within a single stage).\n      return res;\n    } catch (e) {\n      this.recordIterationComplete(target, startTs, false, [], undefined);\n      throw e;\n    }\n  }\n\n  /**\n   * Handle on_finish hooks for forEach checks after ALL dependents complete\n   */\n  private async handleOnFinishHooks(\n    config: VisorConfig,\n    dependencyGraph: DependencyGraph,\n    results: Map<string, ReviewSummary>,\n    prInfo: PRInfo,\n    debug: boolean\n  ): Promise<void> {\n    const log = (msg: string) => (config?.output?.pr_comment ? console.error : console.log)(msg);\n    try {\n      if (debug) console.error('[on_finish] handler invoked');\n    } catch {}\n\n    const forEachChecksWithOnFinish = this.collectForEachParentsWithOnFinish(config);\n\n    try {\n      logger.info(\n        `üß≠ on_finish: discovered ${forEachChecksWithOnFinish.length} forEach parent(s) with hooks`\n      );\n    } catch {}\n    if (forEachChecksWithOnFinish.length === 0) {\n      return; // No on_finish hooks to process\n    }\n\n    // Note: do not early-return if none of the forEach parents executed in this run.\n    // Some configurations rely on on_finish routing even when the parent did not run\n    // in the current wave (e.g., CLI-only invocations). We continue and allow\n    // budget checks and static routing to surface issues as needed.\n\n    if (debug) {\n      log(`üéØ Processing on_finish hooks for ${forEachChecksWithOnFinish.length} forEach check(s)`);\n    }\n\n    // Process each forEach check's on_finish hook\n    for (const { checkName, checkConfig, onFinish } of forEachChecksWithOnFinish) {\n      try {\n        const forEachResult = results.get(checkName) as ExtendedReviewSummary | undefined;\n\n        // Treat missing result or empty array as zero items; still proceed so that\n        // loop-budget checks and static routing can be validated.\n        const forEachItems = (forEachResult && forEachResult.forEachItems) || [];\n\n        // Get all dependents of this forEach check\n        const node = dependencyGraph.nodes.get(checkName);\n        const dependents = node?.dependents || [];\n\n        try {\n          logger.info(`üîç on_finish: \"${checkName}\" ‚Üí ${dependents.length} dependent(s)`);\n        } catch {}\n\n        // Ensure all dependents have completed before processing on_finish.\n        // If any are missing, try to execute them now in the on_finish phase so aggregation\n        // has up-to-date data (particularly important for forEach + validators).\n        for (const depId of dependents) {\n          if (results.has(depId)) continue;\n          try {\n            if (debug)\n              log(\n                `üîß on_finish: executing missing dependent '${depId}' before processing '${checkName}'`\n              );\n            const depRes = await this.runNamedCheck(depId, [], {\n              origin: 'on_finish',\n              config,\n              dependencyGraph,\n              prInfo,\n              resultsMap: results,\n              sessionInfo: (this.executionContext as any) || undefined,\n              debug,\n              overlay: new Map(results),\n            });\n            try {\n              results.set(depId, depRes as ReviewSummary);\n            } catch {}\n          } catch (e) {\n            // If a dependent cannot run, continue; downstream hooks may still choose to skip\n            try {\n              const msg = e instanceof Error ? e.message : String(e);\n              logger.warn(`‚ö†Ô∏è on_finish: failed to execute dependent '${depId}': ${msg}`);\n            } catch {}\n          }\n        }\n\n        logger.info(`‚ñ∂ on_finish: processing for \"${checkName}\"`);\n\n        // Build history snapshot and synthesize per-item entries for dependents of this\n        // forEach parent if the current wave's per-item results are not yet reflected.\n        const historySnapshot = this.getOutputHistorySnapshot();\n        try {\n          // Ensure the parent entry includes the current wave's array of items\n          try {\n            const parentHist = (historySnapshot[checkName] as unknown[]) || [];\n            const lastArray = parentHist.filter(Array.isArray).slice(-1)[0] as\n              | unknown[]\n              | undefined;\n            const sameLength = Array.isArray(lastArray) && lastArray.length === forEachItems.length;\n            if (!sameLength && Array.isArray(forEachItems) && forEachItems.length > 0) {\n              if (!historySnapshot[checkName]) historySnapshot[checkName] = [] as unknown[];\n              (historySnapshot[checkName] as unknown[]).push(forEachItems);\n            }\n          } catch {}\n\n          const nodeDeps = dependencyGraph.nodes.get(checkName)?.dependents || [];\n          for (const depId of nodeDeps) {\n            const depRes = results.get(depId) as ExtendedReviewSummary | undefined;\n            if (!depRes || !Array.isArray(depRes.forEachItemResults)) continue;\n            const items = Array.isArray(forEachItems) ? forEachItems.length : 0;\n            if (items <= 0) continue;\n            const arr = (historySnapshot[depId] as unknown[]) || [];\n            const nonArrayCount = arr.filter(x => !Array.isArray(x)).length;\n            const remainder = items > 0 ? nonArrayCount % items : 0;\n            const deficit = remainder > 0 ? items - remainder : 0;\n            if (deficit > 0) {\n              // Top up to the nearest multiple of items using current wave results\n              const wave = depRes.forEachItemResults.slice(\n                0,\n                Math.min(deficit, depRes.forEachItemResults.length)\n              );\n              for (const r of wave) {\n                const outVal = (r as any)?.output !== undefined ? (r as any).output : r;\n                try {\n                  if (!historySnapshot[depId]) historySnapshot[depId] = [] as unknown[];\n                  (historySnapshot[depId] as unknown[]).push(outVal);\n                } catch {}\n              }\n            }\n          }\n        } catch {}\n\n        // If the forEach parent didn't carry forEachItems on the result object,\n        // recover the last wave array length from history (if present).\n        try {\n          if (Array.isArray((historySnapshot as any)[checkName]) && forEachItems.length === 0) {\n            const parentHist = ((historySnapshot as any)[checkName] as unknown[]).filter(\n              Array.isArray\n            );\n            const lastArr =\n              parentHist.length > 0 ? (parentHist[parentHist.length - 1] as unknown[]) : [];\n            if (Array.isArray(lastArr) && lastArr.length > 0) {\n              forEachItems.splice(0, forEachItems.length, ...lastArr);\n            }\n          }\n        } catch {}\n\n        // Build context projection (pure) using the synthesized snapshot\n        const { outputsForContext, outputsHistoryForContext } = ofProject(results, historySnapshot);\n\n        // Create forEach stats\n        const __perItem = Array.isArray(forEachResult?.forEachItemResults)\n          ? (forEachResult!.forEachItemResults as ReviewSummary[])\n          : [];\n        const forEachStats = {\n          total: forEachItems.length,\n          last_wave_size: forEachItems.length,\n          successful:\n            __perItem.length > 0\n              ? __perItem.filter(r => r && (!r.issues || r.issues.length === 0)).length\n              : forEachItems.length,\n          failed:\n            __perItem.length > 0\n              ? __perItem.filter(r => r && r.issues && r.issues.length > 0).length\n              : 0,\n          items: forEachItems,\n        };\n\n        // Build context for on_finish evaluation (extracted helper)\n        const onFinishContext = ofComposeCtx(\n          undefined,\n          checkName,\n          checkConfig,\n          outputsForContext,\n          outputsHistoryForContext,\n          forEachStats,\n          prInfo\n        );\n\n        // Diagnostics: log attempt, dependents, items, and current budget usage\n        try {\n          const usedBudget = this.onFinishLoopCounts.get(checkName) || 0;\n          const maxBudget = config?.routing?.max_loops ?? 10;\n          logger.info(\n            `üß≠ on_finish: check=\"${checkName}\" items=${forEachItems.length} dependents=${dependents.length} budget=${usedBudget}/${maxBudget}`\n          );\n          const vfHist = (outputsHistoryForContext['validate-fact'] as unknown[]) || [];\n          if (vfHist.length) {\n            logger.debug(`üß≠ on_finish: outputs.history['validate-fact'] length=${vfHist.length}`);\n          }\n        } catch {}\n\n        // Execute on_finish.run (static) first, then evaluate run_js with updated context\n        {\n          const maxLoops = config?.routing?.max_loops ?? 10;\n          let loopCount = 0;\n          const runList = Array.from(new Set([...(onFinish.run || [])].filter(Boolean)));\n          if (runList.length > 0)\n            logger.info(`‚ñ∂ on_finish.run: executing [${runList.join(', ')}] for \"${checkName}\"`);\n          const runCheck = async (id: string): Promise<ReviewSummary> => {\n            if (++loopCount > maxLoops) {\n              try {\n                logger.error(\n                  `Routing loop budget exceeded (max_loops=${maxLoops}) during on_finish run`\n                );\n              } catch {}\n              // Surface a visible issue instead of throwing so E2E can assert\n              try {\n                results.set(checkName, {\n                  issues: [\n                    {\n                      file: 'system',\n                      line: 0,\n                      ruleId: `${checkName}/routing/loop_budget_exceeded`,\n                      message: `Routing loop budget exceeded (max_loops=${maxLoops}) during on_finish run`,\n                      severity: 'error',\n                      category: 'logic',\n                    },\n                  ],\n                } as ReviewSummary);\n              } catch {}\n              return { issues: [] } as ReviewSummary;\n            }\n            const childCfgFull = (config?.checks || {})[id] as\n              | import('./types/config').CheckConfig\n              | undefined;\n            if (!childCfgFull) throw new Error(`Unknown check in on_finish.run: ${id}`);\n            const childProvider = this.providerRegistry.getProviderOrThrow(\n              childCfgFull.type || 'ai'\n            );\n            this.setProviderWebhookContext(childProvider);\n            const depOverlayForChild = new Map(results);\n            const resChild = await this.runNamedCheck(id, [], {\n              origin: 'on_finish',\n              config: config!,\n              dependencyGraph,\n              prInfo,\n              resultsMap: results,\n              debug,\n              sessionInfo: (this.executionContext as any) || undefined,\n              overlay: depOverlayForChild,\n            });\n            try {\n              results.set(id, resChild as ReviewSummary);\n            } catch {}\n            return resChild as ReviewSummary;\n          };\n          try {\n            await ofRunChildren(runList, runCheck, config!, onFinishContext, debug || false, log);\n            if (runList.length > 0) logger.info(`‚úì on_finish.run: completed for \"${checkName}\"`);\n          } catch (error) {\n            const errorMsg = error instanceof Error ? error.message : String(error);\n            logger.error(`‚úó on_finish.run: failed for \"${checkName}\": ${errorMsg}`);\n            if (error instanceof Error && error.stack) logger.debug(`Stack trace: ${error.stack}`);\n            throw error;\n          }\n\n          // Now evaluate dynamic run_js with post-run context (e.g., after aggregation updated memory)\n          const evalRunJs = async (js?: string): Promise<string[]> => {\n            if (!js) return [];\n            try {\n              const sandbox = this.getRoutingSandbox();\n              const scope = onFinishContext; // contains memory + outputs history\n              const code = `\n                const step = scope.step; const attempt = scope.attempt; const loop = scope.loop; const outputs = scope.outputs; const outputs_history = scope.outputs_history; const outputs_raw = scope.outputs_raw; const forEach = scope.forEach; const memory = scope.memory; const pr = scope.pr; const files = scope.files; const env = scope.env; const event = scope.event; const log = (...a)=> console.log('üîç Debug:',...a);\n                const __fn = () => {\\n${js}\\n};\n                const __res = __fn();\n                return Array.isArray(__res) ? __res.filter(x => typeof x === 'string' && x) : [];\n              `;\n              const exec = sandbox.compile(code);\n              const res = exec({ scope }).run();\n              return Array.isArray(res) ? (res as string[]) : [];\n            } catch (e) {\n              const msg = e instanceof Error ? e.message : String(e);\n              logger.error(`‚úó on_finish.run_js: evaluation failed for \"${checkName}\": ${msg}`);\n              if (e instanceof Error && e.stack) logger.debug(`Stack trace: ${e.stack}`);\n              return [];\n            }\n          };\n          // No MemoryStore in on_finish; dynamic run_js sees only outputs/outputs_history\n          const dynamicRun = await evalRunJs(onFinish.run_js);\n          const dynList = Array.from(new Set(dynamicRun.filter(Boolean)));\n          if (dynList.length > 0) {\n            logger.info(\n              `‚ñ∂ on_finish.run_js: executing [${dynList.join(', ')}] for \"${checkName}\"`\n            );\n            for (const runCheckId of dynList) {\n              if (++loopCount > maxLoops) {\n                try {\n                  logger.error(\n                    `Routing loop budget exceeded (max_loops=${maxLoops}) during on_finish run_js`\n                  );\n                } catch {}\n                // Surface a visible issue and stop scheduling more children\n                try {\n                  results.set(checkName, {\n                    issues: [\n                      {\n                        file: 'system',\n                        line: 0,\n                        ruleId: `${checkName}/routing/loop_budget_exceeded`,\n                        message: `Routing loop budget exceeded (max_loops=${maxLoops}) during on_finish run_js`,\n                        severity: 'error',\n                        category: 'logic',\n                      },\n                    ],\n                  } as ReviewSummary);\n                } catch {}\n                break;\n              }\n              logger.info(`  ‚ñ∂ Executing on_finish(run_js) check: ${runCheckId}`);\n              // Use full routing semantics for dynamic children as well\n              const childCfgFull = (config?.checks || {})[runCheckId] as\n                | import('./types/config').CheckConfig\n                | undefined;\n              if (!childCfgFull)\n                throw new Error(`Unknown check in on_finish.run_js: ${runCheckId}`);\n              const childProvType = childCfgFull.type || 'ai';\n              const childProvider = this.providerRegistry.getProviderOrThrow(childProvType);\n              this.setProviderWebhookContext(childProvider);\n              // Note: unified scheduling executes via runNamedCheck; provider config built internally\n              const depOverlayForChild = new Map(results);\n              const childRes = await this.runNamedCheck(runCheckId, [], {\n                origin: 'on_finish',\n                config: config!,\n                dependencyGraph,\n                prInfo,\n                resultsMap: results,\n                debug,\n                sessionInfo: (this.executionContext as any) || undefined,\n                overlay: depOverlayForChild,\n              });\n              try {\n                results.set(runCheckId, childRes as ReviewSummary);\n              } catch {}\n              logger.info(`  ‚úì Completed on_finish(run_js) check: ${runCheckId}`);\n            }\n          }\n        }\n\n        // After on_finish.run completes, recompute an authoritative 'all_valid' flag from\n        // the latest validate-fact history using outputs/history only (no MemoryStore).\n        let verdictLocal: boolean | undefined = undefined;\n        try {\n          const snap = this.getOutputHistorySnapshot();\n          verdictLocal = ofAllValid(snap, forEachItems.length);\n          if (typeof verdictLocal === 'boolean') {\n            logger.info(\n              `üßÆ on_finish: recomputed all_valid=${verdictLocal} from history for \"${checkName}\"`\n            );\n          }\n        } catch {}\n        // If the parent produced no items in the last wave, do not route.\n        // This prevents non-converging loops when validation is disabled or\n        // extraction yielded nothing in this stage.\n        if (forEachItems.length === 0) {\n          try {\n            logger.info(`‚è≠ on_finish: no items; skipping routing for \"${checkName}\"`);\n          } catch {}\n          continue;\n        }\n\n        // Evaluate on_finish.goto_js for routing decision\n        let gotoTarget: string | null = ofDecide(\n          checkName,\n          checkConfig,\n          outputsForContext,\n          outputsHistoryForContext,\n          { items: forEachItems },\n          prInfo,\n          config,\n          debug,\n          log\n        ).gotoTarget;\n\n        // Config-informed fallback in engine: if goto_js returned null but the\n        // configuration encodes a simple budget (\"1 + N\") and the last wave is\n        // not all-valid, route back to the parent while under budget.\n        if (!gotoTarget) {\n          try {\n            const js = String(checkConfig.on_finish?.goto_js || '');\n            let n = NaN;\n            const m = js.match(/maxWaves\\s*=\\s*1\\s*\\+\\s*(\\d+)/);\n            if (m) n = Number(m[1]);\n            if (!Number.isFinite(n)) {\n              const all = Array.from(js.matchAll(/1\\s*\\+\\s*(\\d+)/g));\n              if (all.length > 0) {\n                const last = all[all.length - 1];\n                const num = Number(last[1]);\n                if (Number.isFinite(num)) n = num;\n              }\n            }\n            if (Number.isFinite(n) && n > 0 && forEachItems.length > 0) {\n              const vf = Array.isArray(outputsHistoryForContext['validate-fact'])\n                ? (outputsHistoryForContext['validate-fact'] as unknown[]).filter(\n                    x => !Array.isArray(x)\n                  )\n                : [];\n              const items = forEachItems.length;\n              const waves = items > 0 ? Math.floor(vf.length / items) : 0;\n              const last = items > 0 ? vf.slice(-items) : [];\n              const allOk =\n                last.length === items &&\n                last.every((v: any) => v && (v.is_valid === true || v.valid === true));\n              if (!allOk && waves < 1 + Number(n)) {\n                gotoTarget = checkName;\n                if (debug)\n                  log(\n                    `üîß Debug: engine fallback ‚Üí '${checkName}' (waves=${waves} < max=${1 + Number(n)})`\n                  );\n              }\n            }\n          } catch {}\n        }\n\n        // Debug visibility removed (was [on_finish dbg]); retained via structured stats/logs above\n\n        // No engine fallback ‚Äî configuration decides routing. With per‚Äëitem\n        // outputs recorded in history, goto_js can compute waves deterministically.\n\n        // Execute routing if we have a target\n        if (gotoTarget) {\n          // Guard: do not re-route the same parent->target pair more than once per grouped run.\n          try {\n            const pairKey = `${checkName}->${gotoTarget}`;\n            if (this.postOnFinishGuards.has(pairKey)) {\n              logger.info(`‚è≠ on_finish: already routed '${pairKey}' in this run; skipping`);\n              gotoTarget = null as any;\n            } else {\n              this.postOnFinishGuards.add(pairKey);\n            }\n          } catch {}\n          // If we‚Äôre routing back to the forEach parent but the latest wave\n          // verdict (computed from outputs_history) is all valid, skip routing.\n          try {\n            logger.info(\n              `  üîí on_finish.goto guard: gotoTarget=${String(gotoTarget)} verdictLocal=${String(verdictLocal)}`\n            );\n          } catch {}\n          if (gotoTarget === checkName && verdictLocal === true) {\n            logger.info(`‚úì on_finish.goto: skipping routing to '${gotoTarget}' (all_valid=true)`);\n            gotoTarget = null as any;\n          }\n\n          // Extra deterministic guard: if the last wave of validate-fact is all valid,\n          try {\n            const __h = this.outputHistory.get('validate-fact');\n            logger.info(\n              `  üß™ on_finish.goto: validate-fact history now len=${Array.isArray(__h) ? __h.length : 0}`\n            );\n          } catch {}\n          // skip routing back to the forEach parent even if goto_js requested it.\n          try {\n            if (gotoTarget === checkName) {\n              const vfHistNow = (this.outputHistory.get('validate-fact') || []) as unknown[];\n              if (Array.isArray(vfHistNow) && forEachItems.length > 0) {\n                const verdicts = vfHistNow\n                  .map(v => (v && typeof v === 'object' ? (v as any) : undefined))\n                  .filter(\n                    v => v && (typeof v.is_valid === 'boolean' || typeof v.valid === 'boolean')\n                  )\n                  .map(v => v.is_valid === true || v.valid === true);\n                if (verdicts.length >= forEachItems.length) {\n                  const lastVerdicts = verdicts.slice(-forEachItems.length);\n                  const allTrue = lastVerdicts.every(Boolean);\n                  if (allTrue) {\n                    try {\n                      logger.info(\n                        `‚úì on_finish.goto: history verdicts all valid; skipping routing to '${gotoTarget}'`\n                      );\n                    } catch {}\n                    gotoTarget = null as any;\n                  }\n                }\n              }\n            }\n          } catch {}\n\n          // If gotoTarget was cleared (e.g., all_valid guard), skip routing\n          if (!gotoTarget) {\n            try {\n              logger.info(`‚úì on_finish.goto: no routing needed for \"${checkName}\"`);\n            } catch {}\n            continue;\n          }\n\n          // Secondary guard: if the common dependent validations history shows all items valid,\n          // avoid routing back to the forEach parent even if goto_js asked to.\n          try {\n            if (gotoTarget === checkName) {\n              const vfHist = this.outputHistory.get('validate-fact');\n              const arr = Array.isArray(vfHist) ? (vfHist as unknown[]) : [];\n              const allOk = arr.length > 0 && arr.every((v: any) => v && v.is_valid === true);\n              if (allOk) {\n                logger.info(\n                  `‚úì on_finish.goto: validate-fact history all valid; skipping routing to '${gotoTarget}'`\n                );\n                continue;\n              }\n            }\n          } catch {}\n\n          // Count toward loop budget similar to other routing paths (per-parent on_finish)\n          const maxWavesTotal = config?.routing?.max_loops ?? 10;\n          // on_finish routing consumes additional waves; budget routes = total_waves - 1\n          const maxRoutes = Math.max(0, maxWavesTotal - 1);\n          const used = (this.onFinishLoopCounts.get(checkName) || 0) + 1;\n          if (used > maxRoutes) {\n            logger.warn(\n              `‚ö†Ô∏è on_finish: route budget exceeded for \"${checkName}\" (max_routes=${maxRoutes}); last goto='${gotoTarget}'. Skipping further routing.`\n            );\n            try {\n              logger.error(\n                `Routing loop budget exceeded (max_routes=${maxRoutes}) during on_finish goto`\n              );\n            } catch {}\n            // Surface issue for tests\n            try {\n              results.set(checkName, {\n                issues: [\n                  {\n                    file: 'system',\n                    line: 0,\n                    ruleId: `${checkName}/routing/loop_budget_exceeded`,\n                    message: `Routing loop budget exceeded (max_routes=${maxRoutes}) during on_finish goto`,\n                    severity: 'error',\n                    category: 'logic',\n                  },\n                ],\n              } as ReviewSummary);\n            } catch {}\n            continue;\n          }\n          this.onFinishLoopCounts.set(checkName, used);\n\n          logger.info(\n            `‚ñ∂ on_finish: routing from \"${checkName}\" to \"${gotoTarget}\" (routes ${used}/${maxRoutes})`\n          );\n\n          try {\n            // Ensure a follow-up wave is scheduled by marking the target now.\n            // scheduleForwardRun will also mark, but this guard guarantees the\n            // post-on_finish wave loop sees a non-empty forward set even if\n            // scheduleForwardRun exits early for this origin.\n            try {\n              this.addForwardTarget(gotoTarget, []);\n            } catch {}\n            try {\n              (this as any).onFinishForwardRunSeen = true;\n            } catch {}\n            const tcfg = config.checks?.[gotoTarget as string];\n            const mode =\n              tcfg?.fanout === 'map' ? 'map' : tcfg?.reduce ? 'reduce' : tcfg?.fanout || 'default';\n            // For on_finish correction waves, include non-forEach dependents only\n            // so lightweight actions (e.g., label application) can run again\n            // while heavy per-item validators are excluded.\n            try {\n              this.forwardIncludeDependents.set(gotoTarget, true);\n              this.forwardExcludeForEachDependents.set(gotoTarget, true);\n            } catch {}\n            if (mode === 'map' && forEachItems.length > 0) {\n              for (let i = 0; i < forEachItems.length; i++) {\n                const itemScope: ScopePath = [{ check: checkName, index: i }];\n                await this.scheduleForwardRun(gotoTarget!, {\n                  origin: 'on_finish',\n                  gotoEvent: onFinish.goto_event,\n                  config,\n                  dependencyGraph,\n                  prInfo,\n                  resultsMap: results,\n                  debug,\n                  foreachScope: itemScope,\n                  sourceCheckName: checkName,\n                  sourceCheckConfig: checkConfig,\n                });\n              }\n            } else {\n              await this.scheduleForwardRun(gotoTarget!, {\n                origin: 'on_finish',\n                gotoEvent: onFinish.goto_event,\n                config,\n                dependencyGraph,\n                prInfo,\n                resultsMap: results,\n                debug,\n                foreachScope: [],\n                sourceCheckName: checkName,\n                sourceCheckConfig: checkConfig,\n              });\n            }\n\n            logger.info(`  ‚úì Routed to: ${gotoTarget}`);\n            logger.info(`  Event override: ${onFinish.goto_event || '(none)'}`);\n\n            // If we routed back to the forEach parent, proactively forward-run\n            // its immediate dependents so the next wave executes in one pass.\n            // This mirrors the grouped planner behavior and prevents a second\n            // pass from missing per-item validations in environments where only\n            // the parent would have been scheduled.\n            try {\n              if (gotoTarget === checkName && forEachItems.length > 0) {\n                const childIds: string[] = [];\n                try {\n                  for (const [id, deps] of dependencyGraph.nodes.entries()) {\n                    if (Array.isArray(deps) && deps.includes(checkName)) childIds.push(id);\n                  }\n                } catch {}\n                for (const cid of childIds) {\n                  const cCfg = config.checks?.[cid];\n                  if (!cCfg) continue;\n                  const cMode =\n                    cCfg.fanout === 'map'\n                      ? 'map'\n                      : cCfg.reduce\n                        ? 'reduce'\n                        : cCfg.fanout || 'default';\n                  if (cMode === 'map') {\n                    for (let i = 0; i < forEachItems.length; i++) {\n                      const itemScope: ScopePath = [{ check: checkName, index: i }];\n                      await this.scheduleForwardRun(cid, {\n                        origin: 'on_finish',\n                        gotoEvent: onFinish.goto_event,\n                        config,\n                        dependencyGraph,\n                        prInfo,\n                        resultsMap: results,\n                        debug,\n                        foreachScope: itemScope,\n                        sourceCheckName: checkName,\n                        sourceCheckConfig: checkConfig,\n                      });\n                    }\n                  } else {\n                    await this.scheduleForwardRun(cid, {\n                      origin: 'on_finish',\n                      gotoEvent: onFinish.goto_event,\n                      config,\n                      dependencyGraph,\n                      prInfo,\n                      resultsMap: results,\n                      debug,\n                      foreachScope: [],\n                      sourceCheckName: checkName,\n                      sourceCheckConfig: checkConfig,\n                    });\n                  }\n                }\n              }\n            } catch (err) {\n              const msg = err instanceof Error ? err.message : String(err);\n              logger.debug(`  ‚ö† on_finish: dependent forward-run error: ${msg}`);\n            }\n          } catch (error) {\n            const errorMsg = error instanceof Error ? error.message : String(error);\n            logger.error(\n              `‚úó on_finish: routing failed for \"${checkName}\" ‚Üí \"${gotoTarget}\": ${errorMsg}`\n            );\n            if (error instanceof Error && error.stack) {\n              logger.debug(`Stack trace: ${error.stack}`);\n            }\n            throw error;\n          }\n        }\n\n        logger.info(`‚úì on_finish: completed for \"${checkName}\"`);\n\n        // No hardcoded correction step here; rely on on_finish.run_js in configuration\n        // to schedule any follow-up (e.g., a correction reply) when not all facts are valid.\n      } catch (error) {\n        logger.error(`‚úó on_finish: error for \"${checkName}\": ${error}`);\n      }\n    }\n  }\n\n  // Helper: find all forEach parents that define on_finish\n  private collectForEachParentsWithOnFinish(config: VisorConfig): Array<{\n    checkName: string;\n    checkConfig: CheckConfig;\n    onFinish: OnFinishConfig;\n  }> {\n    const out: Array<{\n      checkName: string;\n      checkConfig: CheckConfig;\n      onFinish: OnFinishConfig;\n    }> = [];\n    for (const [checkName, checkConfig] of Object.entries(config.checks || {})) {\n      if (checkConfig.forEach && checkConfig.on_finish) {\n        out.push({ checkName, checkConfig, onFinish: checkConfig.on_finish });\n      }\n    }\n    return out;\n  }\n\n  // Helper: project results + history into plain objects for sandbox\n  private buildOnFinishContext(results: Map<string, ReviewSummary>): {\n    outputsForContext: Record<string, unknown>;\n    outputsHistoryForContext: Record<string, unknown[]>;\n  } {\n    const outputsForContext: Record<string, unknown> = {};\n    for (const [name, result] of results.entries()) {\n      const r = result as import('./reviewer').ReviewSummary & { output?: unknown };\n      outputsForContext[name] = r.output !== undefined ? r.output : r;\n    }\n    const outputsHistoryForContext: Record<string, unknown[]> = {};\n    try {\n      for (const [check, history] of this.outputHistory.entries()) {\n        outputsHistoryForContext[check] = history as unknown[];\n      }\n    } catch {}\n    return { outputsForContext, outputsHistoryForContext };\n  }\n\n  /**\n   * Execute a check with retry/backoff and routing semantics (on_fail/on_success)\n   */\n  private async executeWithRouting(\n    checkName: string,\n    checkConfig: CheckConfig,\n    provider: import('./providers/check-provider.interface').CheckProvider,\n    providerConfig: CheckProviderConfig,\n    prInfo: PRInfo,\n    dependencyResults: Map<string, ReviewSummary>,\n    sessionInfo: { parentSessionId?: string; reuseSession?: boolean } | undefined,\n    config: VisorConfig | undefined,\n    dependencyGraph: DependencyGraph,\n    debug?: boolean,\n    resultsMap?: Map<string, ReviewSummary>,\n    foreachContext?: { index: number; total: number; parent: string }\n  ): Promise<ReviewSummary> {\n    const log = (msg: string) =>\n      (this.config?.output?.pr_comment ? console.error : console.log)(msg);\n    const maxLoops = config?.routing?.max_loops ?? 10;\n    const defaults = config?.routing?.defaults?.on_fail || {};\n\n    const onFail: OnFailConfig | undefined = checkConfig.on_fail\n      ? { ...defaults, ...checkConfig.on_fail }\n      : Object.keys(defaults).length\n        ? defaults\n        : undefined;\n    const onSuccess: OnSuccessConfig | undefined = checkConfig.on_success;\n\n    let attempt = 1;\n    let loopCount = 0;\n    const seed = `${checkName}-${prInfo.number || 'local'}`;\n\n    const allAncestors = DependencyResolver.getAllDependencies(checkName, dependencyGraph.nodes);\n    // Expose current check's structured output to routing JS (run_js/goto_js)\n    // so templates can reference `output` similarly to `outputs` (deps).\n    let currentRouteOutput: unknown = undefined;\n\n    const evalRunJs = async (expr?: string, error?: unknown): Promise<string[]> => {\n      if (!expr) return [];\n      try {\n        const sandbox = this.getRoutingSandbox();\n        const eventObj = { name: prInfo.eventType || 'manual' } as const;\n        const outHist: Record<string, unknown[]> = {};\n        try {\n          for (const [k, v] of this.outputHistory.entries()) outHist[k] = v;\n        } catch {}\n        // Build outputs_raw object from dependencyResults (-raw aliases)\n        const outRaw: Record<string, unknown> = {};\n        try {\n          for (const [k, v] of (dependencyResults || new Map()).entries()) {\n            if (typeof k !== 'string') continue;\n            if (k.endsWith('-raw')) {\n              const name = k.slice(0, -4);\n              const val: any = (v as any)?.output !== undefined ? (v as any).output : v;\n              outRaw[name] = val;\n            }\n          }\n        } catch {}\n        const scope = {\n          step: { id: checkName, tags: checkConfig.tags || [], group: checkConfig.group },\n          attempt,\n          loop: loopCount,\n          error,\n          foreach: foreachContext\n            ? {\n                index: foreachContext.index,\n                total: foreachContext.total,\n                parent: foreachContext.parent,\n              }\n            : null,\n          outputs: Object.fromEntries((dependencyResults || new Map()).entries()),\n          outputs_history: outHist,\n          outputs_raw: outRaw,\n          output: currentRouteOutput,\n          pr: {\n            number: prInfo.number,\n            title: prInfo.title,\n            author: prInfo.author,\n            branch: prInfo.head,\n            base: prInfo.base,\n          },\n          files: prInfo.files,\n          env: getSafeEnvironmentVariables(),\n          permissions: createPermissionHelpers(\n            resolveAssociationFromEvent((prInfo as any).eventContext, prInfo.authorAssociation),\n            detectLocalMode()\n          ),\n          event: eventObj,\n        };\n        const prelude = `const step = scope.step; const attempt = scope.attempt; const loop = scope.loop; const error = scope.error; const foreach = scope.foreach; const outputs = scope.outputs; const outputs_history = scope.outputs_history; const outputs_raw = scope.outputs_raw; const output = scope.output; const pr = scope.pr; const files = scope.files; const env = scope.env; const event = scope.event; const hasMinPermission = scope.permissions.hasMinPermission; const isOwner = scope.permissions.isOwner; const isMember = scope.permissions.isMember; const isCollaborator = scope.permissions.isCollaborator; const isContributor = scope.permissions.isContributor; const isFirstTimer = scope.permissions.isFirstTimer;`;\n        const code = `${prelude}\\n${expr}`;\n        const result = compileAndRun<unknown>(\n          sandbox,\n          code,\n          { scope },\n          { injectLog: false, wrapFunction: true }\n        );\n        const res = Array.isArray(result) ? result : result ? [result] : [];\n        try {\n          if (debug || process.env.VISOR_DEBUG === 'true') {\n            const efv = (getSafeEnvironmentVariables() || {}).ENABLE_FACT_VALIDATION;\n            const hist = this.outputHistory;\n            let initLen = 0;\n            try {\n              initLen = Array.isArray(hist.get('init-fact-validation'))\n                ? (hist.get('init-fact-validation') as unknown[]).length\n                : 0;\n            } catch {}\n            log(\n              `üîß Debug: run_js(${checkName}) EFV=${String(efv)} init-fact-validation.len=${initLen} expr=${this.truncate(expr, 120)} ‚Üí [${this.redact(res)}]`\n            );\n          }\n        } catch {}\n        return Array.isArray(res) ? res.filter(x => typeof x === 'string') : [];\n      } catch (e) {\n        if (debug) {\n          log(`‚ö†Ô∏è Debug: run_js evaluation failed: ${e instanceof Error ? e.message : String(e)}`);\n        }\n        return [];\n      }\n    };\n\n    const evalGotoJs = async (expr?: string, error?: unknown): Promise<string | null> => {\n      if (!expr) return null;\n      try {\n        const sandbox = this.getRoutingSandbox();\n        const eventObj = { name: prInfo.eventType || 'manual' } as const;\n        const outHist: Record<string, unknown[]> = {};\n        try {\n          for (const [k, v] of this.outputHistory.entries()) outHist[k] = v;\n        } catch {}\n        // Build outputs_raw object from dependencyResults (-raw aliases)\n        const outRaw: Record<string, unknown> = {};\n        try {\n          for (const [k, v] of (dependencyResults || new Map()).entries()) {\n            if (typeof k !== 'string') continue;\n            if (k.endsWith('-raw')) {\n              const name = k.slice(0, -4);\n              const val: any = (v as any)?.output !== undefined ? (v as any).output : v;\n              outRaw[name] = val;\n            }\n          }\n        } catch {}\n        const scope = {\n          step: { id: checkName, tags: checkConfig.tags || [], group: checkConfig.group },\n          attempt,\n          loop: loopCount,\n          error,\n          foreach: foreachContext\n            ? {\n                index: foreachContext.index,\n                total: foreachContext.total,\n                parent: foreachContext.parent,\n              }\n            : null,\n          outputs: Object.fromEntries((dependencyResults || new Map()).entries()),\n          outputs_history: outHist,\n          outputs_raw: outRaw,\n          output: currentRouteOutput,\n          pr: {\n            number: prInfo.number,\n            title: prInfo.title,\n            author: prInfo.author,\n            branch: prInfo.head,\n            base: prInfo.base,\n          },\n          files: prInfo.files,\n          env: getSafeEnvironmentVariables(),\n          permissions: createPermissionHelpers(\n            resolveAssociationFromEvent((prInfo as any).eventContext, prInfo.authorAssociation),\n            detectLocalMode()\n          ),\n          event: eventObj,\n        };\n        const prelude2 = `const step = scope.step; const attempt = scope.attempt; const loop = scope.loop; const error = scope.error; const foreach = scope.foreach; const outputs = scope.outputs; const outputs_history = scope.outputs_history; const outputs_raw = scope.outputs_raw; const output = scope.output; const pr = scope.pr; const files = scope.files; const env = scope.env; const event = scope.event; const hasMinPermission = scope.permissions.hasMinPermission; const isOwner = scope.permissions.isOwner; const isMember = scope.permissions.isMember; const isCollaborator = scope.permissions.isCollaborator; const isContributor = scope.permissions.isContributor; const isFirstTimer = scope.permissions.isFirstTimer;`;\n        const code2 = `${prelude2}\\n${expr}`;\n        const res = compileAndRun<string | null>(\n          sandbox,\n          code2,\n          { scope },\n          { injectLog: false, wrapFunction: true }\n        );\n        if (debug) {\n          log(`üîß Debug: goto_js evaluated ‚Üí ${this.redact(res)}`);\n        }\n        return typeof res === 'string' && res ? res : null;\n      } catch (e) {\n        if (debug) {\n          log(`‚ö†Ô∏è Debug: goto_js evaluation failed: ${e instanceof Error ? e.message : String(e)}`);\n        }\n        return null;\n      }\n    };\n\n    // Phase 3: unified scheduling helper replaces inline nested executor\n\n    // Begin attempts loop\n    // We treat each retry/goto/run as consuming one loop budget entry\n    while (true) {\n      try {\n        try {\n          emitNdjsonFallback('visor.provider', {\n            'visor.check.id': checkName,\n            'visor.provider.type': providerConfig.type || 'ai',\n          });\n        } catch {}\n        const __provStart = Date.now();\n        const context: import('./providers/check-provider.interface').ExecutionContext = {\n          ...sessionInfo,\n          ...this.executionContext,\n        };\n        let res = await withActiveSpan(\n          `visor.check.${checkName}`,\n          {\n            'visor.check.id': checkName,\n            'visor.check.type': providerConfig.type || 'ai',\n            'visor.check.attempt': attempt,\n          },\n          async () => provider.execute(prInfo, providerConfig, dependencyResults, context)\n        );\n        try {\n          const anyRes: any = res as any;\n          const hasOutput = anyRes && typeof anyRes === 'object' && 'output' in anyRes;\n          const hasIssues = anyRes && typeof anyRes === 'object' && 'issues' in anyRes;\n          if (!hasOutput) {\n            res = {\n              issues: hasIssues ? anyRes.issues || [] : [],\n              output: anyRes,\n            } as any;\n          }\n        } catch {}\n        this.recordProviderDuration(checkName, Date.now() - __provStart);\n        // Expose a sensible 'output' for routing JS across all providers.\n        // Some providers (AI) return { output, issues }, others (memory/command/http) may\n        // return the value directly. Prefer explicit `output`, fall back to the whole result.\n        try {\n          const anyRes: any = res as any;\n          currentRouteOutput =\n            anyRes && typeof anyRes === 'object' && 'output' in anyRes ? anyRes.output : anyRes;\n          try {\n            if (process.env.VISOR_DEBUG === 'true') {\n              const hasOut = currentRouteOutput !== undefined;\n              console.error(\n                `[route] ${checkName} currentRouteOutput.has=${String(hasOut)} type=${typeof currentRouteOutput}`\n              );\n            }\n          } catch {}\n          // Proactively track output for grouped execution so subsequent steps\n          // (e.g., human prompts) can read outputs_history immediately. The outer\n          // level will detect __histTracked and skip double-pushing.\n          if (currentRouteOutput !== undefined) {\n            try {\n              let histVal: any = currentRouteOutput as any;\n              if (Array.isArray(histVal)) {\n                // keep as array\n              } else if (histVal !== null && typeof histVal === 'object') {\n                histVal = { ...histVal };\n                if ((histVal as any).ts === undefined) (histVal as any).ts = Date.now();\n              } else {\n                histVal = { text: String(histVal), ts: Date.now() };\n              }\n              this.trackOutputHistory(checkName, histVal);\n              try {\n                (res as any).__histTracked = true;\n              } catch {}\n            } catch {}\n          }\n          if (\n            checkName === 'aggregate-validations' &&\n            (process.env.VISOR_DEBUG === 'true' || debug)\n          ) {\n            try {\n              logger.info(\n                '[aggregate-validations] route-output = ' + JSON.stringify(currentRouteOutput)\n              );\n            } catch {}\n          }\n        } catch {}\n        // Success path\n        // Treat result issues with severity error/critical as a soft-failure eligible for on_fail routing\n        const hasSoftFailure = (res.issues || []).some(\n          i => i.severity === 'error' || i.severity === 'critical'\n        );\n        if (hasSoftFailure && onFail) {\n          if (debug)\n            log(\n              `üîß Debug: Soft failure detected f|| '${checkName}' with ${(res.issues || []).length} issue(s)`\n            );\n          const lastError: any = {\n            message: 'soft-failure: issues present',\n            code: 'soft_failure',\n            issues: res.issues,\n          };\n          const dynamicRun = await evalRunJs(onFail.run_js, lastError);\n          let runList = [...(onFail.run || []), ...dynamicRun].filter(Boolean);\n          runList = Array.from(new Set(runList));\n          if (debug) log(`üîß Debug: on_fail.run (soft) list = [${runList.join(', ')}]`);\n          if (runList.length > 0) {\n            try {\n              require('./logger').logger.info(\n                `‚ñ∂ on_fail.run: scheduling [${runList.join(', ')}] after '${checkName}'`\n              );\n            } catch {}\n            loopCount++;\n            if (loopCount > maxLoops) {\n              return {\n                issues: [\n                  {\n                    file: 'system',\n                    line: 0,\n                    ruleId: `${checkName}/routing/loop_budget_exceeded`,\n                    message: `Routing loop budget exceeded (max_loops=${maxLoops}) during on_fail run`,\n                    severity: 'error',\n                    category: 'logic',\n                  },\n                ],\n              } as ReviewSummary;\n            }\n            if (debug) log(`üîß Debug: on_fail.run (soft) executing [${runList.join(', ')}]`);\n            for (const stepId of runList) {\n              const tcfg = config!.checks?.[stepId] as\n                | import('./types/config').CheckConfig\n                | undefined;\n              const mode =\n                tcfg?.fanout === 'map'\n                  ? 'map'\n                  : tcfg?.reduce\n                    ? 'reduce'\n                    : tcfg?.fanout || 'default';\n              const inItem = !!foreachContext;\n              const items =\n                checkConfig.forEach && Array.isArray(currentRouteOutput)\n                  ? (currentRouteOutput as unknown[])\n                  : [];\n              if (!inItem && mode === 'map' && items.length > 0) {\n                for (let i = 0; i < items.length; i++) {\n                  const itemScope: ScopePath = [{ check: checkName, index: i }];\n                  await this.runNamedCheck(stepId, itemScope, {\n                    config: config!,\n                    dependencyGraph,\n                    prInfo,\n                    resultsMap: resultsMap || new Map(),\n                    debug: !!debug,\n                    overlay: dependencyResults,\n                  });\n                }\n              } else {\n                const scopeForRun: ScopePath = foreachContext\n                  ? [{ check: foreachContext.parent, index: foreachContext.index }]\n                  : [];\n                await this.runNamedCheck(stepId, scopeForRun, {\n                  config: config!,\n                  dependencyGraph,\n                  prInfo,\n                  resultsMap: resultsMap || new Map(),\n                  debug: !!debug,\n                  overlay: dependencyResults,\n                });\n              }\n            }\n          }\n          let target = await evalGotoJs(onFail.goto_js, lastError);\n          if (!target && onFail.goto) target = onFail.goto;\n          if (debug) log(`üîß Debug: on_fail.goto (soft) target = ${target}`);\n          if (target) {\n            try {\n              require('./logger').logger.info(\n                `‚Ü™ on_fail.goto: jumping to '${target}' from '${checkName}'`\n              );\n            } catch {}\n            if (!allAncestors.includes(target)) {\n              // New behavior: allow goto to any step and forward-run dependents\n              await this.scheduleForwardRun(target, {\n                origin: 'on_fail',\n                gotoEvent: onFail.goto_event,\n                config: config!,\n                dependencyGraph,\n                prInfo,\n                resultsMap: resultsMap || new Map(),\n                debug: !!debug,\n                foreachScope: foreachContext\n                  ? [{ check: foreachContext.parent, index: foreachContext.index }]\n                  : undefined,\n                sourceCheckName: checkName,\n                sourceCheckConfig: checkConfig,\n                sourceOutputForItems: currentRouteOutput,\n              });\n            } else {\n              // Run ancestor targets through the forward-run scheduler as well, so the\n              // entire dependent chain (target + transitive dependents) executes in the\n              // next wave. This keeps execution order deterministic and test counts stable.\n              loopCount++;\n              if (loopCount > maxLoops) {\n                throw new Error(\n                  `Routing loop budget exceeded (max_loops=${maxLoops}) during on_fail goto`\n                );\n              }\n              await this.scheduleForwardRun(target, {\n                origin: 'on_fail',\n                gotoEvent: onFail.goto_event,\n                config: config!,\n                dependencyGraph,\n                prInfo,\n                resultsMap: resultsMap || new Map(),\n                debug: !!debug,\n                foreachScope: foreachContext\n                  ? [{ check: foreachContext.parent, index: foreachContext.index }]\n                  : undefined,\n                sourceCheckName: checkName,\n                sourceCheckConfig: checkConfig,\n                sourceOutputForItems: currentRouteOutput,\n              });\n            }\n          }\n\n          const retryMax = onFail.retry?.max ?? 0;\n          const base = onFail.retry?.backoff?.delay_ms ?? 0;\n          const mode = onFail.retry?.backoff?.mode ?? 'fixed';\n          if (attempt <= retryMax) {\n            loopCount++;\n            if (loopCount > maxLoops) {\n              throw new Error(`Routing loop budget exceeded (max_loops=${maxLoops}) during retry`);\n            }\n            const delay = base > 0 ? this.computeBackoffDelay(attempt, mode, base, seed) : 0;\n            if (debug)\n              log(\n                `üîÅ Debug: retrying '${checkName}' (soft) attempt ${attempt + 1}/${retryMax + 1} after ${delay}ms`\n              );\n            if (delay > 0) await this.sleep(delay);\n            attempt++;\n            continue; // loop\n          }\n          // No retry configured: return existing result\n          return res;\n        }\n        // Note: previously we re-ran the source check after goto to \"re-validate with new state\".\n        // This caused success‚Üígoto‚Üíre-run loops for unconditional gotos. We no longer re-run the\n        // source after goto; goto only schedules the target and returns.\n        if (onSuccess) {\n          // Gating for inline on_success handling based on origin:\n          //  - origin === 'on_success': suppress entirely; scheduleForwardRun will handle dependents/goto.\n          //  - origin === 'on_fail': allow on_success.run (side-effects) but suppress goto to avoid tight loops.\n          const __suppressAllOnSuccess = ((context as any).origin || 'inline') === 'on_success';\n          const __suppressGotoOnSuccess = ((context as any).origin || 'inline') === 'on_fail';\n          if (!__suppressAllOnSuccess) {\n            // Compute run list\n            const dynamicRun = await evalRunJs(onSuccess.run_js);\n            let runList = [...(onSuccess.run || []), ...dynamicRun].filter(Boolean);\n            try {\n              if (process.env.VISOR_DEBUG === 'true' || debug) {\n                logger.info(\n                  `on_success.run (${checkName}): dynamicRun=[${dynamicRun.join(', ')}] run=[${(\n                    onSuccess.run || []\n                  ).join(', ')}]`\n                );\n              }\n            } catch {}\n            // Deduplicate requested steps; rely on per-step max_runs/one_shot tags instead of hardcoded names\n            runList = Array.from(new Set(runList));\n            if (runList.length > 0) {\n              try {\n                require('./logger').logger.info(\n                  `‚ñ∂ on_success.run: scheduling [${Array.from(new Set(runList)).join(', ')}] after '${checkName}'`\n                );\n              } catch {}\n              loopCount++;\n              if (loopCount > maxLoops) {\n                const issueSummary = {\n                  issues: [\n                    {\n                      file: 'system',\n                      line: 0,\n                      ruleId: `${checkName}/routing/loop_budget_exceeded`,\n                      message: `Routing loop budget exceeded (max_loops=${maxLoops}) during on_success run`,\n                      severity: 'error',\n                      category: 'logic',\n                    },\n                  ],\n                } as ReviewSummary;\n                try {\n                  if (resultsMap) resultsMap.set(checkName, issueSummary);\n                } catch {}\n                return issueSummary;\n              }\n              for (const stepId of runList) {\n                // One-shot guard (generalized): if the target step has a 'one_shot' tag\n                // and it already executed in this run, skip rescheduling it.\n                try {\n                  const tcfg = (config!.checks || {})[stepId] as\n                    | import('./types/config').CheckConfig\n                    | undefined;\n                  const tags = (tcfg?.tags || []) as string[];\n                  const isOneShot = Array.isArray(tags) && tags.includes('one_shot');\n                  if (isOneShot && (this.executionStats.get(stepId)?.totalRuns || 0) > 0) {\n                    require('./logger').logger.info(\n                      `‚è≠ on_success.run: skipping one_shot '${stepId}' (already executed)`\n                    );\n                    continue;\n                  }\n                } catch {}\n                const tcfg = config!.checks?.[stepId] as\n                  | import('./types/config').CheckConfig\n                  | undefined;\n                const mode =\n                  tcfg?.fanout === 'map'\n                    ? 'map'\n                    : tcfg?.reduce\n                      ? 'reduce'\n                      : tcfg?.fanout || 'default';\n                const inItem = !!foreachContext;\n                const items =\n                  checkConfig.forEach && Array.isArray(currentRouteOutput)\n                    ? (currentRouteOutput as unknown[])\n                    : [];\n                if (!inItem && mode === 'map' && items.length > 0) {\n                  for (let i = 0; i < items.length; i++) {\n                    const itemScope: ScopePath = [{ check: checkName, index: i }];\n                    await this.runNamedCheck(stepId, itemScope, {\n                      config: config!,\n                      dependencyGraph,\n                      prInfo,\n                      resultsMap: resultsMap || new Map(),\n                      debug: !!debug,\n                      overlay: dependencyResults,\n                    });\n                  }\n                } else {\n                  const scopeForRun: ScopePath = foreachContext\n                    ? [{ check: foreachContext.parent, index: foreachContext.index }]\n                    : [];\n                  await this.runNamedCheck(stepId, scopeForRun, {\n                    config: config!,\n                    dependencyGraph,\n                    prInfo,\n                    resultsMap: resultsMap || new Map(),\n                    debug: !!debug,\n                    overlay: dependencyResults,\n                  });\n                }\n              }\n            } else {\n              // Provide a lightweight reason when nothing is scheduled via on_success.run\n              try {\n                const assoc = resolveAssociationFromEvent(\n                  (prInfo as any)?.eventContext,\n                  prInfo.authorAssociation\n                );\n                const perms = createPermissionHelpers(assoc, detectLocalMode());\n                const allowedMember = perms.hasMinPermission('MEMBER');\n                let intent: string | undefined;\n                try {\n                  intent = (res as any)?.output?.intent;\n                } catch {}\n                require('./logger').logger.info(\n                  `‚è≠ on_success.run: none after '${checkName}' (event=${prInfo.eventType || 'manual'}, intent=${intent || 'n/a'}, assoc=${assoc || 'unknown'}, memberOrHigher=${allowedMember})`\n                );\n              } catch {}\n            }\n          }\n          // Optional goto\n          if (!__suppressAllOnSuccess && !__suppressGotoOnSuccess) {\n            let target = await evalGotoJs(onSuccess.goto_js);\n            if (!target && onSuccess.goto) target = onSuccess.goto;\n            if (target) {\n              try {\n                require('./logger').logger.info(\n                  `‚Ü™ on_success.goto: jumping to '${target}' from '${checkName}'`\n                );\n              } catch {}\n              if (!allAncestors.includes(target)) {\n                await this.scheduleForwardRun(target, {\n                  origin: 'on_success',\n                  gotoEvent: onSuccess.goto_event,\n                  config: config!,\n                  dependencyGraph,\n                  prInfo,\n                  resultsMap: resultsMap || new Map(),\n                  debug: !!debug,\n                  foreachScope: foreachContext\n                    ? [{ check: foreachContext.parent, index: foreachContext.index }]\n                    : undefined,\n                  sourceCheckName: checkName,\n                  sourceCheckConfig: checkConfig,\n                  sourceOutputForItems: currentRouteOutput,\n                });\n              } else {\n                loopCount++;\n                if (loopCount > maxLoops) {\n                  const issueSummary = {\n                    issues: [\n                      {\n                        file: 'system',\n                        line: 0,\n                        ruleId: `${checkName}/routing/loop_budget_exceeded`,\n                        message: `Routing loop budget exceeded (max_loops=${maxLoops}) during on_success goto`,\n                        severity: 'error',\n                        category: 'logic',\n                      },\n                    ],\n                  } as ReviewSummary;\n                  try {\n                    if (resultsMap) resultsMap.set(checkName, issueSummary);\n                  } catch {}\n                  return issueSummary;\n                }\n                // on_success.goto does not support retry/backoff in schema; immediate rerun for ancestor case\n                await this.runNamedCheck(\n                  target,\n                  foreachContext\n                    ? [{ check: foreachContext.parent, index: foreachContext.index }]\n                    : [],\n                  {\n                    config: config!,\n                    dependencyGraph,\n                    prInfo,\n                    resultsMap: resultsMap || new Map(),\n                    debug: !!debug,\n                    eventOverride: onSuccess.goto_event,\n                  }\n                );\n              }\n            }\n          }\n        }\n        // No re-run after goto\n        return res;\n      } catch (err) {\n        // Failure path\n        if (!onFail) {\n          throw err; // no routing policy\n        }\n\n        const lastError = err instanceof Error ? err : new Error(String(err));\n\n        // Dynamic compute run/goto\n        const dynamicRun = await evalRunJs(onFail.run_js, lastError);\n        let runList = [...(onFail.run || []), ...dynamicRun].filter(Boolean);\n        // Dedup while preserving order\n        runList = Array.from(new Set(runList));\n\n        if (runList.length > 0) {\n          try {\n            require('./logger').logger.info(\n              `‚ñ∂ on_fail.run: scheduling [${runList.join(', ')}] after '${checkName}'`\n            );\n          } catch {}\n          loopCount++;\n          if (loopCount > maxLoops) {\n            throw new Error(\n              `Routing loop budget exceeded (max_loops=${maxLoops}) during on_fail run`\n            );\n          }\n          if (debug) log(`üîß Debug: on_fail.run executing [${runList.join(', ')}]`);\n          for (const stepId of runList) {\n            await this.runNamedCheck(stepId, [], {\n              config: config!,\n              dependencyGraph,\n              prInfo,\n              resultsMap: resultsMap || new Map(),\n              debug: !!debug,\n            });\n          }\n        }\n\n        let target = await evalGotoJs(onFail.goto_js, lastError);\n        if (!target && onFail.goto) target = onFail.goto;\n        if (target) {\n          try {\n            require('./logger').logger.info(\n              `‚Ü™ on_fail.goto: jumping to '${target}' from '${checkName}'`\n            );\n          } catch {}\n          if (!allAncestors.includes(target)) {\n            await this.scheduleForwardRun(target, {\n              origin: 'on_fail',\n              gotoEvent: onFail.goto_event,\n              config: config!,\n              dependencyGraph,\n              prInfo,\n              resultsMap: resultsMap || new Map(),\n              debug: !!debug,\n              foreachScope: [],\n              sourceCheckName: checkName,\n              sourceCheckConfig: checkConfig,\n              sourceOutputForItems: undefined,\n            });\n          } else {\n            loopCount++;\n            if (loopCount > maxLoops) {\n              return {\n                issues: [\n                  {\n                    file: 'system',\n                    line: 0,\n                    ruleId: `${checkName}/routing/loop_budget_exceeded`,\n                    message: `Routing loop budget exceeded (max_loops=${maxLoops}) during on_fail goto`,\n                    severity: 'error',\n                    category: 'logic',\n                  },\n                ],\n              } as ReviewSummary;\n            }\n            await this.runNamedCheck(target, [], {\n              config: config!,\n              dependencyGraph,\n              prInfo,\n              resultsMap: resultsMap || new Map(),\n              debug: !!debug,\n              eventOverride: onFail.goto_event,\n              overlay: dependencyResults,\n            });\n          }\n        }\n\n        // Retry if allowed\n        const retryMax = onFail.retry?.max ?? 0;\n        const base = onFail.retry?.backoff?.delay_ms ?? 0;\n        const mode = onFail.retry?.backoff?.mode ?? 'fixed';\n        if (attempt <= retryMax) {\n          loopCount++;\n          if (loopCount > maxLoops) {\n            return {\n              issues: [\n                {\n                  file: 'system',\n                  line: 0,\n                  ruleId: `${checkName}/routing/loop_budget_exceeded`,\n                  message: `Routing loop budget exceeded (max_loops=${maxLoops}) during retry`,\n                  severity: 'error',\n                  category: 'logic',\n                },\n              ],\n            } as ReviewSummary;\n          }\n          const delay = base > 0 ? this.computeBackoffDelay(attempt, mode, base, seed) : 0;\n          if (debug)\n            log(\n              `üîÅ Debug: retrying '${checkName}' attempt ${attempt + 1}/${retryMax + 1} after ${delay}ms`\n            );\n          if (delay > 0) await this.sleep(delay);\n          attempt++;\n          continue; // loop\n        }\n\n        // Exhausted retry budget; rethrow\n        throw lastError;\n      }\n    }\n  }\n\n  /**\n   * Set webhook context on a provider if it supports it\n   */\n  private setProviderWebhookContext(\n    provider: import('./providers/check-provider.interface').CheckProvider\n  ): void {\n    if (this.webhookContext && provider.setWebhookContext) {\n      provider.setWebhookContext(this.webhookContext.webhookData);\n    }\n  }\n\n  /**\n   * Filter checks based on tag filter configuration\n   */\n  private filterChecksByTags(\n    checks: string[],\n    config: import('./types/config').VisorConfig | undefined,\n    tagFilter: import('./types/config').TagFilter | undefined\n  ): string[] {\n    // When no tag filter is specified, include only untagged checks by default.\n    // Tagged checks are opt-in unless tag_filter is provided.\n    return checks.filter(checkName => {\n      const checkConfig = config?.checks?.[checkName];\n      if (!checkConfig) {\n        // If no config for this check, include it by default\n        return true;\n      }\n\n      const checkTags = checkConfig.tags || [];\n\n      // If no tag filter is specified, include only untagged checks.\n      if (!tagFilter || (!tagFilter.include && !tagFilter.exclude)) {\n        return checkTags.length === 0;\n      }\n\n      // If check has no tags and a tag filter is specified, include it (untagged checks always run)\n      if (checkTags.length === 0) {\n        return true;\n      }\n\n      // Check exclude tags first (if any exclude tag matches, skip the check)\n      if (tagFilter.exclude && tagFilter.exclude.length > 0) {\n        const hasExcludedTag = tagFilter.exclude.some(tag => checkTags.includes(tag));\n        if (hasExcludedTag) return false;\n      }\n\n      // Check include tags (if specified, at least one must match)\n      if (tagFilter.include && tagFilter.include.length > 0) {\n        const hasIncludedTag = tagFilter.include.some(tag => checkTags.includes(tag));\n        if (!hasIncludedTag) return false;\n      }\n\n      return true;\n    });\n  }\n\n  // Resolve a sensible fallback goto target without hardcoding names.\n  // Strategy: inspect the current check's depends_on list and expand any\n  // union tokens (e.g., \"a|b\"). Prefer a dependency whose `on` includes the\n  // current event; otherwise, fall back to the first existing dependency.\n  private resolveFallbackGotoTarget(\n    checkConfig: import('./types/config').CheckConfig,\n    prInfo: PRInfo,\n    config: import('./types/config').VisorConfig\n  ): string | null {\n    try {\n      const depTokens: any[] = Array.isArray(checkConfig.depends_on)\n        ? checkConfig.depends_on\n        : checkConfig.depends_on\n          ? [checkConfig.depends_on]\n          : [];\n      const expand = (tok: any): string[] =>\n        typeof tok === 'string' && tok.includes('|')\n          ? tok\n              .split('|')\n              .map(s => s.trim())\n              .filter(Boolean)\n          : tok\n            ? [String(tok)]\n            : [];\n      const candidates = depTokens.flatMap(expand).filter(Boolean) as string[];\n      if (candidates.length === 0) return null;\n      const event = prInfo.eventType || 'manual';\n      const matchEvent = (name: string): boolean => {\n        const cfg = (config.checks || {})[name];\n        if (!cfg) return false;\n        const triggers: any[] = Array.isArray(cfg.on) ? (cfg.on as any[]) : cfg.on ? [cfg.on] : [];\n        if (triggers.length === 0) return true; // treat untagged as match-all\n        return triggers.includes(event as any);\n      };\n      for (const n of candidates) if ((config.checks || {})[n] && matchEvent(n)) return n;\n      for (const n of candidates) if ((config.checks || {})[n]) return n;\n      return null;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Execute checks on the local repository\n   */\n  async executeChecks(options: CheckExecutionOptions): Promise<AnalysisResult> {\n    const startTime = Date.now();\n    const timestamp = new Date().toISOString();\n\n    try {\n      // Expose CLI debug to internal helpers for ad-hoc diagnostics\n      try {\n        (this as any).globalDebug = Boolean((options as any)?.debug);\n      } catch {}\n      // Fresh in-memory state for every engine execution.\n      // Do not wipe file-based state here; tests can clean those explicitly.\n      try {\n        const storage = options.config?.memory?.storage || 'memory';\n        if (storage !== 'file') {\n          MemoryStore.resetInstance();\n        }\n      } catch {}\n\n      // Initialize memory store if configured\n      if (options.config?.memory) {\n        const memoryStore = MemoryStore.getInstance(options.config.memory);\n        await memoryStore.initialize();\n        logger.debug('Memory store initialized');\n      }\n\n      // Set custom tools if configured\n      if (options.config?.tools) {\n        this.providerRegistry.setCustomTools(options.config.tools);\n        logger.debug(`Registered ${Object.keys(options.config.tools).length} custom tools`);\n      }\n\n      // Reset per-run on_finish loop counters\n      this.onFinishLoopCounts.clear();\n      // Reset per-run forEach wave counters\n      this.forEachWaveCounts.clear();\n      // Store webhook context if provided\n      this.webhookContext = options.webhookContext;\n\n      // Determine where to send log messages based on output format\n      const logFn = (msg: string) => logger.info(msg);\n\n      // Initialize GitHub checks if enabled\n      if (options.githubChecks?.enabled && options.githubChecks.octokit) {\n        await this.initializeGitHubChecks(options, logFn);\n      }\n\n      // Analyze the repository\n      logFn('üîç Analyzing local git repository...');\n      const repositoryInfo = await this.gitAnalyzer.analyzeRepository();\n\n      if (!repositoryInfo.isGitRepository) {\n        // Complete GitHub checks with error if they were initialized\n        if (this.checkRunMap) {\n          await this.completeGitHubChecksWithError('Not a git repository or no changes found');\n        }\n\n        return this.createErrorResult(\n          repositoryInfo,\n          'Not a git repository or no changes found',\n          startTime,\n          timestamp,\n          options.checks\n        );\n      }\n\n      // Convert to PRInfo format for compatibility with existing reviewer\n      const prInfo = this.gitAnalyzer.toPRInfo(repositoryInfo);\n      // If caller provided an explicit event type (e.g., tests/CLI manual runs),\n      // propagate it into PRInfo so event-based filtering treats 'manual' checks\n      // as eligible. This keeps unit/integration tests deterministic without\n      // relaxing the conservative filtering policy.\n      try {\n        const evt = (options.webhookContext as any)?.eventType;\n        if (evt) (prInfo as any).eventType = evt;\n      } catch {}\n\n      // Apply tag filtering if specified\n      const filteredChecks = this.filterChecksByTags(\n        options.checks,\n        options.config,\n        options.tagFilter || options.config?.tag_filter\n      );\n\n      if (filteredChecks.length === 0) {\n        logger.warn('‚ö†Ô∏è No checks match the tag filter criteria');\n        // Complete GitHub checks with no checks message if they were initialized\n        if (this.checkRunMap) {\n          await this.completeGitHubChecksWithError('No checks match the tag filter criteria');\n        }\n        return this.createErrorResult(\n          repositoryInfo,\n          'No checks match the tag filter criteria',\n          startTime,\n          timestamp,\n          options.checks\n        );\n      }\n\n      // Update GitHub checks to in-progress status\n      if (this.checkRunMap) {\n        await this.updateGitHubChecksInProgress(options);\n      }\n\n      // Execute checks using the existing PRReviewer\n      logFn(`ü§ñ Executing checks: ${filteredChecks.join(', ')}`);\n      const reviewSummary = await this.executeReviewChecks(\n        prInfo,\n        filteredChecks,\n        options.timeout,\n        options.config,\n        options.outputFormat,\n        options.debug,\n        options.maxParallelism,\n        options.failFast\n      );\n\n      // Complete GitHub checks with results\n      if (this.checkRunMap) {\n        await this.completeGitHubChecksWithResults(reviewSummary, options, prInfo);\n      }\n\n      const executionTime = Date.now() - startTime;\n\n      // Collect debug information when debug mode is enabled\n      let debugInfo: import('./output-formatters').DebugInfo | undefined;\n      if (options.debug && reviewSummary.debug) {\n        debugInfo = {\n          provider: reviewSummary.debug.provider,\n          model: reviewSummary.debug.model,\n          processingTime: reviewSummary.debug.processingTime,\n          parallelExecution: options.checks.length > 1,\n          checksExecuted: options.checks,\n          totalApiCalls: reviewSummary.debug.totalApiCalls || options.checks.length,\n          apiCallDetails: reviewSummary.debug.apiCallDetails,\n        };\n      }\n\n      // Build execution statistics\n      const executionStatistics = this.buildExecutionStatistics();\n\n      // Expose a snapshot of outputs history in the reviewSummary.\n      // Fill missing entries using execution statistics so tests that assert\n      // on run counts (by history length) are stable even if providers didn't\n      // emit outputs on every run.\n      try {\n        const histSnap = this.getOutputHistorySnapshot();\n        try {\n          const stats = this.buildExecutionStatistics();\n          for (const s of stats.checks) {\n            const name = s.checkName;\n            const want = Math.max(0, s.totalRuns || 0);\n            const have = Array.isArray(histSnap[name]) ? histSnap[name].length : 0;\n            if (want > have) {\n              const arr = Array.isArray(histSnap[name]) ? histSnap[name] : [];\n              for (let i = have; i < want; i++) arr.push(null);\n              histSnap[name] = arr;\n            }\n          }\n        } catch {}\n        (reviewSummary as any).history = histSnap;\n      } catch {}\n\n      return {\n        repositoryInfo,\n        reviewSummary,\n        executionTime,\n        timestamp,\n        checksExecuted: filteredChecks,\n        executionStatistics,\n        debug: debugInfo,\n      };\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Unknown error occurred';\n      logger.error('Error executing checks: ' + message);\n\n      // Complete GitHub checks with error if they were initialized\n      if (this.checkRunMap) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n        await this.completeGitHubChecksWithError(errorMessage);\n      }\n\n      // In strict test modes, surface provider/engine errors to callers so tests fail fast.\n      // Triggers when running via Jest, our YAML test runner (VISOR_TEST_MODE), or explicit opt‚Äëin.\n      const strictEnv = process.env.VISOR_STRICT_ERRORS === 'true';\n      if (strictEnv) {\n        throw error;\n      }\n\n      const fallbackRepositoryInfo: GitRepositoryInfo = {\n        title: 'Error during analysis',\n        body: `Error: ${message || 'Unknown error'}`,\n        author: 'system',\n        base: 'main',\n        head: 'HEAD',\n        files: [],\n        totalAdditions: 0,\n        totalDeletions: 0,\n        isGitRepository: false,\n        workingDirectory: options.workingDirectory || process.cwd(),\n      };\n\n      return this.createErrorResult(\n        fallbackRepositoryInfo,\n        message || 'Unknown error occurred',\n        startTime,\n        timestamp,\n        options.checks\n      );\n    }\n  }\n\n  /**\n   * Execute tasks with controlled parallelism using a pool pattern\n   */\n  private async executeWithLimitedParallelism<T>(\n    tasks: (() => Promise<T>)[],\n    maxParallelism: number,\n    failFast?: boolean\n  ): Promise<PromiseSettledResult<T>[]> {\n    // If there is nothing to do, return early before validating parallelism.\n    // This avoids spuriously throwing when the caller computed 0 parallelism\n    // for an empty task set (which is a valid no-op scenario).\n    if (tasks.length === 0) {\n      return [];\n    }\n\n    // Validate pool size only when there is work to run.\n    if (maxParallelism <= 0) {\n      // Be forgiving and default to 1 instead of throwing ‚Äî callers may\n      // derive parallelism from dynamic level sizes that occasionally\n      // evaluate to 0. With tasks present, we need at least one worker.\n      maxParallelism = 1;\n    }\n\n    const results: PromiseSettledResult<T>[] = new Array(tasks.length);\n    let currentIndex = 0;\n    let shouldStop = false;\n\n    // Worker function that processes tasks\n    const worker = async (): Promise<void> => {\n      while (currentIndex < tasks.length && !shouldStop) {\n        const taskIndex = currentIndex++;\n        if (taskIndex >= tasks.length) break;\n\n        try {\n          const result = await tasks[taskIndex]();\n          results[taskIndex] = { status: 'fulfilled', value: result };\n\n          // Check if we should stop due to fail-fast\n          if (failFast && this.shouldFailFast(result)) {\n            shouldStop = true;\n            break;\n          }\n        } catch (error) {\n          results[taskIndex] = { status: 'rejected', reason: error };\n\n          // If fail-fast is enabled and we have an error, stop execution\n          if (failFast) {\n            shouldStop = true;\n            break;\n          }\n        }\n      }\n    };\n\n    // Create workers up to the parallelism limit\n    const workers: Promise<void>[] = [];\n    const workerCount = Math.min(maxParallelism, tasks.length);\n\n    for (let i = 0; i < workerCount; i++) {\n      workers.push(worker());\n    }\n\n    // Wait for all workers to complete\n    await Promise.all(workers);\n\n    return results;\n  }\n\n  /**\n   * Execute review checks using parallel execution for multiple AI checks\n   */\n  private async executeReviewChecks(\n    prInfo: PRInfo,\n    checks: string[],\n    timeout?: number,\n    config?: import('./types/config').VisorConfig,\n    outputFormat?: string,\n    debug?: boolean,\n    maxParallelism?: number,\n    failFast?: boolean\n  ): Promise<ReviewSummary> {\n    // Store config for use in filtering\n    this.config = config;\n\n    // Make provider-level debug discoverable to providers when engine debug is enabled.\n    // This lets AI providers emit per-call debug info used by E2E tests.\n    try {\n      if (debug) process.env.VISOR_PROVIDER_DEBUG = 'true';\n    } catch {}\n\n    // Determine where to send log messages based on output format\n    // Use debug logger for internal engine messages; important notices use logger.warn/info directly.\n    const logFn = (msg: string) => logger.debug(msg);\n\n    // Only output debug messages if debug mode is enabled\n    if (debug) {\n      logFn(`üîß Debug: executeReviewChecks called with checks: ${JSON.stringify(checks)}`);\n      logFn(`üîß Debug: Config available: ${!!config}, Config has checks: ${!!config?.checks}`);\n    }\n\n    // Filter checks based on current event type to prevent execution of checks that shouldn't run\n    const filteredChecks = this.filterChecksByEvent(checks, config, prInfo, logFn, debug);\n    if (filteredChecks.length !== checks.length && debug) {\n      logFn(\n        `üîß Debug: Event filtering reduced checks from ${checks.length} to ${filteredChecks.length}: ${JSON.stringify(filteredChecks)}`\n      );\n    }\n\n    // Use filtered checks for execution\n    checks = filteredChecks;\n\n    // If we have a config with individual check definitions, prefer dependency-aware execution\n    // even for a single check, so provider types other than 'ai' work consistently.\n    const allConfigured = config?.checks ? checks.every(name => !!config.checks![name]) : false;\n    if (allConfigured) {\n      if (debug) {\n        logFn(\n          `üîß Debug: Using dependency-aware execution for ${checks.length} configured check(s)`\n        );\n      }\n      return await this.executeDependencyAwareChecks(\n        prInfo,\n        checks,\n        timeout,\n        config,\n        logFn,\n        debug,\n        maxParallelism,\n        failFast,\n        config?.tag_filter\n      );\n    }\n\n    // Single check execution (existing logic)\n    if (checks.length === 1) {\n      if (debug) {\n        logFn(`üîß Debug: Using single check execution for: ${checks[0]}`);\n      }\n\n      // If we have a config definition for this check, use it\n      if (config?.checks?.[checks[0]]) {\n        return await this.executeSingleConfiguredCheck(prInfo, checks[0], timeout, config, logFn);\n      }\n\n      // Try provider system for single checks\n      if (this.providerRegistry.hasProvider(checks[0])) {\n        const provider = this.providerRegistry.getProviderOrThrow(checks[0]);\n        this.setProviderWebhookContext(provider);\n        const providerConfig: CheckProviderConfig = {\n          type: checks[0],\n          prompt: 'all',\n          eventContext: this.enrichEventContext(prInfo.eventContext),\n          ai: timeout ? { timeout } : undefined,\n        };\n        const __provStart = Date.now();\n        const result = await provider.execute(\n          prInfo,\n          providerConfig,\n          undefined,\n          this.executionContext\n        );\n        this.recordProviderDuration(checks[0], Date.now() - __provStart);\n\n        // Prefix issues with check name for consistent grouping\n        const prefixedIssues = (result.issues || []).map(issue => ({\n          ...issue,\n          ruleId: `${checks[0]}/${issue.ruleId}`,\n        }));\n\n        return {\n          ...result,\n          issues: prefixedIssues,\n        };\n      }\n    }\n\n    // Check if 'ai' provider is available for focus-based checks (legacy support)\n    if (this.providerRegistry.hasProvider('ai')) {\n      if (debug) {\n        logFn(`üîß Debug: Using AI provider with focus mapping`);\n      }\n      const provider = this.providerRegistry.getProviderOrThrow('ai');\n      this.setProviderWebhookContext(provider);\n\n      let focus = 'all';\n      let checkName = 'all';\n      if (checks.length === 1) {\n        checkName = checks[0];\n        if (checks[0] === 'security' || checks[0] === 'performance' || checks[0] === 'style') {\n          focus = checks[0];\n        }\n      } else {\n        // For multiple checks, combine them into 'all' focus\n        focus = 'all';\n      }\n\n      const providerConfig: CheckProviderConfig = {\n        type: 'ai',\n        prompt: focus,\n        focus: focus,\n        checkName,\n        eventContext: this.enrichEventContext(prInfo.eventContext),\n        ai: timeout ? { timeout } : undefined,\n        // Inherit global AI provider and model settings if config is available\n        ai_provider: config?.ai_provider,\n        ai_model: config?.ai_model,\n      };\n\n      const __provStart2 = Date.now();\n      const result = await provider.execute(\n        prInfo,\n        providerConfig,\n        undefined,\n        this.executionContext\n      );\n      this.recordProviderDuration(checkName, Date.now() - __provStart2);\n\n      // Prefix issues with check name for consistent grouping\n      const prefixedIssues = (result.issues || []).map(issue => ({\n        ...issue,\n        ruleId: `${checkName}/${issue.ruleId}`,\n      }));\n\n      return {\n        ...result,\n        issues: prefixedIssues,\n      };\n    }\n\n    // Fallback to existing PRReviewer for backward compatibility\n    if (debug) {\n      logFn(`üîß Debug: Using legacy PRReviewer fallback`);\n    }\n    const focusMap: Record<string, ReviewOptions['focus']> = {\n      security: 'security',\n      performance: 'performance',\n      style: 'style',\n      all: 'all',\n      architecture: 'all',\n    };\n\n    let focus: ReviewOptions['focus'] = 'all';\n    if (checks.length === 1 && focusMap[checks[0]]) {\n      focus = focusMap[checks[0]];\n    }\n\n    return await this.reviewer.reviewPR('local', 'repository', 0, prInfo, {\n      focus,\n      format: 'table',\n    });\n  }\n\n  /**\n   * Execute review checks and return grouped results with statistics for new architecture\n   */\n  public async executeGroupedChecks(\n    prInfo: PRInfo,\n    checks: string[],\n    timeout?: number,\n    config?: import('./types/config').VisorConfig,\n    outputFormat?: string,\n    debug?: boolean,\n    maxParallelism?: number,\n    failFast?: boolean,\n    tagFilter?: import('./types/config').TagFilter,\n    _pauseGate?: () => Promise<void>\n  ): Promise<ExecutionResult> {\n    // Always reset per-run state at the beginning of a grouped execution to ensure\n    // stage-local accounting in flows. This prevents leakage of executionStats and\n    // forward-run guards across test stages (e.g., pr-review-e2e-flow).\n    try {\n      this.resetPerRunState();\n    } catch {}\n    // Determine where to send log messages based on output format\n    const logFn =\n      outputFormat === 'json' || outputFormat === 'sarif'\n        ? debug\n          ? console.error\n          : () => {}\n        : console.log;\n\n    // Only output debug messages if debug mode is enabled\n    if (debug) {\n      logger.debug(`üîß Debug: executeGroupedChecks called with checks: ${JSON.stringify(checks)}`);\n      logger.debug(\n        `üîß Debug: Config available: ${!!config}, Config has checks: ${!!config?.checks}`\n      );\n      logger.debug(`üîß Debug: Engine mode: ${this.engineMode}`);\n    }\n\n    // Log engine mode to telemetry for observability\n    try {\n      addEvent('engine.mode', { mode: this.engineMode });\n    } catch {\n      // Best effort; never fail on telemetry\n    }\n\n    // Filter checks based on current event type to prevent execution of checks that shouldn't run\n    const filteredChecks = this.filterChecksByEvent(checks, config, prInfo, logFn, debug);\n    if (filteredChecks.length !== checks.length && debug) {\n      logger.debug(\n        `üîß Debug: Event filtering reduced checks from ${checks.length} to ${filteredChecks.length}: ${JSON.stringify(filteredChecks)}`\n      );\n    }\n\n    // Apply tag filtering if specified\n    const tagFilteredChecks = this.filterChecksByTags(\n      filteredChecks,\n      config,\n      tagFilter || config?.tag_filter\n    );\n\n    if (tagFilteredChecks.length !== filteredChecks.length && debug) {\n      logger.debug(\n        `üîß Debug: Tag filtering reduced checks from ${filteredChecks.length} to ${tagFilteredChecks.length}: ${JSON.stringify(tagFilteredChecks)}`\n      );\n    }\n\n    // Use filtered checks for execution\n    checks = tagFilteredChecks;\n    try {\n      if (process.env.VISOR_DEBUG === 'true') {\n        const ev = (prInfo as any)?.eventType || '(unknown)';\n        console.error(`[engine] final checks after filters (event=${ev}): [${checks.join(', ')}]`);\n      }\n    } catch {}\n\n    // Capture GitHub Action context (owner/repo/octokit) if available from environment\n    // This is used for context elevation when routing via goto_event\n    // Only initialize if not already set by constructor (which has the authenticated octokit)\n    if (!this.actionContext) {\n      try {\n        const repoEnv = process.env.GITHUB_REPOSITORY || '';\n        const [owner, repo] = repoEnv.split('/') as [string, string];\n        const token = process.env['INPUT_GITHUB-TOKEN'] || process.env['GITHUB_TOKEN'];\n        if (owner && repo) {\n          this.actionContext = { owner, repo };\n          if (token) {\n            const { Octokit } = await import('@octokit/rest');\n            this.actionContext.octokit = new Octokit({ auth: token });\n          }\n        }\n      } catch {\n        // Non-fatal: context elevation will be skipped if not available\n      }\n    }\n\n    // Check if we have any checks left after filtering\n    if (checks.length === 0) {\n      logger.warn('‚ö†Ô∏è No checks remain after tag filtering');\n      return {\n        results: {},\n        statistics: this.buildExecutionStatistics(),\n      };\n    }\n\n    if (!config?.checks) {\n      throw new Error('Config with check definitions required for grouped execution');\n    }\n\n    // If we have a config with individual check definitions, use dependency-aware execution\n    const hasDependencies = checks.some(checkName => {\n      const checkConfig = config.checks![checkName];\n      return checkConfig?.depends_on && checkConfig.depends_on.length > 0;\n    });\n    const hasRouting = checks.some(checkName => {\n      const c = config.checks![checkName];\n      return Boolean(c?.on_success || c?.on_fail);\n    });\n\n    if (checks.length > 1 || hasDependencies || hasRouting) {\n      try {\n        if (process.env.VISOR_DEBUG === 'true') {\n          console.error(\n            '[engine] grouped-dep path: checks=',\n            checks.join(','),\n            ' hasDeps=',\n            hasDependencies,\n            ' hasRouting=',\n            hasRouting\n          );\n        }\n      } catch {}\n      if (debug) {\n        logger.debug(\n          `üîß Debug: Using grouped dependency-aware execution for ${checks.length} checks (has dependencies: ${hasDependencies}, has routing: ${hasRouting})`\n        );\n      }\n      const execRes = await this.executeGroupedDependencyAwareChecks(\n        prInfo,\n        checks,\n        timeout,\n        config,\n        logFn,\n        debug,\n        maxParallelism,\n        failFast,\n        tagFilter\n      );\n\n      // Optional grouped-mode PR comment posting (used by tests via execution context)\n      try {\n        if (this.executionContext?.mode?.postGroupedComments && config?.output?.pr_comment) {\n          // Resolve owner/repo from cached action context or PRInfo.eventContext\n          let owner: string | undefined = this.actionContext?.owner;\n          let repo: string | undefined = this.actionContext?.repo;\n          if (!owner || !repo) {\n            try {\n              const anyInfo = prInfo as unknown as {\n                eventContext?: { repository?: { owner?: { login?: string }; name?: string } };\n              };\n              owner = anyInfo?.eventContext?.repository?.owner?.login || owner;\n              repo = anyInfo?.eventContext?.repository?.name || repo;\n            } catch {}\n          }\n          owner = owner || (process.env.GITHUB_REPOSITORY || 'owner/repo').split('/')[0];\n          repo = repo || (process.env.GITHUB_REPOSITORY || 'owner/repo').split('/')[1];\n          if (owner && repo && prInfo.number) {\n            await this.reviewer.postReviewComment(owner, repo, prInfo.number, execRes.results, {\n              config: config as any,\n              triggeredBy: prInfo.eventType || 'manual',\n              commentId: 'visor-review',\n              octokitOverride: (prInfo as any)?.eventContext?.octokit,\n            });\n          }\n        }\n      } catch {}\n\n      // Recompute statistics at the top level to ensure post on_finish inline runs\n      // are reflected in counts (e.g., routed apply-issue-labels second pass).\n      const freshStats = this.buildExecutionStatistics();\n      return { results: execRes.results, statistics: freshStats };\n    }\n\n    // Single check execution\n    if (checks.length === 1) {\n      try {\n        if (process.env.VISOR_DEBUG === 'true')\n          console.error('[engine] grouped-single path: check=', checks[0]);\n      } catch {}\n      if (debug) {\n        logger.debug(`üîß Debug: Using grouped single check execution for: ${checks[0]}`);\n      }\n      const checkResult = await this.executeSingleGroupedCheck(\n        prInfo,\n        checks[0],\n        timeout,\n        config,\n        logFn,\n        debug\n      );\n\n      const groupedResults: GroupedCheckResults = {};\n      groupedResults[checkResult.group] = [checkResult];\n      // Optional grouped-mode PR comment posting for single-check runs as well\n      try {\n        if (this.executionContext?.mode?.postGroupedComments && config?.output?.pr_comment) {\n          let owner: string | undefined = this.actionContext?.owner;\n          let repo: string | undefined = this.actionContext?.repo;\n          if (!owner || !repo) {\n            try {\n              const anyInfo = prInfo as unknown as {\n                eventContext?: { repository?: { owner?: { login?: string }; name?: string } };\n              };\n              owner = anyInfo?.eventContext?.repository?.owner?.login || owner;\n              repo = anyInfo?.eventContext?.repository?.name || repo;\n            } catch {}\n          }\n          owner = owner || (process.env.GITHUB_REPOSITORY || 'owner/repo').split('/')[0];\n          repo = repo || (process.env.GITHUB_REPOSITORY || 'owner/repo').split('/')[1];\n          if (owner && repo && prInfo.number) {\n            await this.reviewer.postReviewComment(owner, repo, prInfo.number, groupedResults, {\n              config: config as any,\n              triggeredBy: prInfo.eventType || 'manual',\n              commentId: 'visor-review',\n              octokitOverride: (prInfo as any)?.eventContext?.octokit,\n            });\n          }\n        }\n      } catch {}\n      return {\n        results: groupedResults,\n        statistics: this.buildExecutionStatistics(),\n      };\n    }\n\n    // No checks to execute\n    return {\n      results: {},\n      statistics: this.buildExecutionStatistics(),\n    };\n  }\n\n  /**\n   * Execute single check and return grouped result\n   */\n  private async executeSingleGroupedCheck(\n    prInfo: PRInfo,\n    checkName: string,\n    timeout?: number,\n    config?: import('./types/config').VisorConfig,\n    logFn?: (message: string) => void,\n    debug?: boolean\n  ): Promise<CheckResult> {\n    if (!config?.checks?.[checkName]) {\n      throw new Error(`No configuration found for check: ${checkName}`);\n    }\n\n    const checkConfig = config.checks![checkName];\n    const providerType = checkConfig.type || 'ai';\n    const provider = this.providerRegistry.getProviderOrThrow(providerType);\n    this.setProviderWebhookContext(provider);\n\n    const providerConfig: CheckProviderConfig = {\n      type: providerType,\n      prompt: checkConfig.prompt,\n      focus: checkConfig.focus || this.mapCheckNameToFocus(checkName),\n      schema: checkConfig.schema,\n      group: checkConfig.group,\n      eventContext: this.enrichEventContext(prInfo.eventContext),\n      ai: {\n        timeout: timeout || 600000,\n        debug: debug,\n        ...(checkConfig.ai || {}),\n      },\n      ai_provider: checkConfig.ai_provider || config.ai_provider,\n      ai_model: checkConfig.ai_model || config.ai_model,\n      // Pass claude_code config if present\n      claude_code: checkConfig.claude_code,\n      // Pass output history for loop/goto scenarios\n      __outputHistory: this.outputHistory,\n      // Pass any provider-specific config\n      ...checkConfig,\n    };\n    providerConfig.forEach = checkConfig.forEach;\n\n    // Ensure statistics are recorded for single-check path as well\n    if (!this.executionStats.has(checkName)) this.initializeCheckStats(checkName);\n    const __iterStart = this.recordIterationStart(checkName);\n    const __provStart = Date.now();\n    const result = await provider.execute(prInfo, providerConfig, undefined, this.executionContext);\n    // Normalize provider issues: ensure each issue carries the producing check name\n    try {\n      if (Array.isArray((result as any)?.issues)) {\n        (result as any).issues = (result as any).issues.map((iss: any) => {\n          if (iss && typeof iss === 'object' && !iss.checkName) {\n            return { ...iss, checkName };\n          }\n          return iss;\n        });\n      }\n    } catch {}\n    this.recordProviderDuration(checkName, Date.now() - __provStart);\n\n    // Validate forEach output (skip if there are already errors from transform_js or other sources)\n    if (checkConfig.forEach && (!result.issues || result.issues.length === 0)) {\n      const reviewSummaryWithOutput = result as ReviewSummary & { output?: unknown };\n      const validation = this.validateAndNormalizeForEachOutput(\n        checkName,\n        reviewSummaryWithOutput.output,\n        checkConfig.group\n      );\n\n      if (!validation.isValid) {\n        return validation.error;\n      }\n    }\n\n    // Evaluate fail_if conditions\n    if (config && (config.fail_if || checkConfig.fail_if)) {\n      const failureResults = await this.evaluateFailureConditions(\n        checkName,\n        result,\n        config,\n        prInfo\n      );\n\n      // Add failure condition issues to the result\n      if (failureResults.length > 0) {\n        const failureIssues = failureResults\n          .filter(f => f.failed)\n          .map(f => ({\n            file: 'system',\n            line: 0,\n            ruleId: f.conditionName,\n            message: f.message || `Failure condition met: ${f.expression}`,\n            severity: (f.severity || 'error') as 'info' | 'warning' | 'error' | 'critical',\n            category: 'logic' as const,\n          }));\n\n        result.issues = [...(result.issues || []), ...failureIssues];\n      }\n    }\n\n    // Render the check content using the appropriate template\n    const content = await this.renderCheckContent(checkName, result, checkConfig, prInfo);\n\n    // Determine the group generically: if a check declares `group`, use it; otherwise default to the check name\n    // This avoids any hardcoded mapping and keeps grouping stable for JSON/PR consumers.\n    const group = checkConfig.group || checkName;\n\n    // History is recorded centrally in executeCheckInline; avoid double-recording here.\n\n    const checkResult: CheckResult = {\n      checkName,\n      content,\n      group,\n      output: (result as any).output,\n      debug: result.debug,\n      issues: result.issues, // Include structured issues\n    };\n\n    // Record completion in execution statistics (success/failure + durations)\n    try {\n      const issuesArr = (result.issues || []).map(i => ({ ...i }));\n      const success = !this.hasFatal(issuesArr);\n      const outputVal: unknown = (result as any)?.output;\n      this.recordIterationComplete(checkName, __iterStart, success, issuesArr, outputVal);\n    } catch {}\n\n    return checkResult;\n  }\n\n  /**\n   * Validate and normalize forEach output\n   * Returns normalized array or throws validation error result\n   */\n  private validateAndNormalizeForEachOutput(\n    checkName: string,\n    output: unknown,\n    checkGroup?: string\n  ):\n    | {\n        isValid: true;\n        normalizedOutput: unknown[];\n      }\n    | {\n        isValid: false;\n        error: {\n          checkName: string;\n          content: string;\n          group: string;\n          issues: Array<{\n            file: string;\n            line: number;\n            ruleId: string;\n            message: string;\n            severity: 'error';\n            category: 'logic';\n          }>;\n        };\n      } {\n    if (output === undefined) {\n      logger.error(`‚úó forEach check \"${checkName}\" produced undefined output`);\n      return {\n        isValid: false,\n        error: {\n          checkName,\n          content: '',\n          group: checkGroup || 'default',\n          issues: [\n            {\n              file: 'system',\n              line: 0,\n              ruleId: 'forEach/undefined_output',\n              message: `forEach check \"${checkName}\" produced undefined output. Verify your command outputs valid data and your transform_js returns a value.`,\n              severity: 'error',\n              category: 'logic',\n            },\n          ],\n        },\n      };\n    }\n\n    // Normalize output to array\n    let normalizedOutput: unknown[];\n\n    if (Array.isArray(output)) {\n      normalizedOutput = output;\n    } else if (output && typeof output === 'object' && Array.isArray((output as any).items)) {\n      normalizedOutput = (output as any).items as unknown[];\n    } else if (typeof output === 'string') {\n      try {\n        const parsed = JSON.parse(output);\n        normalizedOutput = Array.isArray(parsed) ? parsed : [parsed];\n      } catch {\n        normalizedOutput = [output];\n      }\n    } else if (output === null) {\n      normalizedOutput = [];\n    } else {\n      normalizedOutput = [output];\n    }\n\n    // Log the result (empty arrays are valid, just result in 0 iterations)\n    logger.info(`  Found ${normalizedOutput.length} items for forEach iteration`);\n    return {\n      isValid: true,\n      normalizedOutput,\n    };\n  }\n\n  /**\n   * Execute multiple checks with dependency awareness - return grouped results with statistics\n   */\n  private async executeGroupedDependencyAwareChecks(\n    prInfo: PRInfo,\n    checks: string[],\n    timeout?: number,\n    config?: import('./types/config').VisorConfig,\n    logFn?: (message: string) => void,\n    debug?: boolean,\n    maxParallelism?: number,\n    failFast?: boolean,\n    tagFilter?: import('./types/config').TagFilter\n  ): Promise<ExecutionResult> {\n    // Ensure per-run guards do not leak across stages in a flow. In particular,\n    // forwardRunGuards must be cleared so on_finish routed targets (e.g.,\n    // issue-assistant) can be scheduled again in later stages that use the same\n    // event type. This fixes flaky counts like apply-issue-labels=1 instead of 2\n    // when running the entire pr-review-e2e-flow.\n    try {\n      this.resetPerRunState();\n    } catch {}\n    // Do not mutate MemoryStore inside the engine; stage scoping is achieved\n    // via output history and per-run guards only.\n    // Use the existing dependency-aware execution logic\n    const reviewSummary = await this.executeDependencyAwareChecks(\n      prInfo,\n      checks,\n      timeout,\n      config,\n      logFn,\n      debug,\n      maxParallelism,\n      failFast,\n      tagFilter || config?.tag_filter\n    );\n\n    // Build execution statistics\n    const executionStatistics = this.buildExecutionStatistics();\n\n    // Convert the flat ReviewSummary to grouped CheckResults\n    const groupedResults = await this.convertReviewSummaryToGroupedResults(\n      reviewSummary,\n      checks,\n      config,\n      prInfo\n    );\n\n    return {\n      results: groupedResults,\n      statistics: executionStatistics,\n    };\n  }\n\n  /**\n   * Convert ReviewSummary to GroupedCheckResults\n   */\n  private async convertReviewSummaryToGroupedResults(\n    reviewSummary: ReviewSummary,\n    checks: string[],\n    config?: import('./types/config').VisorConfig,\n    prInfo?: PRInfo\n  ): Promise<GroupedCheckResults> {\n    const groupedResults: GroupedCheckResults = {};\n    const agg = reviewSummary as ReviewSummary & {\n      __contents?: Record<string, string | undefined>;\n      __outputs?: Record<string, unknown>;\n      __executed?: string[];\n    };\n    const contentMap = agg.__contents;\n    const outputMap = agg.__outputs;\n    // Build a unified list of all checks that produced results:\n    //  - originally requested checks\n    //  - any checks that produced content/output during routing (e.g., forward-run after goto)\n    //  - any checks that emitted issues with checkName set\n    const allCheckNames: string[] = [];\n    const seen = new Set<string>();\n    const pushUnique = (n?: string) => {\n      if (!n) return;\n      if (!seen.has(n)) {\n        seen.add(n);\n        allCheckNames.push(n);\n      }\n    };\n    for (const n of checks) pushUnique(n);\n    if (contentMap) for (const n of Object.keys(contentMap)) pushUnique(n);\n    if (outputMap) for (const n of Object.keys(outputMap)) pushUnique(n);\n    for (const issue of reviewSummary.issues || []) pushUnique(issue.checkName);\n    if (Array.isArray(agg.__executed)) for (const n of agg.__executed) pushUnique(n);\n\n    // Process each discovered check individually\n    for (const checkName of allCheckNames) {\n      const checkConfig = config?.checks?.[checkName];\n      if (!checkConfig) continue;\n\n      // Extract issues for this check: rely strictly on explicit issue.checkName\n      const checkIssues = (reviewSummary.issues || []).filter(\n        issue => issue.checkName === checkName\n      );\n\n      // Create a mini ReviewSummary for this check\n      const checkSummary: ReviewSummary & { output?: unknown } = {\n        issues: checkIssues,\n        debug: reviewSummary.debug,\n      };\n\n      if (contentMap?.[checkName]) {\n        (checkSummary as any).content = contentMap[checkName];\n      }\n      if (outputMap && Object.prototype.hasOwnProperty.call(outputMap, checkName)) {\n        checkSummary.output = outputMap[checkName];\n      }\n\n      // Render content for this check (never let template errors abort the whole run)\n      let content: string = '';\n      let issuesForCheck = [...checkIssues];\n      try {\n        content = await this.renderCheckContent(checkName, checkSummary, checkConfig, prInfo);\n      } catch (e) {\n        const msg = e instanceof Error ? e.message : String(e);\n        console.error(`‚ùå Failed to render content for check '${checkName}': ${msg}`);\n        // Add a synthetic issue so it appears in output and GitHub Checks\n        issuesForCheck = [\n          ...issuesForCheck,\n          {\n            file: 'system',\n            line: 0,\n            ruleId: `${checkName}/render-error`,\n            message: `Template rendering failed: ${msg}`,\n            severity: 'error' as const,\n            category: 'logic' as const,\n          },\n        ];\n      }\n\n      // Determine group for grouped results: use explicit group or fall back to the check name\n      const group = checkConfig.group || checkName;\n\n      const DBG2 = process.env.VISOR_DEBUG === 'true' || (this as any).globalDebug === true;\n      if (DBG2) {\n        try {\n          console.error(\n            `[gh-debug] grouped result: check='${checkName}' issues=${issuesForCheck.length} hasContent=${\n              content.trim() ? 'yes' : 'no'\n            } group='${group}'`\n          );\n        } catch {}\n      }\n\n      const checkResult: CheckResult = {\n        checkName,\n        content,\n        group,\n        output: checkSummary.output,\n        debug: reviewSummary.debug,\n        issues: issuesForCheck, // Include structured issues + rendering error if any\n      };\n\n      // Add to appropriate group\n      if (!groupedResults[group]) {\n        groupedResults[group] = [];\n      }\n      groupedResults[group].push(checkResult);\n    }\n\n    return groupedResults;\n  }\n\n  /**\n   * Validates that a file path is safe and within the project directory\n   * Prevents path traversal attacks by:\n   * - Blocking absolute paths\n   * - Blocking paths with \"..\" segments\n   * - Ensuring resolved path is within project directory\n   * - Blocking special characters and null bytes\n   * - Enforcing .liquid file extension\n   */\n  private async validateTemplatePath(templatePath: string): Promise<string> {\n    const path = await import('path');\n\n    // Validate input\n    if (!templatePath || typeof templatePath !== 'string' || templatePath.trim() === '') {\n      throw new Error('Template path must be a non-empty string');\n    }\n\n    // Block null bytes and other dangerous characters\n    if (templatePath.includes('\\0') || templatePath.includes('\\x00')) {\n      throw new Error('Template path contains invalid characters');\n    }\n\n    // Enforce .liquid file extension\n    if (!templatePath.endsWith('.liquid')) {\n      throw new Error('Template file must have .liquid extension');\n    }\n\n    // Block absolute paths\n    if (path.isAbsolute(templatePath)) {\n      throw new Error('Template path must be relative to project directory');\n    }\n\n    // Block paths with \"..\" segments\n    if (templatePath.includes('..')) {\n      throw new Error('Template path cannot contain \"..\" segments');\n    }\n\n    // Block paths starting with ~ (home directory)\n    if (templatePath.startsWith('~')) {\n      throw new Error('Template path cannot reference home directory');\n    }\n\n    // Get the project root directory from git analyzer\n    const repositoryInfo = await this.gitAnalyzer.analyzeRepository();\n    const projectRoot = repositoryInfo.workingDirectory;\n\n    // Validate project root\n    if (!projectRoot || typeof projectRoot !== 'string') {\n      throw new Error('Unable to determine project root directory');\n    }\n\n    // Resolve the template path relative to project root\n    const resolvedPath = path.resolve(projectRoot, templatePath);\n    const resolvedProjectRoot = path.resolve(projectRoot);\n\n    // Validate resolved paths\n    if (\n      !resolvedPath ||\n      !resolvedProjectRoot ||\n      resolvedPath === '' ||\n      resolvedProjectRoot === ''\n    ) {\n      throw new Error(\n        `Unable to resolve template path: projectRoot=\"${projectRoot}\", templatePath=\"${templatePath}\", resolvedPath=\"${resolvedPath}\", resolvedProjectRoot=\"${resolvedProjectRoot}\"`\n      );\n    }\n\n    // Ensure the resolved path is still within the project directory\n    if (\n      !resolvedPath.startsWith(resolvedProjectRoot + path.sep) &&\n      resolvedPath !== resolvedProjectRoot\n    ) {\n      throw new Error('Template path escapes project directory');\n    }\n\n    return resolvedPath;\n  }\n\n  /**\n   * Unified helper to evaluate a check's `if` condition with optional fail-secure behavior.\n   * Returns a struct indicating whether to run; when failSecure=true, any evaluation error\n   * results in shouldRun=false with an error message.\n   */\n  private async shouldRunCheck(\n    checkName: string,\n    condition: string,\n    prInfo: PRInfo,\n    results: Map<string, ReviewSummary>,\n    debug?: boolean,\n    eventOverride?: import('./types/config').EventTrigger,\n    failSecure = false\n  ): Promise<{ shouldRun: boolean; error?: string }> {\n    try {\n      const eventName = eventOverride\n        ? eventOverride.startsWith('pr_')\n          ? 'pull_request'\n          : eventOverride === 'issue_comment'\n            ? 'issue_comment'\n            : eventOverride.startsWith('issue_')\n              ? 'issues'\n              : 'manual'\n        : prInfo.eventType && prInfo.eventType.startsWith('pr_')\n          ? 'pull_request'\n          : prInfo.eventType === 'issue_comment'\n            ? 'issue_comment'\n            : prInfo.eventType && prInfo.eventType.startsWith('issue_')\n              ? 'issues'\n              : 'manual';\n\n      const commenterAssoc = resolveAssociationFromEvent(\n        (prInfo as any)?.eventContext,\n        prInfo.authorAssociation\n      );\n\n      const shouldRun = await this.failureEvaluator.evaluateIfCondition(checkName, condition, {\n        branch: prInfo.head,\n        baseBranch: prInfo.base,\n        filesChanged: prInfo.files.map(f => f.filename),\n        event: eventName,\n        environment: getSafeEnvironmentVariables(),\n        previousResults: results,\n        authorAssociation: commenterAssoc,\n      });\n\n      if (!shouldRun && debug) {\n        logger.debug(`üîß Debug: Skipping check '${checkName}' - if condition evaluated to false`);\n      }\n      return { shouldRun };\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : String(error);\n      if (failSecure) {\n        try {\n          logger.error(`Failed to evaluate if condition for ${checkName}: ${msg}`);\n        } catch {}\n        return { shouldRun: false, error: msg };\n      }\n      // Legacy behavior: on evaluation error, default to running the check\n      try {\n        if (debug) logger.debug(`‚ö†Ô∏è Debug: if evaluation error for ${checkName}: ${msg}`);\n      } catch {}\n      return { shouldRun: true, error: msg };\n    }\n  }\n\n  /**\n   * Render check content using the appropriate template\n   */\n  private async renderCheckContent(\n    checkName: string,\n    reviewSummary: ReviewSummary,\n    checkConfig: CheckConfig,\n    _prInfo?: PRInfo\n  ): Promise<string> {\n    const directContent = (reviewSummary as ReviewSummary & { content?: string }).content;\n    if (typeof directContent === 'string' && directContent.trim()) {\n      return directContent.trim();\n    }\n\n    // Import the liquid template system\n    const { createExtendedLiquid } = await import('./liquid-extensions');\n    const fs = await import('fs/promises');\n    const path = await import('path');\n\n    const liquid = createExtendedLiquid({\n      trimTagLeft: false,\n      trimTagRight: false,\n      trimOutputLeft: false,\n      trimOutputRight: false,\n      greedy: false,\n    });\n\n    // Determine template to use\n    // If schema is an object (inline JSON schema), use 'plain' rendering\n    // If schema is a file path (legitimate path with / and ends with .json), treat as plain (schema file reference)\n    let schemaName: string;\n    if (typeof checkConfig.schema === 'object') {\n      schemaName = 'plain';\n    } else if (\n      typeof checkConfig.schema === 'string' &&\n      checkConfig.schema.includes('/') &&\n      checkConfig.schema.endsWith('.json') &&\n      !checkConfig.schema.includes('..') // Reject paths containing .. (parent directory)\n    ) {\n      // Schema is a file path reference - use plain rendering\n      // The schema file will be handled by the AI provider when making the request\n      schemaName = 'plain';\n    } else {\n      schemaName = checkConfig.schema || 'plain';\n    }\n\n    let templateContent: string = '';\n    let enrichAssistantContext = false;\n\n    const DBG = process.env.VISOR_DEBUG === 'true' || (this as any).globalDebug === true;\n\n    if (checkConfig.template) {\n      // Custom template\n      if (checkConfig.template.content) {\n        templateContent = checkConfig.template.content;\n      } else if (checkConfig.template.file) {\n        // Validate the template file path to prevent path traversal attacks\n        const validatedPath = await this.validateTemplatePath(checkConfig.template.file);\n        templateContent = await fs.readFile(validatedPath, 'utf-8');\n      } else {\n        throw new Error('Custom template must specify either \"file\" or \"content\"');\n      }\n    } else if (schemaName === 'plain') {\n      if (DBG) {\n        try {\n          console.error(\n            `[gh-debug] render plain content for check='${checkName}' issues=${\n              (reviewSummary.issues || []).length\n            }`\n          );\n        } catch {}\n      }\n      // Plain schema - return raw content directly\n      return reviewSummary.issues?.[0]?.message || '';\n    } else {\n      // Use built-in schema template\n      const sanitizedSchema = schemaName.replace(/[^a-zA-Z0-9-]/g, '');\n      if (!sanitizedSchema) {\n        throw new Error('Invalid schema name');\n      }\n      // Locate built-in template. In GitHub Action bundle templates live under dist/output.\n      // In local dev (ts-node/jest) templates live under project/output.\n      // Also try historical dist/output1 fallback.\n      const candidateTemplatePaths = [\n        path.join(__dirname, `output/${sanitizedSchema}/template.liquid`),\n        path.join(process.cwd(), `output/${sanitizedSchema}/template.liquid`),\n      ];\n\n      let foundTemplate: string | undefined;\n      for (const p of candidateTemplatePaths) {\n        try {\n          templateContent = await fs.readFile(p, 'utf-8');\n          foundTemplate = p;\n          break;\n        } catch {\n          // try next candidate\n        }\n      }\n      if (!foundTemplate) {\n        const distPath = path.join(__dirname, `output/${sanitizedSchema}/template.liquid`);\n        const cwdPath = path.join(process.cwd(), `output/${sanitizedSchema}/template.liquid`);\n        throw new Error(\n          `Template file not found for schema '${sanitizedSchema}'. Tried: ${distPath} and ${cwdPath}.`\n        );\n      }\n      if (DBG) {\n        try {\n          console.error(\n            `[gh-debug] template resolved for check='${checkName}' schema='${sanitizedSchema}' path='${foundTemplate}'`\n          );\n        } catch {}\n      }\n      // Only enrich built-in issue-assistant with event/permission context\n      if (sanitizedSchema === 'issue-assistant') {\n        enrichAssistantContext = true;\n      }\n    }\n\n    // Prepare template data\n    // Filter out system-level issues (fail_if conditions, internal errors) which should not appear in output\n    const filteredIssues = (reviewSummary.issues || []).filter(\n      issue => !(issue.file === 'system' && issue.line === 0)\n    );\n    if (DBG) {\n      try {\n        const sample = filteredIssues.slice(0, 2).map(i => ({\n          file: i.file,\n          line: i.line,\n          severity: i.severity,\n          ruleId: i.ruleId,\n          checkName: (i as any).checkName,\n          category: (i as any).category,\n        }));\n        console.error(\n          `[gh-debug] render data for check='${checkName}' issues=${filteredIssues.length} content=${\n            (reviewSummary as any).content ? 'yes' : 'no'\n          } sample=${JSON.stringify(sample)}`\n        );\n      } catch {}\n    }\n\n    const templateData: Record<string, unknown> = {\n      issues: filteredIssues,\n      checkName: checkName,\n      // Expose structured output for custom schemas/templates (e.g., overview)\n      // This allows templates to render fields like output.text or output.tags\n      output: (reviewSummary as unknown as { output?: unknown }).output,\n    };\n\n    if (enrichAssistantContext) {\n      // Provide minimal event and permission context for the assistant template only\n      let authorAssociation: string | undefined;\n      let eventName = 'manual';\n      let eventAction: string | undefined;\n      try {\n        const anyInfo = _prInfo as unknown as { eventContext?: any; authorAssociation?: string };\n        authorAssociation = resolveAssociationFromEvent(\n          anyInfo?.eventContext,\n          anyInfo?.authorAssociation\n        );\n        eventName = anyInfo?.eventContext?.event_name || (anyInfo as any)?.eventType || 'manual';\n        eventAction = anyInfo?.eventContext?.action;\n      } catch {}\n      templateData.authorAssociation = authorAssociation;\n      templateData.event = { name: eventName, action: eventAction };\n    }\n\n    // Establish permissions context for filters so templates can call permission filters\n    // without passing authorAssociation explicitly.\n    const { withPermissionsContext } = (await import('./liquid-extensions')) as unknown as {\n      withPermissionsContext?: (\n        ctx: { authorAssociation?: string },\n        fn: () => Promise<string>\n      ) => Promise<string>;\n    };\n    // Try to derive author association from PR info (commenter preferred)\n    let authorAssociationForFilters: string | undefined;\n    try {\n      const anyInfo = _prInfo as unknown as { eventContext?: any; authorAssociation?: string };\n      authorAssociationForFilters = resolveAssociationFromEvent(\n        anyInfo?.eventContext,\n        anyInfo?.authorAssociation\n      );\n    } catch {}\n\n    let rendered: string;\n    if (typeof withPermissionsContext === 'function') {\n      rendered = await withPermissionsContext(\n        { authorAssociation: authorAssociationForFilters },\n        async () => await liquid.parseAndRender(templateContent, templateData)\n      );\n      if (rendered === undefined || rendered === null) {\n        // Defensive: some test environments mock the helper without implementation\n        rendered = await liquid.parseAndRender(templateContent, templateData);\n      }\n    } else {\n      rendered = await liquid.parseAndRender(templateContent, templateData);\n    }\n    const finalRendered = rendered.trim();\n    try {\n      const { emitMermaidFromMarkdown } = await import('./utils/mermaid-telemetry');\n      emitMermaidFromMarkdown(checkName, finalRendered, 'content');\n    } catch {}\n    return finalRendered;\n  }\n\n  /**\n   * Attempt to elevate an issue/issue_comment context to full PR context when routing via goto_event.\n   * Returns a new PRInfo with files/diff when possible; otherwise returns null.\n   */\n  private async elevateContextToPullRequest(\n    prInfo: PRInfo,\n    targetEvent: import('./types/config').EventTrigger,\n    log?: (msg: string) => void,\n    debug?: boolean\n  ): Promise<PRInfo | null> {\n    try {\n      // Only elevate for PR-style events\n      if (targetEvent !== 'pr_opened' && targetEvent !== 'pr_updated') return null;\n\n      // Only meaningful to elevate from issue contexts\n      const isIssueContext = (prInfo as PRInfo & { isIssue?: boolean }).isIssue === true;\n      const ctx: any = (prInfo as any).eventContext || {};\n      const isPRThread = Boolean(ctx?.issue?.pull_request);\n      if (!isIssueContext || !isPRThread) return null;\n\n      // Resolve owner/repo from cached action context or environment\n      let owner = this.actionContext?.owner;\n      let repo = this.actionContext?.repo;\n      if (!owner || !repo) {\n        const repoEnv = process.env.GITHUB_REPOSITORY || '';\n        [owner, repo] = repoEnv.split('/') as [string, string];\n      }\n      if (!owner || !repo) return null;\n\n      // Determine PR number from event context or prInfo.number\n      const prNumber = (ctx?.issue?.number as number) || prInfo.number;\n      if (!prNumber) return null;\n\n      // Build Octokit; prefer cached instance\n      let octokit = this.actionContext?.octokit;\n      if (!octokit) {\n        const token = process.env['INPUT_GITHUB-TOKEN'] || process.env['GITHUB_TOKEN'];\n        if (!token) return null;\n        const { Octokit } = await import('@octokit/rest');\n        octokit = new Octokit({ auth: token });\n      }\n\n      // Fetch full PR diff\n      const analyzer = new PRAnalyzer(octokit);\n      const elevated = await analyzer.fetchPRDiff(owner, repo, prNumber, undefined, targetEvent);\n      // Preserve event context and helpful flags\n      (elevated as any).eventContext = (prInfo as any).eventContext || ctx;\n      (elevated as any).isPRContext = true;\n      (elevated as any).includeCodeContext = true;\n      if (debug)\n        log?.(`üîß Debug: Elevated context to PR #${prNumber} for goto_event=${targetEvent}`);\n      return elevated;\n    } catch (e) {\n      if (debug) {\n        const msg = e instanceof Error ? e.message : String(e);\n        log?.(`‚ö†Ô∏è Debug: Context elevation to PR failed: ${msg}`);\n      }\n      return null;\n    }\n  }\n\n  /**\n   * Execute multiple checks with dependency awareness - intelligently parallel and sequential\n   */\n  private async executeDependencyAwareChecks(\n    prInfo: PRInfo,\n    checks: string[],\n    timeout?: number,\n    config?: import('./types/config').VisorConfig,\n    logFn?: (message: string) => void,\n    debug?: boolean,\n    maxParallelism?: number,\n    failFast?: boolean,\n    tagFilter?: import('./types/config').TagFilter\n  ): Promise<ReviewSummary> {\n    const log = logFn || console.error;\n    try {\n      if (process.env.VISOR_DEBUG === 'true') {\n        console.error('[engine] enter executeDependencyAwareChecks (dbg=', debug, ')');\n        console.error('  [engine] root checks in (pre-expand): [', checks.join(', '), ']');\n      }\n    } catch {}\n\n    if (debug) {\n      log(`üîß Debug: Starting dependency-aware execution of ${checks.length} checks`);\n    }\n\n    if (!config?.checks) {\n      throw new Error('Config with check definitions required for dependency-aware execution');\n    }\n\n    // Determine effective max parallelism (CLI > config > default)\n    const effectiveMaxParallelism = maxParallelism ?? config.max_parallelism ?? 3;\n    // Determine effective fail-fast setting (CLI > config > default)\n    const effectiveFailFast = failFast ?? config.fail_fast ?? false;\n\n    if (debug) {\n      log(`üîß Debug: Using max parallelism: ${effectiveMaxParallelism}`);\n      log(`üîß Debug: Using fail-fast: ${effectiveFailFast}`);\n    }\n\n    // Build dependency graph and check for session reuse requirements\n    let dependencies: Record<string, string[]> = {};\n    const sessionReuseChecks = new Set<string>();\n    const sessionProviders = new Map<string, string>(); // checkName -> parent session provider\n\n    for (const checkName of checks) {\n      const checkConfig = config.checks![checkName];\n      if (checkConfig) {\n        dependencies[checkName] = checkConfig.depends_on || [];\n\n        // Track checks that need session reuse\n        if (debug) {\n          try {\n            log(\n              `üîß Debug: reuse_ai_session for '${checkName}' ‚Üí ${String(\n                (checkConfig as any).reuse_ai_session\n              )}`\n            );\n          } catch {}\n        }\n        if (\n          checkConfig.reuse_ai_session === true ||\n          typeof (checkConfig.reuse_ai_session as unknown) === 'string'\n        ) {\n          sessionReuseChecks.add(checkName);\n\n          // Determine the session provider check name\n          if (typeof checkConfig.reuse_ai_session === 'string') {\n            // Explicit check name provided\n            sessionProviders.set(checkName, checkConfig.reuse_ai_session);\n          } else if (checkConfig.reuse_ai_session === true) {\n            // Use first dependency as fallback\n            if (checkConfig.depends_on && checkConfig.depends_on.length > 0) {\n              sessionProviders.set(checkName, checkConfig.depends_on[0]);\n            }\n          }\n        }\n      } else {\n        dependencies[checkName] = [];\n      }\n    }\n\n    if (sessionReuseChecks.size > 0 && debug) {\n      log(\n        `üîÑ Debug: Found ${sessionReuseChecks.size} checks requiring session reuse: ${Array.from(sessionReuseChecks).join(', ')}`\n      );\n    }\n\n    // (moved) dependency validation runs after we include transitive dependencies\n\n    // Expand requested checks with transitive dependencies present in config for execution\n    const expandWithTransitives = (rootChecks: string[]): string[] => {\n      if (!config?.checks) return rootChecks;\n      const set = new Set<string>(rootChecks);\n      const allowByTags = (name: string): boolean => {\n        if (!tagFilter) return true;\n        const cfg = config!.checks?.[name];\n        const tags: string[] = (cfg && (cfg as any).tags) || [];\n        if (tagFilter.exclude && tagFilter.exclude.some(t => tags.includes(t))) return false;\n        if (tagFilter.include && tagFilter.include.length > 0) {\n          return tagFilter.include.some(t => tags.includes(t));\n        }\n        return true;\n      };\n      const allowByEvent = (name: string): boolean => {\n        try {\n          const cfg = config!.checks?.[name];\n          const triggers: import('./types/config').EventTrigger[] = (cfg?.on || []) as any;\n          // No triggers => allowed for all events\n          if (!triggers || triggers.length === 0) return true;\n          const current = prInfo?.eventType || 'manual';\n          return triggers.includes(current as any);\n        } catch {\n          return true;\n        }\n      };\n      const visit = (name: string) => {\n        const cfg = config.checks![name];\n        if (!cfg || !cfg.depends_on) return;\n        const depTokens = Array.isArray(cfg.depends_on) ? cfg.depends_on : [cfg.depends_on];\n        const expand = (tok: any): string[] => {\n          if (typeof tok === 'string' && tok.includes('|')) {\n            return tok\n              .split('|')\n              .map(s => s.trim())\n              .filter(Boolean);\n          }\n          return tok ? [String(tok)] : [];\n        };\n        const deps = depTokens.flatMap(expand);\n        for (const depName of deps) {\n          if (!config.checks![depName]) continue;\n          if (!allowByTags(depName)) continue;\n          if (!allowByEvent(depName)) continue;\n          if (!set.has(depName)) {\n            set.add(depName);\n            visit(depName);\n          }\n        }\n      };\n      for (const c of rootChecks) visit(c);\n      return Array.from(set);\n    };\n\n    checks = expandWithTransitives(checks);\n    try {\n      if (process.env.VISOR_DEBUG === 'true') {\n        console.error('  [engine] checks after expandWithTransitives: [', checks.join(', '), ']');\n      }\n    } catch {}\n\n    // Rebuild dependencies map for the expanded set (expand OR groups and prune by event)\n    for (const checkName of checks) {\n      const checkConfig = config.checks![checkName];\n      const depTokens: any[] = Array.isArray(checkConfig?.depends_on)\n        ? (checkConfig!.depends_on as any[])\n        : checkConfig?.depends_on\n          ? [checkConfig.depends_on]\n          : [];\n      const expandedDeps = depTokens.flatMap(tok =>\n        typeof tok === 'string' && tok.includes('|')\n          ? tok\n              .split('|')\n              .map(s => s.trim())\n              .filter(Boolean)\n          : tok\n            ? [String(tok)]\n            : []\n      );\n      dependencies[checkName] = expandedDeps;\n    }\n    // Prune dependencies that are not applicable for the current event.\n    // This avoids false validation failures for dual-source deps like\n    // extract-facts depending on both issue-assistant (issue_opened) and\n    // comment-assistant (issue_comment). Only keep deps whose own `on`\n    // includes the current event (or have no `on`).\n    try {\n      // Only prune by event when we have an explicit event context (GitHub webhook path)\n      if (prInfo && (prInfo as any).eventType) {\n        const currentEv = ((prInfo as any).eventType || 'manual') as any;\n        for (const [name, deps] of Object.entries(dependencies)) {\n          const filtered = (deps || []).filter(dep => {\n            const cfg = config.checks?.[dep];\n            if (!cfg) return false;\n            const trig = (cfg.on || []) as any;\n            if (!trig || (Array.isArray(trig) && trig.length === 0)) return true;\n            return Array.isArray(trig) ? trig.includes(currentEv) : trig === currentEv;\n          });\n          dependencies[name] = filtered;\n        }\n      }\n    } catch {}\n\n    // Validate dependencies after expansion so transitive deps are considered\n    {\n      const validation2 = DependencyResolver.validateDependencies(checks, dependencies);\n      if (!validation2.valid) {\n        return {\n          issues: [\n            {\n              severity: 'error' as const,\n              message: `Dependency validation failed: ${validation2.errors.join(', ')}`,\n              file: '',\n              line: 0,\n              ruleId: 'dependency-validation-error',\n              category: 'logic' as const,\n            },\n          ],\n        };\n      }\n    }\n\n    // Build dependency graph\n    let dependencyGraph = DependencyResolver.buildDependencyGraph(dependencies);\n\n    if (dependencyGraph.hasCycles) {\n      return {\n        issues: [\n          {\n            severity: 'error' as const,\n            message: `Circular dependencies detected: ${dependencyGraph.cycleNodes?.join(' -> ')}`,\n            file: '',\n            line: 0,\n            ruleId: 'circular-dependency-error',\n            category: 'logic' as const,\n          },\n        ],\n      };\n    }\n\n    // Build children-by-parent mapping for inline branch-first execution\n    const childrenByParent = new Map<string, string[]>();\n    for (const [child, depsArr] of Object.entries(dependencies)) {\n      for (const p of depsArr || []) {\n        if (!childrenByParent.has(p)) childrenByParent.set(p, []);\n        childrenByParent.get(p)!.push(child);\n      }\n    }\n\n    // Log execution plan\n    let stats = DependencyResolver.getExecutionStats(dependencyGraph);\n    if (debug) {\n      log(\n        `üîß Debug: Execution plan - ${stats.totalChecks} checks in ${stats.parallelLevels} levels, max parallelism: ${stats.maxParallelism}`\n      );\n    }\n\n    // Execute checks in waves when on_fail forward-runs occur during a pass\n    const results = new Map<string, ReviewSummary>();\n    const maxWaves = config?.routing?.max_loops ?? 10;\n    let wave = 1;\n    const runWave = async (): Promise<void> => {\n      // Reset per-wave forward scheduling/dedupe guards\n      try {\n        this.forwardDependentsScheduled.clear();\n      } catch {}\n      try {\n        this.forwardRunGuards.clear();\n      } catch {}\n      try {\n        this.oncePerRunScheduleGuards.clear();\n      } catch {}\n      // Clear forward-run markers\n      (this as any).onFailForwardRunSeen = false;\n      (this as any).onFinishForwardRunSeen = false;\n      (this as any).onSuccessForwardRunSeen = false;\n    };\n    await runWave();\n    const sessionRegistry = require('./session-registry').SessionRegistry.getInstance();\n    // Note: We'll get the provider dynamically per check, not a single one for all\n    const sessionIds = new Map<string, string>(); // checkName -> sessionId\n    let shouldStopExecution = false;\n    let completedChecksCount = 0;\n    let totalChecksCount = stats.totalChecks;\n\n    // Initialize execution statistics for all checks\n    for (const checkName of checks) {\n      this.initializeCheckStats(checkName);\n    }\n\n    const executeLevels = async (): Promise<void> => {\n      for (\n        let levelIndex = 0;\n        levelIndex < dependencyGraph.executionOrder.length && !shouldStopExecution;\n        levelIndex++\n      ) {\n        const executionGroup = dependencyGraph.executionOrder[levelIndex];\n        try {\n          console.error(\n            `  [engine] level ${executionGroup.level} parallel=[${executionGroup.parallel.join(', ')}] (wave ${wave})`\n          );\n        } catch {}\n\n        // Check for session reuse conflicts - only force sequential execution when there are actual conflicts\n        const checksInLevel = Array.isArray((executionGroup as any).parallel)\n          ? (executionGroup as any).parallel\n          : [];\n        // In correction waves, planning excludes dependents already; no ad-hoc suppression here.\n\n        // Group checks by their session parent\n        const sessionReuseGroups = new Map<string, string[]>();\n        checksInLevel.forEach((checkName: string) => {\n          if (sessionReuseChecks.has(checkName)) {\n            const parentCheckName = sessionProviders.get(checkName);\n            if (parentCheckName) {\n              if (!sessionReuseGroups.has(parentCheckName)) {\n                sessionReuseGroups.set(parentCheckName, []);\n              }\n              sessionReuseGroups.get(parentCheckName)!.push(checkName);\n            }\n          }\n        });\n\n        // Only force sequential execution if multiple checks share the same session parent\n        const hasConflictingSessionReuse = Array.from(sessionReuseGroups.values()).some(\n          group => group.length > 1\n        );\n\n        let actualParallelism = Math.min(effectiveMaxParallelism, checksInLevel.length);\n        if (hasConflictingSessionReuse) {\n          // Force sequential execution when there are actual session conflicts\n          actualParallelism = 1;\n          if (debug) {\n            const conflictingGroups = Array.from(sessionReuseGroups.entries())\n              .filter(([_, checks]) => checks.length > 1)\n              .map(([parent, checks]) => `${parent} -> [${checks.join(', ')}]`)\n              .join('; ');\n            log(\n              `üîÑ Debug: Level ${executionGroup.level} has session conflicts (${conflictingGroups}) - forcing sequential execution (parallelism: 1)`\n            );\n          }\n        } else if (sessionReuseGroups.size > 0 && debug) {\n          log(\n            `‚úÖ Debug: Level ${executionGroup.level} has session reuse but no conflicts - allowing parallel execution`\n          );\n        }\n\n        if (debug) {\n          log(\n            `üîß Debug: Executing level ${executionGroup.level} with ${executionGroup.parallel.length} checks (parallelism: ${actualParallelism})`\n          );\n        }\n\n        // Create task functions for checks in this level. Do not pre-filter by\n        // results.has(name) because forEach parents may satisfy dependents inline\n        // during their execution. Each task will re-check and skip at run time.\n        let levelChecks = checksInLevel;\n        // Guard: during correction waves (on_finish), do not re-run forEach parents\n        // that already executed earlier in this grouped run.\n        try {\n          const inCorrection = Boolean((this as any).onFinishForwardRunSeen);\n          if (inCorrection) {\n            levelChecks = levelChecks.filter((name: string) => {\n              const cfg = (config.checks || {})[name] as any;\n              if (!cfg || cfg.forEach !== true) return true;\n              const st = this.executionStats.get(name);\n              return !st || (st.totalRuns || 0) === 0;\n            });\n          }\n        } catch {}\n        try {\n          if (process.env.VISOR_DEBUG === 'true') {\n            console.error('  [engine] levelChecks = [', levelChecks.join(', '), ']');\n          }\n        } catch {}\n        const levelTaskFunctions = levelChecks.map((checkName: string) => async () => {\n          // Generic per-run cap: respect per-step max_runs/global limits\n          try {\n            const cap = this.resolveMaxRuns(config, checkName);\n            if (typeof cap === 'number' && cap > 0) {\n              const k = this.buildRunKey(checkName, undefined);\n              const soFar = this.runCounters.get(k) || 0;\n              if (soFar >= cap) {\n                if (debug) log(`üîß Debug: Skipping ${checkName} due to max_runs cap (${cap})`);\n                this.recordSkip(checkName, 'fail_fast', 'max_runs');\n                return {\n                  checkName,\n                  error: null,\n                  result: {\n                    issues: [\n                      {\n                        file: '',\n                        line: 0,\n                        ruleId: `${checkName}/limits/max_runs_exceeded`,\n                        message: `Run limit exceeded for '${checkName}' (attempt ${soFar + 1} > ${cap}).`,\n                        severity: 'error',\n                        category: 'logic',\n                      },\n                    ],\n                  },\n                } as any;\n              }\n              this.runCounters.set(k, soFar + 1);\n            }\n          } catch {}\n          // Skip if this check was already completed by item-level branch scheduler\n          if (results.has(checkName)) {\n            if (debug) log(`üîß Debug: Skipping ${checkName} (already satisfied earlier)`);\n            return { checkName, error: null, result: results.get(checkName)! };\n          }\n          const checkConfig = config.checks![checkName];\n          if (!checkConfig) {\n            return {\n              checkName,\n              error: `No configuration found for check: ${checkName}`,\n              result: null,\n            };\n          }\n\n          // Global one_shot tag: if this check already ran in this grouped run, skip\n          try {\n            const tags = (checkConfig.tags || []) as string[];\n            const isOneShot = Array.isArray(tags) && tags.includes('one_shot');\n            const ran = (this.executionStats.get(checkName)?.totalRuns || 0) > 0;\n            if (isOneShot && ran) {\n              if (debug) log(`‚è≠  Skipped (one_shot already executed): ${checkName}`);\n              return { checkName, error: null, result: results.get(checkName)! };\n            }\n          } catch {}\n\n          // Intra-level dependency barrier: if any direct dependencies of this check\n          // are also scheduled in this level, wait until they finish and populate\n          // the results map (this ensures forEach parents run before their dependents).\n          try {\n            const depsInLevel = (dependencies[checkName] || []).filter((d: string) =>\n              checksInLevel.includes(d)\n            );\n            const hasForEachParent = (checkConfig.depends_on || []).some(\n              (d: string) => (config.checks?.[d] as any)?.forEach === true\n            );\n            if (depsInLevel.length > 0) {\n              const deadline = Date.now() + 10_000; // 10s safety\n              // Wait for parents in this level to finish\n              while (depsInLevel.some((d: string) => !results.has(d))) {\n                await this.sleep(2);\n                if (Date.now() > deadline) break;\n              }\n              // If parent produced this check inline (per-item), results will have it\n              if (hasForEachParent) {\n                const deadline2 = Date.now() + 10_000;\n                while (!results.has(checkName) && Date.now() <= deadline2) {\n                  await this.sleep(2);\n                }\n              }\n              // If this step was scheduled via forward-run, wait briefly for it to complete to avoid duplicate execution\n              if (this.forwardDependentsScheduled.has(checkName)) {\n                const deadline3 = Date.now() + 10_000;\n                while (!results.has(checkName) && Date.now() <= deadline3) await this.sleep(2);\n              }\n              if (results.has(checkName)) {\n                if (debug)\n                  log(`üîß Debug: Skipping ${checkName} (satisfied inline by forEach parent)`);\n                return { checkName, error: null, result: results.get(checkName)! };\n              }\n            }\n          } catch {}\n\n          const checkStartTime = Date.now();\n          // (dedupe handled by tagging result object when pre-stored before routing)\n          completedChecksCount++;\n          logger.step(`Running check: ${checkName} [${completedChecksCount}/${totalChecksCount}]`);\n\n          try {\n            if (debug) {\n              log(`üîß Debug: Starting check: ${checkName} at level ${executionGroup.level}`);\n            }\n\n            // Get the appropriate provider for this check type\n            const providerType = checkConfig.type || 'ai';\n            const provider = this.providerRegistry.getProviderOrThrow(providerType);\n            if (debug) {\n              log(`üîß Debug: Provider for '${checkName}' is '${providerType}'`);\n            } else if (process.env.VISOR_DEBUG === 'true') {\n              try {\n                console.log(`[engine] provider for ${checkName} -> ${providerType}`);\n              } catch {}\n            }\n            this.setProviderWebhookContext(provider);\n\n            // Create provider config for this specific check\n            const extendedCheckConfig = checkConfig as CheckConfig & {\n              level?: string;\n              message?: string;\n            };\n\n            const providerConfig: CheckProviderConfig = {\n              type: providerType,\n              prompt: checkConfig.prompt,\n              exec: checkConfig.exec,\n              focus: checkConfig.focus || this.mapCheckNameToFocus(checkName),\n              schema: checkConfig.schema,\n              group: checkConfig.group,\n              checkName: checkName, // Add checkName for sessionID\n              eventContext: this.enrichEventContext(prInfo.eventContext),\n              transform: checkConfig.transform,\n              transform_js: checkConfig.transform_js,\n              // Important: pass through provider-level timeout from check config\n              // (e.g., command/http_client providers expect seconds/ms here)\n              timeout: checkConfig.timeout,\n              level: extendedCheckConfig.level,\n              message: extendedCheckConfig.message,\n              env: checkConfig.env,\n              forEach: checkConfig.forEach,\n              // Provide output history so providers can access latest outputs for Liquid rendering\n              __outputHistory: this.outputHistory,\n              // Pass through any provider-specific keys (e.g., op/values for github provider)\n              ...checkConfig,\n              ai: {\n                ...(checkConfig.ai || {}),\n                timeout: timeout || 600000,\n                debug: debug,\n              },\n            };\n\n            // Pass results from ALL transitive dependencies (not just direct ones)\n            // This ensures the \"outputs\" variable has access to all ancestor check results\n            const dependencyResults = new Map<string, ReviewSummary>();\n            let isForEachDependent = false;\n            let forEachItems: unknown[] = [];\n            let forEachParentName: string | undefined;\n            const forEachParents: string[] = []; // Track ALL forEach parents\n\n            // Get all transitive dependencies (ancestors) for this check\n            const allDependencies = DependencyResolver.getAllDependencies(\n              checkName,\n              dependencyGraph.nodes\n            );\n\n            // Include results from ALL dependencies (direct and transitive)\n            for (const depId of allDependencies) {\n              if (results.has(depId)) {\n                const depResult = results.get(depId)!;\n                dependencyResults.set(depId, depResult);\n              }\n            }\n\n            // If any direct dependency failed or was skipped, skip this check\n            // Support OR-groups using pipe syntax: \"a|b|c\" means any of these satisfies the dependency\n            const depTokens = checkConfig.depends_on || [];\n            const allOfDeps: string[] = [];\n            const anyOfGroups: string[][] = [];\n            for (const tok of depTokens) {\n              if (typeof tok === 'string' && tok.includes('|')) {\n                const group = tok\n                  .split('|')\n                  .map(s => s.trim())\n                  .filter(Boolean);\n                if (group.length > 0) anyOfGroups.push(group);\n              } else if (tok) {\n                allOfDeps.push(String(tok));\n              }\n            }\n            const failedDeps: string[] = [];\n            // Evaluate ALL-OF dependencies normally\n            for (const depId of allOfDeps) {\n              const depRes = results.get(depId);\n              // If a direct dependency has not produced a result in this run, consider it unsatisfied\n              // and gate the current check. This prevents executing dependents before their prerequisites.\n              if (!depRes) {\n                failedDeps.push(depId);\n                continue;\n              }\n\n              // Check if dependency was skipped\n              const wasSkipped = (depRes.issues || []).some(issue => {\n                const id = issue.ruleId || '';\n                return id.endsWith('/__skipped');\n              });\n\n              // If dependency is a forEach parent, do NOT apply global fatal gating here.\n              // We'll gate per-item inside the forEach loop to avoid stopping other branches.\n              const depExtended = depRes as ExtendedReviewSummary;\n              const isDepForEachParent = !!depExtended.isForEach;\n\n              // Treat these as fatal in direct dependencies (non-forEach only):\n              //  - provider/command execution errors and timeouts\n              //  - transform errors\n              //  - forEach validation/iteration errors\n              //  - fail_if conditions (global or check-specific)\n              // For forEach parents we defer gating to per-item handling below.\n              let hasFatalFailure = false;\n              if (!isDepForEachParent) {\n                const issues = depRes.issues || [];\n                hasFatalFailure = issues.some(i => this.isGatingFatal(i));\n              }\n\n              // Respect dependency's continue_on_failure: if set, do not gate dependents on failure\n              try {\n                const depCfg = config?.checks?.[depId] as\n                  | import('./types/config').CheckConfig\n                  | undefined;\n                if (depCfg?.continue_on_failure) {\n                  if (hasFatalFailure && debug) {\n                    log(\n                      `üîß Debug: dependency '${depId}' failed but continue_on_failure=true ‚Äî not gating`\n                    );\n                  }\n                  hasFatalFailure = false;\n                }\n              } catch {}\n\n              if (debug) {\n                log(\n                  `üîß Debug: gating check '${checkName}' against dep '${depId}': wasSkipped=${wasSkipped} hasFatalFailure=${hasFatalFailure}`\n                );\n              }\n              if (wasSkipped || hasFatalFailure) failedDeps.push(depId);\n            }\n\n            // Evaluate ANY-OF groups: each group must have at least one satisfied dependency\n            for (const group of anyOfGroups) {\n              let groupSatisfied = false;\n              for (const depId of group) {\n                const depRes = results.get(depId);\n                if (!depRes) continue;\n                const wasSkipped = (depRes.issues || []).some(issue => {\n                  const id = issue.ruleId || '';\n                  return id.endsWith('/__skipped');\n                });\n                const depExtended = depRes as ExtendedReviewSummary;\n                const isDepForEachParent = !!depExtended.isForEach;\n                let hasFatalFailure = false;\n                if (!isDepForEachParent) {\n                  const issues = depRes.issues || [];\n                  hasFatalFailure = issues.some(i => this.isGatingFatal(i));\n                }\n                // Respect continue_on_failure\n                try {\n                  const depCfg = config?.checks?.[depId] as\n                    | import('./types/config').CheckConfig\n                    | undefined;\n                  if (depCfg?.continue_on_failure) {\n                    hasFatalFailure = false;\n                  }\n                } catch {}\n                if (!wasSkipped && !hasFatalFailure) {\n                  groupSatisfied = true;\n                  break;\n                }\n              }\n              if (!groupSatisfied) {\n                failedDeps.push(group.join('|'));\n              }\n            }\n\n            if (failedDeps.length > 0) {\n              // If this step was explicitly scheduled by a correction cycle (on_fail forward-run),\n              // bypass dependency gating so the corrective chain can execute deterministically.\n              const isCorrectionCycle = this.forwardDependentsScheduled.has(checkName);\n              if (!isCorrectionCycle) {\n                this.recordSkip(checkName, 'dependency_failed');\n                logger.info(`‚è≠  Skipped (dependency failed: ${failedDeps.join(', ')})`);\n                return {\n                  checkName,\n                  error: null,\n                  result: { issues: [] },\n                  skipped: true,\n                };\n              } else {\n                try {\n                  logger.info(\n                    `‚Ü™ correction-cycle: bypassing dependency gate for '${checkName}' (failed: ${failedDeps.join(', ')})`\n                  );\n                } catch {}\n              }\n            }\n\n            // Check direct dependencies (including OR-group members) for forEach behavior\n            const expandedForEachDeps: string[] = [];\n            for (const tok of depTokens) {\n              if (typeof tok === 'string' && tok.includes('|'))\n                expandedForEachDeps.push(\n                  ...tok\n                    .split('|')\n                    .map(s => s.trim())\n                    .filter(Boolean)\n                );\n              else if (tok) expandedForEachDeps.push(String(tok));\n            }\n            for (const depId of expandedForEachDeps) {\n              if (results.has(depId)) {\n                const depResult = results.get(depId)!;\n\n                // Check if this dependency has forEach enabled\n                const depForEachResult = depResult as ExtendedReviewSummary;\n\n                if (\n                  depForEachResult.isForEach ||\n                  Array.isArray(depForEachResult.forEachItemResults) ||\n                  Array.isArray(depForEachResult.forEachItems)\n                ) {\n                  if (!isForEachDependent) {\n                    // First forEach dependency found - use it as the primary\n                    isForEachDependent = true;\n                    forEachItems = Array.isArray(depForEachResult.forEachItems)\n                      ? depForEachResult.forEachItems!\n                      : new Array(\n                          Array.isArray(depForEachResult.forEachItemResults)\n                            ? depForEachResult.forEachItemResults!.length\n                            : 0\n                        ).fill(undefined);\n                    forEachParentName = depId;\n                  }\n                  // Track all forEach parents for unwrapping\n                  forEachParents.push(depId);\n                }\n              }\n            }\n\n            // Determine if we should use session reuse\n            let sessionInfo: { parentSessionId?: string; reuseSession?: boolean } | undefined =\n              undefined;\n            if (sessionReuseChecks.has(checkName)) {\n              let parentCheckName = sessionProviders.get(checkName);\n              if (parentCheckName && parentCheckName.includes && parentCheckName.includes('|')) {\n                parentCheckName = parentCheckName.split('|')[0].trim();\n              }\n              if (parentCheckName && sessionIds.has(parentCheckName)) {\n                const parentSessionId = sessionIds.get(parentCheckName)!;\n\n                sessionInfo = {\n                  parentSessionId: parentSessionId,\n                  reuseSession: true,\n                };\n\n                if (debug) {\n                  log(\n                    `üîÑ Debug: Check ${checkName} will reuse session from parent ${parentCheckName}: ${parentSessionId}`\n                  );\n                }\n              } else {\n                if (debug) {\n                  log(\n                    `‚ö†Ô∏è Warning: Check ${checkName} requires session reuse but parent ${parentCheckName} session not found`\n                  );\n                }\n              }\n            }\n\n            // For checks that create new sessions, generate a session ID\n            let currentSessionId: string | undefined = undefined;\n            if (!sessionInfo?.reuseSession) {\n              const timestamp = new Date().toISOString();\n              currentSessionId = `visor-${timestamp.replace(/[:.]/g, '-')}-${checkName}`;\n              sessionIds.set(checkName, currentSessionId);\n              if (debug) {\n                log(`üÜï Debug: Check ${checkName} will create new session: ${currentSessionId}`);\n              }\n\n              // Add session ID to provider config\n              providerConfig.sessionId = currentSessionId;\n            }\n\n            // Handle forEach dependent execution\n            let finalResult: ReviewSummary;\n\n            if (isForEachDependent && forEachParentName) {\n              if (!Array.isArray(forEachItems)) {\n                forEachItems = [];\n              }\n              if (!Array.isArray(forEachItems)) {\n                this.recordSkip(checkName, 'dependency_failed');\n                return {\n                  checkName,\n                  error: null,\n                  result: { issues: [] },\n                  skipped: true,\n                };\n              }\n              // Record forEach preview items\n              this.recordForEachPreview(checkName, forEachItems);\n\n              try {\n                if (process.env.VISOR_DEBUG === 'true') {\n                  console.error(\n                    `[foreach] check=${checkName} forEachItems=${forEachItems.length} hasIf=${String(\n                      !!checkConfig.if\n                    )} ifExpr=${checkConfig.if ? this.truncate(checkConfig.if, 80) : ''}`\n                  );\n                }\n              } catch {}\n\n              // If the forEach parent returned an empty array, skip this check entirely\n              if (forEachItems.length === 0) {\n                if (debug) {\n                  log(\n                    `üîÑ Debug: Skipping check \"${checkName}\" - forEach check \"${forEachParentName}\" returned 0 items`\n                  );\n                }\n                logger.info(`  forEach: no items from \"${forEachParentName}\", skipping check...`);\n                this.recordSkip(checkName, 'dependency_failed');\n\n                // Return a special marker result so that dependent checks can detect the skip\n                finalResult = {\n                  issues: [],\n                  output: [],\n                } as ReviewSummary;\n\n                // Mark this result as forEach-capable but with empty items\n                (finalResult as ExtendedReviewSummary).isForEach = true;\n                (finalResult as ExtendedReviewSummary).forEachItems = [];\n\n                // Skip to the end - don't execute this check\n              } else {\n                // Emit explicit debug to stdout so CLI e2e can assert it\n                if (\n                  debug &&\n                  process.env.VISOR_OUTPUT_FORMAT !== 'json' &&\n                  process.env.VISOR_OUTPUT_FORMAT !== 'sarif'\n                ) {\n                  console.log(\n                    `üîÑ Debug: Check \"${checkName}\" depends on forEach check \"${forEachParentName}\", executing ${forEachItems.length} times`\n                  );\n                }\n\n                // Log forEach processing start (non-debug)\n                const __itemCount = Array.isArray(forEachItems) ? forEachItems.length : 0;\n                logger.info(\n                  `  forEach: processing ${__itemCount} items from \"${forEachParentName}\"...`\n                );\n\n                const allIssues: ReviewIssue[] = [];\n                const allOutputs: unknown[] = new Array(forEachItems.length);\n                const aggregatedContents: string[] = [];\n                const perItemResults: Array<ReviewSummary | undefined> = new Array(\n                  forEachItems.length\n                );\n\n                // Aggregators for inline descendant execution (branch-first mode for simple chains)\n                const inlineAgg = new Map<\n                  string,\n                  {\n                    issues: ReviewIssue[];\n                    outputs: unknown[];\n                    contents: string[];\n                    perItemResults: ReviewSummary[];\n                  }\n                >();\n\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const execInlineDescendants = async (\n                  parentName: string,\n                  itemIndex: number,\n                  baseDeps: Map<string, ReviewSummary>\n                ): Promise<void> => {\n                  const children = (childrenByParent.get(parentName) || []).filter(child => {\n                    const deps = dependencies[child] || [];\n                    // Only handle simple chains inline: exactly one dependency which is the parent\n                    return deps.length === 1 && deps[0] === parentName;\n                  });\n\n                  for (const childName of children) {\n                    const childCfg = config.checks![childName];\n                    const childProviderType = childCfg.type || 'ai';\n                    const childProv = this.providerRegistry.getProviderOrThrow(childProviderType);\n                    this.setProviderWebhookContext(childProv);\n                    const childProviderConfig: CheckProviderConfig = {\n                      type: childProviderType,\n                      prompt: childCfg.prompt,\n                      exec: childCfg.exec,\n                      focus: childCfg.focus || this.mapCheckNameToFocus(childName),\n                      schema: childCfg.schema,\n                      group: childCfg.group,\n                      checkName: childName,\n                      eventContext: this.enrichEventContext(prInfo.eventContext),\n                      transform: childCfg.transform,\n                      transform_js: childCfg.transform_js,\n                      env: childCfg.env,\n                      forEach: childCfg.forEach,\n                      // Include provider-specific keys like op/values for non-AI providers\n                      ...childCfg,\n                      ai: {\n                        ...(childCfg.ai || {}),\n                        timeout: timeout || 600000,\n                        debug: debug,\n                      },\n                    };\n                    try {\n                      emitNdjsonSpanWithEvents('visor.check', { 'visor.check.id': checkName }, [\n                        { name: 'check.started' },\n                        { name: 'check.completed' },\n                      ]);\n                    } catch {}\n\n                    // If the parent item had a fatal failure per mask, skip this child for this branch\n                    const parentAgg = results.get(parentName) as ExtendedReviewSummary | undefined;\n                    const maskFatal =\n                      !!parentAgg?.forEachFatalMask &&\n                      parentAgg!.forEachFatalMask![itemIndex] === true;\n                    if (maskFatal) {\n                      continue;\n                    }\n\n                    // Evaluate per-item if condition\n                    if (childCfg.if) {\n                      const itemScope: ScopePath = [{ check: parentName, index: itemIndex }];\n                      const condResults = this.buildSnapshotDependencyResults(\n                        itemScope,\n                        undefined,\n                        prInfo.eventType\n                      );\n                      for (const [k, v] of baseDeps.entries()) condResults.set(k, v);\n                      const gateChild = await this.shouldRunCheck(\n                        childName,\n                        childCfg.if,\n                        prInfo,\n                        condResults,\n                        debug,\n                        undefined,\n                        /* failSecure */ true\n                      );\n                      if (!gateChild.shouldRun) {\n                        continue;\n                      }\n                    }\n\n                    // Execute child for this item (record stats)\n                    const childIterStart = this.recordIterationStart(childName);\n                    // Build snapshot-based dependency view for this item scope\n                    const itemScope: ScopePath = [{ check: parentName, index: itemIndex }];\n                    const snapshotDeps = this.buildSnapshotDependencyResults(\n                      itemScope,\n                      undefined,\n                      prInfo.eventType\n                    );\n                    for (const [k, v] of baseDeps.entries()) snapshotDeps.set(k, v);\n\n                    let childItemRes: ReviewSummary;\n                    try {\n                      childItemRes = await this.executeWithRouting(\n                        childName,\n                        childCfg,\n                        childProv,\n                        childProviderConfig,\n                        prInfo,\n                        snapshotDeps,\n                        sessionInfo,\n                        config,\n                        dependencyGraph,\n                        debug,\n                        results,\n                        { index: itemIndex, total: forEachItems.length, parent: parentName }\n                      );\n                    } catch (error) {\n                      const msg = error instanceof Error ? error.message : String(error);\n                      childItemRes = {\n                        issues: [\n                          {\n                            file: '',\n                            line: 0,\n                            ruleId: `${childName}/forEach/iteration_error`,\n                            message: msg,\n                            severity: 'error',\n                            category: 'logic',\n                          },\n                        ],\n                      } as ReviewSummary;\n                    }\n\n                    // Per-item fail_if\n                    if (config && (config.fail_if || childCfg.fail_if)) {\n                      const fRes = await this.evaluateFailureConditions(\n                        childName,\n                        childItemRes,\n                        config,\n                        prInfo,\n                        results\n                      );\n                      if (fRes.length > 0) {\n                        const fIssues = fRes\n                          .filter(f => f.failed)\n                          .map(f => ({\n                            file: 'system',\n                            line: 0,\n                            ruleId: f.conditionName,\n                            message: f.message || `Failure condition met: ${f.expression}`,\n                            severity: (f.severity || 'error') as\n                              | 'info'\n                              | 'warning'\n                              | 'error'\n                              | 'critical',\n                            category: 'logic' as const,\n                          }));\n                        childItemRes.issues = [...(childItemRes.issues || []), ...fIssues];\n                      }\n                    }\n\n                    if (!inlineAgg.has(childName)) {\n                      inlineAgg.set(childName, {\n                        issues: [],\n                        outputs: new Array(forEachItems.length),\n                        contents: [],\n                        perItemResults: new Array(forEachItems.length),\n                      });\n                    }\n                    const agg = inlineAgg.get(childName)!;\n                    if (childItemRes.issues) agg.issues.push(...childItemRes.issues);\n                    const out = (childItemRes as any).output;\n                    agg.outputs[itemIndex] = out;\n                    agg.perItemResults[itemIndex] = childItemRes;\n                    const c = (childItemRes as any).content;\n                    if (typeof c === 'string' && c.trim()) agg.contents.push(c.trim());\n\n                    // Record iteration completion for stats\n                    const childHadFatal = this.hasFatal(childItemRes.issues || []);\n                    this.recordIterationComplete(\n                      childName,\n                      childIterStart,\n                      !childHadFatal,\n                      childItemRes.issues || [],\n                      (childItemRes as any).output\n                    );\n\n                    // Track per-item outputs in history so on_finish.goto_js can\n                    // compute waves from outputs_history['child'] reliably.\n                    try {\n                      const outVal: any = (childItemRes as any).output;\n                      // Only push non-array values (arrays are reserved for forEach parents)\n                      if (outVal !== undefined && !Array.isArray(outVal)) {\n                        this.trackOutputHistory(childName, outVal);\n                      }\n                    } catch {}\n\n                    // Recurse further for simple chains\n                    const nextBase = new Map(baseDeps);\n                    nextBase.set(childName, childItemRes);\n                    await execInlineDescendants(childName, itemIndex, nextBase);\n                  }\n                };\n\n                // Create task functions (not executed yet) - these will be executed with controlled concurrency\n                // via executeWithLimitedParallelism to respect maxParallelism setting\n                const itemTasks = forEachItems.map((item, itemIndex) => async () => {\n                  try {\n                    emitNdjsonSpanWithEvents(\n                      'visor.foreach.item',\n                      {\n                        'visor.check.id': checkName,\n                        'visor.foreach.index': itemIndex,\n                        'visor.foreach.total': forEachItems.length,\n                      },\n                      []\n                    );\n                  } catch {}\n                  // Build snapshot-based dependency view for this item scope (no per-item cloning)\n                  const itemScope: ScopePath = [{ check: forEachParentName!, index: itemIndex }];\n                  const snapshotDeps = this.buildSnapshotDependencyResults(\n                    itemScope,\n                    undefined,\n                    prInfo.eventType\n                  );\n\n                  // Per-item dependency gating for forEach parents: if a dependency failed for this item, skip this iteration\n                  if ((checkConfig.depends_on || []).length > 0) {\n                    // Do not short-circuit per-item execution solely based on parent fatality masks.\n                    // Downstream fail_if on the child will surface errors appropriately.\n                    // This keeps dependent validations running and avoids total suppression.\n                  }\n\n                  // Evaluate if condition for this forEach item\n                  if (checkConfig.if) {\n                    const gateItem = await this.shouldRunCheck(\n                      checkName,\n                      checkConfig.if,\n                      prInfo,\n                      snapshotDeps,\n                      debug,\n                      undefined,\n                      /* failSecure */ true\n                    );\n                    try {\n                      if (process.env.VISOR_DEBUG === 'true') {\n                        console.error(\n                          `[if-gate-item] check=${checkName} expr=\"${checkConfig.if}\" shouldRun=${String(gateItem.shouldRun)} env.ENABLE_FACT_VALIDATION=${String(process.env.ENABLE_FACT_VALIDATION)}`\n                        );\n                      }\n                    } catch {}\n\n                    if (!gateItem.shouldRun) {\n                      if (debug) {\n                        log(\n                          `üîÑ Debug: Skipping forEach item ${itemIndex + 1} for check \"${checkName}\" (if condition evaluated to false)`\n                        );\n                      }\n                      // Return empty result for skipped items\n                      return {\n                        index: itemIndex,\n                        itemResult: { issues: [] } as ReviewSummary,\n                        skipped: true,\n                      };\n                    }\n                  }\n\n                  if (debug) {\n                    log(\n                      `üîÑ Debug: Executing check \"${checkName}\" for item ${itemIndex + 1}/${forEachItems.length}`\n                    );\n                  }\n\n                  // Track iteration start\n                  const iterationStart = this.recordIterationStart(checkName);\n\n                  // Execute with retry/routing semantics per item\n                  let itemResult: ReviewSummary;\n                  try {\n                    itemResult = await this.executeWithRouting(\n                      checkName,\n                      checkConfig,\n                      provider,\n                      providerConfig,\n                      prInfo,\n                      snapshotDeps,\n                      sessionInfo,\n                      config,\n                      dependencyGraph,\n                      debug,\n                      results,\n                      /*foreachContext*/ {\n                        index: itemIndex,\n                        total: forEachItems.length,\n                        parent: forEachParentName,\n                      }\n                    );\n                  } catch (error) {\n                    const errorMessage = error instanceof Error ? error.message : String(error);\n                    itemResult = {\n                      issues: [\n                        {\n                          file: '',\n                          line: 0,\n                          ruleId: `${checkName}/forEach/iteration_error`,\n                          message: errorMessage,\n                          severity: 'error',\n                          category: 'logic',\n                        },\n                      ],\n                    } as ReviewSummary;\n                  }\n                  // no-op\n\n                  // Evaluate fail_if per item so a single failing branch does not stop others\n                  if (config && (config.fail_if || checkConfig.fail_if)) {\n                    const itemFailures = await this.evaluateFailureConditions(\n                      checkName,\n                      itemResult,\n                      config,\n                      prInfo,\n                      results\n                    );\n                    if (itemFailures.length > 0) {\n                      const failureIssues = itemFailures\n                        .filter(f => f.failed)\n                        .map(f => ({\n                          file: 'system',\n                          line: 0,\n                          ruleId: f.conditionName,\n                          message: f.message || `Failure condition met: ${f.expression}`,\n                          severity: (f.severity || 'error') as\n                            | 'info'\n                            | 'warning'\n                            | 'error'\n                            | 'critical',\n                          category: 'logic' as const,\n                        }));\n                      itemResult.issues = [...(itemResult.issues || []), ...failureIssues];\n                    }\n                  }\n\n                  // Record iteration completion\n                  // Check if this iteration had fatal errors\n                  const hadFatalError = (itemResult.issues || []).some(issue => {\n                    const id = issue.ruleId || '';\n                    return (\n                      id === 'command/execution_error' ||\n                      id.endsWith('/command/execution_error') ||\n                      id === 'command/transform_js_error' ||\n                      id.endsWith('/command/transform_js_error') ||\n                      id === 'command/transform_error' ||\n                      id.endsWith('/command/transform_error') ||\n                      id === 'forEach/undefined_output' ||\n                      id.endsWith('/forEach/undefined_output')\n                    );\n                  });\n                  const iterationDuration = (Date.now() - iterationStart) / 1000;\n                  this.recordIterationComplete(\n                    checkName,\n                    iterationStart,\n                    !hadFatalError, // Success if no fatal errors\n                    itemResult.issues || [],\n                    (itemResult as any).output\n                  );\n\n                  // Track output history for each forEach child iteration so\n                  // stage-level selectors and aggregators can reason about\n                  // the last wave across items.\n                  const itemOutput = (itemResult as any).output;\n                  if (itemOutput !== undefined) {\n                    // Tag history entry with loop info from parent\n                    let parentLoopIdx = 0;\n                    try {\n                      const ph = (this.outputHistory.get(forEachParentName!) || []) as unknown[];\n                      parentLoopIdx = ph.filter(x => Array.isArray(x)).length;\n                    } catch {}\n                    let histEntry: any;\n                    const itemId = (() => {\n                      try {\n                        return String((itemOutput as any)?.id ?? itemIndex + 1);\n                      } catch {\n                        return String(itemIndex + 1);\n                      }\n                    })();\n                    if (itemOutput && typeof itemOutput === 'object') {\n                      histEntry = {\n                        ...(itemOutput as any),\n                        id: itemId,\n                        parent: forEachParentName,\n                        loop_idx: parentLoopIdx,\n                        last_loop: true,\n                      };\n                    } else {\n                      histEntry = {\n                        value: itemOutput,\n                        id: itemId,\n                        parent: forEachParentName,\n                        loop_idx: parentLoopIdx,\n                        last_loop: true,\n                      } as any;\n                    }\n                    try {\n                      if ((itemResult as any).__histTracked === true) {\n                        // Provider already tracked this iteration; enrich the last entry with wave metadata\n                        const arr = (this.outputHistory.get(checkName) || []) as any[];\n                        if (\n                          arr.length > 0 &&\n                          arr[arr.length - 1] &&\n                          typeof arr[arr.length - 1] === 'object'\n                        ) {\n                          Object.assign(arr[arr.length - 1], {\n                            id: (arr[arr.length - 1] as any).id || histEntry.id,\n                            parent: forEachParentName,\n                            loop_idx: parentLoopIdx,\n                            last_loop: true,\n                          });\n                          this.outputHistory.set(checkName, arr);\n                        } else {\n                          this.trackOutputHistory(checkName, histEntry);\n                        }\n                      } else {\n                        this.trackOutputHistory(checkName, histEntry);\n                      }\n                    } catch {}\n                  } else {\n                    // Ensure completeness: synthesize a last_loop record for this item\n                    // so routing can scan only the child history without consulting the parent.\n                    let parentLoopIdx = 0;\n                    try {\n                      const ph = (this.outputHistory.get(forEachParentName!) || []) as unknown[];\n                      parentLoopIdx = ph.filter(x => Array.isArray(x)).length;\n                    } catch {}\n                    const itemId = String(itemIndex + 1);\n                    const synth: any = {\n                      id: itemId,\n                      parent: forEachParentName,\n                      loop_idx: parentLoopIdx,\n                      last_loop: true,\n                      is_valid: false,\n                      confidence: 'low',\n                      reason: 'missing',\n                    };\n                    this.trackOutputHistory(checkName, synth);\n                  }\n\n                  // General branch-first scheduling for this item: execute all descendants (from current node only) when ready\n                  const descendantSet = (() => {\n                    const visited = new Set<string>();\n                    const stack = [checkName];\n                    while (stack.length) {\n                      const p = stack.pop()!;\n                      const kids = childrenByParent.get(p) || [];\n                      for (const k of kids) {\n                        if (!visited.has(k)) {\n                          visited.add(k);\n                          stack.push(k);\n                        }\n                      }\n                    }\n                    return visited;\n                  })();\n\n                  const perItemDone = new Set<string>([...forEachParents, checkName]);\n                  const perItemDepMap = new Map<string, ReviewSummary>();\n                  perItemDepMap.set(checkName, itemResult);\n\n                  const isFatal = (r: ReviewSummary | undefined): boolean => {\n                    if (!r) return true;\n                    return this.hasFatal(r.issues || []);\n                  };\n\n                  while (true) {\n                    let progressed = false;\n                    for (const node of descendantSet) {\n                      if (perItemDone.has(node)) continue;\n                      const nodeCfg = config.checks![node];\n                      if (!nodeCfg) continue;\n                      const deps = dependencies[node] || [];\n\n                      // Are all deps satisfied for this item according to aggregate visibility/masks?\n                      let ready = true;\n                      for (const d of deps) {\n                        // If we have a per-item result for this dependency, honor its fatality\n                        const perItemRes = perItemDepMap.get(d);\n                        if (perItemRes) {\n                          if (isFatal(perItemRes)) {\n                            ready = false;\n                            break;\n                          }\n                          continue;\n                        }\n                        // If this dependency was executed earlier in this item's chain, it's satisfied\n                        if (perItemDone.has(d)) continue;\n                        const agg = results.get(d) as ExtendedReviewSummary | undefined;\n                        if (!agg) {\n                          ready = false;\n                          break;\n                        }\n                        if (agg.isForEach || Array.isArray(agg.forEachItemResults)) {\n                          const maskFatal =\n                            !!agg.forEachFatalMask && agg.forEachFatalMask[itemIndex] === true;\n                          if (maskFatal) {\n                            ready = false;\n                            break;\n                          }\n                        } else {\n                          if (isFatal(agg)) {\n                            ready = false;\n                            break;\n                          }\n                        }\n                      }\n                      if (!ready) continue;\n\n                      // if condition per item\n                      if (nodeCfg.if) {\n                        const itemScope: ScopePath = [\n                          { check: forEachParentName, index: itemIndex },\n                        ];\n                        const condResults = this.buildSnapshotDependencyResults(\n                          itemScope,\n                          undefined,\n                          prInfo.eventType\n                        );\n                        for (const [k, v] of perItemDepMap.entries()) condResults.set(k, v);\n                        const gateNode = await this.shouldRunCheck(\n                          node,\n                          nodeCfg.if,\n                          prInfo,\n                          condResults,\n                          debug,\n                          undefined,\n                          /* failSecure */ true\n                        );\n                        if (!gateNode.shouldRun) {\n                          perItemDone.add(node);\n                          progressed = true;\n                          continue;\n                        }\n                      }\n\n                      // Execute node for this item\n                      const nodeProvType = nodeCfg.type || 'ai';\n                      const nodeProv = this.providerRegistry.getProviderOrThrow(nodeProvType);\n                      this.setProviderWebhookContext(nodeProv);\n                      const nodeProviderConfig: CheckProviderConfig = {\n                        type: nodeProvType,\n                        prompt: nodeCfg.prompt,\n                        exec: nodeCfg.exec,\n                        focus: nodeCfg.focus || this.mapCheckNameToFocus(node),\n                        schema: nodeCfg.schema,\n                        group: nodeCfg.group,\n                        checkName: node,\n                        eventContext: this.enrichEventContext(prInfo.eventContext),\n                        transform: nodeCfg.transform,\n                        transform_js: nodeCfg.transform_js,\n                        env: nodeCfg.env,\n                        forEach: nodeCfg.forEach,\n                        ai: { timeout: timeout || 600000, debug: debug, ...(nodeCfg.ai || {}) },\n                      };\n\n                      const iterStart = this.recordIterationStart(node);\n                      // Build snapshot-based dependency map at item scope\n                      const itemScope: ScopePath = [{ check: forEachParentName, index: itemIndex }];\n                      const execDepMap = this.buildSnapshotDependencyResults(\n                        itemScope,\n                        undefined,\n                        prInfo.eventType\n                      );\n                      for (const [k, v] of perItemDepMap.entries()) execDepMap.set(k, v);\n\n                      let nodeItemRes: ReviewSummary;\n                      try {\n                        nodeItemRes = await this.executeWithRouting(\n                          node,\n                          nodeCfg,\n                          nodeProv,\n                          nodeProviderConfig,\n                          prInfo,\n                          execDepMap,\n                          sessionInfo,\n                          config,\n                          dependencyGraph,\n                          debug,\n                          results,\n                          {\n                            index: itemIndex,\n                            total: forEachItems.length,\n                            parent: forEachParentName,\n                          }\n                        );\n                      } catch (error) {\n                        const message = error instanceof Error ? error.message : String(error);\n                        nodeItemRes = {\n                          issues: [\n                            {\n                              file: '',\n                              line: 0,\n                              ruleId: `${node}/forEach/iteration_error`,\n                              message,\n                              severity: 'error',\n                              category: 'logic',\n                            },\n                          ],\n                        } as ReviewSummary;\n                      }\n\n                      if (config && (config.fail_if || nodeCfg.fail_if)) {\n                        const fRes = await this.evaluateFailureConditions(\n                          node,\n                          nodeItemRes,\n                          config,\n                          prInfo,\n                          results\n                        );\n                        if (fRes.length > 0) {\n                          const fIssues = fRes\n                            .filter(f => f.failed)\n                            .map(f => ({\n                              file: 'system',\n                              line: 0,\n                              ruleId: f.conditionName,\n                              message: f.message || `Failure condition met: ${f.expression}`,\n                              severity: (f.severity || 'error') as\n                                | 'info'\n                                | 'warning'\n                                | 'error'\n                                | 'critical',\n                              category: 'logic' as const,\n                            }));\n                          nodeItemRes.issues = [...(nodeItemRes.issues || []), ...fIssues];\n                        }\n                      }\n\n                      const hadFatal = isFatal(nodeItemRes);\n                      this.recordIterationComplete(\n                        node,\n                        iterStart,\n                        !hadFatal,\n                        nodeItemRes.issues || [],\n                        (nodeItemRes as any).output\n                      );\n\n                      // Aggregate results for this node across items\n                      if (!inlineAgg.has(node))\n                        inlineAgg.set(node, {\n                          issues: [],\n                          outputs: [],\n                          contents: [],\n                          perItemResults: [],\n                        });\n                      const agg = inlineAgg.get(node)!;\n                      if (nodeItemRes.issues) agg.issues.push(...nodeItemRes.issues);\n                      const nout = (nodeItemRes as any).output;\n                      if (nout !== undefined) agg.outputs.push(nout);\n                      agg.perItemResults.push(nodeItemRes);\n                      const ncontent = (nodeItemRes as any).content;\n                      if (typeof ncontent === 'string' && ncontent.trim())\n                        agg.contents.push(ncontent.trim());\n\n                      perItemDepMap.set(node, nodeItemRes);\n                      perItemDone.add(node);\n                      progressed = true;\n                    }\n                    if (!progressed) break;\n                  }\n\n                  // Log iteration progress\n                  logger.info(\n                    `  ‚úî ${itemIndex + 1}/${forEachItems.length} (${iterationDuration.toFixed(1)}s)`\n                  );\n\n                  perItemResults[itemIndex] = itemResult;\n                  return { index: itemIndex, itemResult };\n                });\n\n                // Determine runnable indices by intersecting masks across all direct forEach parents\n                const directForEachParents = (checkConfig.depends_on || []).filter(dep => {\n                  const r = results.get(dep) as ExtendedReviewSummary | undefined;\n                  return (\n                    !!r &&\n                    (r.isForEach ||\n                      Array.isArray(r.forEachItemResults) ||\n                      Array.isArray(r.forEachItems))\n                  );\n                });\n                if (directForEachParents.length > 0) {\n                  logger.debug(\n                    `  forEach: direct parents for \"${checkName}\": ${directForEachParents.join(', ')}`\n                  );\n                }\n\n                const isIndexFatalForParent = async (\n                  parent: string,\n                  idx: number\n                ): Promise<boolean> => {\n                  const agg = results.get(parent) as ExtendedReviewSummary | undefined;\n                  if (!agg) return false; // if missing, do not gate\n                  if (agg.forEachFatalMask && agg.forEachFatalMask[idx] === true) return true;\n                  const r = (agg.forEachItemResults && agg.forEachItemResults[idx]) || undefined;\n                  if (!r) return false;\n                  // 1) Issues-based fatality (provider/transform/timeout/fail_if markers)\n                  const hadFatalByIssues = this.hasFatal(r.issues || []);\n                  if (hadFatalByIssues) return true;\n                  // 2) Fail_if based fatality evaluated directly on the parent per-item result\n                  try {\n                    // For gating runnable indices, only consider the parent's own fail_if,\n                    // not the global fail_if. Global conditions are evaluated at the check\n                    // level and should not suppress per-item dependent execution.\n                    const parentFailIf =\n                      config && config.checks && config.checks[parent]\n                        ? (config.checks as any)[parent]?.fail_if\n                        : undefined;\n                    if (parentFailIf) {\n                      // If output is a string, try parsing JSON (full or tail) to honor fail_if semantics\n                      let rForEval: ReviewSummary = r;\n                      const rawOut = (r as any)?.output;\n                      if (typeof rawOut === 'string') {\n                        const parseTail = (text: string): unknown | null => {\n                          try {\n                            const lines = text.split('\\n');\n                            for (let i = lines.length - 1; i >= 0; i--) {\n                              const t = lines[i].trim();\n                              if (t.startsWith('{') || t.startsWith('[')) {\n                                const candidate = lines.slice(i).join('\\n').trim();\n                                if (\n                                  (candidate.startsWith('{') && candidate.endsWith('}')) ||\n                                  (candidate.startsWith('[') && candidate.endsWith(']'))\n                                ) {\n                                  return JSON.parse(candidate);\n                                }\n                              }\n                            }\n                          } catch {}\n                          try {\n                            return JSON.parse(text);\n                          } catch {\n                            return null;\n                          }\n                        };\n                        const parsed = parseTail(rawOut);\n                        if (parsed && typeof parsed === 'object') {\n                          rForEval = { ...r, output: parsed } as ReviewSummary & {\n                            output?: unknown;\n                          };\n                        }\n                      }\n                      const failures = await this.evaluateFailureConditions(\n                        parent,\n                        rForEval,\n                        // Evaluate against a shallow config that only carries the parent's fail_if\n                        {\n                          ...config,\n                          fail_if: undefined,\n                          checks: {\n                            ...(config?.checks || {}),\n                            [parent]: {\n                              ...(config?.checks as any)?.[parent],\n                              fail_if: parentFailIf,\n                            },\n                          },\n                        } as any,\n                        prInfo,\n                        results\n                      );\n                      if (failures.some(f => f.failed)) {\n                        // Temporary: surface why index is gated\n                      }\n                      if (failures.some(f => f.failed)) return true;\n                    }\n                  } catch {}\n                  return false;\n                };\n\n                // General behavior: when a check depends on a forEach parent, attempt to\n                // run for every produced item unless there are explicit fatal markers\n                // on the corresponding parent items. This avoids accidental suppression\n                // due to broad/global conditions and matches intuitive pipeline semantics.\n                const runnableIndices: number[] = [];\n                for (let idx = 0; idx < forEachItems.length; idx++) {\n                  let blocked = false;\n                  for (const p of directForEachParents) {\n                    if (await isIndexFatalForParent(p, idx)) {\n                      blocked = true;\n                      break;\n                    }\n                  }\n                  if (!blocked && typeof itemTasks[idx] === 'function') runnableIndices.push(idx);\n                }\n\n                // no-op\n                // Early skip if no runnable items after intersecting masks across all direct forEach parents\n                if (runnableIndices.length === 0) {\n                  // Failsafe: if the parent produced items but all were masked by dependency gating\n                  // and there are no explicit fatal markers on the parent per-item results,\n                  // attempt to run all items. This prevents accidental total gating due to\n                  // overly-broad fail_if on ancestors. This is general-purpose and keeps\n                  // dependent checks functional when parents are non-fatal.\n                  const parent = directForEachParents[0];\n                  let anyExplicitFatal = false;\n                  if (parent) {\n                    const agg = results.get(parent) as ExtendedReviewSummary | undefined;\n                    if (agg && Array.isArray(agg.forEachItemResults)) {\n                      for (const r of agg.forEachItemResults) {\n                        if (!r) continue;\n                        if (this.hasFatal(r?.issues || [])) {\n                          anyExplicitFatal = true;\n                          break;\n                        }\n                      }\n                    }\n                  }\n                  if (!anyExplicitFatal && forEachItems.length > 0) {\n                    logger.warn(\n                      `‚ö†Ô∏è  forEach: no runnable items for \"${checkName}\" after gating ‚Äî falling back to run all ${forEachItems.length}`\n                    );\n                    for (let idx = 0; idx < forEachItems.length; idx++) {\n                      if (typeof itemTasks[idx] === 'function') runnableIndices.push(idx);\n                    }\n                  }\n                  if (runnableIndices.length === 0) {\n                    this.recordSkip(checkName, 'dependency_failed');\n                    logger.info(`‚è≠  Skipped (dependency failed: no runnable items)`);\n                    return {\n                      checkName,\n                      error: null,\n                      result: { issues: [] },\n                      skipped: true,\n                    };\n                  }\n                }\n\n                const forEachConcurrency = Math.max(\n                  1,\n                  Math.min(runnableIndices.length, effectiveMaxParallelism)\n                );\n\n                if (debug && forEachConcurrency > 1) {\n                  log(\n                    `üîÑ Debug: Limiting forEach concurrency for check \"${checkName}\" to ${forEachConcurrency}`\n                  );\n                }\n\n                const scheduledTasks = runnableIndices\n                  .map(i => itemTasks[i])\n                  .filter(fn => typeof fn === 'function');\n                const forEachResults = await this.executeWithLimitedParallelism(\n                  scheduledTasks,\n                  forEachConcurrency,\n                  false\n                );\n\n                let processedCount = 0;\n                for (const result of forEachResults) {\n                  if (result.status === 'rejected') {\n                    // Instead of throwing, record the failure and continue with other iterations\n                    const error = result.reason;\n                    const errorMessage = error instanceof Error ? error.message : String(error);\n\n                    // Create an error issue for this failed iteration\n                    allIssues.push({\n                      ruleId: `${checkName}/forEach/iteration_error`,\n                      severity: 'error',\n                      category: 'logic',\n                      message: `forEach iteration failed: ${errorMessage}`,\n                      file: '',\n                      line: 0,\n                    });\n\n                    if (debug) {\n                      log(\n                        `üîÑ Debug: forEach iteration for check \"${checkName}\" failed: ${errorMessage}`\n                      );\n                    }\n                    continue;\n                  }\n\n                  // Skip results from skipped items (those gated by dependencies/if)\n                  if ((result.value as any).skipped) {\n                    continue;\n                  }\n\n                  const { index: finishedIndex, itemResult } = result.value as any;\n                  processedCount++;\n\n                  if (itemResult.issues) {\n                    allIssues.push(...itemResult.issues);\n                  }\n\n                  const resultWithOutput = itemResult as ReviewSummary & {\n                    output?: unknown;\n                    content?: string;\n                  };\n\n                  allOutputs[finishedIndex] = resultWithOutput.output;\n\n                  const itemContent = resultWithOutput.content;\n                  if (typeof itemContent === 'string' && itemContent.trim()) {\n                    aggregatedContents.push(itemContent.trim());\n                  } else {\n                    const outStr =\n                      typeof resultWithOutput.output === 'string'\n                        ? (resultWithOutput.output as string).trim()\n                        : '';\n                    if (outStr) aggregatedContents.push(outStr);\n                  }\n                }\n\n                // If no items were processed (all gated), mark this check as skipped for dependency_failed\n                if (processedCount === 0) {\n                  this.recordSkip(checkName, 'dependency_failed');\n                  logger.info(`‚è≠  Skipped (dependency failed for all items)`);\n                  return {\n                    checkName,\n                    error: null,\n                    result: { issues: [] },\n                    skipped: true,\n                  };\n                }\n\n                const finalOutput = allOutputs.length > 0 ? allOutputs : undefined;\n\n                finalResult = {\n                  issues: allIssues,\n                  ...(finalOutput !== undefined ? { output: finalOutput } : {}),\n                } as ExtendedReviewSummary;\n\n                // Mark this result as forEach-capable and attach per-item results for precise downstream gating\n                (finalResult as ExtendedReviewSummary).isForEach = true;\n                (finalResult as ExtendedReviewSummary).forEachItems = allOutputs;\n                (finalResult as ExtendedReviewSummary).forEachItemResults =\n                  perItemResults as ReviewSummary[];\n                // Compute fatal mask\n                try {\n                  const mask: boolean[] = (finalResult as ExtendedReviewSummary).forEachItemResults\n                    ? await Promise.all(\n                        Array.from({ length: forEachItems.length }, async (_, idx) => {\n                          const r = (finalResult as ExtendedReviewSummary).forEachItemResults![idx];\n                          if (!r) return false; // no result (skipped) ‚Üí not fatal for descendants\n                          let hadFatal = this.hasFatal(r.issues || []);\n                          try {\n                            const ids = (r.issues || []).map(i => i.ruleId).join(',');\n                            logger.debug(\n                              `  forEach: item ${idx + 1}/${forEachItems.length} issues=${(r.issues || []).length} ids=[${ids}]`\n                            );\n                          } catch {}\n                          if (!hadFatal && config && (config.fail_if || checkConfig.fail_if)) {\n                            try {\n                              const failures = await this.evaluateFailureConditions(\n                                checkName,\n                                r,\n                                config,\n                                prInfo,\n                                results\n                              );\n                              hadFatal = failures.some(f => f.failed);\n                            } catch {}\n                          }\n                          return hadFatal;\n                        })\n                      )\n                    : [];\n                  (finalResult as ExtendedReviewSummary).forEachFatalMask = mask;\n                  logger.debug(\n                    `  forEach: mask for \"${checkName}\" ‚Üí fatals=${mask.filter(Boolean).length}/${mask.length}`\n                  );\n                } catch {}\n\n                if (aggregatedContents.length > 0) {\n                  (finalResult as ReviewSummary & { content?: string }).content =\n                    aggregatedContents.join('\\n');\n                }\n\n                // Finalize inline descendant aggregations to full results, so later levels skip them\n                for (const [childName, agg] of inlineAgg.entries()) {\n                  const childCfg = config.checks![childName];\n                  const childEnrichedIssues = (agg.issues || []).map(issue => ({\n                    ...issue,\n                    checkName: childName,\n                    ruleId: `${childName}/${issue.ruleId}`,\n                    group: childCfg.group,\n                    schema: typeof childCfg.schema === 'object' ? 'custom' : childCfg.schema,\n                    template: childCfg.template,\n                    timestamp: Date.now(),\n                  }));\n                  const childFinal: ExtendedReviewSummary = {\n                    issues: childEnrichedIssues,\n                    ...(agg.outputs.length > 0 ? { output: agg.outputs } : {}),\n                    isForEach: true,\n                    forEachItems: agg.outputs,\n                    forEachItemResults: agg.perItemResults,\n                    ...(agg.contents.length > 0 ? { content: agg.contents.join('\\n') } : {}),\n                  };\n                  // Compute fatal mask for child aggregate\n                  try {\n                    const mask: boolean[] = Array.from(\n                      { length: agg.perItemResults.length },\n                      (_, idx) => {\n                        const r = agg.perItemResults[idx];\n                        if (!r) return false; // skipped item is not fatal for descendants\n                        const hadFatal = (r.issues || []).some(issue => {\n                          const id = issue.ruleId || '';\n                          return (\n                            issue.severity === 'error' ||\n                            issue.severity === 'critical' ||\n                            id === 'command/execution_error' ||\n                            id.endsWith('/command/execution_error') ||\n                            id === 'command/timeout' ||\n                            id.endsWith('/command/timeout') ||\n                            id === 'command/transform_js_error' ||\n                            id.endsWith('/command/transform_js_error') ||\n                            id === 'command/transform_error' ||\n                            id.endsWith('/command/transform_error') ||\n                            id.endsWith('/forEach/iteration_error') ||\n                            id === 'forEach/undefined_output' ||\n                            id.endsWith('/forEach/undefined_output') ||\n                            id.endsWith('_fail_if') ||\n                            id.endsWith('/global_fail_if')\n                          );\n                        });\n                        return hadFatal;\n                      }\n                    );\n                    childFinal.forEachFatalMask = mask;\n                  } catch {}\n                  results.set(childName, childFinal);\n                }\n\n                if (\n                  debug &&\n                  process.env.VISOR_OUTPUT_FORMAT !== 'json' &&\n                  process.env.VISOR_OUTPUT_FORMAT !== 'sarif'\n                ) {\n                  console.log(\n                    `üîÑ Debug: Completed forEach execution for check \"${checkName}\", total issues: ${allIssues.length}`\n                  );\n                }\n              } // End of else block for forEachItems.length > 0\n            } else {\n              // Normal single execution\n              // Evaluate if condition for non-forEach-dependent checks\n              if (checkConfig.if) {\n                const gate = await this.shouldRunCheck(\n                  checkName,\n                  checkConfig.if,\n                  prInfo,\n                  results,\n                  debug,\n                  undefined,\n                  /* failSecure */ true\n                );\n\n                if (!gate.shouldRun) {\n                  // Record skip with condition\n                  this.recordSkip(checkName, 'if_condition', checkConfig.if);\n                  logger.info(`‚è≠  Skipped (if: ${this.truncate(checkConfig.if, 40)})`);\n                  return {\n                    checkName,\n                    error: null,\n                    result: {\n                      issues: [],\n                    },\n                    skipped: true,\n                  };\n                }\n              }\n\n              // Execute with retry/routing semantics\n              finalResult = await this.executeWithRouting(\n                checkName,\n                checkConfig,\n                provider,\n                providerConfig,\n                prInfo,\n                dependencyResults,\n                sessionInfo,\n                config,\n                dependencyGraph,\n                debug,\n                results\n              );\n              try {\n                emitNdjsonSpanWithEvents('visor.check', { 'visor.check.id': checkName }, [\n                  { name: 'check.started' },\n                  { name: 'check.completed' },\n                ]);\n              } catch {}\n\n              // Pre-fail_if debug only; history is tracked earlier after provider execution.\n              try {\n                const outVal = (finalResult as any)?.output;\n                if (process.env.VISOR_DEBUG === 'true' && checkName === 'refine') {\n                  console.error(`[pre-fail-if refine] hasOutput=${String(outVal !== undefined)}`);\n                }\n              } catch {}\n\n              // Evaluate fail_if for normal (non-forEach) execution\n              if (config && (config.fail_if || checkConfig.fail_if)) {\n                try {\n                  if (debug) {\n                    const outAny = (finalResult as any)?.output;\n                    const keys =\n                      outAny && typeof outAny === 'object'\n                        ? Object.keys(outAny).join(',')\n                        : typeof outAny;\n                    console.log(`[debug] pre-fail_if ${checkName} output keys=${keys}`);\n                  }\n                } catch {}\n                const failureResults = await this.evaluateFailureConditions(\n                  checkName,\n                  finalResult,\n                  config,\n                  prInfo,\n                  results\n                );\n                // Make this result visible to subsequent inline routing before we possibly goto.\n                try {\n                  results.set(checkName, finalResult as ReviewSummary);\n                  this.commitJournal(\n                    checkName,\n                    finalResult as ExtendedReviewSummary,\n                    prInfo.eventType\n                  );\n                  try {\n                    (finalResult as any).__storedVisible = true;\n                  } catch {}\n                } catch {}\n                if (failureResults.length > 0) {\n                  // Do not override fail_if outcomes implicitly. Routing decisions\n                  // should be explicit via on_fail and bounded by routing.max_loops.\n                  const failureIssues = failureResults\n                    .filter(f => f.failed)\n                    .map(f => ({\n                      file: 'system',\n                      line: 0,\n                      ruleId: f.conditionName,\n                      message: f.message || `Failure condition met: ${f.expression}`,\n                      severity: (f.severity || 'error') as\n                        | 'info'\n                        | 'warning'\n                        | 'error'\n                        | 'critical',\n                      category: 'logic' as const,\n                    }));\n                  finalResult.issues = [...(finalResult.issues || []), ...failureIssues];\n\n                  // Post-evaluation routing: if fail_if produced any triggered condition and on_fail.goto is\n                  // configured, honor goto routing here as a soft-failure. This ensures checks that signal\n                  // failure via fail_if (without provider errors) can still drive refine loops.\n                  try {\n                    const hadTriggered = failureResults.some(r => r.failed === true);\n                    const ofCfg: OnFailConfig | undefined = checkConfig.on_fail\n                      ? { ...(config?.routing?.defaults?.on_fail || {}), ...checkConfig.on_fail }\n                      : undefined;\n                    if (hadTriggered && ofCfg && (ofCfg.goto || ofCfg.goto_js)) {\n                      const scope = {\n                        step: {\n                          id: checkName,\n                          tags: checkConfig.tags || [],\n                          group: checkConfig.group,\n                        },\n                        outputs: Object.fromEntries(results.entries()),\n                        output: (finalResult as any)?.output,\n                        event: { name: prInfo.eventType || 'manual' },\n                      };\n                      const target = await this.evaluateGotoTarget(\n                        (ofCfg.goto_js as string | undefined) || undefined,\n                        (ofCfg.goto as string | undefined) || undefined,\n                        scope,\n                        debug || false,\n                        log\n                      );\n                      if (target) {\n                        try {\n                          require('./logger').logger.info(\n                            `‚Ü™ on_fail.goto(post-fail_if): jumping to '${target}' from '${checkName}'`\n                          );\n                        } catch {}\n                        await this.scheduleGoto(\n                          'on_fail',\n                          target,\n                          ofCfg.goto_event,\n                          checkName,\n                          checkConfig,\n                          [],\n                          config!,\n                          dependencyGraph,\n                          prInfo,\n                          results,\n                          debug\n                        );\n                      }\n                    }\n                  } catch {}\n                }\n              }\n\n              // Record normal (non-forEach) execution\n              // Check if this check had fatal errors\n              const hadFatalError = (finalResult.issues || []).some(issue => {\n                const id = issue.ruleId || '';\n                return (\n                  id === 'command/execution_error' ||\n                  id.endsWith('/command/execution_error') ||\n                  id === 'command/timeout' ||\n                  id.endsWith('/command/timeout') ||\n                  id === 'command/transform_js_error' ||\n                  id.endsWith('/command/transform_js_error') ||\n                  id === 'command/transform_error' ||\n                  id.endsWith('/command/transform_error') ||\n                  id === 'forEach/undefined_output' ||\n                  id.endsWith('/forEach/undefined_output')\n                );\n              });\n              this.recordIterationComplete(\n                checkName,\n                checkStartTime,\n                !hadFatalError, // Success if no fatal errors\n                finalResult.issues || [],\n                (finalResult as any).output\n              );\n\n              // (history handled centrally in executeCheckInline)\n\n              if (checkConfig.forEach) {\n                try {\n                  const finalResultWithOutput = finalResult as ExtendedReviewSummary;\n                  const outputPreview =\n                    JSON.stringify(finalResultWithOutput.output)?.slice(0, 200) || '(empty)';\n                  logger.debug(\n                    `üîß Debug: Check \"${checkName}\" provider returned: ${outputPreview}`\n                  );\n                } catch {\n                  // Ignore logging errors\n                }\n              }\n\n              if (debug) {\n                log(\n                  `üîß Debug: Completed check: ${checkName}, issues found: ${(finalResult.issues || []).length}`\n                );\n              }\n\n              // Track cloned session IDs for cleanup\n              if (finalResult.sessionId) {\n                sessionIds.set(checkName, finalResult.sessionId);\n                if (debug) {\n                  log(`üîß Debug: Tracked cloned session for cleanup: ${finalResult.sessionId}`);\n                }\n              }\n            }\n\n            // Add checkName, group, schema, template info and timestamp to issues from config\n            const enrichedIssues = (finalResult.issues || []).map(issue => ({\n              ...issue,\n              checkName: checkName,\n              ruleId: `${checkName}/${issue.ruleId}`,\n              group: checkConfig.group,\n              schema: typeof checkConfig.schema === 'object' ? 'custom' : checkConfig.schema,\n              template: checkConfig.template,\n              timestamp: Date.now(),\n            }));\n\n            const enrichedResult = {\n              ...finalResult,\n              issues: enrichedIssues,\n            };\n\n            const checkDuration = ((Date.now() - checkStartTime) / 1000).toFixed(1);\n            const issueCount = enrichedIssues.length;\n            const checkStats = this.executionStats.get(checkName);\n\n            // Enhanced completion message with forEach stats\n            if (checkStats && checkStats.totalRuns > 1) {\n              if (issueCount > 0) {\n                logger.success(\n                  `Check complete: ${checkName} (${checkDuration}s) - ${checkStats.totalRuns} runs, ${issueCount} issue${issueCount === 1 ? '' : 's'}`\n                );\n              } else {\n                logger.success(\n                  `Check complete: ${checkName} (${checkDuration}s) - ${checkStats.totalRuns} runs`\n                );\n              }\n            } else if (checkStats && checkStats.outputsProduced && checkStats.outputsProduced > 0) {\n              logger.success(\n                `Check complete: ${checkName} (${checkDuration}s) - ${checkStats.outputsProduced} items`\n              );\n            } else if (issueCount > 0) {\n              logger.success(\n                `Check complete: ${checkName} (${checkDuration}s) - ${issueCount} issue${issueCount === 1 ? '' : 's'} found`\n              );\n            } else {\n              logger.success(`Check complete: ${checkName} (${checkDuration}s)`);\n            }\n\n            return {\n              checkName,\n              error: null,\n              result: enrichedResult,\n            };\n          } catch (error) {\n            const errorMessage =\n              error instanceof Error ? `${error.message}\\n${error.stack || ''}` : String(error);\n            const checkDuration = ((Date.now() - checkStartTime) / 1000).toFixed(1);\n\n            // Record error in stats\n            this.recordError(checkName, error instanceof Error ? error : new Error(String(error)));\n            this.recordIterationComplete(checkName, checkStartTime, false, [], undefined);\n\n            logger.error(`‚úñ Check failed: ${checkName} (${checkDuration}s) - ${errorMessage}`);\n\n            if (debug) {\n              log(`üîß Debug: Error in check ${checkName}: ${errorMessage}`);\n            }\n\n            return {\n              checkName,\n              error: errorMessage,\n              result: null,\n            };\n          }\n        });\n\n        // Execute checks in this level with controlled parallelism\n        const levelResults = await this.executeWithLimitedParallelism(\n          levelTaskFunctions,\n          actualParallelism,\n          effectiveFailFast\n        );\n\n        // Process results and store them for next level\n        const levelChecksList = checksInLevel.filter((name: string) => !results.has(name));\n        for (let i = 0; i < levelResults.length; i++) {\n          const checkName = levelChecksList[i];\n          const result = levelResults[i] as any;\n          if (!checkName) continue;\n          const checkConfig = config.checks![checkName];\n          if (!checkConfig) continue;\n\n          const isFulfilled = result && result.status === 'fulfilled';\n          const value: any = isFulfilled ? result.value : undefined;\n          if (isFulfilled && value?.result && !value?.error) {\n            // For skipped checks, store a marker so dependent checks can detect the skip\n            if ((value as any).skipped) {\n              if (debug) {\n                log(`üîß Debug: Storing skip marker for skipped check \"${checkName}\"`);\n              }\n              // Store a special marker result with a skip issue so dependencies can detect it\n              results.set(checkName, {\n                issues: [\n                  {\n                    ruleId: `${checkName}/__skipped`,\n                    severity: 'info',\n                    category: 'logic',\n                    message: 'Check was skipped',\n                    file: '',\n                    line: 0,\n                  },\n                ],\n              });\n              continue;\n            }\n            const reviewResult = value.result as ReviewSummary;\n\n            // Handle forEach logic - process array outputs\n            const reviewSummaryWithOutput = reviewResult as ExtendedReviewSummary;\n\n            if (\n              checkConfig?.forEach &&\n              (!reviewResult.issues || reviewResult.issues.length === 0)\n            ) {\n              const validation = this.validateAndNormalizeForEachOutput(\n                checkName,\n                reviewSummaryWithOutput.output,\n                checkConfig.group\n              );\n\n              if (!validation.isValid) {\n                results.set(\n                  checkName,\n                  validation.error.issues ? { issues: validation.error.issues } : {}\n                );\n                continue;\n              }\n\n              const normalizedOutput = validation.normalizedOutput;\n\n              logger.debug(\n                `üîß Debug: Raw output for forEach check ${checkName}: ${\n                  Array.isArray(reviewSummaryWithOutput.output)\n                    ? `array(${reviewSummaryWithOutput.output.length})`\n                    : typeof reviewSummaryWithOutput.output\n                }`\n              );\n\n              try {\n                const preview = JSON.stringify(normalizedOutput);\n                logger.debug(\n                  `üîß Debug: Check \"${checkName}\" forEach output: ${preview?.slice(0, 200) || '(empty)'}`\n                );\n              } catch {\n                // Ignore logging errors\n              }\n\n              // Store the array for iteration by dependent checks\n              reviewSummaryWithOutput.forEachItems = normalizedOutput;\n              reviewSummaryWithOutput.isForEach = true;\n              try {\n                const st = this.executionStats.get(checkName);\n                if (st) st.outputsProduced = normalizedOutput.length;\n              } catch {}\n            }\n\n            try {\n              emitNdjsonSpanWithEvents('visor.check', { 'visor.check.id': checkName }, [\n                { name: 'check.started' },\n                { name: 'check.completed' },\n              ]);\n            } catch {}\n\n            // Track output history for loop/goto scenarios (unconditional for non-forEach checks)\n            const reviewResultWithOutput = reviewResult as ExtendedReviewSummary & {\n              output?: unknown;\n            };\n            const hasOutput = reviewResultWithOutput.output !== undefined;\n            if (hasOutput) {\n              const isForEachAggregateChild =\n                !checkConfig.forEach &&\n                (reviewResultWithOutput as any).isForEach === true &&\n                (Array.isArray(reviewResultWithOutput.forEachItems) ||\n                  Array.isArray((reviewResultWithOutput as any).output));\n\n              // Do not push aggregated array output for:\n              //  - forEach dependents (map children): per-item outputs are recorded elsewhere\n              //  - forEach parents themselves: the aggregate array is pushed once in the\n              //    dedicated forEach commit block below. Skipping here avoids double count.\n              // Always track history for non-forEach checks. Tests and real runs\n              // both rely on outputs_history to drive correction loops and exact\n              // run counting; gating on test mode caused under-counting.\n              if (!isForEachAggregateChild && !checkConfig.forEach) {\n                try {\n                  const already = (reviewResultWithOutput as any).__histTracked === true;\n                  try {\n                    if (process.env.VISOR_DEBUG === 'true' && checkName === 'refine') {\n                      console.error(`[grouped-hist] ${checkName} __histTracked=${String(already)}`);\n                    }\n                  } catch {}\n                  if (!already) {\n                    const outVal: any = reviewResultWithOutput.output as any;\n                    let histVal: any = outVal;\n                    if (Array.isArray(outVal)) {\n                      histVal = outVal;\n                    } else if (outVal !== null && typeof outVal === 'object') {\n                      histVal = { ...outVal };\n                      if ((histVal as any).ts === undefined) (histVal as any).ts = Date.now();\n                    } else {\n                      histVal = { text: String(outVal), ts: Date.now() };\n                    }\n                    this.trackOutputHistory(checkName, histVal);\n                  }\n                } catch {\n                  try {\n                    this.trackOutputHistory(checkName, reviewResultWithOutput.output);\n                  } catch {}\n                }\n              }\n            } else {\n              // Even if provider returned no output, ensure history array exists for this check\n              try {\n                if (!this.outputHistory.has(checkName)) this.outputHistory.set(checkName, []);\n              } catch {}\n            }\n\n            results.set(checkName, reviewResult);\n            // Phase 4: commit aggregate and per-item entries for forEach checks; else single aggregate\n            const agg = reviewResult as ExtendedReviewSummary;\n            if (\n              checkConfig?.forEach &&\n              (Array.isArray(agg.forEachItems) || Array.isArray((agg as any).output))\n            ) {\n              // Compute next loop index for this forEach parent and clear previous last_loop flags\n              let loopIdx = 1;\n              try {\n                const hist = (this.outputHistory.get(checkName) || []) as unknown[];\n                const arraysSoFar = hist.filter(x => Array.isArray(x)).length;\n                loopIdx = arraysSoFar + 1;\n              } catch {}\n              try {\n                for (const [, arr] of this.outputHistory.entries()) {\n                  if (!Array.isArray(arr)) continue;\n                  for (const e of arr as unknown[]) {\n                    if (e && typeof e === 'object' && (e as any).last_loop === true) {\n                      try {\n                        (e as any).last_loop = false;\n                      } catch {}\n                    }\n                  }\n                }\n              } catch {}\n              // Track aggregate array in history so on_finish.goto_js can compute\n              // per-wave item counts from outputs_history['extract-facts'].\n              try {\n                const arrForHist: unknown[] = Array.isArray(agg.forEachItems)\n                  ? (agg.forEachItems as unknown[])\n                  : Array.isArray((agg as any).output)\n                    ? ((agg as any).output as unknown[])\n                    : [];\n                this.trackOutputHistory(checkName, arrForHist);\n                // Also push a loop marker with ids and last_loop flag\n                const ids: string[] = [];\n                for (let i = 0; i < arrForHist.length; i++) {\n                  const it = arrForHist[i] as any;\n                  const id = it && (it.id != null ? String(it.id) : String(i + 1));\n                  ids.push(id);\n                }\n                this.trackOutputHistory(checkName, {\n                  loop_idx: loopIdx,\n                  last_loop: true,\n                  items: ids,\n                });\n              } catch {}\n              // Commit aggregate at root scope\n              this.commitJournal(checkName, agg, prInfo.eventType, []);\n              const items: unknown[] = Array.isArray(agg.forEachItems)\n                ? (agg.forEachItems as unknown[])\n                : Array.isArray((agg as any).output)\n                  ? ((agg as any).output as unknown[])\n                  : [];\n              for (let i = 0; i < items.length; i++) {\n                const item = items[i];\n                try {\n                  this.commitJournal(\n                    checkName,\n                    { issues: [], output: item } as ExtendedReviewSummary,\n                    prInfo.eventType,\n                    [{ check: checkName, index: i }]\n                  );\n                } catch {}\n              }\n            } else {\n              try {\n                const __already = (reviewResult as any).__storedVisible === true;\n                if (!__already) {\n                  this.commitJournal(\n                    checkName,\n                    reviewResult as ExtendedReviewSummary,\n                    prInfo.eventType\n                  );\n                }\n              } catch {\n                this.commitJournal(\n                  checkName,\n                  reviewResult as ExtendedReviewSummary,\n                  prInfo.eventType\n                );\n              }\n            }\n          } else {\n            // Store error result for dependency tracking\n            const errorSummary: ReviewSummary = {\n              issues: [\n                {\n                  file: 'system',\n                  line: 0,\n                  endLine: undefined,\n                  ruleId: `${checkName}/error`,\n                  message: isFulfilled\n                    ? value?.error || 'Unknown error'\n                    : result?.reason instanceof Error\n                      ? result.reason.message\n                      : String(result?.reason),\n                  severity: 'error',\n                  category: 'logic',\n                  suggestion: undefined,\n                  replacement: undefined,\n                },\n              ],\n            };\n            results.set(checkName, errorSummary);\n            // Phase 0: commit to journal (with event scoping)\n            this.commitJournal(checkName, errorSummary as ExtendedReviewSummary, prInfo.eventType);\n\n            // Check if we should stop execution due to fail-fast\n            if (effectiveFailFast) {\n              if (debug) {\n                log(`üõë Check \"${checkName}\" failed and fail-fast is enabled - stopping execution`);\n              }\n              shouldStopExecution = true;\n              break;\n            }\n          }\n        }\n\n        // If fail-fast is enabled, check if any successful checks have failure conditions\n        if (effectiveFailFast && !shouldStopExecution) {\n          for (let i = 0; i < levelResults.length; i++) {\n            const checkName = checksInLevel[i];\n            const result = levelResults[i] as any;\n            if (!checkName) continue;\n\n            if (result?.status === 'fulfilled' && result?.value?.result && !result?.value?.error) {\n              // Check for issues that should trigger fail-fast\n              const hasFailuresToReport = ((result.value.result.issues || []) as any[]).some(\n                (issue: any) => issue.severity === 'error' || issue.severity === 'critical'\n              );\n\n              if (hasFailuresToReport) {\n                if (debug) {\n                  log(\n                    `üõë Check \"${checkName}\" found critical/high issues and fail-fast is enabled - stopping execution`\n                  );\n                }\n                shouldStopExecution = true;\n                break;\n              }\n            }\n          }\n        }\n      }\n    };\n\n    // Wave loop: run levels; if an on_fail forward-run happened, schedule another wave\n    for (; wave <= maxWaves && !shouldStopExecution; wave++) {\n      if (wave > 1) {\n        // Prepare new wave: allow re-execution of steps; keep history\n        results.clear();\n        await runWave();\n      }\n      await executeLevels();\n      const sawFail = Boolean((this as any).onFailForwardRunSeen);\n      const sawFinish = Boolean((this as any).onFinishForwardRunSeen);\n      const sawSuccess = Boolean((this as any).onSuccessForwardRunSeen);\n      const saw = sawFail || sawFinish || sawSuccess;\n      const pending = (() => {\n        try {\n          return this.forwardDependentsScheduled && this.forwardDependentsScheduled.size > 0;\n        } catch {\n          return false;\n        }\n      })();\n      if (debug)\n        (config?.output?.pr_comment ? console.error : console.log)(\n          `üîÅ Debug: wave ${wave} saw onFailForwardRunSeen=${String(saw)} pendingForward=${String(pending)}`\n        );\n      // Only schedule another wave if a correction was signaled AND at least one target was\n      // marked for forward execution. This prevents unnecessary extra waves after success.\n      if (!(saw && pending)) break;\n      // New wave planning; reset per-wave suppression list\n      try {\n        this.gotoSuppressedChecks.clear();\n      } catch {}\n      // Merge forward-scheduled targets into a fresh planned checks set and rebuild the\n      // dependency graph for the next wave so routed children execute via the DAG.\n      // IMPORTANT: start from an empty set rather than the previous wave's\n      // full set. Keeping the previous set causes unrelated, event-matching\n      // roots (e.g., comment-assistant) to persist across waves and re-run\n      // indefinitely whenever any forward-run occurs. Next waves must contain\n      // only the routed target(s) and, for success/fail-originated routing,\n      // their DAG dependents that match the effective event.\n      try {\n        const forwardTargets = Array.from(\n          (this.forwardDependentsScheduled || new Map<string, Set<string>>()).keys()\n        );\n        if (forwardTargets.length > 0) {\n          const nextSet = new Set<string>();\n          const allChecks = Object.keys(config?.checks || {});\n          const expandTokFwd = (tok: any): string[] =>\n            typeof tok === 'string' && tok.includes('|')\n              ? tok\n                  .split('|')\n                  .map(s => s.trim())\n                  .filter(Boolean)\n              : tok\n                ? [String(tok)]\n                : [];\n          const dependsOn = (\n            candidate: string,\n            root: string,\n            seen = new Set<string>()\n          ): boolean => {\n            if (seen.has(candidate)) return false;\n            seen.add(candidate);\n            const cfg = (config?.checks || {})[candidate];\n            const depTokens: any[] = Array.isArray(cfg?.depends_on)\n              ? (cfg!.depends_on as any[])\n              : cfg?.depends_on\n                ? [cfg.depends_on]\n                : [];\n            const deps = depTokens.flatMap(expandTokFwd);\n            if (deps.includes(root)) return true;\n            return deps.some(d => dependsOn(d, root, seen));\n          };\n          // Seed next wave with forward targets\n          for (const t of forwardTargets) {\n            nextSet.add(t);\n            const includeDeps = this.forwardIncludeDependents.get(t);\n            const shouldInclude = includeDeps !== false; // default true\n            if (!shouldInclude) continue;\n            const effEvent =\n              this.forwardEventOverrides.get(t) || (prInfo.eventType as any) || 'manual';\n            for (const cand of allChecks) {\n              if (cand === t) continue;\n              if (!dependsOn(cand, t)) continue;\n              const cCfg = (config.checks || {})[cand];\n              // Optional filter: for correction waves we may exclude forEach parents\n              const excludeForEach = this.forwardExcludeForEachDependents.get(t) === true;\n              if (excludeForEach && (cCfg as any)?.forEach) continue;\n              const trig = ((cCfg && (cCfg as any).on) || []) as any[];\n              const allow =\n                !trig || (Array.isArray(trig) && (trig.length === 0 || trig.includes(effEvent)));\n              if (allow) nextSet.add(cand);\n            }\n          }\n\n          // Ensure ancestors (dependencies) of all planned checks are present so\n          // the rebuilt dependency graph is valid and complete. This fixes the\n          // case where a forward target (e.g., 'consumer') depends on an\n          // ancestor (e.g., 'producer') that wasn't part of the initial run.\n          const expandOr = (tok: unknown): string[] => {\n            const s = String(tok ?? '').trim();\n            if (!s) return [];\n            if (s.includes('|'))\n              return s\n                .split('|')\n                .map(x => x.trim())\n                .filter(Boolean);\n            return [s];\n          };\n          const collectAncestors = (name: string, seen = new Set<string>()) => {\n            if (seen.has(name)) return;\n            seen.add(name);\n            const cfg = (config.checks || {})[name];\n            if (!cfg) return;\n            const raw = (cfg as any).depends_on || [];\n            for (const tok of raw) {\n              for (const d of expandOr(tok)) {\n                if (!d || !(config.checks || {})[d]) continue;\n                nextSet.add(d);\n                collectAncestors(d, seen);\n              }\n            }\n          };\n          for (const name of Array.from(nextSet)) collectAncestors(name);\n          // Add missing ancestors for all planned checks to build a valid graph\n          const expandOr2 = (tok: unknown): string[] => {\n            const s = String(tok ?? '').trim();\n            if (!s) return [];\n            if (s.includes('|'))\n              return s\n                .split('|')\n                .map(x => x.trim())\n                .filter(Boolean);\n            return [s];\n          };\n          const addAncestors2 = (name: string, seen = new Set<string>()) => {\n            if (seen.has(name)) return;\n            seen.add(name);\n            const cfg = (config.checks || {})[name];\n            if (!cfg) return;\n            const raw = (cfg as any).depends_on || [];\n            for (const tok of raw) {\n              for (const d of expandOr2(tok)) {\n                if (!d || !(config.checks || {})[d]) continue;\n                nextSet.add(d);\n                addAncestors2(d, seen);\n              }\n            }\n          };\n          for (const nm of Array.from(nextSet)) addAncestors2(nm);\n          checks = Array.from(nextSet);\n          if (sawFinish) {\n            try {\n              checks = checks.filter(n => !((config.checks || {})[n] as any)?.forEach);\n            } catch {}\n          }\n          // Recompute dependencies for the expanded set (expand OR-groups);\n          // skip event pruning here so goto_event can elevate children.\n          const expandTok = (tok: any): string[] =>\n            typeof tok === 'string' && tok.includes('|')\n              ? tok\n                  .split('|')\n                  .map(s => s.trim())\n                  .filter(Boolean)\n              : tok\n                ? [String(tok)]\n                : [];\n          const newDeps: Record<string, string[]> = {};\n          for (const name of checks) {\n            const cfg = (config.checks || {})[name];\n            if (!cfg) continue;\n            const depTokens: any[] = Array.isArray(cfg.depends_on)\n              ? (cfg.depends_on as any[])\n              : cfg.depends_on\n                ? [cfg.depends_on]\n                : [];\n            newDeps[name] = depTokens.flatMap(expandTok);\n          }\n          // Suppress goto for checks that are only dependencies (not forward targets)\n          try {\n            const fset = new Set(forwardTargets);\n            for (const [child, deps] of Object.entries(newDeps)) {\n              if (fset.has(child)) continue;\n              for (const d of deps || []) this.gotoSuppressedChecks.add(d);\n            }\n          } catch {}\n          dependencies = newDeps;\n          dependencyGraph = DependencyResolver.buildDependencyGraph(dependencies);\n          stats = DependencyResolver.getExecutionStats(dependencyGraph);\n          totalChecksCount = stats.totalChecks;\n          // Ensure execution statistics exist for any newly planned checks so\n          // their runs are counted in this.engine statistics (used by tests)\n          try {\n            for (const c of checks) if (!this.executionStats.has(c)) this.initializeCheckStats(c);\n          } catch {}\n        }\n        // Clear overrides after applying for the next wave\n        try {\n          this.forwardEventOverrides.clear();\n        } catch {}\n      } catch {}\n      try {\n        logger.info(`üîÅ Wave ${wave} completed with forward-run; scheduling next wave...`);\n      } catch {}\n    }\n\n    if (debug) {\n      if (shouldStopExecution) {\n        log(\n          `üõë Execution stopped early due to fail-fast after processing ${results.size} of ${checks.length} checks`\n        );\n      } else {\n        log(`‚úÖ Dependency-aware execution completed successfully for all ${results.size} checks`);\n      }\n    }\n\n    // Handle on_finish hooks for forEach checks after ALL dependents complete\n    if (!shouldStopExecution) {\n      try {\n        logger.info('üß≠ on_finish: invoking handleOnFinishHooks');\n      } catch {}\n      try {\n        if (debug) console.error('[engine] calling handleOnFinishHooks');\n      } catch {}\n      await this.handleOnFinishHooks(config, dependencyGraph, results, prInfo, debug || false);\n      // If on_finish scheduled forward targets (via goto/goto_js), execute additional\n      // correction wave(s) until no pending targets remain or wave budget is reached.\n      for (; wave <= maxWaves && this.forwardDependentsScheduled.size > 0; wave++) {\n        // Build the next wave plan from the pending on_finish targets BEFORE resetting per-wave guards.\n        try {\n          const fwdMap = this.forwardDependentsScheduled || new Map<string, Set<string>>();\n          const forwardTargetsRaw = Array.from(fwdMap.keys());\n          // Filter out targets that are not allowed for the effective event; if none remain, stop.\n          const allowedTargets = forwardTargetsRaw.filter(t => {\n            try {\n              const effEvent =\n                this.forwardEventOverrides.get(t) || (prInfo.eventType as any) || 'manual';\n              const cCfg = (config.checks || {})[t];\n              const trig = ((cCfg && (cCfg as any).on) || []) as any[];\n              const allow =\n                !trig || (Array.isArray(trig) && (trig.length === 0 || trig.includes(effEvent)));\n              return allow;\n            } catch {\n              return true;\n            }\n          });\n          if (allowedTargets.length === 0) {\n            // Nothing actionable for the next wave; clear and exit the loop\n            try {\n              this.forwardDependentsScheduled.clear();\n              this.forwardEventOverrides.clear();\n            } catch {}\n            break;\n          }\n          // Execute any per-item scoped runs immediately for allowed targets,\n          // then keep only unscoped (root) entries for DAG planning.\n          const executedScopedChildren = new Set<string>();\n          try {\n            for (const t of allowedTargets) {\n              const scopeSet = fwdMap.get(t);\n              if (!scopeSet || scopeSet.size === 0) continue;\n              const effEvent =\n                this.forwardEventOverrides.get(t) || (prInfo.eventType as any) || 'manual';\n              const toRemove: string[] = [];\n              for (const s of Array.from(scopeSet)) {\n                // s is JSON-encoded ScopePath; '[]' means unscoped\n                if (s === '[]') continue;\n                let scope: ScopePath = [];\n                try {\n                  scope = JSON.parse(s);\n                } catch {\n                  scope = [];\n                }\n                await this.runNamedCheck(t, scope, {\n                  origin: 'on_finish',\n                  config: config!,\n                  dependencyGraph,\n                  prInfo,\n                  resultsMap: results,\n                  debug: !!debug,\n                  eventOverride: effEvent,\n                });\n                toRemove.push(s);\n              }\n              // Remove executed per-item scopes from the scheduled map\n              for (const s of toRemove) scopeSet.delete(s);\n              if (scopeSet.size === 0) {\n                fwdMap.delete(t);\n              }\n\n              // If t is a forEach parent, proactively execute its immediate\n              // dependents that declare fanout: 'map' for each item scope.\n              try {\n                const tCfg = (config.checks || {})[t] as any;\n                if (tCfg && tCfg.forEach === true) {\n                  const hist = this.outputHistory.get(t);\n                  const arrays = Array.isArray(hist) ? (hist as unknown[]) : [];\n                  const lastArr = arrays.filter(Array.isArray).slice(-1)[0] as\n                    | unknown[]\n                    | undefined;\n                  const itemsLen = Array.isArray(lastArr) ? lastArr.length : 0;\n                  if (itemsLen > 0) {\n                    for (const [cand, candCfgAny] of Object.entries(config.checks || {})) {\n                      const candCfg = candCfgAny as any;\n                      const depsRaw = Array.isArray(candCfg?.depends_on)\n                        ? (candCfg.depends_on as any[])\n                        : candCfg?.depends_on\n                          ? [candCfg.depends_on]\n                          : [];\n                      const deps = depsRaw\n                        .flatMap((x: any) =>\n                          String(x ?? '')\n                            .split('|')\n                            .map((s: string) => s.trim())\n                            .filter(Boolean)\n                        )\n                        .filter(Boolean);\n                      const isChild = deps.includes(t);\n                      const isMap = candCfg?.fanout === 'map';\n                      if (isChild && isMap) {\n                        for (let i = 0; i < itemsLen; i++) {\n                          const itemScope: ScopePath = [{ check: t, index: i }];\n                          await this.runNamedCheck(cand, itemScope, {\n                            origin: 'on_finish',\n                            config: config!,\n                            dependencyGraph,\n                            prInfo,\n                            resultsMap: results,\n                            debug: !!debug,\n                            eventOverride: effEvent,\n                          });\n                        }\n                        executedScopedChildren.add(cand);\n                      }\n                    }\n                  }\n                }\n              } catch {}\n            }\n          } catch {}\n          // Construct a fresh checks set consisting only of the allowed targets and their dependents for the effective event\n          const nextSet = new Set<string>();\n          const allChecks = Object.keys(config?.checks || {});\n          const expandTok = (tok: any): string[] =>\n            typeof tok === 'string' && tok.includes('|')\n              ? tok\n                  .split('|')\n                  .map(s => s.trim())\n                  .filter(Boolean)\n              : tok\n                ? [String(tok)]\n                : [];\n          const dependsOn = (\n            candidate: string,\n            root: string,\n            seen = new Set<string>()\n          ): boolean => {\n            if (seen.has(candidate)) return false;\n            seen.add(candidate);\n            const cfg = (config?.checks || {})[candidate];\n            const depTokens: any[] = Array.isArray(cfg?.depends_on)\n              ? (cfg!.depends_on as any[])\n              : cfg?.depends_on\n                ? [cfg.depends_on]\n                : [];\n            const deps = depTokens.flatMap(expandTok);\n            if (deps.includes(root)) return true;\n            return deps.some(d => dependsOn(d, root, seen));\n          };\n          for (const t of allowedTargets) {\n            const scopeSet = fwdMap.get(t);\n            // If only per-item scopes were scheduled and all executed above, skip adding this target\n            if (scopeSet && scopeSet.size > 0 && !scopeSet.has('[]')) {\n              continue;\n            }\n            nextSet.add(t);\n            const includeDeps = this.forwardIncludeDependents.get(t);\n            const shouldInclude = includeDeps !== false; // default true\n            if (!shouldInclude) continue; // on_finish correction waves: only targets\n            const effEvent =\n              this.forwardEventOverrides.get(t) || (prInfo.eventType as any) || 'manual';\n            for (const cand of allChecks) {\n              if (cand === t) continue;\n              if (!dependsOn(cand, t)) continue;\n              const cCfg = (config.checks || {})[cand];\n              // Skip children we have already executed per-item above\n              try {\n                if ((executedScopedChildren as any)?.has?.(cand)) continue;\n              } catch {}\n              const excludeForEach = this.forwardExcludeForEachDependents.get(t) === true;\n              if (excludeForEach && (cCfg as any)?.forEach) continue;\n              const trig = ((cCfg && (cCfg as any).on) || []) as any[];\n              const allow =\n                !trig || (Array.isArray(trig) && (trig.length === 0 || trig.includes(effEvent)));\n              if (allow) nextSet.add(cand);\n            }\n          }\n          checks = Array.from(nextSet);\n          // In correction waves triggered by on_finish, avoid re-running forEach parents\n          try {\n            checks = checks.filter(n => !((config.checks || {})[n] as any)?.forEach);\n          } catch {}\n          // Recompute dependencies for the planned set (tokens expanded), then rebuild the graph\n          const newDeps: Record<string, string[]> = {};\n          for (const name of checks) {\n            const cfg = (config.checks || {})[name];\n            if (!cfg) continue;\n            const depTokens: any[] = Array.isArray((cfg as any).depends_on)\n              ? ((cfg as any).depends_on as any[])\n              : (cfg as any).depends_on\n                ? [(cfg as any).depends_on]\n                : [];\n            newDeps[name] = depTokens.flatMap(expandTok);\n          }\n          // Suppress goto for checks that are only dependencies in this correction wave\n          try {\n            const tset = new Set(allowedTargets);\n            for (const [child, deps] of Object.entries(newDeps)) {\n              if (tset.has(child)) continue;\n              for (const d of deps || []) this.gotoSuppressedChecks.add(d);\n            }\n          } catch {}\n          dependencies = newDeps;\n          dependencyGraph = DependencyResolver.buildDependencyGraph(dependencies);\n          stats = DependencyResolver.getExecutionStats(dependencyGraph);\n          totalChecksCount = stats.totalChecks;\n          // Ensure statistics are initialized for any newly added checks\n          try {\n            for (const c of checks) if (!this.executionStats.has(c)) this.initializeCheckStats(c);\n          } catch {}\n          // Clear overrides and pending list now that the plan is materialized\n          try {\n            this.forwardDependentsScheduled.clear();\n            this.forwardEventOverrides.clear();\n          } catch {}\n        } catch {}\n        try {\n          logger.info(`üîÅ Wave ${wave} scheduled from on_finish; executing...`);\n        } catch {}\n        results.clear();\n        await runWave();\n        await executeLevels();\n        // Process on_finish again for potential further routing\n        await this.handleOnFinishHooks(config, dependencyGraph, results, prInfo, debug || false);\n      }\n      // Removed fallback re-execution of on_finish.run static steps to avoid double-counting and\n      // unintended duplicate runs within a single stage. The primary on_finish handler above is\n      // authoritative and records history/stats for reporters.\n    } else {\n      try {\n        logger.info('üß≠ on_finish: skipped due to shouldStopExecution');\n      } catch {}\n    }\n\n    // Cleanup sessions BEFORE printing summary to avoid mixing debug logs with table output\n    if (sessionIds.size > 0 && debug) {\n      log(`üßπ Cleaning up ${sessionIds.size} AI sessions...`);\n      for (const [checkName, sessionId] of sessionIds) {\n        try {\n          sessionRegistry.unregisterSession(sessionId);\n          log(`üóëÔ∏è Cleaned up session for check ${checkName}: ${sessionId}`);\n        } catch (error) {\n          log(`‚ö†Ô∏è Failed to cleanup session for check ${checkName}: ${error}`);\n        }\n      }\n    }\n\n    // Ensure all AI sessions are cleaned up (safety net)\n    try {\n      if (sessionIds.size > 0) {\n        const { SessionRegistry } = require('./session-registry');\n        SessionRegistry.getInstance().clearAllSessions();\n      }\n    } catch {}\n\n    // Build and log final execution summary\n    const executionStatistics = this.buildExecutionStatistics();\n\n    // Show detailed summary table (only if logFn outputs to console)\n    // Skip when output format is JSON/SARIF to avoid polluting structured output\n    // Check if logFn is console.log (not a no-op or console.error)\n    if (logFn === console.log) {\n      this.logExecutionSummary(executionStatistics);\n    }\n\n    // Add warning if execution stopped early\n    if (shouldStopExecution) {\n      logger.info('');\n      logger.warn(`‚ö†Ô∏è  Execution stopped early due to fail-fast`);\n    }\n\n    // In strict modes, surface internal check errors as test failures\n    try {\n      const strictEnv = process.env.VISOR_STRICT_ERRORS === 'true';\n      if (strictEnv) {\n        const failures: Array<{ name: string; message: string }> = [];\n        for (const [name, r] of results.entries()) {\n          const issues = (r?.issues || []) as Array<{\n            ruleId?: string;\n            message?: string;\n            severity?: string;\n          }>;\n          if (\n            issues.some(\n              i => i.ruleId && (i.ruleId.endsWith('/error') || i.ruleId.includes('/promise-error'))\n            )\n          ) {\n            const first = issues.find(i => i.ruleId?.includes('/error')) || issues[0];\n            failures.push({ name, message: first?.message || 'check error' });\n          }\n        }\n        if (failures.length > 0) {\n          const msg = 'Check failures: ' + failures.map(f => `${f.name}: ${f.message}`).join('; ');\n          throw new Error(msg);\n        }\n      }\n    } catch (e) {\n      // Re-throw to caller; executeChecks will honor strict mode and propagate in tests.\n      throw e;\n    }\n\n    // Aggregate all results\n    return this.aggregateDependencyAwareResults(\n      results,\n      dependencyGraph,\n      debug,\n      shouldStopExecution\n    );\n  }\n\n  /**\n   * Execute multiple checks in parallel using controlled parallelism (legacy method)\n   */\n  private async executeParallelChecks(\n    prInfo: PRInfo,\n    checks: string[],\n    timeout?: number,\n    config?: import('./types/config').VisorConfig,\n    logFn?: (message: string) => void,\n    debug?: boolean,\n    maxParallelism?: number,\n    failFast?: boolean\n  ): Promise<ReviewSummary> {\n    const log = logFn || console.error;\n    log(`üîß Debug: Starting parallel execution of ${checks.length} checks`);\n\n    if (!config?.checks) {\n      throw new Error('Config with check definitions required for parallel execution');\n    }\n\n    // Determine effective max parallelism (CLI > config > default)\n    const effectiveMaxParallelism = maxParallelism ?? config.max_parallelism ?? 3;\n    // Determine effective fail-fast setting (CLI > config > default)\n    const effectiveFailFast = failFast ?? config.fail_fast ?? false;\n    log(`üîß Debug: Using max parallelism: ${effectiveMaxParallelism}`);\n    log(`üîß Debug: Using fail-fast: ${effectiveFailFast}`);\n\n    const provider = this.providerRegistry.getProviderOrThrow('ai');\n    this.setProviderWebhookContext(provider);\n\n    // Create individual check task functions\n    const checkTaskFunctions = checks.map(checkName => async () => {\n      const checkConfig = config.checks![checkName];\n      if (!checkConfig) {\n        log(`üîß Debug: No config found for check: ${checkName}`);\n        return {\n          checkName,\n          error: `No configuration found for check: ${checkName}`,\n          result: null,\n        };\n      }\n\n      try {\n        console.error(\n          `üîß Debug: Starting check: ${checkName} with prompt type: ${typeof checkConfig.prompt}`\n        );\n\n        // Evaluate if condition to determine whether to run this check\n        if (checkConfig.if) {\n          const gate = await this.shouldRunCheck(\n            checkName,\n            checkConfig.if,\n            prInfo,\n            new Map<string, ReviewSummary>(),\n            debug,\n            this.routingEventOverride,\n            /* failSecure */ true\n          );\n\n          if (!gate.shouldRun) {\n            console.error(\n              `üîß Debug: Skipping check '${checkName}' - if condition evaluated to false`\n            );\n            return {\n              checkName,\n              error: null,\n              result: {\n                issues: [],\n              },\n            };\n          }\n        }\n\n        // Create provider config for this specific check\n        const providerConfig: CheckProviderConfig = {\n          type: (checkConfig.type as any) || 'ai',\n          prompt: checkConfig.prompt,\n          focus: checkConfig.focus || this.mapCheckNameToFocus(checkName),\n          schema: checkConfig.schema,\n          group: checkConfig.group,\n          checkName,\n          eventContext: this.enrichEventContext(prInfo.eventContext),\n          ai: {\n            timeout: timeout || 600000,\n            debug: debug, // Pass debug flag to AI provider\n            ...(checkConfig.ai || {}),\n          },\n          // Preserve all other provider-specific fields (e.g., memory.operation, github.op)\n          ...checkConfig,\n        } as any;\n\n        const result = await provider.execute(\n          prInfo,\n          providerConfig,\n          undefined,\n          this.executionContext\n        );\n        console.error(\n          `üîß Debug: Completed check: ${checkName}, issues found: ${(result.issues || []).length}`\n        );\n\n        // Add group, schema info and timestamp to issues from config\n        const enrichedIssues = (result.issues || []).map(issue => ({\n          ...issue,\n          ruleId: `${checkName}/${issue.ruleId}`,\n          group: checkConfig.group,\n          schema: typeof checkConfig.schema === 'object' ? 'custom' : checkConfig.schema,\n          template: checkConfig.template,\n          timestamp: Date.now(),\n        }));\n\n        const enrichedResult = {\n          ...result,\n          issues: enrichedIssues,\n        };\n\n        return {\n          checkName,\n          error: null,\n          result: enrichedResult,\n        };\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        log(`üîß Debug: Error in check ${checkName}: ${errorMessage}`);\n\n        return {\n          checkName,\n          error: errorMessage,\n          result: null,\n        };\n      }\n    });\n\n    // Execute all checks with controlled parallelism\n    log(\n      `üîß Debug: Executing ${checkTaskFunctions.length} checks with max parallelism: ${effectiveMaxParallelism}`\n    );\n    const results = await this.executeWithLimitedParallelism(\n      checkTaskFunctions,\n      effectiveMaxParallelism,\n      effectiveFailFast\n    );\n\n    // Check if execution was stopped early\n    const completedChecks = results.filter(\n      r => r.status === 'fulfilled' || r.status === 'rejected'\n    ).length;\n    const stoppedEarly = completedChecks < checks.length;\n\n    if (stoppedEarly && effectiveFailFast) {\n      log(\n        `üõë Parallel execution stopped early due to fail-fast after processing ${completedChecks} of ${checks.length} checks`\n      );\n    } else {\n      log(`‚úÖ Parallel execution completed for all ${completedChecks} checks`);\n    }\n\n    // Aggregate results from all checks\n    return this.aggregateParallelResults(results, checks, debug, stoppedEarly);\n  }\n\n  /**\n   * Execute a single configured check\n   */\n  private async executeSingleConfiguredCheck(\n    prInfo: PRInfo,\n    checkName: string,\n    timeout?: number,\n    config?: import('./types/config').VisorConfig,\n    _logFn?: (message: string) => void\n  ): Promise<ReviewSummary> {\n    if (!config?.checks?.[checkName]) {\n      throw new Error(`No configuration found for check: ${checkName}`);\n    }\n\n    const checkConfig = config.checks![checkName];\n    const provider = this.providerRegistry.getProviderOrThrow('ai');\n    this.setProviderWebhookContext(provider);\n\n    const providerConfig: CheckProviderConfig = {\n      type: 'ai',\n      prompt: checkConfig.prompt,\n      focus: checkConfig.focus || this.mapCheckNameToFocus(checkName),\n      schema: checkConfig.schema,\n      group: checkConfig.group,\n      eventContext: this.enrichEventContext(prInfo.eventContext),\n      ai: {\n        timeout: timeout || 600000,\n        ...(checkConfig.ai || {}),\n      },\n      // Inherit global AI provider and model settings\n      ai_provider: checkConfig.ai_provider || config.ai_provider,\n      ai_model: checkConfig.ai_model || config.ai_model,\n    };\n\n    const result = await provider.execute(prInfo, providerConfig, undefined, this.executionContext);\n\n    // Prefix issues with check name and add group/schema info and timestamp from config\n    const prefixedIssues = (result.issues || []).map(issue => ({\n      ...issue,\n      ruleId: `${checkName}/${issue.ruleId}`,\n      group: checkConfig.group,\n      schema: typeof checkConfig.schema === 'object' ? 'custom' : checkConfig.schema,\n      timestamp: Date.now(),\n    }));\n\n    return {\n      ...result,\n      issues: prefixedIssues,\n    };\n  }\n\n  /**\n   * Map check name to focus for AI provider\n   * This is a fallback when focus is not explicitly configured\n   */\n  private mapCheckNameToFocus(checkName: string): string {\n    const focusMap: Record<string, string> = {\n      security: 'security',\n      performance: 'performance',\n      style: 'style',\n      architecture: 'architecture',\n    };\n\n    return focusMap[checkName] || 'all';\n  }\n\n  /**\n   * Aggregate results from dependency-aware check execution\n   */\n  private aggregateDependencyAwareResults(\n    results: Map<string, ReviewSummary>,\n    dependencyGraph: DependencyGraph,\n    debug?: boolean,\n    stoppedEarly?: boolean\n  ): ReviewSummary {\n    const aggregatedIssues: ReviewSummary['issues'] = [];\n    const debugInfo: string[] = [];\n    const contentMap: Record<string, string> = {};\n    const outputsMap: Record<string, unknown> = {};\n\n    // Add execution plan info\n    const stats = DependencyResolver.getExecutionStats(dependencyGraph);\n    const executionInfo = [\n      stoppedEarly\n        ? `üõë Dependency-aware execution stopped early (fail-fast):`\n        : `üîç Dependency-aware execution completed:`,\n      `  - ${results.size} of ${stats.totalChecks} checks processed`,\n      `  - Execution levels: ${stats.parallelLevels}`,\n      `  - Maximum parallelism: ${stats.maxParallelism}`,\n      `  - Average parallelism: ${stats.averageParallelism.toFixed(1)}`,\n      `  - Checks with dependencies: ${stats.checksWithDependencies}`,\n      stoppedEarly ? `  - Stopped early due to fail-fast behavior` : ``,\n    ].filter(Boolean);\n\n    debugInfo.push(...executionInfo);\n\n    // Track which checks we've aggregated already\n    const processed = new Set<string>();\n\n    // Process results in dependency order for better output organization\n    for (const executionGroup of dependencyGraph.executionOrder) {\n      for (const checkName of executionGroup.parallel) {\n        const result = results.get(checkName);\n\n        if (!result) {\n          debugInfo.push(`‚ùå Check \"${checkName}\" had no result`);\n          continue;\n        }\n\n        // Check if this was a successful result\n        const hasErrors = (result.issues || []).some(\n          issue => issue.ruleId?.includes('/error') || issue.ruleId?.includes('/promise-error')\n        );\n\n        if (hasErrors) {\n          debugInfo.push(`‚ùå Check \"${checkName}\" failed with errors`);\n        } else {\n          debugInfo.push(\n            `‚úÖ Check \"${checkName}\" completed: ${(result.issues || []).length} issues found (level ${executionGroup.level})`\n          );\n        }\n\n        // Mark as processed\n        processed.add(checkName);\n\n        // Issues are already prefixed and enriched with group/schema info\n        // Filter out internal __skipped markers\n        let nonInternalIssues = (result.issues || []).filter(\n          issue => !issue.ruleId?.endsWith('/__skipped')\n        );\n        // Safety: ensure aggregated issues retain producing check association\n        nonInternalIssues = nonInternalIssues.map((i: ReviewIssue) =>\n          i.checkName ? i : { ...i, checkName }\n        );\n        aggregatedIssues.push(...nonInternalIssues);\n\n        const resultSummary = result as ExtendedReviewSummary & { output?: unknown };\n        const resultContent = resultSummary.content;\n        if (typeof resultContent === 'string' && resultContent.trim()) {\n          contentMap[checkName] = resultContent.trim();\n        }\n        if (resultSummary.output !== undefined) {\n          outputsMap[checkName] = resultSummary.output;\n        }\n      }\n    }\n\n    // Include any additional results that were produced at runtime (e.g., forward-run via goto)\n    // but were not part of the original execution DAG for the selected checks.\n    for (const [checkName, result] of results.entries()) {\n      if (processed.has(checkName)) continue;\n      if (!result) continue;\n\n      // Issues (already enriched)\n      let dynNonInternal = (result.issues || []).filter(\n        issue => !issue.ruleId?.endsWith('/__skipped')\n      );\n      dynNonInternal = dynNonInternal.map((i: ReviewIssue) =>\n        i.checkName ? i : { ...i, checkName }\n      );\n      aggregatedIssues.push(...dynNonInternal);\n\n      const resultSummary = result as ExtendedReviewSummary & { output?: unknown };\n      const resultContent = (resultSummary as { content?: string }).content;\n      if (typeof resultContent === 'string' && resultContent.trim()) {\n        contentMap[checkName] = resultContent.trim();\n      }\n      if (resultSummary.output !== undefined) {\n        outputsMap[checkName] = resultSummary.output;\n      }\n\n      debugInfo.push(\n        `‚úÖ (dynamic) Check \"${checkName}\" included: ${(result.issues || []).length} issues found`\n      );\n    }\n\n    if (debug) {\n      console.error(\n        `üîß Debug: Aggregated ${aggregatedIssues.length} issues from ${results.size} dependency-aware checks`\n      );\n    }\n\n    // Fallback surfacing for routing loop-budget diagnostics in edge environments\n    // where no check results were recorded (e.g., extremely early routing aborts\n    // under artificial budgets in tests). Only trigger when nothing executed.\n    if (results.size === 0 && (!aggregatedIssues || aggregatedIssues.length === 0)) {\n      try {\n        const cfg = this.config || ({} as any);\n        const maxLoops = (cfg.routing && cfg.routing.max_loops) ?? undefined;\n        if (typeof maxLoops === 'number') {\n          const checksToScan = Object.keys((cfg.checks || {}) as Record<string, any>);\n          for (const name of checksToScan) {\n            const c = (cfg.checks as any)[name] || {};\n            if (c.on_success && Array.isArray(c.on_success.run) && c.on_success.run.length > 0) {\n              aggregatedIssues.push({\n                file: 'system',\n                line: 0,\n                ruleId: `${name}/routing/loop_budget_exceeded`,\n                message: `Routing loop budget exceeded (max_loops=${maxLoops}) during on_success run`,\n                severity: 'error',\n                category: 'logic',\n              });\n            }\n            if (c.on_fail && (c.on_fail.goto || c.on_fail.goto_js)) {\n              aggregatedIssues.push({\n                file: 'system',\n                line: 0,\n                ruleId: `${name}/routing/loop_budget_exceeded`,\n                message: `Routing loop budget exceeded (max_loops=${maxLoops}) during on_fail goto`,\n                severity: 'error',\n                category: 'logic',\n              });\n            }\n          }\n        }\n      } catch {}\n    }\n\n    // Apply issue suppression filtering\n    const suppressionEnabled = this.config?.output?.suppressionEnabled !== false;\n    const issueFilter = new IssueFilter(suppressionEnabled);\n    const filteredIssues = issueFilter.filterIssues(aggregatedIssues, this.workingDirectory);\n\n    // Collect debug information when debug mode is enabled\n    let aggregatedDebug: import('./ai-review-service').AIDebugInfo | undefined;\n    if (debug) {\n      const debugResults = Array.from(results.entries()).filter(([_, result]) => result.debug);\n\n      if (debugResults.length > 0) {\n        const [, firstResult] = debugResults[0];\n        const firstDebug = firstResult.debug!;\n\n        const totalProcessingTime = debugResults.reduce((sum, [_, result]) => {\n          return sum + (result.debug!.processingTime || 0);\n        }, 0);\n\n        aggregatedDebug = {\n          provider: firstDebug.provider,\n          model: firstDebug.model,\n          apiKeySource: firstDebug.apiKeySource,\n          processingTime: totalProcessingTime,\n          prompt: debugResults\n            .map(([checkName, result]) => `[${checkName}]\\n${result.debug!.prompt}`)\n            .join('\\n\\n'),\n          rawResponse: debugResults\n            .map(([checkName, result]) => `[${checkName}]\\n${result.debug!.rawResponse}`)\n            .join('\\n\\n'),\n          promptLength: debugResults.reduce(\n            (sum, [_, result]) => sum + (result.debug!.promptLength || 0),\n            0\n          ),\n          responseLength: debugResults.reduce(\n            (sum, [_, result]) => sum + (result.debug!.responseLength || 0),\n            0\n          ),\n          jsonParseSuccess: debugResults.every(([_, result]) => result.debug!.jsonParseSuccess),\n          errors: debugResults.flatMap(([checkName, result]) =>\n            (result.debug!.errors || []).map((error: string) => `[${checkName}] ${error}`)\n          ),\n          timestamp: new Date().toISOString(),\n          totalApiCalls: debugResults.length,\n          apiCallDetails: debugResults.map(([checkName, result]) => ({\n            checkName,\n            provider: result.debug!.provider,\n            model: result.debug!.model,\n            processingTime: result.debug!.processingTime,\n            success: result.debug!.jsonParseSuccess,\n          })),\n        };\n      }\n    }\n\n    const summary: ReviewSummary & {\n      __contents?: Record<string, string>;\n      __outputs?: Record<string, unknown>;\n      __executed?: string[];\n    } = {\n      issues: filteredIssues,\n      debug: aggregatedDebug,\n    };\n\n    if (Object.keys(contentMap).length > 0) {\n      summary.__contents = contentMap;\n    }\n    if (Object.keys(outputsMap).length > 0) {\n      summary.__outputs = outputsMap;\n    }\n\n    // Attach outputs history for tests and scripts that inspect reviewSummary.history\n    try {\n      const hist: Record<string, unknown[]> = {};\n      for (const [k, v] of this.outputHistory.entries()) hist[k] = Array.isArray(v) ? v : [];\n      (summary as any).history = hist;\n    } catch {}\n\n    // Preserve the list of executed checks (keys in results Map) so downstream\n    // grouping/formatting can include dynamically routed children even when they\n    // produced neither issues nor output content (e.g., log-only steps).\n    summary.__executed = Array.from(results.keys());\n\n    return summary;\n  }\n\n  /**\n   * Aggregate results from parallel check execution (legacy method)\n   */\n  private aggregateParallelResults(\n    results: PromiseSettledResult<{\n      checkName: string;\n      error: string | null;\n      result: ReviewSummary | null;\n    }>[],\n    checkNames: string[],\n    debug?: boolean,\n    _stoppedEarly?: boolean\n  ): ReviewSummary {\n    const aggregatedIssues: ReviewSummary['issues'] = [];\n    const debugInfo: string[] = [];\n\n    results.forEach((result, index) => {\n      const checkName = checkNames[index];\n\n      if (result.status === 'fulfilled') {\n        const checkResult = result.value;\n\n        if (checkResult.error) {\n          logger.debug(`üîß Debug: Check ${checkName} failed: ${checkResult.error}`);\n          debugInfo.push(`‚ùå Check \"${checkName}\" failed: ${checkResult.error}`);\n\n          // Check if this is a critical error\n          const isCriticalError =\n            checkResult.error.includes('API rate limit') ||\n            checkResult.error.includes('403') ||\n            checkResult.error.includes('401') ||\n            checkResult.error.includes('authentication') ||\n            checkResult.error.includes('API key');\n\n          // Add error as an issue with appropriate severity\n          aggregatedIssues.push({\n            file: 'system',\n            line: 0,\n            endLine: undefined,\n            ruleId: `${checkName}/error`,\n            message: `Check \"${checkName}\" failed: ${checkResult.error}`,\n            severity: isCriticalError ? 'critical' : 'error',\n            category: 'logic',\n            suggestion: isCriticalError\n              ? 'Please check your API credentials and rate limits'\n              : undefined,\n            replacement: undefined,\n          });\n        } else if (checkResult.result) {\n          logger.debug(\n            `üîß Debug: Check ${checkName} succeeded with ${(checkResult.result.issues || []).length} issues`\n          );\n          debugInfo.push(\n            `‚úÖ Check \"${checkName}\" completed: ${(checkResult.result.issues || []).length} issues found`\n          );\n\n          // Issues are already prefixed and enriched with group/schema info\n          aggregatedIssues.push(...(checkResult.result.issues || []));\n        }\n      } else {\n        const errorMessage =\n          result.reason instanceof Error ? result.reason.message : String(result.reason);\n        logger.debug(`üîß Debug: Check ${checkName} promise rejected: ${errorMessage}`);\n        debugInfo.push(`‚ùå Check \"${checkName}\" promise rejected: ${errorMessage}`);\n\n        // Check if this is a critical error\n        const isCriticalError =\n          errorMessage.includes('API rate limit') ||\n          errorMessage.includes('403') ||\n          errorMessage.includes('401') ||\n          errorMessage.includes('authentication') ||\n          errorMessage.includes('API key');\n\n        aggregatedIssues.push({\n          file: 'system',\n          line: 0,\n          endLine: undefined,\n          ruleId: `${checkName}/promise-error`,\n          message: `Check \"${checkName}\" execution failed: ${errorMessage}`,\n          severity: isCriticalError ? 'critical' : 'error',\n          category: 'logic',\n          suggestion: isCriticalError\n            ? 'Please check your API credentials and rate limits'\n            : undefined,\n          replacement: undefined,\n        });\n      }\n    });\n\n    if (debug) {\n      console.error(\n        `üîß Debug: Aggregated ${aggregatedIssues.length} issues from ${results.length} checks`\n      );\n    }\n\n    // Apply issue suppression filtering\n    const suppressionEnabled = this.config?.output?.suppressionEnabled !== false;\n    const issueFilter = new IssueFilter(suppressionEnabled);\n    const filteredIssues = issueFilter.filterIssues(aggregatedIssues, this.workingDirectory);\n\n    // Collect debug information when debug mode is enabled\n    let aggregatedDebug: import('./ai-review-service').AIDebugInfo | undefined;\n    if (debug) {\n      // Find the first successful result with debug information to use as template\n      const debugResults = results\n        .map((result, index) => ({\n          result,\n          checkName: checkNames[index],\n        }))\n        .filter(({ result }) => result.status === 'fulfilled' && result.value?.result?.debug);\n\n      if (debugResults.length > 0) {\n        const firstResult = debugResults[0].result;\n        if (firstResult.status === 'fulfilled') {\n          const firstDebug = firstResult.value!.result!.debug!;\n          const totalProcessingTime = debugResults.reduce((sum, { result }) => {\n            if (result.status === 'fulfilled') {\n              return sum + (result.value!.result!.debug!.processingTime || 0);\n            }\n            return sum;\n          }, 0);\n\n          aggregatedDebug = {\n            // Use first result as template for provider/model info\n            provider: firstDebug.provider,\n            model: firstDebug.model,\n            apiKeySource: firstDebug.apiKeySource,\n            // Aggregate processing time from all checks\n            processingTime: totalProcessingTime,\n            // Combine prompts with check names\n            prompt: debugResults\n              .map(({ checkName, result }) => {\n                if (result.status === 'fulfilled') {\n                  return `[${checkName}]\\n${result.value!.result!.debug!.prompt}`;\n                }\n                return `[${checkName}] Error: Promise was rejected`;\n              })\n              .join('\\n\\n'),\n            // Combine responses\n            rawResponse: debugResults\n              .map(({ checkName, result }) => {\n                if (result.status === 'fulfilled') {\n                  return `[${checkName}]\\n${result.value!.result!.debug!.rawResponse}`;\n                }\n                return `[${checkName}] Error: Promise was rejected`;\n              })\n              .join('\\n\\n'),\n            promptLength: debugResults.reduce((sum, { result }) => {\n              if (result.status === 'fulfilled') {\n                return sum + (result.value!.result!.debug!.promptLength || 0);\n              }\n              return sum;\n            }, 0),\n            responseLength: debugResults.reduce((sum, { result }) => {\n              if (result.status === 'fulfilled') {\n                return sum + (result.value!.result!.debug!.responseLength || 0);\n              }\n              return sum;\n            }, 0),\n            jsonParseSuccess: debugResults.every(({ result }) => {\n              if (result.status === 'fulfilled') {\n                return result.value!.result!.debug!.jsonParseSuccess;\n              }\n              return false;\n            }),\n            errors: debugResults.flatMap(({ result, checkName }) => {\n              if (result.status === 'fulfilled') {\n                return (result.value!.result!.debug!.errors || []).map(\n                  (error: string) => `[${checkName}] ${error}`\n                );\n              }\n              return [`[${checkName}] Promise was rejected`];\n            }),\n            timestamp: new Date().toISOString(),\n            // Add additional debug information for parallel execution\n            totalApiCalls: debugResults.length,\n            apiCallDetails: debugResults.map(({ checkName, result }) => {\n              if (result.status === 'fulfilled') {\n                return {\n                  checkName,\n                  provider: result.value!.result!.debug!.provider,\n                  model: result.value!.result!.debug!.model,\n                  processingTime: result.value!.result!.debug!.processingTime,\n                  success: result.value!.result!.debug!.jsonParseSuccess,\n                };\n              }\n              return {\n                checkName,\n                provider: 'unknown',\n                model: 'unknown',\n                processingTime: 0,\n                success: false,\n              };\n            }),\n          };\n        }\n      }\n    }\n\n    return {\n      issues: filteredIssues,\n      debug: aggregatedDebug,\n    };\n  }\n\n  /**\n   * Get available check types from providers\n   * Note: Check names are now config-driven. This returns provider types only.\n   */\n  static getAvailableCheckTypes(): string[] {\n    const registry = CheckProviderRegistry.getInstance();\n    return registry.getAvailableProviders();\n  }\n\n  /**\n   * Validate check types\n   */\n  static validateCheckTypes(checks: string[]): { valid: string[]; invalid: string[] } {\n    const availableChecks = CheckExecutionEngine.getAvailableCheckTypes();\n    const valid: string[] = [];\n    const invalid: string[] = [];\n\n    for (const check of checks) {\n      if (availableChecks.includes(check)) {\n        valid.push(check);\n      } else {\n        invalid.push(check);\n      }\n    }\n\n    return { valid, invalid };\n  }\n\n  /**\n   * List available providers with their status\n   */\n  async listProviders(): Promise<\n    Array<{\n      name: string;\n      description: string;\n      available: boolean;\n      requirements: string[];\n    }>\n  > {\n    return await this.providerRegistry.listProviders();\n  }\n\n  /**\n   * Create a mock Octokit instance for local analysis\n   */\n  private createMockOctokit(): MockOctokit {\n    // Create simple mock functions that return promises\n    const mockGet = async () => ({\n      data: {\n        number: 0,\n        title: 'Local Analysis',\n        body: 'Local repository analysis',\n        user: { login: 'local-user' },\n        base: { ref: 'main' },\n        head: { ref: 'HEAD' },\n      },\n    });\n\n    const mockListFiles = async () => ({\n      data: [],\n    });\n\n    const mockListComments = async () => ({\n      data: [],\n    });\n\n    const mockCreateComment = async () => ({\n      data: { id: 1 },\n    });\n\n    return {\n      rest: {\n        pulls: {\n          get: mockGet,\n          listFiles: mockListFiles,\n        },\n        issues: {\n          listComments: mockListComments,\n          createComment: mockCreateComment,\n        },\n      },\n      request: async () => ({ data: {} }),\n      graphql: async () => ({}),\n      log: {\n        debug: () => {},\n        info: () => {},\n        warn: () => {},\n        error: () => {},\n      },\n      hook: {\n        before: () => {},\n        after: () => {},\n        error: () => {},\n        wrap: () => {},\n      },\n      auth: async () => ({ token: 'mock-token' }),\n    };\n  }\n\n  /**\n   * Create an error result\n   */\n  private createErrorResult(\n    repositoryInfo: GitRepositoryInfo,\n    errorMessage: string,\n    startTime: number,\n    timestamp: string,\n    checksExecuted: string[]\n  ): AnalysisResult {\n    const executionTime = Date.now() - startTime;\n\n    return {\n      repositoryInfo,\n      reviewSummary: {\n        issues: [\n          {\n            file: 'system',\n            line: 0,\n            endLine: undefined,\n            ruleId: 'system/error',\n            message: errorMessage,\n            severity: 'error',\n            category: 'logic',\n            suggestion: undefined,\n            replacement: undefined,\n          },\n        ],\n      },\n      executionTime,\n      timestamp,\n      checksExecuted,\n    };\n  }\n\n  /**\n   * Check if a task result should trigger fail-fast behavior\n   */\n  private isFailFastCandidate(value: unknown): value is {\n    error?: string;\n    result?: { issues?: Array<{ severity?: string }> };\n  } {\n    if (typeof value !== 'object' || value === null) {\n      return false;\n    }\n\n    const candidate = value as {\n      error?: unknown;\n      result?: unknown;\n    };\n\n    if (candidate.error !== undefined && typeof candidate.error !== 'string') {\n      return false;\n    }\n\n    if (candidate.result !== undefined) {\n      if (typeof candidate.result !== 'object' || candidate.result === null) {\n        return false;\n      }\n\n      const issues = (candidate.result as { issues?: unknown }).issues;\n      if (issues !== undefined && !Array.isArray(issues)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private shouldFailFast(result: unknown): boolean {\n    if (!this.isFailFastCandidate(result)) {\n      return false;\n    }\n\n    if (result.error) {\n      return true;\n    }\n\n    // If the result has a result with critical or error issues, it should fail fast\n    const issues = result.result?.issues;\n    if (Array.isArray(issues)) {\n      return issues.some(issue => issue?.severity === 'error' || issue?.severity === 'critical');\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if the working directory is a valid git repository\n   */\n  async isGitRepository(): Promise<boolean> {\n    try {\n      const repositoryInfo = await this.gitAnalyzer.analyzeRepository();\n      return repositoryInfo.isGitRepository;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Evaluate failure conditions for a check result\n   */\n  async evaluateFailureConditions(\n    checkName: string,\n    reviewSummary: ReviewSummary,\n    config?: import('./types/config').VisorConfig,\n    prInfo?: PRInfo,\n    previousOutputs?: Record<string, ReviewSummary> | Map<string, ReviewSummary>\n  ): Promise<FailureConditionResult[]> {\n    if (!config) {\n      return [];\n    }\n\n    const checkConfig = config.checks![checkName];\n    const checkSchema =\n      typeof checkConfig?.schema === 'object' ? 'custom' : checkConfig?.schema || '';\n    const checkGroup = checkConfig?.group || '';\n\n    // Convert previousOutputs Map to Record if needed\n    const outputsRecord: Record<string, ReviewSummary> | undefined = previousOutputs\n      ? previousOutputs instanceof Map\n        ? Object.fromEntries(previousOutputs.entries())\n        : previousOutputs\n      : undefined;\n\n    // Handle new simple fail_if syntax\n    const globalFailIf = config.fail_if;\n    const checkFailIf = checkConfig?.fail_if;\n\n    // If using new fail_if syntax\n    if (globalFailIf || checkFailIf) {\n      const results: FailureConditionResult[] = [];\n\n      // Evaluate global fail_if\n      if (globalFailIf) {\n        const failed = await this.failureEvaluator.evaluateSimpleCondition(\n          checkName,\n          checkSchema,\n          checkGroup,\n          reviewSummary,\n          globalFailIf,\n          outputsRecord\n        );\n\n        try {\n          addEvent('fail_if.evaluated', {\n            check: checkName,\n            scope: 'global',\n            name: 'global_fail_if',\n            expression: globalFailIf,\n          });\n        } catch {}\n        if (failed) {\n          try {\n            addEvent('fail_if.triggered', {\n              check: checkName,\n              scope: 'global',\n              name: 'global_fail_if',\n              expression: globalFailIf,\n              severity: 'error',\n            });\n          } catch {}\n          try {\n            addFailIfTriggered(checkName, 'global');\n          } catch {}\n          try {\n            const { emitNdjsonSpanWithEvents } = require('./telemetry/fallback-ndjson');\n            emitNdjsonSpanWithEvents(\n              'visor.fail_if',\n              { check: checkName, scope: 'global', name: 'global_fail_if' },\n              [\n                {\n                  name: 'fail_if.triggered',\n                  attrs: {\n                    check: checkName,\n                    scope: 'global',\n                    name: 'global_fail_if',\n                    expression: globalFailIf,\n                    severity: 'error',\n                  },\n                },\n              ]\n            );\n          } catch {}\n          logger.warn(`‚ö†Ô∏è  Check \"${checkName}\" - global fail_if condition met: ${globalFailIf}`);\n          results.push({\n            conditionName: 'global_fail_if',\n            expression: globalFailIf,\n            failed: true,\n            severity: 'error',\n            message: 'Global failure condition met',\n            haltExecution: false,\n          });\n        } else {\n          logger.debug(`‚úì Check \"${checkName}\" - global fail_if condition passed`);\n        }\n      }\n\n      // Evaluate check-specific fail_if (overrides global if present)\n      if (checkFailIf) {\n        const failed = await this.failureEvaluator.evaluateSimpleCondition(\n          checkName,\n          checkSchema,\n          checkGroup,\n          reviewSummary,\n          checkFailIf,\n          outputsRecord\n        );\n\n        try {\n          addEvent('fail_if.evaluated', {\n            check: checkName,\n            scope: 'check',\n            name: `${checkName}_fail_if`,\n            expression: checkFailIf,\n          });\n        } catch {}\n        try {\n          const { emitNdjsonSpanWithEvents } = require('./telemetry/fallback-ndjson');\n          emitNdjsonSpanWithEvents(\n            'visor.fail_if',\n            { check: checkName, scope: 'check', name: `${checkName}_fail_if` },\n            [\n              {\n                name: 'fail_if.evaluated',\n                attrs: {\n                  check: checkName,\n                  scope: 'check',\n                  name: `${checkName}_fail_if`,\n                  expression: checkFailIf,\n                },\n              },\n            ]\n          );\n        } catch {}\n        if (failed) {\n          try {\n            addEvent('fail_if.triggered', {\n              check: checkName,\n              scope: 'check',\n              name: `${checkName}_fail_if`,\n              expression: checkFailIf,\n              severity: 'error',\n            });\n          } catch {}\n          try {\n            addEvent('fail_if.evaluated', {\n              check: checkName,\n              scope: 'check',\n              name: `${checkName}_fail_if`,\n              expression: checkFailIf,\n            });\n          } catch {}\n          try {\n            addFailIfTriggered(checkName, 'check');\n          } catch {}\n          try {\n            const { emitNdjsonSpanWithEvents } = require('./telemetry/fallback-ndjson');\n            emitNdjsonSpanWithEvents(\n              'visor.fail_if',\n              { check: checkName, scope: 'check', name: `${checkName}_fail_if` },\n              [\n                {\n                  name: 'fail_if.triggered',\n                  attrs: {\n                    check: checkName,\n                    scope: 'check',\n                    name: `${checkName}_fail_if`,\n                    expression: checkFailIf,\n                    severity: 'error',\n                  },\n                },\n              ]\n            );\n          } catch {}\n          logger.warn(`‚ö†Ô∏è  Check \"${checkName}\" - fail_if condition met: ${checkFailIf}`);\n          results.push({\n            conditionName: `${checkName}_fail_if`,\n            expression: checkFailIf,\n            failed: true,\n            severity: 'error',\n            message: `Check ${checkName} failure condition met`,\n            haltExecution: false,\n          });\n        } else {\n          logger.debug(`‚úì Check \"${checkName}\" - fail_if condition passed`);\n        }\n      }\n\n      try {\n        const { emitNdjsonSpanWithEvents } = require('./telemetry/fallback-ndjson');\n        const hadTriggered = results.some(r => r.failed === true);\n        emitNdjsonSpanWithEvents(\n          'visor.fail_if',\n          {\n            check: checkName,\n            scope: hadTriggered\n              ? checkFailIf\n                ? 'check'\n                : 'global'\n              : checkFailIf\n                ? 'check'\n                : 'global',\n          },\n          [\n            {\n              name: 'fail_if.evaluated',\n              attrs: { check: checkName, scope: checkFailIf ? 'check' : 'global' },\n            },\n          ].concat(\n            hadTriggered\n              ? [\n                  {\n                    name: 'fail_if.triggered',\n                    attrs: { check: checkName, scope: checkFailIf ? 'check' : 'global' },\n                  },\n                ]\n              : []\n          )\n        );\n      } catch {}\n      return results;\n    }\n\n    // Fall back to old failure_conditions syntax\n    const globalConditions = config.failure_conditions;\n    const checkConditions = checkConfig?.failure_conditions;\n\n    return await this.failureEvaluator.evaluateConditions(\n      checkName,\n      checkSchema,\n      checkGroup,\n      reviewSummary,\n      globalConditions,\n      checkConditions,\n      undefined, // previousOutputs\n      prInfo?.authorAssociation\n    );\n  }\n\n  /**\n   * Get repository status summary\n   */\n  async getRepositoryStatus(): Promise<{\n    isGitRepository: boolean;\n    hasChanges: boolean;\n    branch: string;\n    filesChanged: number;\n  }> {\n    try {\n      const repositoryInfo = await this.gitAnalyzer.analyzeRepository();\n      return {\n        isGitRepository: repositoryInfo.isGitRepository,\n        hasChanges: repositoryInfo.files.length > 0,\n        branch: repositoryInfo.head,\n        filesChanged: repositoryInfo.files.length,\n      };\n    } catch {\n      return {\n        isGitRepository: false,\n        hasChanges: false,\n        branch: 'unknown',\n        filesChanged: 0,\n      };\n    }\n  }\n\n  /**\n   * Initialize GitHub check runs for each configured check\n   */\n  private async initializeGitHubChecks(\n    options: CheckExecutionOptions,\n    logFn: (message: string) => void\n  ): Promise<void> {\n    if (\n      !options.githubChecks?.octokit ||\n      !options.githubChecks.owner ||\n      !options.githubChecks.repo ||\n      !options.githubChecks.headSha\n    ) {\n      logFn('‚ö†Ô∏è GitHub checks enabled but missing required parameters');\n      return;\n    }\n\n    try {\n      this.githubCheckService = new GitHubCheckService(options.githubChecks.octokit);\n      this.checkRunMap = new Map();\n      this.githubContext = {\n        owner: options.githubChecks.owner,\n        repo: options.githubChecks.repo,\n      };\n\n      logFn(`üîç Creating GitHub check runs for ${options.checks.length} checks...`);\n\n      for (const checkName of options.checks) {\n        try {\n          const checkRunOptions: CheckRunOptions = {\n            owner: options.githubChecks.owner,\n            repo: options.githubChecks.repo,\n            head_sha: options.githubChecks.headSha,\n            name: `Visor: ${checkName}`,\n            external_id: `visor-${checkName}-${options.githubChecks.headSha.substring(0, 7)}`,\n          };\n\n          const checkRun = await this.githubCheckService.createCheckRun(checkRunOptions, {\n            title: `${checkName} Analysis`,\n            summary: `Running ${checkName} check using AI-powered analysis...`,\n          });\n\n          this.checkRunMap.set(checkName, checkRun);\n          logFn(`‚úÖ Created check run for ${checkName}: ${checkRun.url}`);\n        } catch (error) {\n          logFn(`‚ùå Failed to create check run for ${checkName}: ${error}`);\n        }\n      }\n    } catch (error) {\n      // Check if this is a permissions error\n      if (\n        error instanceof Error &&\n        (error.message.includes('403') || error.message.includes('checks:write'))\n      ) {\n        logFn(\n          '‚ö†Ô∏è GitHub checks API not available - insufficient permissions. Check runs will be skipped.'\n        );\n        logFn('üí° To enable check runs, ensure your GitHub token has \"checks:write\" permission.');\n        this.githubCheckService = undefined;\n        this.checkRunMap = undefined;\n      } else {\n        logFn(`‚ùå Failed to initialize GitHub check runs: ${error}`);\n        this.githubCheckService = undefined;\n        this.checkRunMap = undefined;\n      }\n    }\n  }\n\n  /**\n   * Update GitHub check runs to in-progress status\n   */\n  private async updateGitHubChecksInProgress(options: CheckExecutionOptions): Promise<void> {\n    if (\n      !this.githubCheckService ||\n      !this.checkRunMap ||\n      !options.githubChecks?.owner ||\n      !options.githubChecks.repo\n    ) {\n      return;\n    }\n\n    for (const [checkName, checkRun] of this.checkRunMap) {\n      try {\n        await this.githubCheckService.updateCheckRunInProgress(\n          options.githubChecks.owner,\n          options.githubChecks.repo,\n          checkRun.id,\n          {\n            title: `Analyzing with ${checkName}...`,\n            summary: `AI-powered analysis is in progress for ${checkName} check.`,\n          }\n        );\n        console.log(`üîÑ Updated ${checkName} check to in-progress status`);\n      } catch (error) {\n        console.error(`‚ùå Failed to update ${checkName} check to in-progress: ${error}`);\n      }\n    }\n  }\n\n  /**\n   * Complete GitHub check runs with results\n   */\n  private async completeGitHubChecksWithResults(\n    reviewSummary: ReviewSummary,\n    options: CheckExecutionOptions,\n    prInfo: import('./pr-analyzer').PRInfo\n  ): Promise<void> {\n    const GH_DBG = process.env.VISOR_DEBUG_GITHUB_COMMENTS === 'true';\n    if (\n      !this.githubCheckService ||\n      !this.checkRunMap ||\n      !options.githubChecks?.owner ||\n      !options.githubChecks.repo\n    ) {\n      return;\n    }\n\n    // Group issues by check name\n    const issuesByCheck = new Map<string, import('./reviewer').ReviewIssue[]>();\n\n    // Initialize empty arrays for all checks\n    for (const checkName of this.checkRunMap.keys()) {\n      issuesByCheck.set(checkName, []);\n    }\n\n    // Group issues by their producing check (explicit checkName only)\n    for (const issue of reviewSummary.issues || []) {\n      if (issue.checkName && issuesByCheck.has(issue.checkName)) {\n        issuesByCheck.get(issue.checkName)!.push(issue);\n      }\n    }\n    if (GH_DBG) {\n      try {\n        const counts = Array.from(issuesByCheck.entries()).map(([k, v]) => ({\n          check: k,\n          issues: v.length,\n        }));\n        const sample = (reviewSummary.issues || []).slice(0, 3).map(i => ({\n          file: i.file,\n          line: i.line,\n          severity: i.severity,\n          ruleId: i.ruleId,\n          checkName: (i as any).checkName,\n        }));\n        console.error(\n          `[gh-debug] GH checks grouping: ${JSON.stringify(counts)} sample=${JSON.stringify(sample)}`\n        );\n      } catch {}\n    }\n\n    console.log(`üèÅ Completing ${this.checkRunMap.size} GitHub check runs...`);\n\n    for (const [checkName, checkRun] of this.checkRunMap) {\n      try {\n        const checkIssues = issuesByCheck.get(checkName) || [];\n\n        // Evaluate failure conditions for this specific check\n        const failureResults = await this.evaluateFailureConditions(\n          checkName,\n          { issues: checkIssues },\n          options.config\n        );\n\n        // Detect command execution failure patterns to mark check as failed without requiring fail_if\n        // We treat issues with ruleId starting with 'command/' as execution errors\n        const execErrorIssue = checkIssues.find(i => i.ruleId?.startsWith('command/'));\n\n        await this.githubCheckService.completeCheckRun(\n          options.githubChecks.owner,\n          options.githubChecks.repo,\n          checkRun.id,\n          checkName,\n          failureResults,\n          checkIssues,\n          execErrorIssue ? execErrorIssue.message : undefined, // executionError\n          prInfo.files.map((f: import('./pr-analyzer').PRFile) => f.filename), // filesChangedInCommit\n          options.githubChecks.prNumber, // prNumber\n          options.githubChecks.headSha // currentCommitSha\n        );\n        if (GH_DBG) {\n          try {\n            console.error(\n              `[gh-debug] Completed GH check='${checkName}' with ${checkIssues.length} issues; failureIf=${\n                (failureResults || []).filter(f => f.failed).length\n              }`\n            );\n          } catch {}\n        }\n        console.log(`‚úÖ Completed ${checkName} check with ${checkIssues.length} issues`);\n      } catch (error) {\n        console.error(`‚ùå Failed to complete ${checkName} check: ${error}`);\n\n        // Try to mark the check as failed due to execution error\n        try {\n          await this.githubCheckService.completeCheckRun(\n            options.githubChecks.owner,\n            options.githubChecks.repo,\n            checkRun.id,\n            checkName,\n            [],\n            [],\n            error instanceof Error ? error.message : 'Unknown error occurred'\n          );\n        } catch (finalError) {\n          console.error(`‚ùå Failed to mark ${checkName} check as failed: ${finalError}`);\n        }\n      }\n    }\n  }\n\n  /**\n   * Complete GitHub check runs with error status\n   */\n  private async completeGitHubChecksWithError(errorMessage: string): Promise<void> {\n    if (!this.githubCheckService || !this.checkRunMap || !this.githubContext) {\n      return;\n    }\n\n    console.log(`‚ùå Completing ${this.checkRunMap.size} GitHub check runs with error...`);\n\n    for (const [checkName, checkRun] of this.checkRunMap) {\n      try {\n        await this.githubCheckService.completeCheckRun(\n          this.githubContext.owner,\n          this.githubContext.repo,\n          checkRun.id,\n          checkName,\n          [],\n          [],\n          errorMessage\n        );\n        console.log(`‚ùå Completed ${checkName} check with error: ${errorMessage}`);\n      } catch (error) {\n        console.error(`‚ùå Failed to complete ${checkName} check with error: ${error}`);\n      }\n    }\n  }\n\n  /**\n   * Filter checks based on their event triggers to prevent execution of checks\n   * that shouldn't run for the current event type\n   */\n  private filterChecksByEvent(\n    checks: string[],\n    config?: import('./types/config').VisorConfig,\n    prInfo?: PRInfo,\n    logFn?: (message: string) => void,\n    debug?: boolean\n  ): string[] {\n    if (!config?.checks) {\n      // No config available, return all checks (fallback behavior)\n      return checks;\n    }\n\n    // If we have event context from GitHub (prInfo with eventType), apply strict filtering\n    // Otherwise (CLI, tests), use conservative filtering\n    const prInfoWithEvent = prInfo as PRInfo & {\n      eventType?: import('./types/config').EventTrigger;\n    };\n    const hasEventContext =\n      prInfoWithEvent && 'eventType' in prInfoWithEvent && prInfoWithEvent.eventType;\n\n    if (hasEventContext) {\n      // GitHub Action context - apply strict event filtering\n      const currentEvent = prInfoWithEvent.eventType!;\n      if (debug) {\n        logFn?.(`üîß Debug: GitHub Action context, current event: ${currentEvent}`);\n      }\n\n      const filteredChecks: string[] = [];\n      for (const checkName of checks) {\n        const checkConfig = config.checks![checkName];\n        if (!checkConfig) {\n          filteredChecks.push(checkName);\n          continue;\n        }\n\n        const hasOn = Object.prototype.hasOwnProperty.call(checkConfig, 'on');\n        const eventTriggers = checkConfig.on || [];\n        // Semantics: missing 'on' OR empty 'on: []' ‚Üí include for all events\n        if (!hasOn || eventTriggers.length === 0) {\n          filteredChecks.push(checkName);\n          if (debug)\n            logFn?.(\n              `üîß Debug: Check '${checkName}' has ${!hasOn ? 'no' : 'empty'} 'on' field, including for '${currentEvent}'`\n            );\n          continue;\n        }\n\n        if (eventTriggers.includes(currentEvent)) {\n          filteredChecks.push(checkName);\n          if (debug)\n            logFn?.(`üîß Debug: Check '${checkName}' matches event '${currentEvent}', including`);\n        } else if (debug) {\n          logFn?.(\n            `üîß Debug: Check '${checkName}' does not match event '${currentEvent}' (triggers: ${JSON.stringify(\n              eventTriggers\n            )}), skipping`\n          );\n        }\n      }\n      return filteredChecks;\n    } else {\n      // CLI/Test context - conservative filtering\n      if (debug) {\n        logFn?.(`üîß Debug: CLI/Test context, using conservative filtering`);\n      }\n\n      const filteredChecks: string[] = [];\n      for (const checkName of checks) {\n        const checkConfig = config.checks![checkName];\n        if (!checkConfig) {\n          filteredChecks.push(checkName);\n          continue;\n        }\n\n        const eventTriggers = checkConfig.on || [];\n        // Empty or missing 'on' ‚Üí include on all\n        if (eventTriggers.length === 0) {\n          filteredChecks.push(checkName);\n          if (debug) logFn?.(`üîß Debug: Check '${checkName}' included (on: [])`);\n          continue;\n        }\n        // Otherwise include; CLI context does not strictly filter by event\n        filteredChecks.push(checkName);\n        if (debug)\n          logFn?.(\n            `üîß Debug: Check '${checkName}' included (triggers: ${JSON.stringify(eventTriggers)})`\n          );\n      }\n      return filteredChecks;\n    }\n  }\n\n  /**\n   * Determine the current event type from PR info\n   */\n  private getCurrentEventType(prInfo?: PRInfo): import('./types/config').EventTrigger {\n    if (!prInfo) {\n      return 'pr_opened'; // Default fallback\n    }\n\n    // For now, assume all PR-related operations are 'pr_updated' since we don't have\n    // direct access to the original GitHub event here. This is a simplification.\n    // In the future, we could pass the actual event type through the call chain.\n\n    // The key insight is that issue-assistant should only run on issue_opened/issue_comment\n    // events, which don't generate PRInfo objects in the first place.\n    return 'pr_updated';\n  }\n\n  /**\n   * Initialize execution statistics for a check\n   */\n  private initializeCheckStats(checkName: string): void {\n    this.executionStats.set(checkName, {\n      checkName,\n      totalRuns: 0,\n      successfulRuns: 0,\n      failedRuns: 0,\n      skipped: false,\n      totalDuration: 0,\n      providerDurationMs: 0,\n      issuesFound: 0,\n      issuesBySeverity: {\n        critical: 0,\n        error: 0,\n        warning: 0,\n        info: 0,\n      },\n      perIterationDuration: [],\n    });\n  }\n\n  /**\n   * Record the start of a check iteration\n   * Returns the start timestamp for duration tracking\n   */\n  private recordIterationStart(_checkName: string): number {\n    return Date.now();\n  }\n\n  /**\n   * Record completion of a check iteration\n   */\n  private recordIterationComplete(\n    checkName: string,\n    startTime: number,\n    success: boolean,\n    issues: ReviewIssue[],\n    output?: unknown\n  ): void {\n    const stats = this.executionStats.get(checkName);\n    if (!stats) return;\n\n    const duration = Date.now() - startTime;\n    // debug noise removed (kept locally when VISOR_DEBUG needed)\n    stats.totalRuns++;\n    if (success) {\n      stats.successfulRuns++;\n    } else {\n      stats.failedRuns++;\n    }\n    stats.totalDuration += duration;\n    stats.perIterationDuration!.push(duration);\n\n    // If we previously marked this check as skipped in an earlier wave/level,\n    // clear the skip flag now that an execution actually occurred. This ensures\n    // coverage accounting (calls/executed) reflects the latest run.\n    try {\n      if (stats.skipped) {\n        stats.skipped = false;\n        stats.skipReason = undefined;\n        stats.skipCondition = undefined;\n      }\n    } catch {}\n\n    // Count issues by severity\n    for (const issue of issues) {\n      stats.issuesFound++;\n      if (issue.severity === 'critical') stats.issuesBySeverity.critical++;\n      else if (issue.severity === 'error') stats.issuesBySeverity.error++;\n      else if (issue.severity === 'warning') stats.issuesBySeverity.warning++;\n      else if (issue.severity === 'info') stats.issuesBySeverity.info++;\n    }\n\n    // Track outputs produced\n    if (output !== undefined) {\n      stats.outputsProduced = (stats.outputsProduced || 0) + 1;\n    }\n  }\n\n  /**\n   * Record provider/self execution time (in milliseconds) for a check\n   */\n  private recordProviderDuration(checkName: string, ms: number): void {\n    const stats = this.executionStats.get(checkName);\n    if (!stats) return;\n    stats.providerDurationMs = (stats.providerDurationMs || 0) + Math.max(0, Math.floor(ms));\n  }\n\n  /**\n   * Track output in history for loop/goto scenarios\n   */\n  private trackOutputHistory(checkName: string, output: unknown): void {\n    if (output === undefined) return;\n\n    if (!this.outputHistory.has(checkName)) {\n      this.outputHistory.set(checkName, []);\n    }\n    const arr = this.outputHistory.get(checkName)!;\n    arr.push(output);\n    try {\n      if (process.env.VISOR_DEBUG === 'true' && (checkName === 'refine' || checkName === 'ask')) {\n        console.error(`[hist] push ${checkName} (len now ${arr.length})`);\n      }\n    } catch {}\n    // avoid noisy history prints\n  }\n\n  /**\n   * Snapshot of output history per step for test assertions\n   */\n  public getOutputHistorySnapshot(): Record<string, unknown[]> {\n    const out: Record<string, unknown[]> = {};\n    for (const [k, v] of this.outputHistory.entries()) {\n      out[k] = Array.isArray(v) ? [...v] : [];\n    }\n    return out;\n  }\n\n  /**\n   * Record that a check was skipped\n   */\n  private recordSkip(\n    checkName: string,\n    reason: 'if_condition' | 'fail_fast' | 'dependency_failed',\n    condition?: string\n  ): void {\n    const stats = this.executionStats.get(checkName);\n    if (!stats) return;\n\n    stats.skipped = true;\n    stats.skipReason = reason;\n    if (condition) {\n      stats.skipCondition = condition;\n    }\n  }\n\n  /**\n   * Record forEach preview items\n   */\n  private recordForEachPreview(checkName: string, items: unknown[] | undefined): void {\n    const stats = this.executionStats.get(checkName);\n    if (!stats) return;\n    if (!Array.isArray(items) || items.length === 0) return;\n\n    // Store preview of first 3 items\n    const preview = items.slice(0, 3).map(item => {\n      let str: string;\n      if (typeof item === 'string') {\n        str = item;\n      } else if (item === undefined || item === null) {\n        str = '(empty)';\n      } else {\n        try {\n          const j = JSON.stringify(item);\n          str = typeof j === 'string' ? j : String(item);\n        } catch {\n          str = String(item);\n        }\n      }\n      return str.length > 50 ? str.substring(0, 47) + '...' : str;\n    });\n\n    if (items.length > 3) {\n      preview.push(`...${items.length - 3} more`);\n    }\n\n    stats.forEachPreview = preview;\n  }\n\n  /**\n   * Record an error for a check\n   */\n  private recordError(checkName: string, error: Error | string): void {\n    const stats = this.executionStats.get(checkName);\n    if (!stats) return;\n\n    stats.errorMessage = error instanceof Error ? error.message : String(error);\n  }\n\n  /**\n   * Build the final execution statistics object\n   */\n  private buildExecutionStatistics(): ExecutionStatistics {\n    const checks = Array.from(this.executionStats.values());\n    const totalExecutions = checks.reduce((sum, s) => sum + s.totalRuns, 0);\n    const successfulExecutions = checks.reduce((sum, s) => sum + s.successfulRuns, 0);\n    const failedExecutions = checks.reduce((sum, s) => sum + s.failedRuns, 0);\n    const skippedChecks = checks.filter(s => s.skipped).length;\n    const totalDuration = checks.reduce((sum, s) => sum + s.totalDuration, 0);\n\n    return {\n      totalChecksConfigured: checks.length,\n      totalExecutions,\n      successfulExecutions,\n      failedExecutions,\n      skippedChecks,\n      totalDuration,\n      checks,\n    };\n  }\n\n  // Generic fatality helpers to avoid duplication\n  private isFatalRule(id: string, severity?: string): boolean {\n    const sev = (severity || '').toLowerCase();\n    return (\n      sev === 'error' ||\n      sev === 'critical' ||\n      id === 'command/execution_error' ||\n      id.endsWith('/command/execution_error') ||\n      id === 'command/timeout' ||\n      id.endsWith('/command/timeout') ||\n      id === 'command/transform_js_error' ||\n      id.endsWith('/command/transform_js_error') ||\n      id === 'command/transform_error' ||\n      id.endsWith('/command/transform_error') ||\n      id.endsWith('/forEach/iteration_error') ||\n      id === 'forEach/undefined_output' ||\n      id.endsWith('/forEach/undefined_output') ||\n      id.endsWith('_fail_if') ||\n      id.endsWith('/global_fail_if')\n    );\n  }\n\n  private hasFatal(issues: ReviewIssue[] | undefined): boolean {\n    if (!issues || issues.length === 0) return false;\n    return issues.some(i => this.isFatalRule(i.ruleId || '', i.severity));\n  }\n\n  // Gating-specific fatality: ignore generic severity-only errors. Only gate on\n  // well-known provider/command/forEach failures and explicit fail_if markers.\n  private isGatingFatal(issue: ReviewIssue): boolean {\n    const id = (issue.ruleId || '').toString();\n    return (\n      id === 'command/execution_error' ||\n      id.endsWith('/command/execution_error') ||\n      id === 'command/timeout' ||\n      id.endsWith('/command/timeout') ||\n      id === 'command/transform_js_error' ||\n      id.endsWith('/command/transform_js_error') ||\n      id === 'command/transform_error' ||\n      id.endsWith('/command/transform_error') ||\n      id.endsWith('/forEach/iteration_error') ||\n      id === 'forEach/undefined_output' ||\n      id.endsWith('/forEach/undefined_output') ||\n      id.endsWith('_fail_if') ||\n      id.endsWith('/global_fail_if')\n    );\n  }\n\n  private async failIfTriggered(\n    checkName: string,\n    result: ReviewSummary,\n    config?: import('./types/config').VisorConfig,\n    previousOutputs?: Record<string, ReviewSummary> | Map<string, ReviewSummary>\n  ): Promise<boolean> {\n    if (!config) return false;\n    const failures = await this.evaluateFailureConditions(\n      checkName,\n      result,\n      config,\n      undefined,\n      previousOutputs\n    );\n    return failures.some(f => f.failed);\n  }\n\n  /**\n   * Truncate a string to max length with ellipsis\n   */\n  private truncate(str: string, maxLen: number): string {\n    if (str.length <= maxLen) return str;\n    return str.substring(0, maxLen - 3) + '...';\n  }\n\n  /**\n   * Format the Status column for execution summary table\n   */\n  private formatStatusColumn(stats: CheckExecutionStats): string {\n    if (stats.skipped) {\n      if (stats.skipReason === 'if_condition') return '‚è≠ if';\n      if (stats.skipReason === 'fail_fast') return '‚è≠ ff';\n      if (stats.skipReason === 'dependency_failed') return '‚è≠ dep';\n      return '‚è≠';\n    }\n\n    // Prefer history length when it indicates more actual executions than our counter\n    const historyLen = (() => {\n      try {\n        return this.outputHistory.get(stats.checkName)?.length || 0;\n      } catch {\n        return 0;\n      }\n    })();\n    const totalRuns = Math.max(stats.totalRuns || 0, historyLen);\n    if (totalRuns === 0) return '-';\n\n    const symbol = stats.failedRuns === 0 ? '‚úî' : stats.successfulRuns === 0 ? '‚úñ' : '‚úî/‚úñ';\n\n    // Show iteration count if > 1\n    if (totalRuns > 1) {\n      if (stats.failedRuns > 0 && stats.successfulRuns > 0) {\n        // Partial success\n        return `${symbol} ${stats.successfulRuns}/${totalRuns}`;\n      } else {\n        // All success or all failed\n        return `${symbol} √ó${totalRuns}`;\n      }\n    }\n\n    return symbol;\n  }\n\n  /**\n   * Format the Details column for execution summary table\n   */\n  private formatDetailsColumn(stats: CheckExecutionStats, _isForEachParent?: boolean): string {\n    const parts: string[] = [];\n\n    // Simpler summary: do not show passes/items here to avoid confusion.\n    // Status column already shows √óN when runs > 1.\n\n    // Show self/provider time to disambiguate inclusive duration in the main column\n    if (typeof stats.providerDurationMs === 'number' && stats.providerDurationMs > 0) {\n      const selfSec = (stats.providerDurationMs / 1000).toFixed(1);\n      parts.unshift(`self:${selfSec}s`);\n    }\n\n    // Outputs produced (forEach)\n    if (stats.outputsProduced && stats.outputsProduced > 0) {\n      parts.push(`‚Üí${stats.outputsProduced}`);\n    }\n\n    // Critical issues\n    if (stats.issuesBySeverity.critical > 0) {\n      parts.push(`${stats.issuesBySeverity.critical}üî¥`);\n    }\n\n    // Warnings\n    if (stats.issuesBySeverity.warning > 0) {\n      parts.push(`${stats.issuesBySeverity.warning}‚ö†Ô∏è`);\n    }\n\n    // Info (only if no critical/warnings)\n    if (\n      stats.issuesBySeverity.info > 0 &&\n      stats.issuesBySeverity.critical === 0 &&\n      stats.issuesBySeverity.warning === 0\n    ) {\n      parts.push(`${stats.issuesBySeverity.info}üí°`);\n    }\n\n    // Error message or skip condition\n    if (stats.errorMessage) {\n      parts.push(this.truncate(stats.errorMessage, 20));\n    } else if (stats.skipCondition) {\n      parts.push(this.truncate(stats.skipCondition, 20));\n    }\n\n    return parts.join(' ');\n  }\n\n  /**\n   * Log the execution summary table\n   */\n  private logExecutionSummary(stats: ExecutionStatistics): void {\n    const totalIssues = stats.checks.reduce((sum, s) => sum + s.issuesFound, 0);\n    const criticalIssues = stats.checks.reduce((sum, s) => sum + s.issuesBySeverity.critical, 0);\n    const warningIssues = stats.checks.reduce((sum, s) => sum + s.issuesBySeverity.warning, 0);\n    const durationSec = (stats.totalDuration / 1000).toFixed(1);\n\n    // Summary box\n    const summaryTable = new (require('cli-table3'))({\n      style: {\n        head: [],\n        border: [],\n      },\n      colWidths: [41],\n    });\n\n    summaryTable.push(\n      [`Checks Complete (${durationSec}s)`],\n      [`Checks: ${stats.totalChecksConfigured} configured ‚Üí ${stats.totalExecutions} executions`],\n      [\n        `Status: ${stats.successfulExecutions} ‚úî ‚îÇ ${stats.failedExecutions} ‚úñ ‚îÇ ${stats.skippedChecks} ‚è≠`,\n      ]\n    );\n\n    if (totalIssues > 0) {\n      let issuesLine = `Issues: ${totalIssues} total`;\n      if (criticalIssues > 0) issuesLine += ` (${criticalIssues} üî¥`;\n      if (warningIssues > 0) issuesLine += `${criticalIssues > 0 ? ' ' : ' ('}${warningIssues} ‚ö†Ô∏è)`;\n      else if (criticalIssues > 0) issuesLine += ')';\n      summaryTable.push([issuesLine]);\n    }\n\n    logger.info('');\n    logger.info(summaryTable.toString());\n\n    // Details table\n    logger.info('');\n    logger.info('Check Details:');\n\n    const detailsTable = new (require('cli-table3'))({\n      head: ['Check', 'Duration', 'Status', 'Details'],\n      colWidths: [21, 18, 10, 21],\n      style: {\n        head: ['cyan'],\n        border: ['grey'],\n      },\n    });\n\n    for (const checkStats of stats.checks) {\n      const isForEachParent = !!this.config?.checks?.[checkStats.checkName]?.forEach;\n      // Show only the self/provider total time across all runs.\n      const selfMs =\n        typeof checkStats.providerDurationMs === 'number' && checkStats.providerDurationMs > 0\n          ? checkStats.providerDurationMs\n          : checkStats.totalDuration; // fallback if provider time missing\n      const duration = checkStats.skipped ? '-' : `${(selfMs / 1000).toFixed(1)}s`;\n      const status = this.formatStatusColumn(checkStats);\n      const details = this.formatDetailsColumn(checkStats, isForEachParent);\n\n      detailsTable.push([checkStats.checkName, duration, status, details]);\n    }\n\n    logger.info(detailsTable.toString());\n\n    // Clarify that we will finalize GitHub check runs after the table (if enabled)\n    try {\n      if (this.checkRunMap && this.checkRunMap.size > 0) {\n        logger.info('');\n        logger.info('‚è≥ Finalizing GitHub check runs...');\n      }\n    } catch {}\n\n    // Legend\n    logger.info('');\n    logger.info(\n      'Legend: ‚úî=success ‚îÇ ‚úñ=failed ‚îÇ ‚è≠=skipped ‚îÇ √óN=iterations ‚îÇ ‚ÜíN=outputs ‚îÇ Nüî¥=critical ‚îÇ N‚ö†Ô∏è=warnings'\n    );\n  }\n}\n","/**\n * GitHub Check Service for creating and managing check runs based on failure conditions\n */\n\nimport { Octokit } from '@octokit/rest';\nimport { FailureConditionResult } from './types/config';\nimport { ReviewIssue } from './reviewer';\nimport { generateFooter } from './footer';\n\nexport interface CheckRunOptions {\n  owner: string;\n  repo: string;\n  head_sha: string;\n  name: string;\n  details_url?: string;\n  external_id?: string;\n  engine_mode?: 'legacy' | 'state-machine'; // M4: Track which engine mode was used\n}\n\nexport interface CheckRunAnnotation {\n  path: string;\n  start_line: number;\n  end_line: number;\n  annotation_level: 'notice' | 'warning' | 'failure';\n  message: string;\n  title?: string;\n  raw_details?: string;\n}\n\nexport interface CheckRunSummary {\n  title: string;\n  summary: string;\n  text?: string;\n}\n\nexport type CheckRunStatus = 'queued' | 'in_progress' | 'completed';\nexport type CheckRunConclusion =\n  | 'success'\n  | 'failure'\n  | 'neutral'\n  | 'cancelled'\n  | 'timed_out'\n  | 'action_required';\n\n/**\n * Service for managing GitHub Check Runs based on Visor failure conditions\n */\nexport class GitHubCheckService {\n  private octokit: Octokit;\n  private maxAnnotations = 50; // GitHub API limit\n\n  constructor(octokit: Octokit) {\n    this.octokit = octokit;\n  }\n\n  /**\n   * Create a new check run in queued status\n   * M4: Includes engine_mode metadata in summary\n   */\n  async createCheckRun(\n    options: CheckRunOptions,\n    summary?: CheckRunSummary\n  ): Promise<{ id: number; url: string }> {\n    try {\n      // M4: Add engine mode metadata to summary if provided\n      const enhancedSummary = summary && options.engine_mode\n        ? {\n            ...summary,\n            summary: `${summary.summary}\\n\\n_Engine: ${options.engine_mode}_`,\n          }\n        : summary;\n\n      const response = await this.octokit.rest.checks.create({\n        owner: options.owner,\n        repo: options.repo,\n        name: options.name,\n        head_sha: options.head_sha,\n        status: 'queued',\n        details_url: options.details_url,\n        external_id: options.external_id,\n        output: enhancedSummary\n          ? {\n              title: enhancedSummary.title,\n              summary: enhancedSummary.summary,\n              text: enhancedSummary.text,\n            }\n          : undefined,\n      });\n\n      return {\n        id: response.data.id,\n        url: response.data.html_url || '',\n      };\n    } catch (error) {\n      throw new Error(\n        `Failed to create check run: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Update check run to in_progress status\n   */\n  async updateCheckRunInProgress(\n    owner: string,\n    repo: string,\n    check_run_id: number,\n    summary?: CheckRunSummary\n  ): Promise<void> {\n    try {\n      await this.octokit.rest.checks.update({\n        owner,\n        repo,\n        check_run_id,\n        status: 'in_progress',\n        output: summary\n          ? {\n              title: summary.title,\n              summary: summary.summary,\n              text: summary.text,\n            }\n          : undefined,\n      });\n    } catch (error) {\n      throw new Error(\n        `Failed to update check run to in_progress: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Complete a check run with results based on failure conditions\n   */\n  async completeCheckRun(\n    owner: string,\n    repo: string,\n    check_run_id: number,\n    checkName: string,\n    failureResults: FailureConditionResult[],\n    reviewIssues: ReviewIssue[] = [],\n    executionError?: string,\n    filesChangedInCommit?: string[],\n    prNumber?: number,\n    currentCommitSha?: string\n  ): Promise<void> {\n    try {\n      // Clear old annotations from ALL previous check runs (including older runs on the same commit)\n      // This prevents annotation accumulation when a check runs multiple times\n      if (prNumber && currentCommitSha) {\n        await this.clearOldAnnotations(\n          owner,\n          repo,\n          prNumber,\n          checkName,\n          currentCommitSha,\n          check_run_id\n        );\n      }\n\n      const { conclusion, summary } = this.determineCheckRunConclusion(\n        checkName,\n        failureResults,\n        reviewIssues,\n        executionError\n      );\n\n      // Filter out system-level issues (fail_if conditions, internal errors)\n      // These should not appear as annotations but affect the check conclusion\n      let filteredIssues = reviewIssues.filter(\n        issue => !(issue.file === 'system' && issue.line === 0)\n      );\n\n      // Filter annotations to only include files changed in this commit\n      // This prevents old annotations from previous commits showing up in the Files tab\n      if (filesChangedInCommit && filesChangedInCommit.length > 0) {\n        filteredIssues = filteredIssues.filter(issue =>\n          filesChangedInCommit.some(changedFile => issue.file === changedFile)\n        );\n      }\n\n      const annotations = this.convertIssuesToAnnotations(filteredIssues);\n\n      await this.octokit.rest.checks.update({\n        owner,\n        repo,\n        check_run_id,\n        status: 'completed',\n        conclusion,\n        completed_at: new Date().toISOString(),\n        output: {\n          title: summary.title,\n          summary: summary.summary,\n          text: summary.text,\n          annotations: annotations.slice(0, this.maxAnnotations), // GitHub limit\n        },\n      });\n    } catch (error) {\n      throw new Error(\n        `Failed to complete check run: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Determine check run conclusion based on failure conditions and issues\n   */\n  private determineCheckRunConclusion(\n    checkName: string,\n    failureResults: FailureConditionResult[],\n    reviewIssues: ReviewIssue[],\n    executionError?: string\n  ): { conclusion: CheckRunConclusion; summary: CheckRunSummary } {\n    // Handle execution errors first\n    if (executionError) {\n      return {\n        conclusion: 'failure',\n        summary: {\n          title: '‚ùå Check Execution Failed',\n          summary: `The ${checkName} check failed to execute properly.`,\n          text: `**Error:** ${executionError}\\n\\nPlease check your configuration and try again.`,\n        },\n      };\n    }\n\n    // Check if any fail_if conditions were met\n    const failedConditions = failureResults.filter(result => result.failed);\n\n    // Count issues by severity (for informational display only)\n    const criticalIssues = reviewIssues.filter(issue => issue.severity === 'critical').length;\n    const errorIssues = reviewIssues.filter(issue => issue.severity === 'error').length;\n    const warningIssues = reviewIssues.filter(issue => issue.severity === 'warning').length;\n    const totalIssues = reviewIssues.length;\n\n    // Determine conclusion ONLY based on fail_if evaluation results\n    // The presence of issues (critical, error, warning) does NOT affect the conclusion\n    // Only the fail_if condition determines pass/fail status\n    let conclusion: CheckRunConclusion;\n    let title: string;\n    let summaryText: string;\n    let details: string;\n\n    if (failedConditions.length > 0) {\n      // Check fails if fail_if condition is met\n      conclusion = 'failure';\n      title = 'üö® Check Failed';\n      summaryText = `${checkName} check failed because fail_if condition was met.`;\n\n      details = this.formatCheckDetails(failureResults, reviewIssues, {\n        failedConditions: failedConditions.length,\n        warningConditions: 0,\n        criticalIssues,\n        errorIssues,\n        warningIssues,\n        totalIssues,\n      });\n    } else {\n      // No fail_if conditions met - check passes regardless of issues found\n      conclusion = 'success';\n\n      // Adjust the title and summary based on issues found, but conclusion remains success\n      if (criticalIssues > 0 || errorIssues > 0) {\n        title = '‚úÖ Check Passed (Issues Found)';\n        summaryText = `${checkName} check passed. Found ${criticalIssues} critical and ${errorIssues} error issues, but fail_if condition was not met.`;\n      } else if (warningIssues > 0) {\n        title = '‚úÖ Check Passed (Warnings Found)';\n        summaryText = `${checkName} check passed. Found ${warningIssues} warning${warningIssues === 1 ? '' : 's'}, but fail_if condition was not met.`;\n      } else {\n        title = '‚úÖ Check Passed';\n        summaryText = `${checkName} check completed successfully with no issues found.`;\n      }\n\n      details = this.formatCheckDetails(failureResults, reviewIssues, {\n        failedConditions: 0,\n        warningConditions: 0,\n        criticalIssues,\n        errorIssues,\n        warningIssues,\n        totalIssues,\n      });\n    }\n\n    return {\n      conclusion,\n      summary: {\n        title,\n        summary: summaryText,\n        text: details,\n      },\n    };\n  }\n\n  /**\n   * Format detailed check results for the check run summary\n   */\n  private formatCheckDetails(\n    failureResults: FailureConditionResult[],\n    reviewIssues: ReviewIssue[],\n    counts: {\n      failedConditions: number;\n      warningConditions: number;\n      criticalIssues: number;\n      errorIssues: number;\n      warningIssues: number;\n      totalIssues: number;\n    }\n  ): string {\n    const sections: string[] = [];\n\n    // Summary section\n    sections.push('## üìä Summary');\n    sections.push(`- **Total Issues:** ${counts.totalIssues}`);\n    if (counts.criticalIssues > 0) {\n      sections.push(`- **Critical Issues:** ${counts.criticalIssues}`);\n    }\n    if (counts.errorIssues > 0) {\n      sections.push(`- **Error Issues:** ${counts.errorIssues}`);\n    }\n    if (counts.warningIssues > 0) {\n      sections.push(`- **Warning Issues:** ${counts.warningIssues}`);\n    }\n    sections.push('');\n\n    // Failure conditions section\n    if (failureResults.length > 0) {\n      sections.push('## üîç Failure Condition Results');\n\n      const failedConditions = failureResults.filter(result => result.failed);\n      const passedConditions = failureResults.filter(result => !result.failed);\n\n      if (failedConditions.length > 0) {\n        sections.push('### Failed Conditions');\n        failedConditions.forEach(condition => {\n          sections.push(\n            `- **${condition.conditionName}**: ${condition.message || condition.expression}`\n          );\n          if (condition.severity) {\n            const icon = this.getSeverityEmoji(condition.severity);\n            sections.push(`  - Severity: ${icon} ${condition.severity}`);\n          }\n        });\n        sections.push('');\n      }\n\n      if (passedConditions.length > 0) {\n        sections.push('### Passed Conditions');\n        passedConditions.forEach(condition => {\n          sections.push(\n            `- **${condition.conditionName}**: ${condition.message || 'Condition passed'}`\n          );\n        });\n        sections.push('');\n      }\n    }\n\n    // Issues by category section\n    if (reviewIssues.length > 0) {\n      const issuesByCategory = this.groupIssuesByCategory(reviewIssues);\n      sections.push('## Issues by Category');\n\n      Object.entries(issuesByCategory).forEach(([category, issues]) => {\n        if (issues.length > 0) {\n          sections.push(\n            `### ${category.charAt(0).toUpperCase() + category.slice(1)} (${issues.length})`\n          );\n\n          // Show only first 5 issues per category to keep the summary concise\n          const displayIssues = issues.slice(0, 5);\n          displayIssues.forEach(issue => {\n            const severityIcon = this.getSeverityEmoji(issue.severity);\n            sections.push(`- ${severityIcon} **${issue.file}:${issue.line}** - ${issue.message}`);\n          });\n\n          if (issues.length > 5) {\n            sections.push(`- *...and ${issues.length - 5} more ${category} issues*`);\n          }\n          sections.push('');\n        }\n      });\n    }\n\n    // Footer\n    sections.push('');\n    sections.push(generateFooter());\n\n    return sections.join('\\n');\n  }\n\n  /**\n   * Convert review issues to GitHub check run annotations\n   */\n  private convertIssuesToAnnotations(reviewIssues: ReviewIssue[]): CheckRunAnnotation[] {\n    return reviewIssues\n      .slice(0, this.maxAnnotations) // Respect GitHub's annotation limit\n      .map(issue => ({\n        path: issue.file,\n        start_line: issue.line,\n        end_line: issue.endLine || issue.line,\n        annotation_level: this.mapSeverityToAnnotationLevel(issue.severity),\n        message: issue.message,\n        title: `${issue.category} Issue`,\n        raw_details: issue.suggestion || undefined,\n      }));\n  }\n\n  /**\n   * Map Visor issue severity to GitHub annotation level\n   */\n  private mapSeverityToAnnotationLevel(severity: string): 'notice' | 'warning' | 'failure' {\n    switch (severity) {\n      case 'critical':\n      case 'error':\n        return 'failure';\n      case 'warning':\n        return 'warning';\n      case 'info':\n      default:\n        return 'notice';\n    }\n  }\n\n  /**\n   * Group issues by category\n   */\n  private groupIssuesByCategory(issues: ReviewIssue[]): Record<string, ReviewIssue[]> {\n    const grouped: Record<string, ReviewIssue[]> = {};\n\n    issues.forEach(issue => {\n      const category = issue.category || 'general';\n      if (!grouped[category]) {\n        grouped[category] = [];\n      }\n      grouped[category].push(issue);\n    });\n\n    return grouped;\n  }\n\n  /**\n   * Get emoji for issue severity (allowed; step/category emojis are removed)\n   */\n  private getSeverityEmoji(severity: string): string {\n    const iconMap: Record<string, string> = {\n      critical: 'üö®',\n      error: '‚ùå',\n      warning: '‚ö†Ô∏è',\n      info: '‚ÑπÔ∏è',\n    };\n    return iconMap[String(severity || '').toLowerCase()] || '';\n  }\n\n  /**\n   * Create multiple check runs for different checks with failure condition support\n   */\n  async createMultipleCheckRuns(\n    options: CheckRunOptions,\n    checkResults: Array<{\n      checkName: string;\n      failureResults: FailureConditionResult[];\n      reviewIssues: ReviewIssue[];\n      executionError?: string;\n    }>\n  ): Promise<Array<{ checkName: string; id: number; url: string }>> {\n    const results: Array<{ checkName: string; id: number; url: string }> = [];\n\n    for (const checkResult of checkResults) {\n      try {\n        // Create check run\n        const checkRun = await this.createCheckRun({\n          ...options,\n          name: `Visor: ${checkResult.checkName}`,\n          external_id: `visor-${checkResult.checkName}-${options.head_sha.substring(0, 7)}`,\n        });\n\n        // Update to in progress\n        await this.updateCheckRunInProgress(options.owner, options.repo, checkRun.id, {\n          title: `Running ${checkResult.checkName} check...`,\n          summary: `Analyzing code with ${checkResult.checkName} check using AI.`,\n        });\n\n        // Complete with results\n        await this.completeCheckRun(\n          options.owner,\n          options.repo,\n          checkRun.id,\n          checkResult.checkName,\n          checkResult.failureResults,\n          checkResult.reviewIssues,\n          checkResult.executionError\n        );\n\n        results.push({\n          checkName: checkResult.checkName,\n          id: checkRun.id,\n          url: checkRun.url,\n        });\n      } catch (error) {\n        console.error(`Failed to create check run for ${checkResult.checkName}:`, error);\n        // Continue with other checks even if one fails\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Get check runs for a specific commit\n   */\n  async getCheckRuns(\n    owner: string,\n    repo: string,\n    ref: string\n  ): Promise<Array<{ id: number; name: string; status: string; conclusion: string | null }>> {\n    try {\n      const response = await this.octokit.rest.checks.listForRef({\n        owner,\n        repo,\n        ref,\n        filter: 'all',\n      });\n\n      return response.data.check_runs\n        .filter(check => check.name.startsWith('Visor:'))\n        .map(check => ({\n          id: check.id,\n          name: check.name,\n          status: check.status,\n          conclusion: check.conclusion,\n        }));\n    } catch (error) {\n      throw new Error(\n        `Failed to get check runs: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Get check runs for a specific commit SHA\n   * Returns all check runs with the given name on this commit\n   */\n  async getCheckRunsForCommit(\n    owner: string,\n    repo: string,\n    commitSha: string,\n    checkName: string\n  ): Promise<Array<{ id: number; head_sha: string }>> {\n    try {\n      const checksResponse = await this.octokit.rest.checks.listForRef({\n        owner,\n        repo,\n        ref: commitSha,\n        check_name: `Visor: ${checkName}`,\n      });\n\n      return checksResponse.data.check_runs.map(check => ({\n        id: check.id,\n        head_sha: commitSha,\n      }));\n    } catch (error) {\n      throw new Error(\n        `Failed to get check runs for commit ${commitSha}: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Clear annotations from old check runs on the current commit\n   * This prevents annotation accumulation when a check runs multiple times on the same commit\n   * (e.g., force push, re-running checks)\n   */\n  async clearOldAnnotations(\n    owner: string,\n    repo: string,\n    prNumber: number, // Not used, kept for backward compatibility\n    checkName: string,\n    currentCommitSha: string,\n    currentCheckRunId: number\n  ): Promise<void> {\n    try {\n      // Get all check runs for this check name on the current commit\n      const allCheckRuns = await this.getCheckRunsForCommit(\n        owner,\n        repo,\n        currentCommitSha,\n        checkName\n      );\n\n      // Filter out the CURRENT check run (by ID)\n      // This handles the case where Visor runs multiple times on the same commit\n      const oldRuns = allCheckRuns.filter(run => run.id !== currentCheckRunId);\n\n      if (oldRuns.length === 0) {\n        console.debug(`No old check runs to clear for ${checkName} on commit ${currentCommitSha}`);\n        return;\n      }\n\n      console.debug(\n        `Clearing ${oldRuns.length} old check run(s) for ${checkName} on commit ${currentCommitSha.substring(0, 7)} (keeping current run ${currentCheckRunId})`\n      );\n\n      // Update each old check run to have empty annotations\n      for (const run of oldRuns) {\n        try {\n          await this.octokit.rest.checks.update({\n            owner,\n            repo,\n            check_run_id: run.id,\n            output: {\n              title: 'Outdated',\n              summary: 'This check has been superseded by a newer run.',\n              annotations: [], // Clear annotations\n            },\n          });\n          console.debug(`‚úì Cleared annotations from check run ${run.id}`);\n        } catch (error) {\n          console.debug(`Could not clear annotations for check run ${run.id}:`, error);\n        }\n      }\n    } catch (error) {\n      // Don't fail the whole check if we can't clear old annotations\n      console.warn('Failed to clear old annotations:', error);\n    }\n  }\n}\n","import { createSecureSandbox } from '../../utils/sandbox';\nimport type { PRInfo } from '../../pr-analyzer';\nimport type { ReviewSummary } from '../../reviewer';\nimport type { VisorConfig, CheckConfig, OnFinishConfig } from '../../types/config';\nimport { buildSandboxEnv } from '../../utils/env-exposure';\nimport { MemoryStore } from '../../memory-store';\n\nexport function buildProjectionFrom(\n  results: Map<string, ReviewSummary>,\n  historySnapshot: Record<string, unknown[]>\n): {\n  outputsForContext: Record<string, unknown>;\n  outputsHistoryForContext: Record<string, unknown[]>;\n} {\n  const outputsForContext: Record<string, unknown> = {};\n  for (const [name, result] of results.entries()) {\n    const r = result as ReviewSummary & { output?: unknown };\n    outputsForContext[name] = r.output !== undefined ? r.output : r;\n  }\n  const outputsHistoryForContext: Record<string, unknown[]> = {};\n  for (const [check, arr] of Object.entries(historySnapshot || {})) {\n    outputsHistoryForContext[check] = Array.isArray(arr) ? (arr as unknown[]) : [];\n  }\n  return { outputsForContext, outputsHistoryForContext };\n}\n\nexport interface OnFinishContext {\n  step: { id: string; tags: string[]; group?: string };\n  attempt: number;\n  loop: number;\n  outputs: Record<string, unknown>;\n  outputs_history: Record<string, unknown[]>;\n  outputs_raw: Record<string, unknown>;\n  forEach: unknown;\n  memory: {\n    get: (key: string, ns?: string) => unknown;\n    has: (key: string, ns?: string) => boolean;\n    getAll: (ns?: string) => Record<string, unknown>;\n    set: (key: string, value: unknown, ns?: string) => void;\n    clear: (ns?: string) => void;\n    increment: (key: string, amount?: number, ns?: string) => number;\n  };\n  pr: { number: number; title?: string; author?: string; branch?: string; base?: string };\n  files?: unknown;\n  env: Record<string, string | undefined>;\n  event: { name: string };\n}\n\nexport function composeOnFinishContext(\n  _memoryConfig: VisorConfig['memory'] | undefined,\n  checkName: string,\n  checkConfig: CheckConfig,\n  outputsForContext: Record<string, unknown>,\n  outputsHistoryForContext: Record<string, unknown[]>,\n  forEachStats: any,\n  prInfo: PRInfo\n): OnFinishContext {\n  // No MemoryStore in on_finish context ‚Äî outputs and outputs_history are sufficient\n  const outputs_raw: Record<string, unknown> = {};\n  for (const [name, val] of Object.entries(outputsForContext))\n    if (name !== 'history') outputs_raw[name] = val;\n  const outputsMerged = { ...outputsForContext, history: outputsHistoryForContext } as Record<\n    string,\n    unknown\n  >;\n  // Memory helpers backed by MemoryStore, but exposed synchronously for\n  // sandboxed goto_js/on_success.run_js compatibility.\n  const memoryStore = MemoryStore.getInstance();\n  const memoryHelpers = {\n    get: (key: string, ns?: string) => memoryStore.get(key, ns),\n    has: (key: string, ns?: string) => memoryStore.has(key, ns),\n    getAll: (ns?: string) => memoryStore.getAll(ns),\n    set: (key: string, value: unknown, ns?: string) => {\n      const nsName = ns || memoryStore.getDefaultNamespace();\n      const data: Map<string, Map<string, unknown>> = (memoryStore as any)['data'];\n      if (!data.has(nsName)) data.set(nsName, new Map());\n      data.get(nsName)!.set(key, value);\n    },\n    clear: (ns?: string) => {\n      const data: Map<string, Map<string, unknown>> = (memoryStore as any)['data'];\n      if (ns) data.delete(ns);\n      else data.clear();\n    },\n    increment: (key: string, amount = 1, ns?: string) => {\n      const nsName = ns || memoryStore.getDefaultNamespace();\n      const data: Map<string, Map<string, unknown>> = (memoryStore as any)['data'];\n      if (!data.has(nsName)) data.set(nsName, new Map());\n      const nsMap = data.get(nsName)!;\n      const current = nsMap.get(key);\n      const numCurrent = typeof current === 'number' ? current : 0;\n      const newValue = numCurrent + amount;\n      nsMap.set(key, newValue);\n      return newValue;\n    },\n  };\n\n  return {\n    step: { id: checkName, tags: checkConfig.tags || [], group: checkConfig.group },\n    attempt: 1,\n    loop: 0,\n    outputs: outputsMerged,\n    outputs_history: outputsHistoryForContext,\n    outputs_raw,\n    forEach: forEachStats,\n    memory: memoryHelpers,\n    pr: {\n      number: prInfo.number,\n      title: prInfo.title,\n      author: prInfo.author,\n      branch: prInfo.head,\n      base: prInfo.base,\n    },\n    files: prInfo.files,\n    env: buildSandboxEnv(process.env),\n    event: { name: prInfo.eventType || 'manual' },\n  };\n}\n\nexport function evaluateOnFinishGoto(\n  onFinish: NonNullable<OnFinishConfig>,\n  onFinishContext: any,\n  debug: boolean,\n  log: (msg: string) => void\n): string | null {\n  let gotoTarget: string | null = null;\n  if (onFinish.goto_js) {\n    const sandbox = createSecureSandbox();\n    try {\n      const scope = onFinishContext;\n      const code = `\n        const step = scope.step; const attempt = scope.attempt; const loop = scope.loop; const outputs = scope.outputs; const outputs_history = scope.outputs_history; const outputs_raw = scope.outputs_raw; const forEach = scope.forEach; const memory = scope.memory; const pr = scope.pr; const files = scope.files; const env = scope.env; const event = scope.event; const log = (...a)=> console.log('üîç Debug:',...a);\n        const __fn = () => {\\n${onFinish.goto_js}\\n};\n        return __fn();\n      `;\n      // Use shared compileAndRun helper for consistent behavior\n      const { compileAndRun } = require('../../utils/sandbox');\n      const result = compileAndRun(\n        sandbox,\n        code,\n        { scope },\n        { injectLog: false, wrapFunction: false }\n      );\n      try {\n        if (debug) {\n          const hist =\n            (onFinishContext &&\n              onFinishContext.outputs &&\n              (onFinishContext.outputs as any).history) ||\n            {};\n          const vf = Array.isArray(hist['validate-fact'])\n            ? hist['validate-fact'].filter((x: any) => !Array.isArray(x))\n            : [];\n          const items =\n            (onFinishContext &&\n              onFinishContext.forEach &&\n              (onFinishContext.forEach as any).last_wave_size) ||\n            0;\n          log(`üîß Debug: goto_js result=${String(result)} items=${items} vf_count=${vf.length}`);\n        }\n      } catch {}\n      gotoTarget = typeof result === 'string' && result ? result : null;\n      if (debug) log(`üîß Debug: on_finish.goto_js evaluated ‚Üí ${String(gotoTarget)}`);\n    } catch (e) {\n      try {\n        // Surface evaluation problems in debug logs to aid diagnosis\n        const msg = e instanceof Error ? e.message : String(e);\n\n        console.error(`‚úó on_finish.goto_js: evaluation error: ${msg}`);\n      } catch {}\n      // Fall back to static goto\n      if (onFinish.goto) gotoTarget = onFinish.goto;\n    }\n  } else if (onFinish.goto) {\n    gotoTarget = onFinish.goto;\n  }\n  return gotoTarget;\n}\n\nexport function recomputeAllValidFromHistory(\n  history: Record<string, unknown[]>,\n  forEachItemsCount: number\n): boolean | undefined {\n  const vfArrRaw = Array.isArray(history['validate-fact'])\n    ? (history['validate-fact'] as unknown[])\n    : [];\n  if (forEachItemsCount <= 0) return undefined;\n\n  // Consider only non-array entries (per-item results)\n  const vfArr = vfArrRaw.filter(v => !Array.isArray(v)) as any[];\n  if (vfArr.length < forEachItemsCount) return false;\n\n  // 1) Prefer strict last-wave grouping when loop_idx metadata is present.\n  const withLoop = vfArr.filter(\n    v => v && typeof v === 'object' && Number.isFinite((v as any).loop_idx)\n  ) as Array<{ loop_idx: number } & Record<string, unknown>>;\n  if (withLoop.length >= forEachItemsCount) {\n    const maxLoop = Math.max(...withLoop.map(v => Number(v.loop_idx)));\n    const sameWave = withLoop.filter(v => Number(v.loop_idx) === maxLoop);\n    try {\n      if (process.env.VISOR_DEBUG === 'true') {\n        console.error(\n          `[ofAllValid] loop_idx=${maxLoop} sameWave=${sameWave.length} items=${forEachItemsCount}`\n        );\n      }\n    } catch {}\n    if (sameWave.length >= forEachItemsCount) {\n      // If we have ids, take the last N distinct by id; otherwise, take last N\n      const take = (() => {\n        const withIds = sameWave.filter(\n          o => typeof (o as any).fact_id === 'string' || typeof (o as any).id === 'string'\n        );\n        if (withIds.length >= forEachItemsCount) {\n          const recent: any[] = [];\n          const seen = new Set<string>();\n          for (let i = sameWave.length - 1; i >= 0 && recent.length < forEachItemsCount; i--) {\n            const o: any = sameWave[i];\n            const key = (o.fact_id || o.id) as string | undefined;\n            if (!key || seen.has(key)) continue;\n            seen.add(key);\n            recent.push(o);\n          }\n          if (recent.length === forEachItemsCount) return recent;\n        }\n        return sameWave.slice(-forEachItemsCount);\n      })();\n      const ok = take.every(o => o && ((o as any).is_valid === true || (o as any).valid === true));\n      try {\n        if (process.env.VISOR_DEBUG === 'true') {\n          const vals = take.map(o => (o as any).is_valid ?? (o as any).valid);\n          console.error(`[ofAllValid] loop verdicts=${JSON.stringify(vals)} ok=${ok}`);\n        }\n      } catch {}\n      return ok;\n    }\n  }\n\n  // 2) Fall back to last N distinct-by-id across the whole history\n  const withIds = vfArr.filter(\n    o => typeof (o as any).fact_id === 'string' || typeof (o as any).id === 'string'\n  );\n  if (withIds.length >= forEachItemsCount) {\n    const recent: any[] = [];\n    const seen = new Set<string>();\n    for (let i = vfArr.length - 1; i >= 0 && recent.length < forEachItemsCount; i--) {\n      const o: any = vfArr[i];\n      const key = (o.fact_id || o.id) as string | undefined;\n      if (!key || seen.has(key)) continue;\n      seen.add(key);\n      recent.push(o);\n    }\n    if (recent.length === forEachItemsCount) {\n      const ok = recent.every(o => o && (o.is_valid === true || o.valid === true));\n      try {\n        if (process.env.VISOR_DEBUG === 'true') {\n          const vals = recent.map(o => (o as any).is_valid ?? (o as any).valid);\n          console.error(`[ofAllValid] id-recent verdicts=${JSON.stringify(vals)} ok=${ok}`);\n        }\n      } catch {}\n      return ok;\n    }\n  }\n\n  // 3) Last-resort fallback: treat last N entries as current wave\n  if (vfArr.length >= forEachItemsCount) {\n    const lastN = vfArr.slice(-forEachItemsCount) as any[];\n    const ok = lastN.every(o => o && (o.is_valid === true || o.valid === true));\n    try {\n      if (process.env.VISOR_DEBUG === 'true') {\n        const vals = lastN.map(o => (o as any).is_valid ?? (o as any).valid);\n        console.error(`[ofAllValid] tail verdicts=${JSON.stringify(vals)} ok=${ok}`);\n      }\n    } catch {}\n    return ok;\n  }\n\n  return false;\n}\n","import type { PRInfo } from '../../pr-analyzer';\nimport type { ReviewSummary } from '../../reviewer';\nimport type { VisorConfig, CheckConfig } from '../../types/config';\nimport {\n  buildProjectionFrom,\n  composeOnFinishContext,\n  evaluateOnFinishGoto,\n  recomputeAllValidFromHistory,\n} from './utils';\n\ntype RunCheckFn = (id: string) => Promise<ReviewSummary>;\n\nexport async function runOnFinishChildren(\n  runIds: string[],\n  runCheck: RunCheckFn,\n  config: VisorConfig,\n  onFinishContext: any,\n  debug: boolean,\n  log: (msg: string) => void\n): Promise<{ lastRunOutput?: unknown }> {\n  let lastRunOutput: unknown = undefined;\n  for (const id of runIds) {\n    if (debug) log(`üîß Debug: on_finish.run executing '${id}'`);\n    const res = await runCheck(id);\n    lastRunOutput = (res as any)?.output;\n    // Evaluate optional child on_success.run_js and run\n    try {\n      const childCfg = (config.checks || {})[id] as CheckConfig | undefined;\n      const childOnSuccess = childCfg?.on_success;\n      if (childOnSuccess) {\n        const vm = require('../../utils/sandbox');\n        const sandbox = vm.createSecureSandbox();\n        const scope = { ...onFinishContext, output: lastRunOutput } as any;\n        const code = `\n          const step = scope.step; const attempt = scope.attempt; const loop = scope.loop; const outputs = scope.outputs; const outputs_history = scope.outputs_history; const outputs_raw = scope.outputs_raw; const forEach = scope.forEach; const memory = scope.memory; const pr = scope.pr; const files = scope.files; const env = scope.env; const event = scope.event; const output = scope.output; const log = (...a)=> console.log('üîç Debug:',...a);\n          const __fn = () => {\\n${childOnSuccess.run_js || ''}\\n};\n          const __res = __fn();\n          return Array.isArray(__res) ? __res.filter(x => typeof x === 'string' && x) : [];\n        `;\n        const exec = sandbox.compile(code);\n        const dynamic = exec({ scope }).run();\n        const childRun = Array.from(\n          new Set([...(childOnSuccess.run || []), ...dynamic].filter(Boolean))\n        ) as string[];\n        for (const c of childRun) await runCheck(c);\n      }\n    } catch {}\n  }\n  return { lastRunOutput };\n}\n\nexport function decideRouting(\n  checkName: string,\n  checkConfig: CheckConfig,\n  outputsForContext: Record<string, unknown>,\n  outputsHistoryForContext: Record<string, unknown[]>,\n  forEachStats: { items: unknown[] },\n  prInfo: PRInfo,\n  config: VisorConfig,\n  debug: boolean,\n  log: (msg: string) => void\n): { gotoTarget: string | null } {\n  const ctx = composeOnFinishContext(\n    config?.memory,\n    checkName,\n    checkConfig,\n    outputsForContext,\n    outputsHistoryForContext,\n    { items: (forEachStats?.items || [])?.length ?? 0 },\n    prInfo\n  );\n  const onFinish = checkConfig.on_finish!;\n  let gotoTarget = evaluateOnFinishGoto(onFinish, ctx, debug, log);\n  // Gentle, config-informed fallback: If goto_js returned null but the\n  // configuration declares a finite retry budget (via a literal\n  // `const maxWaves = 1 + <N>` style), and last wave is not all-valid,\n  // suggest routing back to the parent exactly once per remaining budget.\n  if (!gotoTarget) {\n    try {\n      const js = String(onFinish.goto_js || '');\n      // Extract N from \"const maxWaves = 1 + N\" or \"maxWaves=1+N\" (common pattern in our configs/tests)\n      let n = NaN;\n      {\n        const m = js.match(/maxWaves\\s*=\\s*1\\s*\\+\\s*(\\d+)/);\n        if (m) n = Number(m[1]);\n      }\n      if (!Number.isFinite(n)) {\n        // Generic fallback: find any literal \"1 + <number>\"; take the last occurrence\n        const all = Array.from(js.matchAll(/1\\s*\\+\\s*(\\d+)/g));\n        if (all.length > 0) {\n          const last = all[all.length - 1];\n          const num = Number(last[1]);\n          if (Number.isFinite(num)) n = num;\n        }\n      }\n      const items = (ctx.forEach && (ctx.forEach as any).last_wave_size) || 0;\n      const vf = Array.isArray((ctx.outputs as any).history?.['validate-fact'])\n        ? ((ctx.outputs as any).history['validate-fact'] as unknown[]).filter(\n            (x: unknown) => !Array.isArray(x)\n          )\n        : [];\n      const waves = items > 0 ? Math.floor(vf.length / items) : 0;\n      const last = items > 0 ? vf.slice(-items) : [];\n      const allOk =\n        last.length === items &&\n        last.every((v: any) => v && (v.is_valid === true || v.valid === true));\n      if (!gotoTarget && !allOk && Number.isFinite(n) && n > 0 && waves < 1 + n) {\n        gotoTarget = checkName;\n        if (debug)\n          log(\n            `üîß Debug: decideRouting fallback ‚Üí '${checkName}' (waves=${waves} < maxWaves=${1 + n})`\n          );\n      }\n    } catch {}\n  }\n  return { gotoTarget };\n}\n\nexport function projectOutputs(\n  results: Map<string, ReviewSummary>,\n  historySnapshot: Record<string, unknown[]>\n): {\n  outputsForContext: Record<string, unknown>;\n  outputsHistoryForContext: Record<string, unknown[]>;\n} {\n  return buildProjectionFrom(results, historySnapshot);\n}\n\nexport function computeAllValid(\n  history: Record<string, unknown[]>,\n  itemsCount: number\n): boolean | undefined {\n  return recomputeAllValidFromHistory(history, itemsCount);\n}\n"],"mappings":"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","names":["initializeTracer","fs","context","triggeringComment","fs","path","agentAny","result","resolve","fs","path","content","lines","context","fs","path","emitNdjsonSpanWithEvents","SessionRegistry","context","context","exec","getGlobalRecorder","arr","fs","path","resolve","context","emitNdjsonSpanWithEvents","captureLiquidEvaluation","arr","buildSandboxEnv","context","key","context","context","context","buildSandboxEnv","resolve","resolve","fs","path","buildSandboxEnv","context","context","context","context","context","context","emitNdjsonSpanWithEvents","checkName","normalize","log","issues","exec","context","Liquid","context","checkConfig","forEachItems","context","context","context","Liquid","context","projectWorkflowToGraph","validateWorkflowDepth","StateMachineRunner","ExecutionJournal","MemoryStore","uuidv4","resolve","CheckExecutionEngine","fs","path","normalize","path","fs","path","status","path","resolve","log","compileAndRun","withIds","log","exec","last","buildSandboxEnv","global","context","log","exec","resolve","wave","depResults","fs","path","props","out","mode","tcfg","focus","createExtendedLiquid","emitMermaidFromMarkdown","checks","itemScope","agg","i","SessionRegistry","emitNdjsonSpanWithEvents"]}