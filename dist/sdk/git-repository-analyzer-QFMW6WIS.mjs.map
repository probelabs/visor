{"version":3,"sources":["../../src/utils/file-exclusion.ts","../../src/git-repository-analyzer.ts"],"sourcesContent":["import ignore from 'ignore';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n/**\n * Default exclusion patterns for common build artifacts and dependencies.\n * These can be overridden by providing custom patterns to the constructor.\n */\nconst DEFAULT_EXCLUSION_PATTERNS = [\n  'dist/',\n  'build/',\n  '.next/',\n  'out/',\n  'node_modules/',\n  'coverage/',\n  '.turbo/',\n  'bundled/',\n];\n\n/**\n * Shared utility for filtering files based on .gitignore patterns\n *\n * Design Decision: Synchronous I/O in Constructor\n * ------------------------------------------------\n * This class intentionally uses synchronous file I/O in the constructor for the following reasons:\n *\n * 1. **Initialization Context**: The constructor is called once during application startup,\n *    not in request handling or performance-critical paths.\n *\n * 2. **Small File Sizes**: .gitignore files are typically <10KB. Even in large monorepos,\n *    they rarely exceed 100KB. Reading such small files synchronously has negligible impact.\n *\n * 3. **Immediate Availability**: The exclusion patterns must be ready immediately for use.\n *    Asynchronous initialization would require either:\n *    - Async factory method (adds API complexity)\n *    - Lazy loading (race conditions, repeated checks)\n *    - Promise-based initialization (complicates usage across codebase)\n *\n * 4. **Simplicity**: Synchronous loading keeps the API simple and prevents async contagion\n *    throughout the codebase. Methods like shouldExcludeFile() remain synchronous.\n *\n * 5. **No DoS Risk**: The file reading happens exactly once per instance during construction.\n *    Attackers cannot trigger repeated synchronous reads.\n *\n * 6. **Consistency**: This follows the same pattern as other configuration loaders in Node.js\n *    ecosystem (e.g., require(), cosmiconfig's sync mode).\n *\n * Alternative Considered: Async factory pattern would add complexity without meaningful benefit\n * given the usage patterns and file sizes involved.\n */\nexport class FileExclusionHelper {\n  private gitignore: ReturnType<typeof ignore> | null = null;\n  private workingDirectory: string;\n\n  /**\n   * @param workingDirectory - Directory to search for .gitignore\n   * @param additionalPatterns - Additional patterns to include (optional, defaults to common build artifacts)\n   */\n  constructor(\n    workingDirectory: string = process.cwd(),\n    additionalPatterns: string[] | null = DEFAULT_EXCLUSION_PATTERNS\n  ) {\n    // Validate and normalize workingDirectory to prevent path traversal\n    const normalizedPath = path.resolve(workingDirectory);\n\n    // Ensure path doesn't contain suspicious patterns after normalization\n    // Check for null bytes which could be used for injection\n    if (normalizedPath.includes('\\0')) {\n      throw new Error('Invalid workingDirectory: contains null bytes');\n    }\n\n    this.workingDirectory = normalizedPath;\n\n    // Load gitignore synchronously during construction\n    // This is acceptable because:\n    // 1. Constructor is called once during initialization\n    // 2. .gitignore files are typically small (<10KB)\n    // 3. Synchronous loading ensures patterns are ready immediately\n    // 4. Avoids async constructor complexity\n    this.loadGitignore(additionalPatterns);\n  }\n\n  /**\n   * Load .gitignore patterns from the working directory (called once in constructor)\n   * @param additionalPatterns - Additional patterns to add to gitignore rules\n   */\n  private loadGitignore(additionalPatterns: string[] | null): void {\n    // Resolve both paths to absolute, normalized forms\n    const gitignorePath = path.resolve(this.workingDirectory, '.gitignore');\n    const resolvedWorkingDir = path.resolve(this.workingDirectory);\n\n    try {\n      // Robust path validation using path.relative()\n      // This handles symlinks and edge cases better than string comparison\n      const relativePath = path.relative(resolvedWorkingDir, gitignorePath);\n\n      // Security check: ensure .gitignore is within working directory\n      // Reject if:\n      // - Starts with '..' (parent directory)\n      // - Is an absolute path (should be relative after path.relative())\n      if (relativePath.startsWith('..') || path.isAbsolute(relativePath)) {\n        throw new Error('Invalid gitignore path: path traversal detected');\n      }\n\n      // Additionally verify it's exactly '.gitignore' (no subdirectories)\n      if (relativePath !== '.gitignore') {\n        throw new Error('Invalid gitignore path: must be .gitignore in working directory');\n      }\n\n      this.gitignore = ignore();\n\n      // Add additional patterns first (lower priority)\n      if (additionalPatterns && additionalPatterns.length > 0) {\n        this.gitignore.add(additionalPatterns);\n      }\n\n      // Load and add .gitignore patterns (higher priority)\n      if (fs.existsSync(gitignorePath)) {\n        const rawContent = fs.readFileSync(gitignorePath, 'utf8');\n\n        // Comprehensive sanitization to prevent injection attacks\n        const gitignoreContent = rawContent\n          .replace(/[\\r\\n]+/g, '\\n') // Normalize line endings first\n          .replace(/[\\x00-\\x09\\x0B-\\x1F\\x7F]/g, '') // Remove control chars except \\n (0x0A)\n          .split('\\n')\n          .filter(line => line.length < 1000) // Reject extremely long lines that could cause DoS\n          .join('\\n')\n          .trim();\n\n        this.gitignore.add(gitignoreContent);\n        if (process.env.VISOR_DEBUG === 'true') {\n          console.error('‚úÖ Loaded .gitignore patterns for file filtering');\n        }\n      } else if (additionalPatterns && additionalPatterns.length > 0) {\n        // Always emit a user-visible warning so callers can assert this behavior in tests\n        console.error('No .gitignore found, using default exclusion patterns');\n        console.warn('No .gitignore found, using default exclusion patterns');\n      }\n    } catch (error) {\n      // Always emit a warning with the error for visibility and tests\n      console.warn('Failed to load .gitignore:', error instanceof Error ? error.message : error);\n    }\n  }\n\n  /**\n   * Check if a file should be excluded based on .gitignore patterns\n   */\n  shouldExcludeFile(filename: string): boolean {\n    // Check against .gitignore patterns if loaded\n    if (this.gitignore) {\n      return this.gitignore.ignores(filename);\n    }\n\n    return false;\n  }\n}\n","import { simpleGit, SimpleGit, type DefaultLogFields, type ListLogLine } from 'simple-git';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport { PRInfo, PRDiff } from './pr-analyzer';\nimport { FileExclusionHelper } from './utils/file-exclusion';\n\nexport interface GitFileChange {\n  filename: string;\n  status: 'added' | 'removed' | 'modified' | 'renamed';\n  additions: number;\n  deletions: number;\n  changes: number;\n  content?: string;\n  patch?: string;\n  truncated?: boolean;\n}\n\n// Maximum patch size in bytes (50KB) - helps prevent token limit issues\nconst MAX_PATCH_SIZE = 50 * 1024;\n\nexport interface GitRepositoryInfo {\n  title: string;\n  body: string;\n  author: string;\n  base: string;\n  head: string;\n  files: GitFileChange[];\n  totalAdditions: number;\n  totalDeletions: number;\n  isGitRepository: boolean;\n  workingDirectory: string;\n}\n\nexport class GitRepositoryAnalyzer {\n  private git: SimpleGit;\n  private cwd: string;\n  private fileExclusionHelper: FileExclusionHelper;\n\n  constructor(workingDirectory: string = process.cwd()) {\n    this.cwd = workingDirectory;\n    this.git = simpleGit(workingDirectory);\n    this.fileExclusionHelper = new FileExclusionHelper(workingDirectory);\n  }\n\n  /**\n   * Analyze the current git repository state and return data compatible with PRInfo interface\n   */\n  async analyzeRepository(\n    includeContext: boolean = true,\n    enableBranchDiff: boolean = false\n  ): Promise<GitRepositoryInfo> {\n    // Check if we're in a git repository\n    const isRepo = await this.isGitRepository();\n    if (!isRepo) {\n      return this.createEmptyRepositoryInfo('Not a git repository');\n    }\n\n    try {\n      // Get current branch and status\n      const [status, currentBranch, baseBranch] = await Promise.all([\n        this.git.status(),\n        this.getCurrentBranch(),\n        this.getBaseBranch(),\n      ]);\n\n      // Determine if we're on a feature branch\n      const isFeatureBranch =\n        currentBranch !== baseBranch && currentBranch !== 'main' && currentBranch !== 'master';\n\n      // Get uncommitted changes first\n      let uncommittedFiles = await this.getUncommittedChanges(includeContext);\n\n      // If branch diff is explicitly enabled, use branch diff (ignoring uncommitted changes)\n      // Otherwise, if on a feature branch with no uncommitted changes AND branch diff is enabled, get diff vs base branch\n      if (isFeatureBranch && includeContext && enableBranchDiff) {\n        if (uncommittedFiles.length > 0) {\n          console.error(`üìä Feature branch detected: ${currentBranch}`);\n          console.error(\n            `‚ö†Ô∏è  Ignoring ${uncommittedFiles.length} uncommitted file(s) due to --analyze-branch-diff flag`\n          );\n        } else {\n          console.error(`üìä Feature branch detected: ${currentBranch}`);\n        }\n        console.error(\n          `üìÇ Analyzing diff vs ${baseBranch} (${uncommittedFiles.length > 0 ? 'forced by --analyze-branch-diff' : 'auto-enabled for code-review schemas'})`\n        );\n        uncommittedFiles = await this.getBranchDiff(baseBranch, includeContext);\n      } else if (uncommittedFiles.length > 0) {\n        console.error(`üìù Analyzing uncommitted changes (${uncommittedFiles.length} files)`);\n      }\n\n      // Get recent commit info (handle repos with no commits)\n      let lastCommit: (ListLogLine & DefaultLogFields) | null = null;\n      try {\n        const recentCommits = await this.git.log({ maxCount: 1 });\n        lastCommit = recentCommits.latest;\n      } catch {\n        // Repository has no commits yet - this is OK\n        console.error('üìù Repository has no commits yet, analyzing uncommitted changes');\n      }\n\n      // Get author from git config if no commits exist\n      let author = lastCommit?.author_name;\n      if (!author) {\n        try {\n          // Read ONLY repository-local config to avoid leaking global user identity into tests\n          const [userName, userEmail] = await Promise.all([\n            this.git.raw(['config', '--local', 'user.name']).catch(() => null),\n            this.git.raw(['config', '--local', 'user.email']).catch(() => null),\n          ]);\n          author = userName?.trim() || userEmail?.trim() || 'unknown';\n        } catch {\n          author = 'unknown';\n        }\n      }\n\n      // Create repository info\n      const repositoryInfo: GitRepositoryInfo = {\n        title: this.generateTitle(status, currentBranch),\n        body: this.generateDescription(status, lastCommit),\n        author,\n        base: baseBranch,\n        head: currentBranch,\n        files: uncommittedFiles,\n        totalAdditions: uncommittedFiles.reduce((sum, file) => sum + file.additions, 0),\n        totalDeletions: uncommittedFiles.reduce((sum, file) => sum + file.deletions, 0),\n        isGitRepository: true,\n        workingDirectory: this.cwd,\n      };\n\n      return repositoryInfo;\n    } catch (error) {\n      // Don't log the full error object to avoid confusing stack traces\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      console.error('Error analyzing git repository:', errorMessage);\n      return this.createEmptyRepositoryInfo('Error analyzing git repository');\n    }\n  }\n\n  /**\n   * Convert GitRepositoryInfo to PRInfo format for compatibility with existing PRReviewer\n   */\n  toPRInfo(repositoryInfo: GitRepositoryInfo, includeContext: boolean = true): PRInfo {\n    const files = repositoryInfo.files.map(\n      (file): PRDiff => ({\n        filename: file.filename,\n        additions: file.additions,\n        deletions: file.deletions,\n        changes: file.changes,\n        patch: includeContext ? file.patch : undefined,\n        status: file.status,\n      })\n    );\n\n    // Generate fullDiff from patches if includeContext is true\n    let fullDiff: string | undefined;\n    if (includeContext) {\n      fullDiff = files\n        .filter(file => file.patch)\n        .map(file => `--- ${file.filename}\\n${file.patch}`)\n        .join('\\n\\n');\n    }\n\n    return {\n      number: 0, // Local analysis doesn't have PR number\n      title: repositoryInfo.title,\n      body: repositoryInfo.body,\n      author: repositoryInfo.author,\n      base: repositoryInfo.base,\n      head: repositoryInfo.head,\n      files,\n      totalAdditions: repositoryInfo.totalAdditions,\n      totalDeletions: repositoryInfo.totalDeletions,\n      fullDiff,\n    };\n  }\n\n  private async isGitRepository(): Promise<boolean> {\n    try {\n      await this.git.checkIsRepo();\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  private async getCurrentBranch(): Promise<string> {\n    try {\n      const branchSummary = await this.git.branch();\n      return branchSummary.current || 'unknown';\n    } catch {\n      return 'unknown';\n    }\n  }\n\n  private async getBaseBranch(): Promise<string> {\n    try {\n      // Try to get the default branch from remote\n      const branches = await this.git.branch(['-r']);\n      const mainBranches = ['origin/main', 'origin/master', 'origin/develop'];\n\n      for (const mainBranch of mainBranches) {\n        if (branches.all.includes(mainBranch)) {\n          return mainBranch.replace('origin/', '');\n        }\n      }\n\n      // Fallback to main/master\n      return 'main';\n    } catch {\n      return 'main';\n    }\n  }\n\n  /**\n   * Truncate a patch if it exceeds MAX_PATCH_SIZE\n   */\n  private truncatePatch(patch: string, filename: string): { patch: string; truncated: boolean } {\n    const patchSize = Buffer.byteLength(patch, 'utf8');\n\n    if (patchSize <= MAX_PATCH_SIZE) {\n      return { patch, truncated: false };\n    }\n\n    // Truncate to MAX_PATCH_SIZE and add a notice\n    const truncated = patch.substring(0, MAX_PATCH_SIZE);\n    const truncatedPatch = `${truncated}\\n\\n... [TRUNCATED: Diff too large (${(patchSize / 1024).toFixed(1)}KB), showing first ${(MAX_PATCH_SIZE / 1024).toFixed(0)}KB] ...`;\n\n    console.error(\n      `‚ö†Ô∏è  Truncated diff for ${filename} (${(patchSize / 1024).toFixed(1)}KB ‚Üí ${(MAX_PATCH_SIZE / 1024).toFixed(0)}KB)`\n    );\n\n    return { patch: truncatedPatch, truncated: true };\n  }\n\n  private async getRemoteInfo(): Promise<{ name: string; url: string } | null> {\n    try {\n      const remotes = await this.git.getRemotes(true);\n      const origin = remotes.find(r => r.name === 'origin');\n      return origin\n        ? { name: origin.name, url: origin.refs.fetch || origin.refs.push || '' }\n        : null;\n    } catch {\n      return null;\n    }\n  }\n\n  private async getUncommittedChanges(includeContext: boolean = true): Promise<GitFileChange[]> {\n    try {\n      const status = await this.git.status();\n      const changes: GitFileChange[] = [];\n\n      // Process different types of changes\n      const fileChanges = [\n        ...status.created.map(f => ({ file: f, status: 'added' as const })),\n        ...status.deleted.map(f => ({ file: f, status: 'removed' as const })),\n        ...status.modified.map(f => ({ file: f, status: 'modified' as const })),\n        ...status.renamed.map(f => ({\n          file: typeof f === 'string' ? f : f.to || f.from,\n          status: 'renamed' as const,\n        })),\n      ];\n\n      for (const { file, status } of fileChanges) {\n        // Skip files that should be excluded from analysis\n        // FileExclusionHelper uses .gitignore patterns, which is sufficient\n        if (this.fileExclusionHelper.shouldExcludeFile(file)) {\n          console.error(`‚è≠Ô∏è  Skipping excluded file: ${file}`);\n          continue;\n        }\n\n        const filePath = path.join(this.cwd, file);\n        const fileChange = await this.analyzeFileChange(file, status, filePath, includeContext);\n        changes.push(fileChange);\n      }\n\n      return changes;\n    } catch (error) {\n      console.error('Error getting uncommitted changes:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Get diff between current branch and base branch (for feature branch analysis)\n   */\n  private async getBranchDiff(\n    baseBranch: string,\n    includeContext: boolean = true\n  ): Promise<GitFileChange[]> {\n    try {\n      // Get the list of changed files between base and current branch\n      const diffSummary = await this.git.diffSummary([baseBranch]);\n      const changes: GitFileChange[] = [];\n\n      if (!diffSummary || !diffSummary.files) {\n        return [];\n      }\n\n      for (const file of diffSummary.files) {\n        // Skip files that should be excluded from analysis\n        // FileExclusionHelper uses .gitignore patterns, which is sufficient\n        if (this.fileExclusionHelper.shouldExcludeFile(file.file)) {\n          console.error(`‚è≠Ô∏è  Skipping excluded file: ${file.file}`);\n          continue;\n        }\n\n        // Handle different file types (binary files don't have insertions/deletions)\n        const isBinary = 'binary' in file && file.binary;\n        const insertions = 'insertions' in file ? file.insertions : 0;\n        const deletions = 'deletions' in file ? file.deletions : 0;\n        const fileChanges = 'changes' in file ? file.changes : 0;\n\n        // Determine status based on insertions/deletions\n        let status: 'added' | 'removed' | 'modified' | 'renamed';\n        if (isBinary) {\n          status = 'modified';\n        } else if (insertions > 0 && deletions === 0) {\n          status = 'added';\n        } else if (insertions === 0 && deletions > 0) {\n          status = 'removed';\n        } else {\n          status = 'modified';\n        }\n\n        // Get the actual diff patch if needed\n        let patch: string | undefined;\n        let truncated = false;\n        if (includeContext && !isBinary) {\n          try {\n            const rawPatch = await this.git.diff([baseBranch, '--', file.file]);\n            if (rawPatch) {\n              const result = this.truncatePatch(rawPatch, file.file);\n              patch = result.patch;\n              truncated = result.truncated;\n            }\n          } catch {\n            // Ignore diff errors for specific files\n          }\n        }\n\n        const fileChange: GitFileChange = {\n          filename: file.file,\n          additions: insertions,\n          deletions: deletions,\n          changes: fileChanges,\n          status,\n          patch,\n          truncated,\n        };\n\n        changes.push(fileChange);\n      }\n\n      return changes;\n    } catch (error) {\n      console.error('Error getting branch diff:', error);\n      return [];\n    }\n  }\n\n  private async analyzeFileChange(\n    filename: string,\n    status: 'added' | 'removed' | 'modified' | 'renamed',\n    filePath: string,\n    includeContext: boolean = true\n  ): Promise<GitFileChange> {\n    let additions = 0;\n    let deletions = 0;\n    let patch: string | undefined;\n    let content: string | undefined;\n    let truncated = false;\n\n    try {\n      // Get diff for the file if it exists and is not binary\n      if (includeContext && status !== 'added' && fs.existsSync(filePath)) {\n        const diff = await this.git.diff(['--', filename]).catch(() => '');\n        if (diff) {\n          const result = this.truncatePatch(diff, filename);\n          patch = result.patch;\n          truncated = result.truncated;\n          // Count additions and deletions from diff\n          const lines = diff.split('\\n');\n          additions = lines.filter(line => line.startsWith('+')).length;\n          deletions = lines.filter(line => line.startsWith('-')).length;\n        }\n      } else if (status !== 'added' && fs.existsSync(filePath)) {\n        // If not including context, still count changes for statistics\n        const diff = await this.git.diff(['--', filename]).catch(() => '');\n        if (diff) {\n          const lines = diff.split('\\n');\n          additions = lines.filter(line => line.startsWith('+')).length;\n          deletions = lines.filter(line => line.startsWith('-')).length;\n        }\n      }\n\n      // For added files\n      if (status === 'added' && fs.existsSync(filePath)) {\n        try {\n          const stats = fs.statSync(filePath);\n          if (stats.isFile() && stats.size < 1024 * 1024) {\n            // Skip files larger than 1MB\n            if (includeContext) {\n              content = fs.readFileSync(filePath, 'utf8');\n              const result = this.truncatePatch(content, filename);\n              patch = result.patch; // For new files, the entire content is the \"patch\"\n              truncated = result.truncated;\n            }\n            // Always count additions for statistics\n            const fileContent = includeContext ? content : fs.readFileSync(filePath, 'utf8');\n            additions = fileContent!.split('\\n').length;\n          }\n        } catch {\n          // Skip binary or unreadable files\n        }\n      }\n\n      // For removed files, we can't easily count the lines without the previous version\n      if (status === 'removed') {\n        deletions = 1; // Placeholder - in real git we'd need the previous version\n      }\n    } catch (error) {\n      console.error(`Error analyzing file change for ${filename}:`, error);\n    }\n\n    return {\n      filename,\n      status,\n      additions,\n      deletions,\n      changes: additions + deletions,\n      content,\n      patch,\n      truncated,\n    };\n  }\n\n  private generateTitle(status: import('simple-git').StatusResult, branch: string): string {\n    if (status.files.length === 0) {\n      return `Local Analysis: ${branch} (No changes)`;\n    }\n\n    const changeTypes = [];\n    if (status.created.length > 0) changeTypes.push(`${status.created.length} added`);\n    if (status.modified.length > 0) changeTypes.push(`${status.modified.length} modified`);\n    if (status.deleted.length > 0) changeTypes.push(`${status.deleted.length} deleted`);\n    if (status.renamed.length > 0) changeTypes.push(`${status.renamed.length} renamed`);\n\n    return `Local Analysis: ${branch} (${changeTypes.join(', ')})`;\n  }\n\n  private generateDescription(\n    status: import('simple-git').StatusResult,\n    lastCommit: import('simple-git').DefaultLogFields | null\n  ): string {\n    let description = `Analysis of local git repository working directory.\\n\\n`;\n\n    if (lastCommit) {\n      description += `**Last Commit:** ${lastCommit.message}\\n`;\n      description += `**Author:** ${lastCommit.author_name} <${lastCommit.author_email}>\\n`;\n      description += `**Date:** ${lastCommit.date}\\n\\n`;\n    }\n\n    if (status.files.length === 0) {\n      description += `**Status:** Working directory is clean - no uncommitted changes found.\\n`;\n    } else {\n      description += `**Changes Summary:**\\n`;\n      description += `- Files to be committed: ${status.staged.length}\\n`;\n      description += `- Modified files: ${status.modified.length}\\n`;\n      description += `- Untracked files: ${status.not_added.length}\\n`;\n\n      if (status.conflicted.length > 0) {\n        description += `- Conflicted files: ${status.conflicted.length}\\n`;\n      }\n    }\n\n    return description;\n  }\n\n  private createEmptyRepositoryInfo(reason: string): GitRepositoryInfo {\n    return {\n      title: `Local Analysis: ${reason}`,\n      body: `Unable to analyze repository: ${reason}`,\n      author: 'system',\n      base: 'main',\n      head: 'HEAD',\n      files: [],\n      totalAdditions: 0,\n      totalDeletions: 0,\n      isGitRepository: false,\n      workingDirectory: this.cwd,\n    };\n  }\n}\n"],"mappings":"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","names":["path","fs","status"]}