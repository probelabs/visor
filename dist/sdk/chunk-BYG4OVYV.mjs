import {
  generateHumanId,
  init_human_id
} from "./chunk-KFKHU6CM.mjs";
import {
  SessionRegistry,
  init_session_registry,
  session_registry_exports
} from "./chunk-XXAEN5KU.mjs";
import {
  commandExecutor,
  init_command_executor
} from "./chunk-XDLQ3UNF.mjs";
import {
  DependencyResolver,
  WorkflowRegistry,
  init_dependency_resolver,
  init_workflow_registry
} from "./chunk-D5KI4YQ4.mjs";
import {
  config_exports,
  init_config
} from "./chunk-7YSOINAQ.mjs";
import {
  getPromptStateManager,
  init_prompt_state
} from "./chunk-6W75IMDC.mjs";
import {
  ExecutionJournal,
  checkLoopBudget,
  evaluateGoto,
  handleRouting,
  init_routing,
  init_snapshot_store,
  snapshot_store_exports
} from "./chunk-SGS2VMEL.mjs";
import {
  FailureConditionEvaluator,
  init_failure_condition_evaluator
} from "./chunk-N7HO6KKC.mjs";
import {
  addEvent,
  emitNdjsonFallback,
  emitNdjsonSpanWithEvents,
  fallback_ndjson_exports,
  init_fallback_ndjson,
  init_trace_helpers,
  setSpanAttributes,
  trace_helpers_exports,
  withActiveSpan
} from "./chunk-J5RGJQ53.mjs";
import {
  addDiagramBlock,
  init_metrics
} from "./chunk-XR7XXGL7.mjs";
import {
  createExtendedLiquid,
  init_liquid_extensions
} from "./chunk-R5Z7YWPB.mjs";
import {
  createPermissionHelpers,
  detectLocalMode,
  init_author_permissions,
  resolveAssociationFromEvent
} from "./chunk-25IC7KXZ.mjs";
import {
  compileAndRun,
  createSecureSandbox,
  init_sandbox
} from "./chunk-VF6XIUE4.mjs";
import {
  MemoryStore,
  init_memory_store,
  memory_store_exports
} from "./chunk-2KB35MB7.mjs";
import {
  init_logger,
  logger
} from "./chunk-PO7X5XI7.mjs";
import {
  context,
  init_lazy_otel,
  lazy_otel_exports,
  trace
} from "./chunk-HEX3RL32.mjs";
import {
  init_tracer_init,
  initializeTracer
} from "./chunk-B7BVQM5K.mjs";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-J7LXIPZS.mjs";

// src/providers/check-provider.interface.ts
var CheckProvider;
var init_check_provider_interface = __esm({
  "src/providers/check-provider.interface.ts"() {
    "use strict";
    CheckProvider = class {
    };
  }
});

// src/utils/diff-processor.ts
import { extract } from "@probelabs/probe";
import * as path from "path";
async function processDiffWithOutline(diffContent) {
  if (!diffContent || diffContent.trim().length === 0) {
    return diffContent;
  }
  try {
    const originalProbePath = process.env.PROBE_PATH;
    const fs10 = __require("fs");
    const possiblePaths = [
      // Relative to current working directory (most common in production)
      path.join(process.cwd(), "node_modules/@probelabs/probe/bin/probe-binary"),
      // Relative to __dirname (for unbundled development)
      path.join(__dirname, "../..", "node_modules/@probelabs/probe/bin/probe-binary"),
      // Relative to dist directory (for bundled CLI)
      path.join(__dirname, "node_modules/@probelabs/probe/bin/probe-binary")
    ];
    let probeBinaryPath;
    for (const candidatePath of possiblePaths) {
      if (fs10.existsSync(candidatePath)) {
        probeBinaryPath = candidatePath;
        break;
      }
    }
    if (!probeBinaryPath) {
      if (process.env.DEBUG === "1" || process.env.VERBOSE === "1") {
        console.error("Probe binary not found. Tried:", possiblePaths);
      }
      return diffContent;
    }
    process.env.PROBE_PATH = probeBinaryPath;
    const extractPromise = extract({
      content: diffContent,
      format: "outline-diff",
      allowTests: true
      // Allow test files and test code blocks in extraction results
    });
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error("Extract timeout after 30s")), 3e4);
    });
    const result = await Promise.race([extractPromise, timeoutPromise]);
    if (originalProbePath !== void 0) {
      process.env.PROBE_PATH = originalProbePath;
    } else {
      delete process.env.PROBE_PATH;
    }
    return typeof result === "string" ? result : JSON.stringify(result);
  } catch (error) {
    if (process.env.DEBUG === "1" || process.env.VERBOSE === "1") {
      console.error("Failed to process diff with outline-diff format:", error);
    }
    return diffContent;
  }
}
var init_diff_processor = __esm({
  "src/utils/diff-processor.ts"() {
    "use strict";
  }
});

// src/utils/comment-metadata.ts
function parseVisorThreadMetadata(commentBody) {
  const headerRe = /<!--\s*visor:thread=(\{[\s\S]*?\})\s*-->/m;
  const match = headerRe.exec(commentBody);
  if (!match) {
    return null;
  }
  try {
    const metadata = JSON.parse(match[1]);
    return metadata && typeof metadata === "object" && !Array.isArray(metadata) ? metadata : null;
  } catch {
    return null;
  }
}
function shouldFilterVisorReviewComment(commentBody) {
  if (!commentBody) {
    return false;
  }
  if (commentBody.includes("visor-comment-id:pr-review-")) {
    return true;
  }
  const metadata = parseVisorThreadMetadata(commentBody);
  if (metadata && metadata.group === "review") {
    return true;
  }
  return false;
}
var init_comment_metadata = __esm({
  "src/utils/comment-metadata.ts"() {
    "use strict";
  }
});

// src/ai-review-service.ts
import { ProbeAgent } from "@probelabs/probe";
function log(...args) {
  logger.debug(args.join(" "));
}
function createProbeTracerAdapter(fallbackTracer) {
  const fallback = fallbackTracer && typeof fallbackTracer === "object" ? fallbackTracer : null;
  const emitEvent = (name, attrs) => {
    try {
      const span = trace.getActiveSpan();
      if (span && typeof span.addEvent === "function") {
        span.addEvent(name, attrs);
      }
    } catch {
    }
  };
  return {
    withSpan: async (name, fn, attrs) => withActiveSpan(name, attrs, async (span) => {
      if (fallback && typeof fallback.withSpan === "function") {
        return await fallback.withSpan(name, async () => fn(span), attrs);
      }
      return await fn(span);
    }),
    recordEvent: (name, attrs) => {
      emitEvent(name, attrs);
      if (fallback && typeof fallback.recordEvent === "function") {
        try {
          fallback.recordEvent(name, attrs);
        } catch {
        }
      }
    },
    addEvent: (name, attrs) => {
      emitEvent(name, attrs);
      if (fallback && typeof fallback.addEvent === "function") {
        try {
          fallback.addEvent(name, attrs);
        } catch {
        }
      } else if (fallback && typeof fallback.recordEvent === "function") {
        try {
          fallback.recordEvent(name, attrs);
        } catch {
        }
      }
    },
    recordDelegationEvent: (phase, attrs) => {
      emitEvent(`delegation.${phase}`, attrs);
      if (fallback && typeof fallback.recordDelegationEvent === "function") {
        try {
          fallback.recordDelegationEvent(phase, attrs);
        } catch {
        }
      }
    },
    recordMermaidValidationEvent: (phase, attrs) => {
      emitEvent(`mermaid.${phase}`, attrs);
      if (fallback && typeof fallback.recordMermaidValidationEvent === "function") {
        try {
          fallback.recordMermaidValidationEvent(phase, attrs);
        } catch {
        }
      }
    },
    recordJsonValidationEvent: (phase, attrs) => {
      emitEvent(`json.${phase}`, attrs);
      if (fallback && typeof fallback.recordJsonValidationEvent === "function") {
        try {
          fallback.recordJsonValidationEvent(phase, attrs);
        } catch {
        }
      }
    },
    createDelegationSpan: (sessionId, task) => {
      let fallbackSpan = null;
      if (fallback && typeof fallback.createDelegationSpan === "function") {
        try {
          fallbackSpan = fallback.createDelegationSpan(sessionId, task);
        } catch {
        }
      }
      let span = null;
      try {
        const tracer = trace.getTracer("visor");
        span = tracer.startSpan("probe.delegation", {
          attributes: {
            "delegation.session_id": sessionId,
            "delegation.task": task
          }
        });
      } catch {
      }
      if (!span && fallbackSpan) return fallbackSpan;
      if (!span) return null;
      return {
        setAttributes: (attrs) => {
          try {
            if (attrs) span.setAttributes(attrs);
          } catch {
          }
          if (fallbackSpan && typeof fallbackSpan.setAttributes === "function") {
            try {
              fallbackSpan.setAttributes(attrs);
            } catch {
            }
          }
        },
        setStatus: (status) => {
          try {
            span.setStatus(status);
          } catch {
          }
          if (fallbackSpan && typeof fallbackSpan.setStatus === "function") {
            try {
              fallbackSpan.setStatus(status);
            } catch {
            }
          }
        },
        end: () => {
          try {
            span.end();
          } catch {
          }
          if (fallbackSpan && typeof fallbackSpan.end === "function") {
            try {
              fallbackSpan.end();
            } catch {
            }
          }
        }
      };
    },
    flush: async () => {
      if (fallback && typeof fallback.flush === "function") {
        await fallback.flush();
      }
    },
    shutdown: async () => {
      if (fallback && typeof fallback.shutdown === "function") {
        await fallback.shutdown();
      }
    }
  };
}
var AIReviewService;
var init_ai_review_service = __esm({
  "src/ai-review-service.ts"() {
    "use strict";
    init_session_registry();
    init_logger();
    init_lazy_otel();
    init_trace_helpers();
    init_tracer_init();
    init_diff_processor();
    init_comment_metadata();
    AIReviewService = class {
      config;
      sessionRegistry;
      constructor(config = {}) {
        this.config = {
          timeout: 18e5,
          // Increased timeout to 30 minutes for AI responses
          ...config
        };
        this.sessionRegistry = SessionRegistry.getInstance();
        if (typeof this.config.debug === "undefined") {
          try {
            if (process.env.VISOR_PROVIDER_DEBUG === "true" || process.env.VISOR_DEBUG === "true") {
              this.config.debug = true;
            }
          } catch {
          }
        }
        const providerExplicit = typeof this.config.provider === "string" && this.config.provider.length > 0;
        if (!providerExplicit) {
          if (!this.config.apiKey) {
            if (process.env.CLAUDE_CODE_API_KEY) {
              this.config.apiKey = process.env.CLAUDE_CODE_API_KEY;
              this.config.provider = "claude-code";
            } else if (process.env.GOOGLE_API_KEY) {
              this.config.apiKey = process.env.GOOGLE_API_KEY;
              this.config.provider = "google";
            } else if (process.env.ANTHROPIC_API_KEY) {
              this.config.apiKey = process.env.ANTHROPIC_API_KEY;
              this.config.provider = "anthropic";
            } else if (process.env.OPENAI_API_KEY) {
              this.config.apiKey = process.env.OPENAI_API_KEY;
              this.config.provider = "openai";
            } else if (
              // Check for AWS Bedrock credentials
              process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY || process.env.AWS_BEDROCK_API_KEY
            ) {
              this.config.provider = "bedrock";
              this.config.apiKey = "AWS_CREDENTIALS";
            }
          }
        }
        if (!this.config.model && process.env.MODEL_NAME) {
          this.config.model = process.env.MODEL_NAME;
        }
      }
      // NOTE: per request, no additional redaction/encryption helpers are used.
      /**
       * Execute AI review using probe agent
       */
      async executeReview(prInfo, customPrompt, schema, checkName, sessionId) {
        const startTime = Date.now();
        const timestamp = (/* @__PURE__ */ new Date()).toISOString();
        const cfgAny = this.config;
        const skipTransport = cfgAny?.skip_transport_context === true;
        const skipPRContext = cfgAny?.skip_code_context === true || skipTransport && cfgAny?.skip_code_context !== false;
        const skipSlackContext = cfgAny?.skip_slack_context === true || skipTransport && cfgAny?.skip_slack_context !== false;
        const prompt = await this.buildCustomPrompt(prInfo, customPrompt, schema, {
          skipPRContext,
          skipSlackContext
        });
        log(`Executing AI review with ${this.config.provider} provider...`);
        log(`\u{1F527} Debug: Raw schema parameter: ${JSON.stringify(schema)} (type: ${typeof schema})`);
        log(`Schema type: ${schema || "none (no schema)"}`);
        let debugInfo;
        if (this.config.debug) {
          debugInfo = {
            prompt,
            rawResponse: "",
            provider: this.config.provider || "unknown",
            model: this.config.model || "default",
            apiKeySource: this.getApiKeySource(),
            processingTime: 0,
            promptLength: prompt.length,
            responseLength: 0,
            errors: [],
            jsonParseSuccess: false,
            timestamp,
            schemaName: typeof schema === "object" ? "custom" : schema,
            schema: void 0
            // Will be populated when schema is loaded
          };
        }
        if (this.config.model === "mock" || this.config.provider === "mock") {
          log("\u{1F3AD} Using mock AI model/provider for testing - skipping API key validation");
        } else {
          if (!this.config.apiKey) {
            try {
              if (this.config.provider === "google" && process.env.GOOGLE_API_KEY) {
                this.config.apiKey = process.env.GOOGLE_API_KEY;
              } else if (this.config.provider === "anthropic" && process.env.ANTHROPIC_API_KEY) {
                this.config.apiKey = process.env.ANTHROPIC_API_KEY;
              } else if (this.config.provider === "openai" && process.env.OPENAI_API_KEY) {
                this.config.apiKey = process.env.OPENAI_API_KEY;
              } else if (this.config.provider === "claude-code" && process.env.CLAUDE_CODE_API_KEY) {
                this.config.apiKey = process.env.CLAUDE_CODE_API_KEY;
              }
            } catch {
            }
          }
          if (!this.config.apiKey) {
            log("\u26A0\uFE0F No API key configured - ProbeAgent will attempt CLI fallback (claude-code/codex)");
            if (debugInfo) {
              debugInfo.errors = debugInfo.errors || [];
              debugInfo.errors.push("No API key configured - attempting CLI fallback");
            }
          }
        }
        try {
          const call = this.callProbeAgent(prompt, schema, debugInfo, checkName, sessionId);
          const timeoutMs = Math.max(0, this.config.timeout || 0);
          const {
            response,
            effectiveSchema,
            sessionId: usedSessionId
          } = timeoutMs > 0 ? await this.withTimeout(call, timeoutMs, "AI review") : await call;
          const processingTime = Date.now() - startTime;
          if (debugInfo) {
            debugInfo.rawResponse = response;
            debugInfo.responseLength = response.length;
            debugInfo.processingTime = processingTime;
          }
          const result = this.parseAIResponse(response, debugInfo, effectiveSchema);
          try {
            result.sessionId = usedSessionId;
          } catch {
          }
          if (debugInfo) {
            result.debug = debugInfo;
          }
          return result;
        } catch (error) {
          if (debugInfo) {
            debugInfo.errors = [error instanceof Error ? error.message : String(error)];
            debugInfo.processingTime = Date.now() - startTime;
            return {
              issues: [
                {
                  file: "system",
                  line: 0,
                  ruleId: "system/ai-execution-error",
                  message: error instanceof Error ? error.message : String(error),
                  severity: "error",
                  category: "logic"
                }
              ],
              debug: debugInfo
            };
          }
          throw error;
        }
      }
      /**
       * Execute AI review using session reuse - reuses an existing ProbeAgent session
       * @param sessionMode - 'clone' (default) clones history, 'append' shares history
       */
      async executeReviewWithSessionReuse(prInfo, customPrompt, parentSessionId, schema, checkName, sessionMode = "clone") {
        const startTime = Date.now();
        const timestamp = (/* @__PURE__ */ new Date()).toISOString();
        if (!this.config.apiKey) {
          try {
            if (this.config.provider === "google" && process.env.GOOGLE_API_KEY) {
              this.config.apiKey = process.env.GOOGLE_API_KEY;
            } else if (this.config.provider === "anthropic" && process.env.ANTHROPIC_API_KEY) {
              this.config.apiKey = process.env.ANTHROPIC_API_KEY;
            } else if (this.config.provider === "openai" && process.env.OPENAI_API_KEY) {
              this.config.apiKey = process.env.OPENAI_API_KEY;
            } else if (this.config.provider === "claude-code" && process.env.CLAUDE_CODE_API_KEY) {
              this.config.apiKey = process.env.CLAUDE_CODE_API_KEY;
            }
          } catch {
          }
        }
        const existingAgent = this.sessionRegistry.getSession(parentSessionId);
        if (!existingAgent) {
          throw new Error(
            `Session not found for reuse: ${parentSessionId}. Ensure the parent check completed successfully.`
          );
        }
        const cfgAny = this.config;
        const skipTransport = cfgAny?.skip_transport_context === true;
        const skipSlackContext = cfgAny?.skip_slack_context === true || skipTransport && cfgAny?.skip_slack_context !== false;
        const prompt = await this.buildCustomPrompt(prInfo, customPrompt, schema, {
          // When reusing sessions we always skip PR context, regardless of flags
          skipPRContext: true,
          skipSlackContext
        });
        let agentToUse;
        let currentSessionId;
        if (sessionMode === "clone") {
          currentSessionId = `${checkName}-session-${Date.now()}`;
          log(
            `\u{1F4CB} Cloning AI session ${parentSessionId} \u2192 ${currentSessionId} for ${checkName} check...`
          );
          const clonedAgent = await this.sessionRegistry.cloneSession(
            parentSessionId,
            currentSessionId,
            checkName
            // Pass checkName for tracing
          );
          if (!clonedAgent) {
            throw new Error(`Failed to clone session ${parentSessionId}`);
          }
          agentToUse = clonedAgent;
        } else {
          log(`\u{1F504} Appending to AI session ${parentSessionId} (shared history)...`);
          agentToUse = existingAgent;
          currentSessionId = parentSessionId;
        }
        log(`\u{1F527} Debug: Raw schema parameter: ${JSON.stringify(schema)} (type: ${typeof schema})`);
        log(`\u{1F4CB} Schema for this check: ${schema || "none (no schema)"}`);
        if (sessionMode === "clone") {
          log(`\u2705 Cloned agent will use NEW schema (${schema}) - parent schema does not persist`);
          log(`\u{1F504} Clone operation ensures fresh agent with copied history but new configuration`);
        } else {
          log(`\u{1F504} Append mode - using existing agent instance with shared history and configuration`);
        }
        let debugInfo;
        if (this.config.debug) {
          debugInfo = {
            prompt,
            rawResponse: "",
            provider: this.config.provider || "unknown",
            model: this.config.model || "default",
            apiKeySource: this.getApiKeySource(),
            processingTime: 0,
            promptLength: prompt.length,
            responseLength: 0,
            errors: [],
            jsonParseSuccess: false,
            timestamp,
            schemaName: typeof schema === "object" ? "custom" : schema,
            schema: void 0
            // Will be populated when schema is loaded
          };
        }
        try {
          const call = this.callProbeAgentWithExistingSession(
            agentToUse,
            prompt,
            schema,
            debugInfo,
            checkName
          );
          const timeoutMs = Math.max(0, this.config.timeout || 0);
          const { response, effectiveSchema } = timeoutMs > 0 ? await this.withTimeout(call, timeoutMs, "AI review (session)") : await call;
          const processingTime = Date.now() - startTime;
          if (debugInfo) {
            debugInfo.rawResponse = response;
            debugInfo.responseLength = response.length;
            debugInfo.processingTime = processingTime;
          }
          const result = this.parseAIResponse(response, debugInfo, effectiveSchema);
          try {
            result.sessionId = currentSessionId;
          } catch {
          }
          if (debugInfo) {
            result.debug = debugInfo;
          }
          if (sessionMode === "clone" && currentSessionId !== parentSessionId) {
            result.sessionId = currentSessionId;
          }
          return result;
        } catch (error) {
          if (debugInfo) {
            debugInfo.errors = [error instanceof Error ? error.message : String(error)];
            debugInfo.processingTime = Date.now() - startTime;
            return {
              issues: [
                {
                  file: "system",
                  line: 0,
                  ruleId: "system/ai-session-reuse-error",
                  message: error instanceof Error ? error.message : String(error),
                  severity: "error",
                  category: "logic"
                }
              ],
              debug: debugInfo
            };
          }
          throw error;
        }
      }
      /**
       * Promise timeout helper that rejects after ms if unresolved
       */
      async withTimeout(p, ms, label = "operation") {
        let timer;
        try {
          const timeout = new Promise((_, reject) => {
            timer = setTimeout(() => reject(new Error(`${label} timed out after ${ms}ms`)), ms);
          });
          return await Promise.race([p, timeout]);
        } finally {
          if (timer) clearTimeout(timer);
        }
      }
      /**
       * Register a new AI session in the session registry
       */
      registerSession(sessionId, agent) {
        this.sessionRegistry.registerSession(sessionId, agent);
      }
      /**
       * Cleanup a session from the registry
       */
      cleanupSession(sessionId) {
        this.sessionRegistry.unregisterSession(sessionId);
      }
      /**
       * Build a custom prompt for AI review with XML-formatted data
       */
      async buildCustomPrompt(prInfo, customInstructions, schema, options) {
        const skipPRContext = options?.skipPRContext === true;
        const skipSlackContext = options?.skipSlackContext === true;
        const isCodeReviewSchema = schema === "code-review";
        const prContext = skipPRContext ? "" : await this.formatPRContext(prInfo, isCodeReviewSchema);
        const slackContextXml = skipSlackContext === true ? "" : this.formatSlackContextFromPRInfo(prInfo);
        const isIssue = prInfo.isIssue === true;
        if (isIssue) {
          if (skipPRContext && !slackContextXml) {
            return `<instructions>
${customInstructions}
</instructions>`;
          }
          return `<review_request>
  <instructions>
${customInstructions}
  </instructions>

  <context>
${prContext}${slackContextXml}
  </context>

  <rules>
    <rule>Understand the issue context and requirements from the XML data structure</rule>
    <rule>Provide helpful, actionable guidance based on the issue details</rule>
    <rule>Be constructive and supportive in your analysis</rule>
    <rule>Consider project conventions and patterns when making recommendations</rule>
    <rule>Suggest practical solutions or next steps that address the specific concern</rule>
    <rule>Focus on addressing the specific concern raised in the issue</rule>
    <rule>Reference relevant XML elements like metadata, description, labels, assignees when providing context</rule>
  </rules>
</review_request>`;
        }
        if (isCodeReviewSchema) {
          const analysisType = prInfo.isIncremental ? "INCREMENTAL" : "FULL";
          if (skipPRContext && !slackContextXml) {
            return `<instructions>
${customInstructions}
</instructions>

<reminder>
  <rule>The code context and diff were provided in the previous message</rule>
  <rule>Focus on the new analysis instructions above</rule>
  <rule>Only analyze code that appears with + (additions) or - (deletions) in the diff sections</rule>
  <rule>STRICT OUTPUT POLICY: Report only actual problems, risks, or deficiencies</rule>
  <rule>SEVERITY ASSIGNMENT: Assign severity ONLY to problems introduced or left unresolved by this change</rule>
</reminder>`;
          }
          return `<review_request>
  <analysis_type>${analysisType}</analysis_type>

  <analysis_focus>
    ${analysisType === "INCREMENTAL" ? "You are analyzing a NEW COMMIT added to an existing PR. Focus on the changes in the commit_diff section for this specific commit." : "You are analyzing the COMPLETE PR. Review all changes in the full_diff section."}
  </analysis_focus>

  <instructions>
${customInstructions}
  </instructions>

  <context>
${prContext}${slackContextXml}
  </context>

  <rules>
    <rule>Only analyze code that appears with + (additions) or - (deletions) in the diff sections</rule>
    <rule>Ignore unchanged code unless directly relevant to understanding a change</rule>
    <rule>Line numbers in your response should match actual file line numbers from the diff</rule>
    <rule>Focus on real issues, not nitpicks or cosmetic concerns</rule>
    <rule>Provide actionable, specific feedback with clear remediation steps</rule>
    <rule>For INCREMENTAL analysis, ONLY review changes in commit_diff section</rule>
    <rule>For FULL analysis, review all changes in full_diff section</rule>
    <rule>Reference specific XML elements like files_summary, metadata when providing context</rule>
    <rule>STRICT OUTPUT POLICY: Report only actual problems, risks, or deficiencies. Do not write praise, congratulations, or celebratory text. Do not create issues that merely restate improvements or say "no action needed".</rule>
    <rule>SEVERITY ASSIGNMENT: Assign severity ONLY to problems introduced or left unresolved by this change (critical/error/warning/info as appropriate). Do NOT create issue entries solely to acknowledge improvements; if no problems exist, return zero issues.</rule>
  </rules>
</review_request>`;
        }
        if (skipPRContext && !slackContextXml) {
          return `<instructions>
${customInstructions}
</instructions>`;
        }
        return `<instructions>
${customInstructions}
</instructions>

<context>
${prContext}${slackContextXml}
</context>`;
      }
      // REMOVED: Built-in prompts - only use custom prompts from .visor.yaml
      // REMOVED: getFocusInstructions - only use custom prompts from .visor.yaml
      /**
       * Format PR or Issue context for the AI using XML structure
       */
      async formatPRContext(prInfo, isCodeReviewSchema) {
        const prContextInfo = prInfo;
        const isIssue = prContextInfo.isIssue === true;
        const isPRContext = prContextInfo.isPRContext === true;
        const isSlackMode = prContextInfo.slackConversation !== void 0;
        let includeCodeContext;
        if (isPRContext) {
          includeCodeContext = true;
        } else if (isSlackMode) {
          includeCodeContext = prContextInfo.includeCodeContext === true;
        } else {
          includeCodeContext = prContextInfo.includeCodeContext !== false;
        }
        if (isPRContext) {
          log("\u{1F50D} Including full code diffs in AI context (PR mode)");
        } else if (isSlackMode && !includeCodeContext) {
          log("\u{1F4AC} Slack mode: excluding code diffs (use includeCodeContext: true to enable)");
        } else if (!includeCodeContext) {
          log("\u{1F4CA} Including only file summary in AI context (no diffs)");
        } else {
          log("\u{1F50D} Including code diffs in AI context");
        }
        if (isIssue) {
          let context3 = `<issue>
  <!-- Core issue metadata including identification, status, and timeline information -->
  <metadata>
    <number>${prInfo.number}</number>
    <title>${this.escapeXml(prInfo.title)}</title>
    <author>${prInfo.author}</author>
    <state>${prInfo.eventContext?.issue?.state || "open"}</state>
    <created_at>${prInfo.eventContext?.issue?.created_at || ""}</created_at>
    <updated_at>${prInfo.eventContext?.issue?.updated_at || ""}</updated_at>
    <comments_count>${prInfo.eventContext?.issue?.comments || 0}</comments_count>
  </metadata>`;
          if (prInfo.body) {
            context3 += `
  <!-- Full issue description and body text provided by the issue author -->
  <description>
${this.escapeXml(prInfo.body)}
  </description>`;
          }
          const eventContext = prInfo;
          const labels = eventContext.eventContext?.issue?.labels;
          if (labels && labels.length > 0) {
            context3 += `
  <!-- Applied labels for issue categorization and organization -->
  <labels>`;
            labels.forEach((label) => {
              const labelName = typeof label === "string" ? label : label.name || "unknown";
              context3 += `
    <label>${this.escapeXml(labelName)}</label>`;
            });
            context3 += `
  </labels>`;
          }
          const assignees = prInfo.eventContext?.issue?.assignees;
          if (assignees && assignees.length > 0) {
            context3 += `
  <!-- Users assigned to work on this issue -->
  <assignees>`;
            assignees.forEach((assignee) => {
              const assigneeName = typeof assignee === "string" ? assignee : assignee.login || "unknown";
              context3 += `
    <assignee>${this.escapeXml(assigneeName)}</assignee>`;
            });
            context3 += `
  </assignees>`;
          }
          const milestone = prInfo.eventContext?.issue?.milestone;
          if (milestone) {
            context3 += `
  <!-- Associated project milestone information -->
  <milestone>
    <title>${this.escapeXml(milestone.title || "")}</title>
    <state>${milestone.state || "open"}</state>
    <due_on>${milestone.due_on || ""}</due_on>
  </milestone>`;
          }
          const triggeringComment2 = prInfo.eventContext?.comment;
          if (triggeringComment2) {
            context3 += `
  <!-- The comment that triggered this analysis -->
  <triggering_comment>
    <author>${this.escapeXml(triggeringComment2.user?.login || "unknown")}</author>
    <created_at>${triggeringComment2.created_at || ""}</created_at>
    <body>${this.escapeXml(triggeringComment2.body || "")}</body>
  </triggering_comment>`;
          }
          const issueComments = prInfo.comments;
          if (issueComments && issueComments.length > 0) {
            let historicalComments = triggeringComment2 ? issueComments.filter((c) => c.id !== triggeringComment2.id) : issueComments;
            if (isCodeReviewSchema) {
              historicalComments = historicalComments.filter(
                (c) => !shouldFilterVisorReviewComment(c.body)
              );
            }
            if (historicalComments.length > 0) {
              context3 += `
  <!-- Previous comments in chronological order (excluding triggering comment) -->
  <comment_history>`;
              historicalComments.forEach((comment) => {
                context3 += `
    <comment>
      <author>${this.escapeXml(comment.author || "unknown")}</author>
      <created_at>${comment.createdAt || ""}</created_at>
      <body>${this.escapeXml(comment.body || "")}</body>
    </comment>`;
              });
              context3 += `
  </comment_history>`;
            }
          }
          context3 += `
</issue>`;
          return context3;
        }
        let context2 = `<pull_request>
  <!-- Core pull request metadata including identification, branches, and change statistics -->
  <metadata>
    <number>${prInfo.number}</number>
    <title>${this.escapeXml(prInfo.title)}</title>
    <author>${prInfo.author}</author>
    <base_branch>${prInfo.base}</base_branch>
    <target_branch>${prInfo.head}</target_branch>
    <total_additions>${prInfo.totalAdditions}</total_additions>
    <total_deletions>${prInfo.totalDeletions}</total_deletions>
    <files_changed_count>${prInfo.files.length}</files_changed_count>
  </metadata>`;
        try {
          const firstFile = (prInfo.files || [])[0];
          if (firstFile && firstFile.filename) {
            context2 += `
  <raw_diff_header>
${this.escapeXml(`diff --git a/${firstFile.filename} b/${firstFile.filename}`)}
  </raw_diff_header>`;
          }
        } catch {
        }
        if (prInfo.body) {
          context2 += `
  <!-- Full pull request description provided by the author -->
  <description>
${this.escapeXml(prInfo.body)}
  </description>`;
        }
        if (includeCodeContext) {
          if (prInfo.fullDiff) {
            const processedFullDiff = await processDiffWithOutline(prInfo.fullDiff);
            context2 += `
  <!-- Complete unified diff showing all changes in the pull request (processed with outline-diff) -->
  <full_diff>
${this.escapeXml(processedFullDiff)}
  </full_diff>`;
          }
          if (prInfo.isIncremental) {
            if (prInfo.commitDiff && prInfo.commitDiff.length > 0) {
              const processedCommitDiff = await processDiffWithOutline(prInfo.commitDiff);
              context2 += `
  <!-- Diff of only the latest commit for incremental analysis (processed with outline-diff) -->
  <commit_diff>
${this.escapeXml(processedCommitDiff)}
  </commit_diff>`;
            } else {
              const processedFallbackDiff = prInfo.fullDiff ? await processDiffWithOutline(prInfo.fullDiff) : "";
              context2 += `
  <!-- Commit diff could not be retrieved - falling back to full diff analysis (processed with outline-diff) -->
  <commit_diff>
${this.escapeXml(processedFallbackDiff)}
  </commit_diff>`;
            }
          }
        } else {
          context2 += `
  <!-- Code diffs excluded to reduce token usage (no code-review schema detected or disabled by flag) -->`;
        }
        if (prInfo.files.length > 0) {
          context2 += `
  <!-- Summary of all files changed with statistics -->
  <files_summary>`;
          prInfo.files.forEach((file) => {
            context2 += `
    <file>
      <filename>${this.escapeXml(file.filename)}</filename>
      <status>${file.status}</status>
      <additions>${file.additions}</additions>
      <deletions>${file.deletions}</deletions>
    </file>`;
          });
          context2 += `
  </files_summary>`;
        }
        const triggeringComment = prInfo.eventContext?.comment;
        if (triggeringComment) {
          context2 += `
  <!-- The comment that triggered this analysis -->
  <triggering_comment>
    <author>${this.escapeXml(triggeringComment.user?.login || "unknown")}</author>
    <created_at>${triggeringComment.created_at || ""}</created_at>
    <body>${this.escapeXml(triggeringComment.body || "")}</body>
  </triggering_comment>`;
        }
        const prComments = prInfo.comments;
        if (prComments && prComments.length > 0) {
          let historicalComments = triggeringComment ? prComments.filter((c) => c.id !== triggeringComment.id) : prComments;
          if (isCodeReviewSchema) {
            historicalComments = historicalComments.filter(
              (c) => !shouldFilterVisorReviewComment(c.body)
            );
          }
          if (historicalComments.length > 0) {
            context2 += `
  <!-- Previous PR comments in chronological order (excluding triggering comment) -->
  <comment_history>`;
            historicalComments.forEach((comment) => {
              context2 += `
    <comment>
      <author>${this.escapeXml(comment.author || "unknown")}</author>
      <created_at>${comment.createdAt || ""}</created_at>
      <body>${this.escapeXml(comment.body || "")}</body>
    </comment>`;
            });
            context2 += `
  </comment_history>`;
          }
        }
        context2 += `
</pull_request>`;
        return context2;
      }
      /**
       * Format Slack conversation context (if attached to PRInfo) as XML
       */
      formatSlackContextFromPRInfo(prInfo) {
        try {
          const anyInfo = prInfo;
          const conv = anyInfo.slackConversation;
          if (!conv || typeof conv !== "object") return "";
          const transport = conv.transport || "slack";
          const thread = conv.thread || {};
          const messages = Array.isArray(conv.messages) ? conv.messages : [];
          const current = conv.current || {};
          const attrs = conv.attributes || {};
          let xml = `
<slack_context>
  <transport>${this.escapeXml(String(transport))}</transport>
  <thread>
    <id>${this.escapeXml(String(thread.id || ""))}</id>
    <url>${this.escapeXml(String(thread.url || ""))}</url>
  </thread>`;
          const attrKeys = Object.keys(attrs);
          if (attrKeys.length > 0) {
            xml += `
  <attributes>`;
            for (const k of attrKeys) {
              const v = attrs[k];
              xml += `
    <attribute>
      <key>${this.escapeXml(String(k))}</key>
      <value>${this.escapeXml(String(v ?? ""))}</value>
    </attribute>`;
            }
            xml += `
  </attributes>`;
          }
          if (messages.length > 0) {
            xml += `
  <messages>`;
            for (const m of messages) {
              xml += `
    <message>
      <role>${this.escapeXml(String(m.role || "user"))}</role>
      <user>${this.escapeXml(String(m.user || ""))}</user>
      <text>${this.escapeXml(String(m.text || ""))}</text>
      <timestamp>${this.escapeXml(String(m.timestamp || ""))}</timestamp>
      <origin>${this.escapeXml(String(m.origin || ""))}</origin>
    </message>`;
            }
            xml += `
  </messages>`;
          }
          xml += `
  <current>
    <role>${this.escapeXml(String(current.role || "user"))}</role>
    <user>${this.escapeXml(String(current.user || ""))}</user>
    <text>${this.escapeXml(String(current.text || ""))}</text>
    <timestamp>${this.escapeXml(String(current.timestamp || ""))}</timestamp>
    <origin>${this.escapeXml(String(current.origin || ""))}</origin>
  </current>
</slack_context>`;
          return xml;
        } catch {
          return "";
        }
      }
      /**
       * Build a normalized ConversationContext for GitHub (PR/issue + comments)
       * using the same contract as Slack's ConversationContext. This is exposed
       * to templates via the unified `conversation` object.
       */
      buildGitHubConversationFromPRInfo(prInfo) {
        try {
          const anyInfo = prInfo;
          const eventCtx = anyInfo.eventContext || {};
          const comments = anyInfo.comments || [];
          const repoOwner = eventCtx.repository?.owner?.login || process.env.GITHUB_REPOSITORY?.split("/")?.[0];
          const repoName = eventCtx.repository?.name || process.env.GITHUB_REPOSITORY?.split("/")?.[1];
          const number = prInfo.number;
          const threadId = repoOwner && repoName ? `${repoOwner}/${repoName}#${number}` : `github#${number}`;
          const threadUrl = eventCtx.issue?.html_url || eventCtx.pull_request?.html_url || (repoOwner && repoName ? `https://github.com/${repoOwner}/${repoName}/pull/${number}` : void 0);
          const messages = [];
          if (prInfo.body && prInfo.body.trim().length > 0) {
            messages.push({
              role: "user",
              user: prInfo.author || "unknown",
              text: prInfo.body,
              timestamp: eventCtx.pull_request?.created_at || eventCtx.issue?.created_at || "",
              origin: "github"
            });
          }
          for (const c of comments) {
            messages.push({
              role: "user",
              user: c.author || "unknown",
              text: c.body || "",
              timestamp: c.createdAt || "",
              origin: "github"
            });
          }
          const triggeringComment = eventCtx.comment;
          let current;
          if (triggeringComment) {
            current = {
              role: "user",
              user: triggeringComment.user && triggeringComment.user.login || "unknown",
              text: triggeringComment.body || "",
              timestamp: triggeringComment.created_at || "",
              origin: "github"
            };
          } else if (messages.length > 0) {
            current = messages[messages.length - 1];
          } else {
            current = {
              role: "user",
              user: prInfo.author || "unknown",
              text: prInfo.title || "",
              timestamp: "",
              origin: "github"
            };
          }
          const attributes = {};
          if (repoOwner) attributes.owner = repoOwner;
          if (repoName) attributes.repo = repoName;
          attributes.number = String(number);
          if (eventCtx.event_name) attributes.event_name = String(eventCtx.event_name);
          if (eventCtx.action) attributes.action = String(eventCtx.action);
          const ctx = {
            transport: "github",
            thread: { id: threadId, url: threadUrl },
            messages,
            current,
            attributes
          };
          return ctx;
        } catch {
          return void 0;
        }
      }
      /**
       * No longer escaping XML - returning text as-is
       */
      escapeXml(text) {
        return text;
      }
      /**
       * Call ProbeAgent with an existing session
       */
      async callProbeAgentWithExistingSession(agent, prompt, schema, debugInfo, _checkName) {
        if (this.config.model === "mock" || this.config.provider === "mock") {
          log("\u{1F3AD} Using mock AI model/provider for testing (session reuse)");
          const response = await this.generateMockResponse(prompt, _checkName, schema);
          return { response, effectiveSchema: typeof schema === "object" ? "custom" : schema };
        }
        log("\u{1F504} Reusing existing ProbeAgent session for AI review...");
        log(`\u{1F4DD} Prompt length: ${prompt.length} characters`);
        log(`\u2699\uFE0F Model: ${this.config.model || "default"}, Provider: ${this.config.provider || "auto"}`);
        try {
          log("\u{1F680} Calling existing ProbeAgent with answer()...");
          let schemaString = void 0;
          let effectiveSchema = typeof schema === "object" ? "custom" : schema;
          if (schema && schema !== "plain") {
            try {
              schemaString = await this.loadSchemaContent(schema);
              log(`\u{1F4CB} Loaded schema content for: ${schema}`);
              log(`\u{1F4C4} Raw schema JSON:
${schemaString}`);
            } catch (error) {
              log(`\u26A0\uFE0F Failed to load schema ${schema}, proceeding without schema:`, error);
              schemaString = void 0;
              effectiveSchema = void 0;
              if (debugInfo && debugInfo.errors) {
                debugInfo.errors.push(`Failed to load schema: ${error}`);
              }
            }
          } else if (schema === "plain") {
            log(`\u{1F4CB} Using plain schema - no JSON validation will be applied`);
          }
          const schemaOptions = schemaString ? { schema: schemaString } : void 0;
          if (debugInfo && schemaOptions) {
            debugInfo.schema = JSON.stringify(schemaOptions, null, 2);
          }
          if (schemaOptions) {
            log(`\u{1F3AF} Schema options passed to ProbeAgent.answer() (session reuse):`);
            log(JSON.stringify(schemaOptions, null, 2));
          }
          if (process.env.VISOR_DEBUG_AI_SESSIONS === "true") {
            try {
              const fs10 = __require("fs");
              const path12 = __require("path");
              const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
              const provider = this.config.provider || "auto";
              const model = this.config.model || "default";
              let conversationHistory = [];
              try {
                const agentAny2 = agent;
                if (agentAny2.history) {
                  conversationHistory = agentAny2.history;
                } else if (agentAny2.messages) {
                  conversationHistory = agentAny2.messages;
                } else if (agentAny2._messages) {
                  conversationHistory = agentAny2._messages;
                }
              } catch {
              }
              const debugData = {
                timestamp,
                checkName: _checkName || "unknown",
                provider,
                model,
                schema: effectiveSchema,
                schemaOptions: schemaOptions || "none",
                sessionInfo: {
                  isSessionReuse: true,
                  historyMessageCount: conversationHistory.length
                },
                currentPromptLength: prompt.length,
                currentPrompt: prompt,
                conversationHistory
              };
              const debugJson = JSON.stringify(debugData, null, 2);
              let readableVersion = `=============================================================
`;
              readableVersion += `VISOR DEBUG REPORT - SESSION REUSE
`;
              readableVersion += `=============================================================
`;
              readableVersion += `Timestamp: ${timestamp}
`;
              readableVersion += `Check Name: ${_checkName || "unknown"}
`;
              readableVersion += `Provider: ${provider}
`;
              readableVersion += `Model: ${model}
`;
              readableVersion += `Schema: ${effectiveSchema}
`;
              readableVersion += `Schema Options: ${schemaOptions ? "provided" : "none"}
`;
              readableVersion += `History Messages: ${conversationHistory.length}
`;
              readableVersion += `=============================================================

`;
              if (schemaOptions) {
                readableVersion += `
${"=".repeat(60)}
`;
                readableVersion += `SCHEMA CONFIGURATION
`;
                readableVersion += `${"=".repeat(60)}
`;
                readableVersion += JSON.stringify(schemaOptions, null, 2);
                readableVersion += `
`;
              }
              if (conversationHistory.length > 0) {
                readableVersion += `
${"=".repeat(60)}
`;
                readableVersion += `CONVERSATION HISTORY (${conversationHistory.length} messages)
`;
                readableVersion += `${"=".repeat(60)}
`;
                conversationHistory.forEach((msg, index) => {
                  readableVersion += `
${"-".repeat(60)}
`;
                  readableVersion += `MESSAGE #${index + 1}
`;
                  readableVersion += `Role: ${msg.role || "unknown"}
`;
                  if (msg.content) {
                    const contentStr = typeof msg.content === "string" ? msg.content : JSON.stringify(msg.content, null, 2);
                    readableVersion += `Length: ${contentStr.length} characters
`;
                    readableVersion += `${"-".repeat(60)}
`;
                    readableVersion += `${contentStr}
`;
                  }
                });
              }
              readableVersion += `
${"=".repeat(60)}
`;
              readableVersion += `CURRENT PROMPT (NEW MESSAGE)
`;
              readableVersion += `${"=".repeat(60)}
`;
              readableVersion += `Length: ${prompt.length} characters
`;
              readableVersion += `${"-".repeat(60)}
`;
              readableVersion += `${prompt}
`;
              readableVersion += `
${"=".repeat(60)}
`;
              readableVersion += `END OF DEBUG REPORT
`;
              readableVersion += `${"=".repeat(60)}
`;
              const debugArtifactsDir = process.env.VISOR_DEBUG_ARTIFACTS || path12.join(process.cwd(), "debug-artifacts");
              if (!fs10.existsSync(debugArtifactsDir)) {
                fs10.mkdirSync(debugArtifactsDir, { recursive: true });
              }
              const debugFile = path12.join(
                debugArtifactsDir,
                `prompt-${_checkName || "unknown"}-${timestamp}.json`
              );
              fs10.writeFileSync(debugFile, debugJson, "utf-8");
              const readableFile = path12.join(
                debugArtifactsDir,
                `prompt-${_checkName || "unknown"}-${timestamp}.txt`
              );
              fs10.writeFileSync(readableFile, readableVersion, "utf-8");
              log(`
\u{1F4BE} Full debug info saved to:`);
              log(`   JSON: ${debugFile}`);
              log(`   TXT:  ${readableFile}`);
              log(`   - Includes: full conversation history, schema, current prompt`);
            } catch (error) {
              log(`\u26A0\uFE0F Could not save debug file: ${error}`);
            }
          }
          const agentAny = agent;
          agentAny.tracer = createProbeTracerAdapter(agentAny.tracer);
          let response;
          if (agentAny.tracer && typeof agentAny.tracer.withSpan === "function") {
            response = await agentAny.tracer.withSpan(
              "visor.ai_check_reuse",
              async () => {
                return await agent.answer(prompt, void 0, schemaOptions);
              },
              {
                "check.name": _checkName || "unknown",
                "check.mode": "session_reuse",
                "prompt.length": prompt.length,
                "schema.type": effectiveSchema || "none"
              }
            );
          } else {
            response = schemaOptions ? await agent.answer(prompt, void 0, schemaOptions) : await agent.answer(prompt);
          }
          log("\u2705 ProbeAgent session reuse completed successfully");
          log(`\u{1F4E4} Response length: ${response.length} characters`);
          if (process.env.VISOR_DEBUG_AI_SESSIONS === "true") {
            try {
              const fs10 = __require("fs");
              const path12 = __require("path");
              const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
              const agentAny2 = agent;
              let fullHistory = [];
              if (agentAny2.history) {
                fullHistory = agentAny2.history;
              } else if (agentAny2.messages) {
                fullHistory = agentAny2.messages;
              } else if (agentAny2._messages) {
                fullHistory = agentAny2._messages;
              }
              const debugArtifactsDir = process.env.VISOR_DEBUG_ARTIFACTS || path12.join(process.cwd(), "debug-artifacts");
              const sessionBase = path12.join(
                debugArtifactsDir,
                `session-${_checkName || "unknown"}-${timestamp}`
              );
              const sessionData = {
                timestamp,
                checkName: _checkName || "unknown",
                provider: this.config.provider || "auto",
                model: this.config.model || "default",
                schema: effectiveSchema,
                totalMessages: fullHistory.length
              };
              fs10.writeFileSync(sessionBase + ".json", JSON.stringify(sessionData, null, 2), "utf-8");
              let readable = `=============================================================
`;
              readable += `COMPLETE AI SESSION HISTORY (AFTER RESPONSE)
`;
              readable += `=============================================================
`;
              readable += `Timestamp: ${timestamp}
`;
              readable += `Check: ${_checkName || "unknown"}
`;
              readable += `Total Messages: ${fullHistory.length}
`;
              readable += `=============================================================

`;
              fullHistory.forEach((msg, idx) => {
                const role = msg.role || "unknown";
                const content = typeof msg.content === "string" ? msg.content : JSON.stringify(msg.content, null, 2);
                readable += `
${"=".repeat(60)}
MESSAGE ${idx + 1}/${fullHistory.length}
Role: ${role}
${"=".repeat(60)}
`;
                readable += content + "\n";
              });
              fs10.writeFileSync(sessionBase + ".summary.txt", readable, "utf-8");
              log(`\u{1F4BE} Complete session history saved:`);
              log(`   - Contains ALL ${fullHistory.length} messages (prompts + responses)`);
            } catch (error) {
              log(`\u26A0\uFE0F Could not save complete session history: ${error}`);
            }
          }
          if (process.env.VISOR_DEBUG_AI_SESSIONS === "true") {
            try {
              const fs10 = __require("fs");
              const path12 = __require("path");
              const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
              const debugArtifactsDir = process.env.VISOR_DEBUG_ARTIFACTS || path12.join(process.cwd(), "debug-artifacts");
              const responseFile = path12.join(
                debugArtifactsDir,
                `response-${_checkName || "unknown"}-${timestamp}.txt`
              );
              let responseContent = `=============================================================
`;
              responseContent += `VISOR AI RESPONSE - SESSION REUSE
`;
              responseContent += `=============================================================
`;
              responseContent += `Timestamp: ${timestamp}
`;
              responseContent += `Check Name: ${_checkName || "unknown"}
`;
              responseContent += `Response Length: ${response.length} characters
`;
              responseContent += `=============================================================

`;
              responseContent += `${"=".repeat(60)}
`;
              responseContent += `AI RESPONSE
`;
              responseContent += `${"=".repeat(60)}
`;
              responseContent += response;
              responseContent += `
${"=".repeat(60)}
`;
              responseContent += `END OF RESPONSE
`;
              responseContent += `${"=".repeat(60)}
`;
              fs10.writeFileSync(responseFile, responseContent, "utf-8");
              log(`\u{1F4BE} Response saved to: ${responseFile}`);
            } catch (error) {
              log(`\u26A0\uFE0F Could not save response file: ${error}`);
            }
          }
          if (agentAny._traceFilePath && agentAny._telemetryConfig) {
            try {
              if (agentAny.tracer && typeof agentAny.tracer.flush === "function") {
                await agentAny.tracer.flush();
                log(`\u{1F504} Flushed tracer spans for cloned session`);
              }
              if (agentAny._telemetryConfig && typeof agentAny._telemetryConfig.shutdown === "function") {
                await agentAny._telemetryConfig.shutdown();
                log(`\u{1F4CA} OpenTelemetry trace saved to: ${agentAny._traceFilePath}`);
                if (process.env.GITHUB_ACTIONS) {
                  const fs10 = __require("fs");
                  if (fs10.existsSync(agentAny._traceFilePath)) {
                    const stats = fs10.statSync(agentAny._traceFilePath);
                    console.log(
                      `::notice title=AI Trace Saved::${agentAny._traceFilePath} (${stats.size} bytes)`
                    );
                  }
                }
              } else if (agentAny.tracer && typeof agentAny.tracer.shutdown === "function") {
                await agentAny.tracer.shutdown();
                log(`\u{1F4CA} Trace saved to: ${agentAny._traceFilePath}`);
              }
            } catch (exportError) {
              logger.warn(`\u26A0\uFE0F  Warning: Failed to export trace for cloned session: ${exportError}`);
            }
          }
          return { response, effectiveSchema };
        } catch (error) {
          logger.error(
            `\u274C ProbeAgent session reuse failed: ${error instanceof Error ? error.message : "Unknown error"}`
          );
          throw new Error(
            `ProbeAgent session reuse failed: ${error instanceof Error ? error.message : "Unknown error"}`
          );
        }
      }
      /**
       * Call ProbeAgent SDK with built-in schema validation
       */
      async callProbeAgent(prompt, schema, debugInfo, _checkName, providedSessionId) {
        const sessionId = providedSessionId || (() => {
          const timestamp = (/* @__PURE__ */ new Date()).toISOString();
          return `visor-${timestamp.replace(/[:.]/g, "-")}-${_checkName || "unknown"}`;
        })();
        if (this.config.model === "mock" || this.config.provider === "mock") {
          const inJest = !!process.env.JEST_WORKER_ID;
          log("\u{1F3AD} Using mock AI model/provider");
          if (!inJest) {
            const response = await this.generateMockResponse(prompt, _checkName, schema);
            return {
              response,
              effectiveSchema: typeof schema === "object" ? "custom" : schema,
              sessionId
            };
          }
        }
        log("\u{1F916} Creating ProbeAgent for AI review...");
        log(`\u{1F194} Session ID: ${sessionId}`);
        log(`\u{1F4DD} Prompt length: ${prompt.length} characters`);
        log(`\u2699\uFE0F Model: ${this.config.model || "default"}, Provider: ${this.config.provider || "auto"}`);
        const originalEnv = {
          CLAUDE_CODE_API_KEY: process.env.CLAUDE_CODE_API_KEY,
          GOOGLE_API_KEY: process.env.GOOGLE_API_KEY,
          ANTHROPIC_API_KEY: process.env.ANTHROPIC_API_KEY,
          OPENAI_API_KEY: process.env.OPENAI_API_KEY
        };
        try {
          if (this.config.provider === "claude-code" && this.config.apiKey) {
            process.env.CLAUDE_CODE_API_KEY = this.config.apiKey;
            process.env.ANTHROPIC_API_KEY = this.config.apiKey;
          } else if (this.config.provider === "google" && this.config.apiKey) {
            process.env.GOOGLE_API_KEY = this.config.apiKey;
          } else if (this.config.provider === "anthropic" && this.config.apiKey) {
            process.env.ANTHROPIC_API_KEY = this.config.apiKey;
          } else if (this.config.provider === "openai" && this.config.apiKey) {
            process.env.OPENAI_API_KEY = this.config.apiKey;
          } else if (this.config.provider === "bedrock") {
          }
          const explicitPromptType = (process.env.VISOR_PROMPT_TYPE || "").trim();
          let systemPrompt = this.config.systemPrompt;
          if (!systemPrompt && schema !== "code-review") {
            systemPrompt = "You are general assistant, follow user instructions.";
          }
          const options = {
            sessionId,
            // Prefer config promptType, then env override, else fallback to code-review when schema is set
            promptType: this.config.promptType && this.config.promptType.trim() ? this.config.promptType.trim() : explicitPromptType ? explicitPromptType : schema === "code-review" ? "code-review-template" : void 0,
            allowEdit: false,
            // We don't want the agent to modify files
            debug: this.config.debug || false,
            // Use systemPrompt (native in rc168+) with fallback to customPrompt for backward compat
            systemPrompt: systemPrompt || this.config.systemPrompt || this.config.customPrompt
          };
          if (this.config.maxIterations !== void 0) {
            options.maxIterations = this.config.maxIterations;
          }
          let traceFilePath = "";
          let telemetryConfig = null;
          let probeFileTracer = null;
          if (this.config.debug) {
            const tracerResult = await initializeTracer(sessionId, _checkName);
            if (tracerResult) {
              probeFileTracer = tracerResult.tracer;
              telemetryConfig = tracerResult.telemetryConfig;
              traceFilePath = tracerResult.filePath;
            }
          }
          options.tracer = createProbeTracerAdapter(probeFileTracer);
          if (this.config.mcpServers && Object.keys(this.config.mcpServers).length > 0) {
            options.enableMcp = true;
            options.mcpConfig = { mcpServers: this.config.mcpServers };
          }
          if (this.config.enableDelegate !== void 0) {
            options.enableDelegate = this.config.enableDelegate;
          }
          if (this.config.enableTasks !== void 0) {
            options.enableTasks = this.config.enableTasks;
          }
          if (this.config.retry) {
            options.retry = this.config.retry;
          }
          if (this.config.fallback) {
            options.fallback = this.config.fallback;
          }
          if (this.config.allowEdit !== void 0) {
            options.allowEdit = this.config.allowEdit;
          }
          if (this.config.allowedTools !== void 0) {
            options.allowedTools = this.config.allowedTools;
            log(`\u{1F527} Setting allowedTools: ${JSON.stringify(this.config.allowedTools)}`);
          }
          if (this.config.disableTools !== void 0) {
            options.disableTools = this.config.disableTools;
            log(`\u{1F527} Setting disableTools: ${this.config.disableTools}`);
          }
          if (this.config.allowBash !== void 0) {
            options.enableBash = this.config.allowBash;
          }
          if (this.config.bashConfig !== void 0) {
            options.bashConfig = this.config.bashConfig;
          }
          if (this.config.completionPrompt !== void 0) {
            options.completionPrompt = this.config.completionPrompt;
          }
          try {
            const cfgAny = this.config;
            const allowedFolders = cfgAny.allowedFolders;
            const preferredPath = cfgAny.workspacePath || (Array.isArray(allowedFolders) && allowedFolders.length > 0 ? allowedFolders[0] : void 0) || cfgAny.path;
            if (Array.isArray(allowedFolders) && allowedFolders.length > 0) {
              options.allowedFolders = allowedFolders;
              if (!options.path && preferredPath) {
                options.path = preferredPath;
              }
              log(`\u{1F5C2}\uFE0F ProbeAgent workspace config:`);
              log(`   path (cwd): ${options.path}`);
              log(`   allowedFolders[0]: ${allowedFolders[0]}`);
            } else if (preferredPath) {
              options.path = preferredPath;
              log(`\u{1F5C2}\uFE0F ProbeAgent path: ${preferredPath} (no allowedFolders)`);
            }
          } catch {
          }
          if (this.config.provider) {
            const providerOverride = this.config.provider === "claude-code" || this.config.provider === "bedrock" ? "anthropic" : this.config.provider === "anthropic" || this.config.provider === "openai" || this.config.provider === "google" ? this.config.provider : void 0;
            if (providerOverride) {
              options.provider = providerOverride;
            }
          }
          if (this.config.model) {
            options.model = this.config.model;
          }
          const agent = new ProbeAgent(options);
          if (typeof agent.initialize === "function") {
            await agent.initialize();
          }
          log("\u{1F680} Calling ProbeAgent...");
          let schemaString = void 0;
          let effectiveSchema = typeof schema === "object" ? "custom" : schema;
          if (schema && schema !== "plain") {
            try {
              schemaString = await this.loadSchemaContent(schema);
              log(`\u{1F4CB} Loaded schema content for: ${schema}`);
              log(`\u{1F4C4} Raw schema JSON:
${schemaString}`);
            } catch (error) {
              log(`\u26A0\uFE0F Failed to load schema ${schema}, proceeding without schema:`, error);
              schemaString = void 0;
              effectiveSchema = void 0;
              if (debugInfo && debugInfo.errors) {
                debugInfo.errors.push(`Failed to load schema: ${error}`);
              }
            }
          } else if (schema === "plain") {
            log(`\u{1F4CB} Using plain schema - no JSON validation will be applied`);
          }
          const schemaOptions = schemaString ? { schema: schemaString } : void 0;
          if (debugInfo && schemaOptions) {
            debugInfo.schema = JSON.stringify(schemaOptions, null, 2);
          }
          if (schemaOptions) {
            log(`\u{1F3AF} Schema options passed to ProbeAgent.answer():`);
            log(JSON.stringify(schemaOptions, null, 2));
          }
          const provider = this.config.provider || "auto";
          const model = this.config.model || "default";
          if (process.env.VISOR_DEBUG_AI_SESSIONS === "true") {
            try {
              const fs10 = __require("fs");
              const path12 = __require("path");
              const os = __require("os");
              const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
              const debugData = {
                timestamp,
                checkName: _checkName || "unknown",
                provider,
                model,
                schema: effectiveSchema,
                schemaOptions: schemaOptions || "none",
                sessionInfo: {
                  isSessionReuse: false,
                  isNewSession: true
                },
                promptLength: prompt.length,
                prompt
              };
              const debugJson = JSON.stringify(debugData, null, 2);
              let readableVersion = `=============================================================
`;
              readableVersion += `VISOR DEBUG REPORT - NEW SESSION
`;
              readableVersion += `=============================================================
`;
              readableVersion += `Timestamp: ${timestamp}
`;
              readableVersion += `Check Name: ${_checkName || "unknown"}
`;
              readableVersion += `Provider: ${provider}
`;
              readableVersion += `Model: ${model}
`;
              readableVersion += `Schema: ${effectiveSchema}
`;
              readableVersion += `Schema Options: ${schemaOptions ? "provided" : "none"}
`;
              readableVersion += `Session Type: New Session (no history)
`;
              readableVersion += `=============================================================

`;
              if (schemaOptions) {
                readableVersion += `
${"=".repeat(60)}
`;
                readableVersion += `SCHEMA CONFIGURATION
`;
                readableVersion += `${"=".repeat(60)}
`;
                readableVersion += JSON.stringify(schemaOptions, null, 2);
                readableVersion += `
`;
              }
              readableVersion += `
${"=".repeat(60)}
`;
              readableVersion += `PROMPT
`;
              readableVersion += `${"=".repeat(60)}
`;
              readableVersion += `Length: ${prompt.length} characters
`;
              readableVersion += `${"-".repeat(60)}
`;
              readableVersion += `${prompt}
`;
              readableVersion += `
${"=".repeat(60)}
`;
              readableVersion += `END OF DEBUG REPORT
`;
              readableVersion += `${"=".repeat(60)}
`;
              const tempDir = os.tmpdir();
              const promptFile = path12.join(tempDir, `visor-prompt-${timestamp}.txt`);
              fs10.writeFileSync(promptFile, prompt, "utf-8");
              log(`
\u{1F4BE} Prompt saved to: ${promptFile}`);
              const debugArtifactsDir = process.env.VISOR_DEBUG_ARTIFACTS || path12.join(process.cwd(), "debug-artifacts");
              try {
                const base = path12.join(
                  debugArtifactsDir,
                  `prompt-${_checkName || "unknown"}-${timestamp}`
                );
                fs10.writeFileSync(base + ".json", debugJson, "utf-8");
                fs10.writeFileSync(base + ".summary.txt", readableVersion, "utf-8");
                log(`
\u{1F4BE} Full debug info saved to directory: ${debugArtifactsDir}`);
              } catch {
              }
              log(`
\u{1F4DD} To reproduce locally, run:`);
              let cliCommand = `npx @probelabs/probe@latest agent`;
              cliCommand += ` --provider ${provider}`;
              if (model !== "default") {
                cliCommand += ` --model ${model}`;
              }
              if (schema) {
                cliCommand += ` --schema output/${schema}/schema.json`;
              }
              cliCommand += ` "${promptFile}"`;
              log(`
$ ${cliCommand}
`);
            } catch (error) {
              log(`\u26A0\uFE0F Could not save prompt file: ${error}`);
            }
          }
          let response;
          const tracer = options.tracer;
          if (tracer && typeof tracer.withSpan === "function") {
            response = await tracer.withSpan(
              "visor.ai_check",
              async () => {
                return await agent.answer(prompt, void 0, schemaOptions);
              },
              {
                "check.name": _checkName || "unknown",
                "check.session_id": sessionId,
                "prompt.length": prompt.length,
                "schema.type": effectiveSchema || "none"
              }
            );
          } else {
            response = schemaOptions ? await agent.answer(prompt, void 0, schemaOptions) : await agent.answer(prompt);
          }
          log("\u2705 ProbeAgent completed successfully");
          log(`\u{1F4E4} Response length: ${response.length} characters`);
          if (process.env.VISOR_DEBUG_AI_SESSIONS === "true") {
            try {
              const fs10 = __require("fs");
              const path12 = __require("path");
              const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
              const agentAny = agent;
              let fullHistory = [];
              if (agentAny.history) {
                fullHistory = agentAny.history;
              } else if (agentAny.messages) {
                fullHistory = agentAny.messages;
              } else if (agentAny._messages) {
                fullHistory = agentAny._messages;
              }
              const debugArtifactsDir = process.env.VISOR_DEBUG_ARTIFACTS || path12.join(process.cwd(), "debug-artifacts");
              const sessionBase = path12.join(
                debugArtifactsDir,
                `session-${_checkName || "unknown"}-${timestamp}`
              );
              const sessionData = {
                timestamp,
                checkName: _checkName || "unknown",
                provider: this.config.provider || "auto",
                model: this.config.model || "default",
                schema: effectiveSchema,
                totalMessages: fullHistory.length
              };
              fs10.writeFileSync(sessionBase + ".json", JSON.stringify(sessionData, null, 2), "utf-8");
              let readable = `=============================================================
`;
              readable += `COMPLETE AI SESSION HISTORY (AFTER RESPONSE)
`;
              readable += `=============================================================
`;
              readable += `Timestamp: ${timestamp}
`;
              readable += `Check: ${_checkName || "unknown"}
`;
              readable += `Total Messages: ${fullHistory.length}
`;
              readable += `=============================================================

`;
              fullHistory.forEach((msg, idx) => {
                const role = msg.role || "unknown";
                const content = typeof msg.content === "string" ? msg.content : JSON.stringify(msg.content, null, 2);
                readable += `
${"=".repeat(60)}
MESSAGE ${idx + 1}/${fullHistory.length}
Role: ${role}
${"=".repeat(60)}
`;
                readable += content + "\n";
              });
              fs10.writeFileSync(sessionBase + ".summary.txt", readable, "utf-8");
              log(`\u{1F4BE} Complete session history saved:`);
              log(`   - Contains ALL ${fullHistory.length} messages (prompts + responses)`);
            } catch (error) {
              log(`\u26A0\uFE0F Could not save complete session history: ${error}`);
            }
          }
          if (process.env.VISOR_DEBUG_AI_SESSIONS === "true") {
            try {
              const fs10 = __require("fs");
              const path12 = __require("path");
              const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
              const debugArtifactsDir = process.env.VISOR_DEBUG_ARTIFACTS || path12.join(process.cwd(), "debug-artifacts");
              const responseFile = path12.join(
                debugArtifactsDir,
                `response-${_checkName || "unknown"}-${timestamp}.txt`
              );
              let responseContent = `=============================================================
`;
              responseContent += `VISOR AI RESPONSE - NEW SESSION
`;
              responseContent += `=============================================================
`;
              responseContent += `Timestamp: ${timestamp}
`;
              responseContent += `Check Name: ${_checkName || "unknown"}
`;
              responseContent += `Response Length: ${response.length} characters
`;
              responseContent += `=============================================================

`;
              responseContent += `${"=".repeat(60)}
`;
              responseContent += `AI RESPONSE
`;
              responseContent += `${"=".repeat(60)}
`;
              responseContent += response;
              responseContent += `
${"=".repeat(60)}
`;
              responseContent += `END OF RESPONSE
`;
              responseContent += `${"=".repeat(60)}
`;
              fs10.writeFileSync(responseFile, responseContent, "utf-8");
              log(`\u{1F4BE} Response saved to: ${responseFile}`);
            } catch (error) {
              log(`\u26A0\uFE0F Could not save response file: ${error}`);
            }
          }
          if (traceFilePath && telemetryConfig) {
            try {
              const telemetry = telemetryConfig;
              const tracerWithMethods = tracer;
              if (tracerWithMethods && typeof tracerWithMethods.flush === "function") {
                await tracerWithMethods.flush();
                log(`\u{1F504} Flushed tracer spans`);
              }
              if (telemetry && typeof telemetry.shutdown === "function") {
                await telemetry.shutdown();
                log(`\u{1F4CA} OpenTelemetry trace saved to: ${traceFilePath}`);
                if (process.env.GITHUB_ACTIONS) {
                  const fs10 = __require("fs");
                  if (fs10.existsSync(traceFilePath)) {
                    const stats = fs10.statSync(traceFilePath);
                    console.log(
                      `::notice title=AI Trace Saved::OpenTelemetry trace file size: ${stats.size} bytes`
                    );
                  }
                }
              } else if (tracerWithMethods && typeof tracerWithMethods.shutdown === "function") {
                await tracerWithMethods.shutdown();
                log(`\u{1F4CA} Trace saved to: ${traceFilePath}`);
              }
            } catch (exportError) {
              logger.warn(`\u26A0\uFE0F  Warning: Failed to export trace: ${exportError}`);
            }
          }
          if (_checkName) {
            this.registerSession(sessionId, agent);
            log(`\u{1F527} Debug: Registered AI session for potential reuse: ${sessionId}`);
          }
          return { response, effectiveSchema, sessionId };
        } catch (error) {
          console.error("\u274C ProbeAgent failed:", error);
          throw new Error(
            `ProbeAgent execution failed: ${error instanceof Error ? error.message : "Unknown error"}`
          );
        } finally {
          Object.keys(originalEnv).forEach((key) => {
            if (originalEnv[key] === void 0) {
              delete process.env[key];
            } else {
              process.env[key] = originalEnv[key];
            }
          });
        }
      }
      /**
       * Load schema content from schema files or inline definitions
       */
      async loadSchemaContent(schema) {
        const fs10 = __require("fs").promises;
        const path12 = __require("path");
        if (typeof schema === "object" && schema !== null) {
          log("\u{1F4CB} Using inline schema object from configuration");
          return JSON.stringify(schema);
        }
        try {
          const parsed = JSON.parse(schema);
          if (typeof parsed === "object" && parsed !== null) {
            log("\u{1F4CB} Using inline schema JSON string");
            return schema;
          }
        } catch {
        }
        if ((schema.startsWith("./") || schema.includes(".json")) && !path12.isAbsolute(schema)) {
          if (schema.includes("..") || schema.includes("\0")) {
            throw new Error("Invalid schema path: path traversal not allowed");
          }
          try {
            const schemaPath = path12.resolve(process.cwd(), schema);
            log(`\u{1F4CB} Loading custom schema from file: ${schemaPath}`);
            const schemaContent = await fs10.readFile(schemaPath, "utf-8");
            return schemaContent.trim();
          } catch (error) {
            throw new Error(
              `Failed to load custom schema from ${schema}: ${error instanceof Error ? error.message : "Unknown error"}`
            );
          }
        }
        const sanitizedSchemaName = schema.replace(/[^a-zA-Z0-9-]/g, "");
        if (!sanitizedSchemaName || sanitizedSchemaName !== schema) {
          throw new Error("Invalid schema name");
        }
        const candidatePaths = [
          // GitHub Action bundle location
          path12.join(__dirname, "output", sanitizedSchemaName, "schema.json"),
          // Historical fallback when src/output was inadvertently bundled as output1/
          path12.join(__dirname, "output1", sanitizedSchemaName, "schema.json"),
          // Local dev (repo root)
          path12.join(process.cwd(), "output", sanitizedSchemaName, "schema.json")
        ];
        for (const schemaPath of candidatePaths) {
          try {
            const schemaContent = await fs10.readFile(schemaPath, "utf-8");
            return schemaContent.trim();
          } catch {
          }
        }
        const distPath = path12.join(__dirname, "output", sanitizedSchemaName, "schema.json");
        const distAltPath = path12.join(__dirname, "output1", sanitizedSchemaName, "schema.json");
        const cwdPath = path12.join(process.cwd(), "output", sanitizedSchemaName, "schema.json");
        throw new Error(
          `Failed to load schema '${sanitizedSchemaName}'. Tried: ${distPath}, ${distAltPath}, and ${cwdPath}. Ensure build copies 'output/' into dist (build:cli), or provide a custom schema file/path.`
        );
      }
      /**
       * Parse AI response JSON
       */
      parseAIResponse(response, debugInfo, _schema) {
        log("\u{1F50D} Parsing AI response...");
        log(`\u{1F4CA} Raw response length: ${response.length} characters`);
        if (response.length > 400) {
          log("\u{1F4CB} Response preview (first 200 chars):", response.substring(0, 200));
          log("\u{1F4CB} Response preview (last 200 chars):", response.substring(response.length - 200));
        } else {
          log("\u{1F4CB} Full response preview:", response);
        }
        try {
          let reviewData;
          if (_schema === "plain" || !_schema) {
            log(
              `\u{1F4CB} ${_schema === "plain" ? "Plain" : "No"} schema detected - treating raw response as text output`
            );
            const trimmed = typeof response === "string" ? response.trim() : "";
            const out = trimmed ? { text: trimmed } : {};
            return {
              issues: [],
              // Expose assistant-style content via output.text so downstream formatters
              // (Slack frontend, CLI "Assistant Response" section, templates) can render it.
              output: out,
              debug: debugInfo
            };
          }
          {
            log("\u{1F50D} Extracting JSON from AI response...");
            const sanitizedResponse = response.replace(/^\uFEFF/, "").replace(/[\u200B-\u200D\uFEFF\u00A0]/g, "").replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, "").trim();
            try {
              reviewData = JSON.parse(sanitizedResponse);
              log("\u2705 Successfully parsed direct JSON response");
              if (debugInfo) debugInfo.jsonParseSuccess = true;
            } catch (parseErr) {
              const errMsg = parseErr instanceof Error ? parseErr.message : String(parseErr);
              log(`\u{1F50D} Direct JSON parsing failed: ${errMsg}`);
              if (response.toLowerCase().includes("i cannot") || response.toLowerCase().includes("unable to")) {
                console.error("\u{1F6AB} AI refused to analyze - returning refusal as output");
                const trimmed2 = response.trim();
                return {
                  issues: [],
                  output: trimmed2 ? { text: trimmed2 } : {},
                  debug: debugInfo
                };
              }
              log("\u{1F527} Treating response as plain text (no JSON extraction)");
              const trimmed = response.trim();
              return {
                issues: [],
                output: { text: trimmed },
                debug: debugInfo
              };
            }
          }
          const looksLikeTextOutput = reviewData && typeof reviewData === "object" && typeof reviewData.text === "string" && String(reviewData.text).trim().length > 0;
          const isCustomSchema = _schema === "custom" || _schema && (_schema.startsWith("./") || _schema.endsWith(".json")) || _schema && _schema !== "code-review" && !_schema.includes("output/") || !_schema && looksLikeTextOutput;
          const _debugSchemaLogging = this.config.debug === true || process.env.VISOR_DEBUG_AI_SESSIONS === "true";
          if (_debugSchemaLogging) {
            const details = {
              schema: _schema,
              isCustomSchema,
              isCustomLiteral: _schema === "custom",
              startsWithDotSlash: typeof _schema === "string" ? _schema.startsWith("./") : false,
              endsWithJson: typeof _schema === "string" ? _schema.endsWith(".json") : false,
              notCodeReview: _schema !== "code-review",
              noOutputPrefix: typeof _schema === "string" ? !_schema.includes("output/") : false
            };
            try {
              log(`\u{1F50D} Schema detection: ${JSON.stringify(details)}`);
            } catch {
              log(
                `\u{1F50D} Schema detection: _schema="${String(_schema)}", isCustomSchema=${isCustomSchema}`
              );
            }
          }
          if (isCustomSchema) {
            log("\u{1F4CB} Custom schema detected - preserving all fields from parsed JSON");
            log(`\u{1F4CA} Schema: ${_schema}`);
            try {
              log(`\u{1F4CA} Custom schema keys: ${Object.keys(reviewData).join(", ")}`);
            } catch {
            }
            const out = reviewData && typeof reviewData === "object" ? reviewData : {};
            const hasText = typeof out.text === "string" && String(out.text).trim().length > 0;
            if (!hasText) {
              let fallbackText = "";
              try {
                if (Array.isArray(reviewData?.issues) && reviewData.issues.length > 0) {
                  fallbackText = reviewData.issues.map((i) => i && (i.message || i.text || i.response)).filter((s) => typeof s === "string" && s.trim().length > 0).join("\n");
                }
              } catch {
              }
              if (!fallbackText && typeof response === "string" && response.trim()) {
                fallbackText = response.trim().slice(0, 6e4);
              }
              if (fallbackText) {
                out.text = fallbackText;
              }
            }
            const result2 = {
              // Keep issues empty for custom-schema rendering; consumers read from output.*
              issues: [],
              output: out
            };
            log(
              "\u2705 Successfully created ReviewSummary with custom schema output (with fallback text when needed)"
            );
            return result2;
          }
          log("\u{1F50D} Validating parsed review data...");
          log(`\u{1F4CA} Overall score: ${0}`);
          log(`\u{1F4CB} Total issues: ${reviewData.issues?.length || 0}`);
          log(
            `\u{1F6A8} Critical issues: ${reviewData.issues?.filter((i) => i.severity === "critical").length || 0}`
          );
          log(`\u{1F4AC} Comments count: ${Array.isArray(reviewData.issues) ? reviewData.issues.length : 0}`);
          const processedIssues = Array.isArray(reviewData.issues) ? reviewData.issues.map((issue, index) => {
            log(`\u{1F50D} Processing issue ${index + 1}:`, issue);
            return {
              file: issue.file || "unknown",
              line: issue.line || 1,
              endLine: issue.endLine,
              ruleId: issue.ruleId || `${issue.category || "general"}/unknown`,
              message: issue.message || "",
              severity: issue.severity,
              category: issue.category,
              suggestion: issue.suggestion,
              replacement: issue.replacement
            };
          }) : [];
          const result = {
            issues: processedIssues
          };
          const criticalCount = (result.issues || []).filter((i) => i.severity === "critical").length;
          if (criticalCount > 0) {
            log(`\u{1F6A8} Found ${criticalCount} critical severity issue(s)`);
          }
          log(`\u{1F4C8} Total issues: ${(result.issues || []).length}`);
          log("\u2705 Successfully created ReviewSummary");
          return result;
        } catch (error) {
          const detailed = this.config.debug === true || process.env.VISOR_DEBUG_AI_SESSIONS === "true";
          const message = error instanceof Error ? error.message : String(error);
          if (detailed) {
            logger.debug(`\u274C Failed to parse AI response: ${message}`);
            logger.debug("\u{1F4C4} FULL RAW RESPONSE:");
            logger.debug("=".repeat(80));
            logger.debug(response);
            logger.debug("=".repeat(80));
            logger.debug(`\u{1F4CF} Response length: ${response.length} characters`);
            if (error instanceof SyntaxError) {
              logger.debug("\u{1F50D} JSON parsing error - the response may not be valid JSON");
              logger.debug(`\u{1F50D} Error details: ${error.message}`);
              const errorMatch = error.message.match(/position (\d+)/);
              if (errorMatch) {
                const position = parseInt(errorMatch[1]);
                logger.debug(`\u{1F50D} Error at position ${position}:`);
                const start = Math.max(0, position - 50);
                const end = Math.min(response.length, position + 50);
                logger.debug(`\u{1F50D} Context: "${response.substring(start, end)}"`);
                logger.debug(`\u{1F50D} Response beginning: "${response.substring(0, 100)}"`);
              }
              if (response.includes("I cannot")) {
                logger.debug("\u{1F50D} Response appears to be a refusal/explanation rather than JSON");
              }
              if (response.includes("```")) {
                logger.debug("\u{1F50D} Response appears to contain markdown code blocks");
              }
              if (response.startsWith("<")) {
                logger.debug("\u{1F50D} Response appears to start with XML/HTML");
              }
            }
          } else {
            logger.error(`\u274C Failed to parse AI response: ${message}`);
          }
          throw new Error(
            `Invalid AI response format: ${error instanceof Error ? error.message : "Unknown error"}`
          );
        }
      }
      /**
       * Generate mock response for testing
       */
      async generateMockResponse(_prompt, _checkName, _schema) {
        await new Promise((resolve5) => setTimeout(resolve5, 500));
        const name = (_checkName || "").toLowerCase();
        if (name.includes("extract-facts")) {
          const arr = Array.from({ length: 6 }, (_, i) => ({
            id: `fact-${i + 1}`,
            category: "Feature",
            claim: `claim-${i + 1}`,
            verifiable: true,
            refs: [{ path: "src/check-execution-engine.ts", lines: "6400-6460" }]
          }));
          return JSON.stringify(arr);
        }
        if (name.includes("validate-fact")) {
          const idMatch = _prompt.match(/Fact ID:\s*([\w\-]+)/i);
          const claimMatch = _prompt.match(/\*\*Claim:\*\*\s*(.+)/i);
          const attemptMatch = _prompt.match(/Attempt:\s*(\d+)/i);
          const factId = idMatch ? idMatch[1] : "fact-1";
          const claim = claimMatch ? claimMatch[1].trim() : "unknown-claim";
          const n = Number(factId.split("-")[1] || "0");
          const attempt = attemptMatch ? Number(attemptMatch[1]) : 0;
          const isValid = attempt >= 1 ? true : !(n >= 1 && n <= 3);
          return JSON.stringify({
            fact_id: factId,
            claim,
            is_valid: isValid,
            confidence: "high",
            evidence: isValid ? "verified" : "not found",
            correction: isValid ? null : `correct ${claim}`
          });
        }
        if (name.includes("issue-assistant") || name.includes("comment-assistant")) {
          const text = "### Assistant Reply";
          const intent = name.includes("issue") ? "issue_triage" : "comment_reply";
          return JSON.stringify({ text, intent });
        }
        const mockResponse = { content: JSON.stringify({ issues: [], summary: { totalIssues: 0 } }) };
        return JSON.stringify(mockResponse);
      }
      /**
       * Get the API key source for debugging (without revealing the key)
       */
      getApiKeySource() {
        if (process.env.CLAUDE_CODE_API_KEY && this.config.provider === "claude-code") {
          return "CLAUDE_CODE_API_KEY";
        }
        if (process.env.GOOGLE_API_KEY && this.config.provider === "google") {
          return "GOOGLE_API_KEY";
        }
        if (process.env.ANTHROPIC_API_KEY && this.config.provider === "anthropic") {
          return "ANTHROPIC_API_KEY";
        }
        if (process.env.OPENAI_API_KEY && this.config.provider === "openai") {
          return "OPENAI_API_KEY";
        }
        if (this.config.provider === "bedrock") {
          if (process.env.AWS_BEDROCK_API_KEY) {
            return "AWS_BEDROCK_API_KEY";
          }
          if (process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY) {
            return "AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY";
          }
        }
        return "unknown";
      }
    };
  }
});

// src/utils/env-resolver.ts
var EnvironmentResolver;
var init_env_resolver = __esm({
  "src/utils/env-resolver.ts"() {
    "use strict";
    EnvironmentResolver = class {
      /**
       * Resolves a single configuration value that may contain environment variable references
       */
      static resolveValue(value) {
        if (typeof value !== "string") {
          return value;
        }
        let resolved = value.replace(/\$\{\{\s*env\.([A-Z_][A-Z0-9_]*)\s*\}\}/g, (match, envVar) => {
          return process.env[envVar] || match;
        });
        resolved = resolved.replace(/\$\{([A-Z_][A-Z0-9_]*)\}/g, (match, envVar) => {
          return process.env[envVar] || match;
        });
        resolved = resolved.replace(/\$([A-Z_][A-Z0-9_]*)/g, (match, envVar) => {
          return process.env[envVar] || match;
        });
        return resolved;
      }
      /**
       * Resolves all environment variables in an EnvConfig object
       */
      static resolveEnvConfig(envConfig) {
        const resolved = {};
        for (const [key, value] of Object.entries(envConfig)) {
          resolved[key] = this.resolveValue(value);
        }
        return resolved;
      }
      /**
       * Applies environment configuration to the process environment
       * This allows checks to access their specific environment variables
       */
      static applyEnvConfig(envConfig) {
        const resolved = this.resolveEnvConfig(envConfig);
        for (const [key, value] of Object.entries(resolved)) {
          if (value !== void 0) {
            process.env[key] = String(value);
          }
        }
      }
      /**
       * Creates a temporary environment for a specific check execution
       * Returns a cleanup function to restore the original environment
       */
      static withTemporaryEnv(envConfig, callback) {
        const resolved = this.resolveEnvConfig(envConfig);
        const originalValues = {};
        for (const [key, value] of Object.entries(resolved)) {
          originalValues[key] = process.env[key];
          if (value !== void 0) {
            process.env[key] = String(value);
          }
        }
        try {
          const result = callback();
          if (result instanceof Promise) {
            return result.finally(() => {
              for (const [key, originalValue] of Object.entries(originalValues)) {
                if (originalValue === void 0) {
                  delete process.env[key];
                } else {
                  process.env[key] = originalValue;
                }
              }
            });
          }
          for (const [key, originalValue] of Object.entries(originalValues)) {
            if (originalValue === void 0) {
              delete process.env[key];
            } else {
              process.env[key] = originalValue;
            }
          }
          return result;
        } catch (error) {
          for (const [key, originalValue] of Object.entries(originalValues)) {
            if (originalValue === void 0) {
              delete process.env[key];
            } else {
              process.env[key] = originalValue;
            }
          }
          throw error;
        }
      }
      /**
       * Validates that all required environment variables are available
       */
      static validateRequiredEnvVars(envConfig, requiredVars) {
        const resolved = this.resolveEnvConfig(envConfig);
        const missing = [];
        for (const varName of requiredVars) {
          const value = resolved[varName] || process.env[varName];
          if (!value) {
            missing.push(varName);
          }
        }
        return missing;
      }
      /**
       * Resolves environment variables in HTTP headers
       * Each header value is processed through resolveValue to replace env var references
       */
      static resolveHeaders(headers) {
        const resolved = {};
        for (const [key, value] of Object.entries(headers)) {
          resolved[key] = String(this.resolveValue(value));
        }
        return resolved;
      }
      /**
       * Sanitizes headers for logging/telemetry by redacting sensitive values
       * Headers like Authorization, API keys, and cookies are replaced with [REDACTED]
       */
      static sanitizeHeaders(headers) {
        const sensitiveHeaders = ["authorization", "x-api-key", "cookie", "set-cookie"];
        const sanitized = {};
        for (const [key, value] of Object.entries(headers)) {
          if (sensitiveHeaders.includes(key.toLowerCase())) {
            sanitized[key] = "[REDACTED]";
          } else {
            sanitized[key] = value;
          }
        }
        return sanitized;
      }
    };
  }
});

// src/issue-filter.ts
var issue_filter_exports = {};
__export(issue_filter_exports, {
  IssueFilter: () => IssueFilter
});
import * as fs from "fs";
import * as path2 from "path";
var IssueFilter;
var init_issue_filter = __esm({
  "src/issue-filter.ts"() {
    "use strict";
    IssueFilter = class {
      fileCache = /* @__PURE__ */ new Map();
      suppressionEnabled;
      constructor(suppressionEnabled = true) {
        this.suppressionEnabled = suppressionEnabled;
      }
      /**
       * Filter out issues that have suppression comments
       * @param issues Array of issues to filter
       * @param workingDir Working directory for resolving file paths
       * @returns Filtered array of issues with suppressed ones removed
       */
      filterIssues(issues, workingDir = process.cwd()) {
        if (!this.suppressionEnabled || !issues || issues.length === 0) {
          return issues;
        }
        const filteredIssues = [];
        const suppressedCount = {};
        for (const issue of issues) {
          if (this.shouldSuppressIssue(issue, workingDir)) {
            suppressedCount[issue.file] = (suppressedCount[issue.file] || 0) + 1;
          } else {
            filteredIssues.push(issue);
          }
        }
        const totalSuppressed = Object.values(suppressedCount).reduce((sum, count) => sum + count, 0);
        if (totalSuppressed > 0) {
          console.log(`\u{1F507} Suppressed ${totalSuppressed} issue(s) via visor-disable comments:`);
          for (const [file, count] of Object.entries(suppressedCount)) {
            console.log(`   - ${file}: ${count} issue(s)`);
          }
        }
        return filteredIssues;
      }
      /**
       * Check if an issue should be suppressed based on comments in the file
       */
      shouldSuppressIssue(issue, workingDir) {
        if (!issue.file || issue.file === "system" || issue.file === "webhook" || issue.line === 0) {
          return false;
        }
        const lines = this.getFileLines(issue.file, workingDir);
        if (!lines || lines.length === 0) {
          return false;
        }
        const firstFiveLines = lines.slice(0, 5).join("\n").toLowerCase();
        if (firstFiveLines.includes("visor-disable-file")) {
          return true;
        }
        const lineIndex = issue.line - 1;
        const startLine = Math.max(0, lineIndex - 2);
        const endLine = Math.min(lines.length - 1, lineIndex + 2);
        for (let i = startLine; i <= endLine; i++) {
          if (lines[i].toLowerCase().includes("visor-disable")) {
            return true;
          }
        }
        return false;
      }
      /**
       * Get file lines from cache or read from disk
       */
      getFileLines(filePath, workingDir) {
        if (this.fileCache.has(filePath)) {
          return this.fileCache.get(filePath);
        }
        try {
          const resolvedPath = path2.isAbsolute(filePath) ? filePath : path2.join(workingDir, filePath);
          if (!fs.existsSync(resolvedPath)) {
            if (fs.existsSync(filePath)) {
              const content2 = fs.readFileSync(filePath, "utf8");
              const lines2 = content2.split("\n");
              this.fileCache.set(filePath, lines2);
              return lines2;
            }
            return null;
          }
          const content = fs.readFileSync(resolvedPath, "utf8");
          const lines = content.split("\n");
          this.fileCache.set(filePath, lines);
          return lines;
        } catch {
          return null;
        }
      }
      /**
       * Clear the file cache (useful for testing or long-running processes)
       */
      clearCache() {
        this.fileCache.clear();
      }
    };
  }
});

// src/telemetry/state-capture.ts
var state_capture_exports = {};
__export(state_capture_exports, {
  captureCheckInputContext: () => captureCheckInputContext,
  captureCheckOutput: () => captureCheckOutput,
  captureConditionalEvaluation: () => captureConditionalEvaluation,
  captureForEachState: () => captureForEachState,
  captureLiquidEvaluation: () => captureLiquidEvaluation,
  captureProviderCall: () => captureProviderCall,
  captureRoutingDecision: () => captureRoutingDecision,
  captureStateSnapshot: () => captureStateSnapshot,
  captureTransformJS: () => captureTransformJS,
  sanitizeContextForTelemetry: () => sanitizeContextForTelemetry
});
function isSensitiveEnvVar(name) {
  return SENSITIVE_ENV_PATTERNS.some((pattern) => pattern.test(name));
}
function sanitizeContextForTelemetry(context2) {
  if (!context2 || typeof context2 !== "object") return context2;
  const sanitized = { ...context2 };
  if (sanitized.env && typeof sanitized.env === "object") {
    const sanitizedEnv = {};
    for (const [key, value] of Object.entries(sanitized.env)) {
      if (isSensitiveEnvVar(key)) {
        sanitizedEnv[key] = "[REDACTED]";
      } else {
        sanitizedEnv[key] = String(value);
      }
    }
    sanitized.env = sanitizedEnv;
  }
  return sanitized;
}
function safeSerialize(value, maxLength = MAX_ATTRIBUTE_LENGTH) {
  try {
    if (value === void 0 || value === null) return String(value);
    const seen = /* @__PURE__ */ new WeakSet();
    const json = JSON.stringify(value, (key, val) => {
      if (typeof val === "object" && val !== null) {
        if (seen.has(val)) return "[Circular]";
        seen.add(val);
      }
      if (typeof val === "string" && val.length > maxLength) {
        return val.substring(0, maxLength) + "...[truncated]";
      }
      return val;
    });
    if (json.length > maxLength) {
      return json.substring(0, maxLength) + "...[truncated]";
    }
    return json;
  } catch (err) {
    return `[Error serializing: ${err instanceof Error ? err.message : String(err)}]`;
  }
}
function captureCheckInputContext(span, context2) {
  try {
    const sanitizedContext = sanitizeContextForTelemetry(context2);
    const keys = Object.keys(sanitizedContext);
    span.setAttribute("visor.check.input.keys", keys.join(","));
    span.setAttribute("visor.check.input.count", keys.length);
    span.setAttribute("visor.check.input.context", safeSerialize(sanitizedContext));
    if (sanitizedContext.pr) {
      span.setAttribute("visor.check.input.pr", safeSerialize(sanitizedContext.pr, 1e3));
    }
    if (sanitizedContext.outputs) {
      span.setAttribute("visor.check.input.outputs", safeSerialize(sanitizedContext.outputs, 5e3));
    }
    if (sanitizedContext.env) {
      span.setAttribute(
        "visor.check.input.env_keys",
        Object.keys(sanitizedContext.env).join(",")
      );
    }
  } catch (err) {
    try {
      span.setAttribute("visor.check.input.error", String(err));
    } catch {
    }
  }
}
function captureCheckOutput(span, output) {
  try {
    span.setAttribute("visor.check.output.type", typeof output);
    if (Array.isArray(output)) {
      span.setAttribute("visor.check.output.length", output.length);
      const preview = output.slice(0, 10);
      span.setAttribute("visor.check.output.preview", safeSerialize(preview, 2e3));
    }
    span.setAttribute("visor.check.output", safeSerialize(output));
  } catch (err) {
    try {
      span.setAttribute("visor.check.output.error", String(err));
    } catch {
    }
  }
}
function captureForEachState(span, items, index, currentItem) {
  try {
    span.setAttribute("visor.foreach.total", items.length);
    span.setAttribute("visor.foreach.index", index);
    span.setAttribute("visor.foreach.current_item", safeSerialize(currentItem, 500));
    if (items.length <= MAX_ARRAY_ITEMS) {
      span.setAttribute("visor.foreach.items", safeSerialize(items));
    } else {
      span.setAttribute(
        "visor.foreach.items.preview",
        safeSerialize(items.slice(0, MAX_ARRAY_ITEMS))
      );
      span.setAttribute("visor.foreach.items.truncated", true);
    }
  } catch (err) {
    span.setAttribute("visor.foreach.error", String(err));
  }
}
function captureLiquidEvaluation(span, template, context2, result) {
  try {
    span.setAttribute("visor.liquid.template", template.substring(0, 1e3));
    span.setAttribute("visor.liquid.template.length", template.length);
    span.setAttribute("visor.liquid.result", result.substring(0, 2e3));
    span.setAttribute("visor.liquid.result.length", result.length);
    span.setAttribute("visor.liquid.context", safeSerialize(context2, 3e3));
  } catch (err) {
    span.setAttribute("visor.liquid.error", String(err));
  }
}
function captureTransformJS(span, code, input, output) {
  try {
    const codePreview = code.length > 2e3 ? code.substring(0, 2e3) + "...[truncated]" : code;
    span.setAttribute("visor.transform.code", codePreview);
    span.setAttribute("visor.transform.code.length", code.length);
    span.setAttribute("visor.transform.input", safeSerialize(input, 2e3));
    span.setAttribute("visor.transform.output", safeSerialize(output, 2e3));
  } catch (err) {
    span.setAttribute("visor.transform.error", String(err));
  }
}
function captureProviderCall(span, providerType, request, response) {
  try {
    span.setAttribute("visor.provider.type", providerType);
    const fullCapture = process.env.VISOR_TELEMETRY_FULL_CAPTURE === "true" || process.env.VISOR_TELEMETRY_FULL_CAPTURE === "1";
    if (request.model) span.setAttribute("visor.provider.request.model", String(request.model));
    if (request.prompt) {
      span.setAttribute("visor.provider.request.prompt.length", request.prompt.length);
      span.setAttribute("visor.provider.request.prompt.preview", request.prompt.substring(0, 500));
      if (fullCapture) {
        span.setAttribute("visor.provider.request.prompt", safeSerialize(request.prompt));
      }
    }
    if (response.content) {
      span.setAttribute("visor.provider.response.length", response.content.length);
      span.setAttribute("visor.provider.response.preview", response.content.substring(0, 500));
      if (fullCapture) {
        span.setAttribute("visor.provider.response.content", safeSerialize(response.content));
      }
    }
    if (response.tokens) {
      span.setAttribute("visor.provider.response.tokens", response.tokens);
    }
  } catch (err) {
    span.setAttribute("visor.provider.error", String(err));
  }
}
function captureConditionalEvaluation(span, condition, result, context2) {
  try {
    span.setAttribute("visor.condition.expression", condition.substring(0, 500));
    span.setAttribute("visor.condition.result", result);
    span.setAttribute("visor.condition.context", safeSerialize(context2, 2e3));
  } catch (err) {
    span.setAttribute("visor.condition.error", String(err));
  }
}
function captureRoutingDecision(span, action, target, condition) {
  try {
    span.setAttribute("visor.routing.action", action);
    span.setAttribute("visor.routing.target", Array.isArray(target) ? target.join(",") : target);
    if (condition) {
      span.setAttribute("visor.routing.condition", condition.substring(0, 500));
    }
  } catch (err) {
    span.setAttribute("visor.routing.error", String(err));
  }
}
function captureStateSnapshot(span, checkId, outputs, memory) {
  try {
    span.addEvent("state.snapshot", {
      "visor.snapshot.check_id": checkId,
      "visor.snapshot.outputs": safeSerialize(outputs, 5e3),
      "visor.snapshot.memory": safeSerialize(memory, 5e3),
      "visor.snapshot.timestamp": (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (err) {
    span.setAttribute("visor.snapshot.error", String(err));
  }
}
var MAX_ATTRIBUTE_LENGTH, MAX_ARRAY_ITEMS, SENSITIVE_ENV_PATTERNS;
var init_state_capture = __esm({
  "src/telemetry/state-capture.ts"() {
    "use strict";
    MAX_ATTRIBUTE_LENGTH = 1e4;
    MAX_ARRAY_ITEMS = 100;
    SENSITIVE_ENV_PATTERNS = [
      /api[_-]?key/i,
      /secret/i,
      /token/i,
      /password/i,
      /auth/i,
      /credential/i,
      /private[_-]?key/i,
      /^sk-/i,
      // OpenAI-style keys
      /^AIza/i
      // Google API keys
    ];
  }
});

// src/providers/custom-tool-executor.ts
import Ajv from "ajv";
var CustomToolExecutor;
var init_custom_tool_executor = __esm({
  "src/providers/custom-tool-executor.ts"() {
    "use strict";
    init_liquid_extensions();
    init_sandbox();
    init_logger();
    init_command_executor();
    CustomToolExecutor = class {
      liquid;
      sandbox;
      tools;
      ajv;
      constructor(tools) {
        this.liquid = createExtendedLiquid({
          cache: false,
          strictFilters: false,
          strictVariables: false
        });
        this.tools = new Map(Object.entries(tools || {}));
        this.ajv = new Ajv({ allErrors: true, verbose: true });
      }
      /**
       * Register a custom tool
       */
      registerTool(tool) {
        if (!tool.name) {
          throw new Error("Tool must have a name");
        }
        this.tools.set(tool.name, tool);
      }
      /**
       * Register multiple tools
       */
      registerTools(tools) {
        for (const [name, tool] of Object.entries(tools)) {
          tool.name = tool.name || name;
          this.registerTool(tool);
        }
      }
      /**
       * Get all registered tools
       */
      getTools() {
        return Array.from(this.tools.values());
      }
      /**
       * Get a specific tool by name
       */
      getTool(name) {
        return this.tools.get(name);
      }
      /**
       * Validate tool input against schema using ajv
       */
      validateInput(tool, input) {
        if (!tool.inputSchema) {
          return;
        }
        const validate = this.ajv.compile(tool.inputSchema);
        const valid = validate(input);
        if (!valid) {
          const errors = validate.errors?.map((err) => {
            if (err.instancePath) {
              return `${err.instancePath}: ${err.message}`;
            }
            return err.message;
          }).join(", ");
          throw new Error(`Input validation failed for tool '${tool.name}': ${errors}`);
        }
      }
      /**
       * Execute a custom tool
       */
      async execute(toolName, args, context2) {
        const tool = this.tools.get(toolName);
        if (!tool) {
          throw new Error(`Tool not found: ${toolName}`);
        }
        this.validateInput(tool, args);
        const templateContext = {
          ...context2,
          args,
          input: args
        };
        const command = await this.liquid.parseAndRender(tool.exec, templateContext);
        let stdin;
        if (tool.stdin) {
          stdin = await this.liquid.parseAndRender(tool.stdin, templateContext);
        }
        const env = commandExecutor.buildEnvironment(process.env, tool.env, context2?.env);
        const result = await commandExecutor.execute(command, {
          stdin,
          cwd: tool.cwd,
          env,
          timeout: tool.timeout || 3e4
        });
        if (result.exitCode !== 0) {
          const errorOutput = result.stderr || result.stdout || "Command failed";
          throw new Error(
            `Tool '${toolName}' execution failed with exit code ${result.exitCode}: ${errorOutput}`
          );
        }
        let output = result.stdout;
        if (tool.parseJson) {
          try {
            output = JSON.parse(result.stdout);
          } catch (e) {
            const err = e instanceof Error ? e : new Error(String(e));
            logger.warn(`Failed to parse tool output as JSON: ${err.message}`);
            if (!tool.transform && !tool.transform_js) {
              throw new Error(`Tool '${toolName}' output could not be parsed as JSON: ${err.message}`);
            }
          }
        }
        if (tool.transform) {
          const transformContext = {
            ...templateContext,
            output,
            stdout: result.stdout,
            stderr: result.stderr,
            exitCode: result.exitCode
          };
          const transformed = await this.liquid.parseAndRender(tool.transform, transformContext);
          if (typeof transformed === "string" && transformed.trim().startsWith("{")) {
            try {
              output = JSON.parse(transformed);
            } catch {
              output = transformed;
            }
          } else {
            output = transformed;
          }
        }
        if (tool.transform_js) {
          output = await this.applyJavaScriptTransform(tool.transform_js, output, {
            ...templateContext,
            stdout: result.stdout,
            stderr: result.stderr,
            exitCode: result.exitCode
          });
        }
        return output;
      }
      /**
       * Apply JavaScript transform to output
       */
      async applyJavaScriptTransform(transformJs, output, context2) {
        this.sandbox = createSecureSandbox();
        const code = `
      const output = ${JSON.stringify(output)};
      const context = ${JSON.stringify(context2)};
      const args = context.args || {};
      const pr = context.pr || {};
      const files = context.files || [];
      const outputs = context.outputs || {};
      const env = context.env || {};

      ${transformJs}
    `;
        try {
          return await compileAndRun(this.sandbox, code, { timeout: 5e3 });
        } catch (error) {
          logger.error(`JavaScript transform error: ${error}`);
          throw error;
        }
      }
      /**
       * Convert custom tools to MCP tool format
       */
      toMcpTools() {
        return Array.from(this.tools.values()).map((tool) => ({
          name: tool.name,
          description: tool.description,
          inputSchema: tool.inputSchema,
          handler: async (args) => {
            return this.execute(tool.name, args);
          }
        }));
      }
    };
  }
});

// src/providers/workflow-tool-executor.ts
function workflowInputsToJsonSchema(inputs) {
  if (!inputs || inputs.length === 0) {
    return {
      type: "object",
      properties: {},
      required: []
    };
  }
  const properties = {};
  const required = [];
  for (const input of inputs) {
    const propSchema = {};
    if (input.schema) {
      propSchema.type = input.schema.type || "string";
      if (input.schema.description) propSchema.description = input.schema.description;
      if (input.schema.enum) propSchema.enum = input.schema.enum;
      if (input.schema.default !== void 0) propSchema.default = input.schema.default;
      if (input.schema.minimum !== void 0) propSchema.minimum = input.schema.minimum;
      if (input.schema.maximum !== void 0) propSchema.maximum = input.schema.maximum;
      if (input.schema.minLength !== void 0) propSchema.minLength = input.schema.minLength;
      if (input.schema.maxLength !== void 0) propSchema.maxLength = input.schema.maxLength;
      if (input.schema.pattern) propSchema.pattern = input.schema.pattern;
      if (input.schema.format) propSchema.format = input.schema.format;
      if (input.schema.properties) propSchema.properties = input.schema.properties;
      if (input.schema.items) propSchema.items = input.schema.items;
      if (input.schema.additionalProperties !== void 0) {
        propSchema.additionalProperties = input.schema.additionalProperties;
      }
    } else {
      propSchema.type = "string";
    }
    if (!propSchema.description && input.description) {
      propSchema.description = input.description;
    }
    if (propSchema.default === void 0 && input.default !== void 0) {
      propSchema.default = input.default;
    }
    properties[input.name] = propSchema;
    if (input.required !== false && input.default === void 0) {
      required.push(input.name);
    }
  }
  return {
    type: "object",
    properties,
    required: required.length > 0 ? required : void 0
  };
}
function createWorkflowToolDefinition(workflow, argsOverrides) {
  const baseSchema = workflowInputsToJsonSchema(workflow.inputs);
  let inputSchema = baseSchema;
  if (argsOverrides && baseSchema && typeof baseSchema === "object") {
    const baseProperties = baseSchema.properties;
    const baseRequired = baseSchema.required;
    const filteredProperties = baseProperties ? { ...baseProperties } : {};
    for (const key of Object.keys(argsOverrides)) {
      delete filteredProperties[key];
    }
    const filteredRequired = baseRequired ? baseRequired.filter((r) => !argsOverrides[r]) : void 0;
    inputSchema = {
      ...baseSchema,
      properties: filteredProperties,
      required: filteredRequired && filteredRequired.length > 0 ? filteredRequired : void 0
    };
  }
  return {
    name: workflow.id,
    description: workflow.description || `Execute the ${workflow.name} workflow`,
    inputSchema,
    // Workflow tools don't have an exec command - they're executed specially
    exec: "",
    // Marker properties
    __isWorkflowTool: true,
    __workflowId: workflow.id,
    __argsOverrides: argsOverrides
  };
}
function isWorkflowTool(tool) {
  return tool.__isWorkflowTool === true;
}
function isWorkflowToolReference(item) {
  return typeof item === "object" && item !== null && "workflow" in item;
}
async function executeWorkflowAsTool(workflowId, args, context2, argsOverrides) {
  const registry = WorkflowRegistry.getInstance();
  const workflow = registry.get(workflowId);
  if (!workflow) {
    throw new Error(`Workflow '${workflowId}' not found in registry`);
  }
  logger.debug(`[WorkflowToolExecutor] Executing workflow '${workflowId}' as tool`);
  const mergedArgs = {
    ...args,
    ...argsOverrides
  };
  const { WorkflowCheckProvider: WorkflowCheckProvider2 } = await import("./workflow-check-provider-5QBR34G6.mjs");
  const provider = new WorkflowCheckProvider2();
  const checkConfig = {
    type: "workflow",
    workflow: workflowId,
    args: mergedArgs,
    checkName: `workflow-tool-${workflowId}`
  };
  const result = await provider.execute(
    context2.prInfo,
    checkConfig,
    context2.outputs,
    context2.executionContext
  );
  const output = result.output;
  const outputKeys = output ? Object.keys(output) : [];
  const outputPreview = output ? JSON.stringify(output).substring(0, 500) : "undefined";
  logger.info(
    `[WorkflowToolExecutor] Workflow '${workflowId}' completed. Output keys: [${outputKeys.join(", ")}]`
  );
  logger.debug(`[WorkflowToolExecutor] Workflow '${workflowId}' output preview: ${outputPreview}`);
  if (output !== void 0) {
    return output;
  }
  if (result.content) {
    logger.debug(`[WorkflowToolExecutor] Using content fallback for '${workflowId}'`);
    return result.content;
  }
  logger.debug(`[WorkflowToolExecutor] Using full result fallback for '${workflowId}'`);
  return result;
}
function resolveWorkflowToolFromItem(item) {
  const registry = WorkflowRegistry.getInstance();
  if (typeof item === "string") {
    if (registry.has(item)) {
      const workflow = registry.get(item);
      return createWorkflowToolDefinition(workflow);
    }
    return void 0;
  }
  if (isWorkflowToolReference(item)) {
    const workflow = registry.get(item.workflow);
    if (!workflow) {
      logger.warn(`[WorkflowToolExecutor] Workflow '${item.workflow}' not found in registry`);
      return void 0;
    }
    return createWorkflowToolDefinition(workflow, item.args);
  }
  return void 0;
}
var init_workflow_tool_executor = __esm({
  "src/providers/workflow-tool-executor.ts"() {
    "use strict";
    init_workflow_registry();
    init_logger();
  }
});

// src/scheduler/schedule-store.ts
import fs2 from "fs/promises";
import path3 from "path";
import { v4 as uuidv4 } from "uuid";
var ScheduleStore;
var init_schedule_store = __esm({
  "src/scheduler/schedule-store.ts"() {
    "use strict";
    init_logger();
    ScheduleStore = class _ScheduleStore {
      static instance;
      schedules = /* @__PURE__ */ new Map();
      filePath;
      autoSave;
      saveDebounceMs;
      initialized = false;
      saveTimeout = null;
      limits;
      // Concurrency protection
      saveLock = Promise.resolve();
      pendingSave = false;
      dirtyCount = 0;
      // Track unsaved changes
      constructor(config, limits) {
        this.filePath = config?.path || ".visor/schedules.json";
        this.autoSave = config?.autoSave !== false;
        this.saveDebounceMs = config?.saveDebounceMs ?? 1e3;
        this.limits = {
          maxPerUser: limits?.maxPerUser ?? 25,
          maxRecurringPerUser: limits?.maxRecurringPerUser ?? 10,
          maxGlobal: limits?.maxGlobal ?? 1e3
        };
      }
      /**
       * Get singleton instance
       */
      static getInstance(config, limits) {
        if (!_ScheduleStore.instance) {
          _ScheduleStore.instance = new _ScheduleStore(config, limits);
        }
        return _ScheduleStore.instance;
      }
      /**
       * Create a new isolated instance (for testing)
       */
      static createIsolated(config, limits) {
        return new _ScheduleStore(config, limits);
      }
      /**
       * Reset singleton instance (for testing)
       */
      static resetInstance() {
        if (_ScheduleStore.instance) {
          _ScheduleStore.instance.schedules.clear();
          if (_ScheduleStore.instance.saveTimeout) {
            clearTimeout(_ScheduleStore.instance.saveTimeout);
          }
        }
        _ScheduleStore.instance = void 0;
      }
      /**
       * Initialize the store - load from file if it exists
       */
      async initialize() {
        if (this.initialized) {
          return;
        }
        try {
          const resolvedPath = path3.resolve(process.cwd(), this.filePath);
          const content = await fs2.readFile(resolvedPath, "utf-8");
          const data = JSON.parse(content);
          const scheduleList = data.schedules || [];
          if (Array.isArray(scheduleList)) {
            for (const schedule of scheduleList) {
              this.schedules.set(schedule.id, schedule);
            }
            logger.info(
              `[ScheduleStore] Loaded ${this.schedules.size} schedules from ${this.filePath}`
            );
          }
        } catch (error) {
          if (error.code !== "ENOENT") {
            logger.warn(
              `[ScheduleStore] Failed to load schedules: ${error instanceof Error ? error.message : "Unknown error"}`
            );
          } else {
            logger.debug(`[ScheduleStore] No existing schedules file at ${this.filePath}`);
          }
        }
        this.initialized = true;
      }
      /**
       * Save schedules to file with atomic write and concurrency protection
       */
      async save() {
        const previousLock = this.saveLock;
        let releaseLock;
        this.saveLock = new Promise((resolve5) => {
          releaseLock = resolve5;
        });
        try {
          await previousLock;
          const resolvedPath = path3.resolve(process.cwd(), this.filePath);
          const dir = path3.dirname(resolvedPath);
          await fs2.mkdir(dir, { recursive: true });
          const savedDirtyCount = this.dirtyCount;
          const data = {
            version: "2.0",
            // New version for schedule format
            savedAt: (/* @__PURE__ */ new Date()).toISOString(),
            schedules: Array.from(this.schedules.values())
          };
          const tempPath = `${resolvedPath}.tmp.${Date.now()}`;
          await fs2.writeFile(tempPath, JSON.stringify(data, null, 2), "utf-8");
          await fs2.rename(tempPath, resolvedPath);
          this.dirtyCount = Math.max(0, this.dirtyCount - savedDirtyCount);
          this.pendingSave = false;
          logger.debug(`[ScheduleStore] Saved ${this.schedules.size} schedules to ${this.filePath}`);
        } finally {
          releaseLock();
        }
      }
      /**
       * Schedule a debounced save operation with dirty tracking
       */
      scheduleSave() {
        if (!this.autoSave) return;
        this.dirtyCount++;
        this.pendingSave = true;
        if (this.saveTimeout) {
          clearTimeout(this.saveTimeout);
        }
        this.saveTimeout = setTimeout(() => {
          this.save().catch((error) => {
            logger.error(
              `[ScheduleStore] Auto-save failed: ${error instanceof Error ? error.message : "Unknown error"}`
            );
          });
        }, this.saveDebounceMs);
      }
      /**
       * Immediately save if there are pending changes (for critical operations)
       */
      async saveImmediate() {
        if (!this.autoSave) return;
        if (this.saveTimeout) {
          clearTimeout(this.saveTimeout);
          this.saveTimeout = null;
        }
        await this.save();
      }
      /**
       * Create a new schedule (saves immediately to prevent data loss)
       */
      async createAsync(schedule) {
        this.validateLimits(schedule.creatorId, schedule.isRecurring);
        const newSchedule = {
          ...schedule,
          id: uuidv4(),
          createdAt: Date.now(),
          runCount: 0,
          failureCount: 0,
          status: "active"
        };
        this.schedules.set(newSchedule.id, newSchedule);
        await this.saveImmediate();
        logger.info(
          `[ScheduleStore] Created schedule ${newSchedule.id} for user ${newSchedule.creatorId}: workflow="${newSchedule.workflow}"`
        );
        return newSchedule;
      }
      /**
       * Create a new schedule (synchronous, uses debounced save)
       * @deprecated Use createAsync for reliable persistence
       */
      create(schedule) {
        this.validateLimits(schedule.creatorId, schedule.isRecurring);
        const newSchedule = {
          ...schedule,
          id: uuidv4(),
          createdAt: Date.now(),
          runCount: 0,
          failureCount: 0,
          status: "active"
        };
        this.schedules.set(newSchedule.id, newSchedule);
        this.scheduleSave();
        logger.info(
          `[ScheduleStore] Created schedule ${newSchedule.id} for user ${newSchedule.creatorId}: workflow="${newSchedule.workflow}"`
        );
        return newSchedule;
      }
      /**
       * Validate schedule limits before creation
       */
      validateLimits(creatorId, isRecurring) {
        if (this.limits.maxGlobal && this.schedules.size >= this.limits.maxGlobal) {
          throw new Error(`Global schedule limit reached (${this.limits.maxGlobal})`);
        }
        const userSchedules = this.getByCreator(creatorId);
        if (this.limits.maxPerUser && userSchedules.length >= this.limits.maxPerUser) {
          throw new Error(
            `You have reached the maximum number of schedules (${this.limits.maxPerUser})`
          );
        }
        if (isRecurring && this.limits.maxRecurringPerUser) {
          const recurringCount = userSchedules.filter((s) => s.isRecurring).length;
          if (recurringCount >= this.limits.maxRecurringPerUser) {
            throw new Error(
              `You have reached the maximum number of recurring schedules (${this.limits.maxRecurringPerUser})`
            );
          }
        }
      }
      /**
       * Get a schedule by ID
       */
      get(id) {
        return this.schedules.get(id);
      }
      /**
       * Update a schedule
       */
      update(id, patch) {
        const schedule = this.schedules.get(id);
        if (!schedule) {
          return void 0;
        }
        const updated = { ...schedule, ...patch, id: schedule.id };
        this.schedules.set(id, updated);
        this.scheduleSave();
        return updated;
      }
      /**
       * Delete a schedule (saves immediately to prevent data loss)
       */
      async deleteAsync(id) {
        const deleted = this.schedules.delete(id);
        if (deleted) {
          await this.saveImmediate();
          logger.info(`[ScheduleStore] Deleted schedule ${id}`);
        }
        return deleted;
      }
      /**
       * Delete a schedule (synchronous, uses debounced save)
       * @deprecated Use deleteAsync for reliable persistence
       */
      delete(id) {
        const deleted = this.schedules.delete(id);
        if (deleted) {
          this.scheduleSave();
          logger.info(`[ScheduleStore] Deleted schedule ${id}`);
        }
        return deleted;
      }
      /**
       * Get all schedules for a specific creator
       */
      getByCreator(creatorId) {
        return Array.from(this.schedules.values()).filter((s) => s.creatorId === creatorId);
      }
      /**
       * Get all active schedules
       */
      getActiveSchedules() {
        return Array.from(this.schedules.values()).filter((s) => s.status === "active");
      }
      /**
       * Get all schedules due for execution
       * @param now Current timestamp in milliseconds
       */
      getDueSchedules(now = Date.now()) {
        return this.getActiveSchedules().filter((s) => {
          if (!s.isRecurring && s.runAt) {
            return s.runAt <= now;
          }
          if (s.isRecurring && s.nextRunAt) {
            return s.nextRunAt <= now;
          }
          return false;
        });
      }
      /**
       * Find schedules by workflow name
       */
      findByWorkflow(creatorId, workflowName) {
        const lowerWorkflow = workflowName.toLowerCase();
        return this.getByCreator(creatorId).filter(
          (s) => s.status === "active" && s.workflow?.toLowerCase().includes(lowerWorkflow)
        );
      }
      /**
       * Get schedule count statistics
       */
      getStats() {
        const all = Array.from(this.schedules.values());
        return {
          total: all.length,
          active: all.filter((s) => s.status === "active").length,
          paused: all.filter((s) => s.status === "paused").length,
          completed: all.filter((s) => s.status === "completed").length,
          failed: all.filter((s) => s.status === "failed").length,
          recurring: all.filter((s) => s.isRecurring).length,
          oneTime: all.filter((s) => !s.isRecurring).length
        };
      }
      /**
       * Force immediate save (useful for shutdown)
       */
      async flush() {
        if (this.saveTimeout) {
          clearTimeout(this.saveTimeout);
          this.saveTimeout = null;
        }
        await this.save();
      }
      /**
       * Check if initialized
       */
      isInitialized() {
        return this.initialized;
      }
      /**
       * Check if there are unsaved changes
       */
      hasPendingChanges() {
        return this.pendingSave || this.dirtyCount > 0;
      }
      /**
       * Get all schedules (for iteration)
       */
      getAll() {
        return Array.from(this.schedules.values());
      }
    };
  }
});

// src/scheduler/schedule-parser.ts
function getNextRunTime(cronExpression, _timezone = "UTC") {
  const parts = cronExpression.split(" ");
  if (parts.length !== 5) {
    throw new Error(`Invalid cron expression: ${cronExpression}`);
  }
  const [minute, hour, dayOfMonth, month, dayOfWeek] = parts;
  const now = /* @__PURE__ */ new Date();
  const next = new Date(now);
  next.setSeconds(0, 0);
  next.setMinutes(next.getMinutes() + 1);
  const maxAttempts = 365 * 24 * 60;
  for (let i = 0; i < maxAttempts; i++) {
    if (matchesCronPart(next.getMinutes(), minute) && matchesCronPart(next.getHours(), hour) && matchesCronPart(next.getDate(), dayOfMonth) && matchesCronPart(next.getMonth() + 1, month) && matchesCronPart(next.getDay(), dayOfWeek)) {
      return next;
    }
    next.setMinutes(next.getMinutes() + 1);
  }
  const fallback = new Date(now);
  fallback.setDate(fallback.getDate() + 1);
  fallback.setHours(parseInt(hour, 10) || 9);
  fallback.setMinutes(parseInt(minute, 10) || 0);
  fallback.setSeconds(0, 0);
  return fallback;
}
function matchesCronPart(value, cronPart) {
  if (cronPart === "*") return true;
  if (cronPart.startsWith("*/")) {
    const step = parseInt(cronPart.slice(2), 10);
    return value % step === 0;
  }
  if (cronPart.includes("-")) {
    const [start, end] = cronPart.split("-").map((n) => parseInt(n, 10));
    return value >= start && value <= end;
  }
  if (cronPart.includes(",")) {
    return cronPart.split(",").map((n) => parseInt(n, 10)).includes(value);
  }
  return parseInt(cronPart, 10) === value;
}
function isValidCronExpression(expr) {
  if (!expr || typeof expr !== "string") return false;
  const parts = expr.trim().split(/\s+/);
  if (parts.length !== 5) return false;
  const ranges = [
    [0, 59],
    // minute
    [0, 23],
    // hour
    [1, 31],
    // day of month
    [1, 12],
    // month
    [0, 7]
    // day of week (0 and 7 are Sunday)
  ];
  return parts.every((part, i) => {
    if (part === "*") return true;
    if (part.startsWith("*/")) {
      const step = parseInt(part.slice(2), 10);
      return !isNaN(step) && step > 0;
    }
    if (part.includes("-")) {
      const [start, end] = part.split("-").map((n) => parseInt(n, 10));
      return !isNaN(start) && !isNaN(end) && start >= ranges[i][0] && end <= ranges[i][1];
    }
    if (part.includes(",")) {
      return part.split(",").every((n) => {
        const val2 = parseInt(n, 10);
        return !isNaN(val2) && val2 >= ranges[i][0] && val2 <= ranges[i][1];
      });
    }
    const val = parseInt(part, 10);
    return !isNaN(val) && val >= ranges[i][0] && val <= ranges[i][1];
  });
}
var init_schedule_parser = __esm({
  "src/scheduler/schedule-parser.ts"() {
    "use strict";
  }
});

// src/scheduler/schedule-tool.ts
function matchGlobPattern(pattern, value) {
  const regexPattern = pattern.replace(/[.+^${}()|[\]\\]/g, "\\$&").replace(/\*/g, ".*").replace(/\?/g, ".");
  return new RegExp(`^${regexPattern}$`).test(value);
}
function isWorkflowAllowedByPatterns(workflow, allowedPatterns, deniedPatterns) {
  if (deniedPatterns && deniedPatterns.length > 0) {
    for (const pattern of deniedPatterns) {
      if (matchGlobPattern(pattern, workflow)) {
        return {
          allowed: false,
          reason: `Workflow "${workflow}" matches denied pattern "${pattern}"`
        };
      }
    }
  }
  if (allowedPatterns && allowedPatterns.length > 0) {
    for (const pattern of allowedPatterns) {
      if (matchGlobPattern(pattern, workflow)) {
        return { allowed: true };
      }
    }
    return {
      allowed: false,
      reason: `Workflow "${workflow}" does not match any allowed patterns: ${allowedPatterns.join(", ")}`
    };
  }
  return { allowed: true };
}
function checkSchedulePermissions(context2, workflow, requestedScheduleType) {
  const permissions = context2.permissions;
  const scheduleType = requestedScheduleType || context2.scheduleType || "personal";
  if (context2.allowedScheduleType && scheduleType !== context2.allowedScheduleType) {
    const contextNames = {
      personal: "a direct message (DM)",
      channel: "a channel",
      dm: "a group DM"
    };
    const targetNames = {
      personal: "personal",
      channel: "channel",
      dm: "group"
    };
    return {
      allowed: false,
      reason: `From ${contextNames[context2.allowedScheduleType]}, you can only create ${targetNames[context2.allowedScheduleType]} schedules. To create a ${targetNames[scheduleType]} schedule, please use the appropriate context.`
    };
  }
  if (!permissions) {
    return { allowed: true };
  }
  switch (scheduleType) {
    case "personal":
      if (permissions.allowPersonal === false) {
        return {
          allowed: false,
          reason: "Personal schedules are not allowed in this configuration"
        };
      }
      break;
    case "channel":
      if (permissions.allowChannel === false) {
        return {
          allowed: false,
          reason: "Channel schedules are not allowed in this configuration"
        };
      }
      break;
    case "dm":
      if (permissions.allowDm === false) {
        return {
          allowed: false,
          reason: "DM schedules are not allowed in this configuration"
        };
      }
      break;
  }
  return isWorkflowAllowedByPatterns(
    workflow,
    permissions.allowedWorkflows,
    permissions.deniedWorkflows
  );
}
function formatSchedule(schedule) {
  const time = schedule.isRecurring ? schedule.originalExpression : new Date(schedule.runAt).toLocaleString();
  const status = schedule.status !== "active" ? ` (${schedule.status})` : "";
  const displayName = schedule.workflow || schedule.workflowInputs?.text || "scheduled message";
  const truncatedName = displayName.length > 30 ? displayName.substring(0, 27) + "..." : displayName;
  const output = schedule.outputContext?.type || "none";
  return `\`${schedule.id.substring(0, 8)}\` - "${truncatedName}" - ${time} (\u2192 ${output})${status}`;
}
function formatCreateConfirmation(schedule) {
  const outputDesc = schedule.outputContext?.type ? `${schedule.outputContext.type}${schedule.outputContext.target ? `:${schedule.outputContext.target}` : ""}` : "none";
  const displayName = schedule.workflow || schedule.workflowInputs?.text || "scheduled message";
  if (schedule.isRecurring) {
    const nextRun = schedule.nextRunAt ? new Date(schedule.nextRunAt).toLocaleString("en-US", {
      weekday: "long",
      month: "short",
      day: "numeric",
      hour: "numeric",
      minute: "2-digit"
    }) : "calculating...";
    return `**Schedule created!**

**${schedule.workflow ? "Workflow" : "Reminder"}**: ${displayName}
**When**: ${schedule.originalExpression}
**Output**: ${outputDesc}
**Next run**: ${nextRun}

ID: \`${schedule.id.substring(0, 8)}\``;
  } else {
    const when = new Date(schedule.runAt).toLocaleString("en-US", {
      weekday: "long",
      month: "short",
      day: "numeric",
      hour: "numeric",
      minute: "2-digit"
    });
    return `**Schedule created!**

**${schedule.workflow ? "Workflow" : "Reminder"}**: ${displayName}
**When**: ${when}
**Output**: ${outputDesc}

ID: \`${schedule.id.substring(0, 8)}\``;
  }
}
function formatScheduleList(schedules) {
  if (schedules.length === 0) {
    return `You don't have any active schedules.

To create one: "schedule daily-report every Monday at 9am"`;
  }
  const lines = schedules.map((s, i) => `${i + 1}. ${formatSchedule(s)}`);
  return `**Your active schedules:**

${lines.join("\n")}

To cancel: "cancel schedule <id>"
To pause: "pause schedule <id>"`;
}
async function handleScheduleAction(args, context2) {
  const store = ScheduleStore.getInstance();
  if (!store.isInitialized()) {
    await store.initialize();
  }
  switch (args.action) {
    case "create":
      return handleCreate(args, context2, store);
    case "list":
      return handleList(context2, store);
    case "cancel":
      return handleCancel(args, context2, store);
    case "pause":
      return handlePauseResume(args, context2, store, "paused");
    case "resume":
      return handlePauseResume(args, context2, store, "active");
    default:
      return {
        success: false,
        message: `Unknown action: ${args.action}`,
        error: `Supported actions: create, list, cancel, pause, resume`
      };
  }
}
async function handleCreate(args, context2, store) {
  if (!args.reminder_text && !args.workflow) {
    return {
      success: false,
      message: "Missing reminder content",
      error: "Please specify either reminder_text (what to say) or workflow (what to run)"
    };
  }
  if (!args.cron && !args.run_at) {
    return {
      success: false,
      message: "Missing schedule timing",
      error: 'Please specify either cron (for recurring, e.g., "* * * * *") or run_at (ISO timestamp for one-time)'
    };
  }
  if (args.cron && !isValidCronExpression(args.cron)) {
    return {
      success: false,
      message: "Invalid cron expression",
      error: `"${args.cron}" is not a valid cron expression. Format: "minute hour day-of-month month day-of-week"`
    };
  }
  let runAtTimestamp;
  if (args.run_at) {
    const parsed = new Date(args.run_at);
    if (isNaN(parsed.getTime())) {
      return {
        success: false,
        message: "Invalid run_at timestamp",
        error: `"${args.run_at}" is not a valid ISO 8601 timestamp`
      };
    }
    if (parsed.getTime() <= Date.now()) {
      return {
        success: false,
        message: "run_at must be in the future",
        error: "Cannot schedule a reminder in the past"
      };
    }
    runAtTimestamp = parsed.getTime();
  }
  if (args.target_type && !args.target_id) {
    return {
      success: false,
      message: "Missing target_id",
      error: `target_type "${args.target_type}" requires a target_id (channel ID, user ID, or thread_ts)`
    };
  }
  let scheduleType = "personal";
  if (args.target_type === "channel") {
    scheduleType = "channel";
  } else if (args.target_type === "user") {
    scheduleType = "dm";
  }
  const workflowName = args.workflow || "reminder";
  const permissionCheck = checkSchedulePermissions(context2, workflowName, scheduleType);
  if (!permissionCheck.allowed) {
    logger.warn(
      `[ScheduleTool] Permission denied for user ${context2.userId}: ${permissionCheck.reason}`
    );
    return {
      success: false,
      message: "Permission denied",
      error: permissionCheck.reason || "You do not have permission to create this schedule"
    };
  }
  if (args.workflow && context2.availableWorkflows && !context2.availableWorkflows.includes(args.workflow)) {
    return {
      success: false,
      message: `Workflow "${args.workflow}" not found`,
      error: `Available workflows: ${context2.availableWorkflows.slice(0, 5).join(", ")}${context2.availableWorkflows.length > 5 ? "..." : ""}`
    };
  }
  try {
    const timezone = context2.timezone || "UTC";
    const isRecurring = args.is_recurring === true || !!args.cron;
    let outputContext;
    if (args.target_type && args.target_id) {
      outputContext = {
        type: "slack",
        // Currently only Slack supported
        target: args.target_id,
        // Channel ID (C... or D...)
        threadId: args.thread_ts,
        // Thread timestamp for replies
        metadata: {
          targetType: args.target_type,
          reminderText: args.reminder_text
        }
      };
    }
    let nextRunAt;
    if (isRecurring && args.cron) {
      nextRunAt = getNextRunTime(args.cron, timezone).getTime();
    } else if (runAtTimestamp) {
      nextRunAt = runAtTimestamp;
    }
    const schedule = store.create({
      creatorId: context2.userId,
      creatorContext: context2.contextType,
      creatorName: context2.userName,
      timezone,
      schedule: args.cron || "",
      runAt: runAtTimestamp,
      isRecurring,
      originalExpression: args.original_expression || args.cron || args.run_at || "",
      workflow: args.workflow,
      // Only set if explicitly provided
      workflowInputs: args.workflow_inputs || (args.reminder_text ? { text: args.reminder_text } : void 0),
      outputContext,
      nextRunAt
    });
    const displayText = args.reminder_text || args.workflow || "scheduled task";
    logger.info(
      `[ScheduleTool] Created schedule ${schedule.id} for user ${context2.userId}: "${displayText}"`
    );
    return {
      success: true,
      message: formatCreateConfirmation(schedule),
      schedule
    };
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : "Unknown error";
    logger.warn(`[ScheduleTool] Failed to create schedule: ${errorMsg}`);
    return {
      success: false,
      message: `Failed to create schedule: ${errorMsg}`,
      error: errorMsg
    };
  }
}
async function handleList(context2, store) {
  const schedules = store.getByCreator(context2.userId).filter((s) => s.status !== "completed");
  let filteredSchedules = schedules;
  if (context2.allowedScheduleType) {
    filteredSchedules = schedules.filter((s) => {
      const scheduleOutputType = s.outputContext?.type;
      if (!scheduleOutputType || scheduleOutputType === "none") {
        return context2.allowedScheduleType === "personal";
      }
      if (scheduleOutputType === "slack") {
        const target = s.outputContext?.target || "";
        if (target.startsWith("#") || target.match(/^C[A-Z0-9]+$/)) {
          return context2.allowedScheduleType === "channel";
        }
        if (target.startsWith("@") || target.match(/^U[A-Z0-9]+$/)) {
          return context2.allowedScheduleType === "dm";
        }
      }
      return context2.allowedScheduleType === "personal";
    });
  }
  return {
    success: true,
    message: formatScheduleList(filteredSchedules),
    schedules: filteredSchedules
  };
}
async function handleCancel(args, context2, store) {
  let schedule;
  if (args.schedule_id) {
    const userSchedules = store.getByCreator(context2.userId);
    schedule = userSchedules.find((s) => s.id === args.schedule_id);
    if (!schedule) {
      schedule = userSchedules.find((s) => s.id.startsWith(args.schedule_id));
    }
  }
  if (!schedule) {
    return {
      success: false,
      message: "Schedule not found",
      error: `Could not find schedule with ID "${args.schedule_id}" in your schedules. Use "list my schedules" to see your schedules.`
    };
  }
  if (schedule.creatorId !== context2.userId) {
    logger.warn(
      `[ScheduleTool] Attempted cross-user schedule cancellation: ${context2.userId} tried to cancel ${schedule.id} owned by ${schedule.creatorId}`
    );
    return {
      success: false,
      message: "Not your schedule",
      error: "You can only cancel your own schedules."
    };
  }
  store.delete(schedule.id);
  logger.info(`[ScheduleTool] Cancelled schedule ${schedule.id} for user ${context2.userId}`);
  return {
    success: true,
    message: `**Schedule cancelled!**

Was: "${schedule.workflow}" scheduled for ${schedule.originalExpression}`
  };
}
async function handlePauseResume(args, context2, store, newStatus) {
  if (!args.schedule_id) {
    return {
      success: false,
      message: "Missing schedule ID",
      error: "Please specify which schedule to pause/resume."
    };
  }
  const userSchedules = store.getByCreator(context2.userId);
  let schedule = userSchedules.find((s) => s.id === args.schedule_id);
  if (!schedule) {
    schedule = userSchedules.find((s) => s.id.startsWith(args.schedule_id));
  }
  if (!schedule) {
    return {
      success: false,
      message: "Schedule not found",
      error: `Could not find schedule with ID "${args.schedule_id}" in your schedules.`
    };
  }
  if (schedule.creatorId !== context2.userId) {
    logger.warn(
      `[ScheduleTool] Attempted cross-user schedule modification: ${context2.userId} tried to modify ${schedule.id} owned by ${schedule.creatorId}`
    );
    return {
      success: false,
      message: "Not your schedule",
      error: "You can only modify your own schedules."
    };
  }
  const updated = store.update(schedule.id, { status: newStatus });
  const action = newStatus === "paused" ? "paused" : "resumed";
  logger.info(`[ScheduleTool] ${action} schedule ${schedule.id} for user ${context2.userId}`);
  return {
    success: true,
    message: `**Schedule ${action}!**

"${schedule.workflow}" - ${schedule.originalExpression}`,
    schedule: updated
  };
}
function getScheduleToolDefinition() {
  return {
    name: "schedule",
    description: `Schedule, list, and manage reminders or workflow executions.

YOU (the AI) must extract and structure all scheduling parameters. Do NOT pass natural language time expressions - convert them to cron or ISO timestamps.

ACTIONS:
- create: Schedule a new reminder or workflow
- list: Show user's active schedules
- cancel: Remove a schedule by ID
- pause/resume: Temporarily disable/enable a schedule

FOR CREATE ACTION - Extract these from user's request:
1. WHAT: Either reminder_text (message to send) OR workflow (workflow ID to run)
2. WHERE: Use the CURRENT channel from context
   - target_id: The channel ID from context (C... for channels, D... for DMs)
   - target_type: "channel" for public/private channels, "dm" for direct messages
   - ONLY use target_type="thread" with thread_ts if user is INSIDE a thread
   - When NOT in a thread, reminders post as NEW messages (not thread replies)
3. WHEN: Either cron (for recurring) OR run_at (ISO 8601 for one-time)
   - Recurring: Generate cron expression (minute hour day-of-month month day-of-week)
   - One-time: Generate ISO 8601 timestamp

CRON EXAMPLES:
- "every minute" \u2192 cron: "* * * * *"
- "every hour" \u2192 cron: "0 * * * *"
- "every day at 9am" \u2192 cron: "0 9 * * *"
- "every Monday at 9am" \u2192 cron: "0 9 * * 1"
- "weekdays at 8:30am" \u2192 cron: "30 8 * * 1-5"
- "every 5 minutes" \u2192 cron: "*/5 * * * *"

ONE-TIME EXAMPLES:
- "in 2 hours" \u2192 run_at: "<ISO timestamp 2 hours from now>"
- "tomorrow at 3pm" \u2192 run_at: "2026-02-08T15:00:00Z"

USAGE EXAMPLES:

User in DM: "remind me to check builds every day at 9am"
\u2192 {
    "action": "create",
    "reminder_text": "check builds",
    "is_recurring": true,
    "cron": "0 9 * * *",
    "target_type": "dm",
    "target_id": "<DM channel ID from context, e.g., D09SZABNLG3>",
    "original_expression": "every day at 9am"
  }

User in #security channel: "run security-scan every Monday at 10am"
\u2192 {
    "action": "create",
    "workflow": "security-scan",
    "is_recurring": true,
    "cron": "0 10 * * 1",
    "target_type": "channel",
    "target_id": "<channel ID from context, e.g., C05ABC123>",
    "original_expression": "every Monday at 10am"
  }

User in DM: "remind me in 2 hours to review the PR"
\u2192 {
    "action": "create",
    "reminder_text": "review the PR",
    "is_recurring": false,
    "run_at": "2026-02-07T18:00:00Z",
    "target_type": "dm",
    "target_id": "<DM channel ID from context>",
    "original_expression": "in 2 hours"
  }

User inside a thread: "remind me about this tomorrow"
\u2192 {
    "action": "create",
    "reminder_text": "Check this thread",
    "is_recurring": false,
    "run_at": "2026-02-08T09:00:00Z",
    "target_type": "thread",
    "target_id": "<channel ID>",
    "thread_ts": "<thread_ts from context>",
    "original_expression": "tomorrow"
  }

User: "list my schedules"
\u2192 { "action": "list" }

User: "cancel schedule abc123"
\u2192 { "action": "cancel", "schedule_id": "abc123" }`,
    inputSchema: {
      type: "object",
      properties: {
        action: {
          type: "string",
          enum: ["create", "list", "cancel", "pause", "resume"],
          description: "What to do: create new, list existing, cancel/pause/resume by ID"
        },
        // WHAT to do
        reminder_text: {
          type: "string",
          description: "For create: the message/reminder text to send when triggered"
        },
        workflow: {
          type: "string",
          description: "For create: workflow/check ID to run (use instead of reminder_text for workflow execution)"
        },
        workflow_inputs: {
          type: "object",
          description: "For create: optional inputs to pass to the workflow"
        },
        // WHERE to send
        target_type: {
          type: "string",
          enum: ["channel", "dm", "thread", "user"],
          description: "For create: where to send output. channel=public/private channel, dm=DM to self (current DM channel), user=DM to specific user, thread=reply in current thread"
        },
        target_id: {
          type: "string",
          description: "For create: Slack channel ID. Channels start with C, DMs start with D. Always use the channel ID from the current context."
        },
        thread_ts: {
          type: "string",
          description: "For create with target_type=thread: the thread timestamp to reply to. Get this from the current thread context."
        },
        // WHEN to run
        is_recurring: {
          type: "boolean",
          description: "For create: true for recurring schedules (cron), false for one-time (run_at)"
        },
        cron: {
          type: "string",
          description: 'For create recurring: cron expression (minute hour day-of-month month day-of-week). Examples: "0 9 * * *" (daily 9am), "* * * * *" (every minute), "0 9 * * 1" (Mondays 9am)'
        },
        run_at: {
          type: "string",
          description: 'For create one-time: ISO 8601 timestamp when to run (e.g., "2026-02-07T15:00:00Z")'
        },
        original_expression: {
          type: "string",
          description: "For create: the original natural language expression from user (for display only)"
        },
        // For cancel/pause/resume
        schedule_id: {
          type: "string",
          description: "For cancel/pause/resume: the schedule ID to act on (first 8 chars is enough)"
        }
      },
      required: ["action"]
    },
    exec: ""
    // Not used - this tool has a custom handler
  };
}
function isScheduleTool(toolName) {
  return toolName === "schedule";
}
function determineScheduleType(contextType, outputType, outputTarget) {
  if (outputType === "slack" && outputTarget) {
    if (outputTarget.startsWith("#") || outputTarget.match(/^C[A-Z0-9]+$/)) {
      return "channel";
    }
    if (outputTarget.startsWith("@") || outputTarget.match(/^U[A-Z0-9]+$/)) {
      return "dm";
    }
  }
  if (contextType === "cli" || contextType.startsWith("github:")) {
    return "personal";
  }
  return "personal";
}
function slackChannelTypeToScheduleType(channelType) {
  switch (channelType) {
    case "channel":
      return "channel";
    case "group":
      return "dm";
    // Group DMs map to 'dm' schedule type
    case "dm":
    default:
      return "personal";
  }
}
function buildScheduleToolContext(sources, availableWorkflows, permissions, outputInfo) {
  if (sources.slackContext) {
    const contextType = `slack:${sources.slackContext.userId}`;
    const scheduleType = determineScheduleType(
      contextType,
      outputInfo?.outputType,
      outputInfo?.outputTarget
    );
    let allowedScheduleType;
    if (sources.slackContext.channelType) {
      allowedScheduleType = slackChannelTypeToScheduleType(sources.slackContext.channelType);
    }
    let finalScheduleType = scheduleType;
    if (!outputInfo?.outputType && sources.slackContext.channelType) {
      finalScheduleType = slackChannelTypeToScheduleType(sources.slackContext.channelType);
    }
    return {
      userId: sources.slackContext.userId,
      userName: sources.slackContext.userName,
      contextType,
      timezone: sources.slackContext.timezone,
      availableWorkflows,
      scheduleType: finalScheduleType,
      permissions,
      allowedScheduleType
    };
  }
  if (sources.githubContext) {
    return {
      userId: sources.githubContext.login,
      contextType: `github:${sources.githubContext.login}`,
      timezone: "UTC",
      // GitHub doesn't provide timezone
      availableWorkflows,
      scheduleType: "personal",
      permissions,
      allowedScheduleType: "personal"
      // GitHub context only allows personal schedules
    };
  }
  return {
    userId: sources.cliContext?.userId || process.env.USER || "cli-user",
    contextType: "cli",
    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC",
    availableWorkflows,
    scheduleType: "personal",
    permissions,
    allowedScheduleType: "personal"
    // CLI context only allows personal schedules
  };
}
var init_schedule_tool = __esm({
  "src/scheduler/schedule-tool.ts"() {
    "use strict";
    init_schedule_store();
    init_schedule_parser();
    init_logger();
  }
});

// src/state-machine/states/init.ts
async function handleInit(context2, state, transition) {
  if (context2.debug) {
    logger.info("[Init] Initializing state machine...");
  }
  if (!context2.config) {
    throw new Error("Configuration is required");
  }
  if (context2.memory) {
    await context2.memory.initialize();
  }
  if (context2.gitHubChecks) {
    if (context2.debug) {
      logger.info("[Init] GitHub checks service available");
    }
  }
  if (context2.debug) {
    logger.info(`[Init] Session ID: ${context2.sessionId}`);
  }
  transition("PlanReady");
}
var init_init = __esm({
  "src/state-machine/states/init.ts"() {
    "use strict";
    init_logger();
  }
});

// src/state-machine/states/plan-ready.ts
async function handlePlanReady(context2, state, transition) {
  if (context2.debug) {
    logger.info("[PlanReady] Building dependency graph...");
    if (context2.requestedChecks) {
      logger.info(`[PlanReady] Requested checks: ${context2.requestedChecks.join(", ")}`);
    }
    if (context2.config.tag_filter) {
      logger.info(
        `[PlanReady] Tag filter: include=${JSON.stringify(context2.config.tag_filter.include)}, exclude=${JSON.stringify(context2.config.tag_filter.exclude)}`
      );
    } else {
      logger.info("[PlanReady] No tag filter specified - will include only untagged checks");
    }
  }
  const eventTrigger = context2.event;
  const tagFilter = context2.config.tag_filter;
  const expandWithTransitives = (rootChecks) => {
    const expanded = new Set(rootChecks);
    const allowByTags = (checkId) => {
      if (!tagFilter) return true;
      const cfg = context2.config.checks?.[checkId];
      const tags = cfg?.tags || [];
      if (tagFilter.exclude && tagFilter.exclude.some((t) => tags.includes(t))) return false;
      if (tagFilter.include && tagFilter.include.length > 0) {
        return tagFilter.include.some((t) => tags.includes(t));
      }
      return true;
    };
    const allowByEvent = (checkId) => {
      const cfg = context2.config.checks?.[checkId];
      const triggers = cfg?.on || [];
      if (!triggers || triggers.length === 0) return true;
      const current = eventTrigger || "manual";
      return triggers.includes(current);
    };
    const visit = (checkId) => {
      const cfg = context2.config.checks?.[checkId];
      if (!cfg || !cfg.depends_on) return null;
      const depTokens = Array.isArray(cfg.depends_on) ? cfg.depends_on : [cfg.depends_on];
      const expandDep = (tok) => {
        if (tok.includes("|")) {
          return tok.split("|").map((s) => s.trim()).filter(Boolean);
        }
        return [tok];
      };
      const deps = depTokens.flatMap(expandDep);
      for (const depId of deps) {
        if (!context2.config.checks?.[depId]) {
          return `Check "${checkId}" depends on "${depId}" but "${depId}" is not defined`;
        }
        if (!allowByTags(depId)) continue;
        if (!allowByEvent(depId)) continue;
        if (!expanded.has(depId)) {
          expanded.add(depId);
          const err = visit(depId);
          if (err) return err;
        }
      }
      return null;
    };
    for (const checkId of rootChecks) {
      const err = visit(checkId);
      if (err) {
        const validationIssue = {
          file: "system",
          line: 0,
          message: err,
          category: "logic",
          severity: "error",
          ruleId: "system/error"
        };
        context2.journal.commitEntry({
          sessionId: context2.sessionId,
          scope: [],
          checkId: "system",
          result: {
            issues: [validationIssue],
            output: void 0
          }
        });
        return null;
      }
    }
    return expanded;
  };
  const requestedChecksSet = context2.requestedChecks ? expandWithTransitives(context2.requestedChecks) : void 0;
  if (context2.requestedChecks && requestedChecksSet === null) {
    logger.error(`[PlanReady] Dependency validation failed during expansion`);
    state.currentState = "Completed";
    return;
  }
  if (context2.debug && requestedChecksSet && context2.requestedChecks) {
    const added = Array.from(requestedChecksSet).filter((c) => !context2.requestedChecks.includes(c));
    if (added.length > 0) {
      logger.info(
        `[PlanReady] Expanded requested checks with transitive dependencies: ${added.join(", ")}`
      );
    }
  }
  const filteredChecks = {};
  const routingRunTargets = /* @__PURE__ */ new Set();
  for (const [, cfg] of Object.entries(context2.config.checks || {})) {
    const onFinish = cfg.on_finish || {};
    const onSuccess = cfg.on_success || {};
    const onFail = cfg.on_fail || {};
    const collect = (arr) => {
      if (Array.isArray(arr)) {
        for (const t of arr) if (typeof t === "string" && t) routingRunTargets.add(t);
      }
    };
    collect(onFinish.run);
    collect(onSuccess.run);
    collect(onFail.run);
  }
  for (const [checkId, checkConfig] of Object.entries(context2.config.checks || {})) {
    if (requestedChecksSet && !requestedChecksSet.has(checkId)) {
      if (context2.debug) {
        logger.info(
          `[PlanReady] Skipping check '${checkId}': not in expanded requested checks list`
        );
      }
      continue;
    }
    if (!requestedChecksSet && routingRunTargets.has(checkId)) {
      if (context2.debug) {
        logger.info(
          `[PlanReady] Skipping check '${checkId}': routing-run target (will be scheduled by on_*.run)`
        );
      }
      continue;
    }
    if (checkConfig.on && eventTrigger && !checkConfig.on.includes(eventTrigger)) {
      if (context2.debug) {
        logger.info(
          `[PlanReady] Skipping check '${checkId}': on=${JSON.stringify(checkConfig.on)}, event=${eventTrigger}`
        );
      }
      continue;
    }
    const checkTags = checkConfig.tags || [];
    const isTagged = checkTags.length > 0;
    if (tagFilter) {
      if (tagFilter.exclude && tagFilter.exclude.length > 0) {
        const hasExcludedTag = tagFilter.exclude.some((tag) => checkTags.includes(tag));
        if (hasExcludedTag) {
          if (context2.debug) {
            logger.info(`[PlanReady] Skipping check '${checkId}': excluded by tag filter`);
          }
          continue;
        }
      }
      if (tagFilter.include && tagFilter.include.length > 0) {
        const hasIncludedTag = tagFilter.include.some((tag) => checkTags.includes(tag));
        if (!hasIncludedTag && isTagged) {
          if (context2.debug) {
            logger.info(`[PlanReady] Skipping check '${checkId}': not included by tag filter`);
          }
          continue;
        }
      }
    } else {
      if (isTagged) {
        if (context2.debug) {
          logger.info(
            `[PlanReady] Skipping check '${checkId}': tagged but no tag filter specified`
          );
        }
        continue;
      }
    }
    filteredChecks[checkId] = checkConfig;
  }
  if (context2.debug) {
    const totalChecks = Object.keys(context2.config.checks || {}).length;
    const filteredCount = Object.keys(filteredChecks).length;
    logger.info(
      `[PlanReady] Filtered ${totalChecks} checks to ${filteredCount} based on event=${eventTrigger}`
    );
  }
  if (!context2.requestedChecks || context2.requestedChecks.length === 0) {
    const dependentsMap = /* @__PURE__ */ new Map();
    for (const [cid, cfg] of Object.entries(context2.config.checks || {})) {
      const deps = cfg.depends_on || [];
      const depList = Array.isArray(deps) ? deps : [deps];
      for (const raw of depList) {
        if (typeof raw !== "string") continue;
        const tokens = raw.includes("|") ? raw.split("|").map((s) => s.trim()).filter(Boolean) : [raw];
        for (const dep of tokens) {
          if (!dependentsMap.has(dep)) dependentsMap.set(dep, []);
          dependentsMap.get(dep).push(cid);
        }
      }
    }
    const queue = Object.keys(filteredChecks);
    const seenForward = new Set(queue);
    while (queue.length > 0) {
      const cur = queue.shift();
      const kids = dependentsMap.get(cur) || [];
      for (const child of kids) {
        if (seenForward.has(child)) continue;
        const cfg = context2.config.checks?.[child];
        if (!cfg) continue;
        if (cfg.on && eventTrigger && !cfg.on.includes(eventTrigger)) continue;
        const tags = cfg.tags || [];
        const isTagged = tags.length > 0;
        if (!tagFilter && isTagged) continue;
        if (tagFilter) {
          if (tagFilter.exclude && tagFilter.exclude.length > 0) {
            const hasExcluded = tagFilter.exclude.some((t) => tags.includes(t));
            if (hasExcluded) continue;
          }
          if (tagFilter.include && tagFilter.include.length > 0) {
            const hasIncluded = tagFilter.include.some((t) => tags.includes(t));
            if (!hasIncluded && isTagged) continue;
          }
        }
        filteredChecks[child] = cfg;
        seenForward.add(child);
        queue.push(child);
        if (context2.debug)
          logger.info(`[PlanReady] Added dependent '${child}' via forward-closure from '${cur}'`);
      }
    }
  }
  const areDependenciesSatisfied = (dependencies) => {
    for (const dep of dependencies) {
      if (dep.includes("|")) {
        const orOptions = dep.split("|").map((s) => s.trim()).filter(Boolean);
        const hasAtLeastOne = orOptions.some((opt) => filteredChecks[opt] !== void 0);
        if (!hasAtLeastOne) {
          return false;
        }
      } else {
        if (filteredChecks[dep] === void 0) {
          return false;
        }
      }
    }
    return true;
  };
  const finalChecks = {};
  for (const [checkId, checkConfig] of Object.entries(filteredChecks)) {
    const depRaw = checkConfig.depends_on;
    const dependencies = Array.isArray(depRaw) ? depRaw : typeof depRaw === "string" ? [depRaw] : [];
    if (dependencies.length > 0 && !tagFilter && !areDependenciesSatisfied(dependencies)) {
      if (context2.debug) {
        logger.info(
          `[PlanReady] Skipping check '${checkId}': unsatisfied dependencies ${JSON.stringify(dependencies)}`
        );
      }
      continue;
    }
    finalChecks[checkId] = checkConfig;
  }
  if (context2.debug && Object.keys(finalChecks).length !== Object.keys(filteredChecks).length) {
    logger.info(
      `[PlanReady] Removed ${Object.keys(filteredChecks).length - Object.keys(finalChecks).length} checks due to unsatisfied dependencies`
    );
  }
  const checkDependencies = {};
  for (const [checkId, checkConfig] of Object.entries(finalChecks)) {
    const depsRaw2 = checkConfig.depends_on;
    const depList = Array.isArray(depsRaw2) ? depsRaw2 : typeof depsRaw2 === "string" ? [depsRaw2] : [];
    const dependencies = depList.flatMap((d) => {
      if (typeof d === "string" && d.includes("|")) {
        const orOptions = d.split("|").map((s) => s.trim()).filter(Boolean).filter((opt) => finalChecks[opt] !== void 0);
        return orOptions;
      } else {
        if (tagFilter && finalChecks[d] === void 0) {
          if (context2.debug) {
            logger.info(
              `[PlanReady] Soft dependency '${d}' of check '${checkId}' filtered out by tags - check will run without it`
            );
          }
          return [];
        }
        return [d];
      }
    });
    checkDependencies[checkId] = dependencies;
  }
  let graph;
  try {
    graph = DependencyResolver.buildDependencyGraph(checkDependencies);
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    logger.error(`[PlanReady] Dependency validation failed: ${errorMsg}`);
    const validationIssue = {
      file: "system",
      line: 0,
      message: errorMsg,
      category: "logic",
      severity: "error",
      ruleId: "system/error"
    };
    context2.journal.commitEntry({
      sessionId: context2.sessionId,
      scope: [],
      checkId: "system",
      result: {
        issues: [validationIssue],
        output: void 0
      }
    });
    state.currentState = "Completed";
    return;
  }
  if (graph.hasCycles) {
    const cycleNodes = graph.cycleNodes?.join(" -> ") || "unknown";
    const errorMsg = `Dependency cycle detected: ${cycleNodes}`;
    logger.error(`[PlanReady] ${errorMsg}`);
    const cycleIssue = {
      file: "system",
      line: 0,
      message: errorMsg,
      category: "logic",
      severity: "error",
      ruleId: "system/error"
    };
    context2.journal.commitEntry({
      sessionId: context2.sessionId,
      scope: [],
      checkId: "system",
      result: {
        issues: [cycleIssue],
        output: void 0
      }
    });
    state.currentState = "Completed";
    return;
  }
  if (context2.debug) {
    logger.info(
      `[PlanReady] Graph built with ${graph.nodes.size} checks, ${graph.executionOrder.length} levels`
    );
  }
  context2.dependencyGraph = graph;
  state.wave = 0;
  transition("WavePlanning");
}
var init_plan_ready = __esm({
  "src/state-machine/states/plan-ready.ts"() {
    "use strict";
    init_dependency_resolver();
    init_logger();
  }
});

// src/state-machine/states/wave-planning.ts
async function handleWavePlanning(context2, state, transition) {
  if (context2.debug) {
    logger.info(`[WavePlanning] Planning wave ${state.wave}...`);
  }
  try {
    state.flags = state.flags || {};
    state.flags.forwardRunActive = false;
  } catch {
  }
  try {
    const flags = state.flags || {};
    logger.info(
      `[WavePlanning] Checking awaitingHumanInput flag: ${!!flags.awaitingHumanInput} (wave=${state.wave})`
    );
    if (flags.awaitingHumanInput) {
      logger.info("[WavePlanning] Awaiting human input \u2013 finishing run without further waves");
      state.levelQueue = [];
      state.eventQueue = [];
      transition("Completed");
      return;
    }
  } catch (e) {
    logger.warn(`[WavePlanning] Failed to check awaitingHumanInput flag: ${e}`);
  }
  if (!context2.dependencyGraph) {
    if (state.wave === 0 && state.levelQueue.length === 0) {
      throw new Error("Dependency graph not available");
    }
  }
  const bubbledEvents = context2._bubbledEvents || [];
  if (bubbledEvents.length > 0) {
    if (context2.debug) {
      logger.info(
        `[WavePlanning] Processing ${bubbledEvents.length} bubbled events from child workflows`
      );
    }
    for (const event of bubbledEvents) {
      state.eventQueue.push(event);
    }
    context2._bubbledEvents = [];
  }
  const forwardRunRequests = state.eventQueue.filter(
    (e) => e.type === "ForwardRunRequested"
  );
  if (forwardRunRequests.length > 0 && (state.levelQueue.length === 0 || forwardRunRequests.some((r) => r.origin === "goto" || r.origin === "goto_js"))) {
    if (state.levelQueue.length > 0) {
      if (context2.debug) {
        logger.info(
          `[WavePlanning] Preempting ${state.levelQueue.length} remaining levels due to goto forward-run request`
        );
      }
      state.levelQueue = [];
    }
    if (context2.debug) {
      logger.info(`[WavePlanning] Processing ${forwardRunRequests.length} forward run requests`);
    }
    state.eventQueue = state.eventQueue.filter((e) => e.type !== "ForwardRunRequested");
    const checksToRun = /* @__PURE__ */ new Set();
    if (!state.pendingRunScopes) state.pendingRunScopes = /* @__PURE__ */ new Map();
    const eventOverrides = /* @__PURE__ */ new Map();
    for (const request of forwardRunRequests) {
      const { target, gotoEvent } = request;
      const scopeKey = request.scope && Array.isArray(request.scope) ? JSON.stringify(request.scope) : "root";
      const dedupeKey = `${target}:${gotoEvent || "default"}:${state.wave}:${scopeKey}`;
      if (state.forwardRunGuards.has(dedupeKey)) {
        if (context2.debug) {
          logger.info(`[WavePlanning] Skipping duplicate forward run: ${target}`);
        }
        continue;
      }
      state.forwardRunGuards.add(dedupeKey);
      checksToRun.add(target);
      try {
        const scope = request.scope;
        if (scope && scope.length > 0) {
          const arr = state.pendingRunScopes.get(target) || [];
          const key = (s) => JSON.stringify(s);
          if (!arr.some((s) => key(s) === key(scope))) arr.push(scope);
          state.pendingRunScopes.set(target, arr);
        }
      } catch {
      }
      if (gotoEvent) {
        eventOverrides.set(target, gotoEvent);
      }
      const sourceCheck = request.sourceCheck;
      if (sourceCheck && request.origin === "run") {
        if (!state.allowedFailedDeps) {
          state.allowedFailedDeps = /* @__PURE__ */ new Map();
        }
        const allowedSet = state.allowedFailedDeps.get(target) || /* @__PURE__ */ new Set();
        allowedSet.add(sourceCheck);
        state.allowedFailedDeps.set(target, allowedSet);
        if (context2.debug) {
          logger.info(
            `[WavePlanning] Allowing ${target} to run despite failed dependency ${sourceCheck}`
          );
        }
      }
      const origin = request.origin;
      const dependencies = findTransitiveDependencies(target, context2);
      for (const dep of dependencies) {
        const stats = state.stats.get(dep);
        const hasSucceeded = !!stats && (stats.successfulRuns || 0) > 0;
        const hasRun = !!stats && (stats.totalRuns || 0) > 0;
        if (origin === "run" && hasRun) {
          continue;
        }
        if (!hasSucceeded) {
          checksToRun.add(dep);
        }
      }
      let shouldIncludeDependents = true;
      try {
        const origin2 = request.origin;
        const cfg = context2.config.checks?.[target];
        const targetType = String(cfg?.type || "").toLowerCase();
        const execCtx = context2.executionContext || {};
        const hasWebhook = !!execCtx.webhookContext;
        if (hasWebhook && (origin2 === "goto" || origin2 === "goto_js") && targetType === "human-input") {
          shouldIncludeDependents = false;
        }
      } catch {
      }
      if (shouldIncludeDependents) {
        const dependents = findTransitiveDependents(target, context2, gotoEvent);
        for (const dep of dependents) {
          checksToRun.add(dep);
        }
      }
    }
    if (checksToRun.size > 0) {
      const subgraphChecks = Array.from(checksToRun);
      const subDeps = {};
      for (const checkId of subgraphChecks) {
        const checkConfig = context2.config.checks?.[checkId];
        if (!checkConfig) continue;
        const deps = checkConfig.depends_on || [];
        const depList = Array.isArray(deps) ? deps : [deps];
        const expanded = depList.flatMap(
          (d) => typeof d === "string" && d.includes("|") ? d.split("|").map((s) => s.trim()).filter(Boolean) : [d]
        );
        subDeps[checkId] = expanded.filter((d) => checksToRun.has(d));
      }
      const subGraph = DependencyResolver.buildDependencyGraph(subDeps);
      if (subGraph.hasCycles) {
        const cycleNodes = subGraph.cycleNodes?.join(" -> ") || "unknown";
        const errorMsg = `Cycle detected in forward-run dependency subset: ${cycleNodes}`;
        logger.error(`[WavePlanning] ${errorMsg}`);
        const firstCycleCheck = subGraph.cycleNodes?.[0];
        if (firstCycleCheck) {
          const checkStats = {
            checkName: firstCycleCheck,
            totalRuns: 1,
            // Count as 1 execution attempt
            successfulRuns: 0,
            failedRuns: 1,
            skippedRuns: 0,
            skipped: false,
            totalDuration: 0,
            issuesFound: 0,
            issuesBySeverity: {
              critical: 0,
              error: 1,
              warning: 0,
              info: 0
            },
            errorMessage: errorMsg
          };
          state.stats.set(firstCycleCheck, checkStats);
        }
        transition("Completed");
        return;
      }
      state.levelQueue = [...subGraph.executionOrder];
      if (context2.debug) {
        const planned = subgraphChecks.join(", ");
        logger.info(
          `[WavePlanning] Forward-run planning: checks=[${planned}] levels=${state.levelQueue.length}`
        );
      }
      if (context2.debug) {
        logger.info(
          `[WavePlanning] Queued ${state.levelQueue.length} levels for ${checksToRun.size} checks (forward run)`
        );
      }
      state.wave++;
      state.currentWaveCompletions = /* @__PURE__ */ new Set();
      state.failedChecks = /* @__PURE__ */ new Set();
      state.flags.forwardRunRequested = false;
      try {
        state.flags.forwardRunActive = true;
        state.flags.waveKind = "forward";
      } catch {
      }
      transition("LevelDispatch");
      return;
    }
  }
  const waveRetryEvents = state.eventQueue.filter((e) => e.type === "WaveRetry");
  if (waveRetryEvents.length > 0 && state.levelQueue.length === 0 && !state.eventQueue.some((e) => e.type === "ForwardRunRequested")) {
    logger.info(`[WavePlanning] Processing wave retry requests (${waveRetryEvents.length} events)`);
    state.eventQueue = state.eventQueue.filter((e) => e.type !== "WaveRetry");
    const skippedIfChecks = /* @__PURE__ */ new Set();
    logger.info(`[WavePlanning] Scanning ${state.stats.size} stat entries for skipped-if checks`);
    for (const [name, stats] of state.stats.entries()) {
      logger.info(
        `[WavePlanning] Check ${name}: skipped=${stats.skipped}, skipReason=${stats.skipReason}`
      );
      if (stats.skipped === true && stats.skipReason === "if_condition") {
        skippedIfChecks.add(name);
        logger.info(`[WavePlanning] Found skipped-if check for retry: ${name}`);
      }
    }
    logger.info(`[WavePlanning] Total skipped-if checks: ${skippedIfChecks.size}`);
    if (skippedIfChecks.size === 0) {
      transition("Completed");
      return;
    }
    const checksToRun = Array.from(skippedIfChecks).filter(
      (id) => !context2.config.checks?.[id]?.forEach
    );
    const subDeps = {};
    for (const id of checksToRun) {
      const cfg = context2.config.checks?.[id];
      const rawDeps = cfg?.depends_on;
      const depsArray = Array.isArray(rawDeps) ? rawDeps : rawDeps ? [rawDeps] : [];
      const deps = depsArray.filter((d) => checksToRun.includes(d));
      subDeps[id] = deps;
    }
    const subGraph = DependencyResolver.buildDependencyGraph(subDeps);
    state.levelQueue = [...subGraph.executionOrder];
    if (context2.debug) {
      logger.info(
        `[WavePlanning] Wave retry queued ${checksToRun.length} skipped-if check(s) in ${state.levelQueue.length} level(s)`
      );
    }
    state.wave++;
    state.currentWaveCompletions = /* @__PURE__ */ new Set();
    state.failedChecks = /* @__PURE__ */ new Set();
    try {
      state.flags = state.flags || {};
      state.flags.forwardRunActive = true;
      state.flags.waveKind = "retry";
    } catch {
    }
    transition("LevelDispatch");
    return;
  }
  if (state.wave === 0 && state.levelQueue.length === 0) {
    if (!context2.dependencyGraph) {
      throw new Error("Dependency graph not available");
    }
    state.levelQueue = [...context2.dependencyGraph.executionOrder];
    if (context2.debug) {
      logger.info(
        `[WavePlanning] Queued ${state.levelQueue.length} levels for execution (initial wave)`
      );
    }
    state.wave++;
    state.currentWaveCompletions = /* @__PURE__ */ new Set();
    state.failedChecks = /* @__PURE__ */ new Set();
    try {
      state.flags = state.flags || {};
      state.flags.waveKind = "initial";
    } catch {
    }
  }
  if (state.levelQueue.length > 0) {
    transition("LevelDispatch");
  } else {
    if (state.eventQueue.length > 0) {
      if (context2.debug) {
        logger.warn(
          `[WavePlanning] Event queue not empty (${state.eventQueue.length} events) but no work scheduled`
        );
      }
    }
    if (context2.debug) {
      logger.info("[WavePlanning] All waves complete");
    }
    transition("Completed");
  }
}
function findTransitiveDependencies(target, context2) {
  const dependencies = /* @__PURE__ */ new Set();
  const checks = context2.config.checks || {};
  const visited = /* @__PURE__ */ new Set();
  const dfs = (checkId) => {
    if (visited.has(checkId)) return;
    visited.add(checkId);
    const checkConfig = checks[checkId];
    if (!checkConfig) return;
    const deps = checkConfig.depends_on || [];
    const depList = Array.isArray(deps) ? deps : [deps];
    for (const depId of depList) {
      if (typeof depId !== "string") continue;
      if (depId.includes("|")) {
        const orOptions = depId.split("|").map((s) => s.trim()).filter(Boolean);
        for (const opt of orOptions) {
          if (checks[opt]) {
            const optCfg = checks[opt];
            if (String(optCfg?.type || "").toLowerCase() === "memory" && String(optCfg?.operation || "").toLowerCase() === "set") {
              continue;
            }
            dependencies.add(opt);
            dfs(opt);
          }
        }
      } else {
        if (checks[depId]) {
          const dCfg = checks[depId];
          if (String(dCfg?.type || "").toLowerCase() === "memory" && String(dCfg?.operation || "").toLowerCase() === "set") {
            continue;
          }
          dependencies.add(depId);
          dfs(depId);
        }
      }
    }
  };
  dfs(target);
  return dependencies;
}
function findTransitiveDependents(target, context2, gotoEvent) {
  const dependents = /* @__PURE__ */ new Set();
  const checks = context2.config.checks || {};
  if (context2.debug) {
    logger.info(
      `[WavePlanning] findTransitiveDependents called for target=${target}, gotoEvent=${gotoEvent}`
    );
  }
  const dependsOn = (checkId, depId) => {
    const visited = /* @__PURE__ */ new Set();
    const dfs = (current) => {
      if (visited.has(current)) return false;
      visited.add(current);
      const checkConfig = checks[current];
      if (!checkConfig) return false;
      const deps = checkConfig.depends_on || [];
      const depList = Array.isArray(deps) ? deps : [deps];
      for (const dep of depList) {
        if (typeof dep !== "string") continue;
        if (dep.includes("|")) {
          const orOptions = dep.split("|").map((s) => s.trim());
          if (orOptions.includes(depId)) return true;
        } else {
          if (dep === depId) return true;
        }
      }
      for (const d of depList) {
        if (dfs(d)) return true;
      }
      return false;
    };
    return dfs(checkId);
  };
  for (const checkId of Object.keys(checks)) {
    if (checkId === target) continue;
    const checkConfig = checks[checkId];
    if (!checkConfig) continue;
    const isDep = dependsOn(checkId, target);
    if (context2.debug && isDep) {
      logger.info(`[WavePlanning] findTransitiveDependents: ${checkId} depends on ${target}`);
    }
    if (!isDep) continue;
    if (gotoEvent) {
      const triggers = checkConfig.on;
      if (Array.isArray(triggers) && triggers.length > 0) {
        if (!triggers.includes(gotoEvent)) {
          if (context2.debug) {
            logger.info(`[WavePlanning] Skipping ${checkId}: doesn't run for event ${gotoEvent}`);
          }
          continue;
        }
      }
    }
    dependents.add(checkId);
    if (context2.debug) {
      logger.info(`[WavePlanning] Added dependent: ${checkId}`);
    }
  }
  return dependents;
}
var init_wave_planning = __esm({
  "src/state-machine/states/wave-planning.ts"() {
    "use strict";
    init_logger();
    init_dependency_resolver();
  }
});

// src/utils/mermaid-telemetry.ts
import * as fs3 from "fs";
import * as path4 from "path";
function emitMermaidFromMarkdown(checkName, markdown, origin) {
  if (!markdown || typeof markdown !== "string") return 0;
  let m;
  let count = 0;
  MERMAID_RE.lastIndex = 0;
  while ((m = MERMAID_RE.exec(markdown)) != null) {
    const code = (m[1] || "").trim();
    if (code) {
      try {
        addEvent("diagram.block", { check: checkName, origin, code });
        addDiagramBlock(origin);
        if (process.env.VISOR_TRACE_REPORT === "true") {
          const outDir = process.env.VISOR_TRACE_DIR || path4.join(process.cwd(), "output", "traces");
          try {
            if (!fs3.existsSync(outDir)) fs3.mkdirSync(outDir, { recursive: true });
            const ts = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
            const jsonPath = path4.join(outDir, `${ts}.trace.json`);
            const htmlPath = path4.join(outDir, `${ts}.report.html`);
            let data = { spans: [] };
            if (fs3.existsSync(jsonPath)) {
              try {
                data = JSON.parse(fs3.readFileSync(jsonPath, "utf8"));
              } catch {
                data = { spans: [] };
              }
            }
            data.spans.push({
              events: [{ name: "diagram.block", attrs: { check: checkName, origin, code } }]
            });
            fs3.writeFileSync(jsonPath, JSON.stringify(data, null, 2), "utf8");
            if (!fs3.existsSync(htmlPath)) {
              fs3.writeFileSync(
                htmlPath,
                '<!doctype html><html><head><meta charset="utf-8"/><title>Visor Trace Report</title></head><body><h2>Visor Trace Report</h2></body></html>',
                "utf8"
              );
            }
          } catch {
          }
        }
        count++;
      } catch {
      }
    }
  }
  return count;
}
var MERMAID_RE;
var init_mermaid_telemetry = __esm({
  "src/utils/mermaid-telemetry.ts"() {
    "use strict";
    init_trace_helpers();
    init_metrics();
    MERMAID_RE = /```mermaid\s*\n([\s\S]*?)\n```/gi;
  }
});

// src/state-machine/context/workflow-inputs.ts
function resolveWorkflowInputs(checkConfig, context2) {
  if (checkConfig?.workflowInputs) {
    return checkConfig.workflowInputs;
  }
  if (context2.config?.workflow_inputs) {
    return context2.config.workflow_inputs;
  }
  if (context2.executionContext?.workflowInputs) {
    return context2.executionContext.workflowInputs;
  }
  return void 0;
}
var init_workflow_inputs = __esm({
  "src/state-machine/context/workflow-inputs.ts"() {
    "use strict";
  }
});

// src/sandbox/env-filter.ts
function matchesPattern(name, pattern) {
  if (pattern === name) return true;
  if (pattern.endsWith("*")) {
    const prefix = pattern.slice(0, -1);
    return name.startsWith(prefix);
  }
  return false;
}
function filterEnvForSandbox(checkEnv, hostEnv, passthroughPatterns, defaultPatterns) {
  const result = {};
  const defaults = defaultPatterns !== void 0 ? defaultPatterns : BUILTIN_PASSTHROUGH;
  const patterns = [...defaults, ...passthroughPatterns || []];
  for (const [key, value] of Object.entries(hostEnv)) {
    if (value === void 0) continue;
    if (patterns.some((pattern) => matchesPattern(key, pattern))) {
      result[key] = value;
    }
  }
  if (checkEnv) {
    for (const [key, value] of Object.entries(checkEnv)) {
      result[key] = String(value);
    }
  }
  return result;
}
var BUILTIN_PASSTHROUGH;
var init_env_filter = __esm({
  "src/sandbox/env-filter.ts"() {
    "use strict";
    BUILTIN_PASSTHROUGH = ["PATH", "HOME", "USER", "CI", "NODE_ENV", "LANG"];
  }
});

// src/sandbox/sandbox-telemetry.ts
function getTraceHelpers() {
  if (_attempted) return _traceHelpers;
  _attempted = true;
  try {
    _traceHelpers = (init_trace_helpers(), __toCommonJS(trace_helpers_exports));
  } catch {
    _traceHelpers = null;
  }
  return _traceHelpers;
}
async function withActiveSpan2(name, attrs, fn) {
  const helpers = getTraceHelpers();
  if (helpers) {
    return helpers.withActiveSpan(name, attrs, fn);
  }
  return fn({});
}
function addEvent2(name, attrs) {
  const helpers = getTraceHelpers();
  if (helpers) {
    helpers.addEvent(name, attrs);
  }
}
function setSpanError(err) {
  const helpers = getTraceHelpers();
  if (helpers) {
    helpers.setSpanError(err);
  }
}
var _traceHelpers, _attempted;
var init_sandbox_telemetry = __esm({
  "src/sandbox/sandbox-telemetry.ts"() {
    "use strict";
    _traceHelpers = null;
    _attempted = false;
  }
});

// src/sandbox/trace-ingester.ts
import { readFileSync as readFileSync3 } from "fs";
function getTracer() {
  try {
    const helpers = (init_trace_helpers(), __toCommonJS(trace_helpers_exports));
    return helpers.getTracer();
  } catch {
    return null;
  }
}
function getOtelContext() {
  try {
    return init_lazy_otel(), __toCommonJS(lazy_otel_exports);
  } catch {
    return null;
  }
}
function ingestChildTrace(filePath) {
  let content;
  try {
    content = readFileSync3(filePath, "utf8");
  } catch {
    return;
  }
  const lines = content.split("\n");
  const spans = [];
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed) continue;
    try {
      spans.push(JSON.parse(trimmed));
    } catch {
    }
  }
  if (spans.length === 0) return;
  const tracer = getTracer();
  if (!tracer) {
    logger.info(`[trace-ingester] ${spans.length} child spans (OTel unavailable)`);
    return;
  }
  const otel = getOtelContext();
  for (const child of spans) {
    if (!child.name) continue;
    if (child.name === "visor.run" || child.name === "visor.event") continue;
    if (!child.traceId && !child.startTime) continue;
    try {
      const spanOptions = {
        attributes: {
          "visor.sandbox.child_span": true,
          ...child.attributes || {}
        }
      };
      if (child.startTime) {
        spanOptions.startTime = child.startTime;
      }
      const span = tracer.startSpan(`child: ${child.name}`, spanOptions);
      if (Array.isArray(child.events)) {
        for (const evt of child.events) {
          const evtAttrs = evt.attributes || evt.attrs || {};
          if (evt.time) {
            span.addEvent(evt.name, evtAttrs, evt.time);
          } else {
            span.addEvent(evt.name, evtAttrs);
          }
        }
      }
      if (child.status && child.status.code === 2) {
        try {
          const { SpanStatusCode } = otel || {};
          span.setStatus({
            code: SpanStatusCode?.ERROR || 2,
            message: child.status.message
          });
        } catch {
        }
      }
      if (child.endTime) {
        span.end(child.endTime);
      } else {
        span.end();
      }
    } catch {
    }
  }
}
var init_trace_ingester = __esm({
  "src/sandbox/trace-ingester.ts"() {
    "use strict";
    init_logger();
  }
});

// src/sandbox/check-runner.ts
var check_runner_exports = {};
__export(check_runner_exports, {
  CheckRunner: () => CheckRunner
});
import { writeFileSync as writeFileSync2, existsSync as existsSync3, unlinkSync } from "fs";
import { join as join4 } from "path";
import { randomUUID } from "crypto";
function serializePRInfo(prInfo) {
  return {
    number: prInfo.number,
    title: prInfo.title,
    body: prInfo.body,
    author: prInfo.author,
    base: prInfo.base,
    head: prInfo.head,
    files: (prInfo.files || []).map((f) => ({
      filename: f.filename,
      status: f.status,
      additions: f.additions,
      deletions: f.deletions,
      changes: f.changes,
      patch: f.patch
    })),
    totalAdditions: prInfo.totalAdditions,
    totalDeletions: prInfo.totalDeletions,
    eventType: prInfo.eventType,
    fullDiff: prInfo.fullDiff,
    commitDiff: prInfo.commitDiff,
    isIncremental: prInfo.isIncremental,
    isIssue: prInfo.isIssue,
    eventContext: prInfo.eventContext
  };
}
var CheckRunner;
var init_check_runner = __esm({
  "src/sandbox/check-runner.ts"() {
    "use strict";
    init_env_filter();
    init_logger();
    init_sandbox_telemetry();
    init_trace_ingester();
    CheckRunner = class {
      /**
       * Execute a check inside a sandbox container.
       *
       * 1. Build CheckRunPayload JSON
       * 2. Filter env vars through EnvFilter
       * 3. Exec `node <visor_path>/cli-main.js --run-check` inside the sandbox
       * 4. Parse CheckRunResult from stdout JSON
       * 5. Return as ReviewSummary
       */
      static async runCheck(sandboxManager, sandboxName, sandboxConfig, checkConfig, prInfo, dependencyResults, timeoutMs, workspaceDefaults) {
        return withActiveSpan2(
          "visor.sandbox.runCheck",
          {
            "visor.sandbox.name": sandboxName,
            "visor.check.name": checkConfig.name || "unknown"
          },
          async () => {
            const dependencyOutputs = {};
            if (dependencyResults) {
              for (const [key, value] of dependencyResults) {
                dependencyOutputs[key] = value;
              }
            }
            const payload = {
              check: checkConfig,
              prInfo: serializePRInfo(prInfo),
              dependencyOutputs: Object.keys(dependencyOutputs).length > 0 ? dependencyOutputs : void 0
            };
            const env = filterEnvForSandbox(
              checkConfig.env,
              process.env,
              sandboxConfig.env_passthrough,
              workspaceDefaults?.env_passthrough
            );
            const workdir = sandboxConfig.workdir || "/workspace";
            let hostTracePath;
            if (!sandboxConfig.read_only) {
              const traceFileName = `.visor-trace-${randomUUID().slice(0, 8)}.ndjson`;
              hostTracePath = join4(sandboxManager.getRepoPath(), traceFileName);
              const containerTracePath = `${workdir}/${traceFileName}`;
              try {
                writeFileSync2(hostTracePath, "", "utf8");
              } catch {
                hostTracePath = void 0;
              }
              if (hostTracePath) {
                env["VISOR_FALLBACK_TRACE_FILE"] = containerTracePath;
                env["VISOR_TELEMETRY_ENABLED"] = "true";
                env["VISOR_TELEMETRY_SINK"] = "file";
              }
            }
            const visorPath = sandboxConfig.visor_path || "/opt/visor";
            if (!/^[a-zA-Z0-9/_.-]+$/.test(visorPath) || /\.\./.test(visorPath)) {
              throw new Error(
                `Invalid visor_path '${visorPath}': must be a safe absolute path without '..' traversal`
              );
            }
            const payloadJson = JSON.stringify(payload);
            env["NODE_PATH"] = `${workdir}/node_modules`;
            const b64Payload = Buffer.from(payloadJson).toString("base64");
            if (!/^[A-Za-z0-9+/=]+$/.test(b64Payload)) {
              throw new Error("Unexpected characters in base64-encoded payload");
            }
            const command = `echo ${b64Payload} | base64 -d | node ${visorPath}/index.js --run-check -`;
            logger.info(`Executing check in sandbox '${sandboxName}'`);
            const result = await sandboxManager.exec(sandboxName, {
              command,
              env,
              timeoutMs: timeoutMs || 6e5,
              maxBuffer: 50 * 1024 * 1024
            });
            if (hostTracePath) {
              try {
                if (existsSync3(hostTracePath)) {
                  ingestChildTrace(hostTracePath);
                  unlinkSync(hostTracePath);
                }
              } catch {
                try {
                  if (existsSync3(hostTracePath)) unlinkSync(hostTracePath);
                } catch {
                }
              }
            }
            const stdout = result.stdout.trim();
            if (result.exitCode !== 0 && !stdout) {
              setSpanError(new Error(`Sandbox execution failed (exit ${result.exitCode})`));
              return {
                issues: [
                  {
                    severity: "error",
                    message: `Sandbox execution failed (exit ${result.exitCode}): ${result.stderr.slice(0, 500)}`,
                    file: "",
                    line: 0,
                    ruleId: "sandbox-execution-error",
                    category: "logic"
                  }
                ]
              };
            }
            const lines = stdout.split("\n");
            let jsonLine;
            for (let i = lines.length - 1; i >= 0; i--) {
              const line = lines[i].trim();
              if (line.startsWith("{")) {
                jsonLine = line;
                break;
              }
            }
            if (!jsonLine) {
              setSpanError(new Error("No JSON output from sandboxed check"));
              return {
                issues: [
                  {
                    severity: "error",
                    message: `No JSON output from sandboxed check. Stdout: ${stdout.slice(0, 500)}`,
                    file: "",
                    line: 0,
                    ruleId: "sandbox-parse-error",
                    category: "logic"
                  }
                ]
              };
            }
            let checkRunResult;
            try {
              checkRunResult = JSON.parse(jsonLine);
            } catch (parseErr) {
              setSpanError(parseErr);
              return {
                issues: [
                  {
                    severity: "error",
                    message: `Invalid JSON from sandboxed check: ${jsonLine.slice(0, 200)}`,
                    file: "",
                    line: 0,
                    ruleId: "sandbox-parse-error",
                    category: "logic"
                  }
                ]
              };
            }
            const summary = {
              issues: checkRunResult.issues || [],
              debug: checkRunResult.debug
            };
            if (checkRunResult.output !== void 0) {
              summary.output = checkRunResult.output;
            }
            if (checkRunResult.content !== void 0) {
              summary.content = checkRunResult.content;
            }
            return summary;
          }
        );
      }
    };
  }
});

// src/state-machine/dispatch/sandbox-routing.ts
async function executeWithSandboxRouting(checkId, checkConfig, context2, prInfo, dependencyResults, timeout, hostExecute) {
  const sandboxManager = context2.sandboxManager;
  if (!sandboxManager) {
    return hostExecute();
  }
  const sandboxName = sandboxManager.resolveSandbox(
    checkConfig.sandbox,
    context2.config.sandbox
  );
  if (!sandboxName) {
    return hostExecute();
  }
  const sandboxConfig = context2.config.sandboxes?.[sandboxName];
  if (!sandboxConfig) {
    throw new Error(`Sandbox '${sandboxName}' not found in sandboxes configuration`);
  }
  logger.info(`[SandboxRouting] Routing check '${checkId}' to sandbox '${sandboxName}'`);
  const { CheckRunner: CheckRunner2 } = (init_check_runner(), __toCommonJS(check_runner_exports));
  return CheckRunner2.runCheck(
    sandboxManager,
    sandboxName,
    sandboxConfig,
    checkConfig,
    prInfo,
    dependencyResults.size > 0 ? dependencyResults : void 0,
    timeout,
    context2.config.sandbox_defaults
  );
}
var init_sandbox_routing = __esm({
  "src/state-machine/dispatch/sandbox-routing.ts"() {
    "use strict";
    init_logger();
  }
});

// src/state-machine/dispatch/history-snapshot.ts
var history_snapshot_exports = {};
__export(history_snapshot_exports, {
  buildOutputHistoryFromJournal: () => buildOutputHistoryFromJournal
});
function getHistoryLimit() {
  const raw = process.env.VISOR_TEST_HISTORY_LIMIT || process.env.VISOR_OUTPUT_HISTORY_LIMIT;
  if (!raw) return void 0;
  const n = parseInt(raw, 10);
  return Number.isFinite(n) && n > 0 ? n : void 0;
}
function buildOutputHistoryFromJournal(context2) {
  const outputHistory = /* @__PURE__ */ new Map();
  const limit = getHistoryLimit();
  try {
    const snapshot = context2.journal.beginSnapshot();
    const allEntries = context2.journal.readVisible(context2.sessionId, snapshot, void 0);
    for (const entry of allEntries) {
      const checkId = entry.checkId;
      if (!outputHistory.has(checkId)) {
        outputHistory.set(checkId, []);
      }
      try {
        if (entry && typeof entry.result === "object" && entry.result.__skipped) {
          continue;
        }
      } catch {
      }
      const payload = entry.result.output !== void 0 ? entry.result.output : entry.result;
      try {
        if (payload && typeof payload === "object" && payload.forEachItems && Array.isArray(payload.forEachItems)) {
          continue;
        }
      } catch {
      }
      if (payload !== void 0) {
        const arr = outputHistory.get(checkId);
        arr.push(payload);
        if (limit && arr.length > limit) {
          arr.splice(0, arr.length - limit);
        }
      }
    }
  } catch (error) {
    logger.debug(`[LevelDispatch] Error building output history: ${error}`);
  }
  return outputHistory;
}
var init_history_snapshot = __esm({
  "src/state-machine/dispatch/history-snapshot.ts"() {
    "use strict";
    init_logger();
  }
});

// src/state-machine/dispatch/dependency-gating.ts
function buildDependencyResultsWithScope(checkId, checkConfig, context2, scope) {
  const dependencyResults = /* @__PURE__ */ new Map();
  const dependencies = checkConfig.depends_on || [];
  const depList = Array.isArray(dependencies) ? dependencies : [dependencies];
  const currentIndex = scope.length > 0 ? scope[scope.length - 1].index : void 0;
  for (const depId of depList) {
    if (!depId) continue;
    try {
      const snapshotId = context2.journal.beginSnapshot();
      const visible = context2.journal.readVisible(
        context2.sessionId,
        snapshotId,
        context2.event
      );
      const sameScope = (a, b) => {
        if (a.length !== b.length) return false;
        for (let i = 0; i < a.length; i++)
          if (a[i].check !== b[i].check || a[i].index !== b[i].index) return false;
        return true;
      };
      const matches = visible.filter((e) => e.checkId === depId && sameScope(e.scope, scope));
      let journalResult = matches.length > 0 ? matches[matches.length - 1].result : void 0;
      if (journalResult && Array.isArray(journalResult.forEachItems) && currentIndex !== void 0) {
        const perItemSummary = journalResult.forEachItemResults && journalResult.forEachItemResults[currentIndex] || { issues: [] };
        const perItemOutput = journalResult.forEachItems[currentIndex];
        const combined = { ...perItemSummary, output: perItemOutput };
        dependencyResults.set(depId, combined);
        continue;
      }
      if (!journalResult) {
        try {
          const { ContextView } = (init_snapshot_store(), __toCommonJS(snapshot_store_exports));
          const rawContextView = new ContextView(
            context2.journal,
            context2.sessionId,
            snapshotId,
            [],
            context2.event
          );
          const raw = rawContextView.get(depId);
          if (raw && Array.isArray(raw.forEachItems) && currentIndex !== void 0) {
            const perItemSummary = raw.forEachItemResults && raw.forEachItemResults[currentIndex] || { issues: [] };
            const perItemOutput = raw.forEachItems[currentIndex];
            journalResult = { ...perItemSummary, output: perItemOutput };
          }
        } catch {
        }
      }
      if (journalResult) {
        dependencyResults.set(depId, journalResult);
      }
    } catch {
    }
  }
  try {
    const snapshotId = context2.journal.beginSnapshot();
    const allEntries = context2.journal.readVisible(
      context2.sessionId,
      snapshotId,
      context2.event
    );
    const allCheckNames = Array.from(new Set(allEntries.map((e) => e.checkId)));
    for (const checkName of allCheckNames) {
      try {
        const { ContextView } = (init_snapshot_store(), __toCommonJS(snapshot_store_exports));
        const rawContextView = new ContextView(
          context2.journal,
          context2.sessionId,
          snapshotId,
          scope,
          context2.event
        );
        const jr = rawContextView.get(checkName);
        if (jr) dependencyResults.set(checkName, jr);
      } catch {
      }
    }
    for (const checkName of allCheckNames) {
      const checkCfg = context2.config.checks?.[checkName];
      if (checkCfg?.forEach) {
        try {
          const { ContextView } = (init_snapshot_store(), __toCommonJS(snapshot_store_exports));
          const rawContextView = new ContextView(
            context2.journal,
            context2.sessionId,
            snapshotId,
            [],
            context2.event
          );
          const rawResult = rawContextView.get(checkName);
          if (rawResult && rawResult.forEachItems) {
            const rawKey = `${checkName}-raw`;
            dependencyResults.set(rawKey, {
              issues: [],
              output: rawResult.forEachItems
            });
          }
        } catch {
        }
      }
    }
  } catch {
  }
  return dependencyResults;
}
var init_dependency_gating = __esm({
  "src/state-machine/dispatch/dependency-gating.ts"() {
    "use strict";
  }
});

// src/state-machine/dispatch/template-renderer.ts
async function renderTemplateContent(checkId, checkConfig, reviewSummary) {
  try {
    const { createExtendedLiquid: createExtendedLiquid2 } = await import("./liquid-extensions-5IZLTFSZ.mjs");
    const fs10 = await import("fs/promises");
    const path12 = await import("path");
    const schemaRaw = checkConfig.schema || "plain";
    const schema = typeof schemaRaw === "string" ? schemaRaw : "code-review";
    let templateContent;
    if (checkConfig.template && checkConfig.template.content) {
      templateContent = String(checkConfig.template.content);
    } else if (checkConfig.template && checkConfig.template.file) {
      const file = String(checkConfig.template.file);
      const resolved = path12.resolve(process.cwd(), file);
      templateContent = await fs10.readFile(resolved, "utf-8");
    } else if (schema && schema !== "plain") {
      const sanitized = String(schema).replace(/[^a-zA-Z0-9-]/g, "");
      if (sanitized) {
        const candidatePaths = [
          path12.join(__dirname, "output", sanitized, "template.liquid"),
          // bundled: dist/output/
          path12.join(__dirname, "..", "..", "output", sanitized, "template.liquid"),
          // source: output/
          path12.join(process.cwd(), "output", sanitized, "template.liquid"),
          // fallback: cwd/output/
          path12.join(process.cwd(), "dist", "output", sanitized, "template.liquid")
          // fallback: cwd/dist/output/
        ];
        for (const p of candidatePaths) {
          try {
            templateContent = await fs10.readFile(p, "utf-8");
            if (templateContent) break;
          } catch {
          }
        }
      }
    }
    if (!templateContent) return void 0;
    const liquid = createExtendedLiquid2({
      trimTagLeft: false,
      trimTagRight: false,
      trimOutputLeft: false,
      trimOutputRight: false,
      greedy: false
    });
    let output = reviewSummary.output;
    if (typeof output === "string") {
      const trimmed = output.trim();
      if (trimmed.startsWith("{") || trimmed.startsWith("[")) {
        try {
          output = JSON.parse(trimmed);
        } catch {
        }
      }
    }
    const templateData = {
      issues: reviewSummary.issues || [],
      checkName: checkId,
      output
    };
    const rendered = await liquid.parseAndRender(templateContent, templateData);
    return rendered.trim();
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    logger.error(`[LevelDispatch] Failed to render template for ${checkId}: ${msg}`);
    return void 0;
  }
}
var init_template_renderer = __esm({
  "src/state-machine/dispatch/template-renderer.ts"() {
    "use strict";
    init_logger();
  }
});

// src/state-machine/dispatch/stats-manager.ts
function hasFatalIssues(result) {
  if (!result.issues) return false;
  return result.issues.some((issue) => {
    const ruleId = issue.ruleId || "";
    return ruleId.endsWith("/error") || ruleId.includes("/execution_error") || ruleId.includes("timeout") || ruleId.endsWith("_fail_if");
  });
}
function updateStats(results, state, isForEachIteration = false) {
  for (const { checkId, result, error, duration } of results) {
    const existing = state.stats.get(checkId);
    const stats = existing || {
      checkName: checkId,
      totalRuns: 0,
      successfulRuns: 0,
      failedRuns: 0,
      skippedRuns: 0,
      skipped: false,
      totalDuration: 0,
      issuesFound: 0,
      issuesBySeverity: { critical: 0, error: 0, warning: 0, info: 0 }
    };
    const skippedMarker = result.__skipped;
    if (skippedMarker) {
      stats.skipped = true;
      stats.skipReason = typeof skippedMarker === "string" ? skippedMarker : stats.skipReason || "if_condition";
      stats.totalRuns = 0;
      stats.successfulRuns = 0;
      stats.failedRuns = 0;
      stats.skippedRuns++;
      state.stats.set(checkId, stats);
      continue;
    }
    if (stats.skipped) {
      stats.skipped = false;
      stats.skippedRuns = 0;
      stats.skipReason = void 0;
      stats.skipCondition = void 0;
    }
    stats.totalRuns++;
    if (typeof duration === "number" && Number.isFinite(duration)) {
      stats.totalDuration += duration;
    }
    const hasExecutionFailure = !!error || hasFatalIssues(result);
    if (error) {
      stats.failedRuns++;
    } else if (hasExecutionFailure) {
      stats.failedRuns++;
      if (!isForEachIteration) {
        state.failedChecks = state.failedChecks || /* @__PURE__ */ new Set();
        state.failedChecks.add(checkId);
      }
    } else {
      stats.successfulRuns++;
    }
    if (result.issues) {
      stats.issuesFound += result.issues.length;
      for (const issue of result.issues) {
        if (issue.severity === "critical") stats.issuesBySeverity.critical++;
        else if (issue.severity === "error") stats.issuesBySeverity.error++;
        else if (issue.severity === "warning") stats.issuesBySeverity.warning++;
        else if (issue.severity === "info") stats.issuesBySeverity.info++;
      }
    }
    if (stats.outputsProduced === void 0) {
      const forEachItems = result.forEachItems;
      if (Array.isArray(forEachItems)) stats.outputsProduced = forEachItems.length;
      else if (result.output !== void 0) stats.outputsProduced = 1;
    }
    state.stats.set(checkId, stats);
  }
}
var init_stats_manager = __esm({
  "src/state-machine/dispatch/stats-manager.ts"() {
    "use strict";
  }
});

// src/state-machine/dispatch/foreach-processor.ts
async function executeCheckWithForEachItems(checkId, forEachParent, forEachItems, context2, state, emitEvent, transition) {
  try {
    const snapId = context2.journal.beginSnapshot();
    const visible = context2.journal.readVisible(context2.sessionId, snapId, context2.event);
    let latestItems;
    for (let i = visible.length - 1; i >= 0; i--) {
      const e = visible[i];
      if (e.checkId === forEachParent && Array.isArray(e.scope) && e.scope.length === 0) {
        const r = e.result;
        if (r && Array.isArray(r.forEachItems)) {
          latestItems = r.forEachItems;
          break;
        }
      }
    }
    if (Array.isArray(latestItems)) {
      if (context2.debug) {
        try {
          const prevLen = Array.isArray(forEachItems) ? forEachItems.length : 0;
          const newLen = latestItems.length;
          if (prevLen !== newLen) {
            logger.info(
              `[LevelDispatch] Refreshing forEachItems for ${checkId}: from parent '${forEachParent}' latestItems=${newLen} (was ${prevLen})`
            );
          }
        } catch {
        }
      }
      forEachItems = latestItems;
    }
  } catch (e) {
    if (context2.debug) {
      logger.warn(
        `[LevelDispatch] Failed to refresh forEachItems from journal for ${forEachParent}: ${e}`
      );
    }
  }
  const checkConfig = context2.config.checks?.[checkId];
  if (!checkConfig) {
    throw new Error(`Check configuration not found: ${checkId}`);
  }
  logger.info(
    `[LevelDispatch][DEBUG] executeCheckWithForEachItems: checkId=${checkId}, forEachParent=${forEachParent}, items=${forEachItems.length}`
  );
  logger.info(
    `[LevelDispatch][DEBUG] forEachItems: ${JSON.stringify(forEachItems).substring(0, 200)}`
  );
  const allIssues = [];
  const perItemResults = [];
  const allOutputs = [];
  const allContents = [];
  const perIterationDurations = [];
  try {
    const wave = state.wave;
    const lvl = state.currentLevel ?? "?";
    const banner = `\u2501\u2501\u2501 CHECK ${checkId} (wave ${wave}, level ${lvl}, forEach parent) \u2501\u2501\u2501`;
    const isTTY = typeof process !== "undefined" ? !!process.stderr.isTTY : false;
    const outputFormat = process.env.VISOR_OUTPUT_FORMAT || "";
    const isJsonLike = outputFormat === "json" || outputFormat === "sarif";
    if (isTTY && !isJsonLike) {
      const cyan = "\x1B[36m";
      const reset = "\x1B[0m";
      logger.info(`${cyan}${banner}${reset}`);
    } else {
      logger.info(banner);
    }
  } catch {
  }
  for (let itemIndex = 0; itemIndex < forEachItems.length; itemIndex++) {
    const iterationStartMs = Date.now();
    const scope = [
      { check: forEachParent, index: itemIndex }
    ];
    const forEachItem = forEachItems[itemIndex];
    logger.info(
      `[LevelDispatch][DEBUG] Starting iteration ${itemIndex} of ${checkId}, parent=${forEachParent}, item=${JSON.stringify(forEachItem)?.substring(0, 100)}`
    );
    const shouldSkipDueToParentFailure = forEachItem?.__failed === true || forEachItem?.__skip === true;
    if (shouldSkipDueToParentFailure) {
      logger.info(
        `\u23ED  Skipped ${checkId} iteration ${itemIndex} (forEach parent "${forEachParent}" iteration ${itemIndex} marked as failed)`
      );
      const iterationDurationMs = Date.now() - iterationStartMs;
      perIterationDurations.push(iterationDurationMs);
      perItemResults.push({ issues: [] });
      allOutputs.push({ __skip: true });
      continue;
    }
    try {
      emitNdjsonSpanWithEvents(
        "visor.foreach.item",
        {
          "visor.check.id": checkId,
          "visor.foreach.index": itemIndex,
          "visor.foreach.total": forEachItems.length
        },
        []
      );
    } catch (error) {
      logger.warn(`[LevelDispatch] Failed to emit foreach.item span: ${error}`);
    }
    emitEvent({ type: "CheckScheduled", checkId, scope });
    const dispatch = {
      id: `${checkId}-${itemIndex}-${Date.now()}`,
      checkId,
      scope,
      provider: context2.checks[checkId]?.providerType || "unknown",
      startMs: Date.now(),
      attempts: 1,
      foreachIndex: itemIndex
    };
    state.activeDispatches.set(`${checkId}-${itemIndex}`, dispatch);
    try {
      const providerType = checkConfig.type || "ai";
      const providerRegistry = (init_check_provider_registry(), __toCommonJS(check_provider_registry_exports)).CheckProviderRegistry.getInstance();
      const provider = providerRegistry.getProviderOrThrow(providerType);
      const outputHistory = buildOutputHistoryFromJournal(context2);
      const workflowInputs = resolveWorkflowInputs(checkConfig, context2);
      const providerConfig = {
        type: providerType,
        checkName: checkId,
        prompt: checkConfig.prompt,
        exec: checkConfig.exec,
        schema: checkConfig.schema,
        group: checkConfig.group,
        focus: checkConfig.focus || (() => {
          const focusMap = {
            security: "security",
            performance: "performance",
            style: "style",
            architecture: "architecture"
          };
          return focusMap[checkId] || "all";
        })(),
        transform: checkConfig.transform,
        transform_js: checkConfig.transform_js,
        env: checkConfig.env,
        forEach: checkConfig.forEach,
        ...checkConfig,
        eventContext: context2.prInfo?.eventContext || {},
        __outputHistory: outputHistory,
        // Propagate workflow inputs for template access via {{ inputs.* }}
        workflowInputs,
        ai: {
          ...checkConfig.ai || {},
          timeout: checkConfig.ai?.timeout || 18e5,
          debug: !!context2.debug
        }
      };
      const dependencyResults = buildDependencyResultsWithScope(
        checkId,
        checkConfig,
        context2,
        scope
      );
      try {
        const rawDeps = checkConfig?.depends_on || [];
        const depList = Array.isArray(rawDeps) ? rawDeps : [rawDeps];
        if (depList.length > 0) {
          const groupSatisfied = (token) => {
            if (typeof token !== "string") return true;
            const orOptions = token.includes("|") ? token.split("|").map((s) => s.trim()).filter(Boolean) : [token];
            for (const opt of orOptions) {
              const dr = dependencyResults.get(opt);
              const depCfg = context2.config.checks?.[opt];
              const cont = !!(depCfg && depCfg.continue_on_failure === true);
              let failed = false;
              let skipped = false;
              if (!dr) failed = true;
              else {
                const out = dr.output;
                const fatal = hasFatalIssues(dr);
                failed = fatal || !!out && typeof out === "object" && out.__failed === true;
                skipped = !!(out && typeof out === "object" && out.__skip === true);
              }
              const satisfied = !skipped && (!failed || cont);
              if (satisfied) return true;
            }
            return false;
          };
          let allSatisfied = true;
          for (const token of depList) {
            if (!groupSatisfied(token)) {
              allSatisfied = false;
              break;
            }
          }
          if (!allSatisfied) {
            if (context2.debug) {
              logger.info(
                `[LevelDispatch] Skipping ${checkId} iteration ${itemIndex} due to unsatisfied dependency group(s)`
              );
            }
            const iterationDurationMs2 = Date.now() - iterationStartMs;
            perIterationDurations.push(iterationDurationMs2);
            perItemResults.push({ issues: [] });
            allOutputs.push({ __skip: true });
            continue;
          }
        }
      } catch {
      }
      const prInfo = context2.prInfo || {
        number: 1,
        title: "State Machine Execution",
        author: "system",
        eventType: context2.event || "manual",
        eventContext: {},
        files: [],
        commits: []
      };
      const executionContext = {
        ...context2.executionContext,
        _engineMode: context2.mode,
        _parentContext: context2,
        _parentState: state
      };
      const result = await withActiveSpan(
        `visor.check.${checkId}`,
        {
          "visor.check.id": checkId,
          "visor.check.type": providerType,
          session_id: context2.sessionId,
          wave: state.wave
        },
        async () => executeWithSandboxRouting(
          checkId,
          checkConfig,
          context2,
          prInfo,
          dependencyResults,
          checkConfig.ai?.timeout || 18e5,
          () => provider.execute(prInfo, providerConfig, dependencyResults, executionContext)
        )
      );
      const enrichedIssues = (result.issues || []).map((issue) => ({
        ...issue,
        checkName: checkId,
        ruleId: `${checkId}/${issue.ruleId || "unknown"}`,
        group: checkConfig.group,
        schema: typeof checkConfig.schema === "object" ? "custom" : checkConfig.schema,
        template: checkConfig.template,
        timestamp: Date.now()
      }));
      const enrichedResult = { ...result, issues: enrichedIssues };
      const iterationDurationMs = Date.now() - iterationStartMs;
      perIterationDurations.push(iterationDurationMs);
      updateStats(
        [{ checkId, result: enrichedResult, duration: iterationDurationMs }],
        state,
        true
      );
      try {
        context2.journal.commitEntry({
          sessionId: context2.sessionId,
          checkId,
          result: enrichedResult,
          event: context2.event || "manual",
          scope
        });
        logger.info(
          `[LevelDispatch][DEBUG] Committing to journal: checkId=${checkId}, scope=${JSON.stringify(scope)}, hasOutput=${enrichedResult.output !== void 0}`
        );
      } catch (error) {
        logger.warn(`[LevelDispatch] Failed to commit per-iteration result to journal: ${error}`);
      }
      perItemResults.push(enrichedResult);
      if (enrichedResult.content)
        allContents.push(String(enrichedResult.content));
      if (enrichedResult.output !== void 0)
        allOutputs.push(enrichedResult.output);
      allIssues.push(...enrichedResult.issues || []);
      emitEvent({ type: "CheckCompleted", checkId, scope, result: enrichedResult });
    } catch (error) {
      const iterationDurationMs = Date.now() - iterationStartMs;
      perIterationDurations.push(iterationDurationMs);
      const err = error instanceof Error ? error : new Error(String(error));
      logger.error(
        `[LevelDispatch] Error executing ${checkId} iteration ${itemIndex}: ${err.message}`
      );
      updateStats(
        [
          {
            checkId,
            result: {
              issues: [
                {
                  severity: "error",
                  category: "logic",
                  ruleId: `${checkId}/error`,
                  file: "system",
                  line: 0,
                  message: err.message,
                  timestamp: Date.now()
                }
              ]
            },
            error: err,
            duration: iterationDurationMs
          }
        ],
        state,
        true
      );
      allOutputs.push({ __failed: true });
      perItemResults.push({
        issues: [
          {
            severity: "error",
            category: "logic",
            ruleId: `${checkId}/error`,
            file: "system",
            line: 0,
            message: err.message,
            timestamp: Date.now()
          }
        ]
      });
      emitEvent({
        type: "CheckErrored",
        checkId,
        scope,
        error: { message: err.message, stack: err.stack, name: err.name }
      });
    } finally {
      state.activeDispatches.delete(`${checkId}-${itemIndex}`);
    }
  }
  const checkStats = state.stats.get(checkId);
  if (checkStats) {
    checkStats.outputsProduced = allOutputs.length;
    checkStats.perIterationDuration = perIterationDurations;
    const previewItems = allOutputs.slice(0, 3).map((item) => {
      const str = typeof item === "string" ? item : JSON.stringify(item) ?? "undefined";
      return str.length > 50 ? str.substring(0, 50) + "..." : str;
    });
    checkStats.forEachPreview = allOutputs.length > 3 ? [...previewItems, `...${allOutputs.length - 3} more`] : previewItems;
    state.stats.set(checkId, checkStats);
    if (checkStats.totalRuns > 0 && checkStats.failedRuns === checkStats.totalRuns) {
      logger.info(
        `[LevelDispatch] forEach check ${checkId} failed completely (${checkStats.failedRuns}/${checkStats.totalRuns} iterations failed)`
      );
      state.failedChecks = state.failedChecks || /* @__PURE__ */ new Set();
      state.failedChecks.add(checkId);
    }
  }
  const aggregatedResult = {
    issues: allIssues,
    isForEach: true,
    forEachItems: allOutputs,
    forEachItemResults: perItemResults,
    ...allContents.length > 0 ? { content: allContents.join("\n") } : {}
  };
  logger.info(
    `[LevelDispatch][DEBUG] Aggregated result for ${checkId}: forEachItems.length=${allOutputs.length}, results=${perItemResults.length}`
  );
  logger.info(`[LevelDispatch][DEBUG] allOutputs: ${JSON.stringify(allOutputs).substring(0, 200)}`);
  try {
    logger.info(`[LevelDispatch] Calling handleRouting for ${checkId}`);
  } catch {
  }
  let wasHalted = false;
  try {
    state.completedChecks.add(checkId);
    const currentWaveCompletions = state.currentWaveCompletions;
    if (currentWaveCompletions) currentWaveCompletions.add(checkId);
    wasHalted = await handleRouting(context2, state, transition, emitEvent, {
      checkId,
      scope: [],
      result: aggregatedResult,
      checkConfig,
      success: !hasFatalIssues(aggregatedResult)
    });
  } catch (error) {
    logger.warn(`[LevelDispatch] Routing error for aggregated forEach ${checkId}: ${error}`);
  }
  if (wasHalted) {
    logger.info(`[LevelDispatch] Execution halted after routing for aggregated forEach ${checkId}`);
    return aggregatedResult;
  }
  try {
    context2.journal.commitEntry({
      sessionId: context2.sessionId,
      checkId,
      result: aggregatedResult,
      event: context2.event || "manual",
      scope: []
    });
    logger.info(`[LevelDispatch][DEBUG] Committed aggregated result to journal with scope=[]`);
  } catch (error) {
    logger.warn(`[LevelDispatch] Failed to commit aggregated forEach result to journal: ${error}`);
  }
  emitEvent({ type: "CheckCompleted", checkId, scope: [], result: aggregatedResult });
  const parentCheckConfig = context2.config.checks?.[forEachParent];
  logger.info(
    `[LevelDispatch][DEBUG] Checking on_finish for forEach parent ${forEachParent}: has_on_finish=${!!parentCheckConfig?.on_finish}, is_forEach=${!!parentCheckConfig?.forEach}`
  );
  if (parentCheckConfig?.on_finish && parentCheckConfig.forEach) {
    logger.info(
      `[LevelDispatch] Processing on_finish for forEach parent ${forEachParent} after children complete`
    );
    try {
      const snapshotId = context2.journal.beginSnapshot();
      const { ContextView } = (init_snapshot_store(), __toCommonJS(snapshot_store_exports));
      const contextView = new ContextView(
        context2.journal,
        context2.sessionId,
        snapshotId,
        [],
        context2.event
      );
      const parentResult = contextView.get(forEachParent);
      if (parentResult) {
        logger.info(
          `[LevelDispatch] Found parent result for ${forEachParent}, evaluating on_finish`
        );
        const onFinish = parentCheckConfig.on_finish;
        let queuedForward = false;
        logger.info(
          `[LevelDispatch] on_finish.run: ${onFinish.run?.length || 0} targets, targets=${JSON.stringify(onFinish.run || [])}`
        );
        if (onFinish.run && onFinish.run.length > 0) {
          for (const targetCheck of onFinish.run) {
            logger.info(`[LevelDispatch] Processing on_finish.run target: ${targetCheck}`);
            logger.info(
              `[LevelDispatch] Loop budget check: routingLoopCount=${state.routingLoopCount}, max_loops=${context2.config.routing?.max_loops ?? 10}`
            );
            if (checkLoopBudget(context2, state, "on_finish", "run")) {
              const errorIssue = {
                file: "system",
                line: 0,
                ruleId: `${forEachParent}/routing/loop_budget_exceeded`,
                message: `Routing loop budget exceeded (max_loops=${context2.config.routing?.max_loops ?? 10}) during on_finish run`,
                severity: "error",
                category: "logic"
              };
              parentResult.issues = [...parentResult.issues || [], errorIssue];
              try {
                context2.journal.commitEntry({
                  sessionId: context2.sessionId,
                  checkId: forEachParent,
                  result: parentResult,
                  event: context2.event || "manual",
                  scope: []
                });
              } catch (err) {
                logger.warn(
                  `[LevelDispatch] Failed to commit parent result with loop budget error: ${err}`
                );
              }
              return aggregatedResult;
            }
            state.routingLoopCount++;
            emitEvent({
              type: "ForwardRunRequested",
              target: targetCheck,
              scope: [],
              origin: "run"
            });
            queuedForward = true;
          }
        }
        if (context2.debug) {
          logger.info(
            `[LevelDispatch] Evaluating on_finish.goto_js for forEach parent: ${forEachParent}`
          );
          if (onFinish.goto_js)
            logger.info(`[LevelDispatch] goto_js code: ${onFinish.goto_js.substring(0, 200)}`);
          try {
            const snapshotId2 = context2.journal.beginSnapshot();
            const all = context2.journal.readVisible(context2.sessionId, snapshotId2, void 0);
            const keys = Array.from(new Set(all.map((e) => e.checkId)));
            logger.info(`[LevelDispatch] history keys: ${keys.join(", ")}`);
          } catch {
          }
        }
        const gotoTarget = await evaluateGoto(
          onFinish.goto_js,
          onFinish.goto,
          forEachParent,
          parentCheckConfig,
          parentResult,
          context2,
          state
        );
        if (context2.debug)
          logger.info(`[LevelDispatch] goto_js evaluation result: ${gotoTarget || "null"}`);
        if (gotoTarget) {
          if (queuedForward && gotoTarget === forEachParent) {
            logger.info(
              `[LevelDispatch] on_finish.goto to self (${gotoTarget}) deferred, will process after WaveRetry`
            );
            emitEvent({ type: "WaveRetry", reason: "on_finish" });
          } else {
            if (checkLoopBudget(context2, state, "on_finish", "goto")) {
              const errorIssue = {
                file: "system",
                line: 0,
                ruleId: `${forEachParent}/routing/loop_budget_exceeded`,
                message: `Routing loop budget exceeded (max_loops=${context2.config.routing?.max_loops ?? 10}) during on_finish goto`,
                severity: "error",
                category: "logic"
              };
              parentResult.issues = [...parentResult.issues || [], errorIssue];
              try {
                context2.journal.commitEntry({
                  sessionId: context2.sessionId,
                  checkId: forEachParent,
                  result: parentResult,
                  event: context2.event || "manual",
                  scope: []
                });
              } catch {
              }
              return aggregatedResult;
            }
            state.routingLoopCount++;
            emitEvent({ type: "ForwardRunRequested", target: gotoTarget, origin: "goto" });
          }
        }
        if (queuedForward) {
          const guardKey = `waveRetry:on_finish:${forEachParent}:wave:${state.wave}`;
          logger.info(
            `[LevelDispatch] Checking WaveRetry guard: ${guardKey}, has=${!!state.forwardRunGuards?.has(guardKey)}`
          );
          if (!state.forwardRunGuards?.has(guardKey)) {
            state.forwardRunGuards?.add(guardKey);
            logger.info(`[LevelDispatch] Emitting WaveRetry event for on_finish.run targets`);
            emitEvent({ type: "WaveRetry", reason: "on_finish" });
          }
        }
      }
    } catch {
    }
  }
  return aggregatedResult;
}
var init_foreach_processor = __esm({
  "src/state-machine/dispatch/foreach-processor.ts"() {
    "use strict";
    init_logger();
    init_fallback_ndjson();
    init_trace_helpers();
    init_history_snapshot();
    init_dependency_gating();
    init_stats_manager();
    init_routing();
    init_workflow_inputs();
    init_sandbox_routing();
  }
});

// src/state-machine/dispatch/on-init-handlers.ts
async function renderTemplateArguments(args, prInfo, dependencyResults, executionContext) {
  const renderedArgs = {};
  if (!args) {
    return renderedArgs;
  }
  const liquid = createExtendedLiquid();
  for (const [key, value] of Object.entries(args)) {
    if (typeof value === "string") {
      try {
        renderedArgs[key] = await liquid.parseAndRender(value, {
          pr: prInfo,
          outputs: dependencyResults,
          env: process.env,
          args: executionContext.args || {}
        });
      } catch (error) {
        logger.warn(`[OnInit] Failed to render template for ${key}: ${error}`);
        renderedArgs[key] = value;
      }
    } else {
      renderedArgs[key] = value;
    }
  }
  return renderedArgs;
}
async function executeInvocation(item, context2, scope, prInfo, dependencyResults, executionContext) {
  const CheckProviderRegistry2 = (init_check_provider_registry(), __toCommonJS(check_provider_registry_exports)).CheckProviderRegistry;
  const providerRegistry = CheckProviderRegistry2.getInstance();
  const renderedArgs = await renderTemplateArguments(
    item.with,
    prInfo,
    dependencyResults,
    executionContext
  );
  if ("tool" in item) {
    const toolName = item.tool;
    const toolDef = context2.config.tools?.[toolName];
    if (!toolDef) {
      throw new Error(`Tool '${toolName}' not found in tools: section`);
    }
    logger.info(`[OnInit] Executing tool: ${toolName}`);
    const tempCheckConfig = {
      type: "mcp",
      method: toolName,
      transport: "custom",
      args: renderedArgs
    };
    const provider = providerRegistry.getProviderOrThrow("mcp");
    const result = await provider.execute(
      prInfo,
      tempCheckConfig,
      dependencyResults,
      executionContext
    );
    const output = result.output;
    logger.info(`[OnInit] Tool ${toolName} completed`);
    return output;
  } else if ("step" in item) {
    const stepName = item.step;
    const stepConfig = context2.config.checks?.[stepName];
    if (!stepConfig) {
      throw new Error(`Step '${stepName}' not found in checks: section`);
    }
    logger.info(`[OnInit] Executing step: ${stepName}`);
    const enrichedExecutionContext = {
      ...executionContext,
      args: renderedArgs
    };
    const providerType = stepConfig.type || "ai";
    const provider = providerRegistry.getProviderOrThrow(providerType);
    const { buildOutputHistoryFromJournal: buildOutputHistoryFromJournal3 } = (init_history_snapshot(), __toCommonJS(history_snapshot_exports));
    const outputHistory = buildOutputHistoryFromJournal3(context2);
    const providerConfig = {
      type: providerType,
      checkName: stepName,
      prompt: stepConfig.prompt,
      exec: stepConfig.exec,
      schema: stepConfig.schema,
      group: stepConfig.group,
      transform: stepConfig.transform,
      transform_js: stepConfig.transform_js,
      env: stepConfig.env,
      ...stepConfig,
      eventContext: prInfo?.eventContext || {},
      __outputHistory: outputHistory,
      ai: {
        ...stepConfig.ai || {},
        timeout: stepConfig.ai?.timeout || 18e5,
        debug: !!context2.debug
      }
    };
    const result = await provider.execute(
      prInfo,
      providerConfig,
      dependencyResults,
      enrichedExecutionContext
    );
    const output = result.output;
    logger.info(`[OnInit] Step ${stepName} completed`);
    return output;
  } else if ("workflow" in item) {
    const workflowName = item.workflow;
    if (!workflowName) {
      throw new Error("Workflow name is required in on_init workflow invocation");
    }
    logger.info(`[OnInit] Executing workflow: ${workflowName}`);
    const tempCheckConfig = {
      type: "workflow",
      workflow: workflowName,
      args: renderedArgs,
      overrides: item.overrides,
      output_mapping: item.output_mapping
    };
    const provider = providerRegistry.getProviderOrThrow("workflow");
    const result = await provider.execute(
      prInfo,
      tempCheckConfig,
      dependencyResults,
      executionContext
    );
    const output = result.output;
    logger.info(`[OnInit] Workflow ${workflowName} completed`);
    return output;
  }
  throw new Error("Invalid on_init invocation: must specify tool, step, or workflow");
}
async function executeToolInvocation(item, context2, scope, prInfo, dependencyResults, executionContext) {
  return executeInvocation(item, context2, scope, prInfo, dependencyResults, executionContext);
}
async function executeStepInvocation(item, context2, scope, prInfo, dependencyResults, executionContext) {
  return executeInvocation(item, context2, scope, prInfo, dependencyResults, executionContext);
}
async function executeWorkflowInvocation(item, context2, scope, prInfo, dependencyResults, executionContext) {
  return executeInvocation(item, context2, scope, prInfo, dependencyResults, executionContext);
}
var init_on_init_handlers = __esm({
  "src/state-machine/dispatch/on-init-handlers.ts"() {
    "use strict";
    init_logger();
    init_liquid_extensions();
  }
});

// src/state-machine/dispatch/execution-invoker.ts
var execution_invoker_exports = {};
__export(execution_invoker_exports, {
  executeSingleCheck: () => executeSingleCheck
});
function normalizeRunItems(run) {
  if (!Array.isArray(run)) return [];
  return run.filter(Boolean);
}
function detectInvocationType(item) {
  if (typeof item === "string") return "step";
  if ("tool" in item) return "tool";
  if ("workflow" in item) return "workflow";
  if ("step" in item) return "step";
  throw new Error(
    `Invalid on_init item type: ${JSON.stringify(item)}. Must specify tool, step, or workflow.`
  );
}
async function executeOnInitItem(item, context2, scope, prInfo, dependencyResults, executionContext) {
  const itemType = detectInvocationType(item);
  let output;
  let outputName;
  switch (itemType) {
    case "tool": {
      const toolItem = item;
      output = await executeToolInvocation(
        toolItem,
        context2,
        scope,
        prInfo,
        dependencyResults,
        executionContext
      );
      outputName = toolItem.as || toolItem.tool;
      break;
    }
    case "step": {
      if (typeof item === "string") {
        const stepItem = { step: item, with: void 0, as: item };
        output = await executeStepInvocation(
          stepItem,
          context2,
          scope,
          prInfo,
          dependencyResults,
          executionContext
        );
        outputName = item;
      } else {
        const stepItem = item;
        output = await executeStepInvocation(
          stepItem,
          context2,
          scope,
          prInfo,
          dependencyResults,
          executionContext
        );
        outputName = stepItem.as || stepItem.step;
      }
      break;
    }
    case "workflow": {
      const workflowItem = item;
      output = await executeWorkflowInvocation(
        workflowItem,
        context2,
        scope,
        prInfo,
        dependencyResults,
        executionContext
      );
      outputName = workflowItem.as || workflowItem.workflow;
      break;
    }
    default:
      throw new Error(`Unknown on_init item type: ${itemType}`);
  }
  return { output, outputName };
}
async function handleOnInit(checkId, onInit, context2, scope, prInfo, dependencyResults, executionContext) {
  logger.info(`[OnInit] Processing on_init for check: ${checkId}`);
  if (executionContext.__onInitDepth && executionContext.__onInitDepth > 0) {
    logger.warn(
      `[OnInit] Skipping nested on_init for ${checkId} (depth: ${executionContext.__onInitDepth})`
    );
    return;
  }
  let runItems = [];
  if (onInit.run_js) {
    logger.info(`[OnInit] Evaluating run_js for ${checkId}`);
    try {
      const sandbox = createSecureSandbox();
      const result = await compileAndRun(
        sandbox,
        onInit.run_js,
        {
          pr: prInfo,
          outputs: dependencyResults,
          env: process.env,
          args: executionContext.args || {}
        },
        { injectLog: true, wrapFunction: false }
      );
      if (Array.isArray(result)) {
        runItems = result;
      } else {
        logger.warn(`[OnInit] run_js for ${checkId} did not return an array, got ${typeof result}`);
      }
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      logger.error(`[OnInit] Error evaluating run_js for ${checkId}: ${err.message}`);
      const wrappedError = new Error(`on_init.run_js evaluation failed: ${err.message}`);
      wrappedError.stack = err.stack;
      throw wrappedError;
    }
  } else if (onInit.run) {
    runItems = normalizeRunItems(onInit.run);
  }
  if (runItems.length === 0) {
    logger.info(`[OnInit] No items to run for ${checkId}`);
    return;
  }
  if (runItems.length > MAX_ON_INIT_ITEMS) {
    const msg = `on_init for ${checkId} has ${runItems.length} items, exceeding maximum of ${MAX_ON_INIT_ITEMS}`;
    logger.error(`[OnInit] ${msg}`);
    throw new Error(msg);
  }
  logger.info(`[OnInit] Running ${runItems.length} items for ${checkId}`);
  const originalDepth = executionContext.__onInitDepth || 0;
  executionContext.__onInitDepth = originalDepth + 1;
  try {
    for (let i = 0; i < runItems.length; i++) {
      const item = runItems[i];
      const itemType = detectInvocationType(item);
      const itemName = typeof item === "string" ? item : "tool" in item ? item.tool : "step" in item ? item.step : "workflow" in item ? item.workflow : "unknown";
      logger.info(`[OnInit] [${i + 1}/${runItems.length}] Executing ${itemType}: ${itemName}`);
      try {
        const { output, outputName } = await executeOnInitItem(
          item,
          context2,
          scope,
          prInfo,
          dependencyResults,
          executionContext
        );
        dependencyResults[outputName] = output;
        logger.info(`[OnInit] Stored output as: ${outputName}`);
      } catch (error) {
        const err = error instanceof Error ? error : new Error(String(error));
        logger.error(
          `[OnInit] Error executing ${itemType} ${itemName} for ${checkId}: ${err.message}`
        );
        const wrappedError = new Error(`on_init ${itemType} '${itemName}' failed: ${err.message}`);
        wrappedError.stack = err.stack;
        throw wrappedError;
      }
    }
    logger.info(`[OnInit] Completed all on_init items for ${checkId}`);
  } finally {
    executionContext.__onInitDepth = originalDepth;
  }
}
async function executeSingleCheck(checkId, context2, state, emitEvent, transition, evaluateIf, scopeOverride) {
  const checkConfig = context2.config.checks?.[checkId];
  if (checkConfig?.if) {
    const shouldRun = await evaluateIf(checkId, checkConfig, context2, state);
    if (!shouldRun) {
      logger.info(
        `\u23ED  Skipped (if: ${checkConfig.if.substring(0, 40)}${checkConfig.if.length > 40 ? "..." : ""})`
      );
      const emptyResult = { issues: [] };
      try {
        Object.defineProperty(emptyResult, "__skipped", {
          value: "if_condition",
          enumerable: false
        });
      } catch {
      }
      state.completedChecks.add(checkId);
      const stats = {
        checkName: checkId,
        totalRuns: 0,
        successfulRuns: 0,
        failedRuns: 0,
        skippedRuns: 0,
        skipped: true,
        skipReason: "if_condition",
        skipCondition: checkConfig.if,
        totalDuration: 0,
        issuesFound: 0,
        issuesBySeverity: { critical: 0, error: 0, warning: 0, info: 0 }
      };
      state.stats.set(checkId, stats);
      logger.info(`[LevelDispatch] Recorded skip stats for ${checkId}: skipReason=if_condition`);
      try {
        context2.journal.commitEntry({
          sessionId: context2.sessionId,
          checkId,
          result: emptyResult,
          event: context2.event || "manual",
          scope: []
        });
      } catch (error) {
        logger.warn(`[LevelDispatch] Failed to commit skipped result to journal: ${error}`);
      }
      emitEvent({ type: "CheckCompleted", checkId, scope: [], result: emptyResult });
      return emptyResult;
    }
  }
  const dependencies = checkConfig?.depends_on || [];
  const depList = Array.isArray(dependencies) ? dependencies : [dependencies];
  const failedChecks = state.failedChecks;
  const tokens = depList.filter(Boolean);
  const groupSatisfied = (token) => {
    const options = token.includes("|") ? token.split("|").map((s) => s.trim()).filter(Boolean) : [token];
    for (const opt of options) {
      const depCfg = context2.config.checks?.[opt];
      const cont = !!(depCfg && depCfg.continue_on_failure === true);
      const st = state.stats.get(opt);
      const skipped = !!(st && st.skipped === true);
      const skipReason = st?.skipReason;
      const skippedDueToEmptyForEach = skipped && skipReason === "forEach_empty";
      const wasMarkedFailed = !!(failedChecks && failedChecks.has(opt)) && !skippedDueToEmptyForEach;
      const failedOnly = !!(st && (st.failedRuns || 0) > 0 && (st.successfulRuns || 0) === 0);
      const satisfied = (!skipped || skippedDueToEmptyForEach) && (!failedOnly && !wasMarkedFailed || cont);
      if (satisfied) return true;
    }
    return false;
  };
  if (tokens.length > 0) {
    let allOk = true;
    for (const t of tokens) {
      if (!groupSatisfied(t)) {
        allOk = false;
        break;
      }
    }
    if (!allOk) {
      const emptyResult = { issues: [] };
      try {
        Object.defineProperty(emptyResult, "__skipped", {
          value: "dependency_failed",
          enumerable: false
        });
      } catch {
      }
      state.completedChecks.add(checkId);
      state.failedChecks = state.failedChecks || /* @__PURE__ */ new Set();
      state.failedChecks.add(checkId);
      const stats = {
        checkName: checkId,
        totalRuns: 0,
        successfulRuns: 0,
        failedRuns: 0,
        skippedRuns: 0,
        skipped: true,
        skipReason: "dependency_failed",
        totalDuration: 0,
        issuesFound: 0,
        issuesBySeverity: { critical: 0, error: 0, warning: 0, info: 0 }
      };
      state.stats.set(checkId, stats);
      try {
        context2.journal.commitEntry({
          sessionId: context2.sessionId,
          checkId,
          result: emptyResult,
          event: context2.event || "manual",
          scope: []
        });
      } catch (error) {
        logger.warn(`[LevelDispatch] Failed to commit empty result to journal: ${error}`);
      }
      emitEvent({ type: "CheckCompleted", checkId, scope: [], result: emptyResult });
      return emptyResult;
    }
  }
  try {
    const wave = state.wave;
    const level = state.currentLevel ?? "?";
    const banner = `\u2501\u2501\u2501 CHECK ${checkId} (wave ${wave}, level ${level}) \u2501\u2501\u2501`;
    const isTTY = typeof process !== "undefined" ? !!process.stderr.isTTY : false;
    const outputFormat = process.env.VISOR_OUTPUT_FORMAT || "";
    const isJsonLike = outputFormat === "json" || outputFormat === "sarif";
    if (isTTY && !isJsonLike) {
      const cyan = "\x1B[36m";
      const reset = "\x1B[0m";
      logger.info(`${cyan}${banner}${reset}`);
    } else {
      logger.info(banner);
    }
  } catch {
  }
  let forEachParent;
  let forEachItems;
  for (const depId of depList) {
    if (!depId) continue;
    try {
      const snapshotId = context2.journal.beginSnapshot();
      const { ContextView } = (init_snapshot_store(), __toCommonJS(snapshot_store_exports));
      const contextView = new ContextView(
        context2.journal,
        context2.sessionId,
        snapshotId,
        [],
        context2.event
      );
      const depResult = contextView.get(depId);
      if (depResult?.forEachItems && Array.isArray(depResult.forEachItems)) {
        forEachParent = depId;
        forEachItems = depResult.forEachItems;
        break;
      }
    } catch {
    }
  }
  if (forEachParent && forEachItems !== void 0) {
    let fanoutMode = "reduce";
    const explicit = checkConfig?.fanout;
    if (explicit === "map" || explicit === "reduce") fanoutMode = explicit;
    else {
      const providerType = context2.checks[checkId]?.providerType || "";
      const reduceProviders = /* @__PURE__ */ new Set(["log", "memory", "script", "workflow", "noop"]);
      fanoutMode = reduceProviders.has(providerType) ? "reduce" : "map";
    }
    if (fanoutMode === "map") {
      if (forEachItems.length === 0) {
        logger.info(`\u23ED  Skipped (forEach parent "${forEachParent}" has 0 items)`);
        const emptyResult = { issues: [] };
        try {
          Object.defineProperty(emptyResult, "__skipped", {
            value: "forEach_empty",
            enumerable: false
          });
        } catch {
        }
        state.completedChecks.add(checkId);
        let derivedSkipReason = "forEach_empty";
        try {
          const parentFailed = !!(state.failedChecks && state.failedChecks.has(forEachParent)) || (() => {
            const s = state.stats.get(forEachParent);
            return !!(s && (s.failedRuns || 0) > 0);
          })();
          if (parentFailed) derivedSkipReason = "dependency_failed";
        } catch {
        }
        const stats = {
          checkName: checkId,
          totalRuns: 0,
          successfulRuns: 0,
          failedRuns: 0,
          skippedRuns: 0,
          skipped: true,
          skipReason: derivedSkipReason,
          totalDuration: 0,
          issuesFound: 0,
          issuesBySeverity: { critical: 0, error: 0, warning: 0, info: 0 }
        };
        state.stats.set(checkId, stats);
        try {
          context2.journal.commitEntry({
            sessionId: context2.sessionId,
            checkId,
            result: emptyResult,
            event: context2.event || "manual",
            scope: []
          });
        } catch (error) {
          logger.warn(`[LevelDispatch] Failed to commit empty result to journal: ${error}`);
        }
        emitEvent({ type: "CheckCompleted", checkId, scope: [], result: emptyResult });
        return emptyResult;
      }
      return await executeCheckWithForEachItems(
        checkId,
        forEachParent,
        forEachItems,
        context2,
        state,
        emitEvent,
        transition
      );
    }
  }
  const scope = scopeOverride || [];
  emitEvent({ type: "CheckScheduled", checkId, scope });
  const startTime = Date.now();
  const dispatch = {
    id: `${checkId}-${Date.now()}`,
    checkId,
    scope,
    provider: context2.checks[checkId]?.providerType || "unknown",
    startMs: startTime,
    attempts: 1
  };
  state.activeDispatches.set(checkId, dispatch);
  try {
    if (!checkConfig) throw new Error(`Check configuration not found: ${checkId}`);
    const providerType = checkConfig.type || "ai";
    const providerRegistry = (init_check_provider_registry(), __toCommonJS(check_provider_registry_exports)).CheckProviderRegistry.getInstance();
    const provider = providerRegistry.getProviderOrThrow(providerType);
    const outputHistory = buildOutputHistoryFromJournal(context2);
    const workflowInputs = resolveWorkflowInputs(checkConfig, context2);
    const providerConfig = {
      type: providerType,
      checkName: checkId,
      prompt: checkConfig.prompt,
      exec: checkConfig.exec,
      schema: checkConfig.schema,
      group: checkConfig.group,
      focus: checkConfig.focus || mapCheckNameToFocus(checkId),
      transform: checkConfig.transform,
      transform_js: checkConfig.transform_js,
      env: checkConfig.env,
      forEach: checkConfig.forEach,
      ...checkConfig,
      eventContext: context2.prInfo?.eventContext || {},
      __outputHistory: outputHistory,
      // Propagate workflow inputs for template access via {{ inputs.* }}
      workflowInputs,
      ai: {
        ...checkConfig.ai || {},
        timeout: checkConfig.ai?.timeout || 18e5,
        debug: !!context2.debug
      }
    };
    const dependencyResults = buildDependencyResultsWithScope(checkId, checkConfig, context2, scope);
    const prInfo = context2.prInfo || {
      number: 1,
      title: "State Machine Execution",
      author: "system",
      eventType: context2.event || "manual",
      eventContext: {},
      files: [],
      commits: []
    };
    let parentSessionId;
    let reuseSession = false;
    try {
      const reuseCfg = checkConfig.reuse_ai_session;
      if (reuseCfg === "self") {
        const snapshotId = context2.journal.beginSnapshot();
        const visible = context2.journal.readVisible(
          context2.sessionId,
          snapshotId,
          context2.event
        );
        const prior = visible.filter(
          (e) => e.checkId === checkId && (!e.scope || e.scope.length === 0)
        );
        if (prior.length > 0) {
          const last = prior[prior.length - 1];
          const sess = last.result?.sessionId;
          if (typeof sess === "string" && sess.length > 0) {
            parentSessionId = sess;
            reuseSession = true;
          }
        }
      }
    } catch {
      parentSessionId = void 0;
      reuseSession = false;
    }
    const executionContext = {
      ...context2.executionContext,
      _engineMode: context2.mode,
      _parentContext: context2,
      _parentState: state,
      // Explicitly propagate workspace reference for nested workflows
      workspace: context2.workspace
    };
    if (reuseSession && parentSessionId) {
      executionContext.parentSessionId = parentSessionId;
      executionContext.reuseSession = true;
    }
    if (checkConfig.on_init) {
      try {
        const dependencyResultsMap = {};
        for (const [key, value] of dependencyResults.entries()) {
          dependencyResultsMap[key] = value;
        }
        await handleOnInit(
          checkId,
          checkConfig.on_init,
          context2,
          scope,
          prInfo,
          dependencyResultsMap,
          executionContext
        );
        for (const [key, value] of Object.entries(dependencyResultsMap)) {
          if (!dependencyResults.has(key)) {
            dependencyResults.set(key, value);
          }
        }
      } catch (error) {
        const err = error instanceof Error ? error : new Error(String(error));
        logger.error(`[LevelDispatch] on_init failed for ${checkId}: ${err.message}`);
        throw err;
      }
    }
    try {
      emitNdjsonFallback("visor.provider", {
        "visor.check.id": checkId,
        "visor.provider.type": providerType
      });
    } catch {
    }
    const result = await withActiveSpan(
      `visor.check.${checkId}`,
      {
        "visor.check.id": checkId,
        "visor.check.type": providerType,
        session_id: context2.sessionId,
        wave: state.wave
      },
      async () => executeWithSandboxRouting(
        checkId,
        checkConfig,
        context2,
        prInfo,
        dependencyResults,
        checkConfig.ai?.timeout || 18e5,
        () => provider.execute(prInfo, providerConfig, dependencyResults, executionContext)
      )
    );
    const enrichedIssues = (result.issues || []).map((issue) => ({
      ...issue,
      checkName: checkId,
      ruleId: `${checkId}/${issue.ruleId || "unknown"}`,
      group: checkConfig.group,
      schema: typeof checkConfig.schema === "object" ? "custom" : checkConfig.schema,
      template: checkConfig.template,
      timestamp: Date.now()
    }));
    const enrichedResult = { ...result, issues: enrichedIssues };
    let isForEach = false;
    let forEachItemsLocal;
    if (checkConfig.forEach) {
      const output = result.output;
      if (Array.isArray(output)) {
        isForEach = true;
        forEachItemsLocal = output;
        enrichedResult.isForEach = true;
        enrichedResult.forEachItems = output;
      } else {
        if (context2.debug)
          logger.warn(
            `[LevelDispatch] Check ${checkId} has forEach:true but output is not an array: ${typeof output}, converting to single-item array`
          );
        isForEach = true;
        forEachItemsLocal = [output];
        enrichedResult.isForEach = true;
        enrichedResult.forEachItems = [output];
      }
    }
    if (result.isForEach) enrichedResult.isForEach = true;
    if (result.forEachItems) enrichedResult.forEachItems = result.forEachItems;
    if (result.forEachItemResults)
      enrichedResult.forEachItemResults = result.forEachItemResults;
    if (result.forEachFatalMask)
      enrichedResult.forEachFatalMask = result.forEachFatalMask;
    let renderedContent;
    try {
      renderedContent = await renderTemplateContent(checkId, checkConfig, enrichedResult);
      if (renderedContent) emitMermaidFromMarkdown(checkId, renderedContent, "content");
    } catch (error) {
      logger.warn(`[LevelDispatch] Failed to render template for ${checkId}: ${error}`);
    }
    let outputWithTimestamp = void 0;
    if (result.output !== void 0) {
      const output = result.output;
      if (output !== null && typeof output === "object" && !Array.isArray(output))
        outputWithTimestamp = { ...output, ts: Date.now() };
      else outputWithTimestamp = output;
    }
    const enrichedResultWithContent = renderedContent ? { ...enrichedResult, content: renderedContent } : enrichedResult;
    const enrichedResultWithTimestamp = outputWithTimestamp !== void 0 ? { ...enrichedResultWithContent, output: outputWithTimestamp } : enrichedResultWithContent;
    state.completedChecks.add(checkId);
    const currentWaveCompletions = state.currentWaveCompletions;
    if (currentWaveCompletions) currentWaveCompletions.add(checkId);
    try {
      logger.info(`[LevelDispatch] Calling handleRouting for ${checkId}`);
    } catch {
    }
    const wasHalted = await handleRouting(context2, state, transition, emitEvent, {
      checkId,
      scope,
      result: enrichedResult,
      checkConfig,
      success: !hasFatalIssues(enrichedResult)
    });
    if (wasHalted) {
      logger.info(`[LevelDispatch] Execution halted after routing for ${checkId}`);
      return enrichedResult;
    }
    try {
      const commitResult = {
        ...enrichedResult,
        ...renderedContent ? { content: renderedContent } : {},
        ...result.output !== void 0 ? outputWithTimestamp !== void 0 ? { output: outputWithTimestamp } : { output: result.output } : {}
      };
      context2.journal.commitEntry({
        sessionId: context2.sessionId,
        checkId,
        result: commitResult,
        event: context2.event || "manual",
        scope
      });
    } catch (error) {
      logger.warn(`[LevelDispatch] Failed to commit to journal: ${error}`);
    }
    try {
      const duration = Date.now() - startTime;
      updateStats([{ checkId, result: enrichedResult, duration }], state, false);
    } catch {
    }
    if (isForEach) {
      try {
        const existing = state.stats.get(checkId);
        const aggStats = existing || {
          checkName: checkId,
          totalRuns: 0,
          successfulRuns: 0,
          failedRuns: 0,
          skippedRuns: 0,
          skipped: false,
          totalDuration: 0,
          issuesFound: 0,
          issuesBySeverity: { critical: 0, error: 0, warning: 0, info: 0 }
        };
        aggStats.totalRuns++;
        const hasFatal = hasFatalIssues(enrichedResultWithTimestamp);
        if (hasFatal) aggStats.failedRuns++;
        else aggStats.successfulRuns++;
        const items = enrichedResultWithTimestamp.forEachItems;
        if (Array.isArray(items)) aggStats.outputsProduced = items.length;
        state.stats.set(checkId, aggStats);
      } catch {
      }
    }
    if (isForEach && forEachItemsLocal && Array.isArray(forEachItemsLocal)) {
      for (let itemIndex = 0; itemIndex < forEachItemsLocal.length; itemIndex++) {
        const itemScope = [
          { check: checkId, index: itemIndex }
        ];
        const item = forEachItemsLocal[itemIndex];
        try {
          context2.journal.commitEntry({
            sessionId: context2.sessionId,
            checkId,
            result: { issues: [], output: item },
            event: context2.event || "manual",
            scope: itemScope
          });
        } catch (error) {
          logger.warn(
            `[LevelDispatch] Failed to commit per-item journal for ${checkId} item ${itemIndex}: ${error}`
          );
        }
      }
    }
    state.activeDispatches.delete(checkId);
    emitEvent({
      type: "CheckCompleted",
      checkId,
      scope,
      result: {
        ...enrichedResult,
        output: result.output,
        content: renderedContent || result.content
      }
    });
    return enrichedResult;
  } catch (error) {
    const err = error instanceof Error ? error : new Error(String(error));
    logger.error(`[LevelDispatch] Error executing check ${checkId}: ${err.message}`);
    state.activeDispatches.delete(checkId);
    emitEvent({
      type: "CheckErrored",
      checkId,
      scope,
      error: { message: err.message, stack: err.stack, name: err.name }
    });
    throw err;
  }
}
function mapCheckNameToFocus(checkName) {
  const focusMap = {
    security: "security",
    performance: "performance",
    style: "style",
    architecture: "architecture"
  };
  return focusMap[checkName] || "all";
}
var MAX_ON_INIT_ITEMS;
var init_execution_invoker = __esm({
  "src/state-machine/dispatch/execution-invoker.ts"() {
    "use strict";
    init_logger();
    init_trace_helpers();
    init_mermaid_telemetry();
    init_fallback_ndjson();
    init_history_snapshot();
    init_dependency_gating();
    init_template_renderer();
    init_stats_manager();
    init_routing();
    init_foreach_processor();
    init_stats_manager();
    init_on_init_handlers();
    init_sandbox();
    init_workflow_inputs();
    init_sandbox_routing();
    MAX_ON_INIT_ITEMS = 50;
  }
});

// src/state-machine/states/level-dispatch.ts
function mapCheckNameToFocus2(checkName) {
  const focusMap = {
    security: "security",
    performance: "performance",
    style: "style",
    architecture: "architecture"
  };
  return focusMap[checkName] || "all";
}
function formatScopeLabel(scope) {
  if (!scope || scope.length === 0) return "";
  return scope.map((item) => `${item.check}:${item.index}`).join("|");
}
function recordOnFinishRoutingEvent(args) {
  const attrs = {
    check_id: args.checkId,
    trigger: "on_finish",
    action: args.action,
    target: args.target,
    source: args.source
  };
  const scopeLabel = formatScopeLabel(args.scope);
  if (scopeLabel) attrs.scope = scopeLabel;
  if (args.gotoEvent) attrs.goto_event = args.gotoEvent;
  addEvent("visor.routing", attrs);
}
function getHistoryLimit2() {
  const raw = process.env.VISOR_TEST_HISTORY_LIMIT || process.env.VISOR_OUTPUT_HISTORY_LIMIT;
  if (!raw) return void 0;
  const n = parseInt(raw, 10);
  return Number.isFinite(n) && n > 0 ? n : void 0;
}
function buildOutputHistoryFromJournal2(context2) {
  const outputHistory = /* @__PURE__ */ new Map();
  const limit = getHistoryLimit2();
  try {
    const snapshot = context2.journal.beginSnapshot();
    const allEntries = context2.journal.readVisible(context2.sessionId, snapshot, void 0);
    for (const entry of allEntries) {
      const checkId = entry.checkId;
      if (!outputHistory.has(checkId)) {
        outputHistory.set(checkId, []);
      }
      const payload = entry.result.output !== void 0 ? entry.result.output : entry.result;
      if (payload !== void 0) {
        const arr = outputHistory.get(checkId);
        arr.push(payload);
        if (limit && arr.length > limit) {
          arr.splice(0, arr.length - limit);
        }
      }
    }
  } catch (error) {
    logger.debug(`[LevelDispatch] Error building output history: ${error}`);
  }
  return outputHistory;
}
async function evaluateIfCondition(checkId, checkConfig, context2, state) {
  const ifExpression = checkConfig.if;
  if (!ifExpression) {
    return true;
  }
  try {
    const evaluator = new FailureConditionEvaluator();
    const previousResults = /* @__PURE__ */ new Map();
    const currentWaveCompletions = state.currentWaveCompletions;
    const useGlobalOutputsFlag = !!(state.flags && state.flags.forwardRunActive);
    const waveKind = state.flags && state.flags.waveKind || void 0;
    const hasDeps = (() => {
      try {
        const deps = checkConfig?.depends_on;
        if (!deps) return false;
        if (Array.isArray(deps)) return deps.length > 0;
        return typeof deps === "string" ? deps.trim().length > 0 : false;
      } catch {
        return false;
      }
    })();
    const useGlobalOutputs = hasDeps || useGlobalOutputsFlag && waveKind === "forward";
    if (useGlobalOutputs) {
      try {
        const snapshotId = context2.journal.beginSnapshot();
        const ContextView = (init_snapshot_store(), __toCommonJS(snapshot_store_exports)).ContextView;
        const contextView = new ContextView(
          context2.journal,
          context2.sessionId,
          snapshotId,
          [],
          context2.event
        );
        for (const key of Object.keys(context2.checks || {})) {
          const jr = contextView.get(key);
          if (jr) previousResults.set(key, jr);
        }
      } catch {
      }
    } else if (currentWaveCompletions) {
      for (const key of currentWaveCompletions) {
        try {
          const snapshotId = context2.journal.beginSnapshot();
          const ContextView = (init_snapshot_store(), __toCommonJS(snapshot_store_exports)).ContextView;
          const contextView = new ContextView(
            context2.journal,
            context2.sessionId,
            snapshotId,
            [],
            context2.event
          );
          const journalResult = contextView.get(key);
          if (journalResult) {
            previousResults.set(key, journalResult);
          }
        } catch {
        }
      }
    }
    const envSnapshot = {};
    for (const [key, value] of Object.entries(process.env)) {
      if (value !== void 0) {
        envSnapshot[key] = value;
      }
    }
    if (context2.config.env) {
      for (const [key, value] of Object.entries(context2.config.env)) {
        if (value !== void 0 && value !== null) {
          envSnapshot[key] = String(value);
        }
      }
    }
    const contextData = {
      previousResults,
      event: context2.event || "manual",
      branch: context2.prInfo?.branch,
      baseBranch: context2.prInfo?.baseBranch,
      filesChanged: context2.prInfo?.files?.map((f) => f.filename),
      environment: envSnapshot,
      workflowInputs: context2.config.workflow_inputs || {}
    };
    const shouldRun = await evaluator.evaluateIfCondition(checkId, ifExpression, contextData);
    return shouldRun;
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    logger.error(`Failed to evaluate if expression for check '${checkId}': ${msg}`);
    return false;
  }
}
async function handleLevelDispatch(context2, state, transition, emitEvent) {
  const level = state.levelQueue.shift();
  if (!level) {
    if (context2.debug) {
      logger.info("[LevelDispatch] No more levels in queue");
    }
    transition("WavePlanning");
    return;
  }
  if (context2.debug) {
    logger.info(
      `[LevelDispatch] Executing level ${level.level} with ${level.parallel.length} checks`
    );
  }
  state.currentLevel = level.level;
  state.currentLevelChecks = new Set(level.parallel);
  const levelChecksPreview = level.parallel.slice(0, 5).join(",");
  setSpanAttributes({
    level_size: level.parallel.length,
    level_checks_preview: levelChecksPreview
  });
  emitEvent({ type: "LevelReady", level, wave: state.wave });
  const maxParallelism = context2.maxParallelism || 10;
  const results = [];
  const sessionGroups = groupBySession(level.parallel, context2);
  for (const group of sessionGroups) {
    const groupResults = await executeCheckGroup(
      group,
      context2,
      state,
      maxParallelism,
      emitEvent,
      transition
    );
    results.push(...groupResults);
    if (context2.failFast && shouldFailFast(results)) {
      logger.warn("[LevelDispatch] Fail-fast triggered");
      state.flags.failFastTriggered = true;
      break;
    }
  }
  emitEvent({ type: "LevelDepleted", level: level.level, wave: state.wave });
  const nonForEachResults = results.filter((r) => {
    if (r.result.isForEach) return false;
    if (r.result.__skipped) return false;
    return true;
  });
  updateStats2(nonForEachResults, state);
  if (state.flags.failFastTriggered) {
    state.levelQueue = [];
    if (context2.debug) {
      logger.info("[LevelDispatch] Fail-fast triggered, clearing level queue");
    }
  }
  state.currentLevelChecks.clear();
  if (state.currentState !== "Error") {
    transition("WavePlanning");
  } else {
    logger.info("[LevelDispatch] Skipping transition to WavePlanning - already in Error state");
  }
}
function groupBySession(checks, context2) {
  const sessionProviderMap = /* @__PURE__ */ new Map();
  const noSessionChecks = [];
  for (const checkId of checks) {
    const metadata = context2.checks[checkId];
    const sessionProvider = metadata?.sessionProvider;
    if (sessionProvider) {
      const group = sessionProviderMap.get(sessionProvider) || [];
      group.push(checkId);
      sessionProviderMap.set(sessionProvider, group);
    } else {
      noSessionChecks.push(checkId);
    }
  }
  const groups = [];
  for (const group of sessionProviderMap.values()) {
    groups.push(group);
  }
  if (noSessionChecks.length > 0) {
    groups.push(noSessionChecks);
  }
  return groups;
}
async function executeCheckGroup(checks, context2, state, maxParallelism, emitEvent, transition) {
  const results = [];
  const seen = /* @__PURE__ */ new Set();
  const uniqueChecks = [];
  for (const id of checks) {
    if (!seen.has(id)) {
      seen.add(id);
      uniqueChecks.push(id);
    }
  }
  const pool = [];
  for (const checkId of uniqueChecks) {
    const scopedRuns = state.pendingRunScopes && state.pendingRunScopes.get(checkId) || [];
    try {
      const currentWaveCompletions = state.currentWaveCompletions;
      if (currentWaveCompletions && currentWaveCompletions.has(checkId)) {
        if (context2.debug) {
          logger.info(`[LevelDispatch] Skipping ${checkId}: already completed in current wave`);
        }
        continue;
      }
    } catch {
    }
    if (pool.length >= maxParallelism) {
      await Promise.race(pool);
      pool.splice(
        0,
        pool.length,
        ...pool.filter((p) => {
          const settled = p._settled;
          return !settled;
        })
      );
    }
    const runOnce = async (scopeOverride) => {
      const startTime = Date.now();
      try {
        const result = await executeSingleCheck2(
          checkId,
          context2,
          state,
          emitEvent,
          transition,
          scopeOverride
        );
        const duration = Date.now() - startTime;
        results.push({ checkId, result, duration });
      } catch (error) {
        const duration = Date.now() - startTime;
        const err = error instanceof Error ? error : new Error(String(error));
        logger.error(`[LevelDispatch] Error executing check ${checkId}: ${err.message}`);
        results.push({ checkId, result: { issues: [] }, error: err, duration });
      }
    };
    const promise = (async () => {
      if (scopedRuns.length > 0) {
        for (const sc of scopedRuns) {
          await runOnce(sc);
        }
        try {
          state.pendingRunScopes?.delete(checkId);
        } catch {
        }
      } else {
        await runOnce();
      }
    })();
    promise.then(() => {
      promise._settled = true;
    }).catch(() => {
      promise._settled = true;
    });
    pool.push(promise);
  }
  await Promise.all(pool);
  return results;
}
async function executeCheckWithForEachItems2(checkId, forEachParent, forEachItems, context2, state, emitEvent, transition) {
  try {
    const snapId = context2.journal.beginSnapshot();
    const visible = context2.journal.readVisible(context2.sessionId, snapId, context2.event);
    let latestItems;
    for (let i = visible.length - 1; i >= 0; i--) {
      const e = visible[i];
      if (e.checkId === forEachParent && Array.isArray(e.scope) && e.scope.length === 0) {
        const r = e.result;
        if (r && Array.isArray(r.forEachItems)) {
          latestItems = r.forEachItems;
          break;
        }
      }
    }
    if (Array.isArray(latestItems)) {
      if (context2.debug) {
        try {
          const prevLen = Array.isArray(forEachItems) ? forEachItems.length : 0;
          const newLen = latestItems.length;
          if (prevLen !== newLen) {
            logger.info(
              `[LevelDispatch] Refreshing forEachItems for ${checkId}: from parent '${forEachParent}' latestItems=${newLen} (was ${prevLen})`
            );
          }
        } catch {
        }
      }
      forEachItems = latestItems;
    }
  } catch (e) {
    if (context2.debug) {
      logger.warn(
        `[LevelDispatch] Failed to refresh forEachItems from journal for ${forEachParent}: ${e}`
      );
    }
  }
  const checkConfig = context2.config.checks?.[checkId];
  if (!checkConfig) {
    throw new Error(`Check configuration not found: ${checkId}`);
  }
  logger.info(
    `[LevelDispatch][DEBUG] executeCheckWithForEachItems: checkId=${checkId}, forEachParent=${forEachParent}, items=${forEachItems.length}`
  );
  logger.info(
    `[LevelDispatch][DEBUG] forEachItems: ${JSON.stringify(forEachItems).substring(0, 200)}`
  );
  const allIssues = [];
  const perItemResults = [];
  const allOutputs = [];
  const allContents = [];
  const perIterationDurations = [];
  const scope = [];
  const sharedDependencyResults = buildDependencyResultsWithScope2(
    checkId,
    checkConfig,
    context2,
    scope
  );
  if (checkConfig.on_init) {
    try {
      const { handleOnInit: handleOnInit2 } = (init_execution_invoker(), __toCommonJS(execution_invoker_exports));
      const dependencyResultsMap = {};
      for (const [key, value] of sharedDependencyResults.entries()) {
        dependencyResultsMap[key] = value;
      }
      const prInfo = context2.prInfo;
      const executionContext = {
        sessionId: context2.sessionId,
        checkId,
        event: context2.event,
        _parentContext: context2
      };
      await handleOnInit2(
        checkId,
        checkConfig.on_init,
        context2,
        scope,
        prInfo,
        dependencyResultsMap,
        executionContext
      );
      for (const [key, value] of Object.entries(dependencyResultsMap)) {
        if (!sharedDependencyResults.has(key)) {
          sharedDependencyResults.set(key, value);
        }
      }
      logger.info(`[LevelDispatch] on_init completed for ${checkId} before forEach loop`);
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      logger.error(`[LevelDispatch] on_init failed for ${checkId}: ${err.message}`);
      throw err;
    }
  }
  for (let itemIndex = 0; itemIndex < forEachItems.length; itemIndex++) {
    const iterationStartMs = Date.now();
    const scope2 = [
      { check: forEachParent, index: itemIndex }
    ];
    const forEachItem = forEachItems[itemIndex];
    logger.info(
      `[LevelDispatch][DEBUG] Starting iteration ${itemIndex} of ${checkId}, parent=${forEachParent}, item=${JSON.stringify(forEachItem)?.substring(0, 100)}`
    );
    const shouldSkipDueToParentFailure = forEachItem?.__failed === true || forEachItem?.__skip === true;
    if (shouldSkipDueToParentFailure) {
      logger.info(
        `\u23ED  Skipped ${checkId} iteration ${itemIndex} (forEach parent "${forEachParent}" iteration ${itemIndex} marked as failed)`
      );
      const iterationDurationMs = Date.now() - iterationStartMs;
      perIterationDurations.push(iterationDurationMs);
      perItemResults.push({ issues: [] });
      allOutputs.push({ __skip: true });
      continue;
    }
    try {
      emitNdjsonSpanWithEvents(
        "visor.foreach.item",
        {
          "visor.check.id": checkId,
          "visor.foreach.index": itemIndex,
          "visor.foreach.total": forEachItems.length
        },
        []
      );
    } catch (error) {
      logger.warn(`[LevelDispatch] Failed to emit foreach.item span: ${error}`);
    }
    emitEvent({ type: "CheckScheduled", checkId, scope: scope2 });
    const dispatch = {
      id: `${checkId}-${itemIndex}-${Date.now()}`,
      checkId,
      scope: scope2,
      provider: context2.checks[checkId]?.providerType || "unknown",
      startMs: Date.now(),
      attempts: 1,
      foreachIndex: itemIndex
    };
    state.activeDispatches.set(`${checkId}-${itemIndex}`, dispatch);
    try {
      const providerType = checkConfig.type || "ai";
      const providerRegistry = (init_check_provider_registry(), __toCommonJS(check_provider_registry_exports)).CheckProviderRegistry.getInstance();
      const provider = providerRegistry.getProviderOrThrow(providerType);
      const outputHistory = buildOutputHistoryFromJournal2(context2);
      const workflowInputs = resolveWorkflowInputs(checkConfig, context2);
      const providerConfig = {
        type: providerType,
        checkName: checkId,
        prompt: checkConfig.prompt,
        exec: checkConfig.exec,
        schema: checkConfig.schema,
        group: checkConfig.group,
        focus: checkConfig.focus || mapCheckNameToFocus2(checkId),
        transform: checkConfig.transform,
        transform_js: checkConfig.transform_js,
        env: checkConfig.env,
        forEach: checkConfig.forEach,
        ...checkConfig,
        eventContext: context2.prInfo?.eventContext || {},
        __outputHistory: outputHistory,
        // Propagate workflow inputs for template access via {{ inputs.* }}
        workflowInputs,
        ai: {
          ...checkConfig.ai || {},
          timeout: checkConfig.ai?.timeout || 18e5,
          debug: !!context2.debug
        }
      };
      try {
        const maybeOctokit = context2.executionContext?.octokit;
        if (maybeOctokit) {
          providerConfig.eventContext = {
            ...providerConfig.eventContext,
            octokit: maybeOctokit
          };
        }
      } catch {
      }
      try {
        const webhookCtx = context2.executionContext?.webhookContext;
        const webhookData = webhookCtx?.webhookData;
        if (context2.debug) {
          logger.info(
            `[LevelDispatch] webhookContext: ${webhookCtx ? "present" : "absent"}, webhookData size: ${webhookData?.size || 0}`
          );
        }
        if (webhookData && webhookData.size > 0) {
          for (const payload of webhookData.values()) {
            const slackConv = payload?.slack_conversation;
            if (slackConv) {
              const event = payload?.event;
              const messageCount = Array.isArray(slackConv?.messages) ? slackConv.messages.length : 0;
              if (context2.debug) {
                logger.info(
                  `[LevelDispatch] Slack conversation extracted: ${messageCount} messages`
                );
              }
              providerConfig.eventContext = {
                ...providerConfig.eventContext,
                slack: {
                  event: event || {},
                  conversation: slackConv
                },
                conversation: slackConv
                // Also expose at top level for convenience
              };
              break;
            }
          }
        }
      } catch {
      }
      const dependencyResults = buildDependencyResultsWithScope2(
        checkId,
        checkConfig,
        context2,
        scope2
      );
      for (const [key, value] of sharedDependencyResults.entries()) {
        if (!dependencyResults.has(key)) {
          dependencyResults.set(key, value);
        }
      }
      try {
        const rawDeps = checkConfig?.depends_on || [];
        const depList = Array.isArray(rawDeps) ? rawDeps : [rawDeps];
        if (depList.length > 0) {
          const groupSatisfied = (token) => {
            if (typeof token !== "string") return true;
            const orOptions = token.includes("|") ? token.split("|").map((s) => s.trim()).filter(Boolean) : [token];
            for (const opt of orOptions) {
              const dr = dependencyResults.get(opt);
              const depCfg = context2.config.checks?.[opt];
              const cont = !!(depCfg && depCfg.continue_on_failure === true);
              let failed = false;
              let skipped = false;
              if (!dr) {
                failed = true;
              } else {
                const out = dr.output;
                const fatal = hasFatalIssues2(dr);
                failed = fatal || !!out && typeof out === "object" && out.__failed === true;
                skipped = !!(out && typeof out === "object" && out.__skip === true);
              }
              const satisfied = !skipped && (!failed || cont);
              if (satisfied) return true;
            }
            return false;
          };
          let allSatisfied = true;
          for (const token of depList) {
            if (!groupSatisfied(token)) {
              allSatisfied = false;
              break;
            }
          }
          if (!allSatisfied) {
            if (context2.debug) {
              logger.info(
                `[LevelDispatch] Skipping ${checkId} iteration ${itemIndex} due to unsatisfied dependency group(s)`
              );
            }
            const iterationDurationMs2 = Date.now() - iterationStartMs;
            perIterationDurations.push(iterationDurationMs2);
            perItemResults.push({ issues: [] });
            allOutputs.push({ __skip: true });
            continue;
          }
        }
      } catch {
      }
      const prInfo = context2.prInfo || {
        number: 1,
        title: "State Machine Execution",
        author: "system",
        eventType: context2.event || "manual",
        eventContext: {},
        files: [],
        commits: []
      };
      const executionContext = {
        ...context2.executionContext,
        _engineMode: context2.mode,
        _parentContext: context2,
        _parentState: state
      };
      {
        const assumeExpr = checkConfig?.assume;
        if (assumeExpr) {
          let ok = true;
          try {
            const evaluator = new FailureConditionEvaluator();
            const exprs = Array.isArray(assumeExpr) ? assumeExpr : [assumeExpr];
            for (const ex of exprs) {
              const res = await evaluator.evaluateIfCondition(checkId, ex, {
                event: context2.event || "manual",
                previousResults: dependencyResults
              });
              if (!res) {
                ok = false;
                break;
              }
            }
          } catch (error) {
            const msg = error instanceof Error ? error.message : String(error);
            logger.error(`Failed to evaluate assume expression for check '${checkId}': ${msg}`);
            ok = false;
          }
          if (!ok) {
            logger.info(
              `\u23ED  Skipped (assume: ${String(Array.isArray(assumeExpr) ? assumeExpr[0] : assumeExpr).substring(0, 40)}${String(Array.isArray(assumeExpr) ? assumeExpr[0] : assumeExpr).length > 40 ? "..." : ""})`
            );
            const iterationDurationMs2 = Date.now() - iterationStartMs;
            perIterationDurations.push(iterationDurationMs2);
            perItemResults.push({ issues: [] });
            allOutputs.push({ __skip: true });
            continue;
          }
        }
      }
      try {
        emitNdjsonFallback("visor.provider", {
          "visor.check.id": checkId,
          "visor.provider.type": providerType
        });
      } catch {
      }
      const itemResult = await withActiveSpan(
        `visor.check.${checkId}`,
        {
          "visor.check.id": checkId,
          "visor.check.type": providerType,
          "visor.foreach.index": itemIndex,
          session_id: context2.sessionId,
          wave: state.wave
        },
        async () => executeWithSandboxRouting(
          checkId,
          checkConfig,
          context2,
          prInfo,
          dependencyResults,
          checkConfig.ai?.timeout || 18e5,
          () => provider.execute(prInfo, providerConfig, dependencyResults, executionContext)
        )
      );
      const enrichedIssues = (itemResult.issues || []).map((issue) => ({
        ...issue,
        checkName: checkId,
        ruleId: `${checkId}/${issue.ruleId || "unknown"}`,
        group: checkConfig.group,
        schema: typeof checkConfig.schema === "object" ? "custom" : checkConfig.schema,
        template: checkConfig.template,
        timestamp: Date.now()
      }));
      let output = itemResult.output;
      let content = itemResult.content;
      if (!content && enrichedIssues.length > 0) {
        content = enrichedIssues.map(
          (i) => `- **${i.severity.toUpperCase()}**: ${i.message} (${i.file}:${i.line})`
        ).join("\n");
      }
      const iterationHasFatalIssues = enrichedIssues.some((issue) => {
        const ruleId = issue.ruleId || "";
        return ruleId.endsWith("/error") || // System errors
        ruleId.includes("/execution_error") || // Command failures
        ruleId.includes("timeout") || // Timeouts
        ruleId.endsWith("_fail_if");
      });
      if (iterationHasFatalIssues && output !== void 0 && output !== null && typeof output === "object") {
        output = { ...output, __failed: true };
      } else if (iterationHasFatalIssues) {
        output = { __value: output, __failed: true };
      }
      logger.info(
        `[LevelDispatch][DEBUG] Iteration ${itemIndex}: output=${JSON.stringify(output)?.substring(0, 100)}, hasFatalIssues=${iterationHasFatalIssues}`
      );
      const enrichedResult = {
        ...itemResult,
        issues: enrichedIssues,
        ...content ? { content } : {}
      };
      try {
        let schemaObj = (typeof checkConfig.schema === "object" ? checkConfig.schema : void 0) || checkConfig.output_schema;
        if (!schemaObj && typeof checkConfig.schema === "string") {
          try {
            const { loadRendererSchema } = await import("./renderer-schema-CMXOLNIG.mjs");
            schemaObj = await loadRendererSchema(checkConfig.schema);
          } catch {
          }
        }
        const itemOutput = output;
        if (schemaObj && itemOutput !== void 0) {
          const Ajv2 = __require("ajv");
          const ajv = new Ajv2({ allErrors: true, allowUnionTypes: true, strict: false });
          const validate = ajv.compile(schemaObj);
          const valid = validate(itemOutput);
          if (!valid) {
            const errs = (validate.errors || []).slice(0, 3).map((e) => e.message).join("; ");
            const issue = {
              file: "contract",
              line: 0,
              ruleId: `contract/schema_validation_failed`,
              message: `Output schema validation failed${errs ? `: ${errs}` : ""}`,
              severity: "error",
              category: "logic",
              checkName: checkId,
              group: checkConfig.group,
              schema: "json-schema",
              timestamp: Date.now()
            };
            enrichedResult.issues = [...enrichedResult.issues || [], issue];
            if (Array.isArray(enrichedIssues)) {
              enrichedIssues.push(issue);
            }
          }
        }
      } catch {
      }
      try {
        const guaranteeExpr = checkConfig?.guarantee;
        if (guaranteeExpr) {
          const evaluator = new FailureConditionEvaluator();
          const exprs = Array.isArray(guaranteeExpr) ? guaranteeExpr : [guaranteeExpr];
          for (const ex of exprs) {
            const holds = await evaluator.evaluateIfCondition(checkId, ex, {
              previousResults: dependencyResults,
              event: context2.event || "manual",
              output
              // Pass the iteration output for guarantee evaluation
            });
            if (!holds) {
              const issue = {
                file: "contract",
                line: 0,
                ruleId: `contract/guarantee_failed`,
                message: `Guarantee failed: ${ex}`,
                severity: "error",
                category: "logic",
                checkName: checkId,
                group: checkConfig.group,
                schema: typeof checkConfig.schema === "object" ? "custom" : checkConfig.schema,
                timestamp: Date.now()
              };
              enrichedResult.issues = [...enrichedResult.issues || [], issue];
            }
          }
        }
      } catch {
      }
      if (checkConfig.fail_if) {
        try {
          const evaluator = new FailureConditionEvaluator();
          const failed = await evaluator.evaluateSimpleCondition(
            checkId,
            typeof checkConfig.schema === "object" ? "custom" : checkConfig.schema || "",
            checkConfig.group || "",
            enrichedResult,
            checkConfig.fail_if,
            Object.fromEntries(dependencyResults.entries())
          );
          if (failed) {
            logger.warn(
              `[LevelDispatch] fail_if triggered for ${checkId} iteration ${itemIndex}: ${checkConfig.fail_if}`
            );
            const failIssue = {
              file: "system",
              line: 0,
              ruleId: `${checkId}/${checkId}_fail_if`,
              message: `Check failure condition met: ${checkConfig.fail_if}`,
              severity: "error",
              category: "logic",
              checkName: checkId,
              group: checkConfig.group,
              schema: typeof checkConfig.schema === "object" ? "custom" : checkConfig.schema,
              timestamp: Date.now()
            };
            enrichedResult.issues = [...enrichedResult.issues || [], failIssue];
            enrichedIssues.push(failIssue);
            allIssues.push(failIssue);
            const nowHasFatalIssues = enrichedResult.issues.some((issue) => {
              const ruleId = issue.ruleId || "";
              return ruleId.endsWith("/error") || ruleId.includes("/execution_error") || ruleId.includes("timeout") || ruleId.endsWith("_fail_if");
            });
            if (nowHasFatalIssues && output !== void 0 && output !== null && typeof output === "object" && !output.__failed) {
              output = { ...output, __failed: true };
            } else if (nowHasFatalIssues && !output?.__failed) {
              output = { __value: output, __failed: true };
            }
          }
        } catch (error) {
          const msg = error instanceof Error ? error.message : String(error);
          logger.error(
            `[LevelDispatch] Error evaluating fail_if for ${checkId} iteration ${itemIndex}: ${msg}`
          );
        }
      }
      perItemResults.push(enrichedResult);
      allIssues.push(...enrichedIssues);
      allOutputs.push(output);
      if (typeof content === "string" && content.trim()) {
        allContents.push(content.trim());
      }
      try {
        const journalEntry = {
          sessionId: context2.sessionId,
          checkId,
          result: { ...enrichedResult, output },
          event: context2.event || "manual",
          scope: scope2
        };
        logger.info(
          `[LevelDispatch][DEBUG] Committing to journal: checkId=${checkId}, scope=${JSON.stringify(scope2)}, hasOutput=${output !== void 0}`
        );
        context2.journal.commitEntry(journalEntry);
      } catch (error) {
        logger.warn(`[LevelDispatch] Failed to commit to journal: ${error}`);
      }
      state.activeDispatches.delete(`${checkId}-${itemIndex}`);
      emitEvent({
        type: "CheckCompleted",
        checkId,
        scope: scope2,
        result: {
          ...enrichedResult,
          output
        }
      });
      const iterationDurationMs = Date.now() - iterationStartMs;
      perIterationDurations.push(iterationDurationMs);
      updateStats2(
        [{ checkId, result: enrichedResult, duration: iterationDurationMs }],
        state,
        true
      );
    } catch (error) {
      const iterationDurationMs = Date.now() - iterationStartMs;
      perIterationDurations.push(iterationDurationMs);
      const err = error instanceof Error ? error : new Error(String(error));
      logger.error(
        `[LevelDispatch] Error executing check ${checkId} item ${itemIndex}: ${err.message}`
      );
      state.activeDispatches.delete(`${checkId}-${itemIndex}`);
      emitEvent({
        type: "CheckErrored",
        checkId,
        scope: scope2,
        error: {
          message: err.message,
          stack: err.stack,
          name: err.name
        }
      });
      const errorIssue = {
        file: "",
        line: 0,
        ruleId: `${checkId}/error`,
        message: err.message,
        severity: "error",
        category: "logic"
      };
      allIssues.push(errorIssue);
      perItemResults.push({ issues: [errorIssue] });
      updateStats2(
        [{ checkId, result: { issues: [errorIssue] }, error: err, duration: iterationDurationMs }],
        state,
        true
      );
    }
  }
  state.completedChecks.add(checkId);
  const checkStats = state.stats.get(checkId);
  if (checkStats) {
    checkStats.outputsProduced = allOutputs.length;
    checkStats.perIterationDuration = perIterationDurations;
    const previewItems = allOutputs.slice(0, 3).map((item) => {
      const str = typeof item === "string" ? item : JSON.stringify(item) ?? "undefined";
      return str.length > 50 ? str.substring(0, 50) + "..." : str;
    });
    if (allOutputs.length > 3) {
      checkStats.forEachPreview = [...previewItems, `...${allOutputs.length - 3} more`];
    } else {
      checkStats.forEachPreview = previewItems;
    }
    state.stats.set(checkId, checkStats);
    if (checkStats.totalRuns > 0 && checkStats.failedRuns === checkStats.totalRuns) {
      logger.info(
        `[LevelDispatch] forEach check ${checkId} failed completely (${checkStats.failedRuns}/${checkStats.totalRuns} iterations failed)`
      );
      if (!state.failedChecks) {
        state.failedChecks = /* @__PURE__ */ new Set();
      }
      state.failedChecks.add(checkId);
    }
  }
  const aggregatedResult = {
    issues: allIssues,
    isForEach: true,
    forEachItems: allOutputs,
    forEachItemResults: perItemResults,
    // Include aggregated content from all iterations
    ...allContents.length > 0 ? { content: allContents.join("\n") } : {}
  };
  logger.info(
    `[LevelDispatch][DEBUG] Aggregated result for ${checkId}: forEachItems.length=${allOutputs.length}, results=${perItemResults.length}`
  );
  logger.info(`[LevelDispatch][DEBUG] allOutputs: ${JSON.stringify(allOutputs).substring(0, 200)}`);
  try {
    logger.info(`[LevelDispatch] Calling handleRouting for ${checkId}`);
  } catch {
  }
  let wasHalted = false;
  try {
    state.completedChecks.add(checkId);
    const currentWaveCompletions = state.currentWaveCompletions;
    if (currentWaveCompletions) currentWaveCompletions.add(checkId);
    wasHalted = await handleRouting(context2, state, transition, emitEvent, {
      checkId,
      scope: [],
      result: aggregatedResult,
      checkConfig,
      success: !hasFatalIssues2(aggregatedResult)
    });
  } catch (error) {
    logger.warn(`[LevelDispatch] Routing error for aggregated forEach ${checkId}: ${error}`);
  }
  if (wasHalted) {
    logger.info(`[LevelDispatch] Execution halted after routing for aggregated ${checkId}`);
    return aggregatedResult;
  }
  try {
    context2.journal.commitEntry({
      sessionId: context2.sessionId,
      checkId,
      result: aggregatedResult,
      event: context2.event || "manual",
      scope: []
    });
    logger.info(`[LevelDispatch][DEBUG] Committed aggregated result to journal with scope=[]`);
  } catch (error) {
    logger.warn(`[LevelDispatch] Failed to commit aggregated forEach result to journal: ${error}`);
  }
  emitEvent({
    type: "CheckCompleted",
    checkId,
    scope: [],
    result: aggregatedResult
  });
  const parentCheckConfig = context2.config.checks?.[forEachParent];
  logger.info(
    `[LevelDispatch][DEBUG] Checking on_finish for forEach parent ${forEachParent}: has_on_finish=${!!parentCheckConfig?.on_finish}, is_forEach=${!!parentCheckConfig?.forEach}`
  );
  if (parentCheckConfig?.on_finish && parentCheckConfig.forEach) {
    logger.info(
      `[LevelDispatch] Processing on_finish for forEach parent ${forEachParent} after children complete`
    );
    try {
      const snapshotId = context2.journal.beginSnapshot();
      const contextView = new (init_snapshot_store(), __toCommonJS(snapshot_store_exports)).ContextView(
        context2.journal,
        context2.sessionId,
        snapshotId,
        [],
        context2.event
      );
      const parentResult = contextView.get(forEachParent);
      if (parentResult) {
        logger.info(
          `[LevelDispatch] Found parent result for ${forEachParent}, evaluating on_finish`
        );
        const onFinish = parentCheckConfig.on_finish;
        let queuedForward = false;
        logger.info(
          `[LevelDispatch] on_finish.run: ${onFinish.run?.length || 0} targets, targets=${JSON.stringify(onFinish.run || [])}`
        );
        if (onFinish.run && onFinish.run.length > 0) {
          for (const targetCheck of onFinish.run) {
            logger.info(`[LevelDispatch] Processing on_finish.run target: ${targetCheck}`);
            logger.info(
              `[LevelDispatch] Loop budget check: routingLoopCount=${state.routingLoopCount}, max_loops=${context2.config.routing?.max_loops ?? 10}`
            );
            if (checkLoopBudget(context2, state, "on_finish", "run")) {
              const errorIssue = {
                file: "system",
                line: 0,
                ruleId: `${forEachParent}/routing/loop_budget_exceeded`,
                message: `Routing loop budget exceeded (max_loops=${context2.config.routing?.max_loops ?? 10}) during on_finish run`,
                severity: "error",
                category: "logic"
              };
              parentResult.issues = [...parentResult.issues || [], errorIssue];
              try {
                context2.journal.commitEntry({
                  sessionId: context2.sessionId,
                  checkId: forEachParent,
                  result: parentResult,
                  event: context2.event || "manual",
                  scope: []
                });
              } catch (err) {
                logger.warn(
                  `[LevelDispatch] Failed to commit parent result with loop budget error: ${err}`
                );
              }
              return aggregatedResult;
            }
            state.routingLoopCount++;
            recordOnFinishRoutingEvent({
              checkId: forEachParent,
              action: "run",
              target: targetCheck,
              source: "run",
              scope: []
            });
            emitEvent({
              type: "ForwardRunRequested",
              target: targetCheck,
              scope: [],
              origin: "run"
            });
            queuedForward = true;
          }
        }
        try {
          const { evaluateTransitions } = await import("./routing-S3Y7T2X3.mjs");
          const transTarget = await evaluateTransitions(
            onFinish.transitions,
            forEachParent,
            parentCheckConfig,
            parentResult,
            context2,
            state
          );
          if (transTarget !== void 0) {
            if (transTarget) {
              if (checkLoopBudget(context2, state, "on_finish", "goto")) {
                const errorIssue = {
                  file: "system",
                  line: 0,
                  ruleId: `${forEachParent}/routing/loop_budget_exceeded`,
                  message: `Routing loop budget exceeded (max_loops=${context2.config.routing?.max_loops ?? 10}) during on_finish transitions`,
                  severity: "error",
                  category: "logic"
                };
                parentResult.issues = [...parentResult.issues || [], errorIssue];
                try {
                  context2.journal.commitEntry({
                    sessionId: context2.sessionId,
                    checkId: forEachParent,
                    result: parentResult,
                    event: context2.event || "manual",
                    scope: []
                  });
                } catch {
                }
                return aggregatedResult;
              }
              state.routingLoopCount++;
              recordOnFinishRoutingEvent({
                checkId: forEachParent,
                action: "goto",
                target: transTarget.to,
                source: "transitions",
                scope: [],
                gotoEvent: transTarget.goto_event
              });
              emitEvent({
                type: "ForwardRunRequested",
                target: transTarget.to,
                scope: [],
                origin: "goto_js",
                gotoEvent: transTarget.goto_event
              });
              queuedForward = true;
            }
            if (queuedForward) {
            }
            return aggregatedResult;
          }
        } catch (e) {
          logger.error(
            `[LevelDispatch] Error evaluating on_finish transitions for ${forEachParent}: ${e instanceof Error ? e.message : String(e)}`
          );
        }
        const { evaluateGoto: evaluateGoto2 } = await import("./routing-S3Y7T2X3.mjs");
        if (context2.debug) {
          logger.info(
            `[LevelDispatch] Evaluating on_finish.goto_js for forEach parent: ${forEachParent}`
          );
          if (onFinish.goto_js) {
            logger.info(`[LevelDispatch] goto_js code: ${onFinish.goto_js.substring(0, 200)}`);
          }
          try {
            const snapshotId2 = context2.journal.beginSnapshot();
            const all = context2.journal.readVisible(context2.sessionId, snapshotId2, void 0);
            const keys = Array.from(new Set(all.map((e) => e.checkId)));
            logger.info(`[LevelDispatch] history keys: ${keys.join(", ")}`);
          } catch {
          }
        }
        const gotoTarget = await evaluateGoto2(
          onFinish.goto_js,
          onFinish.goto,
          forEachParent,
          parentCheckConfig,
          parentResult,
          context2,
          state
        );
        if (context2.debug) {
          logger.info(`[LevelDispatch] goto_js evaluation result: ${gotoTarget || "null"}`);
        }
        if (gotoTarget) {
          if (queuedForward && gotoTarget === forEachParent) {
            logger.info(
              `[LevelDispatch] on_finish.goto to self (${gotoTarget}) deferred, will process after WaveRetry`
            );
          }
          if (checkLoopBudget(context2, state, "on_finish", "goto")) {
            const errorIssue = {
              file: "system",
              line: 0,
              ruleId: `${forEachParent}/routing/loop_budget_exceeded`,
              message: `Routing loop budget exceeded (max_loops=${context2.config.routing?.max_loops ?? 10}) during on_finish goto`,
              severity: "error",
              category: "logic"
            };
            parentResult.issues = [...parentResult.issues || [], errorIssue];
            try {
              context2.journal.commitEntry({
                sessionId: context2.sessionId,
                checkId: forEachParent,
                result: parentResult,
                event: context2.event || "manual",
                scope: []
              });
            } catch (err) {
              logger.warn(
                `[LevelDispatch] Failed to commit parent result with loop budget error: ${err}`
              );
            }
            return aggregatedResult;
          }
          logger.info(`[LevelDispatch] on_finish for ${forEachParent} routing to: ${gotoTarget}`);
          state.routingLoopCount++;
          recordOnFinishRoutingEvent({
            checkId: forEachParent,
            action: "goto",
            target: gotoTarget,
            source: onFinish.goto_js ? "goto_js" : "goto",
            scope: []
          });
          emitEvent({
            type: "ForwardRunRequested",
            target: gotoTarget,
            scope: [],
            origin: "goto_js",
            gotoEvent: context2.event
          });
          state.flags.forwardRunRequested = true;
          try {
            const guardKeyGoto = `waveRetry:on_finish:${forEachParent}:wave:${state.wave}`;
            if (!state.forwardRunGuards?.has(guardKeyGoto)) {
              state.forwardRunGuards?.add(guardKeyGoto);
              emitEvent({ type: "WaveRetry", reason: "on_finish" });
            }
          } catch {
          }
        } else {
          logger.info(`[LevelDispatch] on_finish for ${forEachParent} returned null, no routing`);
        }
        if (queuedForward) {
          const guardKey = `waveRetry:on_finish:${forEachParent}:wave:${state.wave}`;
          logger.info(
            `[LevelDispatch] Checking WaveRetry guard: ${guardKey}, has=${!!state.forwardRunGuards?.has(guardKey)}`
          );
          if (!state.forwardRunGuards?.has(guardKey)) {
            state.forwardRunGuards?.add(guardKey);
            logger.info(`[LevelDispatch] Emitting WaveRetry event for on_finish.run targets`);
            emitEvent({ type: "WaveRetry", reason: "on_finish" });
          }
        } else {
        }
      } else {
        logger.warn(`[LevelDispatch] Could not find parent result for ${forEachParent} in journal`);
      }
    } catch (error) {
      logger.error(
        `[LevelDispatch] Error processing on_finish for forEach parent ${forEachParent}: ${error}`
      );
    }
  }
  return aggregatedResult;
}
async function executeSingleCheck2(checkId, context2, state, emitEvent, transition, scopeOverride) {
  const checkConfig = context2.config.checks?.[checkId];
  if (checkConfig?.if) {
    const shouldRun = await evaluateIfCondition(checkId, checkConfig, context2, state);
    if (!shouldRun) {
      logger.info(
        `\u23ED  Skipped (if: ${checkConfig.if.substring(0, 40)}${checkConfig.if.length > 40 ? "..." : ""})`
      );
      const emptyResult = { issues: [] };
      try {
        Object.defineProperty(emptyResult, "__skipped", {
          value: "if_condition",
          enumerable: false
        });
      } catch {
      }
      state.completedChecks.add(checkId);
      const stats = {
        checkName: checkId,
        totalRuns: 0,
        successfulRuns: 0,
        failedRuns: 0,
        skippedRuns: 0,
        skipped: true,
        skipReason: "if_condition",
        skipCondition: checkConfig.if,
        totalDuration: 0,
        issuesFound: 0,
        issuesBySeverity: {
          critical: 0,
          error: 0,
          warning: 0,
          info: 0
        }
      };
      state.stats.set(checkId, stats);
      logger.info(`[LevelDispatch] Recorded skip stats for ${checkId}: skipReason=if_condition`);
      try {
        context2.journal.commitEntry({
          sessionId: context2.sessionId,
          checkId,
          result: emptyResult,
          event: context2.event || "manual",
          scope: []
        });
      } catch (error) {
        logger.warn(`[LevelDispatch] Failed to commit skipped result to journal: ${error}`);
      }
      emitEvent({
        type: "CheckCompleted",
        checkId,
        scope: [],
        result: emptyResult
      });
      return emptyResult;
    }
  }
  const dependencies = checkConfig?.depends_on || [];
  const depList = Array.isArray(dependencies) ? dependencies : [dependencies];
  const failedChecks = state.failedChecks;
  const allowedFailedDeps = state.allowedFailedDeps?.get(checkId);
  const tokens = depList.filter(Boolean);
  const groupSatisfied = (token) => {
    const options = token.includes("|") ? token.split("|").map((s) => s.trim()).filter(Boolean) : [token];
    for (const opt of options) {
      const isAllowedFailedDep = !!(allowedFailedDeps && allowedFailedDeps.has(opt));
      if (isAllowedFailedDep) {
        if (context2.debug) {
          logger.info(
            `[LevelDispatch] Allowing ${checkId} to run despite failed dependency ${opt} (on_fail.run)`
          );
        }
        return true;
      }
      const depCfg = context2.config.checks?.[opt];
      const cont = !!(depCfg && depCfg.continue_on_failure === true);
      const st = state.stats.get(opt);
      const skipped = !!(st && st.skipped === true);
      const skipReason = st?.skipReason;
      const skippedDueToEmptyForEach = skipped && skipReason === "forEach_empty";
      const wasMarkedFailed = !!(failedChecks && failedChecks.has(opt)) && !skippedDueToEmptyForEach;
      const failedOnly = !!(st && (st.failedRuns || 0) > 0 && (st.successfulRuns || 0) === 0);
      const satisfied = (!skipped || skippedDueToEmptyForEach) && (!failedOnly && !wasMarkedFailed || cont);
      if (satisfied) return true;
    }
    return false;
  };
  if (tokens.length > 0) {
    let allOk = true;
    for (const t of tokens) {
      if (!groupSatisfied(t)) {
        allOk = false;
        break;
      }
    }
    if (!allOk) {
      const emptyResult = { issues: [] };
      try {
        Object.defineProperty(emptyResult, "__skipped", {
          value: "dependency_failed",
          enumerable: false
        });
      } catch {
      }
      state.completedChecks.add(checkId);
      if (!state.failedChecks) state.failedChecks = /* @__PURE__ */ new Set();
      state.failedChecks.add(checkId);
      const stats = {
        checkName: checkId,
        totalRuns: 0,
        successfulRuns: 0,
        failedRuns: 0,
        skippedRuns: 0,
        skipped: true,
        skipReason: "dependency_failed",
        totalDuration: 0,
        issuesFound: 0,
        issuesBySeverity: { critical: 0, error: 0, warning: 0, info: 0 }
      };
      state.stats.set(checkId, stats);
      try {
        context2.journal.commitEntry({
          sessionId: context2.sessionId,
          checkId,
          result: emptyResult,
          event: context2.event || "manual",
          scope: []
        });
      } catch (error) {
        logger.warn(`[LevelDispatch] Failed to commit empty result to journal: ${error}`);
      }
      emitEvent({ type: "CheckCompleted", checkId, scope: [], result: emptyResult });
      return emptyResult;
    }
  }
  let forEachParent;
  let forEachItems;
  for (const depId of depList) {
    if (!depId) continue;
    try {
      const snapshotId = context2.journal.beginSnapshot();
      const contextView = new (init_snapshot_store(), __toCommonJS(snapshot_store_exports)).ContextView(
        context2.journal,
        context2.sessionId,
        snapshotId,
        [],
        context2.event
      );
      const depResult = contextView.get(depId);
      if (context2.debug) {
        logger.info(
          `[LevelDispatch] Checking dependency ${depId} for ${checkId}: has forEachItems=${!!depResult?.forEachItems}, isArray=${Array.isArray(depResult?.forEachItems)}`
        );
        if (depResult?.forEachItems) {
          logger.info(
            `[LevelDispatch] forEachItems length: ${depResult.forEachItems.length}, items: ${JSON.stringify(depResult.forEachItems).substring(0, 200)}`
          );
        }
      }
      if (depResult?.forEachItems && Array.isArray(depResult.forEachItems)) {
        forEachParent = depId;
        forEachItems = depResult.forEachItems;
        if (context2.debug && forEachItems) {
          logger.info(
            `[LevelDispatch] Detected forEach parent ${depId} with ${forEachItems.length} items for check ${checkId}`
          );
        }
        break;
      }
    } catch (error) {
      if (context2.debug) {
        logger.warn(`[LevelDispatch] Error checking forEach parent ${depId}: ${error}`);
      }
    }
  }
  if (forEachParent && forEachItems !== void 0) {
    let fanoutMode = "reduce";
    const explicit = checkConfig?.fanout;
    if (explicit === "map" || explicit === "reduce") {
      fanoutMode = explicit;
    } else {
      const providerType = context2.checks[checkId]?.providerType || "";
      const reduceProviders = /* @__PURE__ */ new Set(["log", "memory", "script", "workflow", "noop"]);
      fanoutMode = reduceProviders.has(providerType) ? "reduce" : "map";
    }
    if (fanoutMode === "map") {
      if (forEachItems.length === 0) {
        logger.info(`\u23ED  Skipped (forEach parent "${forEachParent}" has 0 items)`);
        if (context2.debug) {
          logger.info(
            `[LevelDispatch] Skipping check ${checkId}: forEach parent ${forEachParent} has zero items`
          );
        }
        const emptyResult = { issues: [] };
        try {
          Object.defineProperty(emptyResult, "__skipped", {
            value: "forEach_empty",
            enumerable: false
          });
        } catch {
        }
        state.completedChecks.add(checkId);
        if (!state.failedChecks) {
          state.failedChecks = /* @__PURE__ */ new Set();
        }
        state.failedChecks.add(checkId);
        let derivedSkipReason = "forEach_empty";
        try {
          const parentFailed = !!(state.failedChecks && state.failedChecks.has(forEachParent)) || (() => {
            const s = state.stats.get(forEachParent);
            return !!(s && (s.failedRuns || 0) > 0);
          })();
          if (parentFailed) derivedSkipReason = "dependency_failed";
        } catch {
        }
        const stats = {
          checkName: checkId,
          totalRuns: 0,
          successfulRuns: 0,
          failedRuns: 0,
          skippedRuns: 0,
          skipped: true,
          skipReason: derivedSkipReason,
          totalDuration: 0,
          issuesFound: 0,
          issuesBySeverity: {
            critical: 0,
            error: 0,
            warning: 0,
            info: 0
          }
        };
        state.stats.set(checkId, stats);
        try {
          context2.journal.commitEntry({
            sessionId: context2.sessionId,
            checkId,
            result: emptyResult,
            event: context2.event || "manual",
            scope: []
          });
        } catch (error) {
          logger.warn(`[LevelDispatch] Failed to commit empty result to journal: ${error}`);
        }
        emitEvent({
          type: "CheckCompleted",
          checkId,
          scope: [],
          result: emptyResult
        });
        return emptyResult;
      }
      return await executeCheckWithForEachItems2(
        checkId,
        forEachParent,
        forEachItems,
        context2,
        state,
        emitEvent,
        transition
      );
    }
  }
  const scope = scopeOverride || [];
  emitEvent({ type: "CheckScheduled", checkId, scope });
  const startTime = Date.now();
  const dispatch = {
    id: `${checkId}-${Date.now()}`,
    checkId,
    scope,
    provider: context2.checks[checkId]?.providerType || "unknown",
    startMs: startTime,
    attempts: 1
  };
  state.activeDispatches.set(checkId, dispatch);
  try {
    const checkConfig2 = context2.config.checks?.[checkId];
    if (!checkConfig2) {
      throw new Error(`Check configuration not found: ${checkId}`);
    }
    const checksMeta = {};
    try {
      const allChecks = context2.config.checks || {};
      for (const [id, cfg] of Object.entries(allChecks)) {
        const anyCfg = cfg;
        checksMeta[id] = { type: anyCfg.type, group: anyCfg.group };
      }
    } catch {
    }
    const providerType = checkConfig2.type || "ai";
    const providerRegistry = (init_check_provider_registry(), __toCommonJS(check_provider_registry_exports)).CheckProviderRegistry.getInstance();
    const provider = providerRegistry.getProviderOrThrow(providerType);
    const outputHistory = buildOutputHistoryFromJournal2(context2);
    const workflowInputs = resolveWorkflowInputs(checkConfig2, context2);
    const providerConfig = {
      type: providerType,
      checkName: checkId,
      prompt: checkConfig2.prompt,
      exec: checkConfig2.exec,
      schema: checkConfig2.schema,
      group: checkConfig2.group,
      focus: checkConfig2.focus || mapCheckNameToFocus2(checkId),
      transform: checkConfig2.transform,
      transform_js: checkConfig2.transform_js,
      env: checkConfig2.env,
      forEach: checkConfig2.forEach,
      ...checkConfig2,
      eventContext: context2.prInfo?.eventContext || {},
      // Expose history and checks metadata for template helpers
      __outputHistory: outputHistory,
      checksMeta,
      // Propagate workflow inputs for template access via {{ inputs.* }}
      workflowInputs,
      ai: {
        ...checkConfig2.ai || {},
        timeout: checkConfig2.ai?.timeout || 18e5,
        debug: !!context2.debug
      }
    };
    try {
      const maybeOctokit = context2.executionContext?.octokit;
      if (maybeOctokit) {
        providerConfig.eventContext = {
          ...providerConfig.eventContext,
          octokit: maybeOctokit
        };
      }
    } catch {
    }
    try {
      const webhookCtx = context2.executionContext?.webhookContext;
      const webhookData = webhookCtx?.webhookData;
      if (context2.debug) {
        logger.info(
          `[LevelDispatch] webhookContext: ${webhookCtx ? "present" : "absent"}, webhookData size: ${webhookData?.size || 0}`
        );
      }
      if (webhookData && webhookData.size > 0) {
        for (const payload of webhookData.values()) {
          const slackConv = payload?.slack_conversation;
          if (slackConv) {
            const event = payload?.event;
            const messageCount = Array.isArray(slackConv?.messages) ? slackConv.messages.length : 0;
            if (context2.debug) {
              logger.info(`[LevelDispatch] Slack conversation extracted: ${messageCount} messages`);
            }
            providerConfig.eventContext = {
              ...providerConfig.eventContext,
              slack: {
                event: event || {},
                conversation: slackConv
              },
              conversation: slackConv
              // Also expose at top level for convenience
            };
            break;
          }
        }
      }
    } catch {
    }
    const dependencyResults = buildDependencyResults(checkId, checkConfig2, context2, state);
    const prInfo = context2.prInfo || {
      number: 1,
      title: "State Machine Execution",
      author: "system",
      eventType: context2.event || "manual",
      eventContext: {},
      files: [],
      commits: []
    };
    const executionContext = {
      ...context2.executionContext,
      _engineMode: context2.mode,
      _parentContext: context2,
      _parentState: state,
      // Make checks metadata available to providers that want it
      checksMeta
    };
    {
      const assumeExpr = checkConfig2?.assume;
      if (assumeExpr) {
        let ok = true;
        try {
          const evaluator = new FailureConditionEvaluator();
          const exprs = Array.isArray(assumeExpr) ? assumeExpr : [assumeExpr];
          for (const ex of exprs) {
            const res = await evaluator.evaluateIfCondition(checkId, ex, {
              event: context2.event || "manual",
              previousResults: dependencyResults
            });
            if (!res) {
              ok = false;
              break;
            }
          }
        } catch (error) {
          const msg = error instanceof Error ? error.message : String(error);
          logger.error(`Failed to evaluate assume expression for check '${checkId}': ${msg}`);
          ok = false;
        }
        if (!ok) {
          logger.info(
            `\u23ED  Skipped (assume: ${String(Array.isArray(assumeExpr) ? assumeExpr[0] : assumeExpr).substring(0, 40)}${String(Array.isArray(assumeExpr) ? assumeExpr[0] : assumeExpr).length > 40 ? "..." : ""})`
          );
          state.completedChecks.add(checkId);
          const stats = {
            checkName: checkId,
            totalRuns: 0,
            successfulRuns: 0,
            failedRuns: 0,
            skippedRuns: 0,
            skipped: true,
            skipReason: "assume",
            totalDuration: 0,
            issuesFound: 0,
            issuesBySeverity: { critical: 0, error: 0, warning: 0, info: 0 }
          };
          state.stats.set(checkId, stats);
          const emptyResult = { issues: [] };
          try {
            Object.defineProperty(emptyResult, "__skipped", {
              value: "assume",
              enumerable: false
            });
          } catch {
          }
          try {
            context2.journal.commitEntry({
              sessionId: context2.sessionId,
              checkId,
              result: emptyResult,
              event: context2.event || "manual",
              scope
            });
          } catch {
          }
          emitEvent({ type: "CheckCompleted", checkId, scope, result: emptyResult });
          return emptyResult;
        }
      }
    }
    try {
      emitNdjsonFallback("visor.provider", {
        "visor.check.id": checkId,
        "visor.provider.type": providerType
      });
    } catch {
    }
    const result = await withActiveSpan(
      `visor.check.${checkId}`,
      {
        "visor.check.id": checkId,
        "visor.check.type": providerType,
        session_id: context2.sessionId,
        wave: state.wave
      },
      async () => executeWithSandboxRouting(
        checkId,
        checkConfig2,
        context2,
        prInfo,
        dependencyResults,
        checkConfig2.ai?.timeout || 18e5,
        () => provider.execute(prInfo, providerConfig, dependencyResults, executionContext)
      )
    );
    try {
      const awaitingHumanInput = result?.awaitingHumanInput === true || result?.output && result.output.awaitingHumanInput === true;
      if (awaitingHumanInput) {
        state.flags = state.flags || {};
        state.flags.awaitingHumanInput = true;
        logger.info(
          `[LevelDispatch] Set awaitingHumanInput=true for check ${checkId} (wave=${state.wave})`
        );
      }
    } catch (e) {
      logger.warn(`[LevelDispatch] Failed to check awaitingHumanInput flag: ${e}`);
    }
    const enrichedIssues = (result.issues || []).map((issue) => ({
      ...issue,
      checkName: checkId,
      ruleId: `${checkId}/${issue.ruleId || "unknown"}`,
      group: checkConfig2.group,
      schema: typeof checkConfig2.schema === "object" ? "custom" : checkConfig2.schema,
      template: checkConfig2.template,
      timestamp: Date.now()
    }));
    const enrichedResult = {
      ...result,
      issues: enrichedIssues
    };
    try {
      let schemaObj = (typeof checkConfig2.schema === "object" ? checkConfig2.schema : void 0) || checkConfig2.output_schema;
      if (!schemaObj && typeof checkConfig2.schema === "string") {
        try {
          const { loadRendererSchema } = await import("./renderer-schema-CMXOLNIG.mjs");
          schemaObj = await loadRendererSchema(checkConfig2.schema);
        } catch {
        }
      }
      if (schemaObj && enrichedResult?.output !== void 0) {
        const Ajv2 = __require("ajv");
        const ajv = new Ajv2({ allErrors: true, allowUnionTypes: true, strict: false });
        const validate = ajv.compile(schemaObj);
        const valid = validate(enrichedResult.output);
        if (!valid) {
          const errs = (validate.errors || []).slice(0, 3).map((e) => e.message).join("; ");
          const issue = {
            file: "contract",
            line: 0,
            ruleId: `contract/schema_validation_failed`,
            message: `Output schema validation failed${errs ? `: ${errs}` : ""}`,
            severity: "error",
            category: "logic",
            checkName: checkId,
            group: checkConfig2.group,
            schema: "json-schema",
            timestamp: Date.now()
          };
          enrichedResult.issues = [...enrichedResult.issues || [], issue];
        }
      }
    } catch {
    }
    try {
      const guaranteeExpr = checkConfig2?.guarantee;
      if (guaranteeExpr) {
        const evaluator = new FailureConditionEvaluator();
        const exprs = Array.isArray(guaranteeExpr) ? guaranteeExpr : [guaranteeExpr];
        for (const ex of exprs) {
          const holds = await evaluator.evaluateIfCondition(checkId, ex, {
            previousResults: dependencyResults,
            event: context2.event || "manual",
            output: enrichedResult.output
          });
          if (!holds) {
            const issue = {
              file: "contract",
              line: 0,
              ruleId: `contract/guarantee_failed`,
              message: `Guarantee failed: ${ex}`,
              severity: "error",
              category: "logic",
              checkName: checkId,
              group: checkConfig2.group,
              schema: typeof checkConfig2.schema === "object" ? "custom" : checkConfig2.schema,
              timestamp: Date.now()
            };
            enrichedResult.issues = [...enrichedResult.issues || [], issue];
          }
        }
      }
    } catch {
    }
    let isForEach = result.isForEach;
    let forEachItems2 = result.forEachItems;
    logger.info(
      `[LevelDispatch][DEBUG] After execution ${checkId}: checkConfig.forEach=${checkConfig2.forEach}, output type=${typeof result.output}, isArray=${Array.isArray(result.output)}`
    );
    if (checkConfig2.forEach === true) {
      const output = result.output;
      logger.info(
        `[LevelDispatch][DEBUG] Processing forEach=true for ${checkId}, output=${JSON.stringify(output)?.substring(0, 200)}`
      );
      if (output === void 0) {
        logger.error(`[LevelDispatch] forEach check "${checkId}" produced undefined output`);
        const undefinedError = {
          file: "system",
          line: 0,
          // Mark as execution failure so dependents treat this as failed dependency
          ruleId: "forEach/execution_error",
          message: `forEach check "${checkId}" produced undefined output. Verify your command outputs valid data and your transform_js returns a value.`,
          severity: "error",
          category: "logic"
        };
        enrichedResult.issues = [...enrichedResult.issues || [], undefinedError];
        isForEach = true;
        forEachItems2 = [];
        enrichedResult.isForEach = true;
        enrichedResult.forEachItems = [];
        try {
          if (!state.failedChecks) {
            state.failedChecks = /* @__PURE__ */ new Set();
          }
          state.failedChecks.add(checkId);
        } catch {
        }
        try {
          state.completedChecks.add(checkId);
          const currentWaveCompletions2 = state.currentWaveCompletions;
          if (currentWaveCompletions2) currentWaveCompletions2.add(checkId);
          const existing = state.stats.get(checkId);
          const aggStats = existing || {
            checkName: checkId,
            totalRuns: 0,
            successfulRuns: 0,
            failedRuns: 0,
            skippedRuns: 0,
            skipped: false,
            totalDuration: 0,
            issuesFound: 0,
            issuesBySeverity: { critical: 0, error: 0, warning: 0, info: 0 }
          };
          aggStats.totalRuns++;
          aggStats.failedRuns++;
          aggStats.outputsProduced = 0;
          state.stats.set(checkId, aggStats);
          context2.journal.commitEntry({
            sessionId: context2.sessionId,
            checkId,
            result: enrichedResult,
            event: context2.event || "manual",
            scope: []
          });
        } catch (err) {
          logger.warn(`[LevelDispatch] Failed to persist undefined forEach result: ${err}`);
        }
        try {
          state.activeDispatches.delete(checkId);
        } catch {
        }
        emitEvent({
          type: "CheckCompleted",
          checkId,
          scope: [],
          result: enrichedResult
        });
        return enrichedResult;
      } else if (Array.isArray(output)) {
        isForEach = true;
        forEachItems2 = output;
        enrichedResult.isForEach = true;
        enrichedResult.forEachItems = output;
        logger.info(`  Found ${output.length} items for forEach iteration`);
        if (context2.debug) {
          logger.info(
            `[LevelDispatch] Check ${checkId} is forEach parent with ${output.length} items`
          );
        }
      } else {
        if (context2.debug) {
          logger.warn(
            `[LevelDispatch] Check ${checkId} has forEach:true but output is not an array: ${typeof output}, converting to single-item array`
          );
        }
        isForEach = true;
        forEachItems2 = [output];
        enrichedResult.isForEach = true;
        enrichedResult.forEachItems = [output];
      }
    }
    if (result.isForEach) {
      enrichedResult.isForEach = true;
    }
    if (result.forEachItems) {
      enrichedResult.forEachItems = result.forEachItems;
    }
    if (result.forEachItemResults) {
      enrichedResult.forEachItemResults = result.forEachItemResults;
    }
    if (result.forEachFatalMask) {
      enrichedResult.forEachFatalMask = result.forEachFatalMask;
    }
    let renderedContent;
    try {
      renderedContent = await renderTemplateContent2(checkId, checkConfig2, enrichedResult);
      if (renderedContent) {
        logger.debug(
          `[LevelDispatch] Template rendered for ${checkId}: ${renderedContent.length} chars`
        );
        emitMermaidFromMarkdown(checkId, renderedContent, "content");
      } else {
        logger.debug(`[LevelDispatch] No template content rendered for ${checkId}`);
      }
    } catch (error) {
      logger.warn(`[LevelDispatch] Failed to render template for ${checkId}: ${error}`);
    }
    if (!renderedContent && enrichedIssues.length > 0) {
      renderedContent = enrichedIssues.map(
        (i) => `- **${i.severity.toUpperCase()}**: ${i.message} (${i.file}:${i.line})`
      ).join("\n");
    }
    let outputWithTimestamp = void 0;
    if (result.output !== void 0) {
      const output = result.output;
      if (output !== null && typeof output === "object" && !Array.isArray(output)) {
        outputWithTimestamp = { ...output, ts: Date.now() };
      } else {
        outputWithTimestamp = output;
      }
    }
    const enrichedResultWithContent = renderedContent ? { ...enrichedResult, content: renderedContent } : enrichedResult;
    const enrichedResultWithTimestamp = outputWithTimestamp !== void 0 ? { ...enrichedResultWithContent, output: outputWithTimestamp } : enrichedResultWithContent;
    state.completedChecks.add(checkId);
    const currentWaveCompletions = state.currentWaveCompletions;
    if (currentWaveCompletions) {
      currentWaveCompletions.add(checkId);
    }
    try {
      logger.info(`[LevelDispatch] Calling handleRouting for ${checkId}`);
    } catch {
    }
    const wasHalted = await handleRouting(context2, state, transition, emitEvent, {
      checkId,
      scope,
      result: enrichedResult,
      checkConfig: checkConfig2,
      success: !hasFatalIssues2(enrichedResult)
    });
    if (wasHalted) {
      logger.info(
        `[LevelDispatch] Execution halted after routing for ${checkId}, stopping level dispatch`
      );
      try {
        const commitResult = {
          ...enrichedResult,
          ...renderedContent ? { content: renderedContent } : {},
          ...result.output !== void 0 ? outputWithTimestamp !== void 0 ? { output: outputWithTimestamp } : { output: result.output } : {}
        };
        context2.journal.commitEntry({
          sessionId: context2.sessionId,
          checkId,
          result: commitResult,
          event: context2.event || "manual",
          scope
        });
      } catch (error) {
        logger.warn(`[LevelDispatch] Failed to commit halt result to journal: ${error}`);
      }
      return enrichedResult;
    }
    try {
      const commitResult = {
        ...enrichedResult,
        ...renderedContent ? { content: renderedContent } : {},
        ...result.output !== void 0 ? outputWithTimestamp !== void 0 ? { output: outputWithTimestamp } : { output: result.output } : {}
      };
      context2.journal.commitEntry({
        sessionId: context2.sessionId,
        checkId,
        result: commitResult,
        event: context2.event || "manual",
        scope
      });
    } catch (error) {
      logger.warn(`[LevelDispatch] Failed to commit to journal: ${error}`);
    }
    if (isForEach) {
      try {
        const existing = state.stats.get(checkId);
        const aggStats = existing || {
          checkName: checkId,
          totalRuns: 0,
          successfulRuns: 0,
          failedRuns: 0,
          skippedRuns: 0,
          skipped: false,
          totalDuration: 0,
          issuesFound: 0,
          issuesBySeverity: { critical: 0, error: 0, warning: 0, info: 0 }
        };
        aggStats.totalRuns++;
        const hasFatal = hasFatalIssues2(enrichedResultWithTimestamp);
        if (hasFatal) aggStats.failedRuns++;
        else aggStats.successfulRuns++;
        const items = enrichedResultWithTimestamp.forEachItems;
        if (Array.isArray(items)) aggStats.outputsProduced = items.length;
        state.stats.set(checkId, aggStats);
      } catch {
      }
    }
    if (isForEach && forEachItems2 && Array.isArray(forEachItems2)) {
      for (let itemIndex = 0; itemIndex < forEachItems2.length; itemIndex++) {
        const itemScope = [
          { check: checkId, index: itemIndex }
        ];
        const item = forEachItems2[itemIndex];
        try {
          context2.journal.commitEntry({
            sessionId: context2.sessionId,
            checkId,
            result: { issues: [], output: item },
            event: context2.event || "manual",
            scope: itemScope
          });
        } catch (error) {
          logger.warn(
            `[LevelDispatch] Failed to commit per-item journal for ${checkId} item ${itemIndex}: ${error}`
          );
        }
      }
    }
    state.activeDispatches.delete(checkId);
    emitEvent({
      type: "CheckCompleted",
      checkId,
      scope,
      result: {
        ...enrichedResult,
        output: result.output,
        content: renderedContent || result.content
      }
    });
    return enrichedResult;
  } catch (error) {
    const err = error instanceof Error ? error : new Error(String(error));
    logger.error(`[LevelDispatch] Error executing check ${checkId}: ${err.message}`);
    state.activeDispatches.delete(checkId);
    emitEvent({
      type: "CheckErrored",
      checkId,
      scope,
      error: {
        message: err.message,
        stack: err.stack,
        name: err.name
      }
    });
    throw err;
  }
}
function buildDependencyResultsWithScope2(checkId, checkConfig, context2, scope) {
  const dependencyResults = /* @__PURE__ */ new Map();
  const dependencies = checkConfig.depends_on || [];
  const depList = Array.isArray(dependencies) ? dependencies : [dependencies];
  const currentIndex = scope.length > 0 ? scope[scope.length - 1].index : void 0;
  for (const depId of depList) {
    if (!depId) continue;
    try {
      const snapshotId = context2.journal.beginSnapshot();
      const visible = context2.journal.readVisible(
        context2.sessionId,
        snapshotId,
        context2.event
      );
      const sameScope = (a, b) => {
        if (a.length !== b.length) return false;
        for (let i = 0; i < a.length; i++)
          if (a[i].check !== b[i].check || a[i].index !== b[i].index) return false;
        return true;
      };
      const matches = visible.filter((e) => e.checkId === depId && sameScope(e.scope, scope));
      let journalResult = matches.length > 0 ? matches[matches.length - 1].result : void 0;
      if (journalResult && Array.isArray(journalResult.forEachItems) && currentIndex !== void 0) {
        const perItemSummary = journalResult.forEachItemResults && journalResult.forEachItemResults[currentIndex] || { issues: [] };
        const perItemOutput = journalResult.forEachItems[currentIndex];
        const combined = { ...perItemSummary, output: perItemOutput };
        dependencyResults.set(depId, combined);
        continue;
      }
      if (!journalResult) {
        try {
          const rawView = new (init_snapshot_store(), __toCommonJS(snapshot_store_exports)).ContextView(
            context2.journal,
            context2.sessionId,
            snapshotId,
            [],
            context2.event
          );
          const rawResult = rawView.get(depId);
          if (rawResult && Array.isArray(rawResult.forEachItems) && currentIndex !== void 0) {
            const perItemSummary = rawResult.forEachItemResults && rawResult.forEachItemResults[currentIndex] || { issues: [] };
            const perItemOutput = rawResult.forEachItems[currentIndex];
            const combined = { ...perItemSummary, output: perItemOutput };
            dependencyResults.set(depId, combined);
            continue;
          }
          journalResult = rawResult;
        } catch {
        }
      }
      if (journalResult) {
        dependencyResults.set(depId, journalResult);
        continue;
      }
    } catch {
    }
    dependencyResults.set(depId, { issues: [] });
  }
  try {
    const snapshotId = context2.journal.beginSnapshot();
    const contextView = new (init_snapshot_store(), __toCommonJS(snapshot_store_exports)).ContextView(
      context2.journal,
      context2.sessionId,
      snapshotId,
      scope,
      context2.event
    );
    const allCheckNames = Object.keys(context2.config.checks || {});
    for (const checkName of allCheckNames) {
      if (dependencyResults.has(checkName)) continue;
      let jr = contextView.get(checkName);
      if (jr && Array.isArray(jr.forEachItems) && currentIndex !== void 0) {
        const perItemSummary = jr.forEachItemResults && jr.forEachItemResults[currentIndex] || { issues: [] };
        const perItemOutput = jr.forEachItems[currentIndex];
        const combined = { ...perItemSummary, output: perItemOutput };
        dependencyResults.set(checkName, combined);
        continue;
      }
      if (!jr) {
        try {
          const rawView = new (init_snapshot_store(), __toCommonJS(snapshot_store_exports)).ContextView(
            context2.journal,
            context2.sessionId,
            snapshotId,
            [],
            context2.event
          );
          const raw = rawView.get(checkName);
          if (raw && Array.isArray(raw.forEachItems) && currentIndex !== void 0) {
            const perItemSummary = raw.forEachItemResults && raw.forEachItemResults[currentIndex] || { issues: [] };
            const perItemOutput = raw.forEachItems[currentIndex];
            const combined = { ...perItemSummary, output: perItemOutput };
            dependencyResults.set(checkName, combined);
            continue;
          }
          jr = raw;
        } catch {
        }
      }
      if (jr) {
        dependencyResults.set(checkName, jr);
      }
    }
    for (const checkName of allCheckNames) {
      const checkCfg = context2.config.checks?.[checkName];
      if (checkCfg?.forEach) {
        try {
          const rawContextView = new (init_snapshot_store(), __toCommonJS(snapshot_store_exports)).ContextView(
            context2.journal,
            context2.sessionId,
            snapshotId,
            [],
            // No scope - get parent-level result with forEachItems
            context2.event
          );
          const rawResult = rawContextView.get(checkName);
          if (rawResult && rawResult.forEachItems) {
            const rawKey = `${checkName}-raw`;
            dependencyResults.set(rawKey, {
              issues: [],
              output: rawResult.forEachItems
            });
          }
        } catch {
        }
      }
    }
  } catch {
  }
  return dependencyResults;
}
function buildDependencyResults(checkId, checkConfig, context2, _state) {
  return buildDependencyResultsWithScope2(checkId, checkConfig, context2, []);
}
function shouldFailFast(results) {
  for (const { result } of results) {
    if (!result || !result.issues) continue;
    if (hasFatalIssues2(result)) {
      return true;
    }
  }
  return false;
}
function hasFatalIssues2(result) {
  if (!result.issues) {
    return false;
  }
  return result.issues.some((issue) => {
    const ruleId = issue.ruleId || "";
    return ruleId.endsWith("/error") || // System errors
    ruleId.includes("/execution_error") || // Command failures
    ruleId.includes("timeout") || // Timeouts
    ruleId.endsWith("_fail_if") && ruleId !== "global_fail_if";
  });
}
function updateStats2(results, state, isForEachIteration = false) {
  for (const { checkId, result, error, duration } of results) {
    const existing = state.stats.get(checkId);
    const stats = existing || {
      checkName: checkId,
      totalRuns: 0,
      successfulRuns: 0,
      failedRuns: 0,
      skippedRuns: 0,
      skipped: false,
      totalDuration: 0,
      issuesFound: 0,
      issuesBySeverity: {
        critical: 0,
        error: 0,
        warning: 0,
        info: 0
      }
    };
    if (checkId === "post-response") {
      logger.info(
        `[updateStats] Called for post-response: existing.skipped=${existing?.skipped}, stats.skipped=${stats.skipped}, skipReason=${stats.skipReason}`
      );
    }
    if (stats.skipped) {
      stats.skipped = false;
      if (checkId === "post-response") {
        logger.info(
          `[updateStats] Clearing skipped flag for post-response (was skipped, now executing)`
        );
      }
    }
    stats.totalRuns++;
    if (duration !== void 0) {
      stats.totalDuration += duration;
    }
    const hasExecutionFailure = result.issues?.some((issue) => {
      const ruleId = issue.ruleId || "";
      return ruleId.endsWith("/error") || // System errors, exceptions
      ruleId.includes("/execution_error") || // Command failures
      ruleId.includes("timeout") || // Timeouts
      ruleId.endsWith("_fail_if") && ruleId !== "global_fail_if";
    });
    if (error) {
      stats.failedRuns++;
      stats.errorMessage = error.message;
      if (!isForEachIteration) {
        if (!state.failedChecks) {
          state.failedChecks = /* @__PURE__ */ new Set();
        }
        state.failedChecks.add(checkId);
      }
    } else if (hasExecutionFailure) {
      stats.failedRuns++;
      if (!isForEachIteration) {
        if (!state.failedChecks) {
          state.failedChecks = /* @__PURE__ */ new Set();
        }
        state.failedChecks.add(checkId);
      }
    } else {
      stats.successfulRuns++;
    }
    if (result.issues) {
      stats.issuesFound += result.issues.length;
      for (const issue of result.issues) {
        if (issue.severity === "critical") stats.issuesBySeverity.critical++;
        else if (issue.severity === "error") stats.issuesBySeverity.error++;
        else if (issue.severity === "warning") stats.issuesBySeverity.warning++;
        else if (issue.severity === "info") stats.issuesBySeverity.info++;
      }
    }
    if (stats.outputsProduced === void 0) {
      const forEachItems = result.forEachItems;
      if (Array.isArray(forEachItems)) {
        stats.outputsProduced = forEachItems.length;
      } else if (result.output !== void 0) {
        stats.outputsProduced = 1;
      }
    }
    state.stats.set(checkId, stats);
  }
}
async function renderTemplateContent2(checkId, checkConfig, reviewSummary) {
  try {
    const { createExtendedLiquid: createExtendedLiquid2 } = await import("./liquid-extensions-5IZLTFSZ.mjs");
    const fs10 = await import("fs/promises");
    const path12 = await import("path");
    const schemaRaw = checkConfig.schema || "plain";
    const schema = typeof schemaRaw === "string" ? schemaRaw : "code-review";
    let templateContent;
    if (checkConfig.template && checkConfig.template.content) {
      templateContent = String(checkConfig.template.content);
      logger.debug(`[LevelDispatch] Using inline template for ${checkId}`);
    } else if (checkConfig.template && checkConfig.template.file) {
      const file = String(checkConfig.template.file);
      const resolved = path12.resolve(process.cwd(), file);
      templateContent = await fs10.readFile(resolved, "utf-8");
      logger.debug(`[LevelDispatch] Using template file for ${checkId}: ${resolved}`);
    } else if (schema && schema !== "plain") {
      const sanitized = String(schema).replace(/[^a-zA-Z0-9-]/g, "");
      if (sanitized) {
        const candidatePaths = [
          path12.join(__dirname, "output", sanitized, "template.liquid"),
          // bundled: dist/output/
          path12.join(__dirname, "..", "..", "output", sanitized, "template.liquid"),
          // source (from state-machine/states)
          path12.join(__dirname, "..", "..", "..", "output", sanitized, "template.liquid"),
          // source (alternate)
          path12.join(process.cwd(), "output", sanitized, "template.liquid"),
          // fallback: cwd/output/
          path12.join(process.cwd(), "dist", "output", sanitized, "template.liquid")
          // fallback: cwd/dist/output/
        ];
        for (const p of candidatePaths) {
          try {
            templateContent = await fs10.readFile(p, "utf-8");
            if (templateContent) {
              logger.debug(`[LevelDispatch] Using schema template for ${checkId}: ${p}`);
              break;
            }
          } catch {
          }
        }
        if (!templateContent) {
          logger.debug(
            `[LevelDispatch] No template found for schema '${sanitized}' (tried ${candidatePaths.length} paths)`
          );
        }
      }
    }
    if (!templateContent) {
      logger.debug(`[LevelDispatch] No template content found for ${checkId}`);
      return void 0;
    }
    const liquid = createExtendedLiquid2({
      trimTagLeft: false,
      trimTagRight: false,
      trimOutputLeft: false,
      trimOutputRight: false,
      greedy: false
    });
    let output = reviewSummary.output;
    if (typeof output === "string") {
      const trimmed = output.trim();
      if (trimmed.startsWith("{") || trimmed.startsWith("[")) {
        try {
          output = JSON.parse(trimmed);
        } catch {
        }
      }
    }
    const templateData = {
      issues: reviewSummary.issues || [],
      checkName: checkId,
      output
    };
    logger.debug(
      `[LevelDispatch] Rendering template for ${checkId} with output keys: ${output && typeof output === "object" ? Object.keys(output).join(", ") : "none"}`
    );
    const rendered = await liquid.parseAndRender(templateContent, templateData);
    logger.debug(
      `[LevelDispatch] Template rendered successfully for ${checkId}: ${rendered.length} chars, trimmed: ${rendered.trim().length} chars`
    );
    return rendered.trim();
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    logger.error(`[LevelDispatch] Failed to render template for ${checkId}: ${msg}`);
    return void 0;
  }
}
var init_level_dispatch = __esm({
  "src/state-machine/states/level-dispatch.ts"() {
    "use strict";
    init_logger();
    init_routing();
    init_trace_helpers();
    init_mermaid_telemetry();
    init_fallback_ndjson();
    init_failure_condition_evaluator();
    init_workflow_inputs();
    init_sandbox_routing();
  }
});

// src/state-machine/states/check-running.ts
async function handleCheckRunning(_context, _state, transition, _emitEvent) {
  transition("WavePlanning");
}
var init_check_running = __esm({
  "src/state-machine/states/check-running.ts"() {
    "use strict";
  }
});

// src/state-machine/states/completed.ts
async function handleCompleted(context2, state) {
  if (context2.debug) {
    logger.info("[Completed] Execution complete");
    logger.info(`[Completed] Total waves: ${state.wave + 1}`);
    logger.info(`[Completed] Checks completed: ${state.completedChecks.size}`);
    logger.info(`[Completed] Stats collected: ${state.stats.size}`);
  }
  if (context2.gitHubChecks) {
    if (context2.debug) {
      logger.info("[Completed] GitHub checks will be finalized by main engine");
    }
  }
}
var init_completed = __esm({
  "src/state-machine/states/completed.ts"() {
    "use strict";
    init_logger();
  }
});

// src/state-machine/states/error.ts
async function handleError(context2, state) {
  logger.error("[Error] State machine entered error state");
  const errorEvent = state.eventQueue.find((e) => e.type === "Shutdown" && e.error);
  if (errorEvent && errorEvent.type === "Shutdown" && errorEvent.error) {
    logger.error(`[Error] Fatal error: ${errorEvent.error.message}`);
    if (errorEvent.error.stack) {
      logger.error(`[Error] Stack: ${errorEvent.error.stack}`);
    }
  }
  if (context2.debug) {
    logger.info(`[Error] Completed ${state.completedChecks.size} checks before error`);
    logger.info(`[Error] Active dispatches: ${state.activeDispatches.size}`);
  }
}
var init_error = __esm({
  "src/state-machine/states/error.ts"() {
    "use strict";
    init_logger();
  }
});

// src/state-machine/runner.ts
var runner_exports = {};
__export(runner_exports, {
  StateMachineRunner: () => StateMachineRunner
});
var StateMachineRunner;
var init_runner = __esm({
  "src/state-machine/runner.ts"() {
    "use strict";
    init_human_id();
    init_logger();
    init_trace_helpers();
    init_init();
    init_plan_ready();
    init_wave_planning();
    init_level_dispatch();
    init_check_running();
    init_completed();
    init_error();
    StateMachineRunner = class {
      context;
      state;
      debugServer;
      hasRun = false;
      constructor(context2, debugServer) {
        this.context = context2;
        this.state = this.initializeState();
        this.debugServer = debugServer;
      }
      /**
       * Initialize the run state
       */
      initializeState() {
        const DEFAULT_MAX_WORKFLOW_DEPTH = 3;
        const configuredMaxDepth = (this.context && this.context.config && this.context.config.limits ? this.context.config.limits.max_workflow_depth : void 0) ?? DEFAULT_MAX_WORKFLOW_DEPTH;
        return {
          currentState: "Init",
          wave: 0,
          levelQueue: [],
          eventQueue: [],
          activeDispatches: /* @__PURE__ */ new Map(),
          completedChecks: /* @__PURE__ */ new Set(),
          flags: {
            failFastTriggered: false,
            forwardRunRequested: false,
            // Maximum nesting depth for nested workflows (configurable)
            maxWorkflowDepth: configuredMaxDepth,
            currentWorkflowDepth: 0
            // Start at root level
          },
          stats: /* @__PURE__ */ new Map(),
          historyLog: [],
          forwardRunGuards: /* @__PURE__ */ new Set(),
          currentLevelChecks: /* @__PURE__ */ new Set(),
          routingLoopCount: 0,
          pendingRunScopes: /* @__PURE__ */ new Map()
        };
      }
      /**
       * Execute the state machine
       */
      async run() {
        this.hasRun = true;
        try {
          this.emitEvent({ type: "StateTransition", from: "Init", to: "Init" });
          while (!this.isTerminalState(this.state.currentState)) {
            const currentState = this.state.currentState;
            if (this.context.debug) {
              logger.info(`[StateMachine] State: ${currentState}, Wave: ${this.state.wave}`);
            }
            await this.executeState(currentState);
            if (this.state.currentState === "Error") {
              break;
            }
          }
          return this.buildExecutionResult();
        } catch (error) {
          const errorMsg = error instanceof Error ? error.message : String(error);
          logger.error(`[StateMachine] Fatal error: ${errorMsg}`);
          const serializedError = {
            message: error instanceof Error ? error.message : String(error),
            stack: error instanceof Error ? error.stack : void 0,
            name: error instanceof Error ? error.name : void 0
          };
          this.emitEvent({ type: "Shutdown", error: serializedError });
          throw error;
        }
      }
      /**
       * Execute a specific state handler
       * M4: Wraps each state execution in an OTEL span for observability
       */
      async executeState(state) {
        const attrs = {
          state,
          engine_mode: this.context.mode,
          wave: this.state.wave,
          session_id: this.context.sessionId
        };
        const waveKind = this.state?.flags?.waveKind;
        if (waveKind) attrs.wave_kind = waveKind;
        return withActiveSpan(`engine.state.${state.toLowerCase()}`, attrs, async () => {
          try {
            switch (state) {
              case "Init":
                await handleInit(this.context, this.state, this.transition.bind(this));
                break;
              case "PlanReady":
                await handlePlanReady(this.context, this.state, this.transition.bind(this));
                break;
              case "WavePlanning":
                await handleWavePlanning(this.context, this.state, this.transition.bind(this));
                break;
              case "LevelDispatch":
                await handleLevelDispatch(
                  this.context,
                  this.state,
                  this.transition.bind(this),
                  this.emitEvent.bind(this)
                );
                break;
              case "CheckRunning":
                await handleCheckRunning(
                  this.context,
                  this.state,
                  this.transition.bind(this),
                  this.emitEvent.bind(this)
                );
                break;
              case "Routing":
                throw new Error("Routing state should be handled by CheckRunning");
              case "Completed":
                await handleCompleted(this.context, this.state);
                break;
              case "Error":
                await handleError(this.context, this.state);
                break;
              default:
                throw new Error(`Unknown state: ${state}`);
            }
          } catch (error) {
            const errorMsg = error instanceof Error ? error.message : String(error);
            logger.error(`[StateMachine] Error in state ${state}: ${errorMsg}`);
            const serializedError = {
              message: error instanceof Error ? error.message : String(error),
              stack: error instanceof Error ? error.stack : void 0,
              name: error instanceof Error ? error.name : void 0
            };
            this.emitEvent({ type: "Shutdown", error: serializedError });
            this.state.currentState = "Error";
            throw error;
          }
        });
      }
      /**
       * Transition to a new state
       * M4: Emits OTEL span for the transition with state metadata
       */
      transition(newState) {
        const oldState = this.state.currentState;
        this.state.currentState = newState;
        const transitionEvent = { type: "StateTransition", from: oldState, to: newState };
        this.emitEvent(transitionEvent);
        try {
          addEvent("engine.state_transition", {
            state_from: oldState,
            state_to: newState,
            engine_mode: this.context.mode,
            wave: this.state.wave,
            session_id: this.context.sessionId
          });
        } catch (_err) {
        }
        if (this.context.debug) {
          logger.info(`[StateMachine] Transition: ${oldState} -> ${newState}`);
        }
      }
      /**
       * Emit an engine event
       * M4: Streams events to debug visualizer for time-travel debugging
       */
      emitEvent(event) {
        this.state.historyLog.push(event);
        if (event.type === "ForwardRunRequested" || event.type === "WaveRetry") {
          this.state.eventQueue.push(event);
        }
        if (this.debugServer) {
          try {
            this.streamEventToDebugServer(event);
          } catch (_err) {
          }
        }
        try {
          const bus = this.context.eventBus;
          if (bus && typeof bus.emit === "function") {
            const envelope = {
              id: generateHumanId(),
              version: 1,
              timestamp: (/* @__PURE__ */ new Date()).toISOString(),
              runId: this.context.sessionId,
              workflowId: this.context.workflowId,
              wave: this.state.wave,
              payload: event
            };
            void bus.emit(envelope);
          }
        } catch {
        }
        if (event.type === "CheckCompleted") {
          try {
            const hook = this.context.executionContext?.hooks?.onCheckComplete;
            if (typeof hook === "function") {
              const checkConfig = this.context.config?.checks?.[event.checkId];
              hook({
                checkId: event.checkId,
                result: event.result,
                checkConfig: checkConfig ? {
                  type: checkConfig.type,
                  group: checkConfig.group,
                  criticality: checkConfig.criticality,
                  schema: checkConfig.schema
                } : void 0
              });
            }
          } catch {
          }
        }
        if (this.context.debug && event.type !== "StateTransition") {
          logger.debug(`[StateMachine] Event: ${event.type}`);
        }
      }
      /**
       * Stream an engine event to debug visualizer (M4)
       * Converts EngineEvent to ProcessedSpan format for visualization
       */
      streamEventToDebugServer(event) {
        if (!this.debugServer) return;
        const timestamp = process.hrtime();
        const span = {
          traceId: this.context.sessionId,
          spanId: `${event.type}-${Date.now()}`,
          name: `engine.event.${event.type.toLowerCase()}`,
          startTime: timestamp,
          endTime: timestamp,
          duration: 0,
          attributes: {
            event_type: event.type,
            engine_mode: this.context.mode,
            wave: this.state.wave,
            session_id: this.context.sessionId,
            ...this.extractEventAttributes(event)
          },
          events: [],
          status: "ok"
        };
        this.debugServer.emitSpan(span);
      }
      /**
       * Extract type-specific attributes from engine events
       */
      extractEventAttributes(event) {
        switch (event.type) {
          case "StateTransition":
            return { state_from: event.from, state_to: event.to };
          case "CheckScheduled":
          case "CheckCompleted":
          case "CheckErrored":
            return {
              check_id: event.checkId,
              scope: event.scope?.join(".") || ""
            };
          case "ForwardRunRequested":
            return {
              target: event.target,
              goto_event: event.gotoEvent,
              scope: event.scope?.join(".") || ""
            };
          case "WaveRetry":
            return { reason: event.reason };
          case "Shutdown":
            return {
              error: event.error?.message
            };
          default:
            return {};
        }
      }
      /**
       * Check if a state is terminal
       */
      isTerminalState(state) {
        return state === "Completed" || state === "Error";
      }
      /**
       * Build the final execution result
       */
      buildExecutionResult() {
        const stats = Array.from(this.state.stats.values());
        stats.sort((a, b) => (b.errorMessage ? 1 : 0) - (a.errorMessage ? 1 : 0));
        const results = this.aggregateResultsFromJournal();
        let totalDuration = 0;
        for (const stat of stats) {
          totalDuration = Math.max(totalDuration, stat.totalDuration);
        }
        try {
          for (const s of stats) {
            const sumSF = (s.successfulRuns || 0) + (s.failedRuns || 0);
            if (s.totalRuns !== void 0 && sumSF !== s.totalRuns) {
              if (sumSF > s.totalRuns) {
                const failures = Math.min(s.failedRuns || 0, s.totalRuns);
                s.failedRuns = failures;
                s.successfulRuns = Math.max(0, s.totalRuns - failures);
              } else {
                s.successfulRuns = (s.successfulRuns || 0) + (s.totalRuns - sumSF);
              }
            }
          }
        } catch {
        }
        if (this.context.debug) {
          logger.info("[StateMachine][Stats] Final statistics breakdown:");
          for (const s of stats) {
            logger.info(
              `  ${s.checkName}: totalRuns=${s.totalRuns}, successful=${s.successfulRuns}, failed=${s.failedRuns}`
            );
          }
          logger.info(
            `[StateMachine][Stats] Total: ${this.state.stats.size} configured, ${stats.reduce((sum, s) => sum + s.totalRuns, 0)} executions`
          );
        }
        return {
          results,
          statistics: {
            totalChecksConfigured: this.state.stats.size,
            totalExecutions: stats.reduce((sum, s) => sum + s.totalRuns, 0),
            successfulExecutions: stats.reduce((sum, s) => sum + s.successfulRuns, 0),
            failedExecutions: stats.reduce((sum, s) => sum + s.failedRuns, 0),
            skippedChecks: stats.filter((s) => s.skipped).length,
            totalDuration,
            checks: stats
          }
        };
      }
      /**
       * Aggregate results from journal into GroupedCheckResults format
       * This matches the format returned by the legacy engine
       */
      aggregateResultsFromJournal() {
        const groupedResults = {};
        const allEntries = this.context.journal.readVisible(
          this.context.sessionId,
          this.context.journal.beginSnapshot(),
          void 0
        );
        const checkEntries = /* @__PURE__ */ new Map();
        for (const entry of allEntries) {
          const existing = checkEntries.get(entry.checkId) || [];
          existing.push(entry);
          checkEntries.set(entry.checkId, existing);
        }
        for (const [checkId, entries] of checkEntries) {
          const checkConfig = this.context.config.checks?.[checkId];
          if (!checkConfig && checkId === "system") {
            const latestEntry = entries[entries.length - 1];
            if (latestEntry && latestEntry.result.issues) {
              if (!groupedResults["system"]) {
                groupedResults["system"] = [];
              }
              groupedResults["system"].push({
                checkName: "system",
                content: "",
                group: "system",
                output: void 0,
                debug: void 0,
                issues: latestEntry.result.issues
              });
            }
            continue;
          }
          if (!checkConfig) continue;
          const group = checkConfig.group || checkId;
          let content = "";
          let output = void 0;
          const allIssues = [];
          let debug = void 0;
          if (checkConfig.forEach && entries.length > 1) {
            const contents = [];
            for (const entry of entries) {
              if (entry.result.content) {
                contents.push(entry.result.content);
              }
              if (entry.result.issues) {
                allIssues.push(...entry.result.issues);
              }
              if (entry.result.debug) {
                debug = entry.result.debug;
              }
              if (entry.result.output !== void 0) {
                output = entry.result.output;
              }
            }
            content = contents.join("\n");
          } else {
            const latestEntry = entries[entries.length - 1];
            if (latestEntry) {
              content = latestEntry.result.content || "";
              output = latestEntry.result.output;
              if (latestEntry.result.issues) {
                allIssues.push(...latestEntry.result.issues);
              }
              debug = latestEntry.result.debug;
            }
          }
          const checkResult = {
            checkName: checkId,
            content,
            group,
            output,
            debug,
            issues: allIssues
          };
          if (!groupedResults[group]) {
            groupedResults[group] = [];
          }
          groupedResults[group].push(checkResult);
        }
        const suppressionEnabled = this.context.config.output?.suppressionEnabled ?? true;
        if (suppressionEnabled) {
          const { IssueFilter: IssueFilter2 } = (init_issue_filter(), __toCommonJS(issue_filter_exports));
          const filter = new IssueFilter2(true);
          for (const group of Object.keys(groupedResults)) {
            for (const checkResult of groupedResults[group]) {
              if (checkResult.issues && checkResult.issues.length > 0) {
                checkResult.issues = filter.filterIssues(
                  checkResult.issues,
                  this.context.workingDirectory
                );
              }
            }
          }
        }
        return groupedResults;
      }
      /**
       * Get current run state (for debugging/testing)
       */
      getState() {
        return this.state;
      }
      /**
       * Hydrate the runner with a previously serialized state. Must be called
       * before `run()` (i.e., when the runner has not started yet).
       */
      setState(state) {
        if (this.hasRun) {
          throw new Error("StateMachineRunner.setState: cannot set state after run() has started");
        }
        this.state = state;
      }
      /**
       * Bubble an event to parent context (nested workflows support)
       * This allows nested workflows to trigger re-runs in parent workflows
       */
      bubbleEventToParent(event) {
        if (this.state.parentContext && this.state.parentContext.mode === "state-machine") {
          if (this.context.debug) {
            logger.info(`[StateMachine] Bubbling event to parent: ${event.type}`);
          }
          if (!this.state.parentContext._bubbledEvents) {
            this.state.parentContext._bubbledEvents = [];
          }
          this.state.parentContext._bubbledEvents.push(event);
        }
      }
    };
  }
});

// src/sandbox/docker-image-sandbox.ts
import { promisify } from "util";
import { execFile as execFileCb } from "child_process";
import { writeFileSync as writeFileSync3, unlinkSync as unlinkSync2, mkdtempSync } from "fs";
import { join as join5 } from "path";
import { tmpdir } from "os";
import { randomUUID as randomUUID2 } from "crypto";
var execFileAsync, EXEC_MAX_BUFFER, DockerImageSandbox;
var init_docker_image_sandbox = __esm({
  "src/sandbox/docker-image-sandbox.ts"() {
    "use strict";
    init_logger();
    init_sandbox_telemetry();
    execFileAsync = promisify(execFileCb);
    EXEC_MAX_BUFFER = 50 * 1024 * 1024;
    DockerImageSandbox = class {
      name;
      config;
      containerId = null;
      containerName;
      repoPath;
      visorDistPath;
      cacheVolumeMounts;
      constructor(name, config, repoPath, visorDistPath, cacheVolumeMounts = []) {
        this.name = name;
        this.config = config;
        this.repoPath = repoPath;
        this.visorDistPath = visorDistPath;
        this.containerName = `visor-${name}-${randomUUID2().slice(0, 8)}`;
        this.cacheVolumeMounts = cacheVolumeMounts;
      }
      /**
       * Build the Docker image if needed (dockerfile or dockerfile_inline mode)
       */
      async buildImageIfNeeded() {
        if (this.config.image) {
          return this.config.image;
        }
        const imageName = `visor-sandbox-${this.name}`;
        const buildMode = this.config.dockerfile_inline ? "inline" : "dockerfile";
        return withActiveSpan2(
          "visor.sandbox.build",
          {
            "visor.sandbox.name": this.name,
            "visor.sandbox.build.mode": buildMode
          },
          async () => {
            if (this.config.dockerfile_inline) {
              if (!/^\s*FROM\s+/im.test(this.config.dockerfile_inline)) {
                throw new Error(
                  `Sandbox '${this.name}' has invalid dockerfile_inline: must contain a FROM instruction`
                );
              }
              const tmpDir = mkdtempSync(join5(tmpdir(), "visor-build-"));
              const dockerfilePath = join5(tmpDir, "Dockerfile");
              writeFileSync3(dockerfilePath, this.config.dockerfile_inline, "utf8");
              try {
                logger.info(`Building sandbox image '${imageName}' from inline Dockerfile`);
                await execFileAsync(
                  "docker",
                  ["build", "-t", imageName, "-f", dockerfilePath, this.repoPath],
                  {
                    maxBuffer: EXEC_MAX_BUFFER,
                    timeout: 3e5
                  }
                );
              } finally {
                try {
                  unlinkSync2(dockerfilePath);
                } catch {
                }
              }
              return imageName;
            }
            if (this.config.dockerfile) {
              logger.info(`Building sandbox image '${imageName}' from ${this.config.dockerfile}`);
              await execFileAsync(
                "docker",
                ["build", "-t", imageName, "-f", this.config.dockerfile, this.repoPath],
                { maxBuffer: EXEC_MAX_BUFFER, timeout: 3e5 }
              );
              return imageName;
            }
            throw new Error(`Sandbox '${this.name}' has no image, dockerfile, or dockerfile_inline`);
          }
        );
      }
      /**
       * Start the sandbox container
       */
      async start() {
        const image = await this.buildImageIfNeeded();
        const workdir = this.config.workdir || "/workspace";
        const visorPath = this.config.visor_path || "/opt/visor";
        const readOnlySuffix = this.config.read_only ? ":ro" : "";
        const args = [
          "docker",
          "run",
          "-d",
          "--name",
          this.containerName,
          "-v",
          `${this.repoPath}:${workdir}${readOnlySuffix}`,
          "-v",
          `${this.visorDistPath}:${visorPath}:ro`,
          "-w",
          workdir
        ];
        if (this.config.network === false) {
          args.push("--network", "none");
        }
        if (this.config.resources?.memory) {
          args.push("--memory", this.config.resources.memory);
        }
        if (this.config.resources?.cpu) {
          args.push("--cpus", String(this.config.resources.cpu));
        }
        for (const mount of this.cacheVolumeMounts) {
          args.push("-v", mount);
        }
        args.push(image, "sleep", "infinity");
        logger.info(`Starting sandbox container '${this.containerName}'`);
        const { stdout } = await execFileAsync(args[0], args.slice(1), {
          maxBuffer: EXEC_MAX_BUFFER,
          timeout: 6e4
        });
        this.containerId = stdout.trim();
        addEvent2("visor.sandbox.container.started", {
          container_name: this.containerName,
          image
        });
      }
      /**
       * Execute a command inside the running container
       */
      async exec(options) {
        if (!this.containerId) {
          throw new Error(`Sandbox '${this.name}' is not started`);
        }
        const args = ["docker", "exec"];
        for (const [key, value] of Object.entries(options.env)) {
          if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key)) {
            throw new Error(`Invalid environment variable name: '${key}'`);
          }
          args.push("-e", `${key}=${value}`);
        }
        args.push(this.containerName, "sh", "-c", options.command);
        try {
          const { stdout, stderr } = await execFileAsync(args[0], args.slice(1), {
            maxBuffer: options.maxBuffer || EXEC_MAX_BUFFER,
            timeout: options.timeoutMs || 6e5
          });
          return { stdout, stderr, exitCode: 0 };
        } catch (err) {
          const execErr = err;
          return {
            stdout: execErr.stdout || "",
            stderr: execErr.stderr || "",
            exitCode: typeof execErr.code === "number" ? execErr.code : 1
          };
        }
      }
      /**
       * Stop and remove the container
       */
      async stop() {
        if (this.containerName) {
          try {
            await execFileAsync("docker", ["rm", "-f", this.containerName], {
              maxBuffer: EXEC_MAX_BUFFER,
              timeout: 3e4
            });
          } catch {
          }
          addEvent2("visor.sandbox.container.stopped", {
            container_name: this.containerName
          });
          this.containerId = null;
        }
      }
    };
  }
});

// src/sandbox/docker-compose-sandbox.ts
import { promisify as promisify2 } from "util";
import { execFile as execFileCb2 } from "child_process";
import { randomUUID as randomUUID3 } from "crypto";
var execFileAsync2, EXEC_MAX_BUFFER2, DockerComposeSandbox;
var init_docker_compose_sandbox = __esm({
  "src/sandbox/docker-compose-sandbox.ts"() {
    "use strict";
    init_logger();
    execFileAsync2 = promisify2(execFileCb2);
    EXEC_MAX_BUFFER2 = 50 * 1024 * 1024;
    DockerComposeSandbox = class {
      name;
      config;
      projectName;
      started = false;
      constructor(name, config) {
        this.name = name;
        this.config = config;
        this.projectName = `visor-${name}-${randomUUID3().slice(0, 8)}`;
      }
      /**
       * Start the compose services
       */
      async start() {
        if (!this.config.compose) {
          throw new Error(`Sandbox '${this.name}' has no compose file specified`);
        }
        if (!this.config.service) {
          throw new Error(`Sandbox '${this.name}' requires a 'service' field for compose mode`);
        }
        logger.info(`Starting compose sandbox '${this.name}' (project: ${this.projectName})`);
        await execFileAsync2(
          "docker",
          ["compose", "-f", this.config.compose, "-p", this.projectName, "up", "-d"],
          {
            maxBuffer: EXEC_MAX_BUFFER2,
            timeout: 12e4
          }
        );
        this.started = true;
      }
      /**
       * Execute a command inside the compose service
       */
      async exec(options) {
        if (!this.started) {
          throw new Error(`Compose sandbox '${this.name}' is not started`);
        }
        const service = this.config.service;
        const args = [
          "docker",
          "compose",
          "-f",
          this.config.compose,
          "-p",
          this.projectName,
          "exec",
          "-T"
          // non-interactive
        ];
        for (const [key, value] of Object.entries(options.env)) {
          if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key)) {
            throw new Error(`Invalid environment variable name: '${key}'`);
          }
          args.push("-e", `${key}=${value}`);
        }
        if (this.config.workdir) {
          args.push("-w", this.config.workdir);
        }
        args.push(service, "sh", "-c", options.command);
        try {
          const { stdout, stderr } = await execFileAsync2(args[0], args.slice(1), {
            maxBuffer: options.maxBuffer || EXEC_MAX_BUFFER2,
            timeout: options.timeoutMs || 6e5
          });
          return { stdout, stderr, exitCode: 0 };
        } catch (err) {
          const execErr = err;
          return {
            stdout: execErr.stdout || "",
            stderr: execErr.stderr || "",
            exitCode: typeof execErr.code === "number" ? execErr.code : 1
          };
        }
      }
      /**
       * Stop and tear down the compose project
       */
      async stop() {
        if (this.started && this.config.compose) {
          try {
            await execFileAsync2(
              "docker",
              ["compose", "-f", this.config.compose, "-p", this.projectName, "down"],
              {
                maxBuffer: EXEC_MAX_BUFFER2,
                timeout: 6e4
              }
            );
          } catch {
          }
          this.started = false;
        }
      }
    };
  }
});

// src/sandbox/cache-volume-manager.ts
import { promisify as promisify3 } from "util";
import { execFile as execFileCb3 } from "child_process";
import { createHash } from "crypto";
function pathHash(containerPath) {
  return createHash("sha256").update(containerPath).digest("hex").slice(0, 8);
}
function parseTtl(ttl) {
  let ms = 0;
  const dayMatch = ttl.match(/(\d+)d/);
  const hourMatch = ttl.match(/(\d+)h/);
  const minMatch = ttl.match(/(\d+)m/);
  if (dayMatch) ms += parseInt(dayMatch[1], 10) * 864e5;
  if (hourMatch) ms += parseInt(hourMatch[1], 10) * 36e5;
  if (minMatch) ms += parseInt(minMatch[1], 10) * 6e4;
  return ms || 6048e5;
}
var execFileAsync3, EXEC_MAX_BUFFER3, CacheVolumeManager;
var init_cache_volume_manager = __esm({
  "src/sandbox/cache-volume-manager.ts"() {
    "use strict";
    init_logger();
    execFileAsync3 = promisify3(execFileCb3);
    EXEC_MAX_BUFFER3 = 10 * 1024 * 1024;
    CacheVolumeManager = class {
      /**
       * Resolve cache config into Docker volume mount specs.
       *
       * Volume naming: visor-cache-<prefix>-<sandboxName>-<pathHash>
       *
       * @param sandboxName - Name of the sandbox
       * @param cacheConfig - Cache configuration from sandbox config
       * @param gitBranch - Current git branch (used as default prefix)
       * @returns Array of volume mount specs for docker run -v
       */
      async resolveVolumes(sandboxName, cacheConfig, gitBranch) {
        const prefix = (cacheConfig.prefix || gitBranch).replace(/[^a-zA-Z0-9._-]/g, "-");
        const volumes = [];
        for (const containerPath of cacheConfig.paths) {
          if (/\.\./.test(containerPath)) {
            throw new Error(`Cache path '${containerPath}' must not contain '..' path traversal`);
          }
          const hash = pathHash(containerPath);
          const volumeName = `visor-cache-${prefix}-${sandboxName}-${hash}`;
          const exists = await this.volumeExists(volumeName);
          if (!exists && cacheConfig.fallback_prefix) {
            const fallbackPrefix = cacheConfig.fallback_prefix.replace(/[^a-zA-Z0-9._-]/g, "-");
            const fallbackVolume = `visor-cache-${fallbackPrefix}-${sandboxName}-${hash}`;
            const fallbackExists = await this.volumeExists(fallbackVolume);
            if (fallbackExists) {
              logger.info(`Cache miss for '${volumeName}', copying from fallback '${fallbackVolume}'`);
              await this.copyVolume(fallbackVolume, volumeName);
            } else {
              await this.createVolume(volumeName);
            }
          } else if (!exists) {
            await this.createVolume(volumeName);
          }
          await this.touchVolume(volumeName);
          volumes.push({
            volumeName,
            mountSpec: `${volumeName}:${containerPath}`
          });
        }
        return volumes;
      }
      /**
       * Check if a Docker volume exists
       */
      async volumeExists(name) {
        try {
          await execFileAsync3("docker", ["volume", "inspect", name], {
            maxBuffer: EXEC_MAX_BUFFER3,
            timeout: 1e4
          });
          return true;
        } catch {
          return false;
        }
      }
      /**
       * Create a Docker named volume
       */
      async createVolume(name) {
        const now = (/* @__PURE__ */ new Date()).toISOString();
        await execFileAsync3("docker", ["volume", "create", "--label", `visor.last-used=${now}`, name], {
          maxBuffer: EXEC_MAX_BUFFER3,
          timeout: 1e4
        });
      }
      /**
       * Copy data from one volume to another using a temp container
       */
      async copyVolume(source, target) {
        await this.createVolume(target);
        try {
          await execFileAsync3(
            "docker",
            [
              "run",
              "--rm",
              "-v",
              `${source}:/src:ro`,
              "-v",
              `${target}:/dst`,
              "alpine",
              "sh",
              "-c",
              "cp -a /src/. /dst/"
            ],
            { maxBuffer: EXEC_MAX_BUFFER3, timeout: 6e4 }
          );
        } catch (err) {
          logger.warn(`Failed to copy cache volume ${source} -> ${target}: ${err}`);
        }
      }
      /**
       * Update the last-used label on a volume.
       * Docker doesn't support updating labels in-place, so we record via a temp file approach
       * by simply re-creating volumes with updated labels if they don't exist.
       * For existing volumes, we track usage time via the volume name pattern.
       */
      async touchVolume(_name) {
      }
      /**
       * Evict expired cache volumes for a sandbox
       */
      async evictExpired(sandboxName, ttl, maxScopes) {
        const ttlMs = ttl ? parseTtl(ttl) : 6048e5;
        const maxScopesLimit = maxScopes || 10;
        try {
          const { stdout } = await execFileAsync3(
            "docker",
            ["volume", "ls", "--filter", "name=visor-cache-", "--format", "{{.Name}}"],
            { maxBuffer: EXEC_MAX_BUFFER3, timeout: 1e4 }
          );
          const allVolumes = stdout.trim().split("\n").filter(Boolean);
          const sandboxVolumes = allVolumes.filter((v) => v.includes(`-${sandboxName}-`));
          if (sandboxVolumes.length === 0) return;
          const scopeMap = /* @__PURE__ */ new Map();
          for (const vol of sandboxVolumes) {
            const match = vol.match(/^visor-cache-(.+)-\w{8}$/);
            if (match) {
              const prefix = match[1].replace(`-${sandboxName}`, "");
              if (!scopeMap.has(prefix)) scopeMap.set(prefix, []);
              scopeMap.get(prefix).push(vol);
            }
          }
          const now = Date.now();
          const inspectResults = await Promise.allSettled(
            sandboxVolumes.map(async (vol) => {
              const { stdout: inspectOut } = await execFileAsync3(
                "docker",
                ["volume", "inspect", vol, "--format", "{{.CreatedAt}}"],
                { maxBuffer: EXEC_MAX_BUFFER3, timeout: 1e4 }
              );
              return { vol, createdAt: new Date(inspectOut.trim()).getTime() };
            })
          );
          for (const result of inspectResults) {
            if (result.status !== "fulfilled") continue;
            const { vol, createdAt } = result.value;
            if (now - createdAt > ttlMs) {
              try {
                logger.info(`Evicting expired cache volume: ${vol}`);
                await execFileAsync3("docker", ["volume", "rm", vol], {
                  maxBuffer: EXEC_MAX_BUFFER3,
                  timeout: 1e4
                });
              } catch {
              }
            }
          }
          if (scopeMap.size > maxScopesLimit) {
            const scopes = Array.from(scopeMap.keys());
            const toRemove = scopes.slice(0, scopes.length - maxScopesLimit);
            for (const scope of toRemove) {
              const vols = scopeMap.get(scope) || [];
              for (const vol of vols) {
                try {
                  logger.info(`Evicting cache volume (max_scopes exceeded): ${vol}`);
                  await execFileAsync3("docker", ["volume", "rm", vol], {
                    maxBuffer: EXEC_MAX_BUFFER3,
                    timeout: 1e4
                  });
                } catch {
                }
              }
            }
          }
        } catch {
        }
      }
    };
  }
});

// src/sandbox/sandbox-manager.ts
import { resolve, dirname, join as join6 } from "path";
import { existsSync as existsSync4 } from "fs";
var SandboxManager;
var init_sandbox_manager = __esm({
  "src/sandbox/sandbox-manager.ts"() {
    "use strict";
    init_docker_image_sandbox();
    init_docker_compose_sandbox();
    init_cache_volume_manager();
    init_logger();
    init_sandbox_telemetry();
    SandboxManager = class {
      sandboxDefs;
      repoPath;
      gitBranch;
      instances = /* @__PURE__ */ new Map();
      cacheManager;
      visorDistPath;
      /** Get the resolved repository path (used by trace file relay) */
      getRepoPath() {
        return this.repoPath;
      }
      constructor(sandboxDefs, repoPath, gitBranch) {
        this.sandboxDefs = sandboxDefs;
        this.repoPath = resolve(repoPath);
        this.gitBranch = gitBranch;
        this.cacheManager = new CacheVolumeManager();
        this.visorDistPath = existsSync4(join6(__dirname, "index.js")) ? __dirname : resolve(dirname(__dirname));
      }
      /**
       * Resolve which sandbox a check should use.
       * Returns null if the check should run on the host.
       *
       * Resolution order:
       * 1. Check-level sandbox: (explicit override)
       * 2. Workspace-level sandbox: (default)
       * 3. null  run on host
       */
      resolveSandbox(checkSandbox, workspaceDefault) {
        const name = checkSandbox || workspaceDefault;
        if (!name) return null;
        if (!this.sandboxDefs[name]) {
          throw new Error(`Sandbox '${name}' is not defined in sandboxes configuration`);
        }
        return name;
      }
      /**
       * Get or lazily start a sandbox instance by name.
       */
      async getOrStart(name) {
        const existing = this.instances.get(name);
        if (existing) return existing;
        const config = this.sandboxDefs[name];
        if (!config) {
          throw new Error(`Sandbox '${name}' is not defined`);
        }
        const mode = config.compose ? "compose" : "image";
        return withActiveSpan2(
          "visor.sandbox.start",
          {
            "visor.sandbox.name": name,
            "visor.sandbox.mode": mode
          },
          async () => {
            let instance;
            if (config.compose) {
              const composeSandbox = new DockerComposeSandbox(name, config);
              await composeSandbox.start();
              instance = composeSandbox;
            } else {
              let cacheVolumeMounts = [];
              if (config.cache) {
                const volumes = await this.cacheManager.resolveVolumes(
                  name,
                  config.cache,
                  this.gitBranch
                );
                cacheVolumeMounts = volumes.map((v) => v.mountSpec);
              }
              const imageSandbox = new DockerImageSandbox(
                name,
                config,
                this.repoPath,
                this.visorDistPath,
                cacheVolumeMounts
              );
              await imageSandbox.start();
              instance = imageSandbox;
            }
            this.instances.set(name, instance);
            return instance;
          }
        );
      }
      /**
       * Execute a command inside a named sandbox
       */
      async exec(name, options) {
        const instance = await this.getOrStart(name);
        return withActiveSpan2(
          "visor.sandbox.exec",
          {
            "visor.sandbox.name": name
          },
          async (span) => {
            const result = await instance.exec(options);
            try {
              span.setAttribute("visor.sandbox.exit_code", result.exitCode);
            } catch {
            }
            return result;
          }
        );
      }
      /**
       * Stop all running sandbox instances and run cache eviction
       */
      async stopAll() {
        return withActiveSpan2("visor.sandbox.stopAll", void 0, async () => {
          const stopPromises = Array.from(this.instances.entries()).map(async ([name, instance]) => {
            try {
              await instance.stop();
              addEvent2("visor.sandbox.stopped", { "visor.sandbox.name": name });
              logger.info(`Stopped sandbox '${name}'`);
            } catch (err) {
              logger.warn(`Failed to stop sandbox '${name}': ${err}`);
            }
            const config = this.sandboxDefs[name];
            if (config?.cache) {
              try {
                await this.cacheManager.evictExpired(name, config.cache.ttl, config.cache.max_scopes);
              } catch {
              }
            }
          });
          await Promise.allSettled(stopPromises);
          this.instances.clear();
        });
      }
    };
  }
});

// src/utils/workspace-manager.ts
import * as fsp from "fs/promises";
import * as path5 from "path";
function shellEscape(str) {
  return "'" + str.replace(/'/g, "'\\''") + "'";
}
function sanitizePathComponent(name) {
  return name.replace(/\.\./g, "").replace(/[\/\\]/g, "-").replace(/^\.+/, "").trim() || "unnamed";
}
var WorkspaceManager;
var init_workspace_manager = __esm({
  "src/utils/workspace-manager.ts"() {
    "use strict";
    init_command_executor();
    init_logger();
    WorkspaceManager = class _WorkspaceManager {
      static instances = /* @__PURE__ */ new Map();
      sessionId;
      basePath;
      workspacePath;
      originalPath;
      config;
      initialized = false;
      mainProjectInfo = null;
      projects = /* @__PURE__ */ new Map();
      cleanupHandlersRegistered = false;
      usedNames = /* @__PURE__ */ new Set();
      // Reference counting to prevent premature cleanup
      activeOperations = 0;
      cleanupRequested = false;
      cleanupResolvers = [];
      constructor(sessionId, originalPath, config) {
        this.sessionId = sessionId;
        this.originalPath = originalPath;
        const configuredName = config?.name || process.env.VISOR_WORKSPACE_NAME;
        const configuredMainProjectName = config?.mainProjectName || process.env.VISOR_WORKSPACE_PROJECT;
        this.config = {
          enabled: true,
          basePath: process.env.VISOR_WORKSPACE_PATH || "/tmp/visor-workspaces",
          cleanupOnExit: true,
          name: configuredName,
          mainProjectName: configuredMainProjectName,
          ...config
        };
        this.basePath = this.config.basePath;
        const workspaceDirName = sanitizePathComponent(this.config.name || this.sessionId);
        this.workspacePath = path5.join(this.basePath, workspaceDirName);
      }
      /**
       * Get or create a WorkspaceManager instance for a session
       */
      static getInstance(sessionId, originalPath, config) {
        if (!_WorkspaceManager.instances.has(sessionId)) {
          _WorkspaceManager.instances.set(
            sessionId,
            new _WorkspaceManager(sessionId, originalPath, config)
          );
        }
        return _WorkspaceManager.instances.get(sessionId);
      }
      /**
       * Clear all instances (for testing)
       */
      static clearInstances() {
        _WorkspaceManager.instances.clear();
      }
      /**
       * Check if workspace isolation is enabled
       */
      isEnabled() {
        return this.config.enabled;
      }
      /**
       * Acquire a reference to the workspace (prevents cleanup while held)
       * Call release() when done with the operation.
       */
      acquire() {
        this.activeOperations++;
        logger.debug(
          `[Workspace] Acquired reference (active: ${this.activeOperations}) for ${this.workspacePath}`
        );
      }
      /**
       * Release a reference to the workspace.
       * If cleanup was requested and this was the last reference, cleanup will proceed.
       */
      release() {
        this.activeOperations = Math.max(0, this.activeOperations - 1);
        logger.debug(
          `[Workspace] Released reference (active: ${this.activeOperations}) for ${this.workspacePath}`
        );
        if (this.cleanupRequested && this.activeOperations === 0) {
          logger.debug(`[Workspace] All references released, proceeding with deferred cleanup`);
          for (const resolve5 of this.cleanupResolvers) {
            resolve5();
          }
          this.cleanupResolvers = [];
        }
      }
      /**
       * Get the number of active operations
       */
      getActiveOperations() {
        return this.activeOperations;
      }
      /**
       * Get the workspace path
       */
      getWorkspacePath() {
        return this.workspacePath;
      }
      /**
       * Get the original working directory
       */
      getOriginalPath() {
        return this.originalPath;
      }
      /**
       * Get workspace info (only available after initialize)
       */
      getWorkspaceInfo() {
        return this.mainProjectInfo;
      }
      /**
       * Initialize the workspace - creates workspace directory and main project worktree
       */
      async initialize() {
        if (!this.config.enabled) {
          throw new Error("Workspace isolation is not enabled");
        }
        if (this.initialized && this.mainProjectInfo) {
          return this.mainProjectInfo;
        }
        logger.info(`Initializing workspace: ${this.workspacePath}`);
        await fsp.mkdir(this.workspacePath, { recursive: true });
        logger.debug(`Created workspace directory: ${this.workspacePath}`);
        const configuredMainProjectName = this.config.mainProjectName;
        const mainProjectName = sanitizePathComponent(
          configuredMainProjectName || this.extractProjectName(this.originalPath)
        );
        this.usedNames.add(mainProjectName);
        const mainProjectPath = path5.join(this.workspacePath, mainProjectName);
        const isGitRepo = await this.isGitRepository(this.originalPath);
        if (isGitRepo) {
          await this.createMainProjectWorktree(mainProjectPath);
        } else {
          logger.debug(`Original path is not a git repo, creating symlink`);
          try {
            await fsp.symlink(this.originalPath, mainProjectPath);
          } catch (error) {
            throw new Error(`Failed to create symlink for main project: ${error}`);
          }
        }
        this.registerCleanupHandlers();
        this.mainProjectInfo = {
          sessionId: this.sessionId,
          workspacePath: this.workspacePath,
          mainProjectPath,
          mainProjectName,
          originalPath: this.originalPath
        };
        this.initialized = true;
        logger.info(`Workspace initialized: ${this.workspacePath}`);
        return this.mainProjectInfo;
      }
      /**
       * Add a project to the workspace (creates symlink to worktree)
       * If the same repository + worktreePath combination already exists, returns the existing path.
       */
      async addProject(repository, worktreePath, description) {
        if (!this.initialized) {
          throw new Error("Workspace not initialized. Call initialize() first.");
        }
        for (const [existingName, existingProject] of this.projects.entries()) {
          if (existingProject.repository === repository && existingProject.worktreePath === worktreePath) {
            logger.debug(`Reusing existing project: ${existingName} (${repository})`);
            return existingProject.path;
          }
        }
        let projectName = sanitizePathComponent(description || this.extractRepoName(repository));
        projectName = this.getUniqueName(projectName);
        this.usedNames.add(projectName);
        const workspacePath = path5.join(this.workspacePath, projectName);
        await fsp.rm(workspacePath, { recursive: true, force: true });
        try {
          await fsp.symlink(worktreePath, workspacePath);
        } catch (error) {
          throw new Error(`Failed to create symlink for project ${projectName}: ${error}`);
        }
        this.projects.set(projectName, {
          name: projectName,
          path: workspacePath,
          worktreePath,
          repository
        });
        logger.info(`Added project to workspace: ${projectName} -> ${worktreePath}`);
        return workspacePath;
      }
      /**
       * List all projects in the workspace
       */
      listProjects() {
        return Array.from(this.projects.values());
      }
      /**
       * Cleanup the workspace.
       * If there are active operations, waits for them to complete before cleaning up.
       * @param timeout Maximum time to wait for active operations (default: 60s)
       */
      async cleanup(timeout = 6e4) {
        logger.info(
          `Cleaning up workspace: ${this.workspacePath} (active operations: ${this.activeOperations})`
        );
        if (this.activeOperations > 0) {
          logger.info(
            `[Workspace] Waiting for ${this.activeOperations} active operations to complete before cleanup`
          );
          this.cleanupRequested = true;
          await Promise.race([
            new Promise((resolve5) => {
              if (this.activeOperations === 0) {
                resolve5();
              } else {
                this.cleanupResolvers.push(resolve5);
              }
            }),
            new Promise((resolve5) => {
              setTimeout(() => {
                logger.warn(
                  `[Workspace] Cleanup timeout after ${timeout}ms, proceeding anyway (${this.activeOperations} operations still active)`
                );
                resolve5();
              }, timeout);
            })
          ]);
        }
        try {
          if (this.mainProjectInfo) {
            const mainProjectPath = this.mainProjectInfo.mainProjectPath;
            try {
              const stats = await fsp.lstat(mainProjectPath);
              if (!stats.isSymbolicLink()) {
                await this.removeMainProjectWorktree(mainProjectPath);
              }
            } catch {
            }
          }
          await fsp.rm(this.workspacePath, { recursive: true, force: true });
          logger.debug(`Removed workspace directory: ${this.workspacePath}`);
          _WorkspaceManager.instances.delete(this.sessionId);
          this.initialized = false;
          this.mainProjectInfo = null;
          this.projects.clear();
          this.usedNames.clear();
          this.cleanupRequested = false;
          this.cleanupResolvers = [];
          logger.info(`Workspace cleanup completed: ${this.sessionId}`);
        } catch (error) {
          logger.warn(`Failed to cleanup workspace: ${error}`);
        }
      }
      /**
       * Create worktree for the main project
       *
       * visor-disable: architecture - Not using WorktreeManager here because:
       * 1. WorktreeManager expects remote URLs and clones to bare repos first
       * 2. This operates on the LOCAL repo we're already in (no cloning needed)
       * 3. Adding a "local mode" to WorktreeManager would add complexity for minimal benefit
       * The git commands here are simpler (just rev-parse + worktree add) vs WorktreeManager's
       * full clone/bare-repo/fetch/worktree pipeline.
       */
      async createMainProjectWorktree(targetPath) {
        logger.debug(`Creating main project worktree: ${targetPath}`);
        const headResult = await commandExecutor.execute(
          `git -C ${shellEscape(this.originalPath)} rev-parse HEAD`,
          {
            timeout: 1e4
          }
        );
        if (headResult.exitCode !== 0) {
          throw new Error(`Failed to get HEAD: ${headResult.stderr}`);
        }
        const headRef = headResult.stdout.trim();
        const createCmd = `git -C ${shellEscape(this.originalPath)} worktree add --detach ${shellEscape(targetPath)} ${shellEscape(headRef)}`;
        const result = await commandExecutor.execute(createCmd, { timeout: 6e4 });
        if (result.exitCode !== 0) {
          throw new Error(`Failed to create main project worktree: ${result.stderr}`);
        }
        logger.debug(`Created main project worktree at ${targetPath}`);
      }
      /**
       * Remove main project worktree
       */
      async removeMainProjectWorktree(worktreePath) {
        logger.debug(`Removing main project worktree: ${worktreePath}`);
        const removeCmd = `git -C ${shellEscape(this.originalPath)} worktree remove ${shellEscape(worktreePath)} --force`;
        const result = await commandExecutor.execute(removeCmd, { timeout: 3e4 });
        if (result.exitCode !== 0) {
          logger.warn(`Failed to remove worktree via git: ${result.stderr}`);
        }
      }
      /**
       * Check if a path is a git repository
       */
      async isGitRepository(dirPath) {
        try {
          const result = await commandExecutor.execute(
            `git -C ${shellEscape(dirPath)} rev-parse --git-dir`,
            {
              timeout: 5e3
            }
          );
          return result.exitCode === 0;
        } catch {
          return false;
        }
      }
      /**
       * Extract project name from path
       */
      extractProjectName(dirPath) {
        return path5.basename(dirPath);
      }
      /**
       * Extract repository name from owner/repo format
       */
      extractRepoName(repository) {
        if (repository.includes("://") || repository.startsWith("git@")) {
          const match = repository.match(/[/:]([^/:]+\/[^/:]+?)(?:\.git)?$/);
          if (match) {
            return match[1].split("/").pop() || repository;
          }
        }
        if (repository.includes("/")) {
          return repository.split("/").pop() || repository;
        }
        return repository;
      }
      /**
       * Get a unique name by appending a number if needed
       */
      getUniqueName(baseName) {
        if (!this.usedNames.has(baseName)) {
          return baseName;
        }
        let counter = 2;
        let uniqueName = `${baseName}-${counter}`;
        while (this.usedNames.has(uniqueName)) {
          counter++;
          uniqueName = `${baseName}-${counter}`;
        }
        return uniqueName;
      }
      /**
       * Register cleanup handlers for process exit
       */
      registerCleanupHandlers() {
        if (this.cleanupHandlersRegistered || !this.config.cleanupOnExit) {
          return;
        }
        this.cleanupHandlersRegistered = true;
      }
    };
  }
});

// src/state-machine/context/build-engine-context.ts
var build_engine_context_exports = {};
__export(build_engine_context_exports, {
  buildEngineContextForRun: () => buildEngineContextForRun,
  initializeWorkspace: () => initializeWorkspace
});
function applyCriticalityDefaults(cfg) {
  const checks = cfg.checks || {};
  for (const id of Object.keys(checks)) {
    const c = checks[id];
    if (!c.criticality) c.criticality = "policy";
    if (c.criticality === "info" && typeof c.continue_on_failure === "undefined")
      c.continue_on_failure = true;
  }
}
function buildEngineContextForRun(workingDirectory, config, prInfo, debug, maxParallelism, failFast, requestedChecks) {
  const clonedConfig = JSON.parse(JSON.stringify(config));
  const checks = {};
  applyCriticalityDefaults(clonedConfig);
  for (const [checkId, checkConfig] of Object.entries(clonedConfig.checks || {})) {
    checks[checkId] = {
      tags: checkConfig.tags || [],
      triggers: (Array.isArray(checkConfig.on) ? checkConfig.on : [checkConfig.on]).filter(
        Boolean
      ),
      group: checkConfig.group,
      providerType: checkConfig.type || "ai",
      // Normalize depends_on to array (supports string | string[])
      dependencies: Array.isArray(checkConfig.depends_on) ? checkConfig.depends_on : checkConfig.depends_on ? [checkConfig.depends_on] : []
    };
  }
  if (requestedChecks && requestedChecks.length > 0) {
    for (const checkName of requestedChecks) {
      if (!checks[checkName] && !clonedConfig.checks?.[checkName]) {
        logger.debug(`[StateMachine] Synthesizing minimal config for legacy check: ${checkName}`);
        if (!clonedConfig.checks) {
          clonedConfig.checks = {};
        }
        clonedConfig.checks[checkName] = {
          type: "ai",
          prompt: `Perform ${checkName} analysis`
        };
        checks[checkName] = {
          tags: [],
          triggers: [],
          group: "default",
          providerType: "ai",
          dependencies: []
        };
      }
    }
  }
  const journal = new ExecutionJournal();
  const memory = MemoryStore.getInstance(clonedConfig.memory);
  return {
    mode: "state-machine",
    config: clonedConfig,
    checks,
    journal,
    memory,
    workingDirectory,
    originalWorkingDirectory: workingDirectory,
    sessionId: generateHumanId(),
    event: prInfo.eventType,
    debug,
    maxParallelism,
    failFast,
    requestedChecks: requestedChecks && requestedChecks.length > 0 ? requestedChecks : void 0,
    // Store prInfo for later access (e.g., in getOutputHistorySnapshot)
    prInfo
  };
}
async function initializeWorkspace(context2) {
  const workspaceConfig = context2.config.workspace;
  const isEnabled = workspaceConfig?.enabled !== false && process.env.VISOR_WORKSPACE_ENABLED !== "false";
  if (!isEnabled) {
    logger.debug("[Workspace] Workspace isolation is disabled");
    return context2;
  }
  const originalPath = context2.workingDirectory || process.cwd();
  try {
    const keepWorkspace = process.env.VISOR_KEEP_WORKSPACE === "true";
    const workspace = WorkspaceManager.getInstance(context2.sessionId, originalPath, {
      enabled: true,
      basePath: workspaceConfig?.base_path || process.env.VISOR_WORKSPACE_PATH || "/tmp/visor-workspaces",
      cleanupOnExit: keepWorkspace ? false : workspaceConfig?.cleanup_on_exit !== false,
      name: workspaceConfig?.name || process.env.VISOR_WORKSPACE_NAME,
      mainProjectName: workspaceConfig?.main_project_name || process.env.VISOR_WORKSPACE_PROJECT
    });
    const info = await workspace.initialize();
    context2.workspace = workspace;
    context2.workingDirectory = info.mainProjectPath;
    context2.originalWorkingDirectory = originalPath;
    try {
      process.env.VISOR_WORKSPACE_ROOT = info.workspacePath;
      process.env.VISOR_WORKSPACE_MAIN_PROJECT = info.mainProjectPath;
      process.env.VISOR_WORKSPACE_MAIN_PROJECT_NAME = info.mainProjectName;
      process.env.VISOR_ORIGINAL_WORKDIR = originalPath;
    } catch {
    }
    logger.info(`[Workspace] Initialized workspace: ${info.workspacePath}`);
    logger.debug(`[Workspace] Main project at: ${info.mainProjectPath}`);
    if (keepWorkspace) {
      logger.info(`[Workspace] Keeping workspace after execution (--keep-workspace)`);
    }
    return context2;
  } catch (error) {
    logger.warn(`[Workspace] Failed to initialize workspace: ${error}`);
    logger.debug("[Workspace] Continuing without workspace isolation");
    return context2;
  }
}
var init_build_engine_context = __esm({
  "src/state-machine/context/build-engine-context.ts"() {
    "use strict";
    init_snapshot_store();
    init_memory_store();
    init_human_id();
    init_logger();
    init_workspace_manager();
  }
});

// src/state-machine/execution/summary.ts
var summary_exports = {};
__export(summary_exports, {
  convertToReviewSummary: () => convertToReviewSummary
});
function convertToReviewSummary(groupedResults, statistics) {
  const allIssues = [];
  for (const checkResults of Object.values(groupedResults)) {
    for (const checkResult of checkResults) {
      if (checkResult.issues && checkResult.issues.length > 0) {
        allIssues.push(...checkResult.issues);
      }
    }
  }
  if (statistics) {
    for (const checkStats of statistics.checks) {
      if (checkStats.errorMessage) {
        allIssues.push({
          file: "system",
          line: 0,
          endLine: void 0,
          ruleId: "system/error",
          message: checkStats.errorMessage,
          severity: "error",
          category: "logic",
          suggestion: void 0,
          replacement: void 0
        });
      }
    }
  }
  return {
    issues: allIssues
  };
}
var init_summary = __esm({
  "src/state-machine/execution/summary.ts"() {
    "use strict";
  }
});

// src/state-machine-execution-engine.ts
import * as path6 from "path";
import * as fs4 from "fs";
function serializeRunState(state) {
  return {
    ...state,
    levelQueue: state.levelQueue,
    eventQueue: state.eventQueue,
    activeDispatches: Array.from(state.activeDispatches.entries()),
    completedChecks: Array.from(state.completedChecks.values()),
    stats: Array.from(state.stats.entries()),
    historyLog: state.historyLog,
    forwardRunGuards: Array.from(state.forwardRunGuards.values()),
    currentLevelChecks: Array.from(state.currentLevelChecks.values()),
    currentWaveCompletions: Array.from(
      state.currentWaveCompletions || []
    ),
    // failedChecks is an internal Set added by stats/dispatch layers; keep it if present
    failedChecks: Array.from(state.failedChecks || []),
    pendingRunScopes: Array.from((state.pendingRunScopes || /* @__PURE__ */ new Map()).entries()).map(([k, v]) => [
      k,
      v
    ])
  };
}
var StateMachineExecutionEngine;
var init_state_machine_execution_engine = __esm({
  "src/state-machine-execution-engine.ts"() {
    "use strict";
    init_runner();
    init_logger();
    init_sandbox_manager();
    StateMachineExecutionEngine = class _StateMachineExecutionEngine {
      workingDirectory;
      executionContext;
      debugServer;
      _lastContext;
      _lastRunner;
      constructor(workingDirectory, octokit, debugServer) {
        this.workingDirectory = workingDirectory || process.cwd();
        this.debugServer = debugServer;
      }
      /**
       * Execute checks using the state machine engine
       *
       * Converts CheckExecutionOptions -> executeGroupedChecks() -> AnalysisResult
       */
      async executeChecks(options) {
        const startTime = Date.now();
        const timestamp = (/* @__PURE__ */ new Date()).toISOString();
        try {
          if (options.config?.memory) {
            const { MemoryStore: MemoryStore2 } = await import("./memory-store-3N4AZCYB.mjs");
            const memoryStore = MemoryStore2.getInstance(options.config.memory);
            await memoryStore.initialize();
            logger.debug("Memory store initialized");
          }
          const { GitRepositoryAnalyzer } = await import("./git-repository-analyzer-QFMW6WIS.mjs");
          const gitAnalyzer = new GitRepositoryAnalyzer(options.workingDirectory);
          logger.info("Analyzing local git repository...");
          const repositoryInfo = await gitAnalyzer.analyzeRepository();
          if (!repositoryInfo.isGitRepository) {
            return this.createErrorResult(
              repositoryInfo,
              "Not a git repository or no changes found",
              startTime,
              timestamp,
              options.checks
            );
          }
          const prInfo = gitAnalyzer.toPRInfo(repositoryInfo);
          try {
            const evt = options.webhookContext?.eventType;
            if (evt) prInfo.eventType = evt;
          } catch {
          }
          const filteredChecks = this.filterChecksByTags(
            options.checks,
            options.config,
            options.tagFilter || options.config?.tag_filter
          );
          if (filteredChecks.length === 0) {
            logger.warn("No checks match the tag filter criteria");
            return this.createErrorResult(
              repositoryInfo,
              "No checks match the tag filter criteria",
              startTime,
              timestamp,
              options.checks
            );
          }
          try {
            const map = options?.webhookContext?.webhookData;
            if (map) {
              const { CheckProviderRegistry: CheckProviderRegistry2 } = await import("./check-provider-registry-SMJ6JVVM.mjs");
              const reg = CheckProviderRegistry2.getInstance();
              const p = reg.getProvider("http_input");
              if (p && typeof p.setWebhookContext === "function") p.setWebhookContext(map);
              const prev = this.executionContext || {};
              this.setExecutionContext({ ...prev, webhookContext: { webhookData: map } });
            }
          } catch {
          }
          logger.info(`Executing checks: ${filteredChecks.join(", ")}`);
          const executionResult = await this.executeGroupedChecks(
            prInfo,
            filteredChecks,
            options.timeout,
            options.config,
            options.outputFormat,
            options.debug,
            options.maxParallelism,
            options.failFast,
            options.tagFilter
          );
          const executionTime = Date.now() - startTime;
          const reviewSummary = this.convertGroupedResultsToReviewSummary(
            executionResult.results,
            executionResult.statistics
          );
          let debugInfo;
          if (options.debug && reviewSummary.debug) {
            debugInfo = {
              provider: reviewSummary.debug.provider,
              model: reviewSummary.debug.model,
              processingTime: reviewSummary.debug.processingTime,
              parallelExecution: options.checks.length > 1,
              checksExecuted: options.checks,
              totalApiCalls: reviewSummary.debug.totalApiCalls || options.checks.length,
              apiCallDetails: reviewSummary.debug.apiCallDetails
            };
          }
          try {
            const histSnap = this.getOutputHistorySnapshot();
            reviewSummary.history = histSnap;
          } catch {
          }
          return {
            repositoryInfo,
            reviewSummary,
            executionTime,
            timestamp,
            checksExecuted: filteredChecks,
            executionStatistics: executionResult.statistics,
            debug: debugInfo
          };
        } catch (error) {
          const message = error instanceof Error ? error.message : "Unknown error occurred";
          logger.error("Error executing checks: " + message);
          const strictEnv = process.env.VISOR_STRICT_ERRORS === "true";
          if (strictEnv) {
            throw error;
          }
          const fallbackRepositoryInfo = {
            title: "Error during analysis",
            body: `Error: ${message || "Unknown error"}`,
            author: "system",
            base: "main",
            head: "HEAD",
            files: [],
            totalAdditions: 0,
            totalDeletions: 0,
            isGitRepository: false,
            workingDirectory: options.workingDirectory || process.cwd()
          };
          return this.createErrorResult(
            fallbackRepositoryInfo,
            message || "Unknown error occurred",
            startTime,
            timestamp,
            options.checks
          );
        }
      }
      /**
       * Get execution context (used by state machine to propagate hooks)
       */
      getExecutionContext() {
        return this.executionContext;
      }
      /**
       * Set execution context for external callers
       */
      setExecutionContext(context2) {
        this.executionContext = context2;
      }
      /**
       * Reset per-run state (no-op for state machine engine)
       *
       * The state machine engine is stateless per-run by design.
       * Each execution creates a fresh journal and context.
       * This method exists only for backward compatibility with test framework.
       *
       * @deprecated This is a no-op. State machine engine doesn't maintain per-run state.
       */
      resetPerRunState() {
      }
      /**
       * Execute grouped checks using the state machine engine
       *
       * M4: Production-ready with full telemetry and debug server support
       */
      async executeGroupedChecks(prInfo, checks, timeout, config, outputFormat, debug, maxParallelism, failFast, tagFilter, _pauseGate) {
        if (debug) {
          logger.info("[StateMachine] Using state machine engine");
        }
        if (!config) {
          const { ConfigManager } = await import("./config-7VTT64SQ.mjs");
          const configManager = new ConfigManager();
          config = await configManager.getDefaultConfig();
          logger.debug("[StateMachine] Using default configuration (no config provided)");
        }
        const configWithTagFilter = tagFilter ? {
          ...config,
          tag_filter: tagFilter
        } : config;
        const context2 = this.buildEngineContext(
          configWithTagFilter,
          prInfo,
          debug,
          maxParallelism,
          failFast,
          checks
          // Pass the explicit checks list
        );
        if (configWithTagFilter.sandboxes && Object.keys(configWithTagFilter.sandboxes).length > 0) {
          try {
            const { execSync } = __require("child_process");
            const gitBranch = execSync("git rev-parse --abbrev-ref HEAD", { encoding: "utf8" }).trim();
            context2.sandboxManager = new SandboxManager(
              configWithTagFilter.sandboxes,
              this.workingDirectory,
              gitBranch
            );
          } catch {
            context2.sandboxManager = new SandboxManager(
              configWithTagFilter.sandboxes,
              this.workingDirectory,
              "unknown"
            );
          }
        }
        const { initializeWorkspace: initializeWorkspace2 } = (init_build_engine_context(), __toCommonJS(build_engine_context_exports));
        await initializeWorkspace2(context2);
        context2.executionContext = this.getExecutionContext();
        this._lastContext = context2;
        let frontendsHost;
        if (Array.isArray(configWithTagFilter.frontends) && configWithTagFilter.frontends.length > 0) {
          try {
            const { EventBus } = await import("./event-bus-5K3Y2FCS.mjs");
            const { FrontendsHost } = await import("./host-FNOJ3KIS.mjs");
            const bus = new EventBus();
            context2.eventBus = bus;
            frontendsHost = new FrontendsHost(bus, logger);
            if (process.env.VISOR_DEBUG === "true") {
              try {
                const fns = (configWithTagFilter.frontends || []).map((f) => ({
                  name: f?.name,
                  hasConfig: !!f?.config,
                  cfg: f?.config || void 0
                }));
                logger.info(`[Frontends] Loading specs: ${JSON.stringify(fns)}`);
              } catch {
              }
            }
            await frontendsHost.load(configWithTagFilter.frontends);
            let owner;
            let name;
            let prNum;
            let headSha;
            try {
              const anyInfo = prInfo;
              owner = anyInfo?.eventContext?.repository?.owner?.login || process.env.GITHUB_REPOSITORY?.split("/")?.[0];
              name = anyInfo?.eventContext?.repository?.name || process.env.GITHUB_REPOSITORY?.split("/")?.[1];
              prNum = typeof anyInfo?.number === "number" ? anyInfo.number : void 0;
              headSha = anyInfo?.eventContext?.pull_request?.head?.sha || process.env.GITHUB_SHA;
            } catch {
            }
            const repoObj = owner && name ? { owner, name } : void 0;
            const octokit = this.executionContext?.octokit;
            if (!headSha && repoObj && prNum && octokit && typeof octokit.rest?.pulls?.get === "function") {
              try {
                const { data } = await octokit.rest.pulls.get({
                  owner: repoObj.owner,
                  repo: repoObj.name,
                  pull_number: prNum
                });
                headSha = data && data.head && data.head.sha || headSha;
              } catch {
              }
            }
            try {
              const prev = this.getExecutionContext() || {};
              this.setExecutionContext({ ...prev, eventBus: bus });
              try {
                context2.executionContext = this.getExecutionContext();
              } catch {
              }
            } catch {
            }
            await frontendsHost.startAll(() => ({
              eventBus: bus,
              logger,
              // Provide the active (possibly tag-filtered) config so frontends can read groups, etc.
              config: configWithTagFilter,
              run: {
                runId: context2.sessionId,
                repo: repoObj,
                pr: prNum,
                headSha,
                event: context2.event || prInfo?.eventType,
                actor: prInfo?.eventContext?.sender?.login || (typeof process.env.GITHUB_ACTOR === "string" ? process.env.GITHUB_ACTOR : void 0)
              },
              octokit,
              webhookContext: this.executionContext?.webhookContext,
              // Surface any injected test doubles for Slack as well
              slack: this.executionContext?.slack || this.executionContext?.slackClient
            }));
            try {
              bus.on("HumanInputRequested", async (envelope) => {
                try {
                  const ev = envelope && envelope.payload || envelope;
                  let channel = ev?.channel;
                  let threadTs = ev?.threadTs;
                  if (!channel || !threadTs) {
                    try {
                      const anyCfg = configWithTagFilter || {};
                      const slackCfg = anyCfg.slack || {};
                      const endpoint = slackCfg.endpoint || "/bots/slack/support";
                      const map = this.executionContext?.webhookContext?.webhookData;
                      const payload = map?.get(endpoint);
                      const e = payload?.event;
                      const derivedTs = String(e?.thread_ts || e?.ts || e?.event_ts || "");
                      const derivedCh = String(e?.channel || "");
                      if (derivedCh && derivedTs) {
                        channel = channel || derivedCh;
                        threadTs = threadTs || derivedTs;
                      }
                    } catch {
                    }
                  }
                  const checkId = String(ev?.checkId || "unknown");
                  const threadKey = ev?.threadKey || (channel && threadTs ? `${channel}:${threadTs}` : "session");
                  const baseDir = process.env.VISOR_SNAPSHOT_DIR || path6.resolve(process.cwd(), ".visor", "snapshots");
                  fs4.mkdirSync(baseDir, { recursive: true });
                  const filePath = path6.join(baseDir, `${threadKey}-${checkId}.json`);
                  await this.saveSnapshotToFile(filePath);
                  logger.info(`[Snapshot] Saved run snapshot: ${filePath}`);
                  try {
                    await bus.emit({
                      type: "SnapshotSaved",
                      checkId: ev?.checkId || "unknown",
                      channel,
                      threadTs,
                      threadKey,
                      filePath
                    });
                  } catch {
                  }
                } catch (e) {
                  logger.warn(
                    `[Snapshot] Failed to save snapshot on HumanInputRequested: ${e instanceof Error ? e.message : String(e)}`
                  );
                }
              });
            } catch {
            }
          } catch (err) {
            logger.warn(
              `[Frontends] Failed to initialize frontends: ${err instanceof Error ? err.message : String(err)}`
            );
          }
        }
        const runner = new StateMachineRunner(context2, this.debugServer);
        this._lastRunner = runner;
        try {
          const result = await runner.run();
          if (frontendsHost && typeof frontendsHost.stopAll === "function") {
            try {
              await frontendsHost.stopAll();
            } catch {
            }
          }
          if (debug) {
            logger.info("[StateMachine] Execution complete");
          }
          try {
            const { SessionRegistry: SessionRegistry2 } = await import("./session-registry-6PV6SGEJ.mjs");
            const sessionRegistry = SessionRegistry2.getInstance();
            sessionRegistry.clearAllSessions();
          } catch (error) {
            logger.debug(`[StateMachine] Failed to cleanup sessions: ${error}`);
          }
          if (context2.workspace) {
            try {
              await context2.workspace.cleanup();
            } catch (error) {
              logger.debug(`[StateMachine] Failed to cleanup workspace: ${error}`);
            }
          }
          return result;
        } finally {
          if (context2.sandboxManager) {
            await context2.sandboxManager.stopAll().catch((err) => {
              logger.warn(`Failed to stop sandboxes: ${err}`);
            });
            context2.sandboxManager = void 0;
          }
        }
      }
      /**
       * Build the engine context for state machine execution
       */
      buildEngineContext(config, prInfo, debug, maxParallelism, failFast, requestedChecks) {
        const { buildEngineContextForRun: buildEngineContextForRun2 } = (init_build_engine_context(), __toCommonJS(build_engine_context_exports));
        return buildEngineContextForRun2(
          this.workingDirectory,
          config,
          prInfo,
          debug,
          maxParallelism,
          failFast,
          requestedChecks
        );
      }
      /**
       * Get output history snapshot for test framework compatibility
       * Extracts output history from the journal
       */
      getOutputHistorySnapshot() {
        const journal = this._lastContext?.journal;
        if (!journal) {
          logger.debug("[StateMachine][DEBUG] getOutputHistorySnapshot: No journal found");
          return {};
        }
        const sessionId = this._lastContext?.sessionId;
        if (!sessionId) {
          logger.debug("[StateMachine][DEBUG] getOutputHistorySnapshot: No sessionId found");
          return {};
        }
        const snapshot = journal.beginSnapshot();
        const allEntries = journal.readVisible(sessionId, snapshot, void 0);
        logger.debug(
          `[StateMachine][DEBUG] getOutputHistorySnapshot: Found ${allEntries.length} journal entries`
        );
        const outputHistory = {};
        for (const entry of allEntries) {
          const checkId = entry.checkId;
          if (!outputHistory[checkId]) {
            outputHistory[checkId] = [];
          }
          try {
            if (entry && typeof entry.result === "object" && entry.result.__skipped) {
              continue;
            }
          } catch {
          }
          const payload = entry.result.output !== void 0 ? entry.result.output : entry.result;
          try {
            if (payload && typeof payload === "object" && payload.forEachItems && Array.isArray(payload.forEachItems)) {
              continue;
            }
          } catch {
          }
          if (payload !== void 0) outputHistory[checkId].push(payload);
        }
        logger.debug(
          `[StateMachine][DEBUG] getOutputHistorySnapshot result: ${JSON.stringify(Object.keys(outputHistory))}`
        );
        for (const [checkId, outputs] of Object.entries(outputHistory)) {
          logger.debug(`[StateMachine][DEBUG]   ${checkId}: ${outputs.length} outputs`);
        }
        return outputHistory;
      }
      /**
       * Save a JSON snapshot of the last run's state and journal to a file (experimental).
       * Does not include secrets. Intended for debugging and future resume support.
       */
      async saveSnapshotToFile(filePath) {
        const fs10 = await import("fs/promises");
        const ctx = this._lastContext;
        const runner = this._lastRunner;
        if (!ctx || !runner) {
          throw new Error("No prior execution context to snapshot");
        }
        const journal = ctx.journal;
        const snapshotId = journal.beginSnapshot();
        const entries = journal.readVisible(ctx.sessionId, snapshotId, void 0);
        const state = runner.getState();
        const serializableState = serializeRunState(state);
        const payload = {
          version: 1,
          sessionId: ctx.sessionId,
          event: ctx.event,
          wave: state.wave,
          state: serializableState,
          journal: entries,
          requestedChecks: ctx.requestedChecks || []
        };
        await fs10.writeFile(filePath, JSON.stringify(payload, null, 2), "utf8");
      }
      /**
       * Load a snapshot JSON from file and return it. Resume support can build on this.
       */
      async loadSnapshotFromFile(filePath) {
        const fs10 = await import("fs/promises");
        const raw = await fs10.readFile(filePath, "utf8");
        return JSON.parse(raw);
      }
      /**
       * Filter checks by tag filter
       */
      filterChecksByTags(checks, config, tagFilter) {
        return checks.filter((checkName) => {
          const checkConfig = config?.checks?.[checkName];
          if (!checkConfig) {
            return true;
          }
          const checkTags = checkConfig.tags || [];
          if (!tagFilter || !tagFilter.include && !tagFilter.exclude) {
            return checkTags.length === 0;
          }
          if (checkTags.length === 0) {
            return true;
          }
          if (tagFilter.exclude && tagFilter.exclude.length > 0) {
            const hasExcludedTag = tagFilter.exclude.some((tag) => checkTags.includes(tag));
            if (hasExcludedTag) return false;
          }
          if (tagFilter.include && tagFilter.include.length > 0) {
            const hasIncludedTag = tagFilter.include.some((tag) => checkTags.includes(tag));
            if (!hasIncludedTag) return false;
          }
          return true;
        });
      }
      /**
       * Create an error result in AnalysisResult format
       */
      createErrorResult(repositoryInfo, errorMessage, startTime, timestamp, checksExecuted) {
        const executionTime = Date.now() - startTime;
        return {
          repositoryInfo,
          reviewSummary: {
            issues: [
              {
                file: "system",
                line: 0,
                endLine: void 0,
                ruleId: "system/error",
                message: errorMessage,
                severity: "error",
                category: "logic",
                suggestion: void 0,
                replacement: void 0
              }
            ]
          },
          executionTime,
          timestamp,
          checksExecuted
        };
      }
      /**
       * Convert GroupedCheckResults to ReviewSummary
       * Aggregates all check results into a single ReviewSummary
       */
      convertGroupedResultsToReviewSummary(groupedResults, statistics) {
        const { convertToReviewSummary: convertToReviewSummary2 } = (init_summary(), __toCommonJS(summary_exports));
        return convertToReviewSummary2(groupedResults, statistics);
      }
      /**
       * Evaluate failure conditions for a check result
       *
       * This method provides backward compatibility with the legacy engine by
       * delegating to the FailureConditionEvaluator.
       *
       * @param checkName - The name of the check being evaluated
       * @param reviewSummary - The review summary containing check results
       * @param config - The Visor configuration containing failure conditions
       * @param previousOutputs - Optional previous check outputs for cross-check conditions
       * @param authorAssociation - Optional GitHub author association for permission checks
       * @returns Array of failure condition evaluation results
       */
      async evaluateFailureConditions(checkName, reviewSummary, config, previousOutputs, authorAssociation) {
        const { FailureConditionEvaluator: FailureConditionEvaluator2 } = await import("./failure-condition-evaluator-4WMDF4Q3.mjs");
        const evaluator = new FailureConditionEvaluator2();
        const { addEvent: addEvent3 } = await import("./trace-helpers-YHNPC7MR.mjs");
        const { addFailIfTriggered } = await import("./metrics-GXQ2EDXA.mjs");
        const checkConfig = config.checks?.[checkName];
        if (!checkConfig) {
          return [];
        }
        const rawSchema = checkConfig.schema || "code-review";
        const checkSchema = typeof rawSchema === "string" ? rawSchema : "code-review";
        const checkGroup = checkConfig.group || "default";
        const results = [];
        if (config.fail_if) {
          const failed = await evaluator.evaluateSimpleCondition(
            checkName,
            checkSchema,
            checkGroup,
            reviewSummary,
            config.fail_if,
            previousOutputs || {}
          );
          try {
            addEvent3("fail_if.evaluated", {
              "visor.check.id": checkName,
              scope: "global",
              expression: String(config.fail_if),
              result: failed ? "triggered" : "not_triggered"
            });
            if (failed) {
              addEvent3("fail_if.triggered", {
                "visor.check.id": checkName,
                scope: "global",
                expression: String(config.fail_if)
              });
              addFailIfTriggered(checkName, "global");
            }
          } catch {
          }
          results.push({
            conditionName: "global_fail_if",
            failed,
            expression: config.fail_if,
            message: failed ? `Global failure condition met: ${config.fail_if}` : void 0,
            severity: "error",
            haltExecution: false
          });
        }
        if (checkConfig.fail_if) {
          const failed = await evaluator.evaluateSimpleCondition(
            checkName,
            checkSchema,
            checkGroup,
            reviewSummary,
            checkConfig.fail_if,
            previousOutputs || {}
          );
          try {
            addEvent3("fail_if.evaluated", {
              "visor.check.id": checkName,
              scope: "check",
              expression: String(checkConfig.fail_if),
              result: failed ? "triggered" : "not_triggered"
            });
            if (failed) {
              addEvent3("fail_if.triggered", {
                "visor.check.id": checkName,
                scope: "check",
                expression: String(checkConfig.fail_if)
              });
              addFailIfTriggered(checkName, "check");
            }
          } catch {
          }
          results.push({
            conditionName: `${checkName}_fail_if`,
            failed,
            expression: checkConfig.fail_if,
            message: failed ? `Check failure condition met: ${checkConfig.fail_if}` : void 0,
            severity: "error",
            haltExecution: false
          });
        }
        const globalConditions = config.failure_conditions;
        const checkConditions = checkConfig.failure_conditions;
        if (globalConditions || checkConditions) {
          const legacyResults = await evaluator.evaluateConditions(
            checkName,
            checkSchema,
            checkGroup,
            reviewSummary,
            globalConditions,
            checkConditions,
            previousOutputs,
            authorAssociation
          );
          results.push(...legacyResults);
        }
        return results;
      }
      /**
       * Get repository status
       * @returns Repository status information
       */
      async getRepositoryStatus() {
        try {
          const { GitRepositoryAnalyzer } = await import("./git-repository-analyzer-QFMW6WIS.mjs");
          const analyzer = new GitRepositoryAnalyzer(this.workingDirectory);
          const info = await analyzer.analyzeRepository();
          return {
            isGitRepository: info.isGitRepository,
            branch: info.head,
            // Use head as branch name
            hasChanges: info.isGitRepository && (info.files?.length > 0 || false),
            filesChanged: info.isGitRepository ? info.files?.length || 0 : 0
          };
        } catch {
          return {
            isGitRepository: false,
            hasChanges: false
          };
        }
      }
      /**
       * Check if current directory is a git repository
       * @returns True if git repository, false otherwise
       */
      async isGitRepository() {
        const status = await this.getRepositoryStatus();
        return status.isGitRepository;
      }
      /**
       * Get list of available check types
       * @returns Array of check type names
       */
      static getAvailableCheckTypes() {
        const { CheckProviderRegistry: CheckProviderRegistry2 } = (init_check_provider_registry(), __toCommonJS(check_provider_registry_exports));
        const registry = CheckProviderRegistry2.getInstance();
        return registry.getAvailableProviders();
      }
      /**
       * Validate check types and return valid/invalid lists
       * @param checks - Array of check type names to validate
       * @returns Object with valid and invalid check types
       */
      static validateCheckTypes(checks) {
        const availableTypes = _StateMachineExecutionEngine.getAvailableCheckTypes();
        const valid = [];
        const invalid = [];
        for (const check of checks) {
          if (availableTypes.includes(check)) {
            valid.push(check);
          } else {
            invalid.push(check);
          }
        }
        return { valid, invalid };
      }
      /**
       * Format the status column for execution statistics
       * Used by execution-statistics-formatting tests
       */
      formatStatusColumn(stats) {
        if (stats.skipped) {
          if (stats.skipReason === "if_condition") {
            return "\u23ED if";
          } else if (stats.skipReason === "fail_fast") {
            return "\u23ED ff";
          } else if (stats.skipReason === "dependency_failed") {
            return "\u23ED dep";
          }
          return "\u23ED";
        }
        const totalRuns = stats.totalRuns;
        const successfulRuns = stats.successfulRuns;
        const failedRuns = stats.failedRuns;
        if (failedRuns > 0 && successfulRuns > 0) {
          return `\u2714/\u2716 ${successfulRuns}/${totalRuns}`;
        } else if (failedRuns > 0) {
          return totalRuns === 1 ? "\u2716" : `\u2716 \xD7${totalRuns}`;
        } else {
          return totalRuns === 1 ? "\u2714" : `\u2714 \xD7${totalRuns}`;
        }
      }
      /**
       * Format the details column for execution statistics
       * Used by execution-statistics-formatting tests
       */
      formatDetailsColumn(stats) {
        const parts = [];
        if (stats.outputsProduced !== void 0 && stats.outputsProduced > 0) {
          parts.push(`\u2192${stats.outputsProduced}`);
        }
        if (stats.issuesBySeverity.critical > 0) {
          parts.push(`${stats.issuesBySeverity.critical}\u{1F534}`);
        }
        if (stats.issuesBySeverity.error > 0 && stats.issuesBySeverity.critical === 0) {
          parts.push(`${stats.issuesBySeverity.error}\u274C`);
        }
        if (stats.issuesBySeverity.warning > 0) {
          parts.push(`${stats.issuesBySeverity.warning}\u26A0\uFE0F`);
        }
        if (stats.issuesBySeverity.info > 0 && stats.issuesBySeverity.critical === 0 && stats.issuesBySeverity.error === 0 && stats.issuesBySeverity.warning === 0) {
          parts.push(`${stats.issuesBySeverity.info}\u{1F4A1}`);
        }
        if (stats.errorMessage) {
          parts.push(this.truncate(stats.errorMessage, 40));
        }
        if (stats.skipCondition) {
          parts.push(this.truncate(stats.skipCondition, 40));
        }
        return parts.join(" ");
      }
      /**
       * Truncate a string to a maximum length
       * Used by formatDetailsColumn
       */
      truncate(str, maxLength) {
        if (str.length <= maxLength) {
          return str;
        }
        return str.substring(0, maxLength - 3) + "...";
      }
    };
  }
});

// src/scheduler/scheduler.ts
import cron from "node-cron";
var init_scheduler = __esm({
  "src/scheduler/scheduler.ts"() {
    "use strict";
    init_schedule_store();
    init_schedule_parser();
    init_logger();
    init_state_machine_execution_engine();
    init_prompt_state();
  }
});

// src/scheduler/cli-handler.ts
var init_cli_handler = __esm({
  "src/scheduler/cli-handler.ts"() {
    "use strict";
    init_schedule_store();
    init_scheduler();
    init_schedule_parser();
    init_logger();
    init_state_machine_execution_engine();
  }
});

// src/scheduler/index.ts
var init_scheduler2 = __esm({
  "src/scheduler/index.ts"() {
    "use strict";
    init_schedule_store();
    init_schedule_parser();
    init_scheduler();
    init_schedule_tool();
    init_cli_handler();
  }
});

// src/slack/schedule-tool-handler.ts
function getChannelType(channelId) {
  if (channelId.startsWith("D")) {
    return "dm";
  } else if (channelId.startsWith("G")) {
    return "group";
  }
  return "channel";
}
function extractSlackContext(webhookData) {
  try {
    for (const payload of webhookData.values()) {
      const p = payload;
      if (!p || typeof p !== "object") continue;
      const event = p.event;
      const conversation = p.slack_conversation;
      if (event) {
        const userId = event.user || "";
        const channel = event.channel || "";
        const isInThread = event.thread_ts && event.thread_ts !== event.ts;
        const threadTs = isInThread ? event.thread_ts : void 0;
        if (userId && channel) {
          return {
            userId,
            channel,
            threadTs,
            userName: conversation?.current?.user,
            timezone: void 0,
            // Will be fetched on-demand
            channelType: getChannelType(channel)
          };
        }
      }
    }
  } catch {
  }
  return null;
}
var init_schedule_tool_handler = __esm({
  "src/slack/schedule-tool-handler.ts"() {
    "use strict";
    init_scheduler2();
    init_logger();
  }
});

// src/providers/mcp-custom-sse-server.ts
import http from "http";
import { EventEmitter } from "events";
var CustomToolsSSEServer;
var init_mcp_custom_sse_server = __esm({
  "src/providers/mcp-custom-sse-server.ts"() {
    "use strict";
    init_custom_tool_executor();
    init_logger();
    init_workflow_tool_executor();
    init_schedule_tool();
    init_schedule_tool_handler();
    CustomToolsSSEServer = class _CustomToolsSSEServer {
      server = null;
      port = 0;
      connections = /* @__PURE__ */ new Set();
      toolExecutor;
      sessionId;
      debug;
      eventBus;
      messageQueue = /* @__PURE__ */ new Map();
      tools;
      workflowContext;
      keepaliveInterval = null;
      activeToolCalls = 0;
      lastActivityAt = Date.now();
      static KEEPALIVE_INTERVAL_MS = 3e4;
      // 30 seconds
      constructor(tools, sessionId, debug = false, workflowContext) {
        this.sessionId = sessionId;
        this.debug = debug;
        this.eventBus = new EventEmitter();
        this.tools = tools;
        this.workflowContext = workflowContext;
        const toolsRecord = {};
        const workflowToolNames = [];
        for (const [name, tool] of tools.entries()) {
          if (!isWorkflowTool(tool)) {
            toolsRecord[name] = tool;
          } else {
            workflowToolNames.push(name);
          }
        }
        if (workflowToolNames.length > 0 && !workflowContext) {
          logger.warn(
            `[CustomToolsSSEServer:${sessionId}] ${workflowToolNames.length} workflow tool(s) registered but no workflowContext provided. Tools [${workflowToolNames.join(", ")}] will fail at runtime. Pass workflowContext to enable workflow tool execution.`
          );
        }
        this.toolExecutor = new CustomToolExecutor(toolsRecord);
        if (this.debug) {
          const workflowToolCount = workflowToolNames.length;
          const regularToolCount = tools.size - workflowToolCount;
          logger.debug(
            `[CustomToolsSSEServer:${sessionId}] Initialized with ${regularToolCount} regular tools and ${workflowToolCount} workflow tools`
          );
        }
      }
      /**
       * Start the SSE server on an ephemeral port
       * Returns the actual bound port number
       */
      async start() {
        return new Promise((resolve5, reject) => {
          try {
            this.server = http.createServer((req, res) => {
              this.handleRequest(req, res).catch((error) => {
                logger.error(
                  `[CustomToolsSSEServer:${this.sessionId}] Request handler error: ${error}`
                );
              });
            });
            this.server.on("error", (error) => {
              if (error.code === "EADDRINUSE") {
                if (this.debug) {
                  logger.debug(
                    `[CustomToolsSSEServer:${this.sessionId}] Port ${this.port} in use, retrying with new port`
                  );
                }
                reject(new Error(`Port ${this.port} already in use`));
              } else {
                reject(error);
              }
            });
            this.server.listen(0, "localhost", () => {
              const address = this.server.address();
              if (!address || typeof address === "string") {
                reject(new Error("Failed to bind to port"));
                return;
              }
              this.port = address.port;
              if (this.debug) {
                logger.debug(
                  `[CustomToolsSSEServer:${this.sessionId}] Started on http://localhost:${this.port}/sse`
                );
              }
              this.startKeepalive();
              resolve5(this.port);
            });
          } catch (error) {
            reject(error);
          }
        });
      }
      /**
       * Start sending periodic keepalive pings to all connections
       * This prevents the SSE connection from being closed during long idle periods
       */
      startKeepalive() {
        if (this.keepaliveInterval) {
          return;
        }
        this.keepaliveInterval = setInterval(() => {
          if (this.connections.size === 0) {
            return;
          }
          for (const connection of this.connections) {
            try {
              connection.response.write(`: keepalive ${Date.now()}

`);
            } catch (error) {
              if (this.debug) {
                logger.debug(
                  `[CustomToolsSSEServer:${this.sessionId}] Keepalive failed for ${connection.id}: ${error}`
                );
              }
            }
          }
          if (this.debug) {
            logger.debug(
              `[CustomToolsSSEServer:${this.sessionId}] Sent keepalive to ${this.connections.size} connection(s)`
            );
          }
        }, _CustomToolsSSEServer.KEEPALIVE_INTERVAL_MS);
      }
      /**
       * Stop the keepalive interval
       */
      stopKeepalive() {
        if (this.keepaliveInterval) {
          clearInterval(this.keepaliveInterval);
          this.keepaliveInterval = null;
        }
      }
      /**
       * Stop the server and cleanup resources
       */
      async stop(options) {
        const graceMs = this.getEnvNumber("VISOR_CUSTOM_TOOLS_GRACE_MS", 0);
        const drainTimeoutMs = this.getEnvNumber("VISOR_CUSTOM_TOOLS_DRAIN_TIMEOUT_MS", 6e4);
        const effectiveGraceMs = options?.graceMs ?? graceMs;
        const effectiveDrainTimeoutMs = options?.drainTimeoutMs ?? drainTimeoutMs;
        if (effectiveGraceMs > 0) {
          const sinceLastActivity = Date.now() - this.lastActivityAt;
          const waitMs = Math.max(0, effectiveGraceMs - sinceLastActivity);
          if (waitMs > 0) {
            logger.debug(
              `[CustomToolsSSEServer:${this.sessionId}] Grace period before stop: ${waitMs}ms (activeToolCalls=${this.activeToolCalls})`
            );
            await new Promise((resolve5) => setTimeout(resolve5, waitMs));
          }
        }
        if (this.activeToolCalls > 0) {
          const startedAt = Date.now();
          logger.debug(
            `[CustomToolsSSEServer:${this.sessionId}] Waiting for ${this.activeToolCalls} active tool call(s) before stop`
          );
          while (this.activeToolCalls > 0 && Date.now() - startedAt < effectiveDrainTimeoutMs) {
            await new Promise((resolve5) => setTimeout(resolve5, 250));
          }
          if (this.activeToolCalls > 0) {
            logger.warn(
              `[CustomToolsSSEServer:${this.sessionId}] Drain timeout reached; stopping with ${this.activeToolCalls} active tool call(s)`
            );
          }
        }
        if (this.debug) {
          logger.debug(`[CustomToolsSSEServer:${this.sessionId}] Stopping server...`);
        }
        this.stopKeepalive();
        for (const connection of this.connections) {
          try {
            connection.response.end();
          } catch (error) {
            if (this.debug) {
              logger.debug(
                `[CustomToolsSSEServer:${this.sessionId}] Error closing connection: ${error}`
              );
            }
          }
        }
        this.connections.clear();
        if (this.server) {
          await new Promise((resolve5, reject) => {
            const timeout = setTimeout(() => {
              if (this.debug) {
                logger.debug(
                  `[CustomToolsSSEServer:${this.sessionId}] Force closing server after timeout`
                );
              }
              this.server?.close(() => resolve5());
            }, 5e3);
            this.server.close((error) => {
              clearTimeout(timeout);
              if (error) {
                reject(error);
              } else {
                resolve5();
              }
            });
          });
          this.server = null;
        }
        if (this.debug) {
          logger.debug(`[CustomToolsSSEServer:${this.sessionId}] Server stopped`);
        }
      }
      /**
       * Get the SSE endpoint URL
       */
      getUrl() {
        if (!this.port) {
          throw new Error("Server not started");
        }
        return `http://localhost:${this.port}/sse`;
      }
      /**
       * Handle incoming HTTP requests
       */
      async handleRequest(req, res) {
        const url = new URL(req.url || "/", `http://localhost:${this.port}`);
        if (this.debug) {
          logger.debug(
            `[CustomToolsSSEServer:${this.sessionId}] HTTP ${req.method} ${url.pathname} (connections=${this.connections.size})`
          );
        }
        if (req.method === "OPTIONS") {
          this.handleCORS(res);
          res.writeHead(204);
          res.end();
          return;
        }
        if (req.method === "GET" && url.pathname === "/sse") {
          this.handleSSEConnection(req, res);
          return;
        }
        if (req.method === "POST" && url.pathname === "/sse") {
          await this.handleLegacySSEPost(req, res);
          return;
        }
        if (req.method === "POST" && url.pathname === "/message") {
          await this.handleMessage(req, res);
          return;
        }
        res.writeHead(404, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ error: "Not found" }));
      }
      /**
       * Handle legacy POST /sse pattern (connection + message in one request)
       * This maintains backward compatibility with tests
       */
      async handleLegacySSEPost(req, res) {
        this.handleCORS(res);
        res.writeHead(200, {
          "Content-Type": "text/event-stream",
          "Cache-Control": "no-cache",
          Connection: "keep-alive"
        });
        const connectionId = `conn-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
        const connection = {
          response: res,
          id: connectionId
        };
        this.connections.add(connection);
        if (this.debug) {
          logger.debug(
            `[CustomToolsSSEServer:${this.sessionId}] Legacy SSE POST connection: ${connectionId} (connections=${this.connections.size})`
          );
        }
        let body = "";
        req.on("data", (chunk) => {
          body += chunk.toString();
        });
        req.on("end", async () => {
          try {
            if (body.trim()) {
              const message = JSON.parse(body);
              await this.handleMCPMessage(connection, message);
            }
          } catch (error) {
            const errorMsg = error instanceof Error ? error.message : "Unknown error";
            if (this.debug) {
              logger.error(
                `[CustomToolsSSEServer:${this.sessionId}] Error in legacy SSE POST: ${errorMsg}`
              );
            }
            this.sendErrorResponse(connection, null, -32700, "Parse error", { error: errorMsg });
          }
        });
        req.on("close", () => {
          this.connections.delete(connection);
          if (this.debug) {
            logger.debug(
              `[CustomToolsSSEServer:${this.sessionId}] Legacy SSE POST connection closed: ${connectionId} (connections=${this.connections.size})`
            );
          }
        });
      }
      /**
       * Handle SSE connection establishment (GET /sse)
       */
      handleSSEConnection(req, res) {
        this.handleCORS(res);
        res.writeHead(200, {
          "Content-Type": "text/event-stream",
          "Cache-Control": "no-cache",
          Connection: "keep-alive"
        });
        const connectionId = `conn-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
        const connection = {
          response: res,
          id: connectionId
        };
        this.connections.add(connection);
        if (this.debug) {
          logger.debug(
            `[CustomToolsSSEServer:${this.sessionId}] New SSE connection: ${connectionId} (connections=${this.connections.size})`
          );
        }
        this.sendSSE(
          connection,
          "endpoint",
          `http://localhost:${this.port}/message?sessionId=${connectionId}`
        );
        req.on("close", () => {
          if (this.debug) {
            logger.debug(
              `[CustomToolsSSEServer:${this.sessionId}] Connection closed: ${connectionId} (connections=${this.connections.size})`
            );
          }
          this.connections.delete(connection);
        });
      }
      /**
       * Handle MCP message (POST /message)
       */
      async handleMessage(req, res) {
        const url = new URL(req.url || "/", `http://localhost:${this.port}`);
        const sessionId = url.searchParams.get("sessionId");
        let connection;
        for (const conn of this.connections) {
          if (conn.id === sessionId) {
            connection = conn;
            break;
          }
        }
        if (!connection) {
          connection = this.connections.values().next().value;
        }
        if (!connection) {
          res.writeHead(400, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ error: "No active SSE connection" }));
          if (this.debug) {
            logger.debug(
              `[CustomToolsSSEServer:${this.sessionId}] No active SSE connection for sessionId=${sessionId}`
            );
          }
          return;
        }
        let body = "";
        req.on("data", (chunk) => {
          body += chunk.toString();
        });
        req.on("end", async () => {
          try {
            const message = JSON.parse(body);
            if (this.debug) {
              logger.debug(
                `[CustomToolsSSEServer:${this.sessionId}] Received message: ${JSON.stringify(message)}`
              );
            }
            await this.handleMCPMessage(connection, message);
            this.handleCORS(res);
            res.writeHead(202, { "Content-Type": "application/json" });
            res.end(JSON.stringify({ status: "accepted" }));
          } catch (error) {
            const errorMsg = error instanceof Error ? error.message : "Unknown error";
            if (this.debug) {
              logger.error(
                `[CustomToolsSSEServer:${this.sessionId}] Error parsing message: ${errorMsg}`
              );
            }
            this.sendErrorResponse(connection, null, -32700, "Parse error", { error: errorMsg });
            res.writeHead(400, { "Content-Type": "application/json" });
            res.end(JSON.stringify({ error: "Parse error", details: errorMsg }));
          }
        });
      }
      /**
       * Handle CORS headers
       */
      handleCORS(res) {
        res.setHeader("Access-Control-Allow-Origin", "*");
        res.setHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
        res.setHeader("Access-Control-Allow-Headers", "Content-Type");
      }
      /**
       * Send SSE message to client
       */
      sendSSE(connection, event, data) {
        try {
          const dataStr = typeof data === "string" ? data : JSON.stringify(data);
          const preview = dataStr.length > 300 ? `${dataStr.substring(0, 150)}...${dataStr.substring(dataStr.length - 150)}` : dataStr;
          logger.debug(
            `[CustomToolsSSEServer:${this.sessionId}] Sending SSE event='${event}' size=${dataStr.length} preview=${preview}`
          );
          connection.response.write(`event: ${event}
`);
          connection.response.write(`data: ${dataStr}

`);
          logger.debug(
            `[CustomToolsSSEServer:${this.sessionId}] SSE message sent successfully, event='${event}'`
          );
        } catch (error) {
          logger.error(`[CustomToolsSSEServer:${this.sessionId}] Error sending SSE: ${error}`);
        }
      }
      /**
       * Handle MCP protocol messages
       */
      async handleMCPMessage(connection, message) {
        if (this.debug) {
          logger.debug(
            `[CustomToolsSSEServer:${this.sessionId}] Received MCP message: ${JSON.stringify(message)}`
          );
        }
        this.lastActivityAt = Date.now();
        if (message.method === "tools/list") {
          const response = await this.handleToolsList(message.id);
          this.sendSSE(connection, "message", response);
          return;
        }
        if (message.method === "tools/call") {
          const request = message;
          const argsPreview = JSON.stringify(request.params.arguments).substring(0, 200);
          logger.info(
            `[CustomToolsSSEServer:${this.sessionId}] Received tools/call for '${request.params.name}' id=${request.id} args=${argsPreview}`
          );
          const response = await this.handleToolCall(
            request.id,
            request.params.name,
            request.params.arguments
          );
          logger.info(
            `[CustomToolsSSEServer:${this.sessionId}] Sending response for '${request.params.name}' id=${request.id} hasError=${!!response.error}`
          );
          this.sendSSE(connection, "message", response);
          return;
        }
        if (message.method === "initialize") {
          const response = {
            jsonrpc: "2.0",
            id: message.id,
            result: {
              protocolVersion: "2024-11-05",
              capabilities: {
                tools: {}
              },
              serverInfo: {
                name: "visor-custom-tools",
                version: "1.0.0"
              }
            }
          };
          this.sendSSE(connection, "message", response);
          return;
        }
        if (message.method === "notifications/initialized") {
          return;
        }
        this.sendErrorResponse(connection, message.id, -32601, "Method not found");
      }
      /**
       * Handle tools/list MCP request
       */
      async handleToolsList(id) {
        const allTools = Array.from(this.tools.values());
        if (this.debug) {
          logger.debug(
            `[CustomToolsSSEServer:${this.sessionId}] Listing ${allTools.length} tools: ${allTools.map((t) => t.name).join(", ")}`
          );
        }
        return {
          jsonrpc: "2.0",
          id,
          result: {
            tools: allTools.map((tool) => ({
              name: tool.name,
              description: tool.description || `Execute ${tool.name}`,
              inputSchema: tool.inputSchema || {
                type: "object",
                properties: {},
                required: []
              }
            }))
          }
        };
      }
      /**
       * Handle tools/call MCP request
       */
      async handleToolCall(id, toolName, args) {
        const workspace = this.workflowContext?.workspace;
        if (workspace) {
          workspace.acquire();
        }
        this.activeToolCalls++;
        this.lastActivityAt = Date.now();
        try {
          if (this.debug) {
            logger.debug(
              `[CustomToolsSSEServer:${this.sessionId}] Executing tool: ${toolName} with args: ${JSON.stringify(args)}`
            );
          }
          const retryCount = this.getEnvNumber("VISOR_CUSTOM_TOOLS_RETRY_COUNT", 0);
          const retryDelayMs = this.getEnvNumber("VISOR_CUSTOM_TOOLS_RETRY_DELAY_MS", 1e3);
          let attempt = 0;
          let result;
          while (true) {
            try {
              if (isScheduleTool(toolName)) {
                const webhookData = this.workflowContext?.executionContext?.webhookContext?.webhookData;
                const slackContext = webhookData ? extractSlackContext(webhookData) : null;
                const visorCfg = this.workflowContext?.visorConfig;
                const availableWorkflows = visorCfg?.checks ? Object.keys(visorCfg.checks) : void 0;
                const schedulerPermissions = visorCfg?.scheduler?.permissions;
                const permissions = schedulerPermissions ? {
                  allowPersonal: schedulerPermissions.allow_personal,
                  allowChannel: schedulerPermissions.allow_channel,
                  allowDm: schedulerPermissions.allow_dm,
                  allowedWorkflows: schedulerPermissions.allowed_workflows,
                  deniedWorkflows: schedulerPermissions.denied_workflows
                } : void 0;
                const scheduleContext = buildScheduleToolContext(
                  {
                    slackContext: slackContext ? {
                      userId: slackContext.userId,
                      userName: slackContext.userName,
                      timezone: slackContext.timezone,
                      channelType: slackContext.channelType
                    } : void 0
                  },
                  availableWorkflows,
                  permissions,
                  {
                    outputType: args.output_type,
                    outputTarget: args.output_target
                  }
                );
                if (this.debug) {
                  logger.debug(
                    `[CustomToolsSSEServer:${this.sessionId}] Executing schedule tool for user ${scheduleContext.userId} (${scheduleContext.contextType})`
                  );
                }
                const scheduleArgs = {
                  action: args.action || "list",
                  // What to do
                  reminder_text: args.reminder_text,
                  workflow: args.workflow,
                  workflow_inputs: args.workflow_inputs,
                  // Where to send
                  target_type: args.target_type,
                  target_id: args.target_id,
                  thread_ts: args.thread_ts,
                  // When to run
                  is_recurring: args.is_recurring,
                  cron: args.cron,
                  run_at: args.run_at,
                  original_expression: args.original_expression,
                  // For cancel/pause/resume
                  schedule_id: args.schedule_id
                };
                const scheduleResult = await handleScheduleAction(scheduleArgs, scheduleContext);
                result = scheduleResult.success ? scheduleResult.message : `Error: ${scheduleResult.error}`;
                break;
              }
              const tool = this.tools.get(toolName);
              if (tool && isWorkflowTool(tool)) {
                if (!this.workflowContext) {
                  throw new Error(
                    `Workflow tool '${toolName}' requires workflow context but none was provided`
                  );
                }
                if (this.debug) {
                  logger.debug(
                    `[CustomToolsSSEServer:${this.sessionId}] Executing workflow tool: ${toolName}`
                  );
                }
                const workflowTool = tool;
                result = await executeWorkflowAsTool(
                  workflowTool.__workflowId,
                  args,
                  this.workflowContext,
                  workflowTool.__argsOverrides
                );
              } else {
                result = await this.toolExecutor.execute(toolName, args);
              }
              break;
            } catch (error) {
              const errorMsg = error instanceof Error ? error.message : "Unknown error";
              if (attempt >= retryCount) {
                throw error;
              }
              const delay = Math.min(retryDelayMs * Math.pow(2, attempt), 3e4);
              logger.warn(
                `[CustomToolsSSEServer:${this.sessionId}] Tool ${toolName} failed (attempt ${attempt + 1}/${retryCount + 1}): ${errorMsg}. Retrying in ${delay}ms`
              );
              await new Promise((resolve5) => setTimeout(resolve5, delay));
              attempt++;
            }
          }
          const resultText = typeof result === "string" ? result : JSON.stringify(result, null, 2);
          const resultPreview = resultText.length > 500 ? `${resultText.substring(0, 250)}...TRUNCATED(${resultText.length} chars)...${resultText.substring(resultText.length - 250)}` : resultText;
          logger.info(
            `[CustomToolsSSEServer:${this.sessionId}] Tool ${toolName} completed. Result size: ${resultText.length} chars`
          );
          logger.debug(
            `[CustomToolsSSEServer:${this.sessionId}] Tool ${toolName} result preview: ${resultPreview}`
          );
          const response = {
            jsonrpc: "2.0",
            id,
            result: {
              content: [
                {
                  type: "text",
                  text: resultText
                }
              ]
            }
          };
          logger.debug(
            `[CustomToolsSSEServer:${this.sessionId}] Returning MCP response for ${toolName}, id=${id}, content_length=${resultText.length}`
          );
          return response;
        } catch (error) {
          const errorMsg = error instanceof Error ? error.message : "Unknown error";
          logger.error(
            `[CustomToolsSSEServer:${this.sessionId}] Tool execution failed: ${toolName} - ${errorMsg}`
          );
          return {
            jsonrpc: "2.0",
            id,
            error: {
              code: -32603,
              message: "Internal error",
              data: {
                tool: toolName,
                error: errorMsg
              }
            }
          };
        } finally {
          this.activeToolCalls = Math.max(0, this.activeToolCalls - 1);
          this.lastActivityAt = Date.now();
          if (workspace) {
            workspace.release();
          }
        }
      }
      getEnvNumber(name, fallback) {
        const raw = process.env[name];
        if (!raw) return fallback;
        const parsed = parseInt(raw, 10);
        return Number.isFinite(parsed) ? parsed : fallback;
      }
      /**
       * Send error response via SSE
       */
      sendErrorResponse(connection, id, code, message, data) {
        const errorResponse = {
          jsonrpc: "2.0",
          id: id ?? "error",
          error: {
            code,
            message,
            data
          }
        };
        this.sendSSE(connection, "message", errorResponse);
      }
    };
  }
});

// src/providers/ai-check-provider.ts
import fs5 from "fs/promises";
import path7 from "path";
var AICheckProvider;
var init_ai_check_provider = __esm({
  "src/providers/ai-check-provider.ts"() {
    "use strict";
    init_check_provider_interface();
    init_ai_review_service();
    init_env_resolver();
    init_issue_filter();
    init_liquid_extensions();
    init_lazy_otel();
    init_state_capture();
    init_mcp_custom_sse_server();
    init_logger();
    init_workflow_tool_executor();
    init_sandbox();
    init_schedule_tool();
    init_schedule_tool_handler();
    AICheckProvider = class extends CheckProvider {
      aiReviewService;
      liquidEngine;
      sandbox = null;
      constructor() {
        super();
        this.aiReviewService = new AIReviewService();
        this.liquidEngine = createExtendedLiquid();
      }
      getName() {
        return "ai";
      }
      getDescription() {
        return "AI-powered code review using Google Gemini, Anthropic Claude, OpenAI GPT, or AWS Bedrock models";
      }
      /** Lightweight debug helper to avoid importing logger here */
      logDebug(msg) {
        try {
          if (process.env.VISOR_DEBUG === "true") {
            console.debug(msg);
          }
        } catch {
        }
      }
      /** Detect Slack webhook payload and build a lightweight slack context for templates */
      buildSlackEventContext(context2, config, prInfo) {
        try {
          const aiCfg = config?.ai || {};
          if (aiCfg.skip_slack_context === true) return {};
          const webhook = context2?.webhookContext;
          const map = webhook?.webhookData;
          if (!map || !(map instanceof Map)) return {};
          const first = Array.from(map.values())[0];
          if (!first || typeof first !== "object") return {};
          const ev = first.event;
          const conv = first.slack_conversation;
          if (!ev && !conv) return {};
          if (conv && prInfo) {
            try {
              prInfo.slackConversation = conv;
            } catch {
            }
          }
          return { slack: { event: ev, conversation: conv } };
        } catch {
          return {};
        }
      }
      async validateConfig(config) {
        if (!config || typeof config !== "object") {
          return false;
        }
        const cfg = config;
        if (cfg.type !== "ai") {
          return false;
        }
        const prompt = cfg.prompt || cfg.focus;
        if (typeof prompt !== "string") {
          return false;
        }
        if (cfg.ai) {
          if (cfg.ai.provider && !["google", "anthropic", "openai", "bedrock", "mock"].includes(cfg.ai.provider)) {
            return false;
          }
          if (cfg.ai.mcpServers) {
            if (!this.validateMcpServers(cfg.ai.mcpServers)) {
              return false;
            }
          }
        }
        const checkLevelMcpServers = cfg.ai_mcp_servers;
        if (checkLevelMcpServers) {
          if (!this.validateMcpServers(checkLevelMcpServers)) {
            return false;
          }
        }
        return true;
      }
      /**
       * Validate MCP servers configuration
       */
      validateMcpServers(mcpServers) {
        if (typeof mcpServers !== "object" || mcpServers === null) {
          return false;
        }
        for (const serverConfig of Object.values(mcpServers)) {
          if (!serverConfig || typeof serverConfig !== "object") {
            return false;
          }
          const config = serverConfig;
          if (typeof config.command !== "string") {
            return false;
          }
          if (config.args !== void 0 && !Array.isArray(config.args)) {
            return false;
          }
        }
        return true;
      }
      /**
       * Group files by their file extension for template context
       */
      groupFilesByExtension(files) {
        const grouped = {};
        files.forEach((file) => {
          const parts = file.filename.split(".");
          const ext = parts.length > 1 ? parts.pop()?.toLowerCase() || "noext" : "noext";
          if (!grouped[ext]) {
            grouped[ext] = [];
          }
          grouped[ext].push(file);
        });
        return grouped;
      }
      /**
       * Process prompt configuration to resolve final prompt string
       */
      async processPrompt(promptConfig, prInfo, eventContext, dependencyResults, outputHistory, args, workflowInputs) {
        let promptContent;
        if (await this.isFilePath(promptConfig)) {
          promptContent = await this.loadPromptFromFile(promptConfig);
        } else {
          promptContent = promptConfig;
        }
        return await this.renderPromptTemplate(
          promptContent,
          prInfo,
          eventContext,
          dependencyResults,
          outputHistory,
          args,
          workflowInputs
        );
      }
      /**
       * Detect if a string is likely a file path and if the file exists
       */
      async isFilePath(str) {
        if (!str || str.trim() !== str || str.length > 512) {
          return false;
        }
        if (/\s{2,}/.test(str) || // Multiple consecutive spaces
        /\n/.test(str) || // Contains newlines
        /^(please|analyze|review|check|find|identify|look|search)/i.test(str.trim()) || // Starts with command words
        str.split(" ").length > 8) {
          return false;
        }
        if (!/[\/\\]/.test(str)) {
          if (/\b(the|and|or|but|for|with|by|from|in|on|at|as)\b/i.test(str)) {
            return false;
          }
        }
        const hasFileExtension = /\.[a-zA-Z0-9]{1,10}$/i.test(str);
        const hasPathSeparators = /[\/\\]/.test(str);
        const isRelativePath = /^\.{1,2}\//.test(str);
        const isAbsolutePath = path7.isAbsolute(str);
        const hasTypicalFileChars = /^[a-zA-Z0-9._\-\/\\:~]+$/.test(str);
        if (!(hasFileExtension || isRelativePath || isAbsolutePath || hasPathSeparators)) {
          return false;
        }
        if (!hasTypicalFileChars) {
          return false;
        }
        try {
          let resolvedPath;
          if (path7.isAbsolute(str)) {
            resolvedPath = path7.normalize(str);
          } else {
            resolvedPath = path7.resolve(process.cwd(), str);
          }
          const fs10 = __require("fs").promises;
          try {
            const stat = await fs10.stat(resolvedPath);
            return stat.isFile();
          } catch {
            return hasFileExtension && (isRelativePath || isAbsolutePath || hasPathSeparators);
          }
        } catch {
          return false;
        }
      }
      /**
       * Load prompt content from file with security validation
       */
      async loadPromptFromFile(promptPath) {
        if (!promptPath.endsWith(".liquid")) {
          throw new Error("Prompt file must have .liquid extension");
        }
        let resolvedPath;
        if (path7.isAbsolute(promptPath)) {
          resolvedPath = promptPath;
        } else {
          resolvedPath = path7.resolve(process.cwd(), promptPath);
        }
        if (!path7.isAbsolute(promptPath)) {
          const normalizedPath = path7.normalize(resolvedPath);
          const currentDir = path7.resolve(process.cwd());
          if (!normalizedPath.startsWith(currentDir)) {
            throw new Error("Invalid prompt file path: path traversal detected");
          }
        }
        if (promptPath.includes("../..")) {
          throw new Error("Invalid prompt file path: path traversal detected");
        }
        try {
          const promptContent = await fs5.readFile(resolvedPath, "utf-8");
          return promptContent;
        } catch (error) {
          throw new Error(
            `Failed to load prompt from ${resolvedPath}: ${error instanceof Error ? error.message : "Unknown error"}`
          );
        }
      }
      /**
       * Render Liquid template in prompt with comprehensive event context
       */
      async renderPromptTemplate(promptContent, prInfo, eventContext, dependencyResults, outputHistory, args, workflowInputs) {
        const outputsRaw = {};
        if (dependencyResults) {
          for (const [k, v] of dependencyResults.entries()) {
            if (typeof k !== "string") continue;
            if (k.endsWith("-raw")) {
              const name = k.slice(0, -4);
              const summary = v;
              outputsRaw[name] = summary.output !== void 0 ? summary.output : summary;
            }
          }
        }
        const templateContext = {
          // PR Information
          pr: {
            number: prInfo.number,
            title: prInfo.title,
            body: prInfo.body,
            author: prInfo.author,
            baseBranch: prInfo.base,
            headBranch: prInfo.head,
            isIncremental: prInfo.isIncremental,
            filesChanged: prInfo.files?.map((f) => f.filename) || [],
            totalAdditions: prInfo.files?.reduce((sum, f) => sum + f.additions, 0) || 0,
            totalDeletions: prInfo.files?.reduce((sum, f) => sum + f.deletions, 0) || 0,
            totalChanges: prInfo.files?.reduce((sum, f) => sum + f.changes, 0) || 0,
            base: prInfo.base,
            head: prInfo.head
          },
          // File Details
          files: prInfo.files || [],
          description: prInfo.body || "",
          // GitHub / webhook Event Context
          event: eventContext ? {
            name: eventContext.event_name || "unknown",
            action: eventContext.action,
            isPullRequest: !prInfo.isIssue,
            // Set based on whether this is a PR or an issue
            // Repository Info
            repository: eventContext.repository ? {
              owner: eventContext.repository?.owner?.login,
              name: eventContext.repository?.name,
              fullName: eventContext.repository ? `${eventContext.repository?.owner?.login}/${eventContext.repository?.name}` : void 0
            } : void 0,
            // Comment Data (for comment events)
            comment: eventContext.comment ? {
              body: eventContext.comment?.body,
              author: eventContext.comment?.user?.login
            } : void 0,
            // Issue Data (for issue events)
            issue: eventContext.issue ? {
              number: eventContext.issue?.number,
              title: eventContext.issue?.title,
              body: eventContext.issue?.body,
              state: eventContext.issue?.state,
              author: eventContext.issue?.user?.login,
              labels: eventContext.issue?.labels || [],
              assignees: eventContext?.issue?.assignees?.map((a) => a.login) || [],
              createdAt: eventContext.issue?.created_at,
              updatedAt: eventContext.issue?.updated_at,
              isPullRequest: !!eventContext.issue?.pull_request
            } : void 0,
            // Pull Request Event Data
            pullRequest: eventContext.pull_request ? {
              number: eventContext.pull_request?.number,
              state: eventContext.pull_request?.state,
              draft: eventContext.pull_request?.draft,
              headSha: eventContext.pull_request?.head?.sha,
              headRef: eventContext.pull_request?.head?.ref,
              baseSha: eventContext.pull_request?.base?.sha,
              baseRef: eventContext.pull_request?.base?.ref
            } : void 0,
            // Raw event payload for advanced use cases
            payload: eventContext
          } : void 0,
          // Slack conversation context (if provided via eventContext.slack)
          slack: (() => {
            try {
              const anyCtx = eventContext;
              const slack = anyCtx?.slack;
              if (slack && typeof slack === "object") return slack;
            } catch {
            }
            return void 0;
          })(),
          // Unified conversation context across transports (Slack & GitHub)
          conversation: (() => {
            try {
              const anyCtx = eventContext;
              if (anyCtx?.slack?.conversation) return anyCtx.slack.conversation;
              if (anyCtx?.github?.conversation) return anyCtx.github.conversation;
              if (anyCtx?.conversation) return anyCtx.conversation;
            } catch {
            }
            return void 0;
          })(),
          // Utility data for templates
          utils: {
            // Date/time helpers
            now: (/* @__PURE__ */ new Date()).toISOString(),
            today: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
            // Dynamic file grouping by extension
            filesByExtension: this.groupFilesByExtension(prInfo.files || []),
            // File status categorizations
            addedFiles: (prInfo.files || []).filter((f) => f.status === "added"),
            modifiedFiles: (prInfo.files || []).filter((f) => f.status === "modified"),
            removedFiles: (prInfo.files || []).filter((f) => f.status === "removed"),
            renamedFiles: (prInfo.files || []).filter((f) => f.status === "renamed"),
            // Change analysis
            hasLargeChanges: (prInfo.files || []).some((f) => f.changes > 50),
            totalFiles: (prInfo.files || []).length
          },
          // Checks metadata for helpers like chat_history
          checks_meta: (() => {
            try {
              return eventContext?.__checksMeta || void 0;
            } catch {
              return void 0;
            }
          })(),
          // Previous check outputs (dependency results)
          // Expose raw output directly if available, otherwise expose the result as-is
          outputs: dependencyResults ? Object.fromEntries(
            Array.from(dependencyResults.entries()).map(([checkName, result]) => [
              checkName,
              (() => {
                const summary = result;
                return summary.output !== void 0 ? summary.output : summary;
              })()
            ])
          ) : {},
          // Alias for consistency with other providers
          outputs_history: (() => {
            const hist = {};
            if (outputHistory) {
              for (const [k, v] of outputHistory.entries()) hist[k] = v;
            }
            return hist;
          })(),
          // Stage-scoped history slice calculated from baseline captured by the flow runner.
          outputs_history_stage: (() => {
            const stage = {};
            try {
              const base = eventContext?.__stageHistoryBase;
              if (!outputHistory || !base) return stage;
              for (const [k, v] of outputHistory.entries()) {
                const start = base[k] || 0;
                const arr = Array.isArray(v) ? v : [];
                stage[k] = arr.slice(start);
              }
            } catch {
            }
            return stage;
          })(),
          // New: outputs_raw exposes aggregate values (e.g., full arrays for forEach parents)
          outputs_raw: outputsRaw,
          // Custom arguments from on_init 'with' directive
          args: args || {},
          // Workflow inputs (for nested workflow steps to access parent inputs like {{ inputs.context }})
          inputs: workflowInputs || {}
        };
        try {
          if (process.env.VISOR_DEBUG === "true") {
            const outKeys = Object.keys(templateContext.outputs || {}).join(", ");
            const histKeys = Object.keys(templateContext.outputs_history || {}).join(", ");
            const inputsKeys = Object.keys(templateContext.inputs || {}).join(", ");
            console.error(
              `[prompt-ctx] outputs.keys=${outKeys} hist.keys=${histKeys} inputs.keys=${inputsKeys}`
            );
            const projects = templateContext.inputs?.projects;
            if (projects) {
              console.error(
                `[prompt-ctx] inputs.projects has ${Array.isArray(projects) ? projects.length : "N/A"} items`
              );
            }
          }
        } catch {
        }
        try {
          return await this.liquidEngine.parseAndRender(promptContent, templateContext);
        } catch (error) {
          const err = error || {};
          const lines = String(promptContent || "").split(/\r?\n/);
          const lineNum = Number(err.line || err?.token?.line || err?.location?.line || 0);
          const colNum = Number(err.col || err?.token?.col || err?.location?.col || 0);
          let snippet = "";
          if (lineNum > 0) {
            const start = Math.max(1, lineNum - 3);
            const end = Math.max(lineNum + 2, lineNum);
            const width = String(end).length;
            for (let i = start; i <= Math.min(end, lines.length); i++) {
              const ln = `${String(i).padStart(width, " ")} | ${lines[i - 1] ?? ""}`;
              snippet += ln + "\n";
              if (i === lineNum) {
                const caretPad = " ".repeat(Math.max(0, colNum > 1 ? colNum - 1 : 0) + width + 3);
                snippet += caretPad + "^\n";
              }
            }
          } else {
            const preview = lines.slice(0, 20).map((l, i) => `${(i + 1).toString().padStart(3, " ")} | ${l}`).join("\n");
            snippet = preview + "\n";
          }
          const msg = `Failed to render prompt template: ${error instanceof Error ? error.message : "Unknown error"}`;
          try {
            console.error("\n[prompt-error] " + msg + "\n" + snippet);
          } catch {
          }
          throw new Error(msg);
        }
      }
      /**
       * Render Liquid templates in schema definitions
       * Supports dynamic enum values and other template-driven schema properties
       */
      async renderSchema(schema, prInfo, _eventContext, dependencyResults, outputHistory, args, workflowInputs) {
        if (!schema) return schema;
        let schemaStr;
        if (typeof schema === "string") {
          if (!schema.includes("{{") && !schema.includes("{%")) {
            return schema;
          }
          schemaStr = schema;
        } else {
          schemaStr = JSON.stringify(schema);
          if (!schemaStr.includes("{{") && !schemaStr.includes("{%")) {
            return schema;
          }
        }
        const outputsRaw = {};
        if (dependencyResults) {
          for (const [k, v] of dependencyResults.entries()) {
            if (typeof k !== "string") continue;
            if (k.endsWith("-raw")) {
              const name = k.slice(0, -4);
              const summary = v;
              outputsRaw[name] = summary.output !== void 0 ? summary.output : summary;
            }
          }
        }
        const templateContext = {
          pr: {
            number: prInfo.number,
            title: prInfo.title,
            body: prInfo.body,
            author: prInfo.author,
            baseBranch: prInfo.base,
            headBranch: prInfo.head,
            isIncremental: prInfo.isIncremental,
            filesChanged: prInfo.files?.map((f) => f.filename) || [],
            totalAdditions: prInfo.files?.reduce((sum, f) => sum + f.additions, 0) || 0,
            totalDeletions: prInfo.files?.reduce((sum, f) => sum + f.deletions, 0) || 0,
            totalChanges: prInfo.files?.reduce((sum, f) => sum + f.changes, 0) || 0,
            base: prInfo.base,
            head: prInfo.head
          },
          files: prInfo.files || [],
          description: prInfo.body || "",
          outputs: dependencyResults ? Object.fromEntries(
            Array.from(dependencyResults.entries()).map(([checkName, result]) => [
              checkName,
              (() => {
                const summary = result;
                return summary.output !== void 0 ? summary.output : summary;
              })()
            ])
          ) : {},
          outputs_history: (() => {
            const hist = {};
            if (outputHistory) {
              for (const [k, v] of outputHistory.entries()) hist[k] = v;
            }
            return hist;
          })(),
          outputs_raw: outputsRaw,
          args: args || {},
          inputs: workflowInputs || {}
        };
        try {
          if (process.env.VISOR_DEBUG === "true") {
            logger.debug(`[schema-render] Rendering schema with Liquid templates`);
            logger.debug(
              `[schema-render] inputs.projects count: ${Array.isArray(templateContext.inputs?.projects) ? templateContext.inputs.projects.length : "N/A"}`
            );
          }
          const renderedStr = await this.liquidEngine.parseAndRender(schemaStr, templateContext);
          try {
            const parsed = JSON.parse(renderedStr);
            if (process.env.VISOR_DEBUG === "true") {
              logger.debug(`[schema-render] Successfully rendered schema`);
            }
            return parsed;
          } catch (parseError) {
            const errorMsg = parseError instanceof Error ? parseError.message : String(parseError);
            const preview = renderedStr.length > 2e3 ? renderedStr.substring(0, 2e3) + "...[truncated]" : renderedStr;
            logger.error(`[schema-render] JSON_PARSE_ERROR: Failed to parse rendered schema as JSON`);
            logger.error(`[schema-render] Parse error: ${errorMsg}`);
            logger.error(`[schema-render] Original schema type: ${typeof schema}`);
            logger.error(`[schema-render] Rendered output (${renderedStr.length} chars):
${preview}`);
            throw new Error(
              `Schema template rendered invalid JSON: ${errorMsg}. Check Liquid template syntax. Rendered output starts with: "${renderedStr.substring(0, 100)}..."`
            );
          }
        } catch (error) {
          if (error instanceof Error && error.message.includes("Schema template rendered invalid JSON")) {
            throw error;
          }
          const errorMsg = error instanceof Error ? error.message : "Unknown error";
          logger.error(`[schema-render] LIQUID_RENDER_ERROR: Failed to render schema template`);
          logger.error(`[schema-render] Error: ${errorMsg}`);
          logger.error(
            `[schema-render] Original schema: ${schemaStr.substring(0, 500)}${schemaStr.length > 500 ? "...[truncated]" : ""}`
          );
          throw new Error(
            `Schema Liquid template error: ${errorMsg}. Check template syntax in schema definition.`
          );
        }
      }
      async execute(prInfo, config, _dependencyResults, sessionInfo) {
        if (config.env) {
          const result = EnvironmentResolver.withTemporaryEnv(config.env, () => {
            return this.executeWithConfig(prInfo, config, _dependencyResults, sessionInfo);
          });
          if (result instanceof Promise) {
            return result;
          }
          return result;
        }
        return this.executeWithConfig(prInfo, config, _dependencyResults, sessionInfo);
      }
      async executeWithConfig(prInfo, config, _dependencyResults, sessionInfo) {
        try {
          if (process.env.VISOR_DEBUG === "true") {
            console.error(`[ai-exec] step=${String(config.checkName || "unknown")}`);
          }
        } catch {
        }
        const aiConfig = {};
        if (config.ai) {
          const aiAny2 = config.ai;
          const skipTransport = aiAny2.skip_transport_context === true;
          if (aiAny2.apiKey !== void 0) {
            aiConfig.apiKey = aiAny2.apiKey;
          }
          if (aiAny2.model !== void 0) {
            aiConfig.model = aiAny2.model;
          }
          if (aiAny2.timeout !== void 0) {
            aiConfig.timeout = aiAny2.timeout;
          }
          if (aiAny2.max_iterations !== void 0 || aiAny2.maxIterations !== void 0) {
            const raw = aiAny2.max_iterations ?? aiAny2.maxIterations;
            aiConfig.maxIterations = Number(raw);
          }
          if (aiAny2.provider !== void 0) {
            aiConfig.provider = aiAny2.provider;
          }
          if (aiAny2.debug !== void 0) {
            aiConfig.debug = aiAny2.debug;
          }
          if (aiAny2.enableDelegate !== void 0) {
            aiConfig.enableDelegate = aiAny2.enableDelegate;
          }
          if (aiAny2.enableTasks !== void 0) {
            aiConfig.enableTasks = aiAny2.enableTasks;
          }
          if (aiAny2.allowEdit !== void 0) {
            aiConfig.allowEdit = aiAny2.allowEdit;
          }
          if (aiAny2.allowedTools !== void 0) {
            aiConfig.allowedTools = aiAny2.allowedTools;
            this.logDebug(
              `[AI Provider] Read allowedTools from YAML: ${JSON.stringify(aiAny2.allowedTools)}`
            );
          }
          if (aiAny2.disableTools !== void 0) {
            aiConfig.disableTools = aiAny2.disableTools;
            this.logDebug(`[AI Provider] Read disableTools from YAML: ${aiAny2.disableTools}`);
          }
          if (aiAny2.allowBash !== void 0) {
            aiConfig.allowBash = aiAny2.allowBash;
          }
          if (aiAny2.bashConfig !== void 0) {
            aiConfig.bashConfig = aiAny2.bashConfig;
          }
          if (aiAny2.completion_prompt !== void 0) {
            aiConfig.completionPrompt = aiAny2.completion_prompt;
          }
          if (aiAny2.skip_code_context !== void 0) {
            aiConfig.skip_code_context = aiAny2.skip_code_context;
          } else if (skipTransport) {
            aiConfig.skip_code_context = true;
          }
          if (aiAny2.skip_slack_context !== void 0) {
            aiConfig.skip_slack_context = aiAny2.skip_slack_context;
          } else if (skipTransport) {
            aiConfig.skip_slack_context = true;
          }
          if (aiAny2.retry !== void 0) {
            aiConfig.retry = aiAny2.retry;
          }
          if (aiAny2.fallback !== void 0) {
            aiConfig.fallback = aiAny2.fallback;
          }
        }
        try {
          const ctxAny = sessionInfo;
          const parentCtx = ctxAny?._parentContext;
          const workspace = parentCtx?.workspace;
          logger.debug(
            `[AI Provider] Workspace detection for check '${config.checkName || "unknown"}':`
          );
          logger.debug(`[AI Provider]   sessionInfo exists: ${!!sessionInfo}`);
          logger.debug(`[AI Provider]   _parentContext exists: ${!!parentCtx}`);
          logger.debug(`[AI Provider]   workspace exists: ${!!workspace}`);
          if (workspace) {
            logger.debug(
              `[AI Provider]   workspace.isEnabled exists: ${typeof workspace.isEnabled === "function"}`
            );
            logger.debug(
              `[AI Provider]   workspace.isEnabled(): ${typeof workspace.isEnabled === "function" ? workspace.isEnabled() : "N/A"}`
            );
            const projectCount = typeof workspace.listProjects === "function" ? workspace.listProjects()?.length : "N/A";
            logger.debug(`[AI Provider]   workspace.listProjects() count: ${projectCount}`);
          }
          if (workspace && typeof workspace.isEnabled === "function" && workspace.isEnabled()) {
            const folders = [];
            let workspaceRoot;
            let mainProjectPath;
            try {
              const info = workspace.getWorkspaceInfo?.();
              if (info && typeof info.workspacePath === "string") {
                workspaceRoot = info.workspacePath;
                mainProjectPath = info.mainProjectPath;
                folders.push(info.workspacePath);
              }
            } catch {
            }
            const projectPaths = [];
            try {
              const projects = workspace.listProjects?.() || [];
              for (const proj of projects) {
                if (proj && typeof proj.path === "string") {
                  folders.push(proj.path);
                  projectPaths.push(proj.path);
                }
              }
            } catch {
            }
            const workspaceCfg = parentCtx?.config?.workspace;
            const includeMainProject = workspaceCfg?.include_main_project === true || process.env.VISOR_WORKSPACE_INCLUDE_MAIN_PROJECT === "true";
            if (includeMainProject && mainProjectPath) {
              folders.push(mainProjectPath);
              logger.debug(`[AI Provider] Including main project (enabled): ${mainProjectPath}`);
            } else if (mainProjectPath) {
              logger.debug(`[AI Provider] Excluding main project (disabled): ${mainProjectPath}`);
            }
            const unique = Array.from(new Set(folders.filter((p) => typeof p === "string" && p)));
            if (unique.length > 0 && workspaceRoot) {
              if (unique[0] !== workspaceRoot) {
                logger.warn(
                  `[AI Provider] allowedFolders[0] is not workspaceRoot; tooling defaults may be mis-scoped`
                );
              }
              aiConfig.allowedFolders = unique;
              const aiCwd = workspaceRoot;
              aiConfig.path = aiCwd;
              aiConfig.cwd = aiCwd;
              aiConfig.workspacePath = aiCwd;
              logger.debug(`[AI Provider] Workspace isolation enabled:`);
              logger.debug(`[AI Provider]   cwd (workspaceRoot): ${aiCwd}`);
              logger.debug(`[AI Provider]   workspaceRoot: ${workspaceRoot}`);
              logger.debug(`[AI Provider]   allowedFolders: ${JSON.stringify(unique)}`);
            }
          } else if (parentCtx && typeof parentCtx.workingDirectory === "string") {
            if (!aiConfig.allowedFolders) {
              aiConfig.allowedFolders = [parentCtx.workingDirectory];
            }
            if (!aiConfig.path) {
              aiConfig.path = parentCtx.workingDirectory;
              aiConfig.cwd = parentCtx.workingDirectory;
            }
          }
        } catch {
        }
        if (config.ai_model !== void 0) {
          aiConfig.model = config.ai_model;
        }
        if (config.ai_provider !== void 0) {
          aiConfig.provider = config.ai_provider;
        }
        if (config.ai_max_iterations !== void 0 && aiConfig.maxIterations === void 0) {
          aiConfig.maxIterations = config.ai_max_iterations;
        }
        const customPrompt = config.prompt;
        if (!customPrompt) {
          throw new Error(
            `No prompt defined for check. All checks must have prompts defined in .visor.yaml configuration.`
          );
        }
        const mcpServers = {};
        const globalConfig = config;
        if (globalConfig.ai_mcp_servers) {
          Object.assign(mcpServers, globalConfig.ai_mcp_servers);
        }
        if (config.ai_mcp_servers) {
          Object.assign(mcpServers, config.ai_mcp_servers);
        }
        if (config.ai?.mcpServers) {
          Object.assign(mcpServers, config.ai.mcpServers);
        }
        const mcpServersJsExpr = config.ai_mcp_servers_js;
        if (mcpServersJsExpr && _dependencyResults) {
          try {
            const dynamicServers = this.evaluateMcpServersJs(
              mcpServersJsExpr,
              prInfo,
              _dependencyResults,
              config
            );
            if (Object.keys(dynamicServers).length > 0) {
              Object.assign(mcpServers, dynamicServers);
            }
          } catch (error) {
            logger.error(
              `[AICheckProvider] Failed to evaluate ai_mcp_servers_js: ${error instanceof Error ? error.message : "Unknown error"}`
            );
          }
        }
        for (const serverConfig of Object.values(mcpServers)) {
          if (serverConfig.env) {
            const resolvedEnv = {};
            for (const [key, value] of Object.entries(serverConfig.env)) {
              if (typeof value === "string") {
                resolvedEnv[key] = String(EnvironmentResolver.resolveValue(value));
              } else {
                resolvedEnv[key] = String(value);
              }
            }
            serverConfig.env = resolvedEnv;
          }
        }
        let customToolsServer = null;
        let customToolsToLoad = [];
        let customToolsServerName = null;
        const customToolsJsExpr = config.ai_custom_tools_js;
        if (customToolsJsExpr && _dependencyResults) {
          try {
            const dynamicTools = this.evaluateCustomToolsJs(
              customToolsJsExpr,
              prInfo,
              _dependencyResults,
              config
            );
            if (dynamicTools.length > 0) {
              customToolsToLoad = dynamicTools;
              customToolsServerName = "__custom_tools__";
              logger.debug(
                `[AICheckProvider] ai_custom_tools_js evaluated to ${dynamicTools.length} tools`
              );
            }
          } catch (error) {
            logger.error(
              `[AICheckProvider] Failed to evaluate ai_custom_tools_js: ${error instanceof Error ? error.message : "Unknown error"}`
            );
          }
        }
        const staticCustomTools = this.getCustomToolsForAI(config);
        if (staticCustomTools.length > 0) {
          if (customToolsToLoad.length > 0) {
            const existingNames = new Set(
              customToolsToLoad.map((item) => typeof item === "string" ? item : item.workflow)
            );
            for (const tool of staticCustomTools) {
              const name = typeof tool === "string" ? tool : tool.workflow;
              if (!existingNames.has(name)) {
                customToolsToLoad.push(tool);
              }
            }
          } else {
            customToolsToLoad = staticCustomTools;
            customToolsServerName = "__custom_tools__";
          }
        }
        for (const [serverName, serverConfig] of Object.entries(mcpServers)) {
          if (serverConfig.tools && Array.isArray(serverConfig.tools)) {
            customToolsToLoad = serverConfig.tools;
            customToolsServerName = serverName;
            break;
          }
        }
        const workflowEntriesFromMcp = [];
        const toolEntriesFromMcp = [];
        const mcpEntriesToRemove = [];
        for (const [serverName, serverConfig] of Object.entries(mcpServers)) {
          const cfg = serverConfig;
          if (cfg.workflow && typeof cfg.workflow === "string") {
            workflowEntriesFromMcp.push({
              workflow: cfg.workflow,
              args: cfg.inputs
            });
            mcpEntriesToRemove.push(serverName);
            logger.debug(
              `[AICheckProvider] Extracted workflow tool '${serverName}' (workflow=${cfg.workflow}) from ai_mcp_servers`
            );
          } else if (cfg.tool && typeof cfg.tool === "string") {
            toolEntriesFromMcp.push(cfg.tool);
            mcpEntriesToRemove.push(serverName);
            logger.debug(`[AICheckProvider] Extracted tool '${cfg.tool}' from ai_mcp_servers`);
          }
        }
        for (const name of mcpEntriesToRemove) {
          delete mcpServers[name];
        }
        if (workflowEntriesFromMcp.length > 0) {
          const existingNames = new Set(
            customToolsToLoad.map((item) => typeof item === "string" ? item : item.workflow)
          );
          for (const wf of workflowEntriesFromMcp) {
            if (!existingNames.has(wf.workflow)) {
              customToolsToLoad.push(wf);
            }
          }
          if (!customToolsServerName) {
            customToolsServerName = "__tools__";
          }
        }
        if (toolEntriesFromMcp.length > 0) {
          const existingNames = new Set(
            customToolsToLoad.map((item) => typeof item === "string" ? item : item.workflow)
          );
          for (const toolName of toolEntriesFromMcp) {
            if (!existingNames.has(toolName)) {
              customToolsToLoad.push(toolName);
            }
          }
          if (!customToolsServerName) {
            customToolsServerName = "__tools__";
          }
        }
        const sessionAny = sessionInfo;
        const webhookData = sessionAny?.webhookContext?.webhookData || sessionAny?._parentContext?.webhookContext?.webhookData;
        const slackContext = webhookData ? extractSlackContext(webhookData) : null;
        const scheduleToolRequested = !config.ai?.disableTools && customToolsToLoad.some(
          (tool) => tool === "schedule" || typeof tool === "object" && tool.workflow === "schedule"
        );
        if (scheduleToolRequested) {
          customToolsToLoad = customToolsToLoad.filter(
            (tool) => tool !== "schedule" && !(typeof tool === "object" && tool.workflow === "schedule")
          );
          if (!customToolsServerName) {
            customToolsServerName = "__tools__";
          }
          const contextInfo = slackContext ? `user=${slackContext.userId}, channelType=${slackContext.channelType}` : "cli";
          logger.debug(`[AICheckProvider] Schedule tool requested (${contextInfo})`);
        }
        const scheduleToolEnabled = scheduleToolRequested || config.ai?.enable_scheduler === true && !config.ai?.disableTools;
        if ((customToolsToLoad.length > 0 || scheduleToolEnabled) && (customToolsServerName || scheduleToolEnabled) && !config.ai?.disableTools) {
          if (!customToolsServerName) {
            customToolsServerName = "__tools__";
          }
          try {
            const customTools = this.loadCustomTools(customToolsToLoad, config);
            if (scheduleToolEnabled) {
              const scheduleTool = getScheduleToolDefinition();
              customTools.set(scheduleTool.name, scheduleTool);
              logger.debug(`[AICheckProvider] Added built-in schedule tool`);
            }
            if (customTools.size > 0) {
              const sessionId = config.checkName || `ai-check-${Date.now()}`;
              const debug = aiConfig.debug || process.env.VISOR_DEBUG === "true";
              const parentCtxForTools = sessionInfo?._parentContext;
              const workflowContext = {
                prInfo,
                outputs: _dependencyResults,
                executionContext: sessionInfo,
                workspace: parentCtxForTools?.workspace
              };
              customToolsServer = new CustomToolsSSEServer(
                customTools,
                sessionId,
                debug,
                workflowContext
              );
              const port = await customToolsServer.start();
              if (debug) {
                logger.debug(
                  `[AICheckProvider] Started custom tools SSE server '${customToolsServerName}' on port ${port} for ${customTools.size} tools`
                );
              }
              mcpServers[customToolsServerName] = {
                command: "",
                args: [],
                url: `http://localhost:${port}/sse`,
                transport: "sse",
                timeout: 6e5
                // 10 minutes for workflow tools
              };
            }
          } catch (error) {
            logger.error(
              `[AICheckProvider] Failed to start custom tools SSE server '${customToolsServerName}': ${error instanceof Error ? error.message : "Unknown error"}`
            );
          }
        }
        if (Object.keys(mcpServers).length > 0 && !config.ai?.disableTools) {
          aiConfig.mcpServers = mcpServers;
        } else if (config.ai?.disableTools) {
        }
        const templateContext = {
          pr: {
            number: prInfo.number,
            title: prInfo.title,
            author: prInfo.author,
            branch: prInfo.head,
            base: prInfo.base
          },
          files: prInfo.files,
          outputs: _dependencyResults ? Object.fromEntries(
            Array.from(_dependencyResults.entries()).map(([checkName, result]) => [
              checkName,
              result.output !== void 0 ? result.output : result
            ])
          ) : {},
          args: sessionInfo?.args || {}
        };
        try {
          const span = trace.getSpan(context.active());
          if (span) {
            captureCheckInputContext(span, templateContext);
          }
        } catch {
        }
        try {
          const checkId = config.checkName || config.id || "unknown";
          const ctxJson = JSON.stringify(sanitizeContextForTelemetry(templateContext));
          const { emitNdjsonSpanWithEvents: emitNdjsonSpanWithEvents2 } = (init_fallback_ndjson(), __toCommonJS(fallback_ndjson_exports));
          emitNdjsonSpanWithEvents2(
            "visor.check",
            { "visor.check.id": checkId, "visor.check.input.context": ctxJson },
            []
          );
        } catch {
        }
        const baseEventContext = config.eventContext || {};
        const checksMeta = config.checksMeta;
        const slackCtx = this.buildSlackEventContext(
          sessionInfo,
          config,
          prInfo
        );
        const baseWithSlack = { ...baseEventContext, ...slackCtx };
        const eventContext = checksMeta ? { ...baseWithSlack, __checksMeta: checksMeta } : baseWithSlack;
        const ctxWithStage = {
          ...eventContext || {},
          __stageHistoryBase: sessionInfo?.stageHistoryBase
        };
        const processedPrompt = await this.processPrompt(
          customPrompt,
          prInfo,
          ctxWithStage,
          _dependencyResults,
          config.__outputHistory,
          sessionInfo?.args,
          config.workflowInputs
        );
        const processedSchema = await this.renderSchema(
          config.schema,
          prInfo,
          ctxWithStage,
          _dependencyResults,
          config.__outputHistory,
          sessionInfo?.args,
          config.workflowInputs
        );
        const aiAny = config.ai || {};
        const persona = (aiAny?.ai_persona || config.ai_persona || "").toString().trim();
        const finalPrompt = persona ? `Persona: ${persona}

${processedPrompt}` : processedPrompt;
        const promptTypeOverride = (aiAny?.prompt_type || config.ai?.promptType || config.ai_prompt_type || "").toString().trim();
        try {
          const stepName = config.checkName || "unknown";
          const serviceForCapture = new AIReviewService(aiConfig);
          const finalPromptCapture = await serviceForCapture.buildCustomPrompt(
            prInfo,
            finalPrompt,
            processedSchema,
            {
              checkName: config.checkName,
              skipPRContext: config.ai?.skip_code_context === true
            }
          );
          sessionInfo?.hooks?.onPromptCaptured?.({
            step: String(stepName),
            provider: "ai",
            prompt: finalPromptCapture
          });
        } catch {
        }
        try {
          const stepName = config.checkName || "unknown";
          const mock = sessionInfo?.hooks?.mockForStep?.(String(stepName));
          if (mock !== void 0) {
            const ms = mock;
            const issuesArr = Array.isArray(ms?.issues) ? ms.issues : [];
            const out = ms && typeof ms === "object" && "output" in ms ? ms.output : ms;
            const summary = {
              issues: issuesArr,
              output: out,
              ...typeof ms?.content === "string" ? { content: String(ms.content) } : {}
            };
            return summary;
          }
        } catch {
        }
        try {
          if (promptTypeOverride) aiConfig.promptType = promptTypeOverride;
          const sys = (aiAny?.system_prompt || config.ai_system_prompt || "").toString().trim();
          const legacy = (aiAny?.custom_prompt || config.ai_custom_prompt || "").toString().trim();
          if (sys) aiConfig.systemPrompt = sys;
          else if (legacy) aiConfig.systemPrompt = legacy;
        } catch {
        }
        const service = new AIReviewService(aiConfig);
        const schema = processedSchema;
        try {
          let result;
          const prevPromptTypeEnv = process.env.VISOR_PROMPT_TYPE;
          const shouldIgnoreEnvPromptType = aiAny?.disableTools === true;
          let didAdjustPromptTypeEnv = false;
          if (promptTypeOverride) {
            process.env.VISOR_PROMPT_TYPE = promptTypeOverride;
            didAdjustPromptTypeEnv = true;
          } else if (shouldIgnoreEnvPromptType && prevPromptTypeEnv !== void 0) {
            delete process.env.VISOR_PROMPT_TYPE;
            didAdjustPromptTypeEnv = true;
          }
          try {
            const reuseEnabled = config.reuse_ai_session === true || typeof config.reuse_ai_session === "string";
            let promptUsed = finalPrompt;
            if (sessionInfo?.reuseSession && sessionInfo.parentSessionId && reuseEnabled) {
              try {
                const { SessionRegistry: SessionRegistry2 } = (init_session_registry(), __toCommonJS(session_registry_exports));
                const reg = SessionRegistry2.getInstance();
                if (!reg.hasSession(sessionInfo.parentSessionId)) {
                  if (aiConfig.debug || process.env.VISOR_DEBUG === "true") {
                    console.warn(
                      `\u26A0\uFE0F  Parent session ${sessionInfo.parentSessionId} not found; creating a new session for ${config.checkName}`
                    );
                  }
                  promptUsed = processedPrompt;
                  const fresh = await service.executeReview(
                    prInfo,
                    processedPrompt,
                    schema,
                    config.checkName,
                    config.sessionId
                  );
                  return {
                    ...fresh,
                    issues: new IssueFilter(config.suppressionEnabled !== false).filterIssues(
                      fresh.issues || [],
                      process.cwd()
                    )
                  };
                }
              } catch {
              }
              const sessionMode = config.session_mode || "clone";
              if (aiConfig.debug) {
                console.error(
                  `\u{1F504} Debug: Using session reuse with parent session: ${sessionInfo.parentSessionId} (mode: ${sessionMode})`
                );
              }
              promptUsed = processedPrompt;
              result = await service.executeReviewWithSessionReuse(
                prInfo,
                processedPrompt,
                sessionInfo.parentSessionId,
                schema,
                config.checkName,
                sessionMode
              );
            } else {
              if (aiConfig.debug) {
                console.error(`\u{1F195} Debug: Creating new AI session for check: ${config.checkName}`);
              }
              promptUsed = finalPrompt;
              result = await service.executeReview(
                prInfo,
                finalPrompt,
                schema,
                config.checkName,
                config.sessionId
              );
            }
            const suppressionEnabled = config.suppressionEnabled !== false;
            const issueFilter = new IssueFilter(suppressionEnabled);
            const filteredIssues = issueFilter.filterIssues(result.issues || [], process.cwd());
            const finalResult = {
              ...result,
              issues: filteredIssues
            };
            try {
              const span = trace.getSpan(context.active());
              if (span) {
                captureProviderCall(
                  span,
                  "ai",
                  {
                    prompt: promptUsed,
                    model: aiConfig.model
                  },
                  {
                    content: JSON.stringify(finalResult),
                    tokens: result.usage?.totalTokens
                  }
                );
                const outputForSpan = finalResult.output ?? finalResult;
                captureCheckOutput(span, outputForSpan);
              }
            } catch {
            }
            try {
              const checkId = config.checkName || config.id || "unknown";
              const outJson = JSON.stringify(finalResult.output ?? finalResult);
              const { emitNdjsonSpanWithEvents: emitNdjsonSpanWithEvents2 } = (init_fallback_ndjson(), __toCommonJS(fallback_ndjson_exports));
              emitNdjsonSpanWithEvents2(
                "visor.check",
                { "visor.check.id": checkId, "visor.check.output": outJson },
                []
              );
            } catch {
            }
            return finalResult;
          } finally {
            if (didAdjustPromptTypeEnv) {
              if (prevPromptTypeEnv === void 0) {
                delete process.env.VISOR_PROMPT_TYPE;
              } else {
                process.env.VISOR_PROMPT_TYPE = prevPromptTypeEnv;
              }
            }
          }
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          console.error(`\u274C AI Check Provider Error for check: ${errorMessage}`);
          const isCriticalError = errorMessage.includes("API rate limit") || errorMessage.includes("403") || errorMessage.includes("401") || errorMessage.includes("authentication") || errorMessage.includes("API key");
          if (isCriticalError) {
            console.error(`\u{1F6A8} CRITICAL ERROR: AI provider authentication or rate limit issue detected`);
            console.error(`\u{1F6A8} This check cannot proceed without valid API credentials`);
          }
          throw new Error(`AI analysis failed: ${errorMessage}`);
        } finally {
          if (customToolsServer) {
            try {
              const drainTimeoutRaw = process.env.VISOR_CUSTOM_TOOLS_DRAIN_TIMEOUT_MS;
              const drainTimeoutMs = drainTimeoutRaw ? parseInt(drainTimeoutRaw, 10) : void 0;
              await customToolsServer.stop({
                graceMs: 0,
                // No grace period at check completion - we're done
                drainTimeoutMs: Number.isFinite(drainTimeoutMs) ? drainTimeoutMs : void 0
              });
              if (aiConfig.debug || process.env.VISOR_DEBUG === "true") {
                logger.debug("[AICheckProvider] Custom tools SSE server stopped");
              }
            } catch (error) {
              logger.error(
                `[AICheckProvider] Error stopping custom tools SSE server: ${error instanceof Error ? error.message : "Unknown error"}`
              );
            }
          }
        }
      }
      /**
       * Get custom tool items from check configuration
       * Returns an array of tool items (string names or workflow references)
       */
      getCustomToolsForAI(config) {
        const aiCustomTools = config.ai_custom_tools;
        if (!aiCustomTools) {
          return [];
        }
        if (Array.isArray(aiCustomTools)) {
          return aiCustomTools.filter(
            (item) => typeof item === "string" || isWorkflowToolReference(item)
          );
        }
        if (typeof aiCustomTools === "string") {
          return [aiCustomTools];
        }
        if (isWorkflowToolReference(aiCustomTools)) {
          return [aiCustomTools];
        }
        return [];
      }
      /**
       * Evaluate ai_custom_tools_js expression to dynamically compute custom tools.
       * Returns an array of tool names or workflow references.
       */
      evaluateCustomToolsJs(expression, prInfo, dependencyResults, config) {
        if (!this.sandbox) {
          this.sandbox = createSecureSandbox();
        }
        const outputs = {};
        for (const [checkId, result] of dependencyResults.entries()) {
          const summary = result;
          outputs[checkId] = summary.output !== void 0 ? summary.output : summary;
        }
        const jsContext = {
          outputs,
          inputs: config.inputs || {},
          pr: {
            number: prInfo.number,
            title: prInfo.title,
            description: prInfo.body,
            author: prInfo.author,
            branch: prInfo.head,
            base: prInfo.base,
            authorAssociation: prInfo.authorAssociation
          },
          files: prInfo.files?.map((f) => ({
            filename: f.filename,
            status: f.status,
            additions: f.additions,
            deletions: f.deletions,
            changes: f.changes
          })) || [],
          env: this.buildSafeEnv(),
          memory: config.__memoryAccessor || {}
        };
        try {
          const result = compileAndRun(this.sandbox, expression, jsContext, {
            injectLog: true,
            wrapFunction: true,
            logPrefix: "[ai_custom_tools_js]"
          });
          if (!Array.isArray(result)) {
            logger.warn(
              `[AICheckProvider] ai_custom_tools_js must return an array, got ${typeof result}`
            );
            return [];
          }
          return result.filter(
            (item) => typeof item === "string" || isWorkflowToolReference(item)
          );
        } catch (error) {
          logger.error(
            `[AICheckProvider] Failed to evaluate ai_custom_tools_js: ${error instanceof Error ? error.message : "Unknown error"}`
          );
          return [];
        }
      }
      /**
       * Evaluate ai_mcp_servers_js expression to dynamically compute MCP servers.
       * Returns a record mapping server names to McpServerConfig objects.
       */
      evaluateMcpServersJs(expression, prInfo, dependencyResults, config) {
        if (!this.sandbox) {
          this.sandbox = createSecureSandbox();
        }
        const outputs = {};
        for (const [checkId, result] of dependencyResults.entries()) {
          const summary = result;
          outputs[checkId] = summary.output !== void 0 ? summary.output : summary;
        }
        const jsContext = {
          outputs,
          inputs: config.inputs || {},
          pr: {
            number: prInfo.number,
            title: prInfo.title,
            description: prInfo.body,
            author: prInfo.author,
            branch: prInfo.head,
            base: prInfo.base,
            authorAssociation: prInfo.authorAssociation
          },
          files: prInfo.files?.map((f) => ({
            filename: f.filename,
            status: f.status,
            additions: f.additions,
            deletions: f.deletions,
            changes: f.changes
          })) || [],
          env: this.buildSafeEnv(),
          memory: config.__memoryAccessor || {}
        };
        try {
          const result = compileAndRun(this.sandbox, expression, jsContext, {
            injectLog: true,
            wrapFunction: true,
            logPrefix: "[ai_mcp_servers_js]"
          });
          if (typeof result !== "object" || result === null || Array.isArray(result)) {
            logger.warn(
              `[AICheckProvider] ai_mcp_servers_js must return an object, got ${Array.isArray(result) ? "array" : typeof result}`
            );
            return {};
          }
          const validServers = {};
          for (const [serverName, serverConfig] of Object.entries(result)) {
            if (typeof serverConfig !== "object" || serverConfig === null) {
              logger.warn(
                `[AICheckProvider] ai_mcp_servers_js: server "${serverName}" config must be an object`
              );
              continue;
            }
            const cfg = serverConfig;
            const isValid = cfg.command || cfg.url || cfg.workflow || cfg.tool || Object.keys(cfg).length === 0;
            if (!isValid) {
              logger.warn(
                `[AICheckProvider] ai_mcp_servers_js: server "${serverName}" must have command, url, workflow, or tool`
              );
              continue;
            }
            validServers[serverName] = cfg;
          }
          logger.debug(
            `[AICheckProvider] ai_mcp_servers_js evaluated to ${Object.keys(validServers).length} servers: ${Object.keys(validServers).join(", ")}`
          );
          return validServers;
        } catch (error) {
          logger.error(
            `[AICheckProvider] Failed to evaluate ai_mcp_servers_js: ${error instanceof Error ? error.message : "Unknown error"}`
          );
          return {};
        }
      }
      /**
       * Build a safe subset of environment variables for sandbox access.
       * Excludes sensitive keys like API keys, secrets, tokens.
       */
      buildSafeEnv() {
        const sensitivePatterns = [
          /api.?key/i,
          /secret/i,
          /token/i,
          /password/i,
          /credential/i,
          /auth/i,
          /private/i
        ];
        const safeEnv = {};
        for (const [key, value] of Object.entries(process.env)) {
          if (value === void 0) continue;
          const isSensitive = sensitivePatterns.some((pattern) => pattern.test(key));
          if (!isSensitive) {
            safeEnv[key] = value;
          }
        }
        return safeEnv;
      }
      /**
       * Load custom tools from global configuration and workflow registry
       * Supports both traditional custom tools and workflow-as-tool references
       */
      loadCustomTools(toolItems, config) {
        const tools = /* @__PURE__ */ new Map();
        const globalTools = config.__globalTools;
        for (const item of toolItems) {
          const workflowTool = resolveWorkflowToolFromItem(item);
          if (workflowTool) {
            logger.debug(`[AICheckProvider] Loaded workflow '${workflowTool.name}' as custom tool`);
            tools.set(workflowTool.name, workflowTool);
            continue;
          }
          if (typeof item === "string") {
            if (globalTools && globalTools[item]) {
              const tool = globalTools[item];
              tool.name = tool.name || item;
              tools.set(item, tool);
              continue;
            }
            logger.warn(
              `[AICheckProvider] Custom tool '${item}' not found in global tools or workflow registry`
            );
          } else if (isWorkflowToolReference(item)) {
            logger.warn(
              `[AICheckProvider] Workflow '${item.workflow}' referenced but not found in registry`
            );
          }
        }
        if (tools.size === 0 && toolItems.length > 0 && !globalTools) {
          logger.warn(
            `[AICheckProvider] ai_custom_tools specified but no global tools found in configuration and no workflows matched`
          );
        }
        return tools;
      }
      getSupportedConfigKeys() {
        return [
          "type",
          "prompt",
          "focus",
          "schema",
          "group",
          "ai.provider",
          "ai.model",
          "ai.apiKey",
          "ai.timeout",
          "ai.max_iterations",
          "ai.mcpServers",
          "ai.enableDelegate",
          "ai.enableTasks",
          // legacy persona/prompt keys supported in config
          "ai_persona",
          "ai_prompt_type",
          "ai_custom_prompt",
          "ai_system_prompt",
          "ai_max_iterations",
          // new provider resilience and tools toggles
          "ai.retry",
          "ai.fallback",
          "ai.allowEdit",
          "ai.allowedTools",
          "ai.disableTools",
          "ai.allowBash",
          "ai.bashConfig",
          "ai_model",
          "ai_provider",
          "ai_mcp_servers",
          "ai_mcp_servers_js",
          "ai_custom_tools",
          "ai_custom_tools_js",
          "env"
        ];
      }
      async isAvailable() {
        return !!(process.env.GOOGLE_API_KEY || process.env.ANTHROPIC_API_KEY || process.env.OPENAI_API_KEY || // AWS Bedrock credentials check
        process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY || process.env.AWS_BEDROCK_API_KEY);
      }
      getRequirements() {
        return [
          "At least one of: GOOGLE_API_KEY, ANTHROPIC_API_KEY, OPENAI_API_KEY, or AWS credentials (AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY)",
          "Optional: MODEL_NAME environment variable",
          "Optional: AWS_REGION for Bedrock provider",
          "Network access to AI provider APIs"
        ];
      }
    };
  }
});

// src/providers/http-check-provider.ts
var HttpCheckProvider;
var init_http_check_provider = __esm({
  "src/providers/http-check-provider.ts"() {
    "use strict";
    init_check_provider_interface();
    init_issue_filter();
    init_liquid_extensions();
    init_lazy_otel();
    init_state_capture();
    init_env_resolver();
    HttpCheckProvider = class extends CheckProvider {
      liquid;
      constructor() {
        super();
        this.liquid = createExtendedLiquid();
      }
      getName() {
        return "http";
      }
      getDescription() {
        return "Send data to external HTTP endpoint for notifications or integration";
      }
      async validateConfig(config) {
        if (!config || typeof config !== "object") {
          return false;
        }
        const cfg = config;
        if (cfg.type !== "http") {
          return false;
        }
        if (typeof cfg.url !== "string" || !cfg.url) {
          return false;
        }
        if (typeof cfg.body !== "string" || !cfg.body) {
          return false;
        }
        try {
          new URL(cfg.url);
          return true;
        } catch {
          return false;
        }
      }
      async execute(prInfo, config, dependencyResults, _sessionInfo) {
        const url = config.url;
        const bodyTemplate = config.body;
        const method = config.method || "POST";
        const headers = config.headers || {};
        const timeout = config.timeout || 3e4;
        const templateContext = {
          pr: {
            number: prInfo.number,
            title: prInfo.title,
            body: prInfo.body,
            author: prInfo.author,
            base: prInfo.base,
            head: prInfo.head,
            totalAdditions: prInfo.totalAdditions,
            totalDeletions: prInfo.totalDeletions
          },
          files: prInfo.files.map((f) => ({
            filename: f.filename,
            status: f.status,
            additions: f.additions,
            deletions: f.deletions,
            changes: f.changes,
            patch: f.patch
          })),
          outputs: dependencyResults ? Object.fromEntries(dependencyResults) : {},
          metadata: config.metadata || {}
        };
        try {
          const span = trace.getSpan(context.active());
          if (span) {
            captureCheckInputContext(span, templateContext);
          }
        } catch {
        }
        let payload;
        try {
          const renderedBody = await this.liquid.parseAndRender(bodyTemplate, templateContext);
          try {
            payload = JSON.parse(renderedBody);
          } catch {
            payload = { message: renderedBody };
          }
        } catch (error) {
          return this.createErrorResult(
            url,
            new Error(
              `Template rendering failed: ${error instanceof Error ? error.message : "Unknown error"}`
            )
          );
        }
        try {
          const resolvedHeaders = EnvironmentResolver.resolveHeaders(headers);
          const response = await this.sendWebhookRequest(
            url,
            method,
            resolvedHeaders,
            payload,
            timeout
          );
          const result = this.parseWebhookResponse(response, url);
          const suppressionEnabled = config.suppressionEnabled !== false;
          const issueFilter = new IssueFilter(suppressionEnabled);
          const filteredIssues = issueFilter.filterIssues(result.issues || [], process.cwd());
          const finalResult = {
            ...result,
            issues: filteredIssues
          };
          try {
            const span = trace.getSpan(context.active());
            if (span) {
              const sanitizedHeaders = EnvironmentResolver.sanitizeHeaders(resolvedHeaders);
              captureProviderCall(
                span,
                "http",
                {
                  url,
                  method,
                  headers: sanitizedHeaders,
                  body: JSON.stringify(payload).substring(0, 500)
                },
                {
                  content: JSON.stringify(response).substring(0, 500)
                }
              );
              const outputForSpan = finalResult.output ?? finalResult;
              captureCheckOutput(span, outputForSpan);
            }
          } catch {
          }
          return finalResult;
        } catch (error) {
          return this.createErrorResult(url, error);
        }
      }
      async sendWebhookRequest(url, method, headers, payload, timeout) {
        if (typeof fetch === "undefined") {
          throw new Error("Webhook provider requires Node.js 18+ or node-fetch package");
        }
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        try {
          const response = await fetch(url, {
            method,
            headers: {
              "Content-Type": "application/json",
              ...headers
            },
            body: JSON.stringify(payload),
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          if (!response.ok) {
            throw new Error(`Webhook returned ${response.status}: ${response.statusText}`);
          }
          return await response.json();
        } catch (error) {
          clearTimeout(timeoutId);
          if (error instanceof Error && error.name === "AbortError") {
            throw new Error(`Webhook request timed out after ${timeout}ms`);
          }
          throw error;
        }
      }
      parseWebhookResponse(response, url) {
        if (!response || typeof response !== "object") {
          return this.createErrorResult(url, new Error("Invalid webhook response format"));
        }
        const issues = Array.isArray(response.comments) ? response.comments.map((c) => ({
          file: c.file || "unknown",
          line: c.line || 0,
          endLine: c.endLine,
          ruleId: c.ruleId || `webhook/${this.validateCategory(c.category)}`,
          message: c.message || "",
          severity: this.validateSeverity(c.severity),
          category: this.validateCategory(c.category),
          suggestion: c.suggestion,
          replacement: c.replacement
        })) : [];
        return {
          issues
        };
      }
      createErrorResult(url, error) {
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        return {
          issues: [
            {
              file: "webhook",
              line: 0,
              endLine: void 0,
              ruleId: "webhook/error",
              message: `Webhook execution error: ${errorMessage}`,
              severity: "error",
              category: "logic",
              suggestion: void 0,
              replacement: void 0
            }
          ]
        };
      }
      validateSeverity(severity) {
        const valid = ["info", "warning", "error", "critical"];
        return valid.includes(severity) ? severity : "info";
      }
      validateCategory(category) {
        const valid = ["security", "performance", "style", "logic", "documentation"];
        return valid.includes(category) ? category : "logic";
      }
      getSupportedConfigKeys() {
        return [
          "type",
          "url",
          "body",
          "method",
          "headers",
          "timeout",
          "metadata",
          "depends_on",
          "on",
          "if",
          "group",
          "schedule"
        ];
      }
      async isAvailable() {
        return typeof fetch !== "undefined";
      }
      getRequirements() {
        return [
          "Valid HTTP URL",
          "Body template (Liquid) for payload construction",
          "Network access to HTTP endpoint",
          "Optional: Dependencies for accessing their outputs in templates"
        ];
      }
    };
  }
});

// src/providers/http-input-provider.ts
var HttpInputProvider;
var init_http_input_provider = __esm({
  "src/providers/http-input-provider.ts"() {
    "use strict";
    init_check_provider_interface();
    init_liquid_extensions();
    init_logger();
    HttpInputProvider = class extends CheckProvider {
      liquid;
      webhookContext;
      constructor() {
        super();
        this.liquid = createExtendedLiquid();
      }
      /**
       * Set webhook context for accessing webhook data
       */
      setWebhookContext(webhookContext) {
        this.webhookContext = webhookContext;
      }
      getName() {
        return "http_input";
      }
      getDescription() {
        return "Receive and process HTTP webhook input data for use by dependent checks";
      }
      async validateConfig(config) {
        if (!config || typeof config !== "object") {
          return false;
        }
        const cfg = config;
        if (cfg.type !== "http_input") {
          return false;
        }
        if (typeof cfg.endpoint !== "string" || !cfg.endpoint) {
          return false;
        }
        if (cfg.transform !== void 0 && typeof cfg.transform !== "string") {
          return false;
        }
        return true;
      }
      async execute(prInfo, config, _dependencyResults, _sessionInfo) {
        const endpoint = config.endpoint;
        const transform = config.transform;
        const webhookData = this.getWebhookData(endpoint);
        if (!webhookData) {
          return {
            issues: []
          };
        }
        let processedData = webhookData;
        if (transform) {
          try {
            const templateContext = {
              webhook: webhookData,
              pr: {
                number: prInfo.number,
                title: prInfo.title,
                author: prInfo.author,
                base: prInfo.base,
                head: prInfo.head
              }
            };
            const rendered = await this.liquid.parseAndRender(transform, templateContext);
            processedData = JSON.parse(rendered);
            logger.verbose(`\u2713 Applied webhook transform successfully`);
          } catch (error) {
            logger.error(
              `\u2717 Failed to transform webhook data: ${error instanceof Error ? error.message : "Unknown error"}`
            );
            return {
              issues: [
                {
                  file: "webhook_input",
                  line: 0,
                  ruleId: "webhook_input/transform_error",
                  message: `Failed to transform webhook data: ${error instanceof Error ? error.message : "Unknown error"}`,
                  severity: "error",
                  category: "logic"
                }
              ]
            };
          }
        }
        return {
          issues: [],
          // Add custom data field that will be passed through
          data: processedData
        };
      }
      getWebhookData(endpoint) {
        if (this.webhookContext) {
          return this.webhookContext.get(endpoint) || null;
        }
        const globalWebhookStore = global.__visor_webhook_data;
        if (globalWebhookStore && globalWebhookStore.get) {
          console.warn(
            "HttpInputProvider: Using deprecated global webhook store. Please use webhook context instead."
          );
          return globalWebhookStore.get(endpoint) || null;
        }
        return null;
      }
      getSupportedConfigKeys() {
        return ["type", "endpoint", "transform", "on", "depends_on", "if", "group"];
      }
      async isAvailable() {
        return true;
      }
      getRequirements() {
        return [
          "HTTP server must be configured and running",
          "Valid endpoint path specified",
          "Optional: Transform template for data processing"
        ];
      }
    };
  }
});

// src/utils/template-context.ts
function prCacheKey(pr) {
  let sum = 0;
  for (const f of pr.files) sum += (f.additions || 0) + (f.deletions || 0) + (f.changes || 0);
  return [pr.number, pr.title, pr.author, pr.base, pr.head, pr.files.length, sum].join("|");
}
function buildProviderTemplateContext(prInfo, dependencyResults, memoryStore, outputHistory, stageHistoryBase, opts = {
  attachMemoryReadHelpers: true
}) {
  const context2 = {};
  const key = prCacheKey(prInfo);
  let prObj = prCache.get(key);
  if (!prObj) {
    prObj = {
      number: prInfo.number,
      title: prInfo.title,
      body: prInfo.body,
      author: prInfo.author,
      base: prInfo.base,
      head: prInfo.head,
      totalAdditions: prInfo.totalAdditions,
      totalDeletions: prInfo.totalDeletions,
      files: prInfo.files.map((f) => ({
        filename: f.filename,
        status: f.status,
        additions: f.additions,
        deletions: f.deletions,
        changes: f.changes
      }))
    };
    prCache.set(key, prObj);
    if (prCache.size > PR_CACHE_LIMIT) {
      const first = prCache.keys().next();
      if (!first.done) prCache.delete(first.value);
    }
  }
  context2.pr = prObj;
  const outputs = {};
  const outputsRaw = {};
  const history = {};
  if (dependencyResults) {
    for (const [checkName, result] of dependencyResults.entries()) {
      if (typeof checkName !== "string") continue;
      const summary = result;
      if (checkName.endsWith("-raw")) {
        const name = checkName.slice(0, -4);
        outputsRaw[name] = summary.output !== void 0 ? summary.output : summary;
      } else {
        const extracted = summary.output !== void 0 ? summary.output : summary;
        outputs[checkName] = extracted;
      }
    }
  }
  if (outputHistory) {
    for (const [checkName, historyArray] of outputHistory) {
      const arr = Array.isArray(historyArray) ? historyArray : [];
      const filtered = arr.filter((v) => {
        try {
          if (!v || typeof v !== "object") return true;
          const obj = v;
          if (Array.isArray(obj.forEachItems)) return false;
          if (obj.isForEach === true && obj.forEachItems !== void 0)
            return false;
        } catch {
        }
        return true;
      });
      history[checkName] = filtered;
    }
  }
  const historyStage = {};
  try {
    if (outputHistory && stageHistoryBase) {
      for (const [checkName, historyArray] of outputHistory) {
        const start = stageHistoryBase[checkName] || 0;
        const arr = Array.isArray(historyArray) ? historyArray : [];
        historyStage[checkName] = arr.slice(start);
      }
    }
  } catch {
  }
  outputs.history = history;
  context2.outputs = outputs;
  context2.outputs_history = history;
  context2.outputs_history_stage = historyStage;
  context2.outputs_raw = outputsRaw;
  if (opts.attachMemoryReadHelpers && memoryStore) {
    context2.memory = {
      get: (key2, ns) => memoryStore.get(key2, ns),
      has: (key2, ns) => memoryStore.has(key2, ns),
      list: (ns) => memoryStore.list(ns),
      getAll: (ns) => memoryStore.getAll(ns)
    };
  }
  if (opts.args) {
    context2.args = opts.args;
  }
  return context2;
}
var PR_CACHE_LIMIT, prCache;
var init_template_context = __esm({
  "src/utils/template-context.ts"() {
    "use strict";
    PR_CACHE_LIMIT = 16;
    prCache = /* @__PURE__ */ new Map();
  }
});

// src/providers/http-client-provider.ts
import * as fs6 from "fs";
import * as path8 from "path";
var HttpClientProvider;
var init_http_client_provider = __esm({
  "src/providers/http-client-provider.ts"() {
    "use strict";
    init_check_provider_interface();
    init_liquid_extensions();
    init_env_resolver();
    init_sandbox();
    init_template_context();
    init_logger();
    HttpClientProvider = class extends CheckProvider {
      liquid;
      sandbox;
      constructor() {
        super();
        this.liquid = createExtendedLiquid();
      }
      createSecureSandbox() {
        return createSecureSandbox();
      }
      getName() {
        return "http_client";
      }
      getDescription() {
        return "Fetch data from HTTP endpoints for use by dependent checks";
      }
      async validateConfig(config) {
        if (!config || typeof config !== "object") {
          return false;
        }
        const cfg = config;
        if (cfg.type !== "http_client") {
          return false;
        }
        if (typeof cfg.url !== "string" || !cfg.url) {
          return false;
        }
        try {
          new URL(cfg.url);
          return true;
        } catch {
          return false;
        }
      }
      async execute(prInfo, config, dependencyResults, context2) {
        const url = config.url;
        const method = config.method || "GET";
        const headers = config.headers || {};
        const timeout = config.timeout || 3e4;
        const transform = config.transform;
        const transformJs = config.transform_js;
        const bodyTemplate = config.body;
        const outputFileTemplate = config.output_file;
        const skipIfExists = config.skip_if_exists !== false;
        let resolvedUrlForErrors = url;
        try {
          const templateContext = buildProviderTemplateContext(
            prInfo,
            dependencyResults,
            void 0,
            // memoryStore
            void 0,
            // outputHistory
            void 0,
            // stageHistoryBase
            { attachMemoryReadHelpers: false }
          );
          templateContext.env = process.env;
          let renderedUrl = String(EnvironmentResolver.resolveValue(url));
          resolvedUrlForErrors = renderedUrl;
          if (renderedUrl.includes("{{") || renderedUrl.includes("{%")) {
            renderedUrl = await this.liquid.parseAndRender(renderedUrl, templateContext);
            resolvedUrlForErrors = renderedUrl;
          }
          let requestBody;
          if (bodyTemplate) {
            let resolvedBody = String(EnvironmentResolver.resolveValue(bodyTemplate));
            if (resolvedBody.includes("{{") || resolvedBody.includes("{%")) {
              resolvedBody = await this.liquid.parseAndRender(resolvedBody, templateContext);
            }
            requestBody = resolvedBody;
          }
          const resolvedHeaders = {};
          for (const [key, value] of Object.entries(headers)) {
            let resolvedValue = String(EnvironmentResolver.resolveValue(value));
            if (resolvedValue.includes("{{") || resolvedValue.includes("{%")) {
              resolvedValue = await this.liquid.parseAndRender(resolvedValue, templateContext);
            }
            resolvedHeaders[key] = resolvedValue;
            if (key.toLowerCase() === "authorization") {
              const maskedValue = resolvedValue.length > 20 ? `${resolvedValue.substring(0, 15)}...${resolvedValue.substring(resolvedValue.length - 5)}` : resolvedValue;
              logger.verbose(`[http_client] ${key}: ${maskedValue}`);
            }
          }
          let resolvedOutputFile;
          if (outputFileTemplate) {
            let outputPath = String(EnvironmentResolver.resolveValue(outputFileTemplate));
            if (outputPath.includes("{{") || outputPath.includes("{%")) {
              outputPath = await this.liquid.parseAndRender(outputPath, templateContext);
            }
            resolvedOutputFile = outputPath.trim();
            const parentContext = context2?._parentContext;
            const workingDirectory = parentContext?.workingDirectory;
            const workspaceEnabled = parentContext?.workspace?.isEnabled?.();
            if (workspaceEnabled && workingDirectory && !path8.isAbsolute(resolvedOutputFile)) {
              resolvedOutputFile = path8.join(workingDirectory, resolvedOutputFile);
              logger.debug(
                `[http_client] Resolved relative output_file to workspace: ${resolvedOutputFile}`
              );
            }
            if (skipIfExists && fs6.existsSync(resolvedOutputFile)) {
              const stats = fs6.statSync(resolvedOutputFile);
              logger.verbose(`[http_client] File cached: ${resolvedOutputFile} (${stats.size} bytes)`);
              return {
                issues: [],
                file_path: resolvedOutputFile,
                size: stats.size,
                cached: true
              };
            }
          }
          const stepName = config.checkName || "unknown";
          const mock = context2?.hooks?.mockForStep?.(String(stepName));
          if (mock !== void 0) {
            const mockObj = typeof mock === "object" && mock !== null ? mock : { data: mock };
            return {
              issues: [],
              ...mockObj
            };
          }
          logger.verbose(`[http_client] ${method} ${renderedUrl}`);
          if (requestBody) {
            logger.verbose(
              `[http_client] Body: ${requestBody.substring(0, 500)}${requestBody.length > 500 ? "..." : ""}`
            );
          }
          if (resolvedOutputFile) {
            const fileResult = await this.downloadToFile(
              renderedUrl,
              method,
              resolvedHeaders,
              requestBody,
              timeout,
              resolvedOutputFile
            );
            return fileResult;
          }
          const data = await this.fetchData(renderedUrl, method, resolvedHeaders, requestBody, timeout);
          let processedData = data;
          if (transform) {
            try {
              const transformContext = {
                response: data,
                pr: templateContext.pr,
                outputs: templateContext.outputs
              };
              const rendered = await this.liquid.parseAndRender(transform, transformContext);
              if (rendered.trim().startsWith("{") || rendered.trim().startsWith("[")) {
                processedData = JSON.parse(rendered);
              } else {
                processedData = rendered;
              }
            } catch (error) {
              return {
                issues: [
                  {
                    file: "http_client",
                    line: 0,
                    ruleId: "http_client/transform_error",
                    message: `Failed to transform response data: ${error instanceof Error ? error.message : "Unknown error"}`,
                    severity: "error",
                    category: "logic"
                  }
                ]
              };
            }
          }
          if (transformJs) {
            try {
              this.sandbox = this.createSecureSandbox();
              const jsScope = {
                output: data,
                pr: templateContext.pr,
                outputs: templateContext.outputs,
                env: process.env
              };
              const result = compileAndRun(this.sandbox, transformJs, jsScope, {
                injectLog: true,
                logPrefix: "\u{1F50D} [transform_js]",
                wrapFunction: true
              });
              processedData = result;
              logger.verbose(`\u2713 Applied JavaScript transform successfully`);
            } catch (error) {
              logger.error(
                `\u2717 Failed to apply JavaScript transform: ${error instanceof Error ? error.message : "Unknown error"}`
              );
              return {
                issues: [
                  {
                    file: "http_client",
                    line: 0,
                    ruleId: "http_client/transform_js_error",
                    message: `Failed to apply JavaScript transform: ${error instanceof Error ? error.message : "Unknown error"}`,
                    severity: "error",
                    category: "logic"
                  }
                ]
              };
            }
          }
          return {
            issues: [],
            output: processedData
          };
        } catch (error) {
          return {
            issues: [
              {
                file: "http_client",
                line: 0,
                ruleId: "http_client/fetch_error",
                message: `Failed to fetch from ${resolvedUrlForErrors}: ${error instanceof Error ? error.message : "Unknown error"}`,
                severity: "error",
                category: "logic"
              }
            ]
          };
        }
      }
      async fetchData(url, method, headers, body, timeout = 3e4) {
        if (typeof fetch === "undefined") {
          throw new Error("HTTP client provider requires Node.js 18+ or node-fetch package");
        }
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        try {
          const requestOptions = {
            method,
            headers: {
              ...headers
            },
            signal: controller.signal
          };
          if (method !== "GET" && body) {
            requestOptions.body = body;
            if (!headers["Content-Type"] && !headers["content-type"]) {
              requestOptions.headers = {
                ...requestOptions.headers,
                "Content-Type": "application/json"
              };
            }
          }
          const response = await fetch(url, requestOptions);
          clearTimeout(timeoutId);
          logger.verbose(`[http_client] Response: ${response.status} ${response.statusText}`);
          if (!response.ok) {
            try {
              const errorBody = await response.text();
              logger.warn(`[http_client] Error body: ${errorBody.substring(0, 500)}`);
            } catch {
            }
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          const contentType = response.headers.get("content-type");
          if (contentType && contentType.includes("application/json")) {
            return await response.json();
          }
          const text = await response.text();
          if (text.trim().startsWith("{") || text.trim().startsWith("[")) {
            try {
              return JSON.parse(text);
            } catch {
              return text;
            }
          }
          return text;
        } catch (error) {
          clearTimeout(timeoutId);
          if (error instanceof Error && error.name === "AbortError") {
            throw new Error(`Request timed out after ${timeout}ms`);
          }
          throw error;
        }
      }
      async downloadToFile(url, method, headers, body, timeout, outputFile) {
        if (typeof fetch === "undefined") {
          throw new Error("HTTP client provider requires Node.js 18+ or node-fetch package");
        }
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        try {
          const requestOptions = {
            method,
            headers: { ...headers },
            signal: controller.signal
          };
          if (method !== "GET" && body) {
            requestOptions.body = body;
            if (!headers["Content-Type"] && !headers["content-type"]) {
              requestOptions.headers = {
                ...requestOptions.headers,
                "Content-Type": "application/json"
              };
            }
          }
          const response = await fetch(url, requestOptions);
          clearTimeout(timeoutId);
          if (!response.ok) {
            return {
              issues: [
                {
                  file: "http_client",
                  line: 0,
                  ruleId: "http_client/download_error",
                  message: `Failed to download file: HTTP ${response.status}: ${response.statusText}`,
                  severity: "error",
                  category: "logic"
                }
              ]
            };
          }
          const parentDir = path8.dirname(outputFile);
          if (parentDir && !fs6.existsSync(parentDir)) {
            fs6.mkdirSync(parentDir, { recursive: true });
          }
          const arrayBuffer = await response.arrayBuffer();
          const buffer = Buffer.from(arrayBuffer);
          fs6.writeFileSync(outputFile, buffer);
          const contentType = response.headers.get("content-type") || "application/octet-stream";
          logger.verbose(`[http_client] Downloaded: ${outputFile} (${buffer.length} bytes)`);
          return {
            issues: [],
            file_path: outputFile,
            size: buffer.length,
            content_type: contentType,
            cached: false
          };
        } catch (error) {
          clearTimeout(timeoutId);
          if (error instanceof Error && error.name === "AbortError") {
            return {
              issues: [
                {
                  file: "http_client",
                  line: 0,
                  ruleId: "http_client/download_timeout",
                  message: `Download timed out after ${timeout}ms`,
                  severity: "error",
                  category: "logic"
                }
              ]
            };
          }
          return {
            issues: [
              {
                file: "http_client",
                line: 0,
                ruleId: "http_client/download_error",
                message: `Failed to download file: ${error instanceof Error ? error.message : "Unknown error"}`,
                severity: "error",
                category: "logic"
              }
            ]
          };
        }
      }
      getSupportedConfigKeys() {
        return [
          "type",
          "url",
          "method",
          "headers",
          "body",
          "transform",
          "transform_js",
          "timeout",
          "output_file",
          "skip_if_exists",
          "depends_on",
          "on",
          "if",
          "group",
          "schedule"
        ];
      }
      async isAvailable() {
        return typeof fetch !== "undefined";
      }
      getRequirements() {
        return [
          "Valid HTTP/HTTPS URL to fetch from",
          "Network access to the endpoint",
          "Optional: Transform template for processing response data",
          "Optional: Body template for POST/PUT requests",
          "Optional: output_file path to download response to a file",
          "Optional: skip_if_exists (default: true) to enable caching for file downloads"
        ];
      }
    };
  }
});

// src/providers/noop-check-provider.ts
var NoopCheckProvider;
var init_noop_check_provider = __esm({
  "src/providers/noop-check-provider.ts"() {
    "use strict";
    init_check_provider_interface();
    NoopCheckProvider = class extends CheckProvider {
      getName() {
        return "noop";
      }
      getDescription() {
        return "No-operation provider for command orchestration and dependency triggering";
      }
      async validateConfig(config) {
        if (!config || typeof config !== "object") {
          return false;
        }
        const cfg = config;
        if (cfg.type !== "noop") {
          return false;
        }
        return true;
      }
      async execute(_prInfo, _config, _dependencyResults, _sessionInfo) {
        return {
          issues: []
        };
      }
      getSupportedConfigKeys() {
        return ["type", "command", "depends_on", "on", "if", "group"];
      }
      async isAvailable() {
        return true;
      }
      getRequirements() {
        return [
          "No external dependencies required",
          "Used for command orchestration and dependency triggering"
        ];
      }
    };
  }
});

// src/providers/log-check-provider.ts
var LogCheckProvider;
var init_log_check_provider = __esm({
  "src/providers/log-check-provider.ts"() {
    "use strict";
    init_check_provider_interface();
    init_liquid_extensions();
    init_logger();
    LogCheckProvider = class extends CheckProvider {
      liquid;
      constructor() {
        super();
        this.liquid = createExtendedLiquid({
          strictVariables: false,
          strictFilters: false
        });
      }
      getName() {
        return "log";
      }
      getDescription() {
        return "Output debugging and logging information for troubleshooting check workflows";
      }
      async validateConfig(config) {
        if (!config || typeof config !== "object") {
          return false;
        }
        const cfg = config;
        if (cfg.type !== "log") {
          return false;
        }
        if (!cfg.message || typeof cfg.message !== "string") {
          return false;
        }
        if (cfg.level && !["debug", "info", "warn", "error"].includes(cfg.level)) {
          return false;
        }
        return true;
      }
      async execute(prInfo, config, dependencyResults, context2) {
        const message = config.message;
        const level = config.level || "info";
        const includePrContext = config.include_pr_context !== false;
        const includeDependencies = config.include_dependencies !== false;
        const includeMetadata = config.include_metadata !== false;
        const templateContext = this.buildTemplateContext(
          prInfo,
          dependencyResults,
          includePrContext,
          includeDependencies,
          includeMetadata,
          config.__outputHistory,
          context2,
          config
        );
        const renderedMessage = await this.liquid.parseAndRender(message, templateContext);
        const logOutput = this.formatLogOutput(
          level,
          renderedMessage,
          templateContext,
          includePrContext,
          includeDependencies,
          includeMetadata
        );
        if (level === "error") logger.error(logOutput);
        else if (level === "warn") logger.warn(logOutput);
        else if (level === "debug") logger.debug(logOutput);
        else logger.info(logOutput);
        const summary = {
          issues: [],
          logOutput
        };
        if (config.group === "chat") {
          summary.output = { text: renderedMessage };
        }
        return summary;
      }
      buildTemplateContext(prInfo, dependencyResults, _includePrContext = true, _includeDependencies = true, includeMetadata = true, outputHistory, executionContext, config) {
        const context2 = {};
        context2.pr = {
          number: prInfo.number,
          title: prInfo.title,
          body: prInfo.body,
          author: prInfo.author,
          base: prInfo.base,
          head: prInfo.head,
          totalAdditions: prInfo.totalAdditions,
          totalDeletions: prInfo.totalDeletions,
          files: prInfo.files.map((f) => ({
            filename: f.filename,
            status: f.status,
            additions: f.additions,
            deletions: f.deletions,
            changes: f.changes
          }))
        };
        context2.filenames = prInfo.files.map((f) => f.filename);
        context2.fileCount = prInfo.files.length;
        if (dependencyResults) {
          const dependencies = {};
          const outputs = {};
          const outputsRaw = {};
          const history = {};
          context2.dependencyCount = dependencyResults.size;
          for (const [checkName, result] of dependencyResults.entries()) {
            if (typeof checkName !== "string") continue;
            dependencies[checkName] = {
              issueCount: result.issues?.length || 0,
              suggestionCount: 0,
              issues: result.issues || []
            };
            const summary = result;
            if (typeof checkName === "string" && checkName.endsWith("-raw")) {
              const name = checkName.slice(0, -4);
              outputsRaw[name] = summary.output !== void 0 ? summary.output : summary;
            } else {
              outputs[checkName] = summary.output !== void 0 ? summary.output : summary;
            }
          }
          if (outputHistory) {
            for (const [checkName, historyArray] of outputHistory) {
              history[checkName] = historyArray;
            }
          }
          outputs.history = history;
          context2.dependencies = dependencies;
          context2.outputs = outputs;
          context2.outputs_history = history;
          context2.outputs_raw = outputsRaw;
        }
        if (includeMetadata) {
          context2.metadata = {
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            executionTime: Date.now(),
            nodeVersion: process.version,
            platform: process.platform,
            workingDirectory: process.cwd()
          };
        }
        const workflowInputs = config?.workflowInputs || executionContext?.workflowInputs || {};
        logger.debug(
          `[LogProvider] Adding ${Object.keys(workflowInputs).length} workflow inputs to context`
        );
        context2.inputs = workflowInputs;
        return context2;
      }
      formatLogOutput(level, message, templateContext, includePrContext, includeDependencies, includeMetadata) {
        const sections = [];
        const levelEmoji = this.getLevelEmoji(level);
        sections.push(`${levelEmoji} **${level.toUpperCase()}**: ${message}`);
        if (includePrContext && templateContext.pr) {
          const pr = templateContext.pr;
          sections.push("");
          sections.push("### PR Context");
          sections.push(`- **PR #${pr.number}**: ${pr.title}`);
          sections.push(`- **Author**: ${pr.author}`);
          sections.push(`- **Base**: ${pr.base} \u2192 **Head**: ${pr.head}`);
          sections.push(`- **Changes**: +${pr.totalAdditions} -${pr.totalDeletions}`);
          sections.push(`- **Files Modified**: ${templateContext.fileCount}`);
        }
        if (includeDependencies && templateContext.dependencies) {
          const deps = templateContext.dependencies;
          sections.push("");
          sections.push("### Dependency Results");
          if (Object.keys(deps).length === 0) {
            sections.push("- No dependency results available");
          } else {
            for (const [checkName, result] of Object.entries(deps)) {
              sections.push(
                `- **${checkName}**: ${result.issueCount} issues, ${result.suggestionCount} suggestions`
              );
            }
          }
        }
        if (includeMetadata && templateContext.metadata) {
          const meta = templateContext.metadata;
          sections.push("");
          sections.push("### Execution Metadata");
          sections.push(`- **Timestamp**: ${meta.timestamp}`);
          sections.push(`- **Node Version**: ${meta.nodeVersion}`);
          sections.push(`- **Platform**: ${meta.platform}`);
          sections.push(`- **Working Directory**: ${meta.workingDirectory}`);
        }
        return sections.join("\n");
      }
      getLevelEmoji(level) {
        switch (level) {
          case "debug":
            return "\u{1F41B}";
          case "info":
            return "\u2139\uFE0F";
          case "warn":
            return "\u26A0\uFE0F";
          case "error":
            return "\u274C";
          default:
            return "\u2139\uFE0F";
        }
      }
      getSupportedConfigKeys() {
        return [
          "type",
          "message",
          "level",
          "include_pr_context",
          "include_dependencies",
          "include_metadata",
          "group",
          "command",
          "depends_on",
          "on",
          "if"
        ];
      }
      async isAvailable() {
        return true;
      }
      getRequirements() {
        return [
          "No external dependencies required",
          "Used for debugging and logging check execution flow"
        ];
      }
    };
  }
});

// src/test-runner/recorders/global-recorder.ts
var global_recorder_exports = {};
__export(global_recorder_exports, {
  getGlobalRecorder: () => getGlobalRecorder,
  setGlobalRecorder: () => setGlobalRecorder
});
function setGlobalRecorder(r) {
  __rec = r;
}
function getGlobalRecorder() {
  return __rec;
}
var __rec;
var init_global_recorder = __esm({
  "src/test-runner/recorders/global-recorder.ts"() {
    "use strict";
    __rec = null;
  }
});

// src/providers/github-ops-provider.ts
var GitHubOpsProvider;
var init_github_ops_provider = __esm({
  "src/providers/github-ops-provider.ts"() {
    "use strict";
    init_check_provider_interface();
    init_sandbox();
    init_liquid_extensions();
    init_logger();
    GitHubOpsProvider = class extends CheckProvider {
      sandbox;
      getName() {
        return "github";
      }
      getDescription() {
        return "Native GitHub operations (labels, comments, reviewers) executed via Octokit";
      }
      async validateConfig(config) {
        if (!config || typeof config !== "object") return false;
        const cfg = config;
        return typeof cfg.op === "string" && cfg.op.length > 0;
      }
      getSupportedConfigKeys() {
        return ["op", "values", "value"];
      }
      async isAvailable() {
        return Boolean(
          process.env.GITHUB_TOKEN || process.env["INPUT_GITHUB-TOKEN"] || process.env.GITHUB_REPOSITORY
        );
      }
      getRequirements() {
        return ["GITHUB_TOKEN or INPUT_GITHUB-TOKEN", "GITHUB_REPOSITORY"];
      }
      async execute(prInfo, config, dependencyResults) {
        const cfg = config;
        let octokit = config.eventContext?.octokit;
        if (process.env.VISOR_DEBUG === "true") {
          try {
            logger.debug(`[github-ops] pre-fallback octokit? ${!!octokit}`);
          } catch {
          }
        }
        if (!octokit) {
          try {
            const { getGlobalRecorder: getGlobalRecorder2 } = (init_global_recorder(), __toCommonJS(global_recorder_exports));
            const rec = getGlobalRecorder2 && getGlobalRecorder2();
            if (rec) octokit = rec;
          } catch {
          }
        }
        if (!octokit) {
          if (process.env.VISOR_DEBUG === "true") {
            try {
              console.error("[github-ops] missing octokit after fallback \u2014 returning issue");
            } catch {
            }
          }
          return {
            issues: [
              {
                file: "system",
                line: 0,
                ruleId: "github/missing_octokit",
                message: "No authenticated Octokit instance available in event context. GitHub operations require proper authentication context.",
                severity: "error",
                category: "logic"
              }
            ]
          };
        }
        const repoEnv = process.env.GITHUB_REPOSITORY || "";
        let owner = "";
        let repo = "";
        if (repoEnv.includes("/")) {
          [owner, repo] = repoEnv.split("/");
        } else {
          try {
            const ec = config.eventContext || {};
            owner = ec?.repository?.owner?.login || owner;
            repo = ec?.repository?.name || repo;
          } catch {
          }
        }
        try {
          if (process.env.VISOR_DEBUG === "true") {
            logger.info(
              `[github-ops] context octokit? ${!!octokit} repo=${owner}/${repo} pr#=${prInfo?.number}`
            );
          }
        } catch {
        }
        if (!owner || !repo || !prInfo?.number) {
          return {
            issues: [
              {
                file: "system",
                line: 0,
                ruleId: "github/missing_context",
                message: "Missing owner/repo or PR number; GitHub operations require Action context",
                severity: "error",
                category: "logic"
              }
            ]
          };
        }
        let valuesRaw = [];
        if (Array.isArray(cfg.values)) valuesRaw = cfg.values.map((v) => String(v));
        else if (typeof cfg.values === "string") valuesRaw = [cfg.values];
        else if (typeof cfg.value === "string") valuesRaw = [cfg.value];
        try {
          if (process.env.VISOR_DEBUG === "true") {
            logger.info(`[github-ops] op=${cfg.op} valuesRaw(before)=${JSON.stringify(valuesRaw)}`);
          }
        } catch {
        }
        const renderValues = async (arr) => {
          if (!arr || arr.length === 0) return [];
          const liq = createExtendedLiquid({
            cache: false,
            strictFilters: false,
            strictVariables: false
          });
          const outputs = {};
          if (dependencyResults) {
            for (const [name, result] of dependencyResults.entries()) {
              const summary = result;
              outputs[name] = summary.output !== void 0 ? summary.output : summary;
            }
          }
          try {
            const hist = config.__outputHistory;
            if (hist) {
              for (const [name, arr2] of hist.entries()) {
                if (!outputs[name] && Array.isArray(arr2) && arr2.length > 0) {
                  outputs[name] = arr2[arr2.length - 1];
                }
              }
            }
          } catch {
          }
          const ctx = {
            pr: {
              number: prInfo.number,
              title: prInfo.title,
              author: prInfo.author,
              branch: prInfo.head,
              base: prInfo.base,
              authorAssociation: prInfo.authorAssociation
            },
            outputs
          };
          try {
            if (process.env.VISOR_DEBUG === "true") {
              logger.info(`[github-ops] deps keys=${Object.keys(outputs).join(", ")}`);
              const ov = outputs["overview"];
              if (ov) {
                logger.info(`[github-ops] outputs.overview.keys=${Object.keys(ov).join(",")}`);
                if (ov.tags) {
                  logger.info(
                    `[github-ops] outputs.overview.tags keys=${Object.keys(ov.tags).join(",")}`
                  );
                  try {
                    logger.info(
                      `[github-ops] outputs.overview.tags['review-effort']=${String(ov.tags["review-effort"])}`
                    );
                  } catch {
                  }
                }
              }
            }
          } catch {
          }
          const out = [];
          for (const item of arr) {
            if (typeof item === "string" && (item.includes("{{") || item.includes("{%"))) {
              try {
                const rendered = await liq.parseAndRender(item, ctx);
                out.push(rendered);
              } catch (e) {
                const msg = e instanceof Error ? e.message : String(e);
                if (process.env.VISOR_DEBUG === "true") {
                  logger.warn(`[github-ops] liquid_render_error: ${msg}`);
                }
                return Promise.reject({
                  issues: [
                    {
                      file: "system",
                      line: 0,
                      ruleId: "github/liquid_render_error",
                      message: `Failed to render template: ${msg}`,
                      severity: "error",
                      category: "logic"
                    }
                  ]
                });
              }
            } else {
              out.push(String(item));
            }
          }
          return out;
        };
        let values = await renderValues(valuesRaw);
        try {
          const flattened = [];
          for (const v of values) {
            const t = String(v ?? "").trim();
            if (!t) continue;
            let expanded = false;
            if (t.startsWith("[") && t.endsWith("]")) {
              try {
                const arr = JSON.parse(t);
                if (Array.isArray(arr)) {
                  for (const x of arr) flattened.push(String(x ?? ""));
                  expanded = true;
                }
              } catch {
              }
            }
            if (expanded) continue;
            if (t.includes("\n")) {
              for (const line of t.split("\n")) {
                const s = line.trim();
                if (s) flattened.push(s);
              }
              expanded = true;
            }
            if (!expanded) flattened.push(t);
          }
          values = flattened;
        } catch {
        }
        const depOutputs = {};
        if (dependencyResults) {
          for (const [name, result] of dependencyResults.entries()) {
            const summary = result;
            depOutputs[name] = summary.output !== void 0 ? summary.output : summary;
          }
        }
        const sanitizeLabel = (s) => s.replace(/[^A-Za-z0-9:\/\- ]/g, "").replace(/\/{2,}/g, "/").trim();
        values = (Array.isArray(values) ? values : []).map((v) => String(v ?? "")).map(sanitizeLabel).filter(Boolean);
        if (values.length === 0 && Object.keys(depOutputs).length > 0) {
          try {
            const lbls = [];
            for (const obj of Object.values(depOutputs)) {
              const labelsAny = obj?.labels;
              if (Array.isArray(labelsAny)) {
                for (const v of labelsAny) lbls.push(String(v ?? ""));
              }
            }
            const norm = lbls.map((s) => s.trim()).filter(Boolean).map((s) => s.replace(/[^A-Za-z0-9:\/\- ]/g, "").replace(/\/{2,}/g, "/"));
            values = Array.from(new Set(norm));
            if (process.env.VISOR_DEBUG === "true") {
              logger.info(`[github-ops] derived values from deps.labels: ${JSON.stringify(values)}`);
            }
          } catch {
          }
        }
        if (values.length === 0 && dependencyResults && dependencyResults.size > 0) {
          try {
            const derived = [];
            for (const result of dependencyResults.values()) {
              const out = result?.output ?? result;
              const tags = out?.["tags"];
              if (tags && typeof tags === "object") {
                const label = tags["label"];
                const effort = tags["review-effort"];
                if (label != null) derived.push(String(label));
                if (effort !== void 0 && effort !== null)
                  derived.push(`review/effort:${String(effort)}`);
              }
            }
            values = derived;
            if (process.env.VISOR_DEBUG === "true") {
              logger.info(`[github-ops] derived values from deps: ${JSON.stringify(values)}`);
            }
          } catch {
          }
        }
        values = Array.from(new Set(values));
        try {
          if (process.env.NODE_ENV === "test" || process.env.VISOR_DEBUG === "true") {
            logger.info(`[github-ops] ${cfg.op} resolved values: ${JSON.stringify(values)}`);
          }
        } catch {
        }
        try {
          switch (cfg.op) {
            case "labels.add": {
              if (values.length === 0) break;
              try {
                if (process.env.VISOR_OUTPUT_FORMAT !== "json")
                  logger.step(`[github-ops] labels.add -> ${JSON.stringify(values)}`);
              } catch {
              }
              await octokit.rest.issues.addLabels({
                owner,
                repo,
                issue_number: prInfo.number,
                labels: values
              });
              break;
            }
            case "labels.remove": {
              for (const l of values) {
                await octokit.rest.issues.removeLabel({
                  owner,
                  repo,
                  issue_number: prInfo.number,
                  name: l
                });
              }
              break;
            }
            case "comment.create": {
              const body = values.join("\n").trim();
              if (body)
                await octokit.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: prInfo.number,
                  body
                });
              break;
            }
            default:
              return {
                issues: [
                  {
                    file: "system",
                    line: 0,
                    ruleId: "github/unsupported_op",
                    message: `Unsupported GitHub op: ${cfg.op}`,
                    severity: "error",
                    category: "logic"
                  }
                ]
              };
          }
          return { issues: [] };
        } catch (e) {
          const msg = e instanceof Error ? e.message : String(e);
          try {
            logger.error(`[github-ops] op_failed ${cfg.op}: ${msg}`);
          } catch {
          }
          return {
            issues: [
              {
                file: "system",
                line: 0,
                ruleId: "github/op_failed",
                message: `GitHub operation failed (${cfg.op}): ${msg}`,
                severity: "error",
                category: "logic"
              }
            ]
          };
        }
      }
      /**
       * Create a secure sandbox for evaluating small expressions without access to process/env
       */
      getSecureSandbox() {
        if (this.sandbox) return this.sandbox;
        this.sandbox = createSecureSandbox();
        return this.sandbox;
      }
    };
  }
});

// src/providers/claude-code-types.ts
async function safeImport(moduleName) {
  try {
    return await import(moduleName);
  } catch {
    return null;
  }
}
var init_claude_code_types = __esm({
  "src/providers/claude-code-types.ts"() {
    "use strict";
  }
});

// src/providers/claude-code-check-provider.ts
import fs7 from "fs/promises";
import path9 from "path";
function isClaudeCodeConstructor(value) {
  return typeof value === "function";
}
var ClaudeCodeSDKNotInstalledError, ClaudeCodeAPIKeyMissingError, ClaudeCodeCheckProvider;
var init_claude_code_check_provider = __esm({
  "src/providers/claude-code-check-provider.ts"() {
    "use strict";
    init_check_provider_interface();
    init_env_resolver();
    init_issue_filter();
    init_liquid_extensions();
    init_claude_code_types();
    ClaudeCodeSDKNotInstalledError = class extends Error {
      constructor() {
        super(
          "Claude Code SDK is not installed. Install with: npm install @anthropic/claude-code-sdk @modelcontextprotocol/sdk"
        );
        this.name = "ClaudeCodeSDKNotInstalledError";
      }
    };
    ClaudeCodeAPIKeyMissingError = class extends Error {
      constructor() {
        super(
          "No API key found for Claude Code provider. Set CLAUDE_CODE_API_KEY or ANTHROPIC_API_KEY environment variable."
        );
        this.name = "ClaudeCodeAPIKeyMissingError";
      }
    };
    ClaudeCodeCheckProvider = class extends CheckProvider {
      liquidEngine;
      claudeCodeClient = null;
      constructor() {
        super();
        this.liquidEngine = createExtendedLiquid();
      }
      getName() {
        return "claude-code";
      }
      getDescription() {
        return "AI-powered code review using Claude Code with MCP tools support";
      }
      async validateConfig(config) {
        if (!config || typeof config !== "object") {
          return false;
        }
        const cfg = config;
        if (cfg.type !== "claude-code") {
          return false;
        }
        if (!cfg.prompt || typeof cfg.prompt !== "string") {
          return false;
        }
        if (cfg.claude_code) {
          const claudeCodeConfig = cfg.claude_code;
          if (claudeCodeConfig.allowedTools && !Array.isArray(claudeCodeConfig.allowedTools)) {
            return false;
          }
          if (claudeCodeConfig.maxTurns && typeof claudeCodeConfig.maxTurns !== "number") {
            return false;
          }
          if (claudeCodeConfig.systemPrompt && typeof claudeCodeConfig.systemPrompt !== "string") {
            return false;
          }
          if (claudeCodeConfig.mcpServers) {
            if (typeof claudeCodeConfig.mcpServers !== "object") {
              return false;
            }
            for (const serverConfig of Object.values(claudeCodeConfig.mcpServers)) {
              if (!serverConfig.command || typeof serverConfig.command !== "string") {
                return false;
              }
              if (serverConfig.args && !Array.isArray(serverConfig.args)) {
                return false;
              }
            }
          }
        }
        return true;
      }
      /**
       * Initialize Claude Code SDK client
       */
      async initializeClaudeCodeClient() {
        if (this.claudeCodeClient) {
          return this.claudeCodeClient;
        }
        const claudeCodeModule = await safeImport("@anthropic/claude-code-sdk");
        if (!claudeCodeModule) {
          throw new ClaudeCodeSDKNotInstalledError();
        }
        const ClaudeCodeCtor = claudeCodeModule.ClaudeCode || claudeCodeModule.default?.ClaudeCode;
        if (!isClaudeCodeConstructor(ClaudeCodeCtor)) {
          throw new Error("ClaudeCode class not found in @anthropic/claude-code-sdk");
        }
        const apiKey = process.env.CLAUDE_CODE_API_KEY || process.env.ANTHROPIC_API_KEY;
        if (!apiKey) {
          throw new ClaudeCodeAPIKeyMissingError();
        }
        try {
          const client = new ClaudeCodeCtor({
            apiKey
          });
          this.claudeCodeClient = client;
          return client;
        } catch (error) {
          throw new Error(
            `Failed to initialize Claude Code SDK: ${error instanceof Error ? error.message : "Unknown error"}`
          );
        }
      }
      /**
       * Group files by their file extension for template context
       */
      groupFilesByExtension(files) {
        const grouped = {};
        files.forEach((file) => {
          const parts = file.filename.split(".");
          const ext = parts.length > 1 ? parts.pop()?.toLowerCase() || "noext" : "noext";
          if (!grouped[ext]) {
            grouped[ext] = [];
          }
          grouped[ext].push(file);
        });
        return grouped;
      }
      /**
       * Process prompt configuration to resolve final prompt string
       */
      async processPrompt(promptConfig, prInfo, eventContext, dependencyResults) {
        let promptContent;
        if (await this.isFilePath(promptConfig)) {
          promptContent = await this.loadPromptFromFile(promptConfig);
        } else {
          promptContent = promptConfig;
        }
        return await this.renderPromptTemplate(promptContent, prInfo, eventContext, dependencyResults);
      }
      /**
       * Detect if a string is likely a file path and if the file exists
       */
      async isFilePath(str) {
        if (!str || str.trim() !== str || str.length > 512) {
          return false;
        }
        if (/\s{2,}/.test(str) || // Multiple consecutive spaces
        /\n/.test(str) || // Contains newlines
        /^(please|analyze|review|check|find|identify|look|search)/i.test(str.trim()) || // Starts with command words
        str.split(" ").length > 8) {
          return false;
        }
        if (!/[\/\\]/.test(str)) {
          if (/\b(the|and|or|but|for|with|by|from|in|on|at|as)\b/i.test(str)) {
            return false;
          }
        }
        const hasFileExtension = /\.[a-zA-Z0-9]{1,10}$/i.test(str);
        const hasPathSeparators = /[\/\\]/.test(str);
        const isRelativePath = /^\.{1,2}\//.test(str);
        const isAbsolutePath = path9.isAbsolute(str);
        const hasTypicalFileChars = /^[a-zA-Z0-9._\-\/\\:~]+$/.test(str);
        if (!(hasFileExtension || isRelativePath || isAbsolutePath || hasPathSeparators)) {
          return false;
        }
        if (!hasTypicalFileChars) {
          return false;
        }
        try {
          let resolvedPath;
          if (path9.isAbsolute(str)) {
            resolvedPath = path9.normalize(str);
          } else {
            resolvedPath = path9.resolve(process.cwd(), str);
          }
          try {
            const stat = await fs7.stat(resolvedPath);
            return stat.isFile();
          } catch {
            return hasFileExtension && (isRelativePath || isAbsolutePath || hasPathSeparators);
          }
        } catch {
          return false;
        }
      }
      /**
       * Load prompt content from file with security validation
       */
      async loadPromptFromFile(promptPath) {
        if (!promptPath.endsWith(".liquid")) {
          throw new Error("Prompt file must have .liquid extension");
        }
        let resolvedPath;
        if (path9.isAbsolute(promptPath)) {
          resolvedPath = promptPath;
        } else {
          resolvedPath = path9.resolve(process.cwd(), promptPath);
        }
        if (!path9.isAbsolute(promptPath)) {
          const normalizedPath = path9.normalize(resolvedPath);
          const currentDir = path9.resolve(process.cwd());
          if (!normalizedPath.startsWith(currentDir)) {
            throw new Error("Invalid prompt file path: path traversal detected");
          }
        }
        if (promptPath.includes("../..")) {
          throw new Error("Invalid prompt file path: path traversal detected");
        }
        try {
          const promptContent = await fs7.readFile(resolvedPath, "utf-8");
          return promptContent;
        } catch (error) {
          throw new Error(
            `Failed to load prompt from ${resolvedPath}: ${error instanceof Error ? error.message : "Unknown error"}`
          );
        }
      }
      /**
       * Render Liquid template in prompt with comprehensive context
       */
      async renderPromptTemplate(promptContent, prInfo, eventContext, dependencyResults) {
        const templateContext = {
          // PR Information
          pr: {
            number: prInfo.number,
            title: prInfo.title,
            body: prInfo.body,
            author: prInfo.author,
            baseBranch: prInfo.base,
            headBranch: prInfo.head,
            isIncremental: prInfo.isIncremental,
            filesChanged: prInfo.files?.map((f) => f.filename) || [],
            totalAdditions: prInfo.files?.reduce((sum, f) => sum + f.additions, 0) || 0,
            totalDeletions: prInfo.files?.reduce((sum, f) => sum + f.deletions, 0) || 0,
            totalChanges: prInfo.files?.reduce((sum, f) => sum + f.changes, 0) || 0,
            base: prInfo.base,
            head: prInfo.head
          },
          // File Details
          files: prInfo.files || [],
          description: prInfo.body || "",
          // GitHub Event Context
          event: eventContext ? {
            name: eventContext.event_name || "unknown",
            action: eventContext.action,
            isPullRequest: !prInfo.isIssue,
            // Repository Info
            repository: eventContext.repository ? {
              owner: eventContext.repository?.owner?.login,
              name: eventContext.repository?.name,
              fullName: eventContext.repository ? `${eventContext.repository?.owner?.login}/${eventContext.repository?.name}` : void 0
            } : void 0,
            // Comment Data (for comment events)
            comment: eventContext.comment ? {
              body: eventContext.comment?.body,
              author: eventContext.comment?.user?.login
            } : void 0,
            // Raw event payload for advanced use cases
            payload: eventContext
          } : void 0,
          // Utility data for templates
          utils: {
            // Date/time helpers
            now: (/* @__PURE__ */ new Date()).toISOString(),
            today: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
            // Dynamic file grouping by extension
            filesByExtension: this.groupFilesByExtension(prInfo.files || []),
            // File status categorizations
            addedFiles: (prInfo.files || []).filter((f) => f.status === "added"),
            modifiedFiles: (prInfo.files || []).filter((f) => f.status === "modified"),
            removedFiles: (prInfo.files || []).filter((f) => f.status === "removed"),
            renamedFiles: (prInfo.files || []).filter((f) => f.status === "renamed"),
            // Change analysis
            hasLargeChanges: (prInfo.files || []).some((f) => f.changes > 50),
            totalFiles: (prInfo.files || []).length
          },
          // Previous check outputs (dependency results)
          // Expose raw output directly if available, otherwise expose the result as-is
          outputs: dependencyResults ? Object.fromEntries(
            Array.from(dependencyResults.entries()).map(([checkName, result]) => [
              checkName,
              // If the result has a direct output field, use it directly
              // Otherwise, expose the entire result
              (() => {
                const summary = result;
                return summary.output !== void 0 ? summary.output : summary;
              })()
            ])
          ) : {}
        };
        try {
          return await this.liquidEngine.parseAndRender(promptContent, templateContext);
        } catch (error) {
          throw new Error(
            `Failed to render prompt template: ${error instanceof Error ? error.message : "Unknown error"}`
          );
        }
      }
      /**
       * Parse structured response from Claude Code
       */
      parseStructuredResponse(content) {
        try {
          const parsed = JSON.parse(content);
          return {
            issues: parsed.issues || []
          };
        } catch {
          return {
            issues: []
          };
        }
      }
      async execute(prInfo, config, dependencyResults, sessionInfo) {
        if (config.env) {
          const result = EnvironmentResolver.withTemporaryEnv(config.env, () => {
            return this.executeWithConfig(prInfo, config, dependencyResults, sessionInfo);
          });
          if (result instanceof Promise) {
            return result;
          }
          return result;
        }
        return this.executeWithConfig(prInfo, config, dependencyResults, sessionInfo);
      }
      async executeWithConfig(prInfo, config, dependencyResults, sessionInfo) {
        try {
          const stepName = config.checkName || "claude-code";
          const mock = sessionInfo?.hooks?.mockForStep?.(String(stepName));
          if (mock !== void 0) {
            if (mock && typeof mock === "object" && "issues" in mock) {
              return mock;
            }
            return { issues: [], output: mock };
          }
        } catch {
        }
        const claudeCodeConfig = config.claude_code || {};
        const customPrompt = config.prompt;
        if (!customPrompt) {
          throw new Error(
            `No prompt defined for check. All checks must have prompts defined in .visor.yaml configuration.`
          );
        }
        const processedPrompt = await this.processPrompt(
          customPrompt,
          prInfo,
          config.eventContext,
          dependencyResults
        );
        const startTime = Date.now();
        try {
          const client = await this.initializeClaudeCodeClient();
          const query = {
            query: processedPrompt,
            maxTurns: claudeCodeConfig.maxTurns || 5,
            systemPrompt: claudeCodeConfig.systemPrompt,
            subagent: claudeCodeConfig.subagent
          };
          if (claudeCodeConfig.allowedTools && claudeCodeConfig.allowedTools.length > 0) {
            query.tools = claudeCodeConfig.allowedTools.map((name) => ({ name }));
          }
          if (claudeCodeConfig.mcpServers && Object.keys(claudeCodeConfig.mcpServers).length > 0) {
            query.mcpServers = claudeCodeConfig.mcpServers;
          }
          let response;
          if (sessionInfo?.reuseSession && sessionInfo.parentSessionId) {
            response = await client.query({
              ...query,
              sessionId: sessionInfo.parentSessionId
            });
          } else {
            response = await client.query(query);
          }
          const result = this.parseStructuredResponse(response.content);
          result.debug = {
            prompt: processedPrompt,
            rawResponse: response.content,
            provider: "claude-code",
            model: "claude-code",
            apiKeySource: "CLAUDE_CODE_API_KEY",
            processingTime: Date.now() - startTime,
            promptLength: processedPrompt.length,
            responseLength: response.content.length,
            jsonParseSuccess: true,
            errors: [],
            checksExecuted: [config.checkName || "claude-code-check"],
            parallelExecution: false,
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            // Claude Code specific debug info
            sessionId: response.session_id,
            turnCount: response.turn_count,
            usage: response.usage
          };
          const suppressionEnabled = config.suppressionEnabled !== false;
          const issueFilter = new IssueFilter(suppressionEnabled);
          const filteredIssues = issueFilter.filterIssues(result.issues || [], process.cwd());
          return {
            ...result,
            issues: filteredIssues
          };
        } catch (error) {
          if (error instanceof ClaudeCodeSDKNotInstalledError || error instanceof ClaudeCodeAPIKeyMissingError) {
            throw error;
          }
          const errorMessage = error instanceof Error ? error.message : String(error);
          console.error(`\u274C Claude Code Check Provider Error: ${errorMessage}`);
          const isCriticalError = errorMessage.includes("API rate limit") || errorMessage.includes("403") || errorMessage.includes("401") || errorMessage.includes("authentication");
          if (isCriticalError) {
            console.error(
              `\u{1F6A8} CRITICAL ERROR: Claude Code provider authentication or setup issue detected`
            );
            console.error(
              `\u{1F6A8} This check cannot proceed without valid API credentials and SDK installation`
            );
          }
          throw new Error(`Claude Code analysis failed: ${errorMessage}`);
        }
      }
      getSupportedConfigKeys() {
        return [
          "type",
          "prompt",
          "claude_code.allowedTools",
          "claude_code.maxTurns",
          "claude_code.systemPrompt",
          "claude_code.mcpServers",
          "claude_code.subagent",
          "claude_code.hooks",
          "env",
          "checkName",
          "sessionId",
          "suppressionEnabled"
        ];
      }
      async isAvailable() {
        try {
          const hasApiKey = !!(process.env.CLAUDE_CODE_API_KEY || process.env.ANTHROPIC_API_KEY);
          if (!hasApiKey) {
            return false;
          }
          const claudeCodeModule = await safeImport("@anthropic/claude-code-sdk");
          if (!claudeCodeModule) {
            return false;
          }
          const ClaudeCode = claudeCodeModule.ClaudeCode || claudeCodeModule.default?.ClaudeCode;
          return !!ClaudeCode;
        } catch {
          return false;
        }
      }
      getRequirements() {
        return [
          "CLAUDE_CODE_API_KEY or ANTHROPIC_API_KEY environment variable",
          "@anthropic/claude-code-sdk npm package",
          "@modelcontextprotocol/sdk npm package (for MCP support)",
          "Network access to Claude Code API"
        ];
      }
    };
  }
});

// src/utils/env-exposure.ts
var env_exposure_exports = {};
__export(env_exposure_exports, {
  buildSandboxEnv: () => buildSandboxEnv
});
function buildSandboxEnv(input) {
  const denyDefaults = [
    "GITHUB_TOKEN",
    "INPUT_GITHUB-TOKEN",
    "ACTIONS_RUNTIME_TOKEN",
    "ACTIONS_ID_TOKEN_REQUEST_TOKEN",
    "AWS_ACCESS_KEY_ID",
    "AWS_SECRET_ACCESS_KEY",
    "AWS_SESSION_TOKEN",
    "AZURE_CLIENT_SECRET",
    "GOOGLE_APPLICATION_CREDENTIALS",
    "OPENAI_API_KEY",
    "ANTHROPIC_API_KEY",
    "HUGGINGFACE_API_KEY",
    "CLAUDE_CODE_API_KEY",
    "PROBE_API_KEY"
  ];
  const denyExtra = (input.VISOR_DENY_ENV || "").split(",").map((s) => s.trim()).filter(Boolean);
  const deny = Array.from(/* @__PURE__ */ new Set([...denyDefaults, ...denyExtra]));
  const allowSpec = (input.VISOR_ALLOW_ENV || "*").trim();
  const denyMatch = (key) => {
    for (const pat of deny) {
      if (!pat) continue;
      if (pat.endsWith("*")) {
        const prefix = pat.slice(0, -1);
        if (key.startsWith(prefix)) return true;
      } else if (key === pat) {
        return true;
      }
    }
    if (/(_TOKEN|_SECRET|_PASSWORD|_PRIVATE_KEY)$/i.test(key)) return true;
    return false;
  };
  const out = {};
  if (allowSpec !== "*") {
    const allow = allowSpec.split(",").map((s) => s.trim()).filter(Boolean);
    for (const key of allow) {
      const val = input[key];
      if (key && val !== void 0 && !denyMatch(key)) out[key] = String(val);
    }
    return out;
  }
  for (const [k, v] of Object.entries(input)) {
    if (v === void 0 || v === null) continue;
    if (denyMatch(k)) continue;
    out[k] = String(v);
  }
  return out;
}
var init_env_exposure = __esm({
  "src/utils/env-exposure.ts"() {
    "use strict";
  }
});

// src/providers/command-check-provider.ts
var CommandCheckProvider;
var init_command_check_provider = __esm({
  "src/providers/command-check-provider.ts"() {
    "use strict";
    init_check_provider_interface();
    init_sandbox();
    init_liquid_extensions();
    init_logger();
    init_command_executor();
    init_author_permissions();
    init_lazy_otel();
    init_state_capture();
    CommandCheckProvider = class extends CheckProvider {
      liquid;
      sandbox;
      constructor() {
        super();
        this.liquid = createExtendedLiquid({
          cache: false,
          strictFilters: false,
          strictVariables: false
        });
      }
      createSecureSandbox() {
        return createSecureSandbox();
      }
      getName() {
        return "command";
      }
      getDescription() {
        return "Execute shell commands and capture output for processing";
      }
      async validateConfig(config) {
        if (!config || typeof config !== "object") {
          return false;
        }
        const cfg = config;
        if (!cfg.exec || typeof cfg.exec !== "string") {
          return false;
        }
        return true;
      }
      async execute(prInfo, config, dependencyResults, context2) {
        try {
          logger.info(
            `  command provider: executing check=${String(config.checkName || config.type)} hasTransformJs=${Boolean(
              config.transform_js
            )}`
          );
        } catch {
        }
        const command = config.exec;
        const transform = config.transform;
        const transformJs = config.transform_js;
        const outputsObj = this.buildOutputContext(
          dependencyResults,
          config.__outputHistory
        );
        const outputsRaw = {};
        if (dependencyResults) {
          for (const [key, value] of dependencyResults.entries()) {
            if (typeof key !== "string") continue;
            if (key.endsWith("-raw")) {
              const name = key.slice(0, -4);
              const summary = value;
              outputsRaw[name] = summary.output !== void 0 ? summary.output : summary;
            }
          }
        }
        const templateContext = {
          pr: {
            number: prInfo.number,
            title: prInfo.title,
            author: prInfo.author,
            branch: prInfo.head,
            base: prInfo.base
          },
          files: prInfo.files,
          fileCount: prInfo.files.length,
          outputs: outputsObj,
          // Alias: outputs_history mirrors outputs.history for consistency
          outputs_history: outputsObj.history || {},
          // Stage-scoped history slice based on baseline provided by runner
          outputs_history_stage: (() => {
            const stage = {};
            try {
              const base = context2?.stageHistoryBase;
              const histMap = config.__outputHistory;
              if (!base || !histMap) return stage;
              for (const [k, v] of histMap.entries()) {
                const start = base[k] || 0;
                const arr = Array.isArray(v) ? v : [];
                stage[k] = arr.slice(start);
              }
            } catch {
            }
            return stage;
          })(),
          // New: outputs_raw exposes aggregate values (e.g., full arrays for forEach parents)
          outputs_raw: outputsRaw,
          // Workflow inputs (when executing within a workflow)
          // Check config first (set by projectWorkflowToGraph), then fall back to context
          inputs: config.workflowInputs || context2?.workflowInputs || {},
          // Custom arguments from on_init 'with' directive
          args: context2?.args || {},
          env: this.getSafeEnvironmentVariables()
        };
        logger.debug(
          `\u{1F527} Debug: Template outputs keys: ${Object.keys(templateContext.outputs || {}).join(", ")}`
        );
        try {
          const span = trace.getSpan(context.active());
          if (span) {
            captureCheckInputContext(span, templateContext);
          }
        } catch {
        }
        try {
          const checkId = config.checkName || config.id || "unknown";
          const ctxJson = JSON.stringify(sanitizeContextForTelemetry(templateContext));
          const { emitNdjsonSpanWithEvents: emitNdjsonSpanWithEvents2 } = (init_fallback_ndjson(), __toCommonJS(fallback_ndjson_exports));
          emitNdjsonSpanWithEvents2(
            "visor.check",
            { "visor.check.id": checkId, "visor.check.input.context": ctxJson },
            [{ name: "check.started" }, { name: "check.completed" }]
          );
        } catch {
        }
        try {
          const stepName = config.checkName || "unknown";
          if (process.env.VISOR_DEBUG === "true") {
            logger.debug(
              `[Command] Mock check: stepName=${stepName}, context=${!!context2}, hooks=${!!context2?.hooks}, mockForStep=${!!context2?.hooks?.mockForStep}`
            );
          }
          const rawMock = context2?.hooks?.mockForStep?.(String(stepName));
          if (process.env.VISOR_DEBUG === "true") {
            logger.debug(
              `[Command] Mock result: ${rawMock !== void 0 ? "found" : "not found"}, value=${JSON.stringify(rawMock)?.slice(0, 200)}`
            );
          }
          if (rawMock !== void 0) {
            let mock;
            if (typeof rawMock === "number") {
              mock = { exit_code: Number(rawMock) };
            } else if (typeof rawMock === "string") {
              mock = { stdout: String(rawMock) };
            } else {
              mock = rawMock;
            }
            const m = mock;
            const isCommandMock = m.stdout !== void 0 || m.stderr !== void 0 || m.exit_code !== void 0 || m.exit !== void 0;
            let out;
            if (isCommandMock) {
              out = m.stdout ?? "";
              try {
                if (typeof out === "string" && (out.trim().startsWith("{") || out.trim().startsWith("["))) {
                  out = JSON.parse(out);
                }
              } catch {
              }
            } else {
              out = mock;
            }
            const code = isCommandMock ? typeof m.exit_code === "number" ? m.exit_code : typeof m.exit === "number" ? m.exit : 0 : 0;
            let outputWithMeta;
            if (isCommandMock) {
              if (out && typeof out === "object" && !Array.isArray(out)) {
                outputWithMeta = { ...out, exit_code: code };
              } else {
                outputWithMeta = { value: out, exit_code: code };
              }
            } else {
              outputWithMeta = out;
            }
            if (code !== 0) {
              return {
                issues: [
                  {
                    file: "command",
                    line: 0,
                    ruleId: "command/execution_error",
                    message: `Mocked command exited with code ${code}`,
                    severity: "error",
                    category: "logic"
                  }
                ],
                output: outputWithMeta
              };
            }
            return { issues: [], output: outputWithMeta };
          }
        } catch {
        }
        try {
          let renderedCommand = command;
          if (command.includes("{{") || command.includes("{%")) {
            renderedCommand = await this.renderCommandTemplate(command, templateContext);
          }
          logger.debug(`\u{1F527} Debug: Rendered command: ${renderedCommand}`);
          const scriptEnv = {};
          for (const [key, value] of Object.entries(process.env)) {
            if (value !== void 0) {
              scriptEnv[key] = value;
            }
          }
          if (config.env) {
            for (const [key, value] of Object.entries(config.env)) {
              if (value !== void 0 && value !== null) {
                scriptEnv[key] = String(value);
              }
            }
          }
          const timeoutMs = config.timeout || 6e4;
          const normalizeNodeEval = (cmd) => {
            const re = /^(?<prefix>\s*(?:\/usr\/bin\/env\s+)?node(?:\.exe)?\s+(?:-e|--eval)\s+)(['"])([\s\S]*?)\2(?<suffix>\s|$)/;
            const m = cmd.match(re);
            if (!m || !m.groups) return cmd;
            const prefix = m.groups.prefix;
            const quote = m[2];
            const code = m[3];
            const suffix = m.groups.suffix || "";
            if (!code.includes("\n")) return cmd;
            const escaped = code.replace(/\n/g, "\\n");
            return cmd.replace(re, `${prefix}${quote}${escaped}${quote}${suffix}`);
          };
          const safeCommand = normalizeNodeEval(renderedCommand);
          const parentContext = context2?._parentContext;
          const workingDirectory = parentContext?.workingDirectory;
          const workspaceEnabled = parentContext?.workspace?.isEnabled?.();
          const cwd = workspaceEnabled && workingDirectory ? workingDirectory : void 0;
          if (cwd) {
            logger.debug(`[command] Using workspace working directory: ${cwd}`);
          }
          const execResult = await commandExecutor.execute(safeCommand, {
            env: scriptEnv,
            timeout: timeoutMs,
            cwd
          });
          const { stdout, stderr, exitCode } = execResult;
          if (stderr) {
            logger.debug(`Command stderr: ${stderr}`);
          }
          if (exitCode !== 0) {
            const errorMessage = stderr || `Command exited with code ${exitCode}`;
            logger.error(`Command failed with exit code ${exitCode}: ${errorMessage}`);
            const errorOutput = {
              error: true,
              exit_code: exitCode,
              message: errorMessage,
              // Include stdout if present - may contain partial results or error details
              ...stdout.trim() ? { stdout: stdout.trim() } : {},
              // Include a text field for AI tool compatibility
              text: `Command failed with exit code ${exitCode}: ${errorMessage}`
            };
            try {
              const span = trace.getSpan(context.active());
              if (span) {
                captureCheckOutput(span, errorOutput);
              }
            } catch {
            }
            return {
              issues: [
                {
                  file: "command",
                  line: 0,
                  ruleId: "command/execution_error",
                  message: `Command execution failed: ${errorMessage}`,
                  severity: "error",
                  category: "logic"
                }
              ],
              output: errorOutput
            };
          }
          const rawOutput = stdout.trim();
          let output = rawOutput;
          try {
            const parsed = JSON.parse(rawOutput);
            output = parsed;
            logger.debug(`\u{1F527} Debug: Parsed entire output as JSON successfully`);
          } catch {
            const extractedTail = this.extractJsonFromEnd(rawOutput);
            if (extractedTail) {
              try {
                output = JSON.parse(extractedTail);
              } catch {
                output = rawOutput;
              }
            } else {
              const extractedAny = this.extractJsonAnywhere(rawOutput);
              if (extractedAny) {
                try {
                  output = JSON.parse(extractedAny);
                } catch {
                  output = rawOutput;
                }
              } else {
                const m = /\berror\b\s*[:=]\s*(true|false)/i.exec(rawOutput);
                if (m) {
                  output = { error: m[1].toLowerCase() === "true" };
                } else {
                  output = rawOutput;
                }
              }
            }
          }
          let finalOutput = output;
          if (transform) {
            try {
              const transformContext = {
                ...templateContext,
                output
                // Use parsed output for Liquid (object if JSON, string otherwise)
              };
              const rendered = await this.liquid.parseAndRender(transform, transformContext);
              try {
                finalOutput = JSON.parse(rendered.trim());
                logger.verbose(`\u2713 Applied Liquid transform successfully (parsed as JSON)`);
              } catch {
                finalOutput = rendered.trim();
                logger.verbose(`\u2713 Applied Liquid transform successfully (string output)`);
              }
              try {
                const span = trace.getSpan(context.active());
                if (span) {
                  const { captureLiquidEvaluation: captureLiquidEvaluation2 } = (init_state_capture(), __toCommonJS(state_capture_exports));
                  captureLiquidEvaluation2(span, transform, transformContext, rendered);
                }
              } catch {
              }
            } catch (error) {
              logger.error(
                `\u2717 Failed to apply Liquid transform: ${error instanceof Error ? error.message : "Unknown error"}`
              );
              return {
                issues: [
                  {
                    file: "command",
                    line: 0,
                    ruleId: "command/transform_error",
                    message: `Failed to apply Liquid transform: ${error instanceof Error ? error.message : "Unknown error"}`,
                    severity: "error",
                    category: "logic"
                  }
                ]
              };
            }
          }
          if (transformJs) {
            try {
              const jsContext = {
                output: this.makeJsonSmart(rawOutput),
                pr: templateContext.pr,
                files: templateContext.files,
                outputs: this.makeOutputsJsonSmart(templateContext.outputs),
                inputs: templateContext.inputs || {},
                env: templateContext.env,
                permissions: createPermissionHelpers(
                  resolveAssociationFromEvent(prInfo.eventContext, prInfo.authorAssociation),
                  detectLocalMode()
                )
              };
              const trimmedTransform = transformJs.trim();
              const buildBodyWithReturn = (raw) => {
                const t = raw.trim();
                const lines = t.split(/\n/);
                let i = lines.length - 1;
                while (i >= 0 && lines[i].trim().length === 0) i--;
                if (i < 0) return "return undefined;";
                const lastLine = lines[i].trim();
                if (/^return\b/i.test(lastLine)) {
                  return t;
                }
                const idx = t.lastIndexOf(lastLine);
                const head = idx >= 0 ? t.slice(0, idx) : "";
                const lastExpr = lastLine.replace(/;\s*$/, "");
                return `${head}
return (${lastExpr});`;
              };
              const bodyWithReturn = buildBodyWithReturn(trimmedTransform);
              const code = `
            const output = scope.output;
            const pr = scope.pr;
            const files = scope.files;
            const outputs = scope.outputs;
            const inputs = scope.inputs;
            const env = scope.env;
            const log = (...args) => { console.log('\u{1F50D} Debug:', ...args); };
            const hasMinPermission = scope.permissions.hasMinPermission;
            const isOwner = scope.permissions.isOwner;
            const isMember = scope.permissions.isMember;
            const isCollaborator = scope.permissions.isCollaborator;
            const isContributor = scope.permissions.isContributor;
            const isFirstTimer = scope.permissions.isFirstTimer;
            const __result = (function(){
${bodyWithReturn}
            })();
            return __result;
          `;
              if (!this.sandbox) {
                this.sandbox = this.createSecureSandbox();
              }
              let parsedFromSandboxJson = void 0;
              try {
                const stringifyCode = `
              const output = scope.output;
              const pr = scope.pr;
              const files = scope.files;
              const outputs = scope.outputs;
              const env = scope.env;
              const log = (...args) => { console.log('\u{1F50D} Debug:', ...args); };
              const hasMinPermission = scope.permissions.hasMinPermission;
              const isOwner = scope.permissions.isOwner;
              const isMember = scope.permissions.isMember;
              const isCollaborator = scope.permissions.isCollaborator;
              const isContributor = scope.permissions.isContributor;
              const isFirstTimer = scope.permissions.isFirstTimer;
              const __ret = (function(){
${bodyWithReturn}
              })();
              return typeof __ret === 'object' && __ret !== null ? JSON.stringify(__ret) : null;
            `;
                const stringifyExec = this.sandbox.compile(stringifyCode);
                const jsonStr = stringifyExec({ scope: jsContext }).run();
                if (typeof jsonStr === "string" && jsonStr.trim().startsWith("{")) {
                  parsedFromSandboxJson = JSON.parse(jsonStr);
                }
              } catch {
              }
              if (parsedFromSandboxJson !== void 0) {
                finalOutput = parsedFromSandboxJson;
              } else {
                finalOutput = compileAndRun(
                  this.sandbox,
                  code,
                  { scope: jsContext },
                  { injectLog: false, wrapFunction: false }
                );
              }
              let finalSnapshot = null;
              try {
                if (finalOutput && typeof finalOutput === "object" && !Array.isArray(finalOutput)) {
                  try {
                    const stringifyExec = this.sandbox.compile("return JSON.stringify(scope.obj);");
                    const jsonStr = stringifyExec({ obj: finalOutput }).run();
                    if (typeof jsonStr === "string" && jsonStr.trim().startsWith("{")) {
                      finalSnapshot = JSON.parse(jsonStr);
                    }
                  } catch {
                  }
                  if (!finalSnapshot) {
                    try {
                      finalSnapshot = JSON.parse(JSON.stringify(finalOutput));
                    } catch {
                    }
                  }
                  if (!finalSnapshot) {
                    const tmp = {};
                    for (const k of Object.keys(finalOutput)) {
                      tmp[k] = finalOutput[k];
                    }
                    finalSnapshot = tmp;
                  }
                }
              } catch {
              }
              this.__lastTransformSnapshot = finalSnapshot;
              try {
                const isObj = finalOutput && typeof finalOutput === "object" && !Array.isArray(finalOutput);
                const keys = isObj ? Object.keys(finalOutput).join(",") : typeof finalOutput;
                logger.debug(
                  `  transform_js: output typeof=${Array.isArray(finalOutput) ? "array" : typeof finalOutput} keys=${keys}`
                );
                if (isObj && finalOutput.issues) {
                  const mi = finalOutput.issues;
                  logger.debug(
                    `  transform_js: issues typeof=${Array.isArray(mi) ? "array" : typeof mi} len=${mi && mi.length || 0}`
                  );
                }
                try {
                  if (isObj)
                    logger.debug(`  transform_js: error value=${String(finalOutput.error)}`);
                } catch {
                }
              } catch {
              }
              logger.verbose(`\u2713 Applied JavaScript transform successfully`);
            } catch (error) {
              logger.error(
                `\u2717 Failed to apply JavaScript transform: ${error instanceof Error ? error.message : "Unknown error"}`
              );
              return {
                issues: [
                  {
                    file: "command",
                    line: 0,
                    ruleId: "command/transform_js_error",
                    message: `Failed to apply JavaScript transform: ${error instanceof Error ? error.message : "Unknown error"}`,
                    severity: "error",
                    category: "logic"
                  }
                ]
              };
            }
          }
          let issues = [];
          let outputForDependents = finalOutput;
          const snapshotForExtraction = this.__lastTransformSnapshot || null;
          try {
            if (snapshotForExtraction) {
              logger.debug(`  provider: snapshot keys=${Object.keys(snapshotForExtraction).join(",")}`);
            } else {
              logger.debug(`  provider: snapshot is null`);
            }
          } catch {
          }
          try {
            if (Array.isArray(outputForDependents) && outputForDependents.length === 1) {
              const first = outputForDependents[0];
              if (typeof first === "string") {
                try {
                  outputForDependents = JSON.parse(first);
                } catch {
                }
              } else if (first && typeof first === "object") {
                outputForDependents = first;
              }
            }
          } catch {
          }
          let content;
          let extracted = null;
          const trimmedRawOutput = typeof rawOutput === "string" ? rawOutput.trim() : void 0;
          const commandConfig = config;
          const isForEachParent = commandConfig.forEach === true;
          if (!isForEachParent) {
            try {
              const baseObj = snapshotForExtraction || finalOutput;
              if (baseObj && typeof baseObj === "object" && Object.prototype.hasOwnProperty.call(baseObj, "issues")) {
                const remaining = { ...baseObj };
                delete remaining.issues;
                outputForDependents = Object.keys(remaining).length > 0 ? remaining : void 0;
                try {
                  const k = outputForDependents && typeof outputForDependents === "object" ? Object.keys(outputForDependents).join(",") : String(outputForDependents);
                  logger.debug(`  provider: generic-remaining keys=${k}`);
                } catch {
                }
              }
            } catch {
            }
            const objForExtraction = snapshotForExtraction || finalOutput;
            if (objForExtraction && typeof objForExtraction === "object") {
              try {
                const rec = objForExtraction;
                const maybeIssues = rec.issues;
                const toPlainArray = (v) => {
                  if (Array.isArray(v)) return v;
                  try {
                    if (v && typeof v === "object" && typeof v[Symbol.iterator] === "function") {
                      return Array.from(v);
                    }
                  } catch {
                  }
                  const len = Number((v || {}).length);
                  if (Number.isFinite(len) && len >= 0) {
                    const arr2 = [];
                    for (let i = 0; i < len; i++) arr2.push(v[i]);
                    return arr2;
                  }
                  try {
                    const cloned = JSON.parse(JSON.stringify(v));
                    return Array.isArray(cloned) ? cloned : null;
                  } catch {
                    return null;
                  }
                };
                try {
                  const ctor = maybeIssues && maybeIssues.constructor ? maybeIssues.constructor.name : "unknown";
                  logger.debug(
                    `  provider: issues inspect typeof=${typeof maybeIssues} Array.isArray=${Array.isArray(
                      maybeIssues
                    )} ctor=${ctor} keys=${Object.keys(maybeIssues || {}).join(",")}`
                  );
                } catch {
                }
                const arr = toPlainArray(maybeIssues);
                if (arr) {
                  const norm = this.normalizeIssueArray(arr);
                  if (norm) {
                    issues = norm;
                    const remaining = { ...rec };
                    delete remaining.issues;
                    outputForDependents = Object.keys(remaining).length > 0 ? remaining : void 0;
                    try {
                      const keys = outputForDependents && typeof outputForDependents === "object" ? Object.keys(outputForDependents).join(",") : String(outputForDependents);
                      logger.info(
                        `  provider: fast-path issues=${issues.length} remaining keys=${keys}`
                      );
                    } catch {
                    }
                  } else {
                    try {
                      logger.info("  provider: fast-path norm failed");
                    } catch {
                    }
                  }
                } else {
                  try {
                    logger.info("  provider: fast-path arr unavailable");
                  } catch {
                  }
                }
              } catch {
              }
            }
            let extractionTarget = snapshotForExtraction || finalOutput;
            try {
              if (Array.isArray(extractionTarget) && extractionTarget.length === 1) {
                const first = extractionTarget[0];
                if (typeof first === "string") {
                  try {
                    extractionTarget = JSON.parse(first);
                  } catch {
                    extractionTarget = first;
                  }
                } else if (first && typeof first === "object") {
                  extractionTarget = first;
                }
              }
            } catch {
            }
            extracted = this.extractIssuesFromOutput(extractionTarget);
            try {
              if (extractionTarget !== (snapshotForExtraction || finalOutput)) {
                finalOutput = extractionTarget;
              }
            } catch {
            }
            if (!extracted && finalOutput && typeof finalOutput === "object") {
              try {
                const rec = finalOutput;
                const maybeIssues = rec.issues;
                if (maybeIssues && typeof maybeIssues === "object") {
                  let arr = null;
                  try {
                    if (typeof maybeIssues[Symbol.iterator] === "function") {
                      arr = Array.from(maybeIssues);
                    }
                  } catch {
                  }
                  if (!arr) {
                    const len = Number(maybeIssues.length);
                    if (Number.isFinite(len) && len >= 0) {
                      arr = [];
                      for (let i = 0; i < len; i++) arr.push(maybeIssues[i]);
                    }
                  }
                  if (!arr) {
                    try {
                      arr = JSON.parse(JSON.stringify(maybeIssues));
                    } catch {
                    }
                  }
                  if (arr && Array.isArray(arr)) {
                    const norm = this.normalizeIssueArray(arr);
                    if (norm) {
                      issues = norm;
                      const remaining = { ...rec };
                      delete remaining.issues;
                      outputForDependents = Object.keys(remaining).length > 0 ? remaining : void 0;
                    }
                  }
                }
              } catch {
              }
            }
            if (!extracted && typeof finalOutput === "string") {
              try {
                const parsed = JSON.parse(finalOutput);
                extracted = this.extractIssuesFromOutput(parsed);
                if (extracted) {
                  issues = extracted.issues;
                  outputForDependents = extracted.remainingOutput;
                  if (typeof extracted.remainingOutput === "object" && extracted.remainingOutput !== null && typeof extracted.remainingOutput.content === "string") {
                    const c = String(extracted.remainingOutput.content).trim();
                    if (c) content = c;
                  }
                }
              } catch {
                try {
                  const any = this.extractJsonAnywhere(finalOutput);
                  if (any) {
                    const parsed = JSON.parse(any);
                    extracted = this.extractIssuesFromOutput(parsed);
                    if (extracted) {
                      issues = extracted.issues;
                      outputForDependents = extracted.remainingOutput;
                      if (typeof extracted.remainingOutput === "object" && extracted.remainingOutput !== null && typeof extracted.remainingOutput.content === "string") {
                        const c = String(extracted.remainingOutput.content).trim();
                        if (c) content = c;
                      }
                    }
                  }
                } catch {
                }
              }
            } else if (extracted) {
              issues = extracted.issues;
              outputForDependents = extracted.remainingOutput;
              if (typeof extracted.remainingOutput === "object" && extracted.remainingOutput !== null && typeof extracted.remainingOutput.content === "string") {
                const c = String(extracted.remainingOutput.content).trim();
                if (c) content = c;
              }
            }
            if (!issues.length && this.shouldTreatAsTextOutput(trimmedRawOutput)) {
              content = trimmedRawOutput;
            } else if (issues.length && typeof extracted?.remainingOutput === "string") {
              const trimmed = extracted.remainingOutput.trim();
              if (trimmed) {
                content = trimmed;
              }
            }
            if (!issues.length && typeof trimmedRawOutput === "string") {
              try {
                const tryParsed = JSON.parse(trimmedRawOutput);
                const reextract = this.extractIssuesFromOutput(tryParsed);
                if (reextract && reextract.issues && reextract.issues.length) {
                  issues = reextract.issues;
                  if (!outputForDependents && reextract.remainingOutput) {
                    outputForDependents = reextract.remainingOutput;
                  }
                } else if (Array.isArray(tryParsed)) {
                  const first = tryParsed[0];
                  if (first && typeof first === "object" && Array.isArray(first.issues)) {
                    const merged = [];
                    for (const el of tryParsed) {
                      if (el && typeof el === "object" && Array.isArray(el.issues)) {
                        merged.push(...el.issues);
                      }
                    }
                    const flat = this.normalizeIssueArray(merged);
                    if (flat) issues = flat;
                  } else {
                    const converted = [];
                    for (const el of tryParsed) {
                      if (typeof el === "string") {
                        try {
                          const obj = JSON.parse(el);
                          converted.push(obj);
                        } catch {
                        }
                      } else {
                        converted.push(el);
                      }
                    }
                    const flat = this.normalizeIssueArray(converted);
                    if (flat) issues = flat;
                  }
                }
              } catch {
              }
              if (!issues.length) {
                try {
                  const any = this.extractJsonAnywhere(trimmedRawOutput);
                  if (any) {
                    const tryParsed = JSON.parse(any);
                    const reextract = this.extractIssuesFromOutput(tryParsed);
                    if (reextract && reextract.issues && reextract.issues.length) {
                      issues = reextract.issues;
                      if (!outputForDependents && reextract.remainingOutput) {
                        outputForDependents = reextract.remainingOutput;
                      }
                    }
                  }
                } catch {
                }
              }
            }
            try {
              const srcObj = snapshotForExtraction || finalOutput;
              if (outputForDependents && typeof outputForDependents === "object" && srcObj && typeof srcObj === "object") {
                for (const k of Object.keys(srcObj)) {
                  const v = srcObj[k];
                  if (typeof v === "boolean" || typeof v === "number" || typeof v === "string") {
                    outputForDependents[k] = v;
                  }
                }
              }
            } catch {
            }
            try {
              if (outputForDependents && typeof outputForDependents === "object" && !Array.isArray(outputForDependents)) {
                const plain = {};
                for (const k of Object.keys(outputForDependents)) {
                  plain[k] = outputForDependents[k];
                }
                outputForDependents = plain;
              }
            } catch {
            }
          }
          if (!content && this.shouldTreatAsTextOutput(trimmedRawOutput) && !isForEachParent) {
            content = trimmedRawOutput;
          }
          try {
            if (outputForDependents && typeof outputForDependents === "object") {
              outputForDependents = JSON.parse(JSON.stringify(outputForDependents));
            }
          } catch {
          }
          const promoted = {};
          try {
            const srcObj = snapshotForExtraction || finalOutput;
            if (srcObj && typeof srcObj === "object") {
              for (const k of Object.keys(srcObj)) {
                const v = srcObj[k];
                if (typeof v === "boolean") {
                  if (v === true && promoted[k] === void 0) promoted[k] = true;
                } else if ((typeof v === "number" || typeof v === "string") && promoted[k] === void 0) {
                  promoted[k] = v;
                }
              }
            }
          } catch {
          }
          const result = {
            issues,
            output: outputForDependents,
            ...content ? { content } : {},
            ...promoted
          };
          try {
            const span = trace.getSpan(context.active());
            if (span) {
              captureCheckOutput(span, outputForDependents);
              if (transformJs && output !== finalOutput) {
                captureTransformJS(span, transformJs, output, finalOutput);
              }
            }
          } catch {
          }
          try {
            const checkId = config.checkName || config.id || "unknown";
            const outJson = JSON.stringify(result.output ?? result);
            const { emitNdjsonSpanWithEvents: emitNdjsonSpanWithEvents2 } = (init_fallback_ndjson(), __toCommonJS(fallback_ndjson_exports));
            emitNdjsonSpanWithEvents2(
              "visor.check",
              { "visor.check.id": checkId, "visor.check.output": outJson },
              [{ name: "check.started" }, { name: "check.completed" }]
            );
          } catch {
          }
          try {
            if (transformJs) {
              const rawObj = snapshotForExtraction || finalOutput;
              if (rawObj && typeof rawObj === "object") {
                result.__raw = rawObj;
              }
            }
          } catch {
          }
          try {
            const srcObj = snapshotForExtraction || finalOutput;
            const srcErr = (() => {
              try {
                if (snapshotForExtraction && typeof snapshotForExtraction === "object" && snapshotForExtraction.error !== void 0) {
                  return Boolean(snapshotForExtraction.error);
                }
                if (finalOutput && typeof finalOutput === "object" && finalOutput.error !== void 0) {
                  return Boolean(finalOutput.error);
                }
              } catch {
              }
              return void 0;
            })();
            const dst = result.output;
            if (srcObj && typeof srcObj === "object" && dst && typeof dst === "object") {
              try {
                logger.debug(
                  `  provider: safeguard src.error typeof=${typeof srcObj.error} val=${String(srcObj.error)} dst.hasErrorBefore=${String(dst.error !== void 0)}`
                );
              } catch {
              }
              for (const k of Object.keys(srcObj)) {
                const v = srcObj[k];
                if (typeof v === "boolean" || typeof v === "number" || typeof v === "string") {
                  dst[k] = v;
                }
              }
              if (srcErr !== void 0 && dst.error === void 0) {
                dst.error = srcErr;
                try {
                  const k = Object.keys(dst).join(",");
                  logger.debug(
                    `  provider: safeguard merged error -> output keys=${k} val=${String(dst.error)}`
                  );
                } catch {
                }
              }
            }
          } catch {
          }
          try {
            const out = result.output;
            if (out && typeof out === "object") {
              const k = Object.keys(out).join(",");
              logger.debug(`  provider: return output keys=${k}`);
            } else {
              logger.debug(`  provider: return output type=${typeof out}`);
            }
          } catch {
          }
          return result;
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : "Unknown error";
          let isTimeout = false;
          if (error && typeof error === "object") {
            const execError = error;
            if (execError.killed && execError.signal === "SIGTERM") {
              isTimeout = true;
            }
            if (execError.code === "ETIMEDOUT") {
              isTimeout = true;
            }
          }
          if (!isTimeout && error instanceof Error) {
            if (/timed out/i.test(error.message)) {
              isTimeout = true;
            }
          }
          let stderrOutput = "";
          if (error && typeof error === "object") {
            const execError = error;
            if (execError.stderr) {
              stderrOutput = execError.stderr.trim();
            }
          }
          let detailedMessage;
          let ruleId;
          if (isTimeout) {
            const timeoutMs = config.timeout || 6e4;
            detailedMessage = `Command execution timed out after ${timeoutMs} milliseconds`;
            if (stderrOutput) {
              detailedMessage += `

Stderr output:
${stderrOutput}`;
            }
            ruleId = "command/timeout";
          } else {
            detailedMessage = stderrOutput ? `Command execution failed: ${errorMessage}

Stderr output:
${stderrOutput}` : `Command execution failed: ${errorMessage}`;
            ruleId = "command/execution_error";
          }
          logger.error(`\u2717 ${detailedMessage}`);
          const errorOutput = {
            error: true,
            timeout: isTimeout,
            message: detailedMessage,
            text: detailedMessage
          };
          try {
            const span = trace.getSpan(context.active());
            if (span) {
              captureCheckOutput(span, errorOutput);
            }
          } catch {
          }
          return {
            issues: [
              {
                file: "command",
                line: 0,
                ruleId,
                message: detailedMessage,
                severity: "error",
                category: "logic"
              }
            ],
            output: errorOutput
          };
        }
      }
      buildOutputContext(dependencyResults, outputHistory) {
        if (!dependencyResults) {
          return {};
        }
        const outputs = {};
        const history = {};
        for (const [checkName, result] of dependencyResults) {
          const summary = result;
          const value = summary.output !== void 0 ? summary.output : summary;
          outputs[checkName] = this.makeJsonSmart(value);
        }
        if (outputHistory) {
          for (const [checkName, historyArray] of outputHistory) {
            history[checkName] = historyArray.map((val) => this.makeJsonSmart(val));
          }
        }
        outputs.history = history;
        return outputs;
      }
      /**
       * Wrap a value with JSON-smart behavior:
       *  - If it's a JSON string, expose parsed properties via Proxy (e.g., value.key)
       *  - When coerced to string (toString/valueOf/Symbol.toPrimitive), return the original raw string
       *  - If parsing fails or value is not a string, return the value unchanged
       *  - Attempts to extract JSON from the end of the output if full parse fails
       */
      makeJsonSmart(value) {
        if (typeof value !== "string") {
          return value;
        }
        const raw = value;
        let parsed;
        try {
          parsed = JSON.parse(raw);
        } catch {
          const jsonMatch = this.extractJsonFromEnd(raw);
          if (jsonMatch) {
            try {
              parsed = JSON.parse(jsonMatch);
              logger.debug(
                `\u{1F527} Debug: Extracted JSON from end of output (${jsonMatch.length} chars from ${raw.length} total)`
              );
            } catch {
              return raw;
            }
          } else {
            return raw;
          }
        }
        const boxed = new String(raw);
        const handler = {
          get(target, prop, receiver) {
            if (prop === "toString" || prop === "valueOf") {
              return () => raw;
            }
            if (prop === Symbol.toPrimitive) {
              return () => raw;
            }
            if (parsed != null && (typeof parsed === "object" || Array.isArray(parsed))) {
              if (prop in parsed) {
                return parsed[prop];
              }
            }
            return Reflect.get(target, prop, receiver);
          },
          has(_target, prop) {
            if (parsed != null && (typeof parsed === "object" || Array.isArray(parsed))) {
              if (prop in parsed) return true;
            }
            return false;
          },
          ownKeys(_target) {
            if (parsed != null && (typeof parsed === "object" || Array.isArray(parsed))) {
              try {
                return Reflect.ownKeys(parsed);
              } catch {
                return [];
              }
            }
            return [];
          },
          getOwnPropertyDescriptor(_target, prop) {
            if (parsed != null && (typeof parsed === "object" || Array.isArray(parsed))) {
              const descriptor = Object.getOwnPropertyDescriptor(parsed, prop);
              if (descriptor) return descriptor;
            }
            return {
              configurable: true,
              enumerable: true,
              writable: false,
              value: void 0
            };
          }
        };
        return new Proxy(boxed, handler);
      }
      /**
       * Extract JSON from the end of a string that may contain logs/debug output
       * Looks for the last occurrence of { or [ and tries to parse from there
       */
      extractJsonFromEnd(text) {
        const lastBrace = Math.max(text.lastIndexOf("}"), text.lastIndexOf("]"));
        if (lastBrace === -1) return null;
        let open = 0;
        for (let i = lastBrace; i >= 0; i--) {
          const ch = text[i];
          if (ch === "}" || ch === "]") open++;
          else if (ch === "{" || ch === "[") open--;
          if (open === 0 && (ch === "{" || ch === "[")) {
            const candidate = text.slice(i, lastBrace + 1).trim();
            try {
              JSON.parse(candidate);
              return candidate;
            } catch {
              return null;
            }
          }
        }
        return null;
      }
      // Extract any balanced JSON object/array substring from anywhere in the text
      extractJsonAnywhere(text) {
        const n = text.length;
        let best = null;
        for (let i = 0; i < n; i++) {
          const start = text[i];
          if (start !== "{" && start !== "[") continue;
          let open = 0;
          let inString = false;
          let escape = false;
          for (let j = i; j < n; j++) {
            const ch = text[j];
            if (escape) {
              escape = false;
              continue;
            }
            if (ch === "\\") {
              escape = true;
              continue;
            }
            if (ch === '"') {
              inString = !inString;
              continue;
            }
            if (inString) continue;
            if (ch === "{" || ch === "[") open++;
            else if (ch === "}" || ch === "]") open--;
            if (open === 0 && (ch === "}" || ch === "]")) {
              const candidate = text.slice(i, j + 1).trim();
              try {
                JSON.parse(candidate);
                best = candidate;
              } catch {
                const strict = this.looseJsonToStrict(candidate);
                if (strict) {
                  try {
                    JSON.parse(strict);
                    best = strict;
                  } catch {
                  }
                }
              }
              break;
            }
          }
        }
        return best;
      }
      // Best-effort conversion of object-literal-like strings to strict JSON
      looseJsonToStrict(candidate) {
        try {
          let s = candidate.trim();
          s = s.replace(/'/g, '"');
          s = s.replace(/([\{,]\s*)([A-Za-z_][A-Za-z0-9_-]*)\s*:/g, '$1"$2":');
          s = s.replace(/:\s*([A-Za-z_][A-Za-z0-9_-]*)\s*(?=[,}])/g, (_match, word) => {
            const lw = String(word).toLowerCase();
            if (lw === "true" || lw === "false" || lw === "null") return `:${lw}`;
            return `:"${word}"`;
          });
          return s;
        } catch {
          return null;
        }
      }
      /**
       * Recursively apply JSON-smart wrapper to outputs object values
       */
      makeOutputsJsonSmart(outputs) {
        const wrapped = {};
        for (const [k, v] of Object.entries(outputs || {})) {
          wrapped[k] = this.makeJsonSmart(v);
        }
        return wrapped;
      }
      getSafeEnvironmentVariables() {
        const safeVars = {};
        const { buildSandboxEnv: buildSandboxEnv2 } = (init_env_exposure(), __toCommonJS(env_exposure_exports));
        const merged = buildSandboxEnv2(process.env);
        for (const [key, value] of Object.entries(merged)) {
          safeVars[key] = String(value);
        }
        safeVars["PWD"] = process.cwd();
        return safeVars;
      }
      getSupportedConfigKeys() {
        return [
          "type",
          "exec",
          "transform",
          "transform_js",
          "env",
          "timeout",
          "depends_on",
          "on",
          "if",
          "group",
          "forEach"
        ];
      }
      async isAvailable() {
        return true;
      }
      getRequirements() {
        return [
          "Valid shell command to execute",
          "Shell environment available",
          "Optional: Transform template for processing output"
        ];
      }
      extractIssuesFromOutput(output) {
        try {
          logger.info(
            `  extractIssuesFromOutput: typeof=${Array.isArray(output) ? "array" : typeof output}`
          );
          if (typeof output === "object" && output) {
            const rec = output;
            logger.info(
              `  extractIssuesFromOutput: keys=${Object.keys(rec).join(",")} issuesIsArray=${Array.isArray(
                rec.issues
              )}`
            );
          }
        } catch {
        }
        if (output === null || output === void 0) {
          return null;
        }
        if (typeof output === "string") {
          return null;
        }
        if (Array.isArray(output)) {
          const first = output[0];
          if (first && typeof first === "object" && !Array.isArray(first.message) && Array.isArray(first.issues)) {
            const merged = [];
            for (const el of output) {
              if (el && typeof el === "object" && Array.isArray(el.issues)) {
                merged.push(...el.issues);
              }
            }
            const flat = this.normalizeIssueArray(merged);
            if (flat) return { issues: flat, remainingOutput: void 0 };
          } else {
            const issues = this.normalizeIssueArray(output);
            if (issues) {
              return { issues, remainingOutput: void 0 };
            }
          }
          return null;
        }
        if (typeof output === "object") {
          const record = output;
          if (Array.isArray(record.issues)) {
            const issues = this.normalizeIssueArray(record.issues);
            if (!issues) {
              return null;
            }
            const remaining = { ...record };
            delete remaining.issues;
            const remainingKeys = Object.keys(remaining);
            const remainingOutput = remainingKeys.length > 0 ? remaining : void 0;
            return {
              issues,
              remainingOutput
            };
          }
          const singleIssue = this.normalizeIssue(record);
          if (singleIssue) {
            return { issues: [singleIssue], remainingOutput: void 0 };
          }
        }
        return null;
      }
      shouldTreatAsTextOutput(value) {
        if (!value) {
          return false;
        }
        const trimmed = value.trim();
        if (!trimmed) {
          return false;
        }
        const startsJson = trimmed.startsWith("{") && trimmed.endsWith("}") || trimmed.startsWith("[") && trimmed.endsWith("]");
        return !startsJson;
      }
      normalizeIssueArray(values) {
        const normalized = [];
        for (const value of values) {
          const issue = this.normalizeIssue(value);
          if (!issue) {
            return null;
          }
          normalized.push(issue);
        }
        return normalized;
      }
      normalizeIssue(raw) {
        if (!raw || typeof raw !== "object") {
          return null;
        }
        const data = raw;
        const message = this.toTrimmedString(
          data.message || data.text || data.description || data.summary
        );
        if (!message) {
          return null;
        }
        const hasIssueField = data.file !== void 0 || data.path !== void 0 || data.filename !== void 0 || data.line !== void 0 || data.startLine !== void 0 || data.lineNumber !== void 0 || data.severity !== void 0 || data.level !== void 0 || data.priority !== void 0 || data.ruleId !== void 0 || data.rule !== void 0 || data.category !== void 0 || data.type !== void 0;
        if (!hasIssueField) {
          return null;
        }
        const allowedSeverities = /* @__PURE__ */ new Set(["info", "warning", "error", "critical"]);
        const severityRaw = this.toTrimmedString(data.severity || data.level || data.priority);
        let severity = "warning";
        if (severityRaw) {
          const lower = severityRaw.toLowerCase();
          if (allowedSeverities.has(lower)) {
            severity = lower;
          } else if (["fatal", "high"].includes(lower)) {
            severity = "error";
          } else if (["medium", "moderate"].includes(lower)) {
            severity = "warning";
          } else if (["low", "minor"].includes(lower)) {
            severity = "info";
          }
        }
        const allowedCategories = /* @__PURE__ */ new Set([
          "security",
          "performance",
          "style",
          "logic",
          "documentation"
        ]);
        const categoryRaw = this.toTrimmedString(data.category || data.type || data.group);
        let category = "logic";
        if (categoryRaw && allowedCategories.has(categoryRaw.toLowerCase())) {
          category = categoryRaw.toLowerCase();
        }
        const file = this.toTrimmedString(data.file || data.path || data.filename) || "system";
        const line = this.toNumber(data.line || data.startLine || data.lineNumber) ?? 0;
        const endLine = this.toNumber(data.endLine || data.end_line || data.stopLine);
        const suggestion = this.toTrimmedString(data.suggestion);
        const replacement = this.toTrimmedString(data.replacement);
        const ruleId = this.toTrimmedString(data.ruleId || data.rule || data.id || data.check) || "command";
        return {
          file,
          line,
          endLine: endLine ?? void 0,
          ruleId,
          message,
          severity,
          category,
          suggestion: suggestion || void 0,
          replacement: replacement || void 0
        };
      }
      toTrimmedString(value) {
        if (typeof value === "string") {
          const trimmed = value.trim();
          return trimmed.length > 0 ? trimmed : null;
        }
        if (value !== null && value !== void 0 && typeof value.toString === "function") {
          const converted = String(value).trim();
          return converted.length > 0 ? converted : null;
        }
        return null;
      }
      toNumber(value) {
        if (value === null || value === void 0) {
          return null;
        }
        const num = Number(value);
        if (Number.isFinite(num)) {
          return Math.trunc(num);
        }
        return null;
      }
      async renderCommandTemplate(template, context2) {
        try {
          let tpl = template;
          if (tpl.includes("{{")) {
            tpl = tpl.replace(/\{\{([\s\S]*?)\}\}/g, (_m, inner) => {
              const fixed = String(inner).replace(/\[\"/g, "['").replace(/\"\]/g, "']");
              return `{{ ${fixed} }}`;
            });
          }
          let rendered = await this.liquid.parseAndRender(tpl, context2);
          if (/\{\{[\s\S]*?\}\}/.test(rendered)) {
            try {
              rendered = this.renderWithJsExpressions(rendered, context2);
            } catch {
            }
          }
          return rendered;
        } catch (error) {
          logger.debug(`\u{1F527} Debug: Liquid templating failed, trying JS-expression fallback: ${error}`);
          try {
            return this.renderWithJsExpressions(template, context2);
          } catch {
            return template;
          }
        }
      }
      renderWithJsExpressions(template, context2) {
        const scope = {
          pr: context2.pr,
          files: context2.files,
          outputs: context2.outputs,
          env: context2.env
        };
        const expressionRegex = /\{\{\s*([^{}]+?)\s*\}\}/g;
        return template.replace(expressionRegex, (_match, expr) => {
          const expression = String(expr).trim();
          if (!expression) return "";
          try {
            const evalCode = `
          const pr = scope.pr;
          const files = scope.files;
          const outputs = scope.outputs;
          const env = scope.env;
          return (${expression});
        `;
            if (!this.sandbox) this.sandbox = this.createSecureSandbox();
            const evaluator = this.sandbox.compile(evalCode);
            const result = evaluator({ scope }).run();
            return result === void 0 || result === null ? "" : String(result);
          } catch {
            return "";
          }
        });
      }
    };
  }
});

// src/utils/script-memory-ops.ts
function createSyncMemoryOps(store) {
  let saveNeeded = false;
  const ensureNs = (ns) => {
    const nsName = ns || store.getDefaultNamespace();
    const anyStore = store;
    if (!anyStore["data"].has(nsName)) {
      anyStore["data"].set(nsName, /* @__PURE__ */ new Map());
    }
    return nsName;
  };
  const ops = {
    get: (key, ns) => store.get(key, ns),
    has: (key, ns) => store.has(key, ns),
    list: (ns) => store.list(ns),
    getAll: (ns) => store.getAll(ns),
    set: (key, value, ns) => {
      const nsName = ensureNs(ns);
      store["data"].get(nsName).set(key, value);
      saveNeeded = true;
      return value;
    },
    append: (key, value, ns) => {
      const existing = store.get(key, ns);
      let newValue;
      if (existing === void 0) newValue = [value];
      else if (Array.isArray(existing)) newValue = [...existing, value];
      else newValue = [existing, value];
      const nsName = ensureNs(ns);
      store["data"].get(nsName).set(key, newValue);
      saveNeeded = true;
      return newValue;
    },
    increment: (key, amount = 1, ns) => {
      const nsName = ensureNs(ns);
      const current = store.get(key, nsName);
      const numCurrent = typeof current === "number" ? current : 0;
      const newValue = numCurrent + amount;
      store["data"].get(nsName).set(key, newValue);
      saveNeeded = true;
      return newValue;
    },
    delete: (key, ns) => {
      const nsName = ensureNs(ns);
      const d = store["data"].get(nsName)?.delete(key) || false;
      if (d) saveNeeded = true;
      return d;
    },
    clear: (ns) => {
      if (ns) store["data"].delete(ns);
      else store["data"].clear();
      saveNeeded = true;
    }
  };
  return { ops, needsSave: () => saveNeeded };
}
var init_script_memory_ops = __esm({
  "src/utils/script-memory-ops.ts"() {
    "use strict";
  }
});

// src/providers/memory-check-provider.ts
var MemoryCheckProvider;
var init_memory_check_provider = __esm({
  "src/providers/memory-check-provider.ts"() {
    "use strict";
    init_check_provider_interface();
    init_memory_store();
    init_liquid_extensions();
    init_logger();
    init_sandbox();
    init_template_context();
    init_script_memory_ops();
    MemoryCheckProvider = class extends CheckProvider {
      liquid;
      sandbox;
      constructor() {
        super();
        this.liquid = createExtendedLiquid({
          strictVariables: false,
          strictFilters: false
        });
      }
      /**
       * Create a secure sandbox for JavaScript execution
       */
      createSecureSandbox() {
        return createSecureSandbox();
      }
      getName() {
        return "memory";
      }
      getDescription() {
        return "Memory/state management provider for persistent key-value storage across checks";
      }
      async validateConfig(config) {
        if (!config || typeof config !== "object") {
          return false;
        }
        const cfg = config;
        if (cfg.type !== "memory") {
          return false;
        }
        if (!cfg.operation || typeof cfg.operation !== "string") {
          return false;
        }
        const operation = cfg.operation;
        const validOps = ["get", "set", "append", "increment", "delete", "clear", "list"];
        if (!validOps.includes(operation)) {
          return false;
        }
        if (["get", "set", "append", "increment", "delete"].includes(operation)) {
          if (!cfg.key || typeof cfg.key !== "string") {
            return false;
          }
        }
        if (["set", "append"].includes(operation)) {
          if (cfg.value === void 0 && !cfg.value_js) {
            return false;
          }
        }
        return true;
      }
      async execute(prInfo, config, dependencyResults, _sessionInfo) {
        const operation = config.operation;
        const key = config.key;
        const namespace = config.namespace;
        const memoryStore = MemoryStore.getInstance();
        const templateContext = this.buildTemplateContext(
          prInfo,
          dependencyResults,
          memoryStore,
          config.__outputHistory,
          _sessionInfo?.stageHistoryBase,
          _sessionInfo?.args
        );
        let result;
        try {
          switch (operation) {
            case "get":
              result = await this.handleGet(memoryStore, key, namespace);
              break;
            case "set":
              result = await this.handleSet(memoryStore, key, config, namespace, templateContext);
              break;
            case "append":
              result = await this.handleAppend(memoryStore, key, config, namespace, templateContext);
              break;
            case "increment":
              result = await this.handleIncrement(
                memoryStore,
                key,
                config,
                namespace,
                templateContext
              );
              break;
            case "delete":
              result = await this.handleDelete(memoryStore, key, namespace);
              break;
            case "clear":
              result = await this.handleClear(memoryStore, namespace);
              break;
            case "list":
              result = await this.handleList(memoryStore, namespace);
              break;
            default:
              throw new Error(`Unknown memory operation: ${operation}`);
          }
          return {
            issues: [],
            output: result
          };
        } catch (error) {
          const errorMsg = error instanceof Error ? error.message : "Unknown error in memory operation";
          logger.error(`Memory operation failed: ${errorMsg}`);
          return {
            issues: [],
            output: null,
            error: errorMsg
          };
        }
      }
      async handleGet(store, key, namespace) {
        const value = store.get(key, namespace);
        logger.debug(
          `Memory GET: ${namespace || store.getDefaultNamespace()}.${key} = ${JSON.stringify(value)}`
        );
        return value;
      }
      async handleSet(store, key, config, namespace, context2) {
        const value = await this.computeValue(config, context2);
        await store.set(key, value, namespace);
        logger.debug(
          `Memory SET: ${namespace || store.getDefaultNamespace()}.${key} = ${JSON.stringify(value)}`
        );
        return value;
      }
      async handleAppend(store, key, config, namespace, context2) {
        const value = await this.computeValue(config, context2);
        await store.append(key, value, namespace);
        const result = store.get(key, namespace);
        logger.debug(
          `Memory APPEND: ${namespace || store.getDefaultNamespace()}.${key} += ${JSON.stringify(value)} (now: ${JSON.stringify(result)})`
        );
        return result;
      }
      async handleIncrement(store, key, config, namespace, context2) {
        let amount = 1;
        if (config.value !== void 0 || config.value_js) {
          const computedValue = await this.computeValue(config, context2);
          if (typeof computedValue === "number") {
            amount = computedValue;
          } else {
            throw new Error(`Increment amount must be a number, got ${typeof computedValue}`);
          }
        }
        const result = await store.increment(key, amount, namespace);
        logger.debug(
          `Memory INCREMENT: ${namespace || store.getDefaultNamespace()}.${key} += ${amount} (now: ${result})`
        );
        return result;
      }
      async handleDelete(store, key, namespace) {
        const deleted = await store.delete(key, namespace);
        logger.debug(
          `Memory DELETE: ${namespace || store.getDefaultNamespace()}.${key} (deleted: ${deleted})`
        );
        return deleted;
      }
      async handleClear(store, namespace) {
        await store.clear(namespace);
        logger.debug(`Memory CLEAR: ${namespace ? `namespace ${namespace}` : "all namespaces"}`);
      }
      async handleList(store, namespace) {
        const keys = store.list(namespace);
        logger.debug(`Memory LIST: ${namespace || store.getDefaultNamespace()} (${keys.length} keys)`);
        return keys;
      }
      // For custom JavaScript execution use ScriptCheckProvider.
      /**
       * Compute value from config using value, value_js, transform, or transform_js
       */
      async computeValue(config, context2) {
        let value;
        if (config.value_js && typeof config.value_js === "string") {
          value = this.evaluateJavaScript(config.value_js, context2);
        } else {
          value = config.value;
        }
        if (config.transform && typeof config.transform === "string") {
          const rendered = await this.liquid.parseAndRender(config.transform, {
            ...context2,
            value
          });
          value = rendered;
        }
        if (config.transform_js && typeof config.transform_js === "string") {
          value = this.evaluateJavaScript(config.transform_js, { ...context2, value });
        }
        return value;
      }
      /**
       * Evaluate JavaScript expression in context using SandboxJS for secure execution
       */
      evaluateJavaScript(expression, context2) {
        this.sandbox = this.createSecureSandbox();
        try {
          const scope = { ...context2 };
          return compileAndRun(this.sandbox, `return (${expression});`, scope, {
            injectLog: true,
            wrapFunction: false,
            logPrefix: "[memory:value_js]"
          });
        } catch (error) {
          const errorMsg = error instanceof Error ? error.message : "Unknown error";
          throw new Error(`Failed to evaluate value_js: ${errorMsg}`);
        }
      }
      // No full-script execution in memory provider. Use ScriptCheckProvider.
      /**
       * Build template context for Liquid and JS evaluation
       */
      buildTemplateContext(prInfo, dependencyResults, memoryStore, outputHistory, stageHistoryBase, args) {
        const base = buildProviderTemplateContext(
          prInfo,
          dependencyResults,
          memoryStore,
          outputHistory,
          stageHistoryBase,
          { attachMemoryReadHelpers: true, args }
        );
        if (memoryStore) {
          const { ops } = createSyncMemoryOps(memoryStore);
          base.memory = ops;
        }
        return base;
      }
      getSupportedConfigKeys() {
        return [
          "type",
          "operation",
          "key",
          "value",
          "value_js",
          "transform",
          "transform_js",
          "namespace",
          "depends_on",
          "group",
          "command",
          "on",
          "if",
          "fail_if",
          "on_fail",
          "on_success"
        ];
      }
      async isAvailable() {
        return true;
      }
      getRequirements() {
        return [
          "No external dependencies required",
          "Used for state management and persistent storage across checks"
        ];
      }
    };
  }
});

// node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS({
  "node_modules/undici/lib/core/symbols.js"(exports, module) {
    "use strict";
    module.exports = {
      kClose: /* @__PURE__ */ Symbol("close"),
      kDestroy: /* @__PURE__ */ Symbol("destroy"),
      kDispatch: /* @__PURE__ */ Symbol("dispatch"),
      kUrl: /* @__PURE__ */ Symbol("url"),
      kWriting: /* @__PURE__ */ Symbol("writing"),
      kResuming: /* @__PURE__ */ Symbol("resuming"),
      kQueue: /* @__PURE__ */ Symbol("queue"),
      kConnect: /* @__PURE__ */ Symbol("connect"),
      kConnecting: /* @__PURE__ */ Symbol("connecting"),
      kHeadersList: /* @__PURE__ */ Symbol("headers list"),
      kKeepAliveDefaultTimeout: /* @__PURE__ */ Symbol("default keep alive timeout"),
      kKeepAliveMaxTimeout: /* @__PURE__ */ Symbol("max keep alive timeout"),
      kKeepAliveTimeoutThreshold: /* @__PURE__ */ Symbol("keep alive timeout threshold"),
      kKeepAliveTimeoutValue: /* @__PURE__ */ Symbol("keep alive timeout"),
      kKeepAlive: /* @__PURE__ */ Symbol("keep alive"),
      kHeadersTimeout: /* @__PURE__ */ Symbol("headers timeout"),
      kBodyTimeout: /* @__PURE__ */ Symbol("body timeout"),
      kServerName: /* @__PURE__ */ Symbol("server name"),
      kLocalAddress: /* @__PURE__ */ Symbol("local address"),
      kHost: /* @__PURE__ */ Symbol("host"),
      kNoRef: /* @__PURE__ */ Symbol("no ref"),
      kBodyUsed: /* @__PURE__ */ Symbol("used"),
      kRunning: /* @__PURE__ */ Symbol("running"),
      kBlocking: /* @__PURE__ */ Symbol("blocking"),
      kPending: /* @__PURE__ */ Symbol("pending"),
      kSize: /* @__PURE__ */ Symbol("size"),
      kBusy: /* @__PURE__ */ Symbol("busy"),
      kQueued: /* @__PURE__ */ Symbol("queued"),
      kFree: /* @__PURE__ */ Symbol("free"),
      kConnected: /* @__PURE__ */ Symbol("connected"),
      kClosed: /* @__PURE__ */ Symbol("closed"),
      kNeedDrain: /* @__PURE__ */ Symbol("need drain"),
      kReset: /* @__PURE__ */ Symbol("reset"),
      kDestroyed: /* @__PURE__ */ Symbol.for("nodejs.stream.destroyed"),
      kMaxHeadersSize: /* @__PURE__ */ Symbol("max headers size"),
      kRunningIdx: /* @__PURE__ */ Symbol("running index"),
      kPendingIdx: /* @__PURE__ */ Symbol("pending index"),
      kError: /* @__PURE__ */ Symbol("error"),
      kClients: /* @__PURE__ */ Symbol("clients"),
      kClient: /* @__PURE__ */ Symbol("client"),
      kParser: /* @__PURE__ */ Symbol("parser"),
      kOnDestroyed: /* @__PURE__ */ Symbol("destroy callbacks"),
      kPipelining: /* @__PURE__ */ Symbol("pipelining"),
      kSocket: /* @__PURE__ */ Symbol("socket"),
      kHostHeader: /* @__PURE__ */ Symbol("host header"),
      kConnector: /* @__PURE__ */ Symbol("connector"),
      kStrictContentLength: /* @__PURE__ */ Symbol("strict content length"),
      kMaxRedirections: /* @__PURE__ */ Symbol("maxRedirections"),
      kMaxRequests: /* @__PURE__ */ Symbol("maxRequestsPerClient"),
      kProxy: /* @__PURE__ */ Symbol("proxy agent options"),
      kCounter: /* @__PURE__ */ Symbol("socket request counter"),
      kInterceptors: /* @__PURE__ */ Symbol("dispatch interceptors"),
      kMaxResponseSize: /* @__PURE__ */ Symbol("max response size"),
      kHTTP2Session: /* @__PURE__ */ Symbol("http2Session"),
      kHTTP2SessionState: /* @__PURE__ */ Symbol("http2Session state"),
      kHTTP2BuildRequest: /* @__PURE__ */ Symbol("http2 build request"),
      kHTTP1BuildRequest: /* @__PURE__ */ Symbol("http1 build request"),
      kHTTP2CopyHeaders: /* @__PURE__ */ Symbol("http2 copy headers"),
      kHTTPConnVersion: /* @__PURE__ */ Symbol("http connection version"),
      kRetryHandlerDefaultRetry: /* @__PURE__ */ Symbol("retry agent default retry"),
      kConstruct: /* @__PURE__ */ Symbol("constructable")
    };
  }
});

// node_modules/undici/lib/core/errors.js
var require_errors = __commonJS({
  "node_modules/undici/lib/core/errors.js"(exports, module) {
    "use strict";
    var UndiciError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "UndiciError";
        this.code = "UND_ERR";
      }
    };
    var ConnectTimeoutError = class _ConnectTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ConnectTimeoutError);
        this.name = "ConnectTimeoutError";
        this.message = message || "Connect Timeout Error";
        this.code = "UND_ERR_CONNECT_TIMEOUT";
      }
    };
    var HeadersTimeoutError = class _HeadersTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _HeadersTimeoutError);
        this.name = "HeadersTimeoutError";
        this.message = message || "Headers Timeout Error";
        this.code = "UND_ERR_HEADERS_TIMEOUT";
      }
    };
    var HeadersOverflowError = class _HeadersOverflowError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _HeadersOverflowError);
        this.name = "HeadersOverflowError";
        this.message = message || "Headers Overflow Error";
        this.code = "UND_ERR_HEADERS_OVERFLOW";
      }
    };
    var BodyTimeoutError = class _BodyTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _BodyTimeoutError);
        this.name = "BodyTimeoutError";
        this.message = message || "Body Timeout Error";
        this.code = "UND_ERR_BODY_TIMEOUT";
      }
    };
    var ResponseStatusCodeError = class _ResponseStatusCodeError extends UndiciError {
      constructor(message, statusCode, headers, body) {
        super(message);
        Error.captureStackTrace(this, _ResponseStatusCodeError);
        this.name = "ResponseStatusCodeError";
        this.message = message || "Response Status Code Error";
        this.code = "UND_ERR_RESPONSE_STATUS_CODE";
        this.body = body;
        this.status = statusCode;
        this.statusCode = statusCode;
        this.headers = headers;
      }
    };
    var InvalidArgumentError = class _InvalidArgumentError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InvalidArgumentError);
        this.name = "InvalidArgumentError";
        this.message = message || "Invalid Argument Error";
        this.code = "UND_ERR_INVALID_ARG";
      }
    };
    var InvalidReturnValueError = class _InvalidReturnValueError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InvalidReturnValueError);
        this.name = "InvalidReturnValueError";
        this.message = message || "Invalid Return Value Error";
        this.code = "UND_ERR_INVALID_RETURN_VALUE";
      }
    };
    var RequestAbortedError = class _RequestAbortedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _RequestAbortedError);
        this.name = "AbortError";
        this.message = message || "Request aborted";
        this.code = "UND_ERR_ABORTED";
      }
    };
    var InformationalError = class _InformationalError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InformationalError);
        this.name = "InformationalError";
        this.message = message || "Request information";
        this.code = "UND_ERR_INFO";
      }
    };
    var RequestContentLengthMismatchError = class _RequestContentLengthMismatchError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _RequestContentLengthMismatchError);
        this.name = "RequestContentLengthMismatchError";
        this.message = message || "Request body length does not match content-length header";
        this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ResponseContentLengthMismatchError = class _ResponseContentLengthMismatchError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ResponseContentLengthMismatchError);
        this.name = "ResponseContentLengthMismatchError";
        this.message = message || "Response body length does not match content-length header";
        this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ClientDestroyedError = class _ClientDestroyedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ClientDestroyedError);
        this.name = "ClientDestroyedError";
        this.message = message || "The client is destroyed";
        this.code = "UND_ERR_DESTROYED";
      }
    };
    var ClientClosedError = class _ClientClosedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ClientClosedError);
        this.name = "ClientClosedError";
        this.message = message || "The client is closed";
        this.code = "UND_ERR_CLOSED";
      }
    };
    var SocketError = class _SocketError extends UndiciError {
      constructor(message, socket) {
        super(message);
        Error.captureStackTrace(this, _SocketError);
        this.name = "SocketError";
        this.message = message || "Socket error";
        this.code = "UND_ERR_SOCKET";
        this.socket = socket;
      }
    };
    var NotSupportedError = class _NotSupportedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _NotSupportedError);
        this.name = "NotSupportedError";
        this.message = message || "Not supported error";
        this.code = "UND_ERR_NOT_SUPPORTED";
      }
    };
    var BalancedPoolMissingUpstreamError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, NotSupportedError);
        this.name = "MissingUpstreamError";
        this.message = message || "No upstream has been added to the BalancedPool";
        this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
      }
    };
    var HTTPParserError = class _HTTPParserError extends Error {
      constructor(message, code, data) {
        super(message);
        Error.captureStackTrace(this, _HTTPParserError);
        this.name = "HTTPParserError";
        this.code = code ? `HPE_${code}` : void 0;
        this.data = data ? data.toString() : void 0;
      }
    };
    var ResponseExceededMaxSizeError = class _ResponseExceededMaxSizeError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ResponseExceededMaxSizeError);
        this.name = "ResponseExceededMaxSizeError";
        this.message = message || "Response content exceeded max size";
        this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
      }
    };
    var RequestRetryError = class _RequestRetryError extends UndiciError {
      constructor(message, code, { headers, data }) {
        super(message);
        Error.captureStackTrace(this, _RequestRetryError);
        this.name = "RequestRetryError";
        this.message = message || "Request retry error";
        this.code = "UND_ERR_REQ_RETRY";
        this.statusCode = code;
        this.data = data;
        this.headers = headers;
      }
    };
    module.exports = {
      HTTPParserError,
      UndiciError,
      HeadersTimeoutError,
      HeadersOverflowError,
      BodyTimeoutError,
      RequestContentLengthMismatchError,
      ConnectTimeoutError,
      ResponseStatusCodeError,
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError,
      ClientDestroyedError,
      ClientClosedError,
      InformationalError,
      SocketError,
      NotSupportedError,
      ResponseContentLengthMismatchError,
      BalancedPoolMissingUpstreamError,
      ResponseExceededMaxSizeError,
      RequestRetryError
    };
  }
});

// node_modules/undici/lib/core/constants.js
var require_constants = __commonJS({
  "node_modules/undici/lib/core/constants.js"(exports, module) {
    "use strict";
    var headerNameLowerCasedRecord = {};
    var wellknownHeaderNames = [
      "Accept",
      "Accept-Encoding",
      "Accept-Language",
      "Accept-Ranges",
      "Access-Control-Allow-Credentials",
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Methods",
      "Access-Control-Allow-Origin",
      "Access-Control-Expose-Headers",
      "Access-Control-Max-Age",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Age",
      "Allow",
      "Alt-Svc",
      "Alt-Used",
      "Authorization",
      "Cache-Control",
      "Clear-Site-Data",
      "Connection",
      "Content-Disposition",
      "Content-Encoding",
      "Content-Language",
      "Content-Length",
      "Content-Location",
      "Content-Range",
      "Content-Security-Policy",
      "Content-Security-Policy-Report-Only",
      "Content-Type",
      "Cookie",
      "Cross-Origin-Embedder-Policy",
      "Cross-Origin-Opener-Policy",
      "Cross-Origin-Resource-Policy",
      "Date",
      "Device-Memory",
      "Downlink",
      "ECT",
      "ETag",
      "Expect",
      "Expect-CT",
      "Expires",
      "Forwarded",
      "From",
      "Host",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Range",
      "If-Unmodified-Since",
      "Keep-Alive",
      "Last-Modified",
      "Link",
      "Location",
      "Max-Forwards",
      "Origin",
      "Permissions-Policy",
      "Pragma",
      "Proxy-Authenticate",
      "Proxy-Authorization",
      "RTT",
      "Range",
      "Referer",
      "Referrer-Policy",
      "Refresh",
      "Retry-After",
      "Sec-WebSocket-Accept",
      "Sec-WebSocket-Extensions",
      "Sec-WebSocket-Key",
      "Sec-WebSocket-Protocol",
      "Sec-WebSocket-Version",
      "Server",
      "Server-Timing",
      "Service-Worker-Allowed",
      "Service-Worker-Navigation-Preload",
      "Set-Cookie",
      "SourceMap",
      "Strict-Transport-Security",
      "Supports-Loading-Mode",
      "TE",
      "Timing-Allow-Origin",
      "Trailer",
      "Transfer-Encoding",
      "Upgrade",
      "Upgrade-Insecure-Requests",
      "User-Agent",
      "Vary",
      "Via",
      "WWW-Authenticate",
      "X-Content-Type-Options",
      "X-DNS-Prefetch-Control",
      "X-Frame-Options",
      "X-Permitted-Cross-Domain-Policies",
      "X-Powered-By",
      "X-Requested-With",
      "X-XSS-Protection"
    ];
    for (let i = 0; i < wellknownHeaderNames.length; ++i) {
      const key = wellknownHeaderNames[i];
      const lowerCasedKey = key.toLowerCase();
      headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
    }
    Object.setPrototypeOf(headerNameLowerCasedRecord, null);
    module.exports = {
      wellknownHeaderNames,
      headerNameLowerCasedRecord
    };
  }
});

// node_modules/undici/lib/core/util.js
var require_util = __commonJS({
  "node_modules/undici/lib/core/util.js"(exports, module) {
    "use strict";
    var assert = __require("assert");
    var { kDestroyed, kBodyUsed } = require_symbols();
    var { IncomingMessage } = __require("http");
    var stream = __require("stream");
    var net = __require("net");
    var { InvalidArgumentError } = require_errors();
    var { Blob: Blob2 } = __require("buffer");
    var nodeUtil = __require("util");
    var { stringify } = __require("querystring");
    var { headerNameLowerCasedRecord } = require_constants();
    var [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));
    function nop() {
    }
    function isStream(obj) {
      return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
    }
    function isBlobLike(object) {
      return Blob2 && object instanceof Blob2 || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
    }
    function buildURL(url, queryParams) {
      if (url.includes("?") || url.includes("#")) {
        throw new Error('Query params cannot be passed when url already contains "?" or "#".');
      }
      const stringified = stringify(queryParams);
      if (stringified) {
        url += "?" + stringified;
      }
      return url;
    }
    function parseURL(url) {
      if (typeof url === "string") {
        url = new URL(url);
        if (!/^https?:/.test(url.origin || url.protocol)) {
          throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
        }
        return url;
      }
      if (!url || typeof url !== "object") {
        throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
      }
      if (!/^https?:/.test(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      if (!(url instanceof URL)) {
        if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port))) {
          throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
        }
        if (url.path != null && typeof url.path !== "string") {
          throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
        }
        if (url.pathname != null && typeof url.pathname !== "string") {
          throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
        }
        if (url.hostname != null && typeof url.hostname !== "string") {
          throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
        }
        if (url.origin != null && typeof url.origin !== "string") {
          throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
        }
        const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
        let origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;
        let path12 = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
        if (origin.endsWith("/")) {
          origin = origin.substring(0, origin.length - 1);
        }
        if (path12 && !path12.startsWith("/")) {
          path12 = `/${path12}`;
        }
        url = new URL(origin + path12);
      }
      return url;
    }
    function parseOrigin(url) {
      url = parseURL(url);
      if (url.pathname !== "/" || url.search || url.hash) {
        throw new InvalidArgumentError("invalid url");
      }
      return url;
    }
    function getHostname(host) {
      if (host[0] === "[") {
        const idx2 = host.indexOf("]");
        assert(idx2 !== -1);
        return host.substring(1, idx2);
      }
      const idx = host.indexOf(":");
      if (idx === -1) return host;
      return host.substring(0, idx);
    }
    function getServerName(host) {
      if (!host) {
        return null;
      }
      assert.strictEqual(typeof host, "string");
      const servername = getHostname(host);
      if (net.isIP(servername)) {
        return "";
      }
      return servername;
    }
    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function isAsyncIterable(obj) {
      return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
    }
    function isIterable(obj) {
      return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
    }
    function bodyLength(body) {
      if (body == null) {
        return 0;
      } else if (isStream(body)) {
        const state = body._readableState;
        return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
      } else if (isBlobLike(body)) {
        return body.size != null ? body.size : null;
      } else if (isBuffer(body)) {
        return body.byteLength;
      }
      return null;
    }
    function isDestroyed(stream2) {
      return !stream2 || !!(stream2.destroyed || stream2[kDestroyed]);
    }
    function isReadableAborted(stream2) {
      const state = stream2 && stream2._readableState;
      return isDestroyed(stream2) && state && !state.endEmitted;
    }
    function destroy(stream2, err) {
      if (stream2 == null || !isStream(stream2) || isDestroyed(stream2)) {
        return;
      }
      if (typeof stream2.destroy === "function") {
        if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
          stream2.socket = null;
        }
        stream2.destroy(err);
      } else if (err) {
        process.nextTick((stream3, err2) => {
          stream3.emit("error", err2);
        }, stream2, err);
      }
      if (stream2.destroyed !== true) {
        stream2[kDestroyed] = true;
      }
    }
    var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
    function parseKeepAliveTimeout(val) {
      const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
      return m ? parseInt(m[1], 10) * 1e3 : null;
    }
    function headerNameToString(value) {
      return headerNameLowerCasedRecord[value] || value.toLowerCase();
    }
    function parseHeaders(headers, obj = {}) {
      if (!Array.isArray(headers)) return headers;
      for (let i = 0; i < headers.length; i += 2) {
        const key = headers[i].toString().toLowerCase();
        let val = obj[key];
        if (!val) {
          if (Array.isArray(headers[i + 1])) {
            obj[key] = headers[i + 1].map((x) => x.toString("utf8"));
          } else {
            obj[key] = headers[i + 1].toString("utf8");
          }
        } else {
          if (!Array.isArray(val)) {
            val = [val];
            obj[key] = val;
          }
          val.push(headers[i + 1].toString("utf8"));
        }
      }
      if ("content-length" in obj && "content-disposition" in obj) {
        obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
      }
      return obj;
    }
    function parseRawHeaders(headers) {
      const ret = [];
      let hasContentLength = false;
      let contentDispositionIdx = -1;
      for (let n = 0; n < headers.length; n += 2) {
        const key = headers[n + 0].toString();
        const val = headers[n + 1].toString("utf8");
        if (key.length === 14 && (key === "content-length" || key.toLowerCase() === "content-length")) {
          ret.push(key, val);
          hasContentLength = true;
        } else if (key.length === 19 && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
          contentDispositionIdx = ret.push(key, val) - 1;
        } else {
          ret.push(key, val);
        }
      }
      if (hasContentLength && contentDispositionIdx !== -1) {
        ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
      }
      return ret;
    }
    function isBuffer(buffer) {
      return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
    }
    function validateHandler(handler, method, upgrade) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      if (typeof handler.onConnect !== "function") {
        throw new InvalidArgumentError("invalid onConnect method");
      }
      if (typeof handler.onError !== "function") {
        throw new InvalidArgumentError("invalid onError method");
      }
      if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) {
        throw new InvalidArgumentError("invalid onBodySent method");
      }
      if (upgrade || method === "CONNECT") {
        if (typeof handler.onUpgrade !== "function") {
          throw new InvalidArgumentError("invalid onUpgrade method");
        }
      } else {
        if (typeof handler.onHeaders !== "function") {
          throw new InvalidArgumentError("invalid onHeaders method");
        }
        if (typeof handler.onData !== "function") {
          throw new InvalidArgumentError("invalid onData method");
        }
        if (typeof handler.onComplete !== "function") {
          throw new InvalidArgumentError("invalid onComplete method");
        }
      }
    }
    function isDisturbed(body) {
      return !!(body && (stream.isDisturbed ? stream.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
    }
    function isErrored(body) {
      return !!(body && (stream.isErrored ? stream.isErrored(body) : /state: 'errored'/.test(
        nodeUtil.inspect(body)
      )));
    }
    function isReadable(body) {
      return !!(body && (stream.isReadable ? stream.isReadable(body) : /state: 'readable'/.test(
        nodeUtil.inspect(body)
      )));
    }
    function getSocketInfo(socket) {
      return {
        localAddress: socket.localAddress,
        localPort: socket.localPort,
        remoteAddress: socket.remoteAddress,
        remotePort: socket.remotePort,
        remoteFamily: socket.remoteFamily,
        timeout: socket.timeout,
        bytesWritten: socket.bytesWritten,
        bytesRead: socket.bytesRead
      };
    }
    async function* convertIterableToBuffer(iterable) {
      for await (const chunk of iterable) {
        yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
      }
    }
    var ReadableStream;
    function ReadableStreamFrom(iterable) {
      if (!ReadableStream) {
        ReadableStream = __require("stream/web").ReadableStream;
      }
      if (ReadableStream.from) {
        return ReadableStream.from(convertIterableToBuffer(iterable));
      }
      let iterator;
      return new ReadableStream(
        {
          async start() {
            iterator = iterable[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { done, value } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
              controller.enqueue(new Uint8Array(buf));
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          }
        },
        0
      );
    }
    function isFormDataLike(object) {
      return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
    }
    function throwIfAborted(signal) {
      if (!signal) {
        return;
      }
      if (typeof signal.throwIfAborted === "function") {
        signal.throwIfAborted();
      } else {
        if (signal.aborted) {
          const err = new Error("The operation was aborted");
          err.name = "AbortError";
          throw err;
        }
      }
    }
    function addAbortListener(signal, listener) {
      if ("addEventListener" in signal) {
        signal.addEventListener("abort", listener, { once: true });
        return () => signal.removeEventListener("abort", listener);
      }
      signal.addListener("abort", listener);
      return () => signal.removeListener("abort", listener);
    }
    var hasToWellFormed = !!String.prototype.toWellFormed;
    function toUSVString(val) {
      if (hasToWellFormed) {
        return `${val}`.toWellFormed();
      } else if (nodeUtil.toUSVString) {
        return nodeUtil.toUSVString(val);
      }
      return `${val}`;
    }
    function parseRangeHeader(range) {
      if (range == null || range === "") return { start: 0, end: null, size: null };
      const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
      return m ? {
        start: parseInt(m[1]),
        end: m[2] ? parseInt(m[2]) : null,
        size: m[3] ? parseInt(m[3]) : null
      } : null;
    }
    var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
    kEnumerableProperty.enumerable = true;
    module.exports = {
      kEnumerableProperty,
      nop,
      isDisturbed,
      isErrored,
      isReadable,
      toUSVString,
      isReadableAborted,
      isBlobLike,
      parseOrigin,
      parseURL,
      getServerName,
      isStream,
      isIterable,
      isAsyncIterable,
      isDestroyed,
      headerNameToString,
      parseRawHeaders,
      parseHeaders,
      parseKeepAliveTimeout,
      destroy,
      bodyLength,
      deepClone,
      ReadableStreamFrom,
      isBuffer,
      validateHandler,
      getSocketInfo,
      isFormDataLike,
      buildURL,
      throwIfAborted,
      addAbortListener,
      parseRangeHeader,
      nodeMajor,
      nodeMinor,
      nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13,
      safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"]
    };
  }
});

// node_modules/undici/lib/timers.js
var require_timers = __commonJS({
  "node_modules/undici/lib/timers.js"(exports, module) {
    "use strict";
    var fastNow = Date.now();
    var fastNowTimeout;
    var fastTimers = [];
    function onTimeout() {
      fastNow = Date.now();
      let len = fastTimers.length;
      let idx = 0;
      while (idx < len) {
        const timer = fastTimers[idx];
        if (timer.state === 0) {
          timer.state = fastNow + timer.delay;
        } else if (timer.state > 0 && fastNow >= timer.state) {
          timer.state = -1;
          timer.callback(timer.opaque);
        }
        if (timer.state === -1) {
          timer.state = -2;
          if (idx !== len - 1) {
            fastTimers[idx] = fastTimers.pop();
          } else {
            fastTimers.pop();
          }
          len -= 1;
        } else {
          idx += 1;
        }
      }
      if (fastTimers.length > 0) {
        refreshTimeout();
      }
    }
    function refreshTimeout() {
      if (fastNowTimeout && fastNowTimeout.refresh) {
        fastNowTimeout.refresh();
      } else {
        clearTimeout(fastNowTimeout);
        fastNowTimeout = setTimeout(onTimeout, 1e3);
        if (fastNowTimeout.unref) {
          fastNowTimeout.unref();
        }
      }
    }
    var Timeout = class {
      constructor(callback, delay, opaque) {
        this.callback = callback;
        this.delay = delay;
        this.opaque = opaque;
        this.state = -2;
        this.refresh();
      }
      refresh() {
        if (this.state === -2) {
          fastTimers.push(this);
          if (!fastNowTimeout || fastTimers.length === 1) {
            refreshTimeout();
          }
        }
        this.state = 0;
      }
      clear() {
        this.state = -1;
      }
    };
    module.exports = {
      setTimeout(callback, delay, opaque) {
        return delay < 1e3 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
      },
      clearTimeout(timeout) {
        if (timeout instanceof Timeout) {
          timeout.clear();
        } else {
          clearTimeout(timeout);
        }
      }
    };
  }
});

// node_modules/@fastify/busboy/deps/streamsearch/sbmh.js
var require_sbmh = __commonJS({
  "node_modules/@fastify/busboy/deps/streamsearch/sbmh.js"(exports, module) {
    "use strict";
    var EventEmitter2 = __require("events").EventEmitter;
    var inherits = __require("util").inherits;
    function SBMH(needle) {
      if (typeof needle === "string") {
        needle = Buffer.from(needle);
      }
      if (!Buffer.isBuffer(needle)) {
        throw new TypeError("The needle has to be a String or a Buffer.");
      }
      const needleLength = needle.length;
      if (needleLength === 0) {
        throw new Error("The needle cannot be an empty String/Buffer.");
      }
      if (needleLength > 256) {
        throw new Error("The needle cannot have a length bigger than 256.");
      }
      this.maxMatches = Infinity;
      this.matches = 0;
      this._occ = new Array(256).fill(needleLength);
      this._lookbehind_size = 0;
      this._needle = needle;
      this._bufpos = 0;
      this._lookbehind = Buffer.alloc(needleLength);
      for (var i = 0; i < needleLength - 1; ++i) {
        this._occ[needle[i]] = needleLength - 1 - i;
      }
    }
    inherits(SBMH, EventEmitter2);
    SBMH.prototype.reset = function() {
      this._lookbehind_size = 0;
      this.matches = 0;
      this._bufpos = 0;
    };
    SBMH.prototype.push = function(chunk, pos) {
      if (!Buffer.isBuffer(chunk)) {
        chunk = Buffer.from(chunk, "binary");
      }
      const chlen = chunk.length;
      this._bufpos = pos || 0;
      let r;
      while (r !== chlen && this.matches < this.maxMatches) {
        r = this._sbmh_feed(chunk);
      }
      return r;
    };
    SBMH.prototype._sbmh_feed = function(data) {
      const len = data.length;
      const needle = this._needle;
      const needleLength = needle.length;
      const lastNeedleChar = needle[needleLength - 1];
      let pos = -this._lookbehind_size;
      let ch;
      if (pos < 0) {
        while (pos < 0 && pos <= len - needleLength) {
          ch = this._sbmh_lookup_char(data, pos + needleLength - 1);
          if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {
            this._lookbehind_size = 0;
            ++this.matches;
            this.emit("info", true);
            return this._bufpos = pos + needleLength;
          }
          pos += this._occ[ch];
        }
        if (pos < 0) {
          while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {
            ++pos;
          }
        }
        if (pos >= 0) {
          this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);
          this._lookbehind_size = 0;
        } else {
          const bytesToCutOff = this._lookbehind_size + pos;
          if (bytesToCutOff > 0) {
            this.emit("info", false, this._lookbehind, 0, bytesToCutOff);
          }
          this._lookbehind.copy(
            this._lookbehind,
            0,
            bytesToCutOff,
            this._lookbehind_size - bytesToCutOff
          );
          this._lookbehind_size -= bytesToCutOff;
          data.copy(this._lookbehind, this._lookbehind_size);
          this._lookbehind_size += len;
          this._bufpos = len;
          return len;
        }
      }
      pos += (pos >= 0) * this._bufpos;
      if (data.indexOf(needle, pos) !== -1) {
        pos = data.indexOf(needle, pos);
        ++this.matches;
        if (pos > 0) {
          this.emit("info", true, data, this._bufpos, pos);
        } else {
          this.emit("info", true);
        }
        return this._bufpos = pos + needleLength;
      } else {
        pos = len - needleLength;
      }
      while (pos < len && (data[pos] !== needle[0] || Buffer.compare(
        data.subarray(pos, pos + len - pos),
        needle.subarray(0, len - pos)
      ) !== 0)) {
        ++pos;
      }
      if (pos < len) {
        data.copy(this._lookbehind, 0, pos, pos + (len - pos));
        this._lookbehind_size = len - pos;
      }
      if (pos > 0) {
        this.emit("info", false, data, this._bufpos, pos < len ? pos : len);
      }
      this._bufpos = len;
      return len;
    };
    SBMH.prototype._sbmh_lookup_char = function(data, pos) {
      return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];
    };
    SBMH.prototype._sbmh_memcmp = function(data, pos, len) {
      for (var i = 0; i < len; ++i) {
        if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) {
          return false;
        }
      }
      return true;
    };
    module.exports = SBMH;
  }
});

// node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js
var require_PartStream = __commonJS({
  "node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js"(exports, module) {
    "use strict";
    var inherits = __require("util").inherits;
    var ReadableStream = __require("stream").Readable;
    function PartStream(opts) {
      ReadableStream.call(this, opts);
    }
    inherits(PartStream, ReadableStream);
    PartStream.prototype._read = function(n) {
    };
    module.exports = PartStream;
  }
});

// node_modules/@fastify/busboy/lib/utils/getLimit.js
var require_getLimit = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/getLimit.js"(exports, module) {
    "use strict";
    module.exports = function getLimit(limits, name, defaultLimit) {
      if (!limits || limits[name] === void 0 || limits[name] === null) {
        return defaultLimit;
      }
      if (typeof limits[name] !== "number" || isNaN(limits[name])) {
        throw new TypeError("Limit " + name + " is not a valid number");
      }
      return limits[name];
    };
  }
});

// node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js
var require_HeaderParser = __commonJS({
  "node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js"(exports, module) {
    "use strict";
    var EventEmitter2 = __require("events").EventEmitter;
    var inherits = __require("util").inherits;
    var getLimit = require_getLimit();
    var StreamSearch = require_sbmh();
    var B_DCRLF = Buffer.from("\r\n\r\n");
    var RE_CRLF = /\r\n/g;
    var RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
    function HeaderParser(cfg) {
      EventEmitter2.call(this);
      cfg = cfg || {};
      const self = this;
      this.nread = 0;
      this.maxed = false;
      this.npairs = 0;
      this.maxHeaderPairs = getLimit(cfg, "maxHeaderPairs", 2e3);
      this.maxHeaderSize = getLimit(cfg, "maxHeaderSize", 80 * 1024);
      this.buffer = "";
      this.header = {};
      this.finished = false;
      this.ss = new StreamSearch(B_DCRLF);
      this.ss.on("info", function(isMatch, data, start, end) {
        if (data && !self.maxed) {
          if (self.nread + end - start >= self.maxHeaderSize) {
            end = self.maxHeaderSize - self.nread + start;
            self.nread = self.maxHeaderSize;
            self.maxed = true;
          } else {
            self.nread += end - start;
          }
          self.buffer += data.toString("binary", start, end);
        }
        if (isMatch) {
          self._finish();
        }
      });
    }
    inherits(HeaderParser, EventEmitter2);
    HeaderParser.prototype.push = function(data) {
      const r = this.ss.push(data);
      if (this.finished) {
        return r;
      }
    };
    HeaderParser.prototype.reset = function() {
      this.finished = false;
      this.buffer = "";
      this.header = {};
      this.ss.reset();
    };
    HeaderParser.prototype._finish = function() {
      if (this.buffer) {
        this._parseHeader();
      }
      this.ss.matches = this.ss.maxMatches;
      const header = this.header;
      this.header = {};
      this.buffer = "";
      this.finished = true;
      this.nread = this.npairs = 0;
      this.maxed = false;
      this.emit("header", header);
    };
    HeaderParser.prototype._parseHeader = function() {
      if (this.npairs === this.maxHeaderPairs) {
        return;
      }
      const lines = this.buffer.split(RE_CRLF);
      const len = lines.length;
      let m, h;
      for (var i = 0; i < len; ++i) {
        if (lines[i].length === 0) {
          continue;
        }
        if (lines[i][0] === "	" || lines[i][0] === " ") {
          if (h) {
            this.header[h][this.header[h].length - 1] += lines[i];
            continue;
          }
        }
        const posColon = lines[i].indexOf(":");
        if (posColon === -1 || posColon === 0) {
          return;
        }
        m = RE_HDR.exec(lines[i]);
        h = m[1].toLowerCase();
        this.header[h] = this.header[h] || [];
        this.header[h].push(m[2] || "");
        if (++this.npairs === this.maxHeaderPairs) {
          break;
        }
      }
    };
    module.exports = HeaderParser;
  }
});

// node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js
var require_Dicer = __commonJS({
  "node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js"(exports, module) {
    "use strict";
    var WritableStream = __require("stream").Writable;
    var inherits = __require("util").inherits;
    var StreamSearch = require_sbmh();
    var PartStream = require_PartStream();
    var HeaderParser = require_HeaderParser();
    var DASH = 45;
    var B_ONEDASH = Buffer.from("-");
    var B_CRLF = Buffer.from("\r\n");
    var EMPTY_FN = function() {
    };
    function Dicer(cfg) {
      if (!(this instanceof Dicer)) {
        return new Dicer(cfg);
      }
      WritableStream.call(this, cfg);
      if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== "string") {
        throw new TypeError("Boundary required");
      }
      if (typeof cfg.boundary === "string") {
        this.setBoundary(cfg.boundary);
      } else {
        this._bparser = void 0;
      }
      this._headerFirst = cfg.headerFirst;
      this._dashes = 0;
      this._parts = 0;
      this._finished = false;
      this._realFinish = false;
      this._isPreamble = true;
      this._justMatched = false;
      this._firstWrite = true;
      this._inHeader = true;
      this._part = void 0;
      this._cb = void 0;
      this._ignoreData = false;
      this._partOpts = { highWaterMark: cfg.partHwm };
      this._pause = false;
      const self = this;
      this._hparser = new HeaderParser(cfg);
      this._hparser.on("header", function(header) {
        self._inHeader = false;
        self._part.emit("header", header);
      });
    }
    inherits(Dicer, WritableStream);
    Dicer.prototype.emit = function(ev) {
      if (ev === "finish" && !this._realFinish) {
        if (!this._finished) {
          const self = this;
          process.nextTick(function() {
            self.emit("error", new Error("Unexpected end of multipart data"));
            if (self._part && !self._ignoreData) {
              const type = self._isPreamble ? "Preamble" : "Part";
              self._part.emit("error", new Error(type + " terminated early due to unexpected end of multipart data"));
              self._part.push(null);
              process.nextTick(function() {
                self._realFinish = true;
                self.emit("finish");
                self._realFinish = false;
              });
              return;
            }
            self._realFinish = true;
            self.emit("finish");
            self._realFinish = false;
          });
        }
      } else {
        WritableStream.prototype.emit.apply(this, arguments);
      }
    };
    Dicer.prototype._write = function(data, encoding, cb) {
      if (!this._hparser && !this._bparser) {
        return cb();
      }
      if (this._headerFirst && this._isPreamble) {
        if (!this._part) {
          this._part = new PartStream(this._partOpts);
          if (this.listenerCount("preamble") !== 0) {
            this.emit("preamble", this._part);
          } else {
            this._ignore();
          }
        }
        const r = this._hparser.push(data);
        if (!this._inHeader && r !== void 0 && r < data.length) {
          data = data.slice(r);
        } else {
          return cb();
        }
      }
      if (this._firstWrite) {
        this._bparser.push(B_CRLF);
        this._firstWrite = false;
      }
      this._bparser.push(data);
      if (this._pause) {
        this._cb = cb;
      } else {
        cb();
      }
    };
    Dicer.prototype.reset = function() {
      this._part = void 0;
      this._bparser = void 0;
      this._hparser = void 0;
    };
    Dicer.prototype.setBoundary = function(boundary) {
      const self = this;
      this._bparser = new StreamSearch("\r\n--" + boundary);
      this._bparser.on("info", function(isMatch, data, start, end) {
        self._oninfo(isMatch, data, start, end);
      });
    };
    Dicer.prototype._ignore = function() {
      if (this._part && !this._ignoreData) {
        this._ignoreData = true;
        this._part.on("error", EMPTY_FN);
        this._part.resume();
      }
    };
    Dicer.prototype._oninfo = function(isMatch, data, start, end) {
      let buf;
      const self = this;
      let i = 0;
      let r;
      let shouldWriteMore = true;
      if (!this._part && this._justMatched && data) {
        while (this._dashes < 2 && start + i < end) {
          if (data[start + i] === DASH) {
            ++i;
            ++this._dashes;
          } else {
            if (this._dashes) {
              buf = B_ONEDASH;
            }
            this._dashes = 0;
            break;
          }
        }
        if (this._dashes === 2) {
          if (start + i < end && this.listenerCount("trailer") !== 0) {
            this.emit("trailer", data.slice(start + i, end));
          }
          this.reset();
          this._finished = true;
          if (self._parts === 0) {
            self._realFinish = true;
            self.emit("finish");
            self._realFinish = false;
          }
        }
        if (this._dashes) {
          return;
        }
      }
      if (this._justMatched) {
        this._justMatched = false;
      }
      if (!this._part) {
        this._part = new PartStream(this._partOpts);
        this._part._read = function(n) {
          self._unpause();
        };
        if (this._isPreamble && this.listenerCount("preamble") !== 0) {
          this.emit("preamble", this._part);
        } else if (this._isPreamble !== true && this.listenerCount("part") !== 0) {
          this.emit("part", this._part);
        } else {
          this._ignore();
        }
        if (!this._isPreamble) {
          this._inHeader = true;
        }
      }
      if (data && start < end && !this._ignoreData) {
        if (this._isPreamble || !this._inHeader) {
          if (buf) {
            shouldWriteMore = this._part.push(buf);
          }
          shouldWriteMore = this._part.push(data.slice(start, end));
          if (!shouldWriteMore) {
            this._pause = true;
          }
        } else if (!this._isPreamble && this._inHeader) {
          if (buf) {
            this._hparser.push(buf);
          }
          r = this._hparser.push(data.slice(start, end));
          if (!this._inHeader && r !== void 0 && r < end) {
            this._oninfo(false, data, start + r, end);
          }
        }
      }
      if (isMatch) {
        this._hparser.reset();
        if (this._isPreamble) {
          this._isPreamble = false;
        } else {
          if (start !== end) {
            ++this._parts;
            this._part.on("end", function() {
              if (--self._parts === 0) {
                if (self._finished) {
                  self._realFinish = true;
                  self.emit("finish");
                  self._realFinish = false;
                } else {
                  self._unpause();
                }
              }
            });
          }
        }
        this._part.push(null);
        this._part = void 0;
        this._ignoreData = false;
        this._justMatched = true;
        this._dashes = 0;
      }
    };
    Dicer.prototype._unpause = function() {
      if (!this._pause) {
        return;
      }
      this._pause = false;
      if (this._cb) {
        const cb = this._cb;
        this._cb = void 0;
        cb();
      }
    };
    module.exports = Dicer;
  }
});

// node_modules/@fastify/busboy/lib/utils/decodeText.js
var require_decodeText = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/decodeText.js"(exports, module) {
    "use strict";
    var utf8Decoder = new TextDecoder("utf-8");
    var textDecoders = /* @__PURE__ */ new Map([
      ["utf-8", utf8Decoder],
      ["utf8", utf8Decoder]
    ]);
    function getDecoder(charset) {
      let lc;
      while (true) {
        switch (charset) {
          case "utf-8":
          case "utf8":
            return decoders.utf8;
          case "latin1":
          case "ascii":
          // TODO: Make these a separate, strict decoder?
          case "us-ascii":
          case "iso-8859-1":
          case "iso8859-1":
          case "iso88591":
          case "iso_8859-1":
          case "windows-1252":
          case "iso_8859-1:1987":
          case "cp1252":
          case "x-cp1252":
            return decoders.latin1;
          case "utf16le":
          case "utf-16le":
          case "ucs2":
          case "ucs-2":
            return decoders.utf16le;
          case "base64":
            return decoders.base64;
          default:
            if (lc === void 0) {
              lc = true;
              charset = charset.toLowerCase();
              continue;
            }
            return decoders.other.bind(charset);
        }
      }
    }
    var decoders = {
      utf8: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.utf8Slice(0, data.length);
      },
      latin1: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          return data;
        }
        return data.latin1Slice(0, data.length);
      },
      utf16le: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.ucs2Slice(0, data.length);
      },
      base64: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.base64Slice(0, data.length);
      },
      other: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        if (textDecoders.has(exports.toString())) {
          try {
            return textDecoders.get(exports).decode(data);
          } catch {
          }
        }
        return typeof data === "string" ? data : data.toString();
      }
    };
    function decodeText(text, sourceEncoding, destEncoding) {
      if (text) {
        return getDecoder(destEncoding)(text, sourceEncoding);
      }
      return text;
    }
    module.exports = decodeText;
  }
});

// node_modules/@fastify/busboy/lib/utils/parseParams.js
var require_parseParams = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/parseParams.js"(exports, module) {
    "use strict";
    var decodeText = require_decodeText();
    var RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;
    var EncodedLookup = {
      "%00": "\0",
      "%01": "",
      "%02": "",
      "%03": "",
      "%04": "",
      "%05": "",
      "%06": "",
      "%07": "\x07",
      "%08": "\b",
      "%09": "	",
      "%0a": "\n",
      "%0A": "\n",
      "%0b": "\v",
      "%0B": "\v",
      "%0c": "\f",
      "%0C": "\f",
      "%0d": "\r",
      "%0D": "\r",
      "%0e": "",
      "%0E": "",
      "%0f": "",
      "%0F": "",
      "%10": "",
      "%11": "",
      "%12": "",
      "%13": "",
      "%14": "",
      "%15": "",
      "%16": "",
      "%17": "",
      "%18": "",
      "%19": "",
      "%1a": "",
      "%1A": "",
      "%1b": "\x1B",
      "%1B": "\x1B",
      "%1c": "",
      "%1C": "",
      "%1d": "",
      "%1D": "",
      "%1e": "",
      "%1E": "",
      "%1f": "",
      "%1F": "",
      "%20": " ",
      "%21": "!",
      "%22": '"',
      "%23": "#",
      "%24": "$",
      "%25": "%",
      "%26": "&",
      "%27": "'",
      "%28": "(",
      "%29": ")",
      "%2a": "*",
      "%2A": "*",
      "%2b": "+",
      "%2B": "+",
      "%2c": ",",
      "%2C": ",",
      "%2d": "-",
      "%2D": "-",
      "%2e": ".",
      "%2E": ".",
      "%2f": "/",
      "%2F": "/",
      "%30": "0",
      "%31": "1",
      "%32": "2",
      "%33": "3",
      "%34": "4",
      "%35": "5",
      "%36": "6",
      "%37": "7",
      "%38": "8",
      "%39": "9",
      "%3a": ":",
      "%3A": ":",
      "%3b": ";",
      "%3B": ";",
      "%3c": "<",
      "%3C": "<",
      "%3d": "=",
      "%3D": "=",
      "%3e": ">",
      "%3E": ">",
      "%3f": "?",
      "%3F": "?",
      "%40": "@",
      "%41": "A",
      "%42": "B",
      "%43": "C",
      "%44": "D",
      "%45": "E",
      "%46": "F",
      "%47": "G",
      "%48": "H",
      "%49": "I",
      "%4a": "J",
      "%4A": "J",
      "%4b": "K",
      "%4B": "K",
      "%4c": "L",
      "%4C": "L",
      "%4d": "M",
      "%4D": "M",
      "%4e": "N",
      "%4E": "N",
      "%4f": "O",
      "%4F": "O",
      "%50": "P",
      "%51": "Q",
      "%52": "R",
      "%53": "S",
      "%54": "T",
      "%55": "U",
      "%56": "V",
      "%57": "W",
      "%58": "X",
      "%59": "Y",
      "%5a": "Z",
      "%5A": "Z",
      "%5b": "[",
      "%5B": "[",
      "%5c": "\\",
      "%5C": "\\",
      "%5d": "]",
      "%5D": "]",
      "%5e": "^",
      "%5E": "^",
      "%5f": "_",
      "%5F": "_",
      "%60": "`",
      "%61": "a",
      "%62": "b",
      "%63": "c",
      "%64": "d",
      "%65": "e",
      "%66": "f",
      "%67": "g",
      "%68": "h",
      "%69": "i",
      "%6a": "j",
      "%6A": "j",
      "%6b": "k",
      "%6B": "k",
      "%6c": "l",
      "%6C": "l",
      "%6d": "m",
      "%6D": "m",
      "%6e": "n",
      "%6E": "n",
      "%6f": "o",
      "%6F": "o",
      "%70": "p",
      "%71": "q",
      "%72": "r",
      "%73": "s",
      "%74": "t",
      "%75": "u",
      "%76": "v",
      "%77": "w",
      "%78": "x",
      "%79": "y",
      "%7a": "z",
      "%7A": "z",
      "%7b": "{",
      "%7B": "{",
      "%7c": "|",
      "%7C": "|",
      "%7d": "}",
      "%7D": "}",
      "%7e": "~",
      "%7E": "~",
      "%7f": "\x7F",
      "%7F": "\x7F",
      "%80": "\x80",
      "%81": "\x81",
      "%82": "\x82",
      "%83": "\x83",
      "%84": "\x84",
      "%85": "\x85",
      "%86": "\x86",
      "%87": "\x87",
      "%88": "\x88",
      "%89": "\x89",
      "%8a": "\x8A",
      "%8A": "\x8A",
      "%8b": "\x8B",
      "%8B": "\x8B",
      "%8c": "\x8C",
      "%8C": "\x8C",
      "%8d": "\x8D",
      "%8D": "\x8D",
      "%8e": "\x8E",
      "%8E": "\x8E",
      "%8f": "\x8F",
      "%8F": "\x8F",
      "%90": "\x90",
      "%91": "\x91",
      "%92": "\x92",
      "%93": "\x93",
      "%94": "\x94",
      "%95": "\x95",
      "%96": "\x96",
      "%97": "\x97",
      "%98": "\x98",
      "%99": "\x99",
      "%9a": "\x9A",
      "%9A": "\x9A",
      "%9b": "\x9B",
      "%9B": "\x9B",
      "%9c": "\x9C",
      "%9C": "\x9C",
      "%9d": "\x9D",
      "%9D": "\x9D",
      "%9e": "\x9E",
      "%9E": "\x9E",
      "%9f": "\x9F",
      "%9F": "\x9F",
      "%a0": "\xA0",
      "%A0": "\xA0",
      "%a1": "\xA1",
      "%A1": "\xA1",
      "%a2": "\xA2",
      "%A2": "\xA2",
      "%a3": "\xA3",
      "%A3": "\xA3",
      "%a4": "\xA4",
      "%A4": "\xA4",
      "%a5": "\xA5",
      "%A5": "\xA5",
      "%a6": "\xA6",
      "%A6": "\xA6",
      "%a7": "\xA7",
      "%A7": "\xA7",
      "%a8": "\xA8",
      "%A8": "\xA8",
      "%a9": "\xA9",
      "%A9": "\xA9",
      "%aa": "\xAA",
      "%Aa": "\xAA",
      "%aA": "\xAA",
      "%AA": "\xAA",
      "%ab": "\xAB",
      "%Ab": "\xAB",
      "%aB": "\xAB",
      "%AB": "\xAB",
      "%ac": "\xAC",
      "%Ac": "\xAC",
      "%aC": "\xAC",
      "%AC": "\xAC",
      "%ad": "\xAD",
      "%Ad": "\xAD",
      "%aD": "\xAD",
      "%AD": "\xAD",
      "%ae": "\xAE",
      "%Ae": "\xAE",
      "%aE": "\xAE",
      "%AE": "\xAE",
      "%af": "\xAF",
      "%Af": "\xAF",
      "%aF": "\xAF",
      "%AF": "\xAF",
      "%b0": "\xB0",
      "%B0": "\xB0",
      "%b1": "\xB1",
      "%B1": "\xB1",
      "%b2": "\xB2",
      "%B2": "\xB2",
      "%b3": "\xB3",
      "%B3": "\xB3",
      "%b4": "\xB4",
      "%B4": "\xB4",
      "%b5": "\xB5",
      "%B5": "\xB5",
      "%b6": "\xB6",
      "%B6": "\xB6",
      "%b7": "\xB7",
      "%B7": "\xB7",
      "%b8": "\xB8",
      "%B8": "\xB8",
      "%b9": "\xB9",
      "%B9": "\xB9",
      "%ba": "\xBA",
      "%Ba": "\xBA",
      "%bA": "\xBA",
      "%BA": "\xBA",
      "%bb": "\xBB",
      "%Bb": "\xBB",
      "%bB": "\xBB",
      "%BB": "\xBB",
      "%bc": "\xBC",
      "%Bc": "\xBC",
      "%bC": "\xBC",
      "%BC": "\xBC",
      "%bd": "\xBD",
      "%Bd": "\xBD",
      "%bD": "\xBD",
      "%BD": "\xBD",
      "%be": "\xBE",
      "%Be": "\xBE",
      "%bE": "\xBE",
      "%BE": "\xBE",
      "%bf": "\xBF",
      "%Bf": "\xBF",
      "%bF": "\xBF",
      "%BF": "\xBF",
      "%c0": "\xC0",
      "%C0": "\xC0",
      "%c1": "\xC1",
      "%C1": "\xC1",
      "%c2": "\xC2",
      "%C2": "\xC2",
      "%c3": "\xC3",
      "%C3": "\xC3",
      "%c4": "\xC4",
      "%C4": "\xC4",
      "%c5": "\xC5",
      "%C5": "\xC5",
      "%c6": "\xC6",
      "%C6": "\xC6",
      "%c7": "\xC7",
      "%C7": "\xC7",
      "%c8": "\xC8",
      "%C8": "\xC8",
      "%c9": "\xC9",
      "%C9": "\xC9",
      "%ca": "\xCA",
      "%Ca": "\xCA",
      "%cA": "\xCA",
      "%CA": "\xCA",
      "%cb": "\xCB",
      "%Cb": "\xCB",
      "%cB": "\xCB",
      "%CB": "\xCB",
      "%cc": "\xCC",
      "%Cc": "\xCC",
      "%cC": "\xCC",
      "%CC": "\xCC",
      "%cd": "\xCD",
      "%Cd": "\xCD",
      "%cD": "\xCD",
      "%CD": "\xCD",
      "%ce": "\xCE",
      "%Ce": "\xCE",
      "%cE": "\xCE",
      "%CE": "\xCE",
      "%cf": "\xCF",
      "%Cf": "\xCF",
      "%cF": "\xCF",
      "%CF": "\xCF",
      "%d0": "\xD0",
      "%D0": "\xD0",
      "%d1": "\xD1",
      "%D1": "\xD1",
      "%d2": "\xD2",
      "%D2": "\xD2",
      "%d3": "\xD3",
      "%D3": "\xD3",
      "%d4": "\xD4",
      "%D4": "\xD4",
      "%d5": "\xD5",
      "%D5": "\xD5",
      "%d6": "\xD6",
      "%D6": "\xD6",
      "%d7": "\xD7",
      "%D7": "\xD7",
      "%d8": "\xD8",
      "%D8": "\xD8",
      "%d9": "\xD9",
      "%D9": "\xD9",
      "%da": "\xDA",
      "%Da": "\xDA",
      "%dA": "\xDA",
      "%DA": "\xDA",
      "%db": "\xDB",
      "%Db": "\xDB",
      "%dB": "\xDB",
      "%DB": "\xDB",
      "%dc": "\xDC",
      "%Dc": "\xDC",
      "%dC": "\xDC",
      "%DC": "\xDC",
      "%dd": "\xDD",
      "%Dd": "\xDD",
      "%dD": "\xDD",
      "%DD": "\xDD",
      "%de": "\xDE",
      "%De": "\xDE",
      "%dE": "\xDE",
      "%DE": "\xDE",
      "%df": "\xDF",
      "%Df": "\xDF",
      "%dF": "\xDF",
      "%DF": "\xDF",
      "%e0": "\xE0",
      "%E0": "\xE0",
      "%e1": "\xE1",
      "%E1": "\xE1",
      "%e2": "\xE2",
      "%E2": "\xE2",
      "%e3": "\xE3",
      "%E3": "\xE3",
      "%e4": "\xE4",
      "%E4": "\xE4",
      "%e5": "\xE5",
      "%E5": "\xE5",
      "%e6": "\xE6",
      "%E6": "\xE6",
      "%e7": "\xE7",
      "%E7": "\xE7",
      "%e8": "\xE8",
      "%E8": "\xE8",
      "%e9": "\xE9",
      "%E9": "\xE9",
      "%ea": "\xEA",
      "%Ea": "\xEA",
      "%eA": "\xEA",
      "%EA": "\xEA",
      "%eb": "\xEB",
      "%Eb": "\xEB",
      "%eB": "\xEB",
      "%EB": "\xEB",
      "%ec": "\xEC",
      "%Ec": "\xEC",
      "%eC": "\xEC",
      "%EC": "\xEC",
      "%ed": "\xED",
      "%Ed": "\xED",
      "%eD": "\xED",
      "%ED": "\xED",
      "%ee": "\xEE",
      "%Ee": "\xEE",
      "%eE": "\xEE",
      "%EE": "\xEE",
      "%ef": "\xEF",
      "%Ef": "\xEF",
      "%eF": "\xEF",
      "%EF": "\xEF",
      "%f0": "\xF0",
      "%F0": "\xF0",
      "%f1": "\xF1",
      "%F1": "\xF1",
      "%f2": "\xF2",
      "%F2": "\xF2",
      "%f3": "\xF3",
      "%F3": "\xF3",
      "%f4": "\xF4",
      "%F4": "\xF4",
      "%f5": "\xF5",
      "%F5": "\xF5",
      "%f6": "\xF6",
      "%F6": "\xF6",
      "%f7": "\xF7",
      "%F7": "\xF7",
      "%f8": "\xF8",
      "%F8": "\xF8",
      "%f9": "\xF9",
      "%F9": "\xF9",
      "%fa": "\xFA",
      "%Fa": "\xFA",
      "%fA": "\xFA",
      "%FA": "\xFA",
      "%fb": "\xFB",
      "%Fb": "\xFB",
      "%fB": "\xFB",
      "%FB": "\xFB",
      "%fc": "\xFC",
      "%Fc": "\xFC",
      "%fC": "\xFC",
      "%FC": "\xFC",
      "%fd": "\xFD",
      "%Fd": "\xFD",
      "%fD": "\xFD",
      "%FD": "\xFD",
      "%fe": "\xFE",
      "%Fe": "\xFE",
      "%fE": "\xFE",
      "%FE": "\xFE",
      "%ff": "\xFF",
      "%Ff": "\xFF",
      "%fF": "\xFF",
      "%FF": "\xFF"
    };
    function encodedReplacer(match) {
      return EncodedLookup[match];
    }
    var STATE_KEY = 0;
    var STATE_VALUE = 1;
    var STATE_CHARSET = 2;
    var STATE_LANG = 3;
    function parseParams(str) {
      const res = [];
      let state = STATE_KEY;
      let charset = "";
      let inquote = false;
      let escaping = false;
      let p = 0;
      let tmp = "";
      const len = str.length;
      for (var i = 0; i < len; ++i) {
        const char = str[i];
        if (char === "\\" && inquote) {
          if (escaping) {
            escaping = false;
          } else {
            escaping = true;
            continue;
          }
        } else if (char === '"') {
          if (!escaping) {
            if (inquote) {
              inquote = false;
              state = STATE_KEY;
            } else {
              inquote = true;
            }
            continue;
          } else {
            escaping = false;
          }
        } else {
          if (escaping && inquote) {
            tmp += "\\";
          }
          escaping = false;
          if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
            if (state === STATE_CHARSET) {
              state = STATE_LANG;
              charset = tmp.substring(1);
            } else {
              state = STATE_VALUE;
            }
            tmp = "";
            continue;
          } else if (state === STATE_KEY && (char === "*" || char === "=") && res.length) {
            state = char === "*" ? STATE_CHARSET : STATE_VALUE;
            res[p] = [tmp, void 0];
            tmp = "";
            continue;
          } else if (!inquote && char === ";") {
            state = STATE_KEY;
            if (charset) {
              if (tmp.length) {
                tmp = decodeText(
                  tmp.replace(RE_ENCODED, encodedReplacer),
                  "binary",
                  charset
                );
              }
              charset = "";
            } else if (tmp.length) {
              tmp = decodeText(tmp, "binary", "utf8");
            }
            if (res[p] === void 0) {
              res[p] = tmp;
            } else {
              res[p][1] = tmp;
            }
            tmp = "";
            ++p;
            continue;
          } else if (!inquote && (char === " " || char === "	")) {
            continue;
          }
        }
        tmp += char;
      }
      if (charset && tmp.length) {
        tmp = decodeText(
          tmp.replace(RE_ENCODED, encodedReplacer),
          "binary",
          charset
        );
      } else if (tmp) {
        tmp = decodeText(tmp, "binary", "utf8");
      }
      if (res[p] === void 0) {
        if (tmp) {
          res[p] = tmp;
        }
      } else {
        res[p][1] = tmp;
      }
      return res;
    }
    module.exports = parseParams;
  }
});

// node_modules/@fastify/busboy/lib/utils/basename.js
var require_basename = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/basename.js"(exports, module) {
    "use strict";
    module.exports = function basename2(path12) {
      if (typeof path12 !== "string") {
        return "";
      }
      for (var i = path12.length - 1; i >= 0; --i) {
        switch (path12.charCodeAt(i)) {
          case 47:
          // '/'
          case 92:
            path12 = path12.slice(i + 1);
            return path12 === ".." || path12 === "." ? "" : path12;
        }
      }
      return path12 === ".." || path12 === "." ? "" : path12;
    };
  }
});

// node_modules/@fastify/busboy/lib/types/multipart.js
var require_multipart = __commonJS({
  "node_modules/@fastify/busboy/lib/types/multipart.js"(exports, module) {
    "use strict";
    var { Readable } = __require("stream");
    var { inherits } = __require("util");
    var Dicer = require_Dicer();
    var parseParams = require_parseParams();
    var decodeText = require_decodeText();
    var basename2 = require_basename();
    var getLimit = require_getLimit();
    var RE_BOUNDARY = /^boundary$/i;
    var RE_FIELD = /^form-data$/i;
    var RE_CHARSET = /^charset$/i;
    var RE_FILENAME = /^filename$/i;
    var RE_NAME = /^name$/i;
    Multipart.detect = /^multipart\/form-data/i;
    function Multipart(boy, cfg) {
      let i;
      let len;
      const self = this;
      let boundary;
      const limits = cfg.limits;
      const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== void 0);
      const parsedConType = cfg.parsedConType || [];
      const defCharset = cfg.defCharset || "utf8";
      const preservePath = cfg.preservePath;
      const fileOpts = { highWaterMark: cfg.fileHwm };
      for (i = 0, len = parsedConType.length; i < len; ++i) {
        if (Array.isArray(parsedConType[i]) && RE_BOUNDARY.test(parsedConType[i][0])) {
          boundary = parsedConType[i][1];
          break;
        }
      }
      function checkFinished() {
        if (nends === 0 && finished && !boy._done) {
          finished = false;
          self.end();
        }
      }
      if (typeof boundary !== "string") {
        throw new Error("Multipart: Boundary not found");
      }
      const fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
      const fileSizeLimit = getLimit(limits, "fileSize", Infinity);
      const filesLimit = getLimit(limits, "files", Infinity);
      const fieldsLimit = getLimit(limits, "fields", Infinity);
      const partsLimit = getLimit(limits, "parts", Infinity);
      const headerPairsLimit = getLimit(limits, "headerPairs", 2e3);
      const headerSizeLimit = getLimit(limits, "headerSize", 80 * 1024);
      let nfiles = 0;
      let nfields = 0;
      let nends = 0;
      let curFile;
      let curField;
      let finished = false;
      this._needDrain = false;
      this._pause = false;
      this._cb = void 0;
      this._nparts = 0;
      this._boy = boy;
      const parserCfg = {
        boundary,
        maxHeaderPairs: headerPairsLimit,
        maxHeaderSize: headerSizeLimit,
        partHwm: fileOpts.highWaterMark,
        highWaterMark: cfg.highWaterMark
      };
      this.parser = new Dicer(parserCfg);
      this.parser.on("drain", function() {
        self._needDrain = false;
        if (self._cb && !self._pause) {
          const cb = self._cb;
          self._cb = void 0;
          cb();
        }
      }).on("part", function onPart(part) {
        if (++self._nparts > partsLimit) {
          self.parser.removeListener("part", onPart);
          self.parser.on("part", skipPart);
          boy.hitPartsLimit = true;
          boy.emit("partsLimit");
          return skipPart(part);
        }
        if (curField) {
          const field = curField;
          field.emit("end");
          field.removeAllListeners("end");
        }
        part.on("header", function(header) {
          let contype;
          let fieldname;
          let parsed;
          let charset;
          let encoding;
          let filename;
          let nsize = 0;
          if (header["content-type"]) {
            parsed = parseParams(header["content-type"][0]);
            if (parsed[0]) {
              contype = parsed[0].toLowerCase();
              for (i = 0, len = parsed.length; i < len; ++i) {
                if (RE_CHARSET.test(parsed[i][0])) {
                  charset = parsed[i][1].toLowerCase();
                  break;
                }
              }
            }
          }
          if (contype === void 0) {
            contype = "text/plain";
          }
          if (charset === void 0) {
            charset = defCharset;
          }
          if (header["content-disposition"]) {
            parsed = parseParams(header["content-disposition"][0]);
            if (!RE_FIELD.test(parsed[0])) {
              return skipPart(part);
            }
            for (i = 0, len = parsed.length; i < len; ++i) {
              if (RE_NAME.test(parsed[i][0])) {
                fieldname = parsed[i][1];
              } else if (RE_FILENAME.test(parsed[i][0])) {
                filename = parsed[i][1];
                if (!preservePath) {
                  filename = basename2(filename);
                }
              }
            }
          } else {
            return skipPart(part);
          }
          if (header["content-transfer-encoding"]) {
            encoding = header["content-transfer-encoding"][0].toLowerCase();
          } else {
            encoding = "7bit";
          }
          let onData, onEnd;
          if (isPartAFile(fieldname, contype, filename)) {
            if (nfiles === filesLimit) {
              if (!boy.hitFilesLimit) {
                boy.hitFilesLimit = true;
                boy.emit("filesLimit");
              }
              return skipPart(part);
            }
            ++nfiles;
            if (boy.listenerCount("file") === 0) {
              self.parser._ignore();
              return;
            }
            ++nends;
            const file = new FileStream(fileOpts);
            curFile = file;
            file.on("end", function() {
              --nends;
              self._pause = false;
              checkFinished();
              if (self._cb && !self._needDrain) {
                const cb = self._cb;
                self._cb = void 0;
                cb();
              }
            });
            file._read = function(n) {
              if (!self._pause) {
                return;
              }
              self._pause = false;
              if (self._cb && !self._needDrain) {
                const cb = self._cb;
                self._cb = void 0;
                cb();
              }
            };
            boy.emit("file", fieldname, file, filename, encoding, contype);
            onData = function(data) {
              if ((nsize += data.length) > fileSizeLimit) {
                const extralen = fileSizeLimit - nsize + data.length;
                if (extralen > 0) {
                  file.push(data.slice(0, extralen));
                }
                file.truncated = true;
                file.bytesRead = fileSizeLimit;
                part.removeAllListeners("data");
                file.emit("limit");
                return;
              } else if (!file.push(data)) {
                self._pause = true;
              }
              file.bytesRead = nsize;
            };
            onEnd = function() {
              curFile = void 0;
              file.push(null);
            };
          } else {
            if (nfields === fieldsLimit) {
              if (!boy.hitFieldsLimit) {
                boy.hitFieldsLimit = true;
                boy.emit("fieldsLimit");
              }
              return skipPart(part);
            }
            ++nfields;
            ++nends;
            let buffer = "";
            let truncated = false;
            curField = part;
            onData = function(data) {
              if ((nsize += data.length) > fieldSizeLimit) {
                const extralen = fieldSizeLimit - (nsize - data.length);
                buffer += data.toString("binary", 0, extralen);
                truncated = true;
                part.removeAllListeners("data");
              } else {
                buffer += data.toString("binary");
              }
            };
            onEnd = function() {
              curField = void 0;
              if (buffer.length) {
                buffer = decodeText(buffer, "binary", charset);
              }
              boy.emit("field", fieldname, buffer, false, truncated, encoding, contype);
              --nends;
              checkFinished();
            };
          }
          part._readableState.sync = false;
          part.on("data", onData);
          part.on("end", onEnd);
        }).on("error", function(err) {
          if (curFile) {
            curFile.emit("error", err);
          }
        });
      }).on("error", function(err) {
        boy.emit("error", err);
      }).on("finish", function() {
        finished = true;
        checkFinished();
      });
    }
    Multipart.prototype.write = function(chunk, cb) {
      const r = this.parser.write(chunk);
      if (r && !this._pause) {
        cb();
      } else {
        this._needDrain = !r;
        this._cb = cb;
      }
    };
    Multipart.prototype.end = function() {
      const self = this;
      if (self.parser.writable) {
        self.parser.end();
      } else if (!self._boy._done) {
        process.nextTick(function() {
          self._boy._done = true;
          self._boy.emit("finish");
        });
      }
    };
    function skipPart(part) {
      part.resume();
    }
    function FileStream(opts) {
      Readable.call(this, opts);
      this.bytesRead = 0;
      this.truncated = false;
    }
    inherits(FileStream, Readable);
    FileStream.prototype._read = function(n) {
    };
    module.exports = Multipart;
  }
});

// node_modules/@fastify/busboy/lib/utils/Decoder.js
var require_Decoder = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/Decoder.js"(exports, module) {
    "use strict";
    var RE_PLUS = /\+/g;
    var HEX = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    function Decoder() {
      this.buffer = void 0;
    }
    Decoder.prototype.write = function(str) {
      str = str.replace(RE_PLUS, " ");
      let res = "";
      let i = 0;
      let p = 0;
      const len = str.length;
      for (; i < len; ++i) {
        if (this.buffer !== void 0) {
          if (!HEX[str.charCodeAt(i)]) {
            res += "%" + this.buffer;
            this.buffer = void 0;
            --i;
          } else {
            this.buffer += str[i];
            ++p;
            if (this.buffer.length === 2) {
              res += String.fromCharCode(parseInt(this.buffer, 16));
              this.buffer = void 0;
            }
          }
        } else if (str[i] === "%") {
          if (i > p) {
            res += str.substring(p, i);
            p = i;
          }
          this.buffer = "";
          ++p;
        }
      }
      if (p < len && this.buffer === void 0) {
        res += str.substring(p);
      }
      return res;
    };
    Decoder.prototype.reset = function() {
      this.buffer = void 0;
    };
    module.exports = Decoder;
  }
});

// node_modules/@fastify/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS({
  "node_modules/@fastify/busboy/lib/types/urlencoded.js"(exports, module) {
    "use strict";
    var Decoder = require_Decoder();
    var decodeText = require_decodeText();
    var getLimit = require_getLimit();
    var RE_CHARSET = /^charset$/i;
    UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
    function UrlEncoded(boy, cfg) {
      const limits = cfg.limits;
      const parsedConType = cfg.parsedConType;
      this.boy = boy;
      this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
      this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100);
      this.fieldsLimit = getLimit(limits, "fields", Infinity);
      let charset;
      for (var i = 0, len = parsedConType.length; i < len; ++i) {
        if (Array.isArray(parsedConType[i]) && RE_CHARSET.test(parsedConType[i][0])) {
          charset = parsedConType[i][1].toLowerCase();
          break;
        }
      }
      if (charset === void 0) {
        charset = cfg.defCharset || "utf8";
      }
      this.decoder = new Decoder();
      this.charset = charset;
      this._fields = 0;
      this._state = "key";
      this._checkingBytes = true;
      this._bytesKey = 0;
      this._bytesVal = 0;
      this._key = "";
      this._val = "";
      this._keyTrunc = false;
      this._valTrunc = false;
      this._hitLimit = false;
    }
    UrlEncoded.prototype.write = function(data, cb) {
      if (this._fields === this.fieldsLimit) {
        if (!this.boy.hitFieldsLimit) {
          this.boy.hitFieldsLimit = true;
          this.boy.emit("fieldsLimit");
        }
        return cb();
      }
      let idxeq;
      let idxamp;
      let i;
      let p = 0;
      const len = data.length;
      while (p < len) {
        if (this._state === "key") {
          idxeq = idxamp = void 0;
          for (i = p; i < len; ++i) {
            if (!this._checkingBytes) {
              ++p;
            }
            if (data[i] === 61) {
              idxeq = i;
              break;
            } else if (data[i] === 38) {
              idxamp = i;
              break;
            }
            if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesKey;
            }
          }
          if (idxeq !== void 0) {
            if (idxeq > p) {
              this._key += this.decoder.write(data.toString("binary", p, idxeq));
            }
            this._state = "val";
            this._hitLimit = false;
            this._checkingBytes = true;
            this._val = "";
            this._bytesVal = 0;
            this._valTrunc = false;
            this.decoder.reset();
            p = idxeq + 1;
          } else if (idxamp !== void 0) {
            ++this._fields;
            let key;
            const keyTrunc = this._keyTrunc;
            if (idxamp > p) {
              key = this._key += this.decoder.write(data.toString("binary", p, idxamp));
            } else {
              key = this._key;
            }
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            if (key.length) {
              this.boy.emit(
                "field",
                decodeText(key, "binary", this.charset),
                "",
                keyTrunc,
                false
              );
            }
            p = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb();
            }
          } else if (this._hitLimit) {
            if (i > p) {
              this._key += this.decoder.write(data.toString("binary", p, i));
            }
            p = i;
            if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
              this._checkingBytes = false;
              this._keyTrunc = true;
            }
          } else {
            if (p < len) {
              this._key += this.decoder.write(data.toString("binary", p));
            }
            p = len;
          }
        } else {
          idxamp = void 0;
          for (i = p; i < len; ++i) {
            if (!this._checkingBytes) {
              ++p;
            }
            if (data[i] === 38) {
              idxamp = i;
              break;
            }
            if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesVal;
            }
          }
          if (idxamp !== void 0) {
            ++this._fields;
            if (idxamp > p) {
              this._val += this.decoder.write(data.toString("binary", p, idxamp));
            }
            this.boy.emit(
              "field",
              decodeText(this._key, "binary", this.charset),
              decodeText(this._val, "binary", this.charset),
              this._keyTrunc,
              this._valTrunc
            );
            this._state = "key";
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            p = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb();
            }
          } else if (this._hitLimit) {
            if (i > p) {
              this._val += this.decoder.write(data.toString("binary", p, i));
            }
            p = i;
            if (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
              this._checkingBytes = false;
              this._valTrunc = true;
            }
          } else {
            if (p < len) {
              this._val += this.decoder.write(data.toString("binary", p));
            }
            p = len;
          }
        }
      }
      cb();
    };
    UrlEncoded.prototype.end = function() {
      if (this.boy._done) {
        return;
      }
      if (this._state === "key" && this._key.length > 0) {
        this.boy.emit(
          "field",
          decodeText(this._key, "binary", this.charset),
          "",
          this._keyTrunc,
          false
        );
      } else if (this._state === "val") {
        this.boy.emit(
          "field",
          decodeText(this._key, "binary", this.charset),
          decodeText(this._val, "binary", this.charset),
          this._keyTrunc,
          this._valTrunc
        );
      }
      this.boy._done = true;
      this.boy.emit("finish");
    };
    module.exports = UrlEncoded;
  }
});

// node_modules/@fastify/busboy/lib/main.js
var require_main = __commonJS({
  "node_modules/@fastify/busboy/lib/main.js"(exports, module) {
    "use strict";
    var WritableStream = __require("stream").Writable;
    var { inherits } = __require("util");
    var Dicer = require_Dicer();
    var MultipartParser = require_multipart();
    var UrlencodedParser = require_urlencoded();
    var parseParams = require_parseParams();
    function Busboy(opts) {
      if (!(this instanceof Busboy)) {
        return new Busboy(opts);
      }
      if (typeof opts !== "object") {
        throw new TypeError("Busboy expected an options-Object.");
      }
      if (typeof opts.headers !== "object") {
        throw new TypeError("Busboy expected an options-Object with headers-attribute.");
      }
      if (typeof opts.headers["content-type"] !== "string") {
        throw new TypeError("Missing Content-Type-header.");
      }
      const {
        headers,
        ...streamOptions
      } = opts;
      this.opts = {
        autoDestroy: false,
        ...streamOptions
      };
      WritableStream.call(this, this.opts);
      this._done = false;
      this._parser = this.getParserByHeaders(headers);
      this._finished = false;
    }
    inherits(Busboy, WritableStream);
    Busboy.prototype.emit = function(ev) {
      if (ev === "finish") {
        if (!this._done) {
          this._parser?.end();
          return;
        } else if (this._finished) {
          return;
        }
        this._finished = true;
      }
      WritableStream.prototype.emit.apply(this, arguments);
    };
    Busboy.prototype.getParserByHeaders = function(headers) {
      const parsed = parseParams(headers["content-type"]);
      const cfg = {
        defCharset: this.opts.defCharset,
        fileHwm: this.opts.fileHwm,
        headers,
        highWaterMark: this.opts.highWaterMark,
        isPartAFile: this.opts.isPartAFile,
        limits: this.opts.limits,
        parsedConType: parsed,
        preservePath: this.opts.preservePath
      };
      if (MultipartParser.detect.test(parsed[0])) {
        return new MultipartParser(this, cfg);
      }
      if (UrlencodedParser.detect.test(parsed[0])) {
        return new UrlencodedParser(this, cfg);
      }
      throw new Error("Unsupported Content-Type.");
    };
    Busboy.prototype._write = function(chunk, encoding, cb) {
      this._parser.write(chunk, cb);
    };
    module.exports = Busboy;
    module.exports.default = Busboy;
    module.exports.Busboy = Busboy;
    module.exports.Dicer = Dicer;
  }
});

// node_modules/undici/lib/fetch/constants.js
var require_constants2 = __commonJS({
  "node_modules/undici/lib/fetch/constants.js"(exports, module) {
    "use strict";
    var { MessageChannel, receiveMessageOnPort } = __require("worker_threads");
    var corsSafeListedMethods = ["GET", "HEAD", "POST"];
    var corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
    var nullBodyStatus = [101, 204, 205, 304];
    var redirectStatus = [301, 302, 303, 307, 308];
    var redirectStatusSet = new Set(redirectStatus);
    var badPorts = [
      "1",
      "7",
      "9",
      "11",
      "13",
      "15",
      "17",
      "19",
      "20",
      "21",
      "22",
      "23",
      "25",
      "37",
      "42",
      "43",
      "53",
      "69",
      "77",
      "79",
      "87",
      "95",
      "101",
      "102",
      "103",
      "104",
      "109",
      "110",
      "111",
      "113",
      "115",
      "117",
      "119",
      "123",
      "135",
      "137",
      "139",
      "143",
      "161",
      "179",
      "389",
      "427",
      "465",
      "512",
      "513",
      "514",
      "515",
      "526",
      "530",
      "531",
      "532",
      "540",
      "548",
      "554",
      "556",
      "563",
      "587",
      "601",
      "636",
      "989",
      "990",
      "993",
      "995",
      "1719",
      "1720",
      "1723",
      "2049",
      "3659",
      "4045",
      "5060",
      "5061",
      "6000",
      "6566",
      "6665",
      "6666",
      "6667",
      "6668",
      "6669",
      "6697",
      "10080"
    ];
    var badPortsSet = new Set(badPorts);
    var referrerPolicy = [
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ];
    var referrerPolicySet = new Set(referrerPolicy);
    var requestRedirect = ["follow", "manual", "error"];
    var safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
    var safeMethodsSet = new Set(safeMethods);
    var requestMode = ["navigate", "same-origin", "no-cors", "cors"];
    var requestCredentials = ["omit", "same-origin", "include"];
    var requestCache = [
      "default",
      "no-store",
      "reload",
      "no-cache",
      "force-cache",
      "only-if-cached"
    ];
    var requestBodyHeader = [
      "content-encoding",
      "content-language",
      "content-location",
      "content-type",
      // See https://github.com/nodejs/undici/issues/2021
      // 'Content-Length' is a forbidden header name, which is typically
      // removed in the Headers implementation. However, undici doesn't
      // filter out headers, so we add it here.
      "content-length"
    ];
    var requestDuplex = [
      "half"
    ];
    var forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
    var forbiddenMethodsSet = new Set(forbiddenMethods);
    var subresource = [
      "audio",
      "audioworklet",
      "font",
      "image",
      "manifest",
      "paintworklet",
      "script",
      "style",
      "track",
      "video",
      "xslt",
      ""
    ];
    var subresourceSet = new Set(subresource);
    var DOMException2 = globalThis.DOMException ?? (() => {
      try {
        atob("~");
      } catch (err) {
        return Object.getPrototypeOf(err).constructor;
      }
    })();
    var channel;
    var structuredClone = globalThis.structuredClone ?? // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js
    // structuredClone was added in v17.0.0, but fetch supports v16.8
    function structuredClone2(value, options = void 0) {
      if (arguments.length === 0) {
        throw new TypeError("missing argument");
      }
      if (!channel) {
        channel = new MessageChannel();
      }
      channel.port1.unref();
      channel.port2.unref();
      channel.port1.postMessage(value, options?.transfer);
      return receiveMessageOnPort(channel.port2).message;
    };
    module.exports = {
      DOMException: DOMException2,
      structuredClone,
      subresource,
      forbiddenMethods,
      requestBodyHeader,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      redirectStatus,
      corsSafeListedMethods,
      nullBodyStatus,
      safeMethods,
      badPorts,
      requestDuplex,
      subresourceSet,
      badPortsSet,
      redirectStatusSet,
      corsSafeListedMethodsSet,
      safeMethodsSet,
      forbiddenMethodsSet,
      referrerPolicySet
    };
  }
});

// node_modules/undici/lib/fetch/global.js
var require_global = __commonJS({
  "node_modules/undici/lib/fetch/global.js"(exports, module) {
    "use strict";
    var globalOrigin = /* @__PURE__ */ Symbol.for("undici.globalOrigin.1");
    function getGlobalOrigin() {
      return globalThis[globalOrigin];
    }
    function setGlobalOrigin(newOrigin) {
      if (newOrigin === void 0) {
        Object.defineProperty(globalThis, globalOrigin, {
          value: void 0,
          writable: true,
          enumerable: false,
          configurable: false
        });
        return;
      }
      const parsedURL = new URL(newOrigin);
      if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
        throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
      }
      Object.defineProperty(globalThis, globalOrigin, {
        value: parsedURL,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    module.exports = {
      getGlobalOrigin,
      setGlobalOrigin
    };
  }
});

// node_modules/undici/lib/fetch/util.js
var require_util2 = __commonJS({
  "node_modules/undici/lib/fetch/util.js"(exports, module) {
    "use strict";
    var { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants2();
    var { getGlobalOrigin } = require_global();
    var { performance: performance2 } = __require("perf_hooks");
    var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util();
    var assert = __require("assert");
    var { isUint8Array } = __require("util/types");
    var supportedHashes = [];
    var crypto2;
    try {
      crypto2 = __require("crypto");
      const possibleRelevantHashes = ["sha256", "sha384", "sha512"];
      supportedHashes = crypto2.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
    } catch {
    }
    function responseURL(response) {
      const urlList = response.urlList;
      const length = urlList.length;
      return length === 0 ? null : urlList[length - 1].toString();
    }
    function responseLocationURL(response, requestFragment) {
      if (!redirectStatusSet.has(response.status)) {
        return null;
      }
      let location = response.headersList.get("location");
      if (location !== null && isValidHeaderValue(location)) {
        location = new URL(location, responseURL(response));
      }
      if (location && !location.hash) {
        location.hash = requestFragment;
      }
      return location;
    }
    function requestCurrentURL(request) {
      return request.urlList[request.urlList.length - 1];
    }
    function requestBadPort(request) {
      const url = requestCurrentURL(request);
      if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
        return "blocked";
      }
      return "allowed";
    }
    function isErrorLike(object) {
      return object instanceof Error || (object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException");
    }
    function isValidReasonPhrase(statusText) {
      for (let i = 0; i < statusText.length; ++i) {
        const c = statusText.charCodeAt(i);
        if (!(c === 9 || // HTAB
        c >= 32 && c <= 126 || // SP / VCHAR
        c >= 128 && c <= 255)) {
          return false;
        }
      }
      return true;
    }
    function isTokenCharCode(c) {
      switch (c) {
        case 34:
        case 40:
        case 41:
        case 44:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 123:
        case 125:
          return false;
        default:
          return c >= 33 && c <= 126;
      }
    }
    function isValidHTTPToken(characters) {
      if (characters.length === 0) {
        return false;
      }
      for (let i = 0; i < characters.length; ++i) {
        if (!isTokenCharCode(characters.charCodeAt(i))) {
          return false;
        }
      }
      return true;
    }
    function isValidHeaderName(potentialValue) {
      return isValidHTTPToken(potentialValue);
    }
    function isValidHeaderValue(potentialValue) {
      if (potentialValue.startsWith("	") || potentialValue.startsWith(" ") || potentialValue.endsWith("	") || potentialValue.endsWith(" ")) {
        return false;
      }
      if (potentialValue.includes("\0") || potentialValue.includes("\r") || potentialValue.includes("\n")) {
        return false;
      }
      return true;
    }
    function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
      const { headersList } = actualResponse;
      const policyHeader = (headersList.get("referrer-policy") ?? "").split(",");
      let policy = "";
      if (policyHeader.length > 0) {
        for (let i = policyHeader.length; i !== 0; i--) {
          const token = policyHeader[i - 1].trim();
          if (referrerPolicyTokens.has(token)) {
            policy = token;
            break;
          }
        }
      }
      if (policy !== "") {
        request.referrerPolicy = policy;
      }
    }
    function crossOriginResourcePolicyCheck() {
      return "allowed";
    }
    function corsCheck() {
      return "success";
    }
    function TAOCheck() {
      return "success";
    }
    function appendFetchMetadata(httpRequest) {
      let header = null;
      header = httpRequest.mode;
      httpRequest.headersList.set("sec-fetch-mode", header);
    }
    function appendRequestOriginHeader(request) {
      let serializedOrigin = request.origin;
      if (request.responseTainting === "cors" || request.mode === "websocket") {
        if (serializedOrigin) {
          request.headersList.append("origin", serializedOrigin);
        }
      } else if (request.method !== "GET" && request.method !== "HEAD") {
        switch (request.referrerPolicy) {
          case "no-referrer":
            serializedOrigin = null;
            break;
          case "no-referrer-when-downgrade":
          case "strict-origin":
          case "strict-origin-when-cross-origin":
            if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          case "same-origin":
            if (!sameOrigin(request, requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          default:
        }
        if (serializedOrigin) {
          request.headersList.append("origin", serializedOrigin);
        }
      }
    }
    function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
      return performance2.now();
    }
    function createOpaqueTimingInfo(timingInfo) {
      return {
        startTime: timingInfo.startTime ?? 0,
        redirectStartTime: 0,
        redirectEndTime: 0,
        postRedirectStartTime: timingInfo.startTime ?? 0,
        finalServiceWorkerStartTime: 0,
        finalNetworkResponseStartTime: 0,
        finalNetworkRequestStartTime: 0,
        endTime: 0,
        encodedBodySize: 0,
        decodedBodySize: 0,
        finalConnectionTimingInfo: null
      };
    }
    function makePolicyContainer() {
      return {
        referrerPolicy: "strict-origin-when-cross-origin"
      };
    }
    function clonePolicyContainer(policyContainer) {
      return {
        referrerPolicy: policyContainer.referrerPolicy
      };
    }
    function determineRequestsReferrer(request) {
      const policy = request.referrerPolicy;
      assert(policy);
      let referrerSource = null;
      if (request.referrer === "client") {
        const globalOrigin = getGlobalOrigin();
        if (!globalOrigin || globalOrigin.origin === "null") {
          return "no-referrer";
        }
        referrerSource = new URL(globalOrigin);
      } else if (request.referrer instanceof URL) {
        referrerSource = request.referrer;
      }
      let referrerURL = stripURLForReferrer(referrerSource);
      const referrerOrigin = stripURLForReferrer(referrerSource, true);
      if (referrerURL.toString().length > 4096) {
        referrerURL = referrerOrigin;
      }
      const areSameOrigin = sameOrigin(request, referrerURL);
      const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);
      switch (policy) {
        case "origin":
          return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
        case "unsafe-url":
          return referrerURL;
        case "same-origin":
          return areSameOrigin ? referrerOrigin : "no-referrer";
        case "origin-when-cross-origin":
          return areSameOrigin ? referrerURL : referrerOrigin;
        case "strict-origin-when-cross-origin": {
          const currentURL = requestCurrentURL(request);
          if (sameOrigin(referrerURL, currentURL)) {
            return referrerURL;
          }
          if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerOrigin;
        }
        case "strict-origin":
        // eslint-disable-line
        /**
           * 1. If referrerURL is a potentially trustworthy URL and
           * requests current URL is not a potentially trustworthy URL,
           * then return no referrer.
           * 2. Return referrerOrigin
          */
        case "no-referrer-when-downgrade":
        // eslint-disable-line
        /**
         * 1. If referrerURL is a potentially trustworthy URL and
         * requests current URL is not a potentially trustworthy URL,
         * then return no referrer.
         * 2. Return referrerOrigin
        */
        default:
          return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
      }
    }
    function stripURLForReferrer(url, originOnly) {
      assert(url instanceof URL);
      if (url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:") {
        return "no-referrer";
      }
      url.username = "";
      url.password = "";
      url.hash = "";
      if (originOnly) {
        url.pathname = "";
        url.search = "";
      }
      return url;
    }
    function isURLPotentiallyTrustworthy(url) {
      if (!(url instanceof URL)) {
        return false;
      }
      if (url.href === "about:blank" || url.href === "about:srcdoc") {
        return true;
      }
      if (url.protocol === "data:") return true;
      if (url.protocol === "file:") return true;
      return isOriginPotentiallyTrustworthy(url.origin);
      function isOriginPotentiallyTrustworthy(origin) {
        if (origin == null || origin === "null") return false;
        const originAsURL = new URL(origin);
        if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {
          return true;
        }
        if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost")) {
          return true;
        }
        return false;
      }
    }
    function bytesMatch(bytes, metadataList) {
      if (crypto2 === void 0) {
        return true;
      }
      const parsedMetadata = parseMetadata(metadataList);
      if (parsedMetadata === "no metadata") {
        return true;
      }
      if (parsedMetadata.length === 0) {
        return true;
      }
      const strongest = getStrongestMetadata(parsedMetadata);
      const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
      for (const item of metadata) {
        const algorithm = item.algo;
        const expectedValue = item.hash;
        let actualValue = crypto2.createHash(algorithm).update(bytes).digest("base64");
        if (actualValue[actualValue.length - 1] === "=") {
          if (actualValue[actualValue.length - 2] === "=") {
            actualValue = actualValue.slice(0, -2);
          } else {
            actualValue = actualValue.slice(0, -1);
          }
        }
        if (compareBase64Mixed(actualValue, expectedValue)) {
          return true;
        }
      }
      return false;
    }
    var parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
    function parseMetadata(metadata) {
      const result = [];
      let empty = true;
      for (const token of metadata.split(" ")) {
        empty = false;
        const parsedToken = parseHashWithOptions.exec(token);
        if (parsedToken === null || parsedToken.groups === void 0 || parsedToken.groups.algo === void 0) {
          continue;
        }
        const algorithm = parsedToken.groups.algo.toLowerCase();
        if (supportedHashes.includes(algorithm)) {
          result.push(parsedToken.groups);
        }
      }
      if (empty === true) {
        return "no metadata";
      }
      return result;
    }
    function getStrongestMetadata(metadataList) {
      let algorithm = metadataList[0].algo;
      if (algorithm[3] === "5") {
        return algorithm;
      }
      for (let i = 1; i < metadataList.length; ++i) {
        const metadata = metadataList[i];
        if (metadata.algo[3] === "5") {
          algorithm = "sha512";
          break;
        } else if (algorithm[3] === "3") {
          continue;
        } else if (metadata.algo[3] === "3") {
          algorithm = "sha384";
        }
      }
      return algorithm;
    }
    function filterMetadataListByAlgorithm(metadataList, algorithm) {
      if (metadataList.length === 1) {
        return metadataList;
      }
      let pos = 0;
      for (let i = 0; i < metadataList.length; ++i) {
        if (metadataList[i].algo === algorithm) {
          metadataList[pos++] = metadataList[i];
        }
      }
      metadataList.length = pos;
      return metadataList;
    }
    function compareBase64Mixed(actualValue, expectedValue) {
      if (actualValue.length !== expectedValue.length) {
        return false;
      }
      for (let i = 0; i < actualValue.length; ++i) {
        if (actualValue[i] !== expectedValue[i]) {
          if (actualValue[i] === "+" && expectedValue[i] === "-" || actualValue[i] === "/" && expectedValue[i] === "_") {
            continue;
          }
          return false;
        }
      }
      return true;
    }
    function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {
    }
    function sameOrigin(A, B) {
      if (A.origin === B.origin && A.origin === "null") {
        return true;
      }
      if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
        return true;
      }
      return false;
    }
    function createDeferredPromise() {
      let res;
      let rej;
      const promise = new Promise((resolve5, reject) => {
        res = resolve5;
        rej = reject;
      });
      return { promise, resolve: res, reject: rej };
    }
    function isAborted(fetchParams) {
      return fetchParams.controller.state === "aborted";
    }
    function isCancelled(fetchParams) {
      return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
    }
    var normalizeMethodRecord = {
      delete: "DELETE",
      DELETE: "DELETE",
      get: "GET",
      GET: "GET",
      head: "HEAD",
      HEAD: "HEAD",
      options: "OPTIONS",
      OPTIONS: "OPTIONS",
      post: "POST",
      POST: "POST",
      put: "PUT",
      PUT: "PUT"
    };
    Object.setPrototypeOf(normalizeMethodRecord, null);
    function normalizeMethod(method) {
      return normalizeMethodRecord[method.toLowerCase()] ?? method;
    }
    function serializeJavascriptValueToJSONString(value) {
      const result = JSON.stringify(value);
      if (result === void 0) {
        throw new TypeError("Value is not JSON serializable");
      }
      assert(typeof result === "string");
      return result;
    }
    var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
    function makeIterator(iterator, name, kind) {
      const object = {
        index: 0,
        kind,
        target: iterator
      };
      const i = {
        next() {
          if (Object.getPrototypeOf(this) !== i) {
            throw new TypeError(
              `'next' called on an object that does not implement interface ${name} Iterator.`
            );
          }
          const { index, kind: kind2, target } = object;
          const values = target();
          const len = values.length;
          if (index >= len) {
            return { value: void 0, done: true };
          }
          const pair = values[index];
          object.index = index + 1;
          return iteratorResult(pair, kind2);
        },
        // The class string of an iterator prototype object for a given interface is the
        // result of concatenating the identifier of the interface and the string " Iterator".
        [Symbol.toStringTag]: `${name} Iterator`
      };
      Object.setPrototypeOf(i, esIteratorPrototype);
      return Object.setPrototypeOf({}, i);
    }
    function iteratorResult(pair, kind) {
      let result;
      switch (kind) {
        case "key": {
          result = pair[0];
          break;
        }
        case "value": {
          result = pair[1];
          break;
        }
        case "key+value": {
          result = pair;
          break;
        }
      }
      return { value: result, done: false };
    }
    async function fullyReadBody(body, processBody, processBodyError) {
      const successSteps = processBody;
      const errorSteps = processBodyError;
      let reader;
      try {
        reader = body.stream.getReader();
      } catch (e) {
        errorSteps(e);
        return;
      }
      try {
        const result = await readAllBytes(reader);
        successSteps(result);
      } catch (e) {
        errorSteps(e);
      }
    }
    var ReadableStream = globalThis.ReadableStream;
    function isReadableStreamLike(stream) {
      if (!ReadableStream) {
        ReadableStream = __require("stream/web").ReadableStream;
      }
      return stream instanceof ReadableStream || stream[Symbol.toStringTag] === "ReadableStream" && typeof stream.tee === "function";
    }
    var MAXIMUM_ARGUMENT_LENGTH = 65535;
    function isomorphicDecode(input) {
      if (input.length < MAXIMUM_ARGUMENT_LENGTH) {
        return String.fromCharCode(...input);
      }
      return input.reduce((previous, current) => previous + String.fromCharCode(current), "");
    }
    function readableStreamClose(controller) {
      try {
        controller.close();
      } catch (err) {
        if (!err.message.includes("Controller is already closed")) {
          throw err;
        }
      }
    }
    function isomorphicEncode(input) {
      for (let i = 0; i < input.length; i++) {
        assert(input.charCodeAt(i) <= 255);
      }
      return input;
    }
    async function readAllBytes(reader) {
      const bytes = [];
      let byteLength = 0;
      while (true) {
        const { done, value: chunk } = await reader.read();
        if (done) {
          return Buffer.concat(bytes, byteLength);
        }
        if (!isUint8Array(chunk)) {
          throw new TypeError("Received non-Uint8Array chunk");
        }
        bytes.push(chunk);
        byteLength += chunk.length;
      }
    }
    function urlIsLocal(url) {
      assert("protocol" in url);
      const protocol = url.protocol;
      return protocol === "about:" || protocol === "blob:" || protocol === "data:";
    }
    function urlHasHttpsScheme(url) {
      if (typeof url === "string") {
        return url.startsWith("https:");
      }
      return url.protocol === "https:";
    }
    function urlIsHttpHttpsScheme(url) {
      assert("protocol" in url);
      const protocol = url.protocol;
      return protocol === "http:" || protocol === "https:";
    }
    var hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
    module.exports = {
      isAborted,
      isCancelled,
      createDeferredPromise,
      ReadableStreamFrom,
      toUSVString,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      coarsenedSharedCurrentTime,
      determineRequestsReferrer,
      makePolicyContainer,
      clonePolicyContainer,
      appendFetchMetadata,
      appendRequestOriginHeader,
      TAOCheck,
      corsCheck,
      crossOriginResourcePolicyCheck,
      createOpaqueTimingInfo,
      setRequestReferrerPolicyOnRedirect,
      isValidHTTPToken,
      requestBadPort,
      requestCurrentURL,
      responseURL,
      responseLocationURL,
      isBlobLike,
      isURLPotentiallyTrustworthy,
      isValidReasonPhrase,
      sameOrigin,
      normalizeMethod,
      serializeJavascriptValueToJSONString,
      makeIterator,
      isValidHeaderName,
      isValidHeaderValue,
      hasOwn,
      isErrorLike,
      fullyReadBody,
      bytesMatch,
      isReadableStreamLike,
      readableStreamClose,
      isomorphicEncode,
      isomorphicDecode,
      urlIsLocal,
      urlHasHttpsScheme,
      urlIsHttpHttpsScheme,
      readAllBytes,
      normalizeMethodRecord,
      parseMetadata
    };
  }
});

// node_modules/undici/lib/fetch/symbols.js
var require_symbols2 = __commonJS({
  "node_modules/undici/lib/fetch/symbols.js"(exports, module) {
    "use strict";
    module.exports = {
      kUrl: /* @__PURE__ */ Symbol("url"),
      kHeaders: /* @__PURE__ */ Symbol("headers"),
      kSignal: /* @__PURE__ */ Symbol("signal"),
      kState: /* @__PURE__ */ Symbol("state"),
      kGuard: /* @__PURE__ */ Symbol("guard"),
      kRealm: /* @__PURE__ */ Symbol("realm")
    };
  }
});

// node_modules/undici/lib/fetch/webidl.js
var require_webidl = __commonJS({
  "node_modules/undici/lib/fetch/webidl.js"(exports, module) {
    "use strict";
    var { types } = __require("util");
    var { hasOwn, toUSVString } = require_util2();
    var webidl = {};
    webidl.converters = {};
    webidl.util = {};
    webidl.errors = {};
    webidl.errors.exception = function(message) {
      return new TypeError(`${message.header}: ${message.message}`);
    };
    webidl.errors.conversionFailed = function(context2) {
      const plural = context2.types.length === 1 ? "" : " one of";
      const message = `${context2.argument} could not be converted to${plural}: ${context2.types.join(", ")}.`;
      return webidl.errors.exception({
        header: context2.prefix,
        message
      });
    };
    webidl.errors.invalidArgument = function(context2) {
      return webidl.errors.exception({
        header: context2.prefix,
        message: `"${context2.value}" is an invalid ${context2.type}.`
      });
    };
    webidl.brandCheck = function(V, I, opts = void 0) {
      if (opts?.strict !== false && !(V instanceof I)) {
        throw new TypeError("Illegal invocation");
      } else {
        return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];
      }
    };
    webidl.argumentLengthCheck = function({ length }, min, ctx) {
      if (length < min) {
        throw webidl.errors.exception({
          message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
          ...ctx
        });
      }
    };
    webidl.illegalConstructor = function() {
      throw webidl.errors.exception({
        header: "TypeError",
        message: "Illegal constructor"
      });
    };
    webidl.util.Type = function(V) {
      switch (typeof V) {
        case "undefined":
          return "Undefined";
        case "boolean":
          return "Boolean";
        case "string":
          return "String";
        case "symbol":
          return "Symbol";
        case "number":
          return "Number";
        case "bigint":
          return "BigInt";
        case "function":
        case "object": {
          if (V === null) {
            return "Null";
          }
          return "Object";
        }
      }
    };
    webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
      let upperBound;
      let lowerBound;
      if (bitLength === 64) {
        upperBound = Math.pow(2, 53) - 1;
        if (signedness === "unsigned") {
          lowerBound = 0;
        } else {
          lowerBound = Math.pow(-2, 53) + 1;
        }
      } else if (signedness === "unsigned") {
        lowerBound = 0;
        upperBound = Math.pow(2, bitLength) - 1;
      } else {
        lowerBound = Math.pow(-2, bitLength) - 1;
        upperBound = Math.pow(2, bitLength - 1) - 1;
      }
      let x = Number(V);
      if (x === 0) {
        x = 0;
      }
      if (opts.enforceRange === true) {
        if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Could not convert ${V} to an integer.`
          });
        }
        x = webidl.util.IntegerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
          });
        }
        return x;
      }
      if (!Number.isNaN(x) && opts.clamp === true) {
        x = Math.min(Math.max(x, lowerBound), upperBound);
        if (Math.floor(x) % 2 === 0) {
          x = Math.floor(x);
        } else {
          x = Math.ceil(x);
        }
        return x;
      }
      if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
        return 0;
      }
      x = webidl.util.IntegerPart(x);
      x = x % Math.pow(2, bitLength);
      if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
        return x - Math.pow(2, bitLength);
      }
      return x;
    };
    webidl.util.IntegerPart = function(n) {
      const r = Math.floor(Math.abs(n));
      if (n < 0) {
        return -1 * r;
      }
      return r;
    };
    webidl.sequenceConverter = function(converter) {
      return (V) => {
        if (webidl.util.Type(V) !== "Object") {
          throw webidl.errors.exception({
            header: "Sequence",
            message: `Value of type ${webidl.util.Type(V)} is not an Object.`
          });
        }
        const method = V?.[Symbol.iterator]?.();
        const seq = [];
        if (method === void 0 || typeof method.next !== "function") {
          throw webidl.errors.exception({
            header: "Sequence",
            message: "Object is not an iterator."
          });
        }
        while (true) {
          const { done, value } = method.next();
          if (done) {
            break;
          }
          seq.push(converter(value));
        }
        return seq;
      };
    };
    webidl.recordConverter = function(keyConverter, valueConverter) {
      return (O) => {
        if (webidl.util.Type(O) !== "Object") {
          throw webidl.errors.exception({
            header: "Record",
            message: `Value of type ${webidl.util.Type(O)} is not an Object.`
          });
        }
        const result = {};
        if (!types.isProxy(O)) {
          const keys2 = Object.keys(O);
          for (const key of keys2) {
            const typedKey = keyConverter(key);
            const typedValue = valueConverter(O[key]);
            result[typedKey] = typedValue;
          }
          return result;
        }
        const keys = Reflect.ownKeys(O);
        for (const key of keys) {
          const desc = Reflect.getOwnPropertyDescriptor(O, key);
          if (desc?.enumerable) {
            const typedKey = keyConverter(key);
            const typedValue = valueConverter(O[key]);
            result[typedKey] = typedValue;
          }
        }
        return result;
      };
    };
    webidl.interfaceConverter = function(i) {
      return (V, opts = {}) => {
        if (opts.strict !== false && !(V instanceof i)) {
          throw webidl.errors.exception({
            header: i.name,
            message: `Expected ${V} to be an instance of ${i.name}.`
          });
        }
        return V;
      };
    };
    webidl.dictionaryConverter = function(converters) {
      return (dictionary) => {
        const type = webidl.util.Type(dictionary);
        const dict = {};
        if (type === "Null" || type === "Undefined") {
          return dict;
        } else if (type !== "Object") {
          throw webidl.errors.exception({
            header: "Dictionary",
            message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
          });
        }
        for (const options of converters) {
          const { key, defaultValue, required, converter } = options;
          if (required === true) {
            if (!hasOwn(dictionary, key)) {
              throw webidl.errors.exception({
                header: "Dictionary",
                message: `Missing required key "${key}".`
              });
            }
          }
          let value = dictionary[key];
          const hasDefault = hasOwn(options, "defaultValue");
          if (hasDefault && value !== null) {
            value = value ?? defaultValue;
          }
          if (required || hasDefault || value !== void 0) {
            value = converter(value);
            if (options.allowedValues && !options.allowedValues.includes(value)) {
              throw webidl.errors.exception({
                header: "Dictionary",
                message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
              });
            }
            dict[key] = value;
          }
        }
        return dict;
      };
    };
    webidl.nullableConverter = function(converter) {
      return (V) => {
        if (V === null) {
          return V;
        }
        return converter(V);
      };
    };
    webidl.converters.DOMString = function(V, opts = {}) {
      if (V === null && opts.legacyNullToEmptyString) {
        return "";
      }
      if (typeof V === "symbol") {
        throw new TypeError("Could not convert argument of type symbol to string.");
      }
      return String(V);
    };
    webidl.converters.ByteString = function(V) {
      const x = webidl.converters.DOMString(V);
      for (let index = 0; index < x.length; index++) {
        if (x.charCodeAt(index) > 255) {
          throw new TypeError(
            `Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`
          );
        }
      }
      return x;
    };
    webidl.converters.USVString = toUSVString;
    webidl.converters.boolean = function(V) {
      const x = Boolean(V);
      return x;
    };
    webidl.converters.any = function(V) {
      return V;
    };
    webidl.converters["long long"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 64, "signed");
      return x;
    };
    webidl.converters["unsigned long long"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 64, "unsigned");
      return x;
    };
    webidl.converters["unsigned long"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 32, "unsigned");
      return x;
    };
    webidl.converters["unsigned short"] = function(V, opts) {
      const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts);
      return x;
    };
    webidl.converters.ArrayBuffer = function(V, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V)) {
        throw webidl.errors.conversionFailed({
          prefix: `${V}`,
          argument: `${V}`,
          types: ["ArrayBuffer"]
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.TypedArray = function(V, T, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isTypedArray(V) || V.constructor.name !== T.name) {
        throw webidl.errors.conversionFailed({
          prefix: `${T.name}`,
          argument: `${V}`,
          types: [T.name]
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.DataView = function(V, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isDataView(V)) {
        throw webidl.errors.exception({
          header: "DataView",
          message: "Object is not a DataView."
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.BufferSource = function(V, opts = {}) {
      if (types.isAnyArrayBuffer(V)) {
        return webidl.converters.ArrayBuffer(V, opts);
      }
      if (types.isTypedArray(V)) {
        return webidl.converters.TypedArray(V, V.constructor);
      }
      if (types.isDataView(V)) {
        return webidl.converters.DataView(V, opts);
      }
      throw new TypeError(`Could not convert ${V} to a BufferSource.`);
    };
    webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
      webidl.converters.ByteString
    );
    webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(
      webidl.converters["sequence<ByteString>"]
    );
    webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(
      webidl.converters.ByteString,
      webidl.converters.ByteString
    );
    module.exports = {
      webidl
    };
  }
});

// node_modules/undici/lib/fetch/dataURL.js
var require_dataURL = __commonJS({
  "node_modules/undici/lib/fetch/dataURL.js"(exports, module) {
    "use strict";
    var assert = __require("assert");
    var { atob: atob2 } = __require("buffer");
    var { isomorphicDecode } = require_util2();
    var encoder = new TextEncoder();
    var HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
    var HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/;
    var HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
    function dataURLProcessor(dataURL) {
      assert(dataURL.protocol === "data:");
      let input = URLSerializer(dataURL, true);
      input = input.slice(5);
      const position = { position: 0 };
      let mimeType = collectASequenceOfCodePointsFast(
        ",",
        input,
        position
      );
      const mimeTypeLength = mimeType.length;
      mimeType = removeASCIIWhitespace(mimeType, true, true);
      if (position.position >= input.length) {
        return "failure";
      }
      position.position++;
      const encodedBody = input.slice(mimeTypeLength + 1);
      let body = stringPercentDecode(encodedBody);
      if (/;(\u0020){0,}base64$/i.test(mimeType)) {
        const stringBody = isomorphicDecode(body);
        body = forgivingBase64(stringBody);
        if (body === "failure") {
          return "failure";
        }
        mimeType = mimeType.slice(0, -6);
        mimeType = mimeType.replace(/(\u0020)+$/, "");
        mimeType = mimeType.slice(0, -1);
      }
      if (mimeType.startsWith(";")) {
        mimeType = "text/plain" + mimeType;
      }
      let mimeTypeRecord = parseMIMEType(mimeType);
      if (mimeTypeRecord === "failure") {
        mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
      }
      return { mimeType: mimeTypeRecord, body };
    }
    function URLSerializer(url, excludeFragment = false) {
      if (!excludeFragment) {
        return url.href;
      }
      const href = url.href;
      const hashLength = url.hash.length;
      return hashLength === 0 ? href : href.substring(0, href.length - hashLength);
    }
    function collectASequenceOfCodePoints(condition, input, position) {
      let result = "";
      while (position.position < input.length && condition(input[position.position])) {
        result += input[position.position];
        position.position++;
      }
      return result;
    }
    function collectASequenceOfCodePointsFast(char, input, position) {
      const idx = input.indexOf(char, position.position);
      const start = position.position;
      if (idx === -1) {
        position.position = input.length;
        return input.slice(start);
      }
      position.position = idx;
      return input.slice(start, position.position);
    }
    function stringPercentDecode(input) {
      const bytes = encoder.encode(input);
      return percentDecode(bytes);
    }
    function percentDecode(input) {
      const output = [];
      for (let i = 0; i < input.length; i++) {
        const byte = input[i];
        if (byte !== 37) {
          output.push(byte);
        } else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {
          output.push(37);
        } else {
          const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);
          const bytePoint = Number.parseInt(nextTwoBytes, 16);
          output.push(bytePoint);
          i += 2;
        }
      }
      return Uint8Array.from(output);
    }
    function parseMIMEType(input) {
      input = removeHTTPWhitespace(input, true, true);
      const position = { position: 0 };
      const type = collectASequenceOfCodePointsFast(
        "/",
        input,
        position
      );
      if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
        return "failure";
      }
      if (position.position > input.length) {
        return "failure";
      }
      position.position++;
      let subtype = collectASequenceOfCodePointsFast(
        ";",
        input,
        position
      );
      subtype = removeHTTPWhitespace(subtype, false, true);
      if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
        return "failure";
      }
      const typeLowercase = type.toLowerCase();
      const subtypeLowercase = subtype.toLowerCase();
      const mimeType = {
        type: typeLowercase,
        subtype: subtypeLowercase,
        /** @type {Map<string, string>} */
        parameters: /* @__PURE__ */ new Map(),
        // https://mimesniff.spec.whatwg.org/#mime-type-essence
        essence: `${typeLowercase}/${subtypeLowercase}`
      };
      while (position.position < input.length) {
        position.position++;
        collectASequenceOfCodePoints(
          // https://fetch.spec.whatwg.org/#http-whitespace
          (char) => HTTP_WHITESPACE_REGEX.test(char),
          input,
          position
        );
        let parameterName = collectASequenceOfCodePoints(
          (char) => char !== ";" && char !== "=",
          input,
          position
        );
        parameterName = parameterName.toLowerCase();
        if (position.position < input.length) {
          if (input[position.position] === ";") {
            continue;
          }
          position.position++;
        }
        if (position.position > input.length) {
          break;
        }
        let parameterValue = null;
        if (input[position.position] === '"') {
          parameterValue = collectAnHTTPQuotedString(input, position, true);
          collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
        } else {
          parameterValue = collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
          parameterValue = removeHTTPWhitespace(parameterValue, false, true);
          if (parameterValue.length === 0) {
            continue;
          }
        }
        if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
          mimeType.parameters.set(parameterName, parameterValue);
        }
      }
      return mimeType;
    }
    function forgivingBase64(data) {
      data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
      if (data.length % 4 === 0) {
        data = data.replace(/=?=$/, "");
      }
      if (data.length % 4 === 1) {
        return "failure";
      }
      if (/[^+/0-9A-Za-z]/.test(data)) {
        return "failure";
      }
      const binary = atob2(data);
      const bytes = new Uint8Array(binary.length);
      for (let byte = 0; byte < binary.length; byte++) {
        bytes[byte] = binary.charCodeAt(byte);
      }
      return bytes;
    }
    function collectAnHTTPQuotedString(input, position, extractValue) {
      const positionStart = position.position;
      let value = "";
      assert(input[position.position] === '"');
      position.position++;
      while (true) {
        value += collectASequenceOfCodePoints(
          (char) => char !== '"' && char !== "\\",
          input,
          position
        );
        if (position.position >= input.length) {
          break;
        }
        const quoteOrBackslash = input[position.position];
        position.position++;
        if (quoteOrBackslash === "\\") {
          if (position.position >= input.length) {
            value += "\\";
            break;
          }
          value += input[position.position];
          position.position++;
        } else {
          assert(quoteOrBackslash === '"');
          break;
        }
      }
      if (extractValue) {
        return value;
      }
      return input.slice(positionStart, position.position);
    }
    function serializeAMimeType(mimeType) {
      assert(mimeType !== "failure");
      const { parameters, essence } = mimeType;
      let serialization = essence;
      for (let [name, value] of parameters.entries()) {
        serialization += ";";
        serialization += name;
        serialization += "=";
        if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
          value = value.replace(/(\\|")/g, "\\$1");
          value = '"' + value;
          value += '"';
        }
        serialization += value;
      }
      return serialization;
    }
    function isHTTPWhiteSpace(char) {
      return char === "\r" || char === "\n" || char === "	" || char === " ";
    }
    function removeHTTPWhitespace(str, leading = true, trailing = true) {
      let lead = 0;
      let trail = str.length - 1;
      if (leading) {
        for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++) ;
      }
      if (trailing) {
        for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--) ;
      }
      return str.slice(lead, trail + 1);
    }
    function isASCIIWhitespace(char) {
      return char === "\r" || char === "\n" || char === "	" || char === "\f" || char === " ";
    }
    function removeASCIIWhitespace(str, leading = true, trailing = true) {
      let lead = 0;
      let trail = str.length - 1;
      if (leading) {
        for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++) ;
      }
      if (trailing) {
        for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--) ;
      }
      return str.slice(lead, trail + 1);
    }
    module.exports = {
      dataURLProcessor,
      URLSerializer,
      collectASequenceOfCodePoints,
      collectASequenceOfCodePointsFast,
      stringPercentDecode,
      parseMIMEType,
      collectAnHTTPQuotedString,
      serializeAMimeType
    };
  }
});

// node_modules/undici/lib/fetch/file.js
var require_file = __commonJS({
  "node_modules/undici/lib/fetch/file.js"(exports, module) {
    "use strict";
    var { Blob: Blob2, File: NativeFile } = __require("buffer");
    var { types } = __require("util");
    var { kState } = require_symbols2();
    var { isBlobLike } = require_util2();
    var { webidl } = require_webidl();
    var { parseMIMEType, serializeAMimeType } = require_dataURL();
    var { kEnumerableProperty } = require_util();
    var encoder = new TextEncoder();
    var File = class _File extends Blob2 {
      constructor(fileBits, fileName, options = {}) {
        webidl.argumentLengthCheck(arguments, 2, { header: "File constructor" });
        fileBits = webidl.converters["sequence<BlobPart>"](fileBits);
        fileName = webidl.converters.USVString(fileName);
        options = webidl.converters.FilePropertyBag(options);
        const n = fileName;
        let t = options.type;
        let d;
        substep: {
          if (t) {
            t = parseMIMEType(t);
            if (t === "failure") {
              t = "";
              break substep;
            }
            t = serializeAMimeType(t).toLowerCase();
          }
          d = options.lastModified;
        }
        super(processBlobParts(fileBits, options), { type: t });
        this[kState] = {
          name: n,
          lastModified: d,
          type: t
        };
      }
      get name() {
        webidl.brandCheck(this, _File);
        return this[kState].name;
      }
      get lastModified() {
        webidl.brandCheck(this, _File);
        return this[kState].lastModified;
      }
      get type() {
        webidl.brandCheck(this, _File);
        return this[kState].type;
      }
    };
    var FileLike = class _FileLike {
      constructor(blobLike, fileName, options = {}) {
        const n = fileName;
        const t = options.type;
        const d = options.lastModified ?? Date.now();
        this[kState] = {
          blobLike,
          name: n,
          type: t,
          lastModified: d
        };
      }
      stream(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.stream(...args);
      }
      arrayBuffer(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.arrayBuffer(...args);
      }
      slice(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.slice(...args);
      }
      text(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.text(...args);
      }
      get size() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.size;
      }
      get type() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.type;
      }
      get name() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].name;
      }
      get lastModified() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    };
    Object.defineProperties(File.prototype, {
      [Symbol.toStringTag]: {
        value: "File",
        configurable: true
      },
      name: kEnumerableProperty,
      lastModified: kEnumerableProperty
    });
    webidl.converters.Blob = webidl.interfaceConverter(Blob2);
    webidl.converters.BlobPart = function(V, opts) {
      if (webidl.util.Type(V) === "Object") {
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }
        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
          return webidl.converters.BufferSource(V, opts);
        }
      }
      return webidl.converters.USVString(V, opts);
    };
    webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(
      webidl.converters.BlobPart
    );
    webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
      {
        key: "lastModified",
        converter: webidl.converters["long long"],
        get defaultValue() {
          return Date.now();
        }
      },
      {
        key: "type",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "endings",
        converter: (value) => {
          value = webidl.converters.DOMString(value);
          value = value.toLowerCase();
          if (value !== "native") {
            value = "transparent";
          }
          return value;
        },
        defaultValue: "transparent"
      }
    ]);
    function processBlobParts(parts, options) {
      const bytes = [];
      for (const element of parts) {
        if (typeof element === "string") {
          let s = element;
          if (options.endings === "native") {
            s = convertLineEndingsNative(s);
          }
          bytes.push(encoder.encode(s));
        } else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element)) {
          if (!element.buffer) {
            bytes.push(new Uint8Array(element));
          } else {
            bytes.push(
              new Uint8Array(element.buffer, element.byteOffset, element.byteLength)
            );
          }
        } else if (isBlobLike(element)) {
          bytes.push(element);
        }
      }
      return bytes;
    }
    function convertLineEndingsNative(s) {
      let nativeLineEnding = "\n";
      if (process.platform === "win32") {
        nativeLineEnding = "\r\n";
      }
      return s.replace(/\r?\n/g, nativeLineEnding);
    }
    function isFileLike(object) {
      return NativeFile && object instanceof NativeFile || object instanceof File || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
    }
    module.exports = { File, FileLike, isFileLike };
  }
});

// node_modules/undici/lib/fetch/formdata.js
var require_formdata = __commonJS({
  "node_modules/undici/lib/fetch/formdata.js"(exports, module) {
    "use strict";
    var { isBlobLike, toUSVString, makeIterator } = require_util2();
    var { kState } = require_symbols2();
    var { File: UndiciFile, FileLike, isFileLike } = require_file();
    var { webidl } = require_webidl();
    var { Blob: Blob2, File: NativeFile } = __require("buffer");
    var File = NativeFile ?? UndiciFile;
    var FormData = class _FormData {
      constructor(form) {
        if (form !== void 0) {
          throw webidl.errors.conversionFailed({
            prefix: "FormData constructor",
            argument: "Argument 1",
            types: ["undefined"]
          });
        }
        this[kState] = [];
      }
      append(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 2, { header: "FormData.append" });
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }
        name = webidl.converters.USVString(name);
        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? webidl.converters.USVString(filename) : void 0;
        const entry = makeEntry(name, value, filename);
        this[kState].push(entry);
      }
      delete(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.delete" });
        name = webidl.converters.USVString(name);
        this[kState] = this[kState].filter((entry) => entry.name !== name);
      }
      get(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.get" });
        name = webidl.converters.USVString(name);
        const idx = this[kState].findIndex((entry) => entry.name === name);
        if (idx === -1) {
          return null;
        }
        return this[kState][idx].value;
      }
      getAll(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" });
        name = webidl.converters.USVString(name);
        return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
      }
      has(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.has" });
        name = webidl.converters.USVString(name);
        return this[kState].findIndex((entry) => entry.name === name) !== -1;
      }
      set(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 2, { header: "FormData.set" });
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }
        name = webidl.converters.USVString(name);
        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? toUSVString(filename) : void 0;
        const entry = makeEntry(name, value, filename);
        const idx = this[kState].findIndex((entry2) => entry2.name === name);
        if (idx !== -1) {
          this[kState] = [
            ...this[kState].slice(0, idx),
            entry,
            ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
          ];
        } else {
          this[kState].push(entry);
        }
      }
      entries() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "key+value"
        );
      }
      keys() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "key"
        );
      }
      values() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "value"
        );
      }
      /**
       * @param {(value: string, key: string, self: FormData) => void} callbackFn
       * @param {unknown} thisArg
       */
      forEach(callbackFn, thisArg = globalThis) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" });
        if (typeof callbackFn !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'."
          );
        }
        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
    };
    FormData.prototype[Symbol.iterator] = FormData.prototype.entries;
    Object.defineProperties(FormData.prototype, {
      [Symbol.toStringTag]: {
        value: "FormData",
        configurable: true
      }
    });
    function makeEntry(name, value, filename) {
      name = Buffer.from(name).toString("utf8");
      if (typeof value === "string") {
        value = Buffer.from(value).toString("utf8");
      } else {
        if (!isFileLike(value)) {
          value = value instanceof Blob2 ? new File([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
        }
        if (filename !== void 0) {
          const options = {
            type: value.type,
            lastModified: value.lastModified
          };
          value = NativeFile && value instanceof NativeFile || value instanceof UndiciFile ? new File([value], filename, options) : new FileLike(value, filename, options);
        }
      }
      return { name, value };
    }
    module.exports = { FormData };
  }
});

// node_modules/undici/lib/fetch/body.js
var require_body = __commonJS({
  "node_modules/undici/lib/fetch/body.js"(exports, module) {
    "use strict";
    var Busboy = require_main();
    var util = require_util();
    var {
      ReadableStreamFrom,
      isBlobLike,
      isReadableStreamLike,
      readableStreamClose,
      createDeferredPromise,
      fullyReadBody
    } = require_util2();
    var { FormData } = require_formdata();
    var { kState } = require_symbols2();
    var { webidl } = require_webidl();
    var { DOMException: DOMException2, structuredClone } = require_constants2();
    var { Blob: Blob2, File: NativeFile } = __require("buffer");
    var { kBodyUsed } = require_symbols();
    var assert = __require("assert");
    var { isErrored } = require_util();
    var { isUint8Array, isArrayBuffer } = __require("util/types");
    var { File: UndiciFile } = require_file();
    var { parseMIMEType, serializeAMimeType } = require_dataURL();
    var random;
    try {
      const crypto2 = __require("crypto");
      random = (max) => crypto2.randomInt(0, max);
    } catch {
      random = (max) => Math.floor(Math.random(max));
    }
    var ReadableStream = globalThis.ReadableStream;
    var File = NativeFile ?? UndiciFile;
    var textEncoder = new TextEncoder();
    var textDecoder = new TextDecoder();
    function extractBody(object, keepalive = false) {
      if (!ReadableStream) {
        ReadableStream = __require("stream/web").ReadableStream;
      }
      let stream = null;
      if (object instanceof ReadableStream) {
        stream = object;
      } else if (isBlobLike(object)) {
        stream = object.stream();
      } else {
        stream = new ReadableStream({
          async pull(controller) {
            controller.enqueue(
              typeof source === "string" ? textEncoder.encode(source) : source
            );
            queueMicrotask(() => readableStreamClose(controller));
          },
          start() {
          },
          type: void 0
        });
      }
      assert(isReadableStreamLike(stream));
      let action = null;
      let source = null;
      let length = null;
      let type = null;
      if (typeof object === "string") {
        source = object;
        type = "text/plain;charset=UTF-8";
      } else if (object instanceof URLSearchParams) {
        source = object.toString();
        type = "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isArrayBuffer(object)) {
        source = new Uint8Array(object.slice());
      } else if (ArrayBuffer.isView(object)) {
        source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
      } else if (util.isFormDataLike(object)) {
        const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, "0")}`;
        const prefix = `--${boundary}\r
Content-Disposition: form-data`;
        const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
        const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
        const blobParts = [];
        const rn = new Uint8Array([13, 10]);
        length = 0;
        let hasUnknownSizeValue = false;
        for (const [name, value] of object) {
          if (typeof value === "string") {
            const chunk2 = textEncoder.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
            blobParts.push(chunk2);
            length += chunk2.byteLength;
          } else {
            const chunk2 = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
            blobParts.push(chunk2, value, rn);
            if (typeof value.size === "number") {
              length += chunk2.byteLength + value.size + rn.byteLength;
            } else {
              hasUnknownSizeValue = true;
            }
          }
        }
        const chunk = textEncoder.encode(`--${boundary}--`);
        blobParts.push(chunk);
        length += chunk.byteLength;
        if (hasUnknownSizeValue) {
          length = null;
        }
        source = object;
        action = async function* () {
          for (const part of blobParts) {
            if (part.stream) {
              yield* part.stream();
            } else {
              yield part;
            }
          }
        };
        type = "multipart/form-data; boundary=" + boundary;
      } else if (isBlobLike(object)) {
        source = object;
        length = object.size;
        if (object.type) {
          type = object.type;
        }
      } else if (typeof object[Symbol.asyncIterator] === "function") {
        if (keepalive) {
          throw new TypeError("keepalive");
        }
        if (util.isDisturbed(object) || object.locked) {
          throw new TypeError(
            "Response body object should not be disturbed or locked"
          );
        }
        stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
      }
      if (typeof source === "string" || util.isBuffer(source)) {
        length = Buffer.byteLength(source);
      }
      if (action != null) {
        let iterator;
        stream = new ReadableStream({
          async start() {
            iterator = action(object)[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { value, done } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              if (!isErrored(stream)) {
                controller.enqueue(new Uint8Array(value));
              }
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          },
          type: void 0
        });
      }
      const body = { stream, source, length };
      return [body, type];
    }
    function safelyExtractBody(object, keepalive = false) {
      if (!ReadableStream) {
        ReadableStream = __require("stream/web").ReadableStream;
      }
      if (object instanceof ReadableStream) {
        assert(!util.isDisturbed(object), "The body has already been consumed.");
        assert(!object.locked, "The stream is locked.");
      }
      return extractBody(object, keepalive);
    }
    function cloneBody(body) {
      const [out1, out2] = body.stream.tee();
      const out2Clone = structuredClone(out2, { transfer: [out2] });
      const [, finalClone] = out2Clone.tee();
      body.stream = out1;
      return {
        stream: finalClone,
        length: body.length,
        source: body.source
      };
    }
    async function* consumeBody(body) {
      if (body) {
        if (isUint8Array(body)) {
          yield body;
        } else {
          const stream = body.stream;
          if (util.isDisturbed(stream)) {
            throw new TypeError("The body has already been consumed.");
          }
          if (stream.locked) {
            throw new TypeError("The stream is locked.");
          }
          stream[kBodyUsed] = true;
          yield* stream;
        }
      }
    }
    function throwIfAborted(state) {
      if (state.aborted) {
        throw new DOMException2("The operation was aborted.", "AbortError");
      }
    }
    function bodyMixinMethods(instance) {
      const methods = {
        blob() {
          return specConsumeBody(this, (bytes) => {
            let mimeType = bodyMimeType(this);
            if (mimeType === "failure") {
              mimeType = "";
            } else if (mimeType) {
              mimeType = serializeAMimeType(mimeType);
            }
            return new Blob2([bytes], { type: mimeType });
          }, instance);
        },
        arrayBuffer() {
          return specConsumeBody(this, (bytes) => {
            return new Uint8Array(bytes).buffer;
          }, instance);
        },
        text() {
          return specConsumeBody(this, utf8DecodeBytes, instance);
        },
        json() {
          return specConsumeBody(this, parseJSONFromBytes, instance);
        },
        async formData() {
          webidl.brandCheck(this, instance);
          throwIfAborted(this[kState]);
          const contentType = this.headers.get("Content-Type");
          if (/multipart\/form-data/.test(contentType)) {
            const headers = {};
            for (const [key, value] of this.headers) headers[key.toLowerCase()] = value;
            const responseFormData = new FormData();
            let busboy;
            try {
              busboy = new Busboy({
                headers,
                preservePath: true
              });
            } catch (err) {
              throw new DOMException2(`${err}`, "AbortError");
            }
            busboy.on("field", (name, value) => {
              responseFormData.append(name, value);
            });
            busboy.on("file", (name, value, filename, encoding, mimeType) => {
              const chunks = [];
              if (encoding === "base64" || encoding.toLowerCase() === "base64") {
                let base64chunk = "";
                value.on("data", (chunk) => {
                  base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
                  const end = base64chunk.length - base64chunk.length % 4;
                  chunks.push(Buffer.from(base64chunk.slice(0, end), "base64"));
                  base64chunk = base64chunk.slice(end);
                });
                value.on("end", () => {
                  chunks.push(Buffer.from(base64chunk, "base64"));
                  responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
                });
              } else {
                value.on("data", (chunk) => {
                  chunks.push(chunk);
                });
                value.on("end", () => {
                  responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
                });
              }
            });
            const busboyResolve = new Promise((resolve5, reject) => {
              busboy.on("finish", resolve5);
              busboy.on("error", (err) => reject(new TypeError(err)));
            });
            if (this.body !== null) for await (const chunk of consumeBody(this[kState].body)) busboy.write(chunk);
            busboy.end();
            await busboyResolve;
            return responseFormData;
          } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
            let entries;
            try {
              let text = "";
              const streamingDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
              for await (const chunk of consumeBody(this[kState].body)) {
                if (!isUint8Array(chunk)) {
                  throw new TypeError("Expected Uint8Array chunk");
                }
                text += streamingDecoder.decode(chunk, { stream: true });
              }
              text += streamingDecoder.decode();
              entries = new URLSearchParams(text);
            } catch (err) {
              throw Object.assign(new TypeError(), { cause: err });
            }
            const formData = new FormData();
            for (const [name, value] of entries) {
              formData.append(name, value);
            }
            return formData;
          } else {
            await Promise.resolve();
            throwIfAborted(this[kState]);
            throw webidl.errors.exception({
              header: `${instance.name}.formData`,
              message: "Could not parse content as FormData."
            });
          }
        }
      };
      return methods;
    }
    function mixinBody(prototype) {
      Object.assign(prototype.prototype, bodyMixinMethods(prototype));
    }
    async function specConsumeBody(object, convertBytesToJSValue, instance) {
      webidl.brandCheck(object, instance);
      throwIfAborted(object[kState]);
      if (bodyUnusable(object[kState].body)) {
        throw new TypeError("Body is unusable");
      }
      const promise = createDeferredPromise();
      const errorSteps = (error) => promise.reject(error);
      const successSteps = (data) => {
        try {
          promise.resolve(convertBytesToJSValue(data));
        } catch (e) {
          errorSteps(e);
        }
      };
      if (object[kState].body == null) {
        successSteps(new Uint8Array());
        return promise.promise;
      }
      await fullyReadBody(object[kState].body, successSteps, errorSteps);
      return promise.promise;
    }
    function bodyUnusable(body) {
      return body != null && (body.stream.locked || util.isDisturbed(body.stream));
    }
    function utf8DecodeBytes(buffer) {
      if (buffer.length === 0) {
        return "";
      }
      if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
        buffer = buffer.subarray(3);
      }
      const output = textDecoder.decode(buffer);
      return output;
    }
    function parseJSONFromBytes(bytes) {
      return JSON.parse(utf8DecodeBytes(bytes));
    }
    function bodyMimeType(object) {
      const { headersList } = object[kState];
      const contentType = headersList.get("content-type");
      if (contentType === null) {
        return "failure";
      }
      return parseMIMEType(contentType);
    }
    module.exports = {
      extractBody,
      safelyExtractBody,
      cloneBody,
      mixinBody
    };
  }
});

// node_modules/undici/lib/core/request.js
var require_request = __commonJS({
  "node_modules/undici/lib/core/request.js"(exports, module) {
    "use strict";
    var {
      InvalidArgumentError,
      NotSupportedError
    } = require_errors();
    var assert = __require("assert");
    var { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require_symbols();
    var util = require_util();
    var tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
    var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    var invalidPathRegex = /[^\u0021-\u00ff]/;
    var kHandler = /* @__PURE__ */ Symbol("handler");
    var channels = {};
    var extractBody;
    try {
      const diagnosticsChannel = __require("diagnostics_channel");
      channels.create = diagnosticsChannel.channel("undici:request:create");
      channels.bodySent = diagnosticsChannel.channel("undici:request:bodySent");
      channels.headers = diagnosticsChannel.channel("undici:request:headers");
      channels.trailers = diagnosticsChannel.channel("undici:request:trailers");
      channels.error = diagnosticsChannel.channel("undici:request:error");
    } catch {
      channels.create = { hasSubscribers: false };
      channels.bodySent = { hasSubscribers: false };
      channels.headers = { hasSubscribers: false };
      channels.trailers = { hasSubscribers: false };
      channels.error = { hasSubscribers: false };
    }
    var Request = class _Request {
      constructor(origin, {
        path: path12,
        method,
        body,
        headers,
        query,
        idempotent,
        blocking,
        upgrade,
        headersTimeout,
        bodyTimeout,
        reset,
        throwOnError,
        expectContinue
      }, handler) {
        if (typeof path12 !== "string") {
          throw new InvalidArgumentError("path must be a string");
        } else if (path12[0] !== "/" && !(path12.startsWith("http://") || path12.startsWith("https://")) && method !== "CONNECT") {
          throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
        } else if (invalidPathRegex.exec(path12) !== null) {
          throw new InvalidArgumentError("invalid request path");
        }
        if (typeof method !== "string") {
          throw new InvalidArgumentError("method must be a string");
        } else if (tokenRegExp.exec(method) === null) {
          throw new InvalidArgumentError("invalid request method");
        }
        if (upgrade && typeof upgrade !== "string") {
          throw new InvalidArgumentError("upgrade must be a string");
        }
        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("invalid headersTimeout");
        }
        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("invalid bodyTimeout");
        }
        if (reset != null && typeof reset !== "boolean") {
          throw new InvalidArgumentError("invalid reset");
        }
        if (expectContinue != null && typeof expectContinue !== "boolean") {
          throw new InvalidArgumentError("invalid expectContinue");
        }
        this.headersTimeout = headersTimeout;
        this.bodyTimeout = bodyTimeout;
        this.throwOnError = throwOnError === true;
        this.method = method;
        this.abort = null;
        if (body == null) {
          this.body = null;
        } else if (util.isStream(body)) {
          this.body = body;
          const rState = this.body._readableState;
          if (!rState || !rState.autoDestroy) {
            this.endHandler = function autoDestroy() {
              util.destroy(this);
            };
            this.body.on("end", this.endHandler);
          }
          this.errorHandler = (err) => {
            if (this.abort) {
              this.abort(err);
            } else {
              this.error = err;
            }
          };
          this.body.on("error", this.errorHandler);
        } else if (util.isBuffer(body)) {
          this.body = body.byteLength ? body : null;
        } else if (ArrayBuffer.isView(body)) {
          this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
        } else if (body instanceof ArrayBuffer) {
          this.body = body.byteLength ? Buffer.from(body) : null;
        } else if (typeof body === "string") {
          this.body = body.length ? Buffer.from(body) : null;
        } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {
          this.body = body;
        } else {
          throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
        }
        this.completed = false;
        this.aborted = false;
        this.upgrade = upgrade || null;
        this.path = query ? util.buildURL(path12, query) : path12;
        this.origin = origin;
        this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
        this.blocking = blocking == null ? false : blocking;
        this.reset = reset == null ? null : reset;
        this.host = null;
        this.contentLength = null;
        this.contentType = null;
        this.headers = "";
        this.expectContinue = expectContinue != null ? expectContinue : false;
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(this, headers[i], headers[i + 1]);
          }
        } else if (headers && typeof headers === "object") {
          const keys = Object.keys(headers);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            processHeader(this, key, headers[key]);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        if (util.isFormDataLike(this.body)) {
          if (util.nodeMajor < 16 || util.nodeMajor === 16 && util.nodeMinor < 8) {
            throw new InvalidArgumentError("Form-Data bodies are only supported in node v16.8 and newer.");
          }
          if (!extractBody) {
            extractBody = require_body().extractBody;
          }
          const [bodyStream, contentType] = extractBody(body);
          if (this.contentType == null) {
            this.contentType = contentType;
            this.headers += `content-type: ${contentType}\r
`;
          }
          this.body = bodyStream.stream;
          this.contentLength = bodyStream.length;
        } else if (util.isBlobLike(body) && this.contentType == null && body.type) {
          this.contentType = body.type;
          this.headers += `content-type: ${body.type}\r
`;
        }
        util.validateHandler(handler, method, upgrade);
        this.servername = util.getServerName(this.host);
        this[kHandler] = handler;
        if (channels.create.hasSubscribers) {
          channels.create.publish({ request: this });
        }
      }
      onBodySent(chunk) {
        if (this[kHandler].onBodySent) {
          try {
            return this[kHandler].onBodySent(chunk);
          } catch (err) {
            this.abort(err);
          }
        }
      }
      onRequestSent() {
        if (channels.bodySent.hasSubscribers) {
          channels.bodySent.publish({ request: this });
        }
        if (this[kHandler].onRequestSent) {
          try {
            return this[kHandler].onRequestSent();
          } catch (err) {
            this.abort(err);
          }
        }
      }
      onConnect(abort) {
        assert(!this.aborted);
        assert(!this.completed);
        if (this.error) {
          abort(this.error);
        } else {
          this.abort = abort;
          return this[kHandler].onConnect(abort);
        }
      }
      onHeaders(statusCode, headers, resume, statusText) {
        assert(!this.aborted);
        assert(!this.completed);
        if (channels.headers.hasSubscribers) {
          channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
        }
        try {
          return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
        } catch (err) {
          this.abort(err);
        }
      }
      onData(chunk) {
        assert(!this.aborted);
        assert(!this.completed);
        try {
          return this[kHandler].onData(chunk);
        } catch (err) {
          this.abort(err);
          return false;
        }
      }
      onUpgrade(statusCode, headers, socket) {
        assert(!this.aborted);
        assert(!this.completed);
        return this[kHandler].onUpgrade(statusCode, headers, socket);
      }
      onComplete(trailers) {
        this.onFinally();
        assert(!this.aborted);
        this.completed = true;
        if (channels.trailers.hasSubscribers) {
          channels.trailers.publish({ request: this, trailers });
        }
        try {
          return this[kHandler].onComplete(trailers);
        } catch (err) {
          this.onError(err);
        }
      }
      onError(error) {
        this.onFinally();
        if (channels.error.hasSubscribers) {
          channels.error.publish({ request: this, error });
        }
        if (this.aborted) {
          return;
        }
        this.aborted = true;
        return this[kHandler].onError(error);
      }
      onFinally() {
        if (this.errorHandler) {
          this.body.off("error", this.errorHandler);
          this.errorHandler = null;
        }
        if (this.endHandler) {
          this.body.off("end", this.endHandler);
          this.endHandler = null;
        }
      }
      // TODO: adjust to support H2
      addHeader(key, value) {
        processHeader(this, key, value);
        return this;
      }
      static [kHTTP1BuildRequest](origin, opts, handler) {
        return new _Request(origin, opts, handler);
      }
      static [kHTTP2BuildRequest](origin, opts, handler) {
        const headers = opts.headers;
        opts = { ...opts, headers: null };
        const request = new _Request(origin, opts, handler);
        request.headers = {};
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(request, headers[i], headers[i + 1], true);
          }
        } else if (headers && typeof headers === "object") {
          const keys = Object.keys(headers);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            processHeader(request, key, headers[key], true);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        return request;
      }
      static [kHTTP2CopyHeaders](raw) {
        const rawHeaders = raw.split("\r\n");
        const headers = {};
        for (const header of rawHeaders) {
          const [key, value] = header.split(": ");
          if (value == null || value.length === 0) continue;
          if (headers[key]) headers[key] += `,${value}`;
          else headers[key] = value;
        }
        return headers;
      }
    };
    function processHeaderValue(key, val, skipAppend) {
      if (val && typeof val === "object") {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      val = val != null ? `${val}` : "";
      if (headerCharRegex.exec(val) !== null) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      return skipAppend ? val : `${key}: ${val}\r
`;
    }
    function processHeader(request, key, val, skipAppend = false) {
      if (val && (typeof val === "object" && !Array.isArray(val))) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      } else if (val === void 0) {
        return;
      }
      if (request.host === null && key.length === 4 && key.toLowerCase() === "host") {
        if (headerCharRegex.exec(val) !== null) {
          throw new InvalidArgumentError(`invalid ${key} header`);
        }
        request.host = val;
      } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
        request.contentLength = parseInt(val, 10);
        if (!Number.isFinite(request.contentLength)) {
          throw new InvalidArgumentError("invalid content-length header");
        }
      } else if (request.contentType === null && key.length === 12 && key.toLowerCase() === "content-type") {
        request.contentType = val;
        if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);
        else request.headers += processHeaderValue(key, val);
      } else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
        throw new InvalidArgumentError("invalid transfer-encoding header");
      } else if (key.length === 10 && key.toLowerCase() === "connection") {
        const value = typeof val === "string" ? val.toLowerCase() : null;
        if (value !== "close" && value !== "keep-alive") {
          throw new InvalidArgumentError("invalid connection header");
        } else if (value === "close") {
          request.reset = true;
        }
      } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
        throw new InvalidArgumentError("invalid keep-alive header");
      } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
        throw new InvalidArgumentError("invalid upgrade header");
      } else if (key.length === 6 && key.toLowerCase() === "expect") {
        throw new NotSupportedError("expect header not supported");
      } else if (tokenRegExp.exec(key) === null) {
        throw new InvalidArgumentError("invalid header key");
      } else {
        if (Array.isArray(val)) {
          for (let i = 0; i < val.length; i++) {
            if (skipAppend) {
              if (request.headers[key]) request.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`;
              else request.headers[key] = processHeaderValue(key, val[i], skipAppend);
            } else {
              request.headers += processHeaderValue(key, val[i]);
            }
          }
        } else {
          if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);
          else request.headers += processHeaderValue(key, val);
        }
      }
    }
    module.exports = Request;
  }
});

// node_modules/undici/lib/dispatcher.js
var require_dispatcher = __commonJS({
  "node_modules/undici/lib/dispatcher.js"(exports, module) {
    "use strict";
    var EventEmitter2 = __require("events");
    var Dispatcher = class extends EventEmitter2 {
      dispatch() {
        throw new Error("not implemented");
      }
      close() {
        throw new Error("not implemented");
      }
      destroy() {
        throw new Error("not implemented");
      }
    };
    module.exports = Dispatcher;
  }
});

// node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base = __commonJS({
  "node_modules/undici/lib/dispatcher-base.js"(exports, module) {
    "use strict";
    var Dispatcher = require_dispatcher();
    var {
      ClientDestroyedError,
      ClientClosedError,
      InvalidArgumentError
    } = require_errors();
    var { kDestroy, kClose, kDispatch, kInterceptors } = require_symbols();
    var kDestroyed = /* @__PURE__ */ Symbol("destroyed");
    var kClosed = /* @__PURE__ */ Symbol("closed");
    var kOnDestroyed = /* @__PURE__ */ Symbol("onDestroyed");
    var kOnClosed = /* @__PURE__ */ Symbol("onClosed");
    var kInterceptedDispatch = /* @__PURE__ */ Symbol("Intercepted Dispatch");
    var DispatcherBase = class extends Dispatcher {
      constructor() {
        super();
        this[kDestroyed] = false;
        this[kOnDestroyed] = null;
        this[kClosed] = false;
        this[kOnClosed] = [];
      }
      get destroyed() {
        return this[kDestroyed];
      }
      get closed() {
        return this[kClosed];
      }
      get interceptors() {
        return this[kInterceptors];
      }
      set interceptors(newInterceptors) {
        if (newInterceptors) {
          for (let i = newInterceptors.length - 1; i >= 0; i--) {
            const interceptor = this[kInterceptors][i];
            if (typeof interceptor !== "function") {
              throw new InvalidArgumentError("interceptor must be an function");
            }
          }
        }
        this[kInterceptors] = newInterceptors;
      }
      close(callback) {
        if (callback === void 0) {
          return new Promise((resolve5, reject) => {
            this.close((err, data) => {
              return err ? reject(err) : resolve5(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          queueMicrotask(() => callback(new ClientDestroyedError(), null));
          return;
        }
        if (this[kClosed]) {
          if (this[kOnClosed]) {
            this[kOnClosed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        this[kClosed] = true;
        this[kOnClosed].push(callback);
        const onClosed = () => {
          const callbacks = this[kOnClosed];
          this[kOnClosed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kClose]().then(() => this.destroy()).then(() => {
          queueMicrotask(onClosed);
        });
      }
      destroy(err, callback) {
        if (typeof err === "function") {
          callback = err;
          err = null;
        }
        if (callback === void 0) {
          return new Promise((resolve5, reject) => {
            this.destroy(err, (err2, data) => {
              return err2 ? (
                /* istanbul ignore next: should never error */
                reject(err2)
              ) : resolve5(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          if (this[kOnDestroyed]) {
            this[kOnDestroyed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        if (!err) {
          err = new ClientDestroyedError();
        }
        this[kDestroyed] = true;
        this[kOnDestroyed] = this[kOnDestroyed] || [];
        this[kOnDestroyed].push(callback);
        const onDestroyed = () => {
          const callbacks = this[kOnDestroyed];
          this[kOnDestroyed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kDestroy](err).then(() => {
          queueMicrotask(onDestroyed);
        });
      }
      [kInterceptedDispatch](opts, handler) {
        if (!this[kInterceptors] || this[kInterceptors].length === 0) {
          this[kInterceptedDispatch] = this[kDispatch];
          return this[kDispatch](opts, handler);
        }
        let dispatch = this[kDispatch].bind(this);
        for (let i = this[kInterceptors].length - 1; i >= 0; i--) {
          dispatch = this[kInterceptors][i](dispatch);
        }
        this[kInterceptedDispatch] = dispatch;
        return dispatch(opts, handler);
      }
      dispatch(opts, handler) {
        if (!handler || typeof handler !== "object") {
          throw new InvalidArgumentError("handler must be an object");
        }
        try {
          if (!opts || typeof opts !== "object") {
            throw new InvalidArgumentError("opts must be an object.");
          }
          if (this[kDestroyed] || this[kOnDestroyed]) {
            throw new ClientDestroyedError();
          }
          if (this[kClosed]) {
            throw new ClientClosedError();
          }
          return this[kInterceptedDispatch](opts, handler);
        } catch (err) {
          if (typeof handler.onError !== "function") {
            throw new InvalidArgumentError("invalid onError method");
          }
          handler.onError(err);
          return false;
        }
      }
    };
    module.exports = DispatcherBase;
  }
});

// node_modules/undici/lib/core/connect.js
var require_connect = __commonJS({
  "node_modules/undici/lib/core/connect.js"(exports, module) {
    "use strict";
    var net = __require("net");
    var assert = __require("assert");
    var util = require_util();
    var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
    var tls;
    var SessionCache;
    if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {
      SessionCache = class WeakSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
          this._sessionRegistry = new global.FinalizationRegistry((key) => {
            if (this._sessionCache.size < this._maxCachedSessions) {
              return;
            }
            const ref = this._sessionCache.get(key);
            if (ref !== void 0 && ref.deref() === void 0) {
              this._sessionCache.delete(key);
            }
          });
        }
        get(sessionKey) {
          const ref = this._sessionCache.get(sessionKey);
          return ref ? ref.deref() : null;
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          this._sessionCache.set(sessionKey, new WeakRef(session));
          this._sessionRegistry.register(session, sessionKey);
        }
      };
    } else {
      SessionCache = class SimpleSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
        }
        get(sessionKey) {
          return this._sessionCache.get(sessionKey);
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          if (this._sessionCache.size >= this._maxCachedSessions) {
            const { value: oldestKey } = this._sessionCache.keys().next();
            this._sessionCache.delete(oldestKey);
          }
          this._sessionCache.set(sessionKey, session);
        }
      };
    }
    function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {
      if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
        throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
      }
      const options = { path: socketPath, ...opts };
      const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
      timeout = timeout == null ? 1e4 : timeout;
      allowH2 = allowH2 != null ? allowH2 : false;
      return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
        let socket;
        if (protocol === "https:") {
          if (!tls) {
            tls = __require("tls");
          }
          servername = servername || options.servername || util.getServerName(host) || null;
          const sessionKey = servername || hostname;
          const session = sessionCache.get(sessionKey) || null;
          assert(sessionKey);
          socket = tls.connect({
            highWaterMark: 16384,
            // TLS in node can't have bigger HWM anyway...
            ...options,
            servername,
            session,
            localAddress,
            // TODO(HTTP/2): Add support for h2c
            ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
            socket: httpSocket,
            // upgrade socket connection
            port: port || 443,
            host: hostname
          });
          socket.on("session", function(session2) {
            sessionCache.set(sessionKey, session2);
          });
        } else {
          assert(!httpSocket, "httpSocket can only be sent on TLS update");
          socket = net.connect({
            highWaterMark: 64 * 1024,
            // Same as nodejs fs streams.
            ...options,
            localAddress,
            port: port || 80,
            host: hostname
          });
        }
        if (options.keepAlive == null || options.keepAlive) {
          const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
          socket.setKeepAlive(true, keepAliveInitialDelay);
        }
        const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
        socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
          cancelTimeout();
          if (callback) {
            const cb = callback;
            callback = null;
            cb(null, this);
          }
        }).on("error", function(err) {
          cancelTimeout();
          if (callback) {
            const cb = callback;
            callback = null;
            cb(err);
          }
        });
        return socket;
      };
    }
    function setupTimeout(onConnectTimeout2, timeout) {
      if (!timeout) {
        return () => {
        };
      }
      let s1 = null;
      let s2 = null;
      const timeoutId = setTimeout(() => {
        s1 = setImmediate(() => {
          if (process.platform === "win32") {
            s2 = setImmediate(() => onConnectTimeout2());
          } else {
            onConnectTimeout2();
          }
        });
      }, timeout);
      return () => {
        clearTimeout(timeoutId);
        clearImmediate(s1);
        clearImmediate(s2);
      };
    }
    function onConnectTimeout(socket) {
      util.destroy(socket, new ConnectTimeoutError());
    }
    module.exports = buildConnector;
  }
});

// node_modules/undici/lib/llhttp/utils.js
var require_utils = __commonJS({
  "node_modules/undici/lib/llhttp/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.enumToMap = void 0;
    function enumToMap(obj) {
      const res = {};
      Object.keys(obj).forEach((key) => {
        const value = obj[key];
        if (typeof value === "number") {
          res[key] = value;
        }
      });
      return res;
    }
    exports.enumToMap = enumToMap;
  }
});

// node_modules/undici/lib/llhttp/constants.js
var require_constants3 = __commonJS({
  "node_modules/undici/lib/llhttp/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;
    var utils_1 = require_utils();
    var ERROR;
    (function(ERROR2) {
      ERROR2[ERROR2["OK"] = 0] = "OK";
      ERROR2[ERROR2["INTERNAL"] = 1] = "INTERNAL";
      ERROR2[ERROR2["STRICT"] = 2] = "STRICT";
      ERROR2[ERROR2["LF_EXPECTED"] = 3] = "LF_EXPECTED";
      ERROR2[ERROR2["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
      ERROR2[ERROR2["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
      ERROR2[ERROR2["INVALID_METHOD"] = 6] = "INVALID_METHOD";
      ERROR2[ERROR2["INVALID_URL"] = 7] = "INVALID_URL";
      ERROR2[ERROR2["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
      ERROR2[ERROR2["INVALID_VERSION"] = 9] = "INVALID_VERSION";
      ERROR2[ERROR2["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
      ERROR2[ERROR2["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
      ERROR2[ERROR2["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
      ERROR2[ERROR2["INVALID_STATUS"] = 13] = "INVALID_STATUS";
      ERROR2[ERROR2["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
      ERROR2[ERROR2["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
      ERROR2[ERROR2["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
      ERROR2[ERROR2["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
      ERROR2[ERROR2["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
      ERROR2[ERROR2["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
      ERROR2[ERROR2["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
      ERROR2[ERROR2["PAUSED"] = 21] = "PAUSED";
      ERROR2[ERROR2["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
      ERROR2[ERROR2["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
      ERROR2[ERROR2["USER"] = 24] = "USER";
    })(ERROR = exports.ERROR || (exports.ERROR = {}));
    var TYPE;
    (function(TYPE2) {
      TYPE2[TYPE2["BOTH"] = 0] = "BOTH";
      TYPE2[TYPE2["REQUEST"] = 1] = "REQUEST";
      TYPE2[TYPE2["RESPONSE"] = 2] = "RESPONSE";
    })(TYPE = exports.TYPE || (exports.TYPE = {}));
    var FLAGS;
    (function(FLAGS2) {
      FLAGS2[FLAGS2["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
      FLAGS2[FLAGS2["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
      FLAGS2[FLAGS2["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
      FLAGS2[FLAGS2["CHUNKED"] = 8] = "CHUNKED";
      FLAGS2[FLAGS2["UPGRADE"] = 16] = "UPGRADE";
      FLAGS2[FLAGS2["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
      FLAGS2[FLAGS2["SKIPBODY"] = 64] = "SKIPBODY";
      FLAGS2[FLAGS2["TRAILING"] = 128] = "TRAILING";
      FLAGS2[FLAGS2["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
    })(FLAGS = exports.FLAGS || (exports.FLAGS = {}));
    var LENIENT_FLAGS;
    (function(LENIENT_FLAGS2) {
      LENIENT_FLAGS2[LENIENT_FLAGS2["HEADERS"] = 1] = "HEADERS";
      LENIENT_FLAGS2[LENIENT_FLAGS2["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
      LENIENT_FLAGS2[LENIENT_FLAGS2["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
    })(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
    var METHODS;
    (function(METHODS2) {
      METHODS2[METHODS2["DELETE"] = 0] = "DELETE";
      METHODS2[METHODS2["GET"] = 1] = "GET";
      METHODS2[METHODS2["HEAD"] = 2] = "HEAD";
      METHODS2[METHODS2["POST"] = 3] = "POST";
      METHODS2[METHODS2["PUT"] = 4] = "PUT";
      METHODS2[METHODS2["CONNECT"] = 5] = "CONNECT";
      METHODS2[METHODS2["OPTIONS"] = 6] = "OPTIONS";
      METHODS2[METHODS2["TRACE"] = 7] = "TRACE";
      METHODS2[METHODS2["COPY"] = 8] = "COPY";
      METHODS2[METHODS2["LOCK"] = 9] = "LOCK";
      METHODS2[METHODS2["MKCOL"] = 10] = "MKCOL";
      METHODS2[METHODS2["MOVE"] = 11] = "MOVE";
      METHODS2[METHODS2["PROPFIND"] = 12] = "PROPFIND";
      METHODS2[METHODS2["PROPPATCH"] = 13] = "PROPPATCH";
      METHODS2[METHODS2["SEARCH"] = 14] = "SEARCH";
      METHODS2[METHODS2["UNLOCK"] = 15] = "UNLOCK";
      METHODS2[METHODS2["BIND"] = 16] = "BIND";
      METHODS2[METHODS2["REBIND"] = 17] = "REBIND";
      METHODS2[METHODS2["UNBIND"] = 18] = "UNBIND";
      METHODS2[METHODS2["ACL"] = 19] = "ACL";
      METHODS2[METHODS2["REPORT"] = 20] = "REPORT";
      METHODS2[METHODS2["MKACTIVITY"] = 21] = "MKACTIVITY";
      METHODS2[METHODS2["CHECKOUT"] = 22] = "CHECKOUT";
      METHODS2[METHODS2["MERGE"] = 23] = "MERGE";
      METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH";
      METHODS2[METHODS2["NOTIFY"] = 25] = "NOTIFY";
      METHODS2[METHODS2["SUBSCRIBE"] = 26] = "SUBSCRIBE";
      METHODS2[METHODS2["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
      METHODS2[METHODS2["PATCH"] = 28] = "PATCH";
      METHODS2[METHODS2["PURGE"] = 29] = "PURGE";
      METHODS2[METHODS2["MKCALENDAR"] = 30] = "MKCALENDAR";
      METHODS2[METHODS2["LINK"] = 31] = "LINK";
      METHODS2[METHODS2["UNLINK"] = 32] = "UNLINK";
      METHODS2[METHODS2["SOURCE"] = 33] = "SOURCE";
      METHODS2[METHODS2["PRI"] = 34] = "PRI";
      METHODS2[METHODS2["DESCRIBE"] = 35] = "DESCRIBE";
      METHODS2[METHODS2["ANNOUNCE"] = 36] = "ANNOUNCE";
      METHODS2[METHODS2["SETUP"] = 37] = "SETUP";
      METHODS2[METHODS2["PLAY"] = 38] = "PLAY";
      METHODS2[METHODS2["PAUSE"] = 39] = "PAUSE";
      METHODS2[METHODS2["TEARDOWN"] = 40] = "TEARDOWN";
      METHODS2[METHODS2["GET_PARAMETER"] = 41] = "GET_PARAMETER";
      METHODS2[METHODS2["SET_PARAMETER"] = 42] = "SET_PARAMETER";
      METHODS2[METHODS2["REDIRECT"] = 43] = "REDIRECT";
      METHODS2[METHODS2["RECORD"] = 44] = "RECORD";
      METHODS2[METHODS2["FLUSH"] = 45] = "FLUSH";
    })(METHODS = exports.METHODS || (exports.METHODS = {}));
    exports.METHODS_HTTP = [
      METHODS.DELETE,
      METHODS.GET,
      METHODS.HEAD,
      METHODS.POST,
      METHODS.PUT,
      METHODS.CONNECT,
      METHODS.OPTIONS,
      METHODS.TRACE,
      METHODS.COPY,
      METHODS.LOCK,
      METHODS.MKCOL,
      METHODS.MOVE,
      METHODS.PROPFIND,
      METHODS.PROPPATCH,
      METHODS.SEARCH,
      METHODS.UNLOCK,
      METHODS.BIND,
      METHODS.REBIND,
      METHODS.UNBIND,
      METHODS.ACL,
      METHODS.REPORT,
      METHODS.MKACTIVITY,
      METHODS.CHECKOUT,
      METHODS.MERGE,
      METHODS["M-SEARCH"],
      METHODS.NOTIFY,
      METHODS.SUBSCRIBE,
      METHODS.UNSUBSCRIBE,
      METHODS.PATCH,
      METHODS.PURGE,
      METHODS.MKCALENDAR,
      METHODS.LINK,
      METHODS.UNLINK,
      METHODS.PRI,
      // TODO(indutny): should we allow it with HTTP?
      METHODS.SOURCE
    ];
    exports.METHODS_ICE = [
      METHODS.SOURCE
    ];
    exports.METHODS_RTSP = [
      METHODS.OPTIONS,
      METHODS.DESCRIBE,
      METHODS.ANNOUNCE,
      METHODS.SETUP,
      METHODS.PLAY,
      METHODS.PAUSE,
      METHODS.TEARDOWN,
      METHODS.GET_PARAMETER,
      METHODS.SET_PARAMETER,
      METHODS.REDIRECT,
      METHODS.RECORD,
      METHODS.FLUSH,
      // For AirPlay
      METHODS.GET,
      METHODS.POST
    ];
    exports.METHOD_MAP = utils_1.enumToMap(METHODS);
    exports.H_METHOD_MAP = {};
    Object.keys(exports.METHOD_MAP).forEach((key) => {
      if (/^H/.test(key)) {
        exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
      }
    });
    var FINISH;
    (function(FINISH2) {
      FINISH2[FINISH2["SAFE"] = 0] = "SAFE";
      FINISH2[FINISH2["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
      FINISH2[FINISH2["UNSAFE"] = 2] = "UNSAFE";
    })(FINISH = exports.FINISH || (exports.FINISH = {}));
    exports.ALPHA = [];
    for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
      exports.ALPHA.push(String.fromCharCode(i));
      exports.ALPHA.push(String.fromCharCode(i + 32));
    }
    exports.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9
    };
    exports.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    };
    exports.NUM = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ];
    exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
    exports.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
    exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
    exports.STRICT_URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~"
    ].concat(exports.ALPHANUM);
    exports.URL_CHAR = exports.STRICT_URL_CHAR.concat(["	", "\f"]);
    for (let i = 128; i <= 255; i++) {
      exports.URL_CHAR.push(i);
    }
    exports.HEX = exports.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
    exports.STRICT_TOKEN = [
      "!",
      "#",
      "$",
      "%",
      "&",
      "'",
      "*",
      "+",
      "-",
      ".",
      "^",
      "_",
      "`",
      "|",
      "~"
    ].concat(exports.ALPHANUM);
    exports.TOKEN = exports.STRICT_TOKEN.concat([" "]);
    exports.HEADER_CHARS = ["	"];
    for (let i = 32; i <= 255; i++) {
      if (i !== 127) {
        exports.HEADER_CHARS.push(i);
      }
    }
    exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
    exports.MAJOR = exports.NUM_MAP;
    exports.MINOR = exports.MAJOR;
    var HEADER_STATE;
    (function(HEADER_STATE2) {
      HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
      HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
      HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
      HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
    })(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
    exports.SPECIAL_HEADERS = {
      "connection": HEADER_STATE.CONNECTION,
      "content-length": HEADER_STATE.CONTENT_LENGTH,
      "proxy-connection": HEADER_STATE.CONNECTION,
      "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
      "upgrade": HEADER_STATE.UPGRADE
    };
  }
});

// node_modules/undici/lib/handler/RedirectHandler.js
var require_RedirectHandler = __commonJS({
  "node_modules/undici/lib/handler/RedirectHandler.js"(exports, module) {
    "use strict";
    var util = require_util();
    var { kBodyUsed } = require_symbols();
    var assert = __require("assert");
    var { InvalidArgumentError } = require_errors();
    var EE = __require("events");
    var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
    var kBody = /* @__PURE__ */ Symbol("body");
    var BodyAsyncIterable = class {
      constructor(body) {
        this[kBody] = body;
        this[kBodyUsed] = false;
      }
      async *[Symbol.asyncIterator]() {
        assert(!this[kBodyUsed], "disturbed");
        this[kBodyUsed] = true;
        yield* this[kBody];
      }
    };
    var RedirectHandler = class {
      constructor(dispatch, maxRedirections, opts, handler) {
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        util.validateHandler(handler, opts.method, opts.upgrade);
        this.dispatch = dispatch;
        this.location = null;
        this.abort = null;
        this.opts = { ...opts, maxRedirections: 0 };
        this.maxRedirections = maxRedirections;
        this.handler = handler;
        this.history = [];
        if (util.isStream(this.opts.body)) {
          if (util.bodyLength(this.opts.body) === 0) {
            this.opts.body.on("data", function() {
              assert(false);
            });
          }
          if (typeof this.opts.body.readableDidRead !== "boolean") {
            this.opts.body[kBodyUsed] = false;
            EE.prototype.on.call(this.opts.body, "data", function() {
              this[kBodyUsed] = true;
            });
          }
        } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        }
      }
      onConnect(abort) {
        this.abort = abort;
        this.handler.onConnect(abort, { history: this.history });
      }
      onUpgrade(statusCode, headers, socket) {
        this.handler.onUpgrade(statusCode, headers, socket);
      }
      onError(error) {
        this.handler.onError(error);
      }
      onHeaders(statusCode, headers, resume, statusText) {
        this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
        if (this.opts.origin) {
          this.history.push(new URL(this.opts.path, this.opts.origin));
        }
        if (!this.location) {
          return this.handler.onHeaders(statusCode, headers, resume, statusText);
        }
        const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
        const path12 = search ? `${pathname}${search}` : pathname;
        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
        this.opts.path = path12;
        this.opts.origin = origin;
        this.opts.maxRedirections = 0;
        this.opts.query = null;
        if (statusCode === 303 && this.opts.method !== "HEAD") {
          this.opts.method = "GET";
          this.opts.body = null;
        }
      }
      onData(chunk) {
        if (this.location) {
        } else {
          return this.handler.onData(chunk);
        }
      }
      onComplete(trailers) {
        if (this.location) {
          this.location = null;
          this.abort = null;
          this.dispatch(this.opts, this);
        } else {
          this.handler.onComplete(trailers);
        }
      }
      onBodySent(chunk) {
        if (this.handler.onBodySent) {
          this.handler.onBodySent(chunk);
        }
      }
    };
    function parseLocation(statusCode, headers) {
      if (redirectableStatusCodes.indexOf(statusCode) === -1) {
        return null;
      }
      for (let i = 0; i < headers.length; i += 2) {
        if (headers[i].toString().toLowerCase() === "location") {
          return headers[i + 1];
        }
      }
    }
    function shouldRemoveHeader(header, removeContent, unknownOrigin) {
      if (header.length === 4) {
        return util.headerNameToString(header) === "host";
      }
      if (removeContent && util.headerNameToString(header).startsWith("content-")) {
        return true;
      }
      if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
        const name = util.headerNameToString(header);
        return name === "authorization" || name === "cookie" || name === "proxy-authorization";
      }
      return false;
    }
    function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
      const ret = [];
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
            ret.push(headers[i], headers[i + 1]);
          }
        }
      } else if (headers && typeof headers === "object") {
        for (const key of Object.keys(headers)) {
          if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
            ret.push(key, headers[key]);
          }
        }
      } else {
        assert(headers == null, "headers must be an object or an array");
      }
      return ret;
    }
    module.exports = RedirectHandler;
  }
});

// node_modules/undici/lib/interceptor/redirectInterceptor.js
var require_redirectInterceptor = __commonJS({
  "node_modules/undici/lib/interceptor/redirectInterceptor.js"(exports, module) {
    "use strict";
    var RedirectHandler = require_RedirectHandler();
    function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
      return (dispatch) => {
        return function Intercept(opts, handler) {
          const { maxRedirections = defaultMaxRedirections } = opts;
          if (!maxRedirections) {
            return dispatch(opts, handler);
          }
          const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
          opts = { ...opts, maxRedirections: 0 };
          return dispatch(opts, redirectHandler);
        };
      };
    }
    module.exports = createRedirectInterceptor;
  }
});

// node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS({
  "node_modules/undici/lib/llhttp/llhttp-wasm.js"(exports, module) {
    "use strict";
    module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
  }
});

// node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS({
  "node_modules/undici/lib/llhttp/llhttp_simd-wasm.js"(exports, module) {
    "use strict";
    module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCrLgAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQyoCAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDKgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMqAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMqAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL/gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARB//8DcSIDQQhxDQACQCADQYAEcUUNAAJAIAAtAChBAUcNACAALQAtQQpxDQBBBQ8LQQQPCwJAIANBIHENAAJAIAAtAChBAUYNACAALwEyQf//A3EiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQShxRQ0CIANBiARxQYAERg0CC0EADwtBAEEDIAApAyBQGyEFCyAFC2IBAn9BACEBAkAgAC0AKEEBRg0AIAAvATJB//8DcSICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6cBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMkH//wNxIgVBnH9qQeQASQ0AIAVBzAFGDQAgBUGwAkYNACAEQcAAcQ0AQQAhAyAEQYgEcUGABEYNACAEQShxQQBHIQMLIABBADsBMCAAQQA6AC8gAwuZAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEBIAAvATAiAkECcUUNAQwCC0EAIQEgAC8BMCICQQFxRQ0BC0EBIQEgAC0AKEEBRg0AIAAvATJB//8DcSIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC0kBAXsgAEEQav0MAAAAAAAAAAAAAAAAAAAAACIB/QsDACAAIAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
  }
});

// node_modules/undici/lib/client.js
var require_client = __commonJS({
  "node_modules/undici/lib/client.js"(exports, module) {
    "use strict";
    var assert = __require("assert");
    var net = __require("net");
    var http2 = __require("http");
    var { pipeline } = __require("stream");
    var util = require_util();
    var timers = require_timers();
    var Request = require_request();
    var DispatcherBase = require_dispatcher_base();
    var {
      RequestContentLengthMismatchError,
      ResponseContentLengthMismatchError,
      InvalidArgumentError,
      RequestAbortedError,
      HeadersTimeoutError,
      HeadersOverflowError,
      SocketError,
      InformationalError,
      BodyTimeoutError,
      HTTPParserError,
      ResponseExceededMaxSizeError,
      ClientDestroyedError
    } = require_errors();
    var buildConnector = require_connect();
    var {
      kUrl,
      kReset,
      kServerName,
      kClient,
      kBusy,
      kParser,
      kConnect,
      kBlocking,
      kResuming,
      kRunning,
      kPending,
      kSize,
      kWriting,
      kQueue,
      kConnected,
      kConnecting,
      kNeedDrain,
      kNoRef,
      kKeepAliveDefaultTimeout,
      kHostHeader,
      kPendingIdx,
      kRunningIdx,
      kError,
      kPipelining,
      kSocket,
      kKeepAliveTimeoutValue,
      kMaxHeadersSize,
      kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold,
      kHeadersTimeout,
      kBodyTimeout,
      kStrictContentLength,
      kConnector,
      kMaxRedirections,
      kMaxRequests,
      kCounter,
      kClose,
      kDestroy,
      kDispatch,
      kInterceptors,
      kLocalAddress,
      kMaxResponseSize,
      kHTTPConnVersion,
      // HTTP2
      kHost,
      kHTTP2Session,
      kHTTP2SessionState,
      kHTTP2BuildRequest,
      kHTTP2CopyHeaders,
      kHTTP1BuildRequest
    } = require_symbols();
    var http22;
    try {
      http22 = __require("http2");
    } catch {
      http22 = { constants: {} };
    }
    var {
      constants: {
        HTTP2_HEADER_AUTHORITY,
        HTTP2_HEADER_METHOD,
        HTTP2_HEADER_PATH,
        HTTP2_HEADER_SCHEME,
        HTTP2_HEADER_CONTENT_LENGTH,
        HTTP2_HEADER_EXPECT,
        HTTP2_HEADER_STATUS
      }
    } = http22;
    var h2ExperimentalWarned = false;
    var FastBuffer = Buffer[Symbol.species];
    var kClosedResolve = /* @__PURE__ */ Symbol("kClosedResolve");
    var channels = {};
    try {
      const diagnosticsChannel = __require("diagnostics_channel");
      channels.sendHeaders = diagnosticsChannel.channel("undici:client:sendHeaders");
      channels.beforeConnect = diagnosticsChannel.channel("undici:client:beforeConnect");
      channels.connectError = diagnosticsChannel.channel("undici:client:connectError");
      channels.connected = diagnosticsChannel.channel("undici:client:connected");
    } catch {
      channels.sendHeaders = { hasSubscribers: false };
      channels.beforeConnect = { hasSubscribers: false };
      channels.connectError = { hasSubscribers: false };
      channels.connected = { hasSubscribers: false };
    }
    var Client2 = class extends DispatcherBase {
      /**
       *
       * @param {string|URL} url
       * @param {import('../types/client').Client.Options} options
       */
      constructor(url, {
        interceptors,
        maxHeaderSize,
        headersTimeout,
        socketTimeout,
        requestTimeout,
        connectTimeout,
        bodyTimeout,
        idleTimeout,
        keepAlive,
        keepAliveTimeout,
        maxKeepAliveTimeout,
        keepAliveMaxTimeout,
        keepAliveTimeoutThreshold,
        socketPath,
        pipelining,
        tls,
        strictContentLength,
        maxCachedSessions,
        maxRedirections,
        connect: connect2,
        maxRequestsPerClient,
        localAddress,
        maxResponseSize,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        // h2
        allowH2,
        maxConcurrentStreams
      } = {}) {
        super();
        if (keepAlive !== void 0) {
          throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
        }
        if (socketTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (requestTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (idleTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
        }
        if (maxKeepAliveTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
        }
        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
          throw new InvalidArgumentError("invalid maxHeaderSize");
        }
        if (socketPath != null && typeof socketPath !== "string") {
          throw new InvalidArgumentError("invalid socketPath");
        }
        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
          throw new InvalidArgumentError("invalid connectTimeout");
        }
        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveTimeout");
        }
        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
        }
        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
          throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
        }
        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
        }
        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
        }
        if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
          throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
        }
        if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) {
          throw new InvalidArgumentError("localAddress must be valid string IP address");
        }
        if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
          throw new InvalidArgumentError("maxResponseSize must be a positive number");
        }
        if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
          throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
        }
        if (allowH2 != null && typeof allowH2 !== "boolean") {
          throw new InvalidArgumentError("allowH2 must be a valid boolean value");
        }
        if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
          throw new InvalidArgumentError("maxConcurrentStreams must be a possitive integer, greater than 0");
        }
        if (typeof connect2 !== "function") {
          connect2 = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect2
          });
        }
        this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({ maxRedirections })];
        this[kUrl] = util.parseOrigin(url);
        this[kConnector] = connect2;
        this[kSocket] = null;
        this[kPipelining] = pipelining != null ? pipelining : 1;
        this[kMaxHeadersSize] = maxHeaderSize || http2.maxHeaderSize;
        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
        this[kServerName] = null;
        this[kLocalAddress] = localAddress != null ? localAddress : null;
        this[kResuming] = 0;
        this[kNeedDrain] = 0;
        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
        this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
        this[kMaxRedirections] = maxRedirections;
        this[kMaxRequests] = maxRequestsPerClient;
        this[kClosedResolve] = null;
        this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
        this[kHTTPConnVersion] = "h1";
        this[kHTTP2Session] = null;
        this[kHTTP2SessionState] = !allowH2 ? null : {
          // streams: null, // Fixed queue of streams - For future support of `push`
          openStreams: 0,
          // Keep track of them to decide wether or not unref the session
          maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100
          // Max peerConcurrentStreams for a Node h2 server
        };
        this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}`;
        this[kQueue] = [];
        this[kRunningIdx] = 0;
        this[kPendingIdx] = 0;
      }
      get pipelining() {
        return this[kPipelining];
      }
      set pipelining(value) {
        this[kPipelining] = value;
        resume(this, true);
      }
      get [kPending]() {
        return this[kQueue].length - this[kPendingIdx];
      }
      get [kRunning]() {
        return this[kPendingIdx] - this[kRunningIdx];
      }
      get [kSize]() {
        return this[kQueue].length - this[kRunningIdx];
      }
      get [kConnected]() {
        return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
      }
      get [kBusy]() {
        const socket = this[kSocket];
        return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
      }
      /* istanbul ignore: only used for test */
      [kConnect](cb) {
        connect(this);
        this.once("connect", cb);
      }
      [kDispatch](opts, handler) {
        const origin = opts.origin || this[kUrl].origin;
        const request = this[kHTTPConnVersion] === "h2" ? Request[kHTTP2BuildRequest](origin, opts, handler) : Request[kHTTP1BuildRequest](origin, opts, handler);
        this[kQueue].push(request);
        if (this[kResuming]) {
        } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
          this[kResuming] = 1;
          process.nextTick(resume, this);
        } else {
          resume(this, true);
        }
        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
          this[kNeedDrain] = 2;
        }
        return this[kNeedDrain] < 2;
      }
      async [kClose]() {
        return new Promise((resolve5) => {
          if (!this[kSize]) {
            resolve5(null);
          } else {
            this[kClosedResolve] = resolve5;
          }
        });
      }
      async [kDestroy](err) {
        return new Promise((resolve5) => {
          const requests = this[kQueue].splice(this[kPendingIdx]);
          for (let i = 0; i < requests.length; i++) {
            const request = requests[i];
            errorRequest(this, request, err);
          }
          const callback = () => {
            if (this[kClosedResolve]) {
              this[kClosedResolve]();
              this[kClosedResolve] = null;
            }
            resolve5();
          };
          if (this[kHTTP2Session] != null) {
            util.destroy(this[kHTTP2Session], err);
            this[kHTTP2Session] = null;
            this[kHTTP2SessionState] = null;
          }
          if (!this[kSocket]) {
            queueMicrotask(callback);
          } else {
            util.destroy(this[kSocket].on("close", callback), err);
          }
          resume(this);
        });
      }
    };
    function onHttp2SessionError(err) {
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      this[kSocket][kError] = err;
      onError(this[kClient], err);
    }
    function onHttp2FrameError(type, code, id) {
      const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
      if (id === 0) {
        this[kSocket][kError] = err;
        onError(this[kClient], err);
      }
    }
    function onHttp2SessionEnd() {
      util.destroy(this, new SocketError("other side closed"));
      util.destroy(this[kSocket], new SocketError("other side closed"));
    }
    function onHTTP2GoAway(code) {
      const client = this[kClient];
      const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
      client[kSocket] = null;
      client[kHTTP2Session] = null;
      if (client.destroyed) {
        assert(this[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(this, request, err);
        }
      } else if (client[kRunning] > 0) {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit(
        "disconnect",
        client[kUrl],
        [client],
        err
      );
      resume(client);
    }
    var constants2 = require_constants3();
    var createRedirectInterceptor = require_redirectInterceptor();
    var EMPTY_BUF = Buffer.alloc(0);
    async function lazyllhttp() {
      const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
      let mod;
      try {
        mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
      } catch (e) {
        mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
      }
      return await WebAssembly.instantiate(mod, {
        env: {
          /* eslint-disable camelcase */
          wasm_on_url: (p, at, len) => {
            return 0;
          },
          wasm_on_status: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_begin: (p) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageBegin() || 0;
          },
          wasm_on_header_field: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_header_value: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
          },
          wasm_on_body: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_complete: (p) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageComplete() || 0;
          }
          /* eslint-enable camelcase */
        }
      });
    }
    var llhttpInstance = null;
    var llhttpPromise = lazyllhttp();
    llhttpPromise.catch();
    var currentParser = null;
    var currentBufferRef = null;
    var currentBufferSize = 0;
    var currentBufferPtr = null;
    var TIMEOUT_HEADERS = 1;
    var TIMEOUT_BODY = 2;
    var TIMEOUT_IDLE = 3;
    var Parser = class {
      constructor(client, socket, { exports: exports2 }) {
        assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
        this.llhttp = exports2;
        this.ptr = this.llhttp.llhttp_alloc(constants2.TYPE.RESPONSE);
        this.client = client;
        this.socket = socket;
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.statusCode = null;
        this.statusText = "";
        this.upgrade = false;
        this.headers = [];
        this.headersSize = 0;
        this.headersMaxSize = client[kMaxHeadersSize];
        this.shouldKeepAlive = false;
        this.paused = false;
        this.resume = this.resume.bind(this);
        this.bytesRead = 0;
        this.keepAlive = "";
        this.contentLength = "";
        this.connection = "";
        this.maxResponseSize = client[kMaxResponseSize];
      }
      setTimeout(value, type) {
        this.timeoutType = type;
        if (value !== this.timeoutValue) {
          timers.clearTimeout(this.timeout);
          if (value) {
            this.timeout = timers.setTimeout(onParserTimeout, value, this);
            if (this.timeout.unref) {
              this.timeout.unref();
            }
          } else {
            this.timeout = null;
          }
          this.timeoutValue = value;
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
      }
      resume() {
        if (this.socket.destroyed || !this.paused) {
          return;
        }
        assert(this.ptr != null);
        assert(currentParser == null);
        this.llhttp.llhttp_resume(this.ptr);
        assert(this.timeoutType === TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        this.paused = false;
        this.execute(this.socket.read() || EMPTY_BUF);
        this.readMore();
      }
      readMore() {
        while (!this.paused && this.ptr) {
          const chunk = this.socket.read();
          if (chunk === null) {
            break;
          }
          this.execute(chunk);
        }
      }
      execute(data) {
        assert(this.ptr != null);
        assert(currentParser == null);
        assert(!this.paused);
        const { socket, llhttp } = this;
        if (data.length > currentBufferSize) {
          if (currentBufferPtr) {
            llhttp.free(currentBufferPtr);
          }
          currentBufferSize = Math.ceil(data.length / 4096) * 4096;
          currentBufferPtr = llhttp.malloc(currentBufferSize);
        }
        new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
        try {
          let ret;
          try {
            currentBufferRef = data;
            currentParser = this;
            ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
          } catch (err) {
            throw err;
          } finally {
            currentParser = null;
            currentBufferRef = null;
          }
          const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
          if (ret === constants2.ERROR.PAUSED_UPGRADE) {
            this.onUpgrade(data.slice(offset));
          } else if (ret === constants2.ERROR.PAUSED) {
            this.paused = true;
            socket.unshift(data.slice(offset));
          } else if (ret !== constants2.ERROR.OK) {
            const ptr = llhttp.llhttp_get_error_reason(this.ptr);
            let message = "";
            if (ptr) {
              const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
              message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
            }
            throw new HTTPParserError(message, constants2.ERROR[ret], data.slice(offset));
          }
        } catch (err) {
          util.destroy(socket, err);
        }
      }
      destroy() {
        assert(this.ptr != null);
        assert(currentParser == null);
        this.llhttp.llhttp_free(this.ptr);
        this.ptr = null;
        timers.clearTimeout(this.timeout);
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.paused = false;
      }
      onStatus(buf) {
        this.statusText = buf.toString();
      }
      onMessageBegin() {
        const { socket, client } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
      }
      onHeaderField(buf) {
        const len = this.headers.length;
        if ((len & 1) === 0) {
          this.headers.push(buf);
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        this.trackHeader(buf.length);
      }
      onHeaderValue(buf) {
        let len = this.headers.length;
        if ((len & 1) === 1) {
          this.headers.push(buf);
          len += 1;
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        const key = this.headers[len - 2];
        if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") {
          this.keepAlive += buf.toString();
        } else if (key.length === 10 && key.toString().toLowerCase() === "connection") {
          this.connection += buf.toString();
        } else if (key.length === 14 && key.toString().toLowerCase() === "content-length") {
          this.contentLength += buf.toString();
        }
        this.trackHeader(buf.length);
      }
      trackHeader(len) {
        this.headersSize += len;
        if (this.headersSize >= this.headersMaxSize) {
          util.destroy(this.socket, new HeadersOverflowError());
        }
      }
      onUpgrade(head) {
        const { upgrade, client, socket, headers, statusCode } = this;
        assert(upgrade);
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(!socket.destroyed);
        assert(socket === client[kSocket]);
        assert(!this.paused);
        assert(request.upgrade || request.method === "CONNECT");
        this.statusCode = null;
        this.statusText = "";
        this.shouldKeepAlive = null;
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        socket.unshift(head);
        socket[kParser].destroy();
        socket[kParser] = null;
        socket[kClient] = null;
        socket[kError] = null;
        socket.removeListener("error", onSocketError).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
        client[kSocket] = null;
        client[kQueue][client[kRunningIdx]++] = null;
        client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
        try {
          request.onUpgrade(statusCode, headers, socket);
        } catch (err) {
          util.destroy(socket, err);
        }
        resume(client);
      }
      onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
        const { client, socket, headers, statusText } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
        assert(!this.upgrade);
        assert(this.statusCode < 200);
        if (statusCode === 100) {
          util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket)));
          return -1;
        }
        if (upgrade && !request.upgrade) {
          util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket)));
          return -1;
        }
        assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
        this.statusCode = statusCode;
        this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.
        request.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
        if (this.statusCode >= 200) {
          const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
          this.setTimeout(bodyTimeout, TIMEOUT_BODY);
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        if (request.method === "CONNECT") {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        if (upgrade) {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (this.shouldKeepAlive && client[kPipelining]) {
          const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
          if (keepAliveTimeout != null) {
            const timeout = Math.min(
              keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
              client[kKeepAliveMaxTimeout]
            );
            if (timeout <= 0) {
              socket[kReset] = true;
            } else {
              client[kKeepAliveTimeoutValue] = timeout;
            }
          } else {
            client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
          }
        } else {
          socket[kReset] = true;
        }
        const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;
        if (request.aborted) {
          return -1;
        }
        if (request.method === "HEAD") {
          return 1;
        }
        if (statusCode < 200) {
          return 1;
        }
        if (socket[kBlocking]) {
          socket[kBlocking] = false;
          resume(client);
        }
        return pause ? constants2.ERROR.PAUSED : 0;
      }
      onBody(buf) {
        const { client, socket, statusCode, maxResponseSize } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert.strictEqual(this.timeoutType, TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        assert(statusCode >= 200);
        if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
          util.destroy(socket, new ResponseExceededMaxSizeError());
          return -1;
        }
        this.bytesRead += buf.length;
        if (request.onData(buf) === false) {
          return constants2.ERROR.PAUSED;
        }
      }
      onMessageComplete() {
        const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
          return -1;
        }
        if (upgrade) {
          return;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(statusCode >= 100);
        this.statusCode = null;
        this.statusText = "";
        this.bytesRead = 0;
        this.contentLength = "";
        this.keepAlive = "";
        this.connection = "";
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (statusCode < 200) {
          return;
        }
        if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
          util.destroy(socket, new ResponseContentLengthMismatchError());
          return -1;
        }
        request.onComplete(headers);
        client[kQueue][client[kRunningIdx]++] = null;
        if (socket[kWriting]) {
          assert.strictEqual(client[kRunning], 0);
          util.destroy(socket, new InformationalError("reset"));
          return constants2.ERROR.PAUSED;
        } else if (!shouldKeepAlive) {
          util.destroy(socket, new InformationalError("reset"));
          return constants2.ERROR.PAUSED;
        } else if (socket[kReset] && client[kRunning] === 0) {
          util.destroy(socket, new InformationalError("reset"));
          return constants2.ERROR.PAUSED;
        } else if (client[kPipelining] === 1) {
          setImmediate(resume, client);
        } else {
          resume(client);
        }
      }
    };
    function onParserTimeout(parser) {
      const { socket, timeoutType, client } = parser;
      if (timeoutType === TIMEOUT_HEADERS) {
        if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
          assert(!parser.paused, "cannot be paused while waiting for headers");
          util.destroy(socket, new HeadersTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_BODY) {
        if (!parser.paused) {
          util.destroy(socket, new BodyTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_IDLE) {
        assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
        util.destroy(socket, new InformationalError("socket idle timeout"));
      }
    }
    function onSocketReadable() {
      const { [kParser]: parser } = this;
      if (parser) {
        parser.readMore();
      }
    }
    function onSocketError(err) {
      const { [kClient]: client, [kParser]: parser } = this;
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      if (client[kHTTPConnVersion] !== "h2") {
        if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
          return;
        }
      }
      this[kError] = err;
      onError(this[kClient], err);
    }
    function onError(client, err) {
      if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
        assert(client[kPendingIdx] === client[kRunningIdx]);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(client, request, err);
        }
        assert(client[kSize] === 0);
      }
    }
    function onSocketEnd() {
      const { [kParser]: parser, [kClient]: client } = this;
      if (client[kHTTPConnVersion] !== "h2") {
        if (parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
          return;
        }
      }
      util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
    }
    function onSocketClose() {
      const { [kClient]: client, [kParser]: parser } = this;
      if (client[kHTTPConnVersion] === "h1" && parser) {
        if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
        }
        this[kParser].destroy();
        this[kParser] = null;
      }
      const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
      client[kSocket] = null;
      if (client.destroyed) {
        assert(client[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(client, request, err);
        }
      } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit("disconnect", client[kUrl], [client], err);
      resume(client);
    }
    async function connect(client) {
      assert(!client[kConnecting]);
      assert(!client[kSocket]);
      let { host, hostname, protocol, port } = client[kUrl];
      if (hostname[0] === "[") {
        const idx = hostname.indexOf("]");
        assert(idx !== -1);
        const ip = hostname.substring(1, idx);
        assert(net.isIP(ip));
        hostname = ip;
      }
      client[kConnecting] = true;
      if (channels.beforeConnect.hasSubscribers) {
        channels.beforeConnect.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector]
        });
      }
      try {
        const socket = await new Promise((resolve5, reject) => {
          client[kConnector]({
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          }, (err, socket2) => {
            if (err) {
              reject(err);
            } else {
              resolve5(socket2);
            }
          });
        });
        if (client.destroyed) {
          util.destroy(socket.on("error", () => {
          }), new ClientDestroyedError());
          return;
        }
        client[kConnecting] = false;
        assert(socket);
        const isH2 = socket.alpnProtocol === "h2";
        if (isH2) {
          if (!h2ExperimentalWarned) {
            h2ExperimentalWarned = true;
            process.emitWarning("H2 support is experimental, expect them to change at any time.", {
              code: "UNDICI-H2"
            });
          }
          const session = http22.connect(client[kUrl], {
            createConnection: () => socket,
            peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams
          });
          client[kHTTPConnVersion] = "h2";
          session[kClient] = client;
          session[kSocket] = socket;
          session.on("error", onHttp2SessionError);
          session.on("frameError", onHttp2FrameError);
          session.on("end", onHttp2SessionEnd);
          session.on("goaway", onHTTP2GoAway);
          session.on("close", onSocketClose);
          session.unref();
          client[kHTTP2Session] = session;
          socket[kHTTP2Session] = session;
        } else {
          if (!llhttpInstance) {
            llhttpInstance = await llhttpPromise;
            llhttpPromise = null;
          }
          socket[kNoRef] = false;
          socket[kWriting] = false;
          socket[kReset] = false;
          socket[kBlocking] = false;
          socket[kParser] = new Parser(client, socket, llhttpInstance);
        }
        socket[kCounter] = 0;
        socket[kMaxRequests] = client[kMaxRequests];
        socket[kClient] = client;
        socket[kError] = null;
        socket.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose);
        client[kSocket] = socket;
        if (channels.connected.hasSubscribers) {
          channels.connected.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            socket
          });
        }
        client.emit("connect", client[kUrl], [client]);
      } catch (err) {
        if (client.destroyed) {
          return;
        }
        client[kConnecting] = false;
        if (channels.connectError.hasSubscribers) {
          channels.connectError.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            error: err
          });
        }
        if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
          assert(client[kRunning] === 0);
          while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
            const request = client[kQueue][client[kPendingIdx]++];
            errorRequest(client, request, err);
          }
        } else {
          onError(client, err);
        }
        client.emit("connectionError", client[kUrl], [client], err);
      }
      resume(client);
    }
    function emitDrain(client) {
      client[kNeedDrain] = 0;
      client.emit("drain", client[kUrl], [client]);
    }
    function resume(client, sync) {
      if (client[kResuming] === 2) {
        return;
      }
      client[kResuming] = 2;
      _resume(client, sync);
      client[kResuming] = 0;
      if (client[kRunningIdx] > 256) {
        client[kQueue].splice(0, client[kRunningIdx]);
        client[kPendingIdx] -= client[kRunningIdx];
        client[kRunningIdx] = 0;
      }
    }
    function _resume(client, sync) {
      while (true) {
        if (client.destroyed) {
          assert(client[kPending] === 0);
          return;
        }
        if (client[kClosedResolve] && !client[kSize]) {
          client[kClosedResolve]();
          client[kClosedResolve] = null;
          return;
        }
        const socket = client[kSocket];
        if (socket && !socket.destroyed && socket.alpnProtocol !== "h2") {
          if (client[kSize] === 0) {
            if (!socket[kNoRef] && socket.unref) {
              socket.unref();
              socket[kNoRef] = true;
            }
          } else if (socket[kNoRef] && socket.ref) {
            socket.ref();
            socket[kNoRef] = false;
          }
          if (client[kSize] === 0) {
            if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
              socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
            }
          } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
            if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
              const request2 = client[kQueue][client[kRunningIdx]];
              const headersTimeout = request2.headersTimeout != null ? request2.headersTimeout : client[kHeadersTimeout];
              socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
            }
          }
        }
        if (client[kBusy]) {
          client[kNeedDrain] = 2;
        } else if (client[kNeedDrain] === 2) {
          if (sync) {
            client[kNeedDrain] = 1;
            process.nextTick(emitDrain, client);
          } else {
            emitDrain(client);
          }
          continue;
        }
        if (client[kPending] === 0) {
          return;
        }
        if (client[kRunning] >= (client[kPipelining] || 1)) {
          return;
        }
        const request = client[kQueue][client[kPendingIdx]];
        if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
          if (client[kRunning] > 0) {
            return;
          }
          client[kServerName] = request.servername;
          if (socket && socket.servername !== request.servername) {
            util.destroy(socket, new InformationalError("servername changed"));
            return;
          }
        }
        if (client[kConnecting]) {
          return;
        }
        if (!socket && !client[kHTTP2Session]) {
          connect(client);
          return;
        }
        if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
          return;
        }
        if (client[kRunning] > 0 && !request.idempotent) {
          return;
        }
        if (client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT")) {
          return;
        }
        if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body))) {
          return;
        }
        if (!request.aborted && write(client, request)) {
          client[kPendingIdx]++;
        } else {
          client[kQueue].splice(client[kPendingIdx], 1);
        }
      }
    }
    function shouldSendContentLength(method) {
      return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
    }
    function write(client, request) {
      if (client[kHTTPConnVersion] === "h2") {
        writeH2(client, client[kHTTP2Session], request);
        return;
      }
      const { body, method, path: path12, host, upgrade, headers, blocking, reset } = request;
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      const bodyLength = util.bodyLength(body);
      let contentLength = bodyLength;
      if (contentLength === null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 && !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      const socket = client[kSocket];
      try {
        request.onConnect((err) => {
          if (request.aborted || request.completed) {
            return;
          }
          errorRequest(client, request, err || new RequestAbortedError());
          util.destroy(socket, new InformationalError("aborted"));
        });
      } catch (err) {
        errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      if (method === "HEAD") {
        socket[kReset] = true;
      }
      if (upgrade || method === "CONNECT") {
        socket[kReset] = true;
      }
      if (reset != null) {
        socket[kReset] = reset;
      }
      if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
        socket[kReset] = true;
      }
      if (blocking) {
        socket[kBlocking] = true;
      }
      let header = `${method} ${path12} HTTP/1.1\r
`;
      if (typeof host === "string") {
        header += `host: ${host}\r
`;
      } else {
        header += client[kHostHeader];
      }
      if (upgrade) {
        header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
      } else if (client[kPipelining] && !socket[kReset]) {
        header += "connection: keep-alive\r\n";
      } else {
        header += "connection: close\r\n";
      }
      if (headers) {
        header += headers;
      }
      if (channels.sendHeaders.hasSubscribers) {
        channels.sendHeaders.publish({ request, headers: header, socket });
      }
      if (!body || bodyLength === 0) {
        if (contentLength === 0) {
          socket.write(`${header}content-length: 0\r
\r
`, "latin1");
        } else {
          assert(contentLength === null, "no body must not have content length");
          socket.write(`${header}\r
`, "latin1");
        }
        request.onRequestSent();
      } else if (util.isBuffer(body)) {
        assert(contentLength === body.byteLength, "buffer body must have content length");
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        socket.write(body);
        socket.uncork();
        request.onBodySent(body);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
      } else if (util.isBlobLike(body)) {
        if (typeof body.stream === "function") {
          writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload });
        } else {
          writeBlob({ body, client, request, socket, contentLength, header, expectsPayload });
        }
      } else if (util.isStream(body)) {
        writeStream({ body, client, request, socket, contentLength, header, expectsPayload });
      } else if (util.isIterable(body)) {
        writeIterable({ body, client, request, socket, contentLength, header, expectsPayload });
      } else {
        assert(false);
      }
      return true;
    }
    function writeH2(client, session, request) {
      const { body, method, path: path12, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;
      let headers;
      if (typeof reqHeaders === "string") headers = Request[kHTTP2CopyHeaders](reqHeaders.trim());
      else headers = reqHeaders;
      if (upgrade) {
        errorRequest(client, request, new Error("Upgrade not supported for H2"));
        return false;
      }
      try {
        request.onConnect((err) => {
          if (request.aborted || request.completed) {
            return;
          }
          errorRequest(client, request, err || new RequestAbortedError());
        });
      } catch (err) {
        errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      let stream;
      const h2State = client[kHTTP2SessionState];
      headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];
      headers[HTTP2_HEADER_METHOD] = method;
      if (method === "CONNECT") {
        session.ref();
        stream = session.request(headers, { endStream: false, signal });
        if (stream.id && !stream.pending) {
          request.onUpgrade(null, null, stream);
          ++h2State.openStreams;
        } else {
          stream.once("ready", () => {
            request.onUpgrade(null, null, stream);
            ++h2State.openStreams;
          });
        }
        stream.once("close", () => {
          h2State.openStreams -= 1;
          if (h2State.openStreams === 0) session.unref();
        });
        return true;
      }
      headers[HTTP2_HEADER_PATH] = path12;
      headers[HTTP2_HEADER_SCHEME] = "https";
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      let contentLength = util.bodyLength(body);
      if (contentLength == null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 || !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      if (contentLength != null) {
        assert(body, "no body must not have content length");
        headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
      }
      session.ref();
      const shouldEndStream = method === "GET" || method === "HEAD";
      if (expectContinue) {
        headers[HTTP2_HEADER_EXPECT] = "100-continue";
        stream = session.request(headers, { endStream: shouldEndStream, signal });
        stream.once("continue", writeBodyH2);
      } else {
        stream = session.request(headers, {
          endStream: shouldEndStream,
          signal
        });
        writeBodyH2();
      }
      ++h2State.openStreams;
      stream.once("response", (headers2) => {
        const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers2;
        if (request.onHeaders(Number(statusCode), realHeaders, stream.resume.bind(stream), "") === false) {
          stream.pause();
        }
      });
      stream.once("end", () => {
        request.onComplete([]);
      });
      stream.on("data", (chunk) => {
        if (request.onData(chunk) === false) {
          stream.pause();
        }
      });
      stream.once("close", () => {
        h2State.openStreams -= 1;
        if (h2State.openStreams === 0) {
          session.unref();
        }
      });
      stream.once("error", function(err) {
        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
          h2State.streams -= 1;
          util.destroy(stream, err);
        }
      });
      stream.once("frameError", (type, code) => {
        const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
        errorRequest(client, request, err);
        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
          h2State.streams -= 1;
          util.destroy(stream, err);
        }
      });
      return true;
      function writeBodyH2() {
        if (!body) {
          request.onRequestSent();
        } else if (util.isBuffer(body)) {
          assert(contentLength === body.byteLength, "buffer body must have content length");
          stream.cork();
          stream.write(body);
          stream.uncork();
          stream.end();
          request.onBodySent(body);
          request.onRequestSent();
        } else if (util.isBlobLike(body)) {
          if (typeof body.stream === "function") {
            writeIterable({
              client,
              request,
              contentLength,
              h2stream: stream,
              expectsPayload,
              body: body.stream(),
              socket: client[kSocket],
              header: ""
            });
          } else {
            writeBlob({
              body,
              client,
              request,
              contentLength,
              expectsPayload,
              h2stream: stream,
              header: "",
              socket: client[kSocket]
            });
          }
        } else if (util.isStream(body)) {
          writeStream({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            socket: client[kSocket],
            h2stream: stream,
            header: ""
          });
        } else if (util.isIterable(body)) {
          writeIterable({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            header: "",
            h2stream: stream,
            socket: client[kSocket]
          });
        } else {
          assert(false);
        }
      }
    }
    function writeStream({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
      if (client[kHTTPConnVersion] === "h2") {
        let onPipeData = function(chunk) {
          request.onBodySent(chunk);
        };
        const pipe = pipeline(
          body,
          h2stream,
          (err) => {
            if (err) {
              util.destroy(body, err);
              util.destroy(h2stream, err);
            } else {
              request.onRequestSent();
            }
          }
        );
        pipe.on("data", onPipeData);
        pipe.once("end", () => {
          pipe.removeListener("data", onPipeData);
          util.destroy(pipe);
        });
        return;
      }
      let finished = false;
      const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      const onData = function(chunk) {
        if (finished) {
          return;
        }
        try {
          if (!writer.write(chunk) && this.pause) {
            this.pause();
          }
        } catch (err) {
          util.destroy(this, err);
        }
      };
      const onDrain = function() {
        if (finished) {
          return;
        }
        if (body.resume) {
          body.resume();
        }
      };
      const onAbort = function() {
        if (finished) {
          return;
        }
        const err = new RequestAbortedError();
        queueMicrotask(() => onFinished(err));
      };
      const onFinished = function(err) {
        if (finished) {
          return;
        }
        finished = true;
        assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
        socket.off("drain", onDrain).off("error", onFinished);
        body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
        if (!err) {
          try {
            writer.end();
          } catch (er) {
            err = er;
          }
        }
        writer.destroy(err);
        if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
          util.destroy(body, err);
        } else {
          util.destroy(body);
        }
      };
      body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
      if (body.resume) {
        body.resume();
      }
      socket.on("drain", onDrain).on("error", onFinished);
    }
    async function writeBlob({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength === body.size, "blob body must have content length");
      const isH2 = client[kHTTPConnVersion] === "h2";
      try {
        if (contentLength != null && contentLength !== body.size) {
          throw new RequestContentLengthMismatchError();
        }
        const buffer = Buffer.from(await body.arrayBuffer());
        if (isH2) {
          h2stream.cork();
          h2stream.write(buffer);
          h2stream.uncork();
        } else {
          socket.cork();
          socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          socket.write(buffer);
          socket.uncork();
        }
        request.onBodySent(buffer);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        resume(client);
      } catch (err) {
        util.destroy(isH2 ? h2stream : socket, err);
      }
    }
    async function writeIterable({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
      let callback = null;
      function onDrain() {
        if (callback) {
          const cb = callback;
          callback = null;
          cb();
        }
      }
      const waitForDrain = () => new Promise((resolve5, reject) => {
        assert(callback === null);
        if (socket[kError]) {
          reject(socket[kError]);
        } else {
          callback = resolve5;
        }
      });
      if (client[kHTTPConnVersion] === "h2") {
        h2stream.on("close", onDrain).on("drain", onDrain);
        try {
          for await (const chunk of body) {
            if (socket[kError]) {
              throw socket[kError];
            }
            const res = h2stream.write(chunk);
            request.onBodySent(chunk);
            if (!res) {
              await waitForDrain();
            }
          }
        } catch (err) {
          h2stream.destroy(err);
        } finally {
          request.onRequestSent();
          h2stream.end();
          h2stream.off("close", onDrain).off("drain", onDrain);
        }
        return;
      }
      socket.on("close", onDrain).on("drain", onDrain);
      const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      try {
        for await (const chunk of body) {
          if (socket[kError]) {
            throw socket[kError];
          }
          if (!writer.write(chunk)) {
            await waitForDrain();
          }
        }
        writer.end();
      } catch (err) {
        writer.destroy(err);
      } finally {
        socket.off("close", onDrain).off("drain", onDrain);
      }
    }
    var AsyncWriter = class {
      constructor({ socket, request, contentLength, client, expectsPayload, header }) {
        this.socket = socket;
        this.request = request;
        this.contentLength = contentLength;
        this.client = client;
        this.bytesWritten = 0;
        this.expectsPayload = expectsPayload;
        this.header = header;
        socket[kWriting] = true;
      }
      write(chunk) {
        const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return false;
        }
        const len = Buffer.byteLength(chunk);
        if (!len) {
          return true;
        }
        if (contentLength !== null && bytesWritten + len > contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          }
          process.emitWarning(new RequestContentLengthMismatchError());
        }
        socket.cork();
        if (bytesWritten === 0) {
          if (!expectsPayload) {
            socket[kReset] = true;
          }
          if (contentLength === null) {
            socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
          } else {
            socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          }
        }
        if (contentLength === null) {
          socket.write(`\r
${len.toString(16)}\r
`, "latin1");
        }
        this.bytesWritten += len;
        const ret = socket.write(chunk);
        socket.uncork();
        request.onBodySent(chunk);
        if (!ret) {
          if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
            if (socket[kParser].timeout.refresh) {
              socket[kParser].timeout.refresh();
            }
          }
        }
        return ret;
      }
      end() {
        const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
        request.onRequestSent();
        socket[kWriting] = false;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return;
        }
        if (bytesWritten === 0) {
          if (expectsPayload) {
            socket.write(`${header}content-length: 0\r
\r
`, "latin1");
          } else {
            socket.write(`${header}\r
`, "latin1");
          }
        } else if (contentLength === null) {
          socket.write("\r\n0\r\n\r\n", "latin1");
        }
        if (contentLength !== null && bytesWritten !== contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          } else {
            process.emitWarning(new RequestContentLengthMismatchError());
          }
        }
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
        resume(client);
      }
      destroy(err) {
        const { socket, client } = this;
        socket[kWriting] = false;
        if (err) {
          assert(client[kRunning] <= 1, "pipeline should only contain this request");
          util.destroy(socket, err);
        }
      }
    };
    function errorRequest(client, request, err) {
      try {
        request.onError(err);
        assert(request.aborted);
      } catch (err2) {
        client.emit("error", err2);
      }
    }
    module.exports = Client2;
  }
});

// node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS({
  "node_modules/undici/lib/node/fixed-queue.js"(exports, module) {
    "use strict";
    var kSize = 2048;
    var kMask = kSize - 1;
    var FixedCircularBuffer = class {
      constructor() {
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
      }
      isEmpty() {
        return this.top === this.bottom;
      }
      isFull() {
        return (this.top + 1 & kMask) === this.bottom;
      }
      push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
      }
      shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === void 0)
          return null;
        this.list[this.bottom] = void 0;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
      }
    };
    module.exports = class FixedQueue {
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
      push(data) {
        if (this.head.isFull()) {
          this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
      }
      shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
          this.tail = tail.next;
        }
        return next;
      }
    };
  }
});

// node_modules/undici/lib/pool-stats.js
var require_pool_stats = __commonJS({
  "node_modules/undici/lib/pool-stats.js"(exports, module) {
    "use strict";
    var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();
    var kPool = /* @__PURE__ */ Symbol("pool");
    var PoolStats = class {
      constructor(pool) {
        this[kPool] = pool;
      }
      get connected() {
        return this[kPool][kConnected];
      }
      get free() {
        return this[kPool][kFree];
      }
      get pending() {
        return this[kPool][kPending];
      }
      get queued() {
        return this[kPool][kQueued];
      }
      get running() {
        return this[kPool][kRunning];
      }
      get size() {
        return this[kPool][kSize];
      }
    };
    module.exports = PoolStats;
  }
});

// node_modules/undici/lib/pool-base.js
var require_pool_base = __commonJS({
  "node_modules/undici/lib/pool-base.js"(exports, module) {
    "use strict";
    var DispatcherBase = require_dispatcher_base();
    var FixedQueue = require_fixed_queue();
    var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();
    var PoolStats = require_pool_stats();
    var kClients = /* @__PURE__ */ Symbol("clients");
    var kNeedDrain = /* @__PURE__ */ Symbol("needDrain");
    var kQueue = /* @__PURE__ */ Symbol("queue");
    var kClosedResolve = /* @__PURE__ */ Symbol("closed resolve");
    var kOnDrain = /* @__PURE__ */ Symbol("onDrain");
    var kOnConnect = /* @__PURE__ */ Symbol("onConnect");
    var kOnDisconnect = /* @__PURE__ */ Symbol("onDisconnect");
    var kOnConnectionError = /* @__PURE__ */ Symbol("onConnectionError");
    var kGetDispatcher = /* @__PURE__ */ Symbol("get dispatcher");
    var kAddClient = /* @__PURE__ */ Symbol("add client");
    var kRemoveClient = /* @__PURE__ */ Symbol("remove client");
    var kStats = /* @__PURE__ */ Symbol("stats");
    var PoolBase = class extends DispatcherBase {
      constructor() {
        super();
        this[kQueue] = new FixedQueue();
        this[kClients] = [];
        this[kQueued] = 0;
        const pool = this;
        this[kOnDrain] = function onDrain(origin, targets) {
          const queue = pool[kQueue];
          let needDrain = false;
          while (!needDrain) {
            const item = queue.shift();
            if (!item) {
              break;
            }
            pool[kQueued]--;
            needDrain = !this.dispatch(item.opts, item.handler);
          }
          this[kNeedDrain] = needDrain;
          if (!this[kNeedDrain] && pool[kNeedDrain]) {
            pool[kNeedDrain] = false;
            pool.emit("drain", origin, [pool, ...targets]);
          }
          if (pool[kClosedResolve] && queue.isEmpty()) {
            Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
          }
        };
        this[kOnConnect] = (origin, targets) => {
          pool.emit("connect", origin, [pool, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          pool.emit("disconnect", origin, [pool, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          pool.emit("connectionError", origin, [pool, ...targets], err);
        };
        this[kStats] = new PoolStats(this);
      }
      get [kBusy]() {
        return this[kNeedDrain];
      }
      get [kConnected]() {
        return this[kClients].filter((client) => client[kConnected]).length;
      }
      get [kFree]() {
        return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
      }
      get [kPending]() {
        let ret = this[kQueued];
        for (const { [kPending]: pending } of this[kClients]) {
          ret += pending;
        }
        return ret;
      }
      get [kRunning]() {
        let ret = 0;
        for (const { [kRunning]: running } of this[kClients]) {
          ret += running;
        }
        return ret;
      }
      get [kSize]() {
        let ret = this[kQueued];
        for (const { [kSize]: size } of this[kClients]) {
          ret += size;
        }
        return ret;
      }
      get stats() {
        return this[kStats];
      }
      async [kClose]() {
        if (this[kQueue].isEmpty()) {
          return Promise.all(this[kClients].map((c) => c.close()));
        } else {
          return new Promise((resolve5) => {
            this[kClosedResolve] = resolve5;
          });
        }
      }
      async [kDestroy](err) {
        while (true) {
          const item = this[kQueue].shift();
          if (!item) {
            break;
          }
          item.handler.onError(err);
        }
        return Promise.all(this[kClients].map((c) => c.destroy(err)));
      }
      [kDispatch](opts, handler) {
        const dispatcher = this[kGetDispatcher]();
        if (!dispatcher) {
          this[kNeedDrain] = true;
          this[kQueue].push({ opts, handler });
          this[kQueued]++;
        } else if (!dispatcher.dispatch(opts, handler)) {
          dispatcher[kNeedDrain] = true;
          this[kNeedDrain] = !this[kGetDispatcher]();
        }
        return !this[kNeedDrain];
      }
      [kAddClient](client) {
        client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
        this[kClients].push(client);
        if (this[kNeedDrain]) {
          process.nextTick(() => {
            if (this[kNeedDrain]) {
              this[kOnDrain](client[kUrl], [this, client]);
            }
          });
        }
        return this;
      }
      [kRemoveClient](client) {
        client.close(() => {
          const idx = this[kClients].indexOf(client);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        });
        this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
      }
    };
    module.exports = {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    };
  }
});

// node_modules/undici/lib/pool.js
var require_pool = __commonJS({
  "node_modules/undici/lib/pool.js"(exports, module) {
    "use strict";
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kGetDispatcher
    } = require_pool_base();
    var Client2 = require_client();
    var {
      InvalidArgumentError
    } = require_errors();
    var util = require_util();
    var { kUrl, kInterceptors } = require_symbols();
    var buildConnector = require_connect();
    var kOptions = /* @__PURE__ */ Symbol("options");
    var kConnections = /* @__PURE__ */ Symbol("connections");
    var kFactory = /* @__PURE__ */ Symbol("factory");
    function defaultFactory(origin, opts) {
      return new Client2(origin, opts);
    }
    var Pool = class extends PoolBase {
      constructor(origin, {
        connections,
        factory = defaultFactory,
        connect,
        connectTimeout,
        tls,
        maxCachedSessions,
        socketPath,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        allowH2,
        ...options
      } = {}) {
        super();
        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
          throw new InvalidArgumentError("invalid connections");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (typeof connect !== "function") {
          connect = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect
          });
        }
        this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
        this[kConnections] = connections || null;
        this[kUrl] = util.parseOrigin(origin);
        this[kOptions] = { ...util.deepClone(options), connect, allowH2 };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kFactory] = factory;
        this.on("connectionError", (origin2, targets, error) => {
          for (const target of targets) {
            const idx = this[kClients].indexOf(target);
            if (idx !== -1) {
              this[kClients].splice(idx, 1);
            }
          }
        });
      }
      [kGetDispatcher]() {
        let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);
        if (dispatcher) {
          return dispatcher;
        }
        if (!this[kConnections] || this[kClients].length < this[kConnections]) {
          dispatcher = this[kFactory](this[kUrl], this[kOptions]);
          this[kAddClient](dispatcher);
        }
        return dispatcher;
      }
    };
    module.exports = Pool;
  }
});

// node_modules/undici/lib/balanced-pool.js
var require_balanced_pool = __commonJS({
  "node_modules/undici/lib/balanced-pool.js"(exports, module) {
    "use strict";
    var {
      BalancedPoolMissingUpstreamError,
      InvalidArgumentError
    } = require_errors();
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    } = require_pool_base();
    var Pool = require_pool();
    var { kUrl, kInterceptors } = require_symbols();
    var { parseOrigin } = require_util();
    var kFactory = /* @__PURE__ */ Symbol("factory");
    var kOptions = /* @__PURE__ */ Symbol("options");
    var kGreatestCommonDivisor = /* @__PURE__ */ Symbol("kGreatestCommonDivisor");
    var kCurrentWeight = /* @__PURE__ */ Symbol("kCurrentWeight");
    var kIndex = /* @__PURE__ */ Symbol("kIndex");
    var kWeight = /* @__PURE__ */ Symbol("kWeight");
    var kMaxWeightPerServer = /* @__PURE__ */ Symbol("kMaxWeightPerServer");
    var kErrorPenalty = /* @__PURE__ */ Symbol("kErrorPenalty");
    function getGreatestCommonDivisor(a, b) {
      if (b === 0) return a;
      return getGreatestCommonDivisor(b, a % b);
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var BalancedPool = class extends PoolBase {
      constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
        super();
        this[kOptions] = opts;
        this[kIndex] = -1;
        this[kCurrentWeight] = 0;
        this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
        this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
        if (!Array.isArray(upstreams)) {
          upstreams = [upstreams];
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
        this[kFactory] = factory;
        for (const upstream of upstreams) {
          this.addUpstream(upstream);
        }
        this._updateBalancedPoolStats();
      }
      addUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {
          return this;
        }
        const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
        this[kAddClient](pool);
        pool.on("connect", () => {
          pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
        });
        pool.on("connectionError", () => {
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        });
        pool.on("disconnect", (...args) => {
          const err = args[2];
          if (err && err.code === "UND_ERR_SOCKET") {
            pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
            this._updateBalancedPoolStats();
          }
        });
        for (const client of this[kClients]) {
          client[kWeight] = this[kMaxWeightPerServer];
        }
        this._updateBalancedPoolStats();
        return this;
      }
      _updateBalancedPoolStats() {
        this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
      }
      removeUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
        if (pool) {
          this[kRemoveClient](pool);
        }
        return this;
      }
      get upstreams() {
        return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
      }
      [kGetDispatcher]() {
        if (this[kClients].length === 0) {
          throw new BalancedPoolMissingUpstreamError();
        }
        const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
        if (!dispatcher) {
          return;
        }
        const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true);
        if (allClientsBusy) {
          return;
        }
        let counter = 0;
        let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
        while (counter++ < this[kClients].length) {
          this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
          const pool = this[kClients][this[kIndex]];
          if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
            maxWeightIndex = this[kIndex];
          }
          if (this[kIndex] === 0) {
            this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
            if (this[kCurrentWeight] <= 0) {
              this[kCurrentWeight] = this[kMaxWeightPerServer];
            }
          }
          if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
            return pool;
          }
        }
        this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
        this[kIndex] = maxWeightIndex;
        return this[kClients][maxWeightIndex];
      }
    };
    module.exports = BalancedPool;
  }
});

// node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS({
  "node_modules/undici/lib/compat/dispatcher-weakref.js"(exports, module) {
    "use strict";
    var { kConnected, kSize } = require_symbols();
    var CompatWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
      }
    };
    var CompatFinalizer = class {
      constructor(finalizer) {
        this.finalizer = finalizer;
      }
      register(dispatcher, key) {
        if (dispatcher.on) {
          dispatcher.on("disconnect", () => {
            if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
              this.finalizer(key);
            }
          });
        }
      }
    };
    module.exports = function() {
      if (process.env.NODE_V8_COVERAGE) {
        return {
          WeakRef: CompatWeakRef,
          FinalizationRegistry: CompatFinalizer
        };
      }
      return {
        WeakRef: global.WeakRef || CompatWeakRef,
        FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
      };
    };
  }
});

// node_modules/undici/lib/agent.js
var require_agent = __commonJS({
  "node_modules/undici/lib/agent.js"(exports, module) {
    "use strict";
    var { InvalidArgumentError } = require_errors();
    var { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols();
    var DispatcherBase = require_dispatcher_base();
    var Pool = require_pool();
    var Client2 = require_client();
    var util = require_util();
    var createRedirectInterceptor = require_redirectInterceptor();
    var { WeakRef: WeakRef2, FinalizationRegistry } = require_dispatcher_weakref()();
    var kOnConnect = /* @__PURE__ */ Symbol("onConnect");
    var kOnDisconnect = /* @__PURE__ */ Symbol("onDisconnect");
    var kOnConnectionError = /* @__PURE__ */ Symbol("onConnectionError");
    var kMaxRedirections = /* @__PURE__ */ Symbol("maxRedirections");
    var kOnDrain = /* @__PURE__ */ Symbol("onDrain");
    var kFactory = /* @__PURE__ */ Symbol("factory");
    var kFinalizer = /* @__PURE__ */ Symbol("finalizer");
    var kOptions = /* @__PURE__ */ Symbol("options");
    function defaultFactory(origin, opts) {
      return opts && opts.connections === 1 ? new Client2(origin, opts) : new Pool(origin, opts);
    }
    var Agent2 = class extends DispatcherBase {
      constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
        super();
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (connect && typeof connect !== "function") {
          connect = { ...connect };
        }
        this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })];
        this[kOptions] = { ...util.deepClone(options), connect };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kMaxRedirections] = maxRedirections;
        this[kFactory] = factory;
        this[kClients] = /* @__PURE__ */ new Map();
        this[kFinalizer] = new FinalizationRegistry(
          /* istanbul ignore next: gc is undeterministic */
          (key) => {
            const ref = this[kClients].get(key);
            if (ref !== void 0 && ref.deref() === void 0) {
              this[kClients].delete(key);
            }
          }
        );
        const agent = this;
        this[kOnDrain] = (origin, targets) => {
          agent.emit("drain", origin, [agent, ...targets]);
        };
        this[kOnConnect] = (origin, targets) => {
          agent.emit("connect", origin, [agent, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          agent.emit("disconnect", origin, [agent, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          agent.emit("connectionError", origin, [agent, ...targets], err);
        };
      }
      get [kRunning]() {
        let ret = 0;
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            ret += client[kRunning];
          }
        }
        return ret;
      }
      [kDispatch](opts, handler) {
        let key;
        if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
          key = String(opts.origin);
        } else {
          throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
        }
        const ref = this[kClients].get(key);
        let dispatcher = ref ? ref.deref() : null;
        if (!dispatcher) {
          dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
          this[kClients].set(key, new WeakRef2(dispatcher));
          this[kFinalizer].register(dispatcher, key);
        }
        return dispatcher.dispatch(opts, handler);
      }
      async [kClose]() {
        const closePromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            closePromises.push(client.close());
          }
        }
        await Promise.all(closePromises);
      }
      async [kDestroy](err) {
        const destroyPromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            destroyPromises.push(client.destroy(err));
          }
        }
        await Promise.all(destroyPromises);
      }
    };
    module.exports = Agent2;
  }
});

// node_modules/undici/lib/api/readable.js
var require_readable = __commonJS({
  "node_modules/undici/lib/api/readable.js"(exports, module) {
    "use strict";
    var assert = __require("assert");
    var { Readable } = __require("stream");
    var { RequestAbortedError, NotSupportedError, InvalidArgumentError } = require_errors();
    var util = require_util();
    var { ReadableStreamFrom, toUSVString } = require_util();
    var Blob2;
    var kConsume = /* @__PURE__ */ Symbol("kConsume");
    var kReading = /* @__PURE__ */ Symbol("kReading");
    var kBody = /* @__PURE__ */ Symbol("kBody");
    var kAbort = /* @__PURE__ */ Symbol("abort");
    var kContentType = /* @__PURE__ */ Symbol("kContentType");
    var noop = () => {
    };
    module.exports = class BodyReadable extends Readable {
      constructor({
        resume,
        abort,
        contentType = "",
        highWaterMark = 64 * 1024
        // Same as nodejs fs streams.
      }) {
        super({
          autoDestroy: true,
          read: resume,
          highWaterMark
        });
        this._readableState.dataEmitted = false;
        this[kAbort] = abort;
        this[kConsume] = null;
        this[kBody] = null;
        this[kContentType] = contentType;
        this[kReading] = false;
      }
      destroy(err) {
        if (this.destroyed) {
          return this;
        }
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        if (err) {
          this[kAbort]();
        }
        return super.destroy(err);
      }
      emit(ev, ...args) {
        if (ev === "data") {
          this._readableState.dataEmitted = true;
        } else if (ev === "error") {
          this._readableState.errorEmitted = true;
        }
        return super.emit(ev, ...args);
      }
      on(ev, ...args) {
        if (ev === "data" || ev === "readable") {
          this[kReading] = true;
        }
        return super.on(ev, ...args);
      }
      addListener(ev, ...args) {
        return this.on(ev, ...args);
      }
      off(ev, ...args) {
        const ret = super.off(ev, ...args);
        if (ev === "data" || ev === "readable") {
          this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
        }
        return ret;
      }
      removeListener(ev, ...args) {
        return this.off(ev, ...args);
      }
      push(chunk) {
        if (this[kConsume] && chunk !== null && this.readableLength === 0) {
          consumePush(this[kConsume], chunk);
          return this[kReading] ? super.push(chunk) : true;
        }
        return super.push(chunk);
      }
      // https://fetch.spec.whatwg.org/#dom-body-text
      async text() {
        return consume(this, "text");
      }
      // https://fetch.spec.whatwg.org/#dom-body-json
      async json() {
        return consume(this, "json");
      }
      // https://fetch.spec.whatwg.org/#dom-body-blob
      async blob() {
        return consume(this, "blob");
      }
      // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
      async arrayBuffer() {
        return consume(this, "arrayBuffer");
      }
      // https://fetch.spec.whatwg.org/#dom-body-formdata
      async formData() {
        throw new NotSupportedError();
      }
      // https://fetch.spec.whatwg.org/#dom-body-bodyused
      get bodyUsed() {
        return util.isDisturbed(this);
      }
      // https://fetch.spec.whatwg.org/#dom-body-body
      get body() {
        if (!this[kBody]) {
          this[kBody] = ReadableStreamFrom(this);
          if (this[kConsume]) {
            this[kBody].getReader();
            assert(this[kBody].locked);
          }
        }
        return this[kBody];
      }
      dump(opts) {
        let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
        const signal = opts && opts.signal;
        if (signal) {
          try {
            if (typeof signal !== "object" || !("aborted" in signal)) {
              throw new InvalidArgumentError("signal must be an AbortSignal");
            }
            util.throwIfAborted(signal);
          } catch (err) {
            return Promise.reject(err);
          }
        }
        if (this.closed) {
          return Promise.resolve(null);
        }
        return new Promise((resolve5, reject) => {
          const signalListenerCleanup = signal ? util.addAbortListener(signal, () => {
            this.destroy();
          }) : noop;
          this.on("close", function() {
            signalListenerCleanup();
            if (signal && signal.aborted) {
              reject(signal.reason || Object.assign(new Error("The operation was aborted"), { name: "AbortError" }));
            } else {
              resolve5(null);
            }
          }).on("error", noop).on("data", function(chunk) {
            limit -= chunk.length;
            if (limit <= 0) {
              this.destroy();
            }
          }).resume();
        });
      }
    };
    function isLocked(self) {
      return self[kBody] && self[kBody].locked === true || self[kConsume];
    }
    function isUnusable(self) {
      return util.isDisturbed(self) || isLocked(self);
    }
    async function consume(stream, type) {
      if (isUnusable(stream)) {
        throw new TypeError("unusable");
      }
      assert(!stream[kConsume]);
      return new Promise((resolve5, reject) => {
        stream[kConsume] = {
          type,
          stream,
          resolve: resolve5,
          reject,
          length: 0,
          body: []
        };
        stream.on("error", function(err) {
          consumeFinish(this[kConsume], err);
        }).on("close", function() {
          if (this[kConsume].body !== null) {
            consumeFinish(this[kConsume], new RequestAbortedError());
          }
        });
        process.nextTick(consumeStart, stream[kConsume]);
      });
    }
    function consumeStart(consume2) {
      if (consume2.body === null) {
        return;
      }
      const { _readableState: state } = consume2.stream;
      for (const chunk of state.buffer) {
        consumePush(consume2, chunk);
      }
      if (state.endEmitted) {
        consumeEnd(this[kConsume]);
      } else {
        consume2.stream.on("end", function() {
          consumeEnd(this[kConsume]);
        });
      }
      consume2.stream.resume();
      while (consume2.stream.read() != null) {
      }
    }
    function consumeEnd(consume2) {
      const { type, body, resolve: resolve5, stream, length } = consume2;
      try {
        if (type === "text") {
          resolve5(toUSVString(Buffer.concat(body)));
        } else if (type === "json") {
          resolve5(JSON.parse(Buffer.concat(body)));
        } else if (type === "arrayBuffer") {
          const dst = new Uint8Array(length);
          let pos = 0;
          for (const buf of body) {
            dst.set(buf, pos);
            pos += buf.byteLength;
          }
          resolve5(dst.buffer);
        } else if (type === "blob") {
          if (!Blob2) {
            Blob2 = __require("buffer").Blob;
          }
          resolve5(new Blob2(body, { type: stream[kContentType] }));
        }
        consumeFinish(consume2);
      } catch (err) {
        stream.destroy(err);
      }
    }
    function consumePush(consume2, chunk) {
      consume2.length += chunk.length;
      consume2.body.push(chunk);
    }
    function consumeFinish(consume2, err) {
      if (consume2.body === null) {
        return;
      }
      if (err) {
        consume2.reject(err);
      } else {
        consume2.resolve();
      }
      consume2.type = null;
      consume2.stream = null;
      consume2.resolve = null;
      consume2.reject = null;
      consume2.length = 0;
      consume2.body = null;
    }
  }
});

// node_modules/undici/lib/api/util.js
var require_util3 = __commonJS({
  "node_modules/undici/lib/api/util.js"(exports, module) {
    "use strict";
    var assert = __require("assert");
    var {
      ResponseStatusCodeError
    } = require_errors();
    var { toUSVString } = require_util();
    async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
      assert(body);
      let chunks = [];
      let limit = 0;
      for await (const chunk of body) {
        chunks.push(chunk);
        limit += chunk.length;
        if (limit > 128 * 1024) {
          chunks = null;
          break;
        }
      }
      if (statusCode === 204 || !contentType || !chunks) {
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
        return;
      }
      try {
        if (contentType.startsWith("application/json")) {
          const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
          return;
        }
        if (contentType.startsWith("text/")) {
          const payload = toUSVString(Buffer.concat(chunks));
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
          return;
        }
      } catch (err) {
      }
      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
    }
    module.exports = { getResolveErrorBodyCallback };
  }
});

// node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS({
  "node_modules/undici/lib/api/abort-signal.js"(exports, module) {
    "use strict";
    var { addAbortListener } = require_util();
    var { RequestAbortedError } = require_errors();
    var kListener = /* @__PURE__ */ Symbol("kListener");
    var kSignal = /* @__PURE__ */ Symbol("kSignal");
    function abort(self) {
      if (self.abort) {
        self.abort();
      } else {
        self.onError(new RequestAbortedError());
      }
    }
    function addSignal(self, signal) {
      self[kSignal] = null;
      self[kListener] = null;
      if (!signal) {
        return;
      }
      if (signal.aborted) {
        abort(self);
        return;
      }
      self[kSignal] = signal;
      self[kListener] = () => {
        abort(self);
      };
      addAbortListener(self[kSignal], self[kListener]);
    }
    function removeSignal(self) {
      if (!self[kSignal]) {
        return;
      }
      if ("removeEventListener" in self[kSignal]) {
        self[kSignal].removeEventListener("abort", self[kListener]);
      } else {
        self[kSignal].removeListener("abort", self[kListener]);
      }
      self[kSignal] = null;
      self[kListener] = null;
    }
    module.exports = {
      addSignal,
      removeSignal
    };
  }
});

// node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS({
  "node_modules/undici/lib/api/api-request.js"(exports, module) {
    "use strict";
    var Readable = require_readable();
    var {
      InvalidArgumentError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { getResolveErrorBodyCallback } = require_util3();
    var { AsyncResource } = __require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var RequestHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
            throw new InvalidArgumentError("invalid highWaterMark");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_REQUEST");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", util.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.body = body;
        this.trailers = {};
        this.context = null;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError;
        this.highWaterMark = highWaterMark;
        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context2) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context2;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { callback, opaque, abort, context: context2, responseHeaders, highWaterMark } = this;
        const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
        const contentType = parsedHeaders["content-type"];
        const body = new Readable({ resume, abort, contentType, highWaterMark });
        this.callback = null;
        this.res = body;
        if (callback !== null) {
          if (this.throwOnError && statusCode >= 400) {
            this.runInAsyncScope(
              getResolveErrorBodyCallback,
              null,
              { callback, body, contentType, statusCode, statusMessage, headers }
            );
          } else {
            this.runInAsyncScope(callback, null, null, {
              statusCode,
              headers,
              trailers: this.trailers,
              opaque,
              body,
              context: context2
            });
          }
        }
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        util.parseHeaders(trailers, this.trailers);
        res.push(null);
      }
      onError(err) {
        const { res, callback, body, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (res) {
          this.res = null;
          queueMicrotask(() => {
            util.destroy(res, err);
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    };
    function request(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve5, reject) => {
          request.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve5(data);
          });
        });
      }
      try {
        this.dispatch(opts, new RequestHandler(opts, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module.exports = request;
    module.exports.RequestHandler = RequestHandler;
  }
});

// node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS({
  "node_modules/undici/lib/api/api-stream.js"(exports, module) {
    "use strict";
    var { finished, PassThrough } = __require("stream");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { getResolveErrorBodyCallback } = require_util3();
    var { AsyncResource } = __require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var StreamHandler = class extends AsyncResource {
      constructor(opts, factory, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (typeof factory !== "function") {
            throw new InvalidArgumentError("invalid factory");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_STREAM");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", util.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.factory = factory;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.context = null;
        this.trailers = null;
        this.body = body;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError || false;
        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context2) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context2;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { factory, opaque, context: context2, callback, responseHeaders } = this;
        const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.factory = null;
        let res;
        if (this.throwOnError && statusCode >= 400) {
          const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
          const contentType = parsedHeaders["content-type"];
          res = new PassThrough();
          this.callback = null;
          this.runInAsyncScope(
            getResolveErrorBodyCallback,
            null,
            { callback, body: res, contentType, statusCode, statusMessage, headers }
          );
        } else {
          if (factory === null) {
            return;
          }
          res = this.runInAsyncScope(factory, null, {
            statusCode,
            headers,
            opaque,
            context: context2
          });
          if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
            throw new InvalidReturnValueError("expected Writable");
          }
          finished(res, { readable: false }, (err) => {
            const { callback: callback2, res: res2, opaque: opaque2, trailers, abort } = this;
            this.res = null;
            if (err || !res2.readable) {
              util.destroy(res2, err);
            }
            this.callback = null;
            this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers });
            if (err) {
              abort();
            }
          });
        }
        res.on("drain", resume);
        this.res = res;
        const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
        return needDrain !== true;
      }
      onData(chunk) {
        const { res } = this;
        return res ? res.write(chunk) : true;
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        if (!res) {
          return;
        }
        this.trailers = util.parseHeaders(trailers);
        res.end();
      }
      onError(err) {
        const { res, callback, opaque, body } = this;
        removeSignal(this);
        this.factory = null;
        if (res) {
          this.res = null;
          util.destroy(res, err);
        } else if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    };
    function stream(opts, factory, callback) {
      if (callback === void 0) {
        return new Promise((resolve5, reject) => {
          stream.call(this, opts, factory, (err, data) => {
            return err ? reject(err) : resolve5(data);
          });
        });
      }
      try {
        this.dispatch(opts, new StreamHandler(opts, factory, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module.exports = stream;
  }
});

// node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS({
  "node_modules/undici/lib/api/api-pipeline.js"(exports, module) {
    "use strict";
    var {
      Readable,
      Duplex,
      PassThrough
    } = __require("stream");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { AsyncResource } = __require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var assert = __require("assert");
    var kResume = /* @__PURE__ */ Symbol("resume");
    var PipelineRequest = class extends Readable {
      constructor() {
        super({ autoDestroy: true });
        this[kResume] = null;
      }
      _read() {
        const { [kResume]: resume } = this;
        if (resume) {
          this[kResume] = null;
          resume();
        }
      }
      _destroy(err, callback) {
        this._read();
        callback(err);
      }
    };
    var PipelineResponse = class extends Readable {
      constructor(resume) {
        super({ autoDestroy: true });
        this[kResume] = resume;
      }
      _read() {
        this[kResume]();
      }
      _destroy(err, callback) {
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        callback(err);
      }
    };
    var PipelineHandler = class extends AsyncResource {
      constructor(opts, handler) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof handler !== "function") {
          throw new InvalidArgumentError("invalid handler");
        }
        const { signal, method, opaque, onInfo, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_PIPELINE");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.handler = handler;
        this.abort = null;
        this.context = null;
        this.onInfo = onInfo || null;
        this.req = new PipelineRequest().on("error", util.nop);
        this.ret = new Duplex({
          readableObjectMode: opts.objectMode,
          autoDestroy: true,
          read: () => {
            const { body } = this;
            if (body && body.resume) {
              body.resume();
            }
          },
          write: (chunk, encoding, callback) => {
            const { req } = this;
            if (req.push(chunk, encoding) || req._readableState.destroyed) {
              callback();
            } else {
              req[kResume] = callback;
            }
          },
          destroy: (err, callback) => {
            const { body, req, res, ret, abort } = this;
            if (!err && !ret._readableState.endEmitted) {
              err = new RequestAbortedError();
            }
            if (abort && err) {
              abort();
            }
            util.destroy(body, err);
            util.destroy(req, err);
            util.destroy(res, err);
            removeSignal(this);
            callback(err);
          }
        }).on("prefinish", () => {
          const { req } = this;
          req.push(null);
        });
        this.res = null;
        addSignal(this, signal);
      }
      onConnect(abort, context2) {
        const { ret, res } = this;
        assert(!res, "pipeline cannot be retried");
        if (ret.destroyed) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context2;
      }
      onHeaders(statusCode, rawHeaders, resume) {
        const { opaque, handler, context: context2 } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.res = new PipelineResponse(resume);
        let body;
        try {
          this.handler = null;
          const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          body = this.runInAsyncScope(handler, null, {
            statusCode,
            headers,
            opaque,
            body: this.res,
            context: context2
          });
        } catch (err) {
          this.res.on("error", util.nop);
          throw err;
        }
        if (!body || typeof body.on !== "function") {
          throw new InvalidReturnValueError("expected Readable");
        }
        body.on("data", (chunk) => {
          const { ret, body: body2 } = this;
          if (!ret.push(chunk) && body2.pause) {
            body2.pause();
          }
        }).on("error", (err) => {
          const { ret } = this;
          util.destroy(ret, err);
        }).on("end", () => {
          const { ret } = this;
          ret.push(null);
        }).on("close", () => {
          const { ret } = this;
          if (!ret._readableState.ended) {
            util.destroy(ret, new RequestAbortedError());
          }
        });
        this.body = body;
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        res.push(null);
      }
      onError(err) {
        const { ret } = this;
        this.handler = null;
        util.destroy(ret, err);
      }
    };
    function pipeline(opts, handler) {
      try {
        const pipelineHandler = new PipelineHandler(opts, handler);
        this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
        return pipelineHandler.ret;
      } catch (err) {
        return new PassThrough().destroy(err);
      }
    }
    module.exports = pipeline;
  }
});

// node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS({
  "node_modules/undici/lib/api/api-upgrade.js"(exports, module) {
    "use strict";
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
    var { AsyncResource } = __require("async_hooks");
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var assert = __require("assert");
    var UpgradeHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_UPGRADE");
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.abort = null;
        this.context = null;
        addSignal(this, signal);
      }
      onConnect(abort, context2) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = null;
      }
      onHeaders() {
        throw new SocketError("bad upgrade", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context: context2 } = this;
        assert.strictEqual(statusCode, 101);
        removeSignal(this);
        this.callback = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        this.runInAsyncScope(callback, null, null, {
          headers,
          socket,
          opaque,
          context: context2
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function upgrade(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve5, reject) => {
          upgrade.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve5(data);
          });
        });
      }
      try {
        const upgradeHandler = new UpgradeHandler(opts, callback);
        this.dispatch({
          ...opts,
          method: opts.method || "GET",
          upgrade: opts.protocol || "Websocket"
        }, upgradeHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module.exports = upgrade;
  }
});

// node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS({
  "node_modules/undici/lib/api/api-connect.js"(exports, module) {
    "use strict";
    var { AsyncResource } = __require("async_hooks");
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var ConnectHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_CONNECT");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.callback = callback;
        this.abort = null;
        addSignal(this, signal);
      }
      onConnect(abort, context2) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context2;
      }
      onHeaders() {
        throw new SocketError("bad connect", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context: context2 } = this;
        removeSignal(this);
        this.callback = null;
        let headers = rawHeaders;
        if (headers != null) {
          headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        }
        this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers,
          socket,
          opaque,
          context: context2
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function connect(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve5, reject) => {
          connect.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve5(data);
          });
        });
      }
      try {
        const connectHandler = new ConnectHandler(opts, callback);
        this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module.exports = connect;
  }
});

// node_modules/undici/lib/api/index.js
var require_api = __commonJS({
  "node_modules/undici/lib/api/index.js"(exports, module) {
    "use strict";
    module.exports.request = require_api_request();
    module.exports.stream = require_api_stream();
    module.exports.pipeline = require_api_pipeline();
    module.exports.upgrade = require_api_upgrade();
    module.exports.connect = require_api_connect();
  }
});

// node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS({
  "node_modules/undici/lib/mock/mock-errors.js"(exports, module) {
    "use strict";
    var { UndiciError } = require_errors();
    var MockNotMatchedError = class _MockNotMatchedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _MockNotMatchedError);
        this.name = "MockNotMatchedError";
        this.message = message || "The request does not match any registered mock dispatches";
        this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
      }
    };
    module.exports = {
      MockNotMatchedError
    };
  }
});

// node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS({
  "node_modules/undici/lib/mock/mock-symbols.js"(exports, module) {
    "use strict";
    module.exports = {
      kAgent: /* @__PURE__ */ Symbol("agent"),
      kOptions: /* @__PURE__ */ Symbol("options"),
      kFactory: /* @__PURE__ */ Symbol("factory"),
      kDispatches: /* @__PURE__ */ Symbol("dispatches"),
      kDispatchKey: /* @__PURE__ */ Symbol("dispatch key"),
      kDefaultHeaders: /* @__PURE__ */ Symbol("default headers"),
      kDefaultTrailers: /* @__PURE__ */ Symbol("default trailers"),
      kContentLength: /* @__PURE__ */ Symbol("content length"),
      kMockAgent: /* @__PURE__ */ Symbol("mock agent"),
      kMockAgentSet: /* @__PURE__ */ Symbol("mock agent set"),
      kMockAgentGet: /* @__PURE__ */ Symbol("mock agent get"),
      kMockDispatch: /* @__PURE__ */ Symbol("mock dispatch"),
      kClose: /* @__PURE__ */ Symbol("close"),
      kOriginalClose: /* @__PURE__ */ Symbol("original agent close"),
      kOrigin: /* @__PURE__ */ Symbol("origin"),
      kIsMockActive: /* @__PURE__ */ Symbol("is mock active"),
      kNetConnect: /* @__PURE__ */ Symbol("net connect"),
      kGetNetConnect: /* @__PURE__ */ Symbol("get net connect"),
      kConnected: /* @__PURE__ */ Symbol("connected")
    };
  }
});

// node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS({
  "node_modules/undici/lib/mock/mock-utils.js"(exports, module) {
    "use strict";
    var { MockNotMatchedError } = require_mock_errors();
    var {
      kDispatches,
      kMockAgent,
      kOriginalDispatch,
      kOrigin,
      kGetNetConnect
    } = require_mock_symbols();
    var { buildURL, nop } = require_util();
    var { STATUS_CODES } = __require("http");
    var {
      types: {
        isPromise
      }
    } = __require("util");
    function matchValue(match, value) {
      if (typeof match === "string") {
        return match === value;
      }
      if (match instanceof RegExp) {
        return match.test(value);
      }
      if (typeof match === "function") {
        return match(value) === true;
      }
      return false;
    }
    function lowerCaseEntries(headers) {
      return Object.fromEntries(
        Object.entries(headers).map(([headerName, headerValue]) => {
          return [headerName.toLocaleLowerCase(), headerValue];
        })
      );
    }
    function getHeaderByName(headers, key) {
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
            return headers[i + 1];
          }
        }
        return void 0;
      } else if (typeof headers.get === "function") {
        return headers.get(key);
      } else {
        return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
      }
    }
    function buildHeadersFromArray(headers) {
      const clone = headers.slice();
      const entries = [];
      for (let index = 0; index < clone.length; index += 2) {
        entries.push([clone[index], clone[index + 1]]);
      }
      return Object.fromEntries(entries);
    }
    function matchHeaders(mockDispatch2, headers) {
      if (typeof mockDispatch2.headers === "function") {
        if (Array.isArray(headers)) {
          headers = buildHeadersFromArray(headers);
        }
        return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
      }
      if (typeof mockDispatch2.headers === "undefined") {
        return true;
      }
      if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
        return false;
      }
      for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
        const headerValue = getHeaderByName(headers, matchHeaderName);
        if (!matchValue(matchHeaderValue, headerValue)) {
          return false;
        }
      }
      return true;
    }
    function safeUrl(path12) {
      if (typeof path12 !== "string") {
        return path12;
      }
      const pathSegments = path12.split("?");
      if (pathSegments.length !== 2) {
        return path12;
      }
      const qp = new URLSearchParams(pathSegments.pop());
      qp.sort();
      return [...pathSegments, qp.toString()].join("?");
    }
    function matchKey(mockDispatch2, { path: path12, method, body, headers }) {
      const pathMatch = matchValue(mockDispatch2.path, path12);
      const methodMatch = matchValue(mockDispatch2.method, method);
      const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
      const headersMatch = matchHeaders(mockDispatch2, headers);
      return pathMatch && methodMatch && bodyMatch && headersMatch;
    }
    function getResponseData(data) {
      if (Buffer.isBuffer(data)) {
        return data;
      } else if (typeof data === "object") {
        return JSON.stringify(data);
      } else {
        return data.toString();
      }
    }
    function getMockDispatch(mockDispatches, key) {
      const basePath = key.query ? buildURL(key.path, key.query) : key.path;
      const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
      let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path: path12 }) => matchValue(safeUrl(path12), resolvedPath));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
      }
      return matchedMockDispatches[0];
    }
    function addMockDispatch(mockDispatches, key, data) {
      const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
      const replyData = typeof data === "function" ? { callback: data } : { ...data };
      const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
      mockDispatches.push(newMockDispatch);
      return newMockDispatch;
    }
    function deleteMockDispatch(mockDispatches, key) {
      const index = mockDispatches.findIndex((dispatch) => {
        if (!dispatch.consumed) {
          return false;
        }
        return matchKey(dispatch, key);
      });
      if (index !== -1) {
        mockDispatches.splice(index, 1);
      }
    }
    function buildKey(opts) {
      const { path: path12, method, body, headers, query } = opts;
      return {
        path: path12,
        method,
        body,
        headers,
        query
      };
    }
    function generateKeyValues(data) {
      return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
        ...keyValuePairs,
        Buffer.from(`${key}`),
        Array.isArray(value) ? value.map((x) => Buffer.from(`${x}`)) : Buffer.from(`${value}`)
      ], []);
    }
    function getStatusText(statusCode) {
      return STATUS_CODES[statusCode] || "unknown";
    }
    async function getResponse(body) {
      const buffers = [];
      for await (const data of body) {
        buffers.push(data);
      }
      return Buffer.concat(buffers).toString("utf8");
    }
    function mockDispatch(opts, handler) {
      const key = buildKey(opts);
      const mockDispatch2 = getMockDispatch(this[kDispatches], key);
      mockDispatch2.timesInvoked++;
      if (mockDispatch2.data.callback) {
        mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
      }
      const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch2;
      const { timesInvoked, times } = mockDispatch2;
      mockDispatch2.consumed = !persist && timesInvoked >= times;
      mockDispatch2.pending = timesInvoked < times;
      if (error !== null) {
        deleteMockDispatch(this[kDispatches], key);
        handler.onError(error);
        return true;
      }
      if (typeof delay === "number" && delay > 0) {
        setTimeout(() => {
          handleReply(this[kDispatches]);
        }, delay);
      } else {
        handleReply(this[kDispatches]);
      }
      function handleReply(mockDispatches, _data = data) {
        const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
        const body = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
        if (isPromise(body)) {
          body.then((newData) => handleReply(mockDispatches, newData));
          return;
        }
        const responseData = getResponseData(body);
        const responseHeaders = generateKeyValues(headers);
        const responseTrailers = generateKeyValues(trailers);
        handler.abort = nop;
        handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));
        handler.onData(Buffer.from(responseData));
        handler.onComplete(responseTrailers);
        deleteMockDispatch(mockDispatches, key);
      }
      function resume() {
      }
      return true;
    }
    function buildMockDispatch() {
      const agent = this[kMockAgent];
      const origin = this[kOrigin];
      const originalDispatch = this[kOriginalDispatch];
      return function dispatch(opts, handler) {
        if (agent.isMockActive) {
          try {
            mockDispatch.call(this, opts, handler);
          } catch (error) {
            if (error instanceof MockNotMatchedError) {
              const netConnect = agent[kGetNetConnect]();
              if (netConnect === false) {
                throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
              }
              if (checkNetConnect(netConnect, origin)) {
                originalDispatch.call(this, opts, handler);
              } else {
                throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
              }
            } else {
              throw error;
            }
          }
        } else {
          originalDispatch.call(this, opts, handler);
        }
      };
    }
    function checkNetConnect(netConnect, origin) {
      const url = new URL(origin);
      if (netConnect === true) {
        return true;
      } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
        return true;
      }
      return false;
    }
    function buildMockOptions(opts) {
      if (opts) {
        const { agent, ...mockOptions } = opts;
        return mockOptions;
      }
    }
    module.exports = {
      getResponseData,
      getMockDispatch,
      addMockDispatch,
      deleteMockDispatch,
      buildKey,
      generateKeyValues,
      matchValue,
      getResponse,
      getStatusText,
      mockDispatch,
      buildMockDispatch,
      checkNetConnect,
      buildMockOptions,
      getHeaderByName
    };
  }
});

// node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS({
  "node_modules/undici/lib/mock/mock-interceptor.js"(exports, module) {
    "use strict";
    var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kDispatchKey,
      kDefaultHeaders,
      kDefaultTrailers,
      kContentLength,
      kMockDispatch
    } = require_mock_symbols();
    var { InvalidArgumentError } = require_errors();
    var { buildURL } = require_util();
    var MockScope = class {
      constructor(mockDispatch) {
        this[kMockDispatch] = mockDispatch;
      }
      /**
       * Delay a reply by a set amount in ms.
       */
      delay(waitInMs) {
        if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
          throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
        }
        this[kMockDispatch].delay = waitInMs;
        return this;
      }
      /**
       * For a defined reply, never mark as consumed.
       */
      persist() {
        this[kMockDispatch].persist = true;
        return this;
      }
      /**
       * Allow one to define a reply for a set amount of matching requests.
       */
      times(repeatTimes) {
        if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
          throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
        }
        this[kMockDispatch].times = repeatTimes;
        return this;
      }
    };
    var MockInterceptor = class {
      constructor(opts, mockDispatches) {
        if (typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object");
        }
        if (typeof opts.path === "undefined") {
          throw new InvalidArgumentError("opts.path must be defined");
        }
        if (typeof opts.method === "undefined") {
          opts.method = "GET";
        }
        if (typeof opts.path === "string") {
          if (opts.query) {
            opts.path = buildURL(opts.path, opts.query);
          } else {
            const parsedURL = new URL(opts.path, "data://");
            opts.path = parsedURL.pathname + parsedURL.search;
          }
        }
        if (typeof opts.method === "string") {
          opts.method = opts.method.toUpperCase();
        }
        this[kDispatchKey] = buildKey(opts);
        this[kDispatches] = mockDispatches;
        this[kDefaultHeaders] = {};
        this[kDefaultTrailers] = {};
        this[kContentLength] = false;
      }
      createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
        const responseData = getResponseData(data);
        const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
        const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
        const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
        return { statusCode, data, headers, trailers };
      }
      validateReplyParameters(statusCode, data, responseOptions) {
        if (typeof statusCode === "undefined") {
          throw new InvalidArgumentError("statusCode must be defined");
        }
        if (typeof data === "undefined") {
          throw new InvalidArgumentError("data must be defined");
        }
        if (typeof responseOptions !== "object") {
          throw new InvalidArgumentError("responseOptions must be an object");
        }
      }
      /**
       * Mock an undici request with a defined reply.
       */
      reply(replyData) {
        if (typeof replyData === "function") {
          const wrappedDefaultsCallback = (opts) => {
            const resolvedData = replyData(opts);
            if (typeof resolvedData !== "object") {
              throw new InvalidArgumentError("reply options callback must return an object");
            }
            const { statusCode: statusCode2, data: data2 = "", responseOptions: responseOptions2 = {} } = resolvedData;
            this.validateReplyParameters(statusCode2, data2, responseOptions2);
            return {
              ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)
            };
          };
          const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
          return new MockScope(newMockDispatch2);
        }
        const [statusCode, data = "", responseOptions = {}] = [...arguments];
        this.validateReplyParameters(statusCode, data, responseOptions);
        const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
        return new MockScope(newMockDispatch);
      }
      /**
       * Mock an undici request with a defined error.
       */
      replyWithError(error) {
        if (typeof error === "undefined") {
          throw new InvalidArgumentError("error must be defined");
        }
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error });
        return new MockScope(newMockDispatch);
      }
      /**
       * Set default reply headers on the interceptor for subsequent replies
       */
      defaultReplyHeaders(headers) {
        if (typeof headers === "undefined") {
          throw new InvalidArgumentError("headers must be defined");
        }
        this[kDefaultHeaders] = headers;
        return this;
      }
      /**
       * Set default reply trailers on the interceptor for subsequent replies
       */
      defaultReplyTrailers(trailers) {
        if (typeof trailers === "undefined") {
          throw new InvalidArgumentError("trailers must be defined");
        }
        this[kDefaultTrailers] = trailers;
        return this;
      }
      /**
       * Set reply content length header for replies on the interceptor
       */
      replyContentLength() {
        this[kContentLength] = true;
        return this;
      }
    };
    module.exports.MockInterceptor = MockInterceptor;
    module.exports.MockScope = MockScope;
  }
});

// node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS({
  "node_modules/undici/lib/mock/mock-client.js"(exports, module) {
    "use strict";
    var { promisify: promisify4 } = __require("util");
    var Client2 = require_client();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockClient = class extends Client2 {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify4(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module.exports = MockClient;
  }
});

// node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS({
  "node_modules/undici/lib/mock/mock-pool.js"(exports, module) {
    "use strict";
    var { promisify: promisify4 } = __require("util");
    var Pool = require_pool();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockPool = class extends Pool {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify4(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module.exports = MockPool;
  }
});

// node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = __commonJS({
  "node_modules/undici/lib/mock/pluralizer.js"(exports, module) {
    "use strict";
    var singulars = {
      pronoun: "it",
      is: "is",
      was: "was",
      this: "this"
    };
    var plurals = {
      pronoun: "they",
      is: "are",
      was: "were",
      this: "these"
    };
    module.exports = class Pluralizer {
      constructor(singular, plural) {
        this.singular = singular;
        this.plural = plural;
      }
      pluralize(count) {
        const one = count === 1;
        const keys = one ? singulars : plurals;
        const noun = one ? this.singular : this.plural;
        return { ...keys, count, noun };
      }
    };
  }
});

// node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS({
  "node_modules/undici/lib/mock/pending-interceptors-formatter.js"(exports, module) {
    "use strict";
    var { Transform } = __require("stream");
    var { Console } = __require("console");
    module.exports = class PendingInterceptorsFormatter {
      constructor({ disableColors } = {}) {
        this.transform = new Transform({
          transform(chunk, _enc, cb) {
            cb(null, chunk);
          }
        });
        this.logger = new Console({
          stdout: this.transform,
          inspectOptions: {
            colors: !disableColors && !process.env.CI
          }
        });
      }
      format(pendingInterceptors) {
        const withPrettyHeaders = pendingInterceptors.map(
          ({ method, path: path12, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
            Method: method,
            Origin: origin,
            Path: path12,
            "Status code": statusCode,
            Persistent: persist ? "\u2705" : "\u274C",
            Invocations: timesInvoked,
            Remaining: persist ? Infinity : times - timesInvoked
          })
        );
        this.logger.table(withPrettyHeaders);
        return this.transform.read().toString();
      }
    };
  }
});

// node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS({
  "node_modules/undici/lib/mock/mock-agent.js"(exports, module) {
    "use strict";
    var { kClients } = require_symbols();
    var Agent2 = require_agent();
    var {
      kAgent,
      kMockAgentSet,
      kMockAgentGet,
      kDispatches,
      kIsMockActive,
      kNetConnect,
      kGetNetConnect,
      kOptions,
      kFactory
    } = require_mock_symbols();
    var MockClient = require_mock_client();
    var MockPool = require_mock_pool();
    var { matchValue, buildMockOptions } = require_mock_utils();
    var { InvalidArgumentError, UndiciError } = require_errors();
    var Dispatcher = require_dispatcher();
    var Pluralizer = require_pluralizer();
    var PendingInterceptorsFormatter = require_pending_interceptors_formatter();
    var FakeWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value;
      }
    };
    var MockAgent = class extends Dispatcher {
      constructor(opts) {
        super(opts);
        this[kNetConnect] = true;
        this[kIsMockActive] = true;
        if (opts && opts.agent && typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        const agent = opts && opts.agent ? opts.agent : new Agent2(opts);
        this[kAgent] = agent;
        this[kClients] = agent[kClients];
        this[kOptions] = buildMockOptions(opts);
      }
      get(origin) {
        let dispatcher = this[kMockAgentGet](origin);
        if (!dispatcher) {
          dispatcher = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher);
        }
        return dispatcher;
      }
      dispatch(opts, handler) {
        this.get(opts.origin);
        return this[kAgent].dispatch(opts, handler);
      }
      async close() {
        await this[kAgent].close();
        this[kClients].clear();
      }
      deactivate() {
        this[kIsMockActive] = false;
      }
      activate() {
        this[kIsMockActive] = true;
      }
      enableNetConnect(matcher) {
        if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
          if (Array.isArray(this[kNetConnect])) {
            this[kNetConnect].push(matcher);
          } else {
            this[kNetConnect] = [matcher];
          }
        } else if (typeof matcher === "undefined") {
          this[kNetConnect] = true;
        } else {
          throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
        }
      }
      disableNetConnect() {
        this[kNetConnect] = false;
      }
      // This is required to bypass issues caused by using global symbols - see:
      // https://github.com/nodejs/undici/issues/1447
      get isMockActive() {
        return this[kIsMockActive];
      }
      [kMockAgentSet](origin, dispatcher) {
        this[kClients].set(origin, new FakeWeakRef(dispatcher));
      }
      [kFactory](origin) {
        const mockOptions = Object.assign({ agent: this }, this[kOptions]);
        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
      }
      [kMockAgentGet](origin) {
        const ref = this[kClients].get(origin);
        if (ref) {
          return ref.deref();
        }
        if (typeof origin !== "string") {
          const dispatcher = this[kFactory]("http://localhost:9999");
          this[kMockAgentSet](origin, dispatcher);
          return dispatcher;
        }
        for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
          const nonExplicitDispatcher = nonExplicitRef.deref();
          if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
            const dispatcher = this[kFactory](origin);
            this[kMockAgentSet](origin, dispatcher);
            dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
            return dispatcher;
          }
        }
      }
      [kGetNetConnect]() {
        return this[kNetConnect];
      }
      pendingInterceptors() {
        const mockAgentClients = this[kClients];
        return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
      }
      assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
        const pending = this.pendingInterceptors();
        if (pending.length === 0) {
          return;
        }
        const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
        throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
      }
    };
    module.exports = MockAgent;
  }
});

// node_modules/undici/lib/proxy-agent.js
var require_proxy_agent = __commonJS({
  "node_modules/undici/lib/proxy-agent.js"(exports, module) {
    "use strict";
    var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols();
    var { URL: URL2 } = __require("url");
    var Agent2 = require_agent();
    var Pool = require_pool();
    var DispatcherBase = require_dispatcher_base();
    var { InvalidArgumentError, RequestAbortedError } = require_errors();
    var buildConnector = require_connect();
    var kAgent = /* @__PURE__ */ Symbol("proxy agent");
    var kClient = /* @__PURE__ */ Symbol("proxy client");
    var kProxyHeaders = /* @__PURE__ */ Symbol("proxy headers");
    var kRequestTls = /* @__PURE__ */ Symbol("request tls settings");
    var kProxyTls = /* @__PURE__ */ Symbol("proxy tls settings");
    var kConnectEndpoint = /* @__PURE__ */ Symbol("connect endpoint function");
    function defaultProtocolPort(protocol) {
      return protocol === "https:" ? 443 : 80;
    }
    function buildProxyOptions(opts) {
      if (typeof opts === "string") {
        opts = { uri: opts };
      }
      if (!opts || !opts.uri) {
        throw new InvalidArgumentError("Proxy opts.uri is mandatory");
      }
      return {
        uri: opts.uri,
        protocol: opts.protocol || "https"
      };
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var ProxyAgent = class extends DispatcherBase {
      constructor(opts) {
        super(opts);
        this[kProxy] = buildProxyOptions(opts);
        this[kAgent] = new Agent2(opts);
        this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
        if (typeof opts === "string") {
          opts = { uri: opts };
        }
        if (!opts || !opts.uri) {
          throw new InvalidArgumentError("Proxy opts.uri is mandatory");
        }
        const { clientFactory = defaultFactory } = opts;
        if (typeof clientFactory !== "function") {
          throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
        }
        this[kRequestTls] = opts.requestTls;
        this[kProxyTls] = opts.proxyTls;
        this[kProxyHeaders] = opts.headers || {};
        const resolvedUrl = new URL2(opts.uri);
        const { origin, port, host, username, password } = resolvedUrl;
        if (opts.auth && opts.token) {
          throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
        } else if (opts.auth) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
        } else if (opts.token) {
          this[kProxyHeaders]["proxy-authorization"] = opts.token;
        } else if (username && password) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
        }
        const connect = buildConnector({ ...opts.proxyTls });
        this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
        this[kClient] = clientFactory(resolvedUrl, { connect });
        this[kAgent] = new Agent2({
          ...opts,
          connect: async (opts2, callback) => {
            let requestedHost = opts2.host;
            if (!opts2.port) {
              requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;
            }
            try {
              const { socket, statusCode } = await this[kClient].connect({
                origin,
                port,
                path: requestedHost,
                signal: opts2.signal,
                headers: {
                  ...this[kProxyHeaders],
                  host
                }
              });
              if (statusCode !== 200) {
                socket.on("error", () => {
                }).destroy();
                callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
              }
              if (opts2.protocol !== "https:") {
                callback(null, socket);
                return;
              }
              let servername;
              if (this[kRequestTls]) {
                servername = this[kRequestTls].servername;
              } else {
                servername = opts2.servername;
              }
              this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
            } catch (err) {
              callback(err);
            }
          }
        });
      }
      dispatch(opts, handler) {
        const { host } = new URL2(opts.origin);
        const headers = buildHeaders(opts.headers);
        throwIfProxyAuthIsSent(headers);
        return this[kAgent].dispatch(
          {
            ...opts,
            headers: {
              ...headers,
              host
            }
          },
          handler
        );
      }
      async [kClose]() {
        await this[kAgent].close();
        await this[kClient].close();
      }
      async [kDestroy]() {
        await this[kAgent].destroy();
        await this[kClient].destroy();
      }
    };
    function buildHeaders(headers) {
      if (Array.isArray(headers)) {
        const headersPair = {};
        for (let i = 0; i < headers.length; i += 2) {
          headersPair[headers[i]] = headers[i + 1];
        }
        return headersPair;
      }
      return headers;
    }
    function throwIfProxyAuthIsSent(headers) {
      const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
      if (existProxyAuth) {
        throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
      }
    }
    module.exports = ProxyAgent;
  }
});

// node_modules/undici/lib/handler/RetryHandler.js
var require_RetryHandler = __commonJS({
  "node_modules/undici/lib/handler/RetryHandler.js"(exports, module) {
    "use strict";
    var assert = __require("assert");
    var { kRetryHandlerDefaultRetry } = require_symbols();
    var { RequestRetryError } = require_errors();
    var { isDisturbed, parseHeaders, parseRangeHeader } = require_util();
    function calculateRetryAfterHeader(retryAfter) {
      const current = Date.now();
      const diff = new Date(retryAfter).getTime() - current;
      return diff;
    }
    var RetryHandler = class _RetryHandler {
      constructor(opts, handlers) {
        const { retryOptions, ...dispatchOpts } = opts;
        const {
          // Retry scoped
          retry: retryFn,
          maxRetries,
          maxTimeout,
          minTimeout,
          timeoutFactor,
          // Response scoped
          methods,
          errorCodes,
          retryAfter,
          statusCodes
        } = retryOptions ?? {};
        this.dispatch = handlers.dispatch;
        this.handler = handlers.handler;
        this.opts = dispatchOpts;
        this.abort = null;
        this.aborted = false;
        this.retryOpts = {
          retry: retryFn ?? _RetryHandler[kRetryHandlerDefaultRetry],
          retryAfter: retryAfter ?? true,
          maxTimeout: maxTimeout ?? 30 * 1e3,
          // 30s,
          timeout: minTimeout ?? 500,
          // .5s
          timeoutFactor: timeoutFactor ?? 2,
          maxRetries: maxRetries ?? 5,
          // What errors we should retry
          methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
          // Indicates which errors to retry
          statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
          // List of errors to retry
          errorCodes: errorCodes ?? [
            "ECONNRESET",
            "ECONNREFUSED",
            "ENOTFOUND",
            "ENETDOWN",
            "ENETUNREACH",
            "EHOSTDOWN",
            "EHOSTUNREACH",
            "EPIPE"
          ]
        };
        this.retryCount = 0;
        this.start = 0;
        this.end = null;
        this.etag = null;
        this.resume = null;
        this.handler.onConnect((reason) => {
          this.aborted = true;
          if (this.abort) {
            this.abort(reason);
          } else {
            this.reason = reason;
          }
        });
      }
      onRequestSent() {
        if (this.handler.onRequestSent) {
          this.handler.onRequestSent();
        }
      }
      onUpgrade(statusCode, headers, socket) {
        if (this.handler.onUpgrade) {
          this.handler.onUpgrade(statusCode, headers, socket);
        }
      }
      onConnect(abort) {
        if (this.aborted) {
          abort(this.reason);
        } else {
          this.abort = abort;
        }
      }
      onBodySent(chunk) {
        if (this.handler.onBodySent) return this.handler.onBodySent(chunk);
      }
      static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
        const { statusCode, code, headers } = err;
        const { method, retryOptions } = opts;
        const {
          maxRetries,
          timeout,
          maxTimeout,
          timeoutFactor,
          statusCodes,
          errorCodes,
          methods
        } = retryOptions;
        let { counter, currentTimeout } = state;
        currentTimeout = currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout;
        if (code && code !== "UND_ERR_REQ_RETRY" && code !== "UND_ERR_SOCKET" && !errorCodes.includes(code)) {
          cb(err);
          return;
        }
        if (Array.isArray(methods) && !methods.includes(method)) {
          cb(err);
          return;
        }
        if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
          cb(err);
          return;
        }
        if (counter > maxRetries) {
          cb(err);
          return;
        }
        let retryAfterHeader = headers != null && headers["retry-after"];
        if (retryAfterHeader) {
          retryAfterHeader = Number(retryAfterHeader);
          retryAfterHeader = isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3;
        }
        const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);
        state.currentTimeout = retryTimeout;
        setTimeout(() => cb(null), retryTimeout);
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const headers = parseHeaders(rawHeaders);
        this.retryCount += 1;
        if (statusCode >= 300) {
          this.abort(
            new RequestRetryError("Request failed", statusCode, {
              headers,
              count: this.retryCount
            })
          );
          return false;
        }
        if (this.resume != null) {
          this.resume = null;
          if (statusCode !== 206) {
            return true;
          }
          const contentRange = parseRangeHeader(headers["content-range"]);
          if (!contentRange) {
            this.abort(
              new RequestRetryError("Content-Range mismatch", statusCode, {
                headers,
                count: this.retryCount
              })
            );
            return false;
          }
          if (this.etag != null && this.etag !== headers.etag) {
            this.abort(
              new RequestRetryError("ETag mismatch", statusCode, {
                headers,
                count: this.retryCount
              })
            );
            return false;
          }
          const { start, size, end = size } = contentRange;
          assert(this.start === start, "content-range mismatch");
          assert(this.end == null || this.end === end, "content-range mismatch");
          this.resume = resume;
          return true;
        }
        if (this.end == null) {
          if (statusCode === 206) {
            const range = parseRangeHeader(headers["content-range"]);
            if (range == null) {
              return this.handler.onHeaders(
                statusCode,
                rawHeaders,
                resume,
                statusMessage
              );
            }
            const { start, size, end = size } = range;
            assert(
              start != null && Number.isFinite(start) && this.start !== start,
              "content-range mismatch"
            );
            assert(Number.isFinite(start));
            assert(
              end != null && Number.isFinite(end) && this.end !== end,
              "invalid content-length"
            );
            this.start = start;
            this.end = end;
          }
          if (this.end == null) {
            const contentLength = headers["content-length"];
            this.end = contentLength != null ? Number(contentLength) : null;
          }
          assert(Number.isFinite(this.start));
          assert(
            this.end == null || Number.isFinite(this.end),
            "invalid content-length"
          );
          this.resume = resume;
          this.etag = headers.etag != null ? headers.etag : null;
          return this.handler.onHeaders(
            statusCode,
            rawHeaders,
            resume,
            statusMessage
          );
        }
        const err = new RequestRetryError("Request failed", statusCode, {
          headers,
          count: this.retryCount
        });
        this.abort(err);
        return false;
      }
      onData(chunk) {
        this.start += chunk.length;
        return this.handler.onData(chunk);
      }
      onComplete(rawTrailers) {
        this.retryCount = 0;
        return this.handler.onComplete(rawTrailers);
      }
      onError(err) {
        if (this.aborted || isDisturbed(this.opts.body)) {
          return this.handler.onError(err);
        }
        this.retryOpts.retry(
          err,
          {
            state: { counter: this.retryCount++, currentTimeout: this.retryAfter },
            opts: { retryOptions: this.retryOpts, ...this.opts }
          },
          onRetry.bind(this)
        );
        function onRetry(err2) {
          if (err2 != null || this.aborted || isDisturbed(this.opts.body)) {
            return this.handler.onError(err2);
          }
          if (this.start !== 0) {
            this.opts = {
              ...this.opts,
              headers: {
                ...this.opts.headers,
                range: `bytes=${this.start}-${this.end ?? ""}`
              }
            };
          }
          try {
            this.dispatch(this.opts, this);
          } catch (err3) {
            this.handler.onError(err3);
          }
        }
      }
    };
    module.exports = RetryHandler;
  }
});

// node_modules/undici/lib/global.js
var require_global2 = __commonJS({
  "node_modules/undici/lib/global.js"(exports, module) {
    "use strict";
    var globalDispatcher = /* @__PURE__ */ Symbol.for("undici.globalDispatcher.1");
    var { InvalidArgumentError } = require_errors();
    var Agent2 = require_agent();
    if (getGlobalDispatcher() === void 0) {
      setGlobalDispatcher(new Agent2());
    }
    function setGlobalDispatcher(agent) {
      if (!agent || typeof agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument agent must implement Agent");
      }
      Object.defineProperty(globalThis, globalDispatcher, {
        value: agent,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    function getGlobalDispatcher() {
      return globalThis[globalDispatcher];
    }
    module.exports = {
      setGlobalDispatcher,
      getGlobalDispatcher
    };
  }
});

// node_modules/undici/lib/handler/DecoratorHandler.js
var require_DecoratorHandler = __commonJS({
  "node_modules/undici/lib/handler/DecoratorHandler.js"(exports, module) {
    "use strict";
    module.exports = class DecoratorHandler {
      constructor(handler) {
        this.handler = handler;
      }
      onConnect(...args) {
        return this.handler.onConnect(...args);
      }
      onError(...args) {
        return this.handler.onError(...args);
      }
      onUpgrade(...args) {
        return this.handler.onUpgrade(...args);
      }
      onHeaders(...args) {
        return this.handler.onHeaders(...args);
      }
      onData(...args) {
        return this.handler.onData(...args);
      }
      onComplete(...args) {
        return this.handler.onComplete(...args);
      }
      onBodySent(...args) {
        return this.handler.onBodySent(...args);
      }
    };
  }
});

// node_modules/undici/lib/fetch/headers.js
var require_headers = __commonJS({
  "node_modules/undici/lib/fetch/headers.js"(exports, module) {
    "use strict";
    var { kHeadersList, kConstruct } = require_symbols();
    var { kGuard } = require_symbols2();
    var { kEnumerableProperty } = require_util();
    var {
      makeIterator,
      isValidHeaderName,
      isValidHeaderValue
    } = require_util2();
    var util = __require("util");
    var { webidl } = require_webidl();
    var assert = __require("assert");
    var kHeadersMap = /* @__PURE__ */ Symbol("headers map");
    var kHeadersSortedMap = /* @__PURE__ */ Symbol("headers map sorted");
    function isHTTPWhiteSpaceCharCode(code) {
      return code === 10 || code === 13 || code === 9 || code === 32;
    }
    function headerValueNormalize(potentialValue) {
      let i = 0;
      let j = potentialValue.length;
      while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j;
      while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i;
      return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
    }
    function fill(headers, object) {
      if (Array.isArray(object)) {
        for (let i = 0; i < object.length; ++i) {
          const header = object[i];
          if (header.length !== 2) {
            throw webidl.errors.exception({
              header: "Headers constructor",
              message: `expected name/value pair to be length 2, found ${header.length}.`
            });
          }
          appendHeader(headers, header[0], header[1]);
        }
      } else if (typeof object === "object" && object !== null) {
        const keys = Object.keys(object);
        for (let i = 0; i < keys.length; ++i) {
          appendHeader(headers, keys[i], object[keys[i]]);
        }
      } else {
        throw webidl.errors.conversionFailed({
          prefix: "Headers constructor",
          argument: "Argument 1",
          types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
        });
      }
    }
    function appendHeader(headers, name, value) {
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value,
          type: "header value"
        });
      }
      if (headers[kGuard] === "immutable") {
        throw new TypeError("immutable");
      } else if (headers[kGuard] === "request-no-cors") {
      }
      return headers[kHeadersList].append(name, value);
    }
    var HeadersList = class _HeadersList {
      /** @type {[string, string][]|null} */
      cookies = null;
      constructor(init) {
        if (init instanceof _HeadersList) {
          this[kHeadersMap] = new Map(init[kHeadersMap]);
          this[kHeadersSortedMap] = init[kHeadersSortedMap];
          this.cookies = init.cookies === null ? null : [...init.cookies];
        } else {
          this[kHeadersMap] = new Map(init);
          this[kHeadersSortedMap] = null;
        }
      }
      // https://fetch.spec.whatwg.org/#header-list-contains
      contains(name) {
        name = name.toLowerCase();
        return this[kHeadersMap].has(name);
      }
      clear() {
        this[kHeadersMap].clear();
        this[kHeadersSortedMap] = null;
        this.cookies = null;
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-append
      append(name, value) {
        this[kHeadersSortedMap] = null;
        const lowercaseName = name.toLowerCase();
        const exists = this[kHeadersMap].get(lowercaseName);
        if (exists) {
          const delimiter = lowercaseName === "cookie" ? "; " : ", ";
          this[kHeadersMap].set(lowercaseName, {
            name: exists.name,
            value: `${exists.value}${delimiter}${value}`
          });
        } else {
          this[kHeadersMap].set(lowercaseName, { name, value });
        }
        if (lowercaseName === "set-cookie") {
          this.cookies ??= [];
          this.cookies.push(value);
        }
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-set
      set(name, value) {
        this[kHeadersSortedMap] = null;
        const lowercaseName = name.toLowerCase();
        if (lowercaseName === "set-cookie") {
          this.cookies = [value];
        }
        this[kHeadersMap].set(lowercaseName, { name, value });
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-delete
      delete(name) {
        this[kHeadersSortedMap] = null;
        name = name.toLowerCase();
        if (name === "set-cookie") {
          this.cookies = null;
        }
        this[kHeadersMap].delete(name);
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-get
      get(name) {
        const value = this[kHeadersMap].get(name.toLowerCase());
        return value === void 0 ? null : value.value;
      }
      *[Symbol.iterator]() {
        for (const [name, { value }] of this[kHeadersMap]) {
          yield [name, value];
        }
      }
      get entries() {
        const headers = {};
        if (this[kHeadersMap].size) {
          for (const { name, value } of this[kHeadersMap].values()) {
            headers[name] = value;
          }
        }
        return headers;
      }
    };
    var Headers = class _Headers {
      constructor(init = void 0) {
        if (init === kConstruct) {
          return;
        }
        this[kHeadersList] = new HeadersList();
        this[kGuard] = "none";
        if (init !== void 0) {
          init = webidl.converters.HeadersInit(init);
          fill(this, init);
        }
      }
      // https://fetch.spec.whatwg.org/#dom-headers-append
      append(name, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, { header: "Headers.append" });
        name = webidl.converters.ByteString(name);
        value = webidl.converters.ByteString(value);
        return appendHeader(this, name, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-delete
      delete(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.delete" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.delete",
            value: name,
            type: "header name"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
        }
        if (!this[kHeadersList].contains(name)) {
          return;
        }
        this[kHeadersList].delete(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-get
      get(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.get" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.get",
            value: name,
            type: "header name"
          });
        }
        return this[kHeadersList].get(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-has
      has(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.has" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.has",
            value: name,
            type: "header name"
          });
        }
        return this[kHeadersList].contains(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-set
      set(name, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, { header: "Headers.set" });
        name = webidl.converters.ByteString(name);
        value = webidl.converters.ByteString(value);
        value = headerValueNormalize(value);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.set",
            value: name,
            type: "header name"
          });
        } else if (!isValidHeaderValue(value)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.set",
            value,
            type: "header value"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
        }
        this[kHeadersList].set(name, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
      getSetCookie() {
        webidl.brandCheck(this, _Headers);
        const list = this[kHeadersList].cookies;
        if (list) {
          return [...list];
        }
        return [];
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
      get [kHeadersSortedMap]() {
        if (this[kHeadersList][kHeadersSortedMap]) {
          return this[kHeadersList][kHeadersSortedMap];
        }
        const headers = [];
        const names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1);
        const cookies = this[kHeadersList].cookies;
        for (let i = 0; i < names.length; ++i) {
          const [name, value] = names[i];
          if (name === "set-cookie") {
            for (let j = 0; j < cookies.length; ++j) {
              headers.push([name, cookies[j]]);
            }
          } else {
            assert(value !== null);
            headers.push([name, value]);
          }
        }
        this[kHeadersList][kHeadersSortedMap] = headers;
        return headers;
      }
      keys() {
        webidl.brandCheck(this, _Headers);
        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "key"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "key"
        );
      }
      values() {
        webidl.brandCheck(this, _Headers);
        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "value"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "value"
        );
      }
      entries() {
        webidl.brandCheck(this, _Headers);
        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "key+value"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "key+value"
        );
      }
      /**
       * @param {(value: string, key: string, self: Headers) => void} callbackFn
       * @param {unknown} thisArg
       */
      forEach(callbackFn, thisArg = globalThis) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" });
        if (typeof callbackFn !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'."
          );
        }
        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
      [/* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom")]() {
        webidl.brandCheck(this, _Headers);
        return this[kHeadersList];
      }
    };
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    Object.defineProperties(Headers.prototype, {
      append: kEnumerableProperty,
      delete: kEnumerableProperty,
      get: kEnumerableProperty,
      has: kEnumerableProperty,
      set: kEnumerableProperty,
      getSetCookie: kEnumerableProperty,
      keys: kEnumerableProperty,
      values: kEnumerableProperty,
      entries: kEnumerableProperty,
      forEach: kEnumerableProperty,
      [Symbol.iterator]: { enumerable: false },
      [Symbol.toStringTag]: {
        value: "Headers",
        configurable: true
      },
      [util.inspect.custom]: {
        enumerable: false
      }
    });
    webidl.converters.HeadersInit = function(V) {
      if (webidl.util.Type(V) === "Object") {
        if (V[Symbol.iterator]) {
          return webidl.converters["sequence<sequence<ByteString>>"](V);
        }
        return webidl.converters["record<ByteString, ByteString>"](V);
      }
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    };
    module.exports = {
      fill,
      Headers,
      HeadersList
    };
  }
});

// node_modules/undici/lib/fetch/response.js
var require_response = __commonJS({
  "node_modules/undici/lib/fetch/response.js"(exports, module) {
    "use strict";
    var { Headers, HeadersList, fill } = require_headers();
    var { extractBody, cloneBody, mixinBody } = require_body();
    var util = require_util();
    var { kEnumerableProperty } = util;
    var {
      isValidReasonPhrase,
      isCancelled,
      isAborted,
      isBlobLike,
      serializeJavascriptValueToJSONString,
      isErrorLike,
      isomorphicEncode
    } = require_util2();
    var {
      redirectStatusSet,
      nullBodyStatus,
      DOMException: DOMException2
    } = require_constants2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var { webidl } = require_webidl();
    var { FormData } = require_formdata();
    var { getGlobalOrigin } = require_global();
    var { URLSerializer } = require_dataURL();
    var { kHeadersList, kConstruct } = require_symbols();
    var assert = __require("assert");
    var { types } = __require("util");
    var ReadableStream = globalThis.ReadableStream || __require("stream/web").ReadableStream;
    var textEncoder = new TextEncoder("utf-8");
    var Response = class _Response {
      // Creates network error Response.
      static error() {
        const relevantRealm = { settingsObject: {} };
        const responseObject = new _Response();
        responseObject[kState] = makeNetworkError();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response-json
      static json(data, init = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "Response.json" });
        if (init !== null) {
          init = webidl.converters.ResponseInit(init);
        }
        const bytes = textEncoder.encode(
          serializeJavascriptValueToJSONString(data)
        );
        const body = extractBody(bytes);
        const relevantRealm = { settingsObject: {} };
        const responseObject = new _Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "response";
        responseObject[kHeaders][kRealm] = relevantRealm;
        initializeResponse(responseObject, init, { body: body[0], type: "application/json" });
        return responseObject;
      }
      // Creates a redirect Response that redirects to url with status status.
      static redirect(url, status = 302) {
        const relevantRealm = { settingsObject: {} };
        webidl.argumentLengthCheck(arguments, 1, { header: "Response.redirect" });
        url = webidl.converters.USVString(url);
        status = webidl.converters["unsigned short"](status);
        let parsedURL;
        try {
          parsedURL = new URL(url, getGlobalOrigin());
        } catch (err) {
          throw Object.assign(new TypeError("Failed to parse URL from " + url), {
            cause: err
          });
        }
        if (!redirectStatusSet.has(status)) {
          throw new RangeError("Invalid status code " + status);
        }
        const responseObject = new _Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        responseObject[kState].status = status;
        const value = isomorphicEncode(URLSerializer(parsedURL));
        responseObject[kState].headersList.append("location", value);
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response
      constructor(body = null, init = {}) {
        if (body !== null) {
          body = webidl.converters.BodyInit(body);
        }
        init = webidl.converters.ResponseInit(init);
        this[kRealm] = { settingsObject: {} };
        this[kState] = makeResponse({});
        this[kHeaders] = new Headers(kConstruct);
        this[kHeaders][kGuard] = "response";
        this[kHeaders][kHeadersList] = this[kState].headersList;
        this[kHeaders][kRealm] = this[kRealm];
        let bodyWithType = null;
        if (body != null) {
          const [extractedBody, type] = extractBody(body);
          bodyWithType = { body: extractedBody, type };
        }
        initializeResponse(this, init, bodyWithType);
      }
      // Returns responses type, e.g., "cors".
      get type() {
        webidl.brandCheck(this, _Response);
        return this[kState].type;
      }
      // Returns responses URL, if it has one; otherwise the empty string.
      get url() {
        webidl.brandCheck(this, _Response);
        const urlList = this[kState].urlList;
        const url = urlList[urlList.length - 1] ?? null;
        if (url === null) {
          return "";
        }
        return URLSerializer(url, true);
      }
      // Returns whether response was obtained through a redirect.
      get redirected() {
        webidl.brandCheck(this, _Response);
        return this[kState].urlList.length > 1;
      }
      // Returns responses status.
      get status() {
        webidl.brandCheck(this, _Response);
        return this[kState].status;
      }
      // Returns whether responses status is an ok status.
      get ok() {
        webidl.brandCheck(this, _Response);
        return this[kState].status >= 200 && this[kState].status <= 299;
      }
      // Returns responses status message.
      get statusText() {
        webidl.brandCheck(this, _Response);
        return this[kState].statusText;
      }
      // Returns responses headers as Headers.
      get headers() {
        webidl.brandCheck(this, _Response);
        return this[kHeaders];
      }
      get body() {
        webidl.brandCheck(this, _Response);
        return this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Response);
        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
      }
      // Returns a clone of response.
      clone() {
        webidl.brandCheck(this, _Response);
        if (this.bodyUsed || this.body && this.body.locked) {
          throw webidl.errors.exception({
            header: "Response.clone",
            message: "Body has already been consumed."
          });
        }
        const clonedResponse = cloneResponse(this[kState]);
        const clonedResponseObject = new _Response();
        clonedResponseObject[kState] = clonedResponse;
        clonedResponseObject[kRealm] = this[kRealm];
        clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
        clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        return clonedResponseObject;
      }
    };
    mixinBody(Response);
    Object.defineProperties(Response.prototype, {
      type: kEnumerableProperty,
      url: kEnumerableProperty,
      status: kEnumerableProperty,
      ok: kEnumerableProperty,
      redirected: kEnumerableProperty,
      statusText: kEnumerableProperty,
      headers: kEnumerableProperty,
      clone: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Response",
        configurable: true
      }
    });
    Object.defineProperties(Response, {
      json: kEnumerableProperty,
      redirect: kEnumerableProperty,
      error: kEnumerableProperty
    });
    function cloneResponse(response) {
      if (response.internalResponse) {
        return filterResponse(
          cloneResponse(response.internalResponse),
          response.type
        );
      }
      const newResponse = makeResponse({ ...response, body: null });
      if (response.body != null) {
        newResponse.body = cloneBody(response.body);
      }
      return newResponse;
    }
    function makeResponse(init) {
      return {
        aborted: false,
        rangeRequested: false,
        timingAllowPassed: false,
        requestIncludesCredentials: false,
        type: "default",
        status: 200,
        timingInfo: null,
        cacheState: "",
        statusText: "",
        ...init,
        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),
        urlList: init.urlList ? [...init.urlList] : []
      };
    }
    function makeNetworkError(reason) {
      const isError = isErrorLike(reason);
      return makeResponse({
        type: "error",
        status: 0,
        error: isError ? reason : new Error(reason ? String(reason) : reason),
        aborted: reason && reason.name === "AbortError"
      });
    }
    function makeFilteredResponse(response, state) {
      state = {
        internalResponse: response,
        ...state
      };
      return new Proxy(response, {
        get(target, p) {
          return p in state ? state[p] : target[p];
        },
        set(target, p, value) {
          assert(!(p in state));
          target[p] = value;
          return true;
        }
      });
    }
    function filterResponse(response, type) {
      if (type === "basic") {
        return makeFilteredResponse(response, {
          type: "basic",
          headersList: response.headersList
        });
      } else if (type === "cors") {
        return makeFilteredResponse(response, {
          type: "cors",
          headersList: response.headersList
        });
      } else if (type === "opaque") {
        return makeFilteredResponse(response, {
          type: "opaque",
          urlList: Object.freeze([]),
          status: 0,
          statusText: "",
          body: null
        });
      } else if (type === "opaqueredirect") {
        return makeFilteredResponse(response, {
          type: "opaqueredirect",
          status: 0,
          statusText: "",
          headersList: [],
          body: null
        });
      } else {
        assert(false);
      }
    }
    function makeAppropriateNetworkError(fetchParams, err = null) {
      assert(isCancelled(fetchParams));
      return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException2("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException2("Request was cancelled."), { cause: err }));
    }
    function initializeResponse(response, init, body) {
      if (init.status !== null && (init.status < 200 || init.status > 599)) {
        throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
      }
      if ("statusText" in init && init.statusText != null) {
        if (!isValidReasonPhrase(String(init.statusText))) {
          throw new TypeError("Invalid statusText");
        }
      }
      if ("status" in init && init.status != null) {
        response[kState].status = init.status;
      }
      if ("statusText" in init && init.statusText != null) {
        response[kState].statusText = init.statusText;
      }
      if ("headers" in init && init.headers != null) {
        fill(response[kHeaders], init.headers);
      }
      if (body) {
        if (nullBodyStatus.includes(response.status)) {
          throw webidl.errors.exception({
            header: "Response constructor",
            message: "Invalid response status code " + response.status
          });
        }
        response[kState].body = body.body;
        if (body.type != null && !response[kState].headersList.contains("Content-Type")) {
          response[kState].headersList.append("content-type", body.type);
        }
      }
    }
    webidl.converters.ReadableStream = webidl.interfaceConverter(
      ReadableStream
    );
    webidl.converters.FormData = webidl.interfaceConverter(
      FormData
    );
    webidl.converters.URLSearchParams = webidl.interfaceConverter(
      URLSearchParams
    );
    webidl.converters.XMLHttpRequestBodyInit = function(V) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V);
      }
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (types.isArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {
        return webidl.converters.BufferSource(V);
      }
      if (util.isFormDataLike(V)) {
        return webidl.converters.FormData(V, { strict: false });
      }
      if (V instanceof URLSearchParams) {
        return webidl.converters.URLSearchParams(V);
      }
      return webidl.converters.DOMString(V);
    };
    webidl.converters.BodyInit = function(V) {
      if (V instanceof ReadableStream) {
        return webidl.converters.ReadableStream(V);
      }
      if (V?.[Symbol.asyncIterator]) {
        return V;
      }
      return webidl.converters.XMLHttpRequestBodyInit(V);
    };
    webidl.converters.ResponseInit = webidl.dictionaryConverter([
      {
        key: "status",
        converter: webidl.converters["unsigned short"],
        defaultValue: 200
      },
      {
        key: "statusText",
        converter: webidl.converters.ByteString,
        defaultValue: ""
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      }
    ]);
    module.exports = {
      makeNetworkError,
      makeResponse,
      makeAppropriateNetworkError,
      filterResponse,
      Response,
      cloneResponse
    };
  }
});

// node_modules/undici/lib/fetch/request.js
var require_request2 = __commonJS({
  "node_modules/undici/lib/fetch/request.js"(exports, module) {
    "use strict";
    var { extractBody, mixinBody, cloneBody } = require_body();
    var { Headers, fill: fillHeaders, HeadersList } = require_headers();
    var { FinalizationRegistry } = require_dispatcher_weakref()();
    var util = require_util();
    var {
      isValidHTTPToken,
      sameOrigin,
      normalizeMethod,
      makePolicyContainer,
      normalizeMethodRecord
    } = require_util2();
    var {
      forbiddenMethodsSet,
      corsSafeListedMethodsSet,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      requestDuplex
    } = require_constants2();
    var { kEnumerableProperty } = util;
    var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols2();
    var { webidl } = require_webidl();
    var { getGlobalOrigin } = require_global();
    var { URLSerializer } = require_dataURL();
    var { kHeadersList, kConstruct } = require_symbols();
    var assert = __require("assert");
    var { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = __require("events");
    var TransformStream = globalThis.TransformStream;
    var kAbortController = /* @__PURE__ */ Symbol("abortController");
    var requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
      signal.removeEventListener("abort", abort);
    });
    var Request = class _Request {
      // https://fetch.spec.whatwg.org/#dom-request
      constructor(input, init = {}) {
        if (input === kConstruct) {
          return;
        }
        webidl.argumentLengthCheck(arguments, 1, { header: "Request constructor" });
        input = webidl.converters.RequestInfo(input);
        init = webidl.converters.RequestInit(init);
        this[kRealm] = {
          settingsObject: {
            baseUrl: getGlobalOrigin(),
            get origin() {
              return this.baseUrl?.origin;
            },
            policyContainer: makePolicyContainer()
          }
        };
        let request = null;
        let fallbackMode = null;
        const baseUrl = this[kRealm].settingsObject.baseUrl;
        let signal = null;
        if (typeof input === "string") {
          let parsedURL;
          try {
            parsedURL = new URL(input, baseUrl);
          } catch (err) {
            throw new TypeError("Failed to parse URL from " + input, { cause: err });
          }
          if (parsedURL.username || parsedURL.password) {
            throw new TypeError(
              "Request cannot be constructed from a URL that includes credentials: " + input
            );
          }
          request = makeRequest({ urlList: [parsedURL] });
          fallbackMode = "cors";
        } else {
          assert(input instanceof _Request);
          request = input[kState];
          signal = input[kSignal];
        }
        const origin = this[kRealm].settingsObject.origin;
        let window = "client";
        if (request.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request.window, origin)) {
          window = request.window;
        }
        if (init.window != null) {
          throw new TypeError(`'window' option '${window}' must be null`);
        }
        if ("window" in init) {
          window = "no-window";
        }
        request = makeRequest({
          // URL requests URL.
          // undici implementation note: this is set as the first item in request's urlList in makeRequest
          // method requests method.
          method: request.method,
          // header list A copy of requests header list.
          // undici implementation note: headersList is cloned in makeRequest
          headersList: request.headersList,
          // unsafe-request flag Set.
          unsafeRequest: request.unsafeRequest,
          // client Thiss relevant settings object.
          client: this[kRealm].settingsObject,
          // window window.
          window,
          // priority requests priority.
          priority: request.priority,
          // origin requests origin. The propagation of the origin is only significant for navigation requests
          // being handled by a service worker. In this scenario a request can have an origin that is different
          // from the current client.
          origin: request.origin,
          // referrer requests referrer.
          referrer: request.referrer,
          // referrer policy requests referrer policy.
          referrerPolicy: request.referrerPolicy,
          // mode requests mode.
          mode: request.mode,
          // credentials mode requests credentials mode.
          credentials: request.credentials,
          // cache mode requests cache mode.
          cache: request.cache,
          // redirect mode requests redirect mode.
          redirect: request.redirect,
          // integrity metadata requests integrity metadata.
          integrity: request.integrity,
          // keepalive requests keepalive.
          keepalive: request.keepalive,
          // reload-navigation flag requests reload-navigation flag.
          reloadNavigation: request.reloadNavigation,
          // history-navigation flag requests history-navigation flag.
          historyNavigation: request.historyNavigation,
          // URL list A clone of requests URL list.
          urlList: [...request.urlList]
        });
        const initHasKey = Object.keys(init).length !== 0;
        if (initHasKey) {
          if (request.mode === "navigate") {
            request.mode = "same-origin";
          }
          request.reloadNavigation = false;
          request.historyNavigation = false;
          request.origin = "client";
          request.referrer = "client";
          request.referrerPolicy = "";
          request.url = request.urlList[request.urlList.length - 1];
          request.urlList = [request.url];
        }
        if (init.referrer !== void 0) {
          const referrer = init.referrer;
          if (referrer === "") {
            request.referrer = "no-referrer";
          } else {
            let parsedReferrer;
            try {
              parsedReferrer = new URL(referrer, baseUrl);
            } catch (err) {
              throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
            }
            if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl)) {
              request.referrer = "client";
            } else {
              request.referrer = parsedReferrer;
            }
          }
        }
        if (init.referrerPolicy !== void 0) {
          request.referrerPolicy = init.referrerPolicy;
        }
        let mode;
        if (init.mode !== void 0) {
          mode = init.mode;
        } else {
          mode = fallbackMode;
        }
        if (mode === "navigate") {
          throw webidl.errors.exception({
            header: "Request constructor",
            message: "invalid request mode navigate."
          });
        }
        if (mode != null) {
          request.mode = mode;
        }
        if (init.credentials !== void 0) {
          request.credentials = init.credentials;
        }
        if (init.cache !== void 0) {
          request.cache = init.cache;
        }
        if (request.cache === "only-if-cached" && request.mode !== "same-origin") {
          throw new TypeError(
            "'only-if-cached' can be set only with 'same-origin' mode"
          );
        }
        if (init.redirect !== void 0) {
          request.redirect = init.redirect;
        }
        if (init.integrity != null) {
          request.integrity = String(init.integrity);
        }
        if (init.keepalive !== void 0) {
          request.keepalive = Boolean(init.keepalive);
        }
        if (init.method !== void 0) {
          let method = init.method;
          if (!isValidHTTPToken(method)) {
            throw new TypeError(`'${method}' is not a valid HTTP method.`);
          }
          if (forbiddenMethodsSet.has(method.toUpperCase())) {
            throw new TypeError(`'${method}' HTTP method is unsupported.`);
          }
          method = normalizeMethodRecord[method] ?? normalizeMethod(method);
          request.method = method;
        }
        if (init.signal !== void 0) {
          signal = init.signal;
        }
        this[kState] = request;
        const ac = new AbortController();
        this[kSignal] = ac.signal;
        this[kSignal][kRealm] = this[kRealm];
        if (signal != null) {
          if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") {
            throw new TypeError(
              "Failed to construct 'Request': member signal is not of type AbortSignal."
            );
          }
          if (signal.aborted) {
            ac.abort(signal.reason);
          } else {
            this[kAbortController] = ac;
            const acRef = new WeakRef(ac);
            const abort = function() {
              const ac2 = acRef.deref();
              if (ac2 !== void 0) {
                ac2.abort(this.reason);
              }
            };
            try {
              if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) {
                setMaxListeners(100, signal);
              } else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) {
                setMaxListeners(100, signal);
              }
            } catch {
            }
            util.addAbortListener(signal, abort);
            requestFinalizer.register(ac, { signal, abort });
          }
        }
        this[kHeaders] = new Headers(kConstruct);
        this[kHeaders][kHeadersList] = request.headersList;
        this[kHeaders][kGuard] = "request";
        this[kHeaders][kRealm] = this[kRealm];
        if (mode === "no-cors") {
          if (!corsSafeListedMethodsSet.has(request.method)) {
            throw new TypeError(
              `'${request.method} is unsupported in no-cors mode.`
            );
          }
          this[kHeaders][kGuard] = "request-no-cors";
        }
        if (initHasKey) {
          const headersList = this[kHeaders][kHeadersList];
          const headers = init.headers !== void 0 ? init.headers : new HeadersList(headersList);
          headersList.clear();
          if (headers instanceof HeadersList) {
            for (const [key, val] of headers) {
              headersList.append(key, val);
            }
            headersList.cookies = headers.cookies;
          } else {
            fillHeaders(this[kHeaders], headers);
          }
        }
        const inputBody = input instanceof _Request ? input[kState].body : null;
        if ((init.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body.");
        }
        let initBody = null;
        if (init.body != null) {
          const [extractedBody, contentType] = extractBody(
            init.body,
            request.keepalive
          );
          initBody = extractedBody;
          if (contentType && !this[kHeaders][kHeadersList].contains("content-type")) {
            this[kHeaders].append("content-type", contentType);
          }
        }
        const inputOrInitBody = initBody ?? inputBody;
        if (inputOrInitBody != null && inputOrInitBody.source == null) {
          if (initBody != null && init.duplex == null) {
            throw new TypeError("RequestInit: duplex option is required when sending a body.");
          }
          if (request.mode !== "same-origin" && request.mode !== "cors") {
            throw new TypeError(
              'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
            );
          }
          request.useCORSPreflightFlag = true;
        }
        let finalBody = inputOrInitBody;
        if (initBody == null && inputBody != null) {
          if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
            throw new TypeError(
              "Cannot construct a Request with a Request object that has already been used."
            );
          }
          if (!TransformStream) {
            TransformStream = __require("stream/web").TransformStream;
          }
          const identityTransform = new TransformStream();
          inputBody.stream.pipeThrough(identityTransform);
          finalBody = {
            source: inputBody.source,
            length: inputBody.length,
            stream: identityTransform.readable
          };
        }
        this[kState].body = finalBody;
      }
      // Returns requests HTTP method, which is "GET" by default.
      get method() {
        webidl.brandCheck(this, _Request);
        return this[kState].method;
      }
      // Returns the URL of request as a string.
      get url() {
        webidl.brandCheck(this, _Request);
        return URLSerializer(this[kState].url);
      }
      // Returns a Headers object consisting of the headers associated with request.
      // Note that headers added in the network layer by the user agent will not
      // be accounted for in this object, e.g., the "Host" header.
      get headers() {
        webidl.brandCheck(this, _Request);
        return this[kHeaders];
      }
      // Returns the kind of resource requested by request, e.g., "document"
      // or "script".
      get destination() {
        webidl.brandCheck(this, _Request);
        return this[kState].destination;
      }
      // Returns the referrer of request. Its value can be a same-origin URL if
      // explicitly set in init, the empty string to indicate no referrer, and
      // "about:client" when defaulting to the globals default. This is used
      // during fetching to determine the value of the `Referer` header of the
      // request being made.
      get referrer() {
        webidl.brandCheck(this, _Request);
        if (this[kState].referrer === "no-referrer") {
          return "";
        }
        if (this[kState].referrer === "client") {
          return "about:client";
        }
        return this[kState].referrer.toString();
      }
      // Returns the referrer policy associated with request.
      // This is used during fetching to compute the value of the requests
      // referrer.
      get referrerPolicy() {
        webidl.brandCheck(this, _Request);
        return this[kState].referrerPolicy;
      }
      // Returns the mode associated with request, which is a string indicating
      // whether the request will use CORS, or will be restricted to same-origin
      // URLs.
      get mode() {
        webidl.brandCheck(this, _Request);
        return this[kState].mode;
      }
      // Returns the credentials mode associated with request,
      // which is a string indicating whether credentials will be sent with the
      // request always, never, or only when sent to a same-origin URL.
      get credentials() {
        return this[kState].credentials;
      }
      // Returns the cache mode associated with request,
      // which is a string indicating how the request will
      // interact with the browsers cache when fetching.
      get cache() {
        webidl.brandCheck(this, _Request);
        return this[kState].cache;
      }
      // Returns the redirect mode associated with request,
      // which is a string indicating how redirects for the
      // request will be handled during fetching. A request
      // will follow redirects by default.
      get redirect() {
        webidl.brandCheck(this, _Request);
        return this[kState].redirect;
      }
      // Returns requests subresource integrity metadata, which is a
      // cryptographic hash of the resource being fetched. Its value
      // consists of multiple hashes separated by whitespace. [SRI]
      get integrity() {
        webidl.brandCheck(this, _Request);
        return this[kState].integrity;
      }
      // Returns a boolean indicating whether or not request can outlive the
      // global in which it was created.
      get keepalive() {
        webidl.brandCheck(this, _Request);
        return this[kState].keepalive;
      }
      // Returns a boolean indicating whether or not request is for a reload
      // navigation.
      get isReloadNavigation() {
        webidl.brandCheck(this, _Request);
        return this[kState].reloadNavigation;
      }
      // Returns a boolean indicating whether or not request is for a history
      // navigation (a.k.a. back-foward navigation).
      get isHistoryNavigation() {
        webidl.brandCheck(this, _Request);
        return this[kState].historyNavigation;
      }
      // Returns the signal associated with request, which is an AbortSignal
      // object indicating whether or not request has been aborted, and its
      // abort event handler.
      get signal() {
        webidl.brandCheck(this, _Request);
        return this[kSignal];
      }
      get body() {
        webidl.brandCheck(this, _Request);
        return this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Request);
        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
      }
      get duplex() {
        webidl.brandCheck(this, _Request);
        return "half";
      }
      // Returns a clone of request.
      clone() {
        webidl.brandCheck(this, _Request);
        if (this.bodyUsed || this.body?.locked) {
          throw new TypeError("unusable");
        }
        const clonedRequest = cloneRequest(this[kState]);
        const clonedRequestObject = new _Request(kConstruct);
        clonedRequestObject[kState] = clonedRequest;
        clonedRequestObject[kRealm] = this[kRealm];
        clonedRequestObject[kHeaders] = new Headers(kConstruct);
        clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
        clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        const ac = new AbortController();
        if (this.signal.aborted) {
          ac.abort(this.signal.reason);
        } else {
          util.addAbortListener(
            this.signal,
            () => {
              ac.abort(this.signal.reason);
            }
          );
        }
        clonedRequestObject[kSignal] = ac.signal;
        return clonedRequestObject;
      }
    };
    mixinBody(Request);
    function makeRequest(init) {
      const request = {
        method: "GET",
        localURLsOnly: false,
        unsafeRequest: false,
        body: null,
        client: null,
        reservedClient: null,
        replacesClientId: "",
        window: "client",
        keepalive: false,
        serviceWorkers: "all",
        initiator: "",
        destination: "",
        priority: null,
        origin: "client",
        policyContainer: "client",
        referrer: "client",
        referrerPolicy: "",
        mode: "no-cors",
        useCORSPreflightFlag: false,
        credentials: "same-origin",
        useCredentials: false,
        cache: "default",
        redirect: "follow",
        integrity: "",
        cryptoGraphicsNonceMetadata: "",
        parserMetadata: "",
        reloadNavigation: false,
        historyNavigation: false,
        userActivation: false,
        taintedOrigin: false,
        redirectCount: 0,
        responseTainting: "basic",
        preventNoCacheCacheControlHeaderModification: false,
        done: false,
        timingAllowFailed: false,
        ...init,
        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
      };
      request.url = request.urlList[0];
      return request;
    }
    function cloneRequest(request) {
      const newRequest = makeRequest({ ...request, body: null });
      if (request.body != null) {
        newRequest.body = cloneBody(request.body);
      }
      return newRequest;
    }
    Object.defineProperties(Request.prototype, {
      method: kEnumerableProperty,
      url: kEnumerableProperty,
      headers: kEnumerableProperty,
      redirect: kEnumerableProperty,
      clone: kEnumerableProperty,
      signal: kEnumerableProperty,
      duplex: kEnumerableProperty,
      destination: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      isHistoryNavigation: kEnumerableProperty,
      isReloadNavigation: kEnumerableProperty,
      keepalive: kEnumerableProperty,
      integrity: kEnumerableProperty,
      cache: kEnumerableProperty,
      credentials: kEnumerableProperty,
      attribute: kEnumerableProperty,
      referrerPolicy: kEnumerableProperty,
      referrer: kEnumerableProperty,
      mode: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Request",
        configurable: true
      }
    });
    webidl.converters.Request = webidl.interfaceConverter(
      Request
    );
    webidl.converters.RequestInfo = function(V) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V);
      }
      if (V instanceof Request) {
        return webidl.converters.Request(V);
      }
      return webidl.converters.USVString(V);
    };
    webidl.converters.AbortSignal = webidl.interfaceConverter(
      AbortSignal
    );
    webidl.converters.RequestInit = webidl.dictionaryConverter([
      {
        key: "method",
        converter: webidl.converters.ByteString
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      },
      {
        key: "body",
        converter: webidl.nullableConverter(
          webidl.converters.BodyInit
        )
      },
      {
        key: "referrer",
        converter: webidl.converters.USVString
      },
      {
        key: "referrerPolicy",
        converter: webidl.converters.DOMString,
        // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
        allowedValues: referrerPolicy
      },
      {
        key: "mode",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#concept-request-mode
        allowedValues: requestMode
      },
      {
        key: "credentials",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcredentials
        allowedValues: requestCredentials
      },
      {
        key: "cache",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcache
        allowedValues: requestCache
      },
      {
        key: "redirect",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestredirect
        allowedValues: requestRedirect
      },
      {
        key: "integrity",
        converter: webidl.converters.DOMString
      },
      {
        key: "keepalive",
        converter: webidl.converters.boolean
      },
      {
        key: "signal",
        converter: webidl.nullableConverter(
          (signal) => webidl.converters.AbortSignal(
            signal,
            { strict: false }
          )
        )
      },
      {
        key: "window",
        converter: webidl.converters.any
      },
      {
        key: "duplex",
        converter: webidl.converters.DOMString,
        allowedValues: requestDuplex
      }
    ]);
    module.exports = { Request, makeRequest };
  }
});

// node_modules/undici/lib/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/undici/lib/fetch/index.js"(exports, module) {
    "use strict";
    var {
      Response,
      makeNetworkError,
      makeAppropriateNetworkError,
      filterResponse,
      makeResponse
    } = require_response();
    var { Headers } = require_headers();
    var { Request, makeRequest } = require_request2();
    var zlib = __require("zlib");
    var {
      bytesMatch,
      makePolicyContainer,
      clonePolicyContainer,
      requestBadPort,
      TAOCheck,
      appendRequestOriginHeader,
      responseLocationURL,
      requestCurrentURL,
      setRequestReferrerPolicyOnRedirect,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      createOpaqueTimingInfo,
      appendFetchMetadata,
      corsCheck,
      crossOriginResourcePolicyCheck,
      determineRequestsReferrer,
      coarsenedSharedCurrentTime,
      createDeferredPromise,
      isBlobLike,
      sameOrigin,
      isCancelled,
      isAborted,
      isErrorLike,
      fullyReadBody,
      readableStreamClose,
      isomorphicEncode,
      urlIsLocal,
      urlIsHttpHttpsScheme,
      urlHasHttpsScheme
    } = require_util2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var assert = __require("assert");
    var { safelyExtractBody } = require_body();
    var {
      redirectStatusSet,
      nullBodyStatus,
      safeMethodsSet,
      requestBodyHeader,
      subresourceSet,
      DOMException: DOMException2
    } = require_constants2();
    var { kHeadersList } = require_symbols();
    var EE = __require("events");
    var { Readable, pipeline } = __require("stream");
    var { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = require_util();
    var { dataURLProcessor, serializeAMimeType } = require_dataURL();
    var { TransformStream } = __require("stream/web");
    var { getGlobalDispatcher } = require_global2();
    var { webidl } = require_webidl();
    var { STATUS_CODES } = __require("http");
    var GET_OR_HEAD = ["GET", "HEAD"];
    var resolveObjectURL;
    var ReadableStream = globalThis.ReadableStream;
    var Fetch = class extends EE {
      constructor(dispatcher) {
        super();
        this.dispatcher = dispatcher;
        this.connection = null;
        this.dump = false;
        this.state = "ongoing";
        this.setMaxListeners(21);
      }
      terminate(reason) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "terminated";
        this.connection?.destroy(reason);
        this.emit("terminated", reason);
      }
      // https://fetch.spec.whatwg.org/#fetch-controller-abort
      abort(error) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "aborted";
        if (!error) {
          error = new DOMException2("The operation was aborted.", "AbortError");
        }
        this.serializedAbortReason = error;
        this.connection?.destroy(error);
        this.emit("terminated", error);
      }
    };
    function fetch2(input, init = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
      const p = createDeferredPromise();
      let requestObject;
      try {
        requestObject = new Request(input, init);
      } catch (e) {
        p.reject(e);
        return p.promise;
      }
      const request = requestObject[kState];
      if (requestObject.signal.aborted) {
        abortFetch(p, request, null, requestObject.signal.reason);
        return p.promise;
      }
      const globalObject = request.client.globalObject;
      if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
        request.serviceWorkers = "none";
      }
      let responseObject = null;
      const relevantRealm = null;
      let locallyAborted = false;
      let controller = null;
      addAbortListener(
        requestObject.signal,
        () => {
          locallyAborted = true;
          assert(controller != null);
          controller.abort(requestObject.signal.reason);
          abortFetch(p, request, responseObject, requestObject.signal.reason);
        }
      );
      const handleFetchDone = (response) => finalizeAndReportTiming(response, "fetch");
      const processResponse = (response) => {
        if (locallyAborted) {
          return Promise.resolve();
        }
        if (response.aborted) {
          abortFetch(p, request, responseObject, controller.serializedAbortReason);
          return Promise.resolve();
        }
        if (response.type === "error") {
          p.reject(
            Object.assign(new TypeError("fetch failed"), { cause: response.error })
          );
          return Promise.resolve();
        }
        responseObject = new Response();
        responseObject[kState] = response;
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = response.headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        p.resolve(responseObject);
      };
      controller = fetching({
        request,
        processResponseEndOfBody: handleFetchDone,
        processResponse,
        dispatcher: init.dispatcher ?? getGlobalDispatcher()
        // undici
      });
      return p.promise;
    }
    function finalizeAndReportTiming(response, initiatorType = "other") {
      if (response.type === "error" && response.aborted) {
        return;
      }
      if (!response.urlList?.length) {
        return;
      }
      const originalURL = response.urlList[0];
      let timingInfo = response.timingInfo;
      let cacheState = response.cacheState;
      if (!urlIsHttpHttpsScheme(originalURL)) {
        return;
      }
      if (timingInfo === null) {
        return;
      }
      if (!response.timingAllowPassed) {
        timingInfo = createOpaqueTimingInfo({
          startTime: timingInfo.startTime
        });
        cacheState = "";
      }
      timingInfo.endTime = coarsenedSharedCurrentTime();
      response.timingInfo = timingInfo;
      markResourceTiming(
        timingInfo,
        originalURL,
        initiatorType,
        globalThis,
        cacheState
      );
    }
    function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {
      if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2) {
        performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis2, cacheState);
      }
    }
    function abortFetch(p, request, responseObject, error) {
      if (!error) {
        error = new DOMException2("The operation was aborted.", "AbortError");
      }
      p.reject(error);
      if (request.body != null && isReadable(request.body?.stream)) {
        request.body.stream.cancel(error).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
      if (responseObject == null) {
        return;
      }
      const response = responseObject[kState];
      if (response.body != null && isReadable(response.body?.stream)) {
        response.body.stream.cancel(error).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
    }
    function fetching({
      request,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseEndOfBody,
      processResponseConsumeBody,
      useParallelQueue = false,
      dispatcher
      // undici
    }) {
      let taskDestination = null;
      let crossOriginIsolatedCapability = false;
      if (request.client != null) {
        taskDestination = request.client.globalObject;
        crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
      }
      const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
      const timingInfo = createOpaqueTimingInfo({
        startTime: currenTime
      });
      const fetchParams = {
        controller: new Fetch(dispatcher),
        request,
        timingInfo,
        processRequestBodyChunkLength,
        processRequestEndOfBody,
        processResponse,
        processResponseConsumeBody,
        processResponseEndOfBody,
        taskDestination,
        crossOriginIsolatedCapability
      };
      assert(!request.body || request.body.stream);
      if (request.window === "client") {
        request.window = request.client?.globalObject?.constructor?.name === "Window" ? request.client : "no-window";
      }
      if (request.origin === "client") {
        request.origin = request.client?.origin;
      }
      if (request.policyContainer === "client") {
        if (request.client != null) {
          request.policyContainer = clonePolicyContainer(
            request.client.policyContainer
          );
        } else {
          request.policyContainer = makePolicyContainer();
        }
      }
      if (!request.headersList.contains("accept")) {
        const value = "*/*";
        request.headersList.append("accept", value);
      }
      if (!request.headersList.contains("accept-language")) {
        request.headersList.append("accept-language", "*");
      }
      if (request.priority === null) {
      }
      if (subresourceSet.has(request.destination)) {
      }
      mainFetch(fetchParams).catch((err) => {
        fetchParams.controller.terminate(err);
      });
      return fetchParams.controller;
    }
    async function mainFetch(fetchParams, recursive = false) {
      const request = fetchParams.request;
      let response = null;
      if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
        response = makeNetworkError("local URLs only");
      }
      tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
      if (requestBadPort(request) === "blocked") {
        response = makeNetworkError("bad port");
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = request.policyContainer.referrerPolicy;
      }
      if (request.referrer !== "no-referrer") {
        request.referrer = determineRequestsReferrer(request);
      }
      if (response === null) {
        response = await (async () => {
          const currentURL = requestCurrentURL(request);
          if (
            // - requests current URLs origin is same origin with requests origin,
            //   and requests response tainting is "basic"
            sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || // requests current URLs scheme is "data"
            currentURL.protocol === "data:" || // - requests mode is "navigate" or "websocket"
            (request.mode === "navigate" || request.mode === "websocket")
          ) {
            request.responseTainting = "basic";
            return await schemeFetch(fetchParams);
          }
          if (request.mode === "same-origin") {
            return makeNetworkError('request mode cannot be "same-origin"');
          }
          if (request.mode === "no-cors") {
            if (request.redirect !== "follow") {
              return makeNetworkError(
                'redirect mode cannot be "follow" for "no-cors" request'
              );
            }
            request.responseTainting = "opaque";
            return await schemeFetch(fetchParams);
          }
          if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
            return makeNetworkError("URL scheme must be a HTTP(S) scheme");
          }
          request.responseTainting = "cors";
          return await httpFetch(fetchParams);
        })();
      }
      if (recursive) {
        return response;
      }
      if (response.status !== 0 && !response.internalResponse) {
        if (request.responseTainting === "cors") {
        }
        if (request.responseTainting === "basic") {
          response = filterResponse(response, "basic");
        } else if (request.responseTainting === "cors") {
          response = filterResponse(response, "cors");
        } else if (request.responseTainting === "opaque") {
          response = filterResponse(response, "opaque");
        } else {
          assert(false);
        }
      }
      let internalResponse = response.status === 0 ? response : response.internalResponse;
      if (internalResponse.urlList.length === 0) {
        internalResponse.urlList.push(...request.urlList);
      }
      if (!request.timingAllowFailed) {
        response.timingAllowPassed = true;
      }
      if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains("range")) {
        response = internalResponse = makeNetworkError();
      }
      if (response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
        internalResponse.body = null;
        fetchParams.controller.dump = true;
      }
      if (request.integrity) {
        const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
        if (request.responseTainting === "opaque" || response.body == null) {
          processBodyError(response.error);
          return;
        }
        const processBody = (bytes) => {
          if (!bytesMatch(bytes, request.integrity)) {
            processBodyError("integrity mismatch");
            return;
          }
          response.body = safelyExtractBody(bytes)[0];
          fetchFinale(fetchParams, response);
        };
        await fullyReadBody(response.body, processBody, processBodyError);
      } else {
        fetchFinale(fetchParams, response);
      }
    }
    function schemeFetch(fetchParams) {
      if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
        return Promise.resolve(makeAppropriateNetworkError(fetchParams));
      }
      const { request } = fetchParams;
      const { protocol: scheme } = requestCurrentURL(request);
      switch (scheme) {
        case "about:": {
          return Promise.resolve(makeNetworkError("about scheme is not supported"));
        }
        case "blob:": {
          if (!resolveObjectURL) {
            resolveObjectURL = __require("buffer").resolveObjectURL;
          }
          const blobURLEntry = requestCurrentURL(request);
          if (blobURLEntry.search.length !== 0) {
            return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
          }
          const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
          if (request.method !== "GET" || !isBlobLike(blobURLEntryObject)) {
            return Promise.resolve(makeNetworkError("invalid method"));
          }
          const bodyWithType = safelyExtractBody(blobURLEntryObject);
          const body = bodyWithType[0];
          const length = isomorphicEncode(`${body.length}`);
          const type = bodyWithType[1] ?? "";
          const response = makeResponse({
            statusText: "OK",
            headersList: [
              ["content-length", { name: "Content-Length", value: length }],
              ["content-type", { name: "Content-Type", value: type }]
            ]
          });
          response.body = body;
          return Promise.resolve(response);
        }
        case "data:": {
          const currentURL = requestCurrentURL(request);
          const dataURLStruct = dataURLProcessor(currentURL);
          if (dataURLStruct === "failure") {
            return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
          }
          const mimeType = serializeAMimeType(dataURLStruct.mimeType);
          return Promise.resolve(makeResponse({
            statusText: "OK",
            headersList: [
              ["content-type", { name: "Content-Type", value: mimeType }]
            ],
            body: safelyExtractBody(dataURLStruct.body)[0]
          }));
        }
        case "file:": {
          return Promise.resolve(makeNetworkError("not implemented... yet..."));
        }
        case "http:":
        case "https:": {
          return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
        }
        default: {
          return Promise.resolve(makeNetworkError("unknown scheme"));
        }
      }
    }
    function finalizeResponse(fetchParams, response) {
      fetchParams.request.done = true;
      if (fetchParams.processResponseDone != null) {
        queueMicrotask(() => fetchParams.processResponseDone(response));
      }
    }
    function fetchFinale(fetchParams, response) {
      if (response.type === "error") {
        response.urlList = [fetchParams.request.urlList[0]];
        response.timingInfo = createOpaqueTimingInfo({
          startTime: fetchParams.timingInfo.startTime
        });
      }
      const processResponseEndOfBody = () => {
        fetchParams.request.done = true;
        if (fetchParams.processResponseEndOfBody != null) {
          queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
        }
      };
      if (fetchParams.processResponse != null) {
        queueMicrotask(() => fetchParams.processResponse(response));
      }
      if (response.body == null) {
        processResponseEndOfBody();
      } else {
        const identityTransformAlgorithm = (chunk, controller) => {
          controller.enqueue(chunk);
        };
        const transformStream = new TransformStream({
          start() {
          },
          transform: identityTransformAlgorithm,
          flush: processResponseEndOfBody
        }, {
          size() {
            return 1;
          }
        }, {
          size() {
            return 1;
          }
        });
        response.body = { stream: response.body.stream.pipeThrough(transformStream) };
      }
      if (fetchParams.processResponseConsumeBody != null) {
        const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);
        const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);
        if (response.body == null) {
          queueMicrotask(() => processBody(null));
        } else {
          return fullyReadBody(response.body, processBody, processBodyError);
        }
        return Promise.resolve();
      }
    }
    async function httpFetch(fetchParams) {
      const request = fetchParams.request;
      let response = null;
      let actualResponse = null;
      const timingInfo = fetchParams.timingInfo;
      if (request.serviceWorkers === "all") {
      }
      if (response === null) {
        if (request.redirect === "follow") {
          request.serviceWorkers = "none";
        }
        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
        if (request.responseTainting === "cors" && corsCheck(request, response) === "failure") {
          return makeNetworkError("cors failure");
        }
        if (TAOCheck(request, response) === "failure") {
          request.timingAllowFailed = true;
        }
      }
      if ((request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(
        request.origin,
        request.client,
        request.destination,
        actualResponse
      ) === "blocked") {
        return makeNetworkError("blocked");
      }
      if (redirectStatusSet.has(actualResponse.status)) {
        if (request.redirect !== "manual") {
          fetchParams.controller.connection.destroy();
        }
        if (request.redirect === "error") {
          response = makeNetworkError("unexpected redirect");
        } else if (request.redirect === "manual") {
          response = actualResponse;
        } else if (request.redirect === "follow") {
          response = await httpRedirectFetch(fetchParams, response);
        } else {
          assert(false);
        }
      }
      response.timingInfo = timingInfo;
      return response;
    }
    function httpRedirectFetch(fetchParams, response) {
      const request = fetchParams.request;
      const actualResponse = response.internalResponse ? response.internalResponse : response;
      let locationURL;
      try {
        locationURL = responseLocationURL(
          actualResponse,
          requestCurrentURL(request).hash
        );
        if (locationURL == null) {
          return response;
        }
      } catch (err) {
        return Promise.resolve(makeNetworkError(err));
      }
      if (!urlIsHttpHttpsScheme(locationURL)) {
        return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
      }
      if (request.redirectCount === 20) {
        return Promise.resolve(makeNetworkError("redirect count exceeded"));
      }
      request.redirectCount += 1;
      if (request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {
        return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
      }
      if (request.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
        return Promise.resolve(makeNetworkError(
          'URL cannot contain credentials for request mode "cors"'
        ));
      }
      if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {
        return Promise.resolve(makeNetworkError());
      }
      if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {
        request.method = "GET";
        request.body = null;
        for (const headerName of requestBodyHeader) {
          request.headersList.delete(headerName);
        }
      }
      if (!sameOrigin(requestCurrentURL(request), locationURL)) {
        request.headersList.delete("authorization");
        request.headersList.delete("proxy-authorization", true);
        request.headersList.delete("cookie");
        request.headersList.delete("host");
      }
      if (request.body != null) {
        assert(request.body.source != null);
        request.body = safelyExtractBody(request.body.source)[0];
      }
      const timingInfo = fetchParams.timingInfo;
      timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
      if (timingInfo.redirectStartTime === 0) {
        timingInfo.redirectStartTime = timingInfo.startTime;
      }
      request.urlList.push(locationURL);
      setRequestReferrerPolicyOnRedirect(request, actualResponse);
      return mainFetch(fetchParams, true);
    }
    async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
      const request = fetchParams.request;
      let httpFetchParams = null;
      let httpRequest = null;
      let response = null;
      const httpCache = null;
      const revalidatingFlag = false;
      if (request.window === "no-window" && request.redirect === "error") {
        httpFetchParams = fetchParams;
        httpRequest = request;
      } else {
        httpRequest = makeRequest(request);
        httpFetchParams = { ...fetchParams };
        httpFetchParams.request = httpRequest;
      }
      const includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic";
      const contentLength = httpRequest.body ? httpRequest.body.length : null;
      let contentLengthHeaderValue = null;
      if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
        contentLengthHeaderValue = "0";
      }
      if (contentLength != null) {
        contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
      }
      if (contentLengthHeaderValue != null) {
        httpRequest.headersList.append("content-length", contentLengthHeaderValue);
      }
      if (contentLength != null && httpRequest.keepalive) {
      }
      if (httpRequest.referrer instanceof URL) {
        httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href));
      }
      appendRequestOriginHeader(httpRequest);
      appendFetchMetadata(httpRequest);
      if (!httpRequest.headersList.contains("user-agent")) {
        httpRequest.headersList.append("user-agent", typeof esbuildDetection === "undefined" ? "undici" : "node");
      }
      if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since") || httpRequest.headersList.contains("if-none-match") || httpRequest.headersList.contains("if-unmodified-since") || httpRequest.headersList.contains("if-match") || httpRequest.headersList.contains("if-range"))) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control")) {
        httpRequest.headersList.append("cache-control", "max-age=0");
      }
      if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
        if (!httpRequest.headersList.contains("pragma")) {
          httpRequest.headersList.append("pragma", "no-cache");
        }
        if (!httpRequest.headersList.contains("cache-control")) {
          httpRequest.headersList.append("cache-control", "no-cache");
        }
      }
      if (httpRequest.headersList.contains("range")) {
        httpRequest.headersList.append("accept-encoding", "identity");
      }
      if (!httpRequest.headersList.contains("accept-encoding")) {
        if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
          httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
        } else {
          httpRequest.headersList.append("accept-encoding", "gzip, deflate");
        }
      }
      httpRequest.headersList.delete("host");
      if (includeCredentials) {
      }
      if (httpCache == null) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") {
      }
      if (response == null) {
        if (httpRequest.mode === "only-if-cached") {
          return makeNetworkError("only if cached");
        }
        const forwardResponse = await httpNetworkFetch(
          httpFetchParams,
          includeCredentials,
          isNewConnectionFetch
        );
        if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {
        }
        if (revalidatingFlag && forwardResponse.status === 304) {
        }
        if (response == null) {
          response = forwardResponse;
        }
      }
      response.urlList = [...httpRequest.urlList];
      if (httpRequest.headersList.contains("range")) {
        response.rangeRequested = true;
      }
      response.requestIncludesCredentials = includeCredentials;
      if (response.status === 407) {
        if (request.window === "no-window") {
          return makeNetworkError();
        }
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        return makeNetworkError("proxy authentication required");
      }
      if (
        // responses status is 421
        response.status === 421 && // isNewConnectionFetch is false
        !isNewConnectionFetch && // requests body is null, or requests body is non-null and requests bodys source is non-null
        (request.body == null || request.body.source != null)
      ) {
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        fetchParams.controller.connection.destroy();
        response = await httpNetworkOrCacheFetch(
          fetchParams,
          isAuthenticationFetch,
          true
        );
      }
      if (isAuthenticationFetch) {
      }
      return response;
    }
    async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
      assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
      fetchParams.controller.connection = {
        abort: null,
        destroyed: false,
        destroy(err) {
          if (!this.destroyed) {
            this.destroyed = true;
            this.abort?.(err ?? new DOMException2("The operation was aborted.", "AbortError"));
          }
        }
      };
      const request = fetchParams.request;
      let response = null;
      const timingInfo = fetchParams.timingInfo;
      const httpCache = null;
      if (httpCache == null) {
        request.cache = "no-store";
      }
      const newConnection = forceNewConnection ? "yes" : "no";
      if (request.mode === "websocket") {
      } else {
      }
      let requestBody = null;
      if (request.body == null && fetchParams.processRequestEndOfBody) {
        queueMicrotask(() => fetchParams.processRequestEndOfBody());
      } else if (request.body != null) {
        const processBodyChunk = async function* (bytes) {
          if (isCancelled(fetchParams)) {
            return;
          }
          yield bytes;
          fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
        };
        const processEndOfBody = () => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (fetchParams.processRequestEndOfBody) {
            fetchParams.processRequestEndOfBody();
          }
        };
        const processBodyError = (e) => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (e.name === "AbortError") {
            fetchParams.controller.abort();
          } else {
            fetchParams.controller.terminate(e);
          }
        };
        requestBody = (async function* () {
          try {
            for await (const bytes of request.body.stream) {
              yield* processBodyChunk(bytes);
            }
            processEndOfBody();
          } catch (err) {
            processBodyError(err);
          }
        })();
      }
      try {
        const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
        if (socket) {
          response = makeResponse({ status, statusText, headersList, socket });
        } else {
          const iterator = body[Symbol.asyncIterator]();
          fetchParams.controller.next = () => iterator.next();
          response = makeResponse({ status, statusText, headersList });
        }
      } catch (err) {
        if (err.name === "AbortError") {
          fetchParams.controller.connection.destroy();
          return makeAppropriateNetworkError(fetchParams, err);
        }
        return makeNetworkError(err);
      }
      const pullAlgorithm = () => {
        fetchParams.controller.resume();
      };
      const cancelAlgorithm = (reason) => {
        fetchParams.controller.abort(reason);
      };
      if (!ReadableStream) {
        ReadableStream = __require("stream/web").ReadableStream;
      }
      const stream = new ReadableStream(
        {
          async start(controller) {
            fetchParams.controller.controller = controller;
          },
          async pull(controller) {
            await pullAlgorithm(controller);
          },
          async cancel(reason) {
            await cancelAlgorithm(reason);
          }
        },
        {
          highWaterMark: 0,
          size() {
            return 1;
          }
        }
      );
      response.body = { stream };
      fetchParams.controller.on("terminated", onAborted);
      fetchParams.controller.resume = async () => {
        while (true) {
          let bytes;
          let isFailure;
          try {
            const { done, value } = await fetchParams.controller.next();
            if (isAborted(fetchParams)) {
              break;
            }
            bytes = done ? void 0 : value;
          } catch (err) {
            if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
              bytes = void 0;
            } else {
              bytes = err;
              isFailure = true;
            }
          }
          if (bytes === void 0) {
            readableStreamClose(fetchParams.controller.controller);
            finalizeResponse(fetchParams, response);
            return;
          }
          timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
          if (isFailure) {
            fetchParams.controller.terminate(bytes);
            return;
          }
          fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
          if (isErrored(stream)) {
            fetchParams.controller.terminate();
            return;
          }
          if (!fetchParams.controller.controller.desiredSize) {
            return;
          }
        }
      };
      function onAborted(reason) {
        if (isAborted(fetchParams)) {
          response.aborted = true;
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(
              fetchParams.controller.serializedAbortReason
            );
          }
        } else {
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(new TypeError("terminated", {
              cause: isErrorLike(reason) ? reason : void 0
            }));
          }
        }
        fetchParams.controller.connection.destroy();
      }
      return response;
      async function dispatch({ body }) {
        const url = requestCurrentURL(request);
        const agent = fetchParams.controller.dispatcher;
        return new Promise((resolve5, reject) => agent.dispatch(
          {
            path: url.pathname + url.search,
            origin: url.origin,
            method: request.method,
            body: fetchParams.controller.dispatcher.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
            headers: request.headersList.entries,
            maxRedirections: 0,
            upgrade: request.mode === "websocket" ? "websocket" : void 0
          },
          {
            body: null,
            abort: null,
            onConnect(abort) {
              const { connection } = fetchParams.controller;
              if (connection.destroyed) {
                abort(new DOMException2("The operation was aborted.", "AbortError"));
              } else {
                fetchParams.controller.on("terminated", abort);
                this.abort = connection.abort = abort;
              }
            },
            onHeaders(status, headersList, resume, statusText) {
              if (status < 200) {
                return;
              }
              let codings = [];
              let location = "";
              const headers = new Headers();
              if (Array.isArray(headersList)) {
                for (let n = 0; n < headersList.length; n += 2) {
                  const key = headersList[n + 0].toString("latin1");
                  const val = headersList[n + 1].toString("latin1");
                  if (key.toLowerCase() === "content-encoding") {
                    codings = val.toLowerCase().split(",").map((x) => x.trim());
                  } else if (key.toLowerCase() === "location") {
                    location = val;
                  }
                  headers[kHeadersList].append(key, val);
                }
              } else {
                const keys = Object.keys(headersList);
                for (const key of keys) {
                  const val = headersList[key];
                  if (key.toLowerCase() === "content-encoding") {
                    codings = val.toLowerCase().split(",").map((x) => x.trim()).reverse();
                  } else if (key.toLowerCase() === "location") {
                    location = val;
                  }
                  headers[kHeadersList].append(key, val);
                }
              }
              this.body = new Readable({ read: resume });
              const decoders = [];
              const willFollow = request.redirect === "follow" && location && redirectStatusSet.has(status);
              if (request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
                for (const coding of codings) {
                  if (coding === "x-gzip" || coding === "gzip") {
                    decoders.push(zlib.createGunzip({
                      // Be less strict when decoding compressed responses, since sometimes
                      // servers send slightly invalid responses that are still accepted
                      // by common browsers.
                      // Always using Z_SYNC_FLUSH is what cURL does.
                      flush: zlib.constants.Z_SYNC_FLUSH,
                      finishFlush: zlib.constants.Z_SYNC_FLUSH
                    }));
                  } else if (coding === "deflate") {
                    decoders.push(zlib.createInflate());
                  } else if (coding === "br") {
                    decoders.push(zlib.createBrotliDecompress());
                  } else {
                    decoders.length = 0;
                    break;
                  }
                }
              }
              resolve5({
                status,
                statusText,
                headersList: headers[kHeadersList],
                body: decoders.length ? pipeline(this.body, ...decoders, () => {
                }) : this.body.on("error", () => {
                })
              });
              return true;
            },
            onData(chunk) {
              if (fetchParams.controller.dump) {
                return;
              }
              const bytes = chunk;
              timingInfo.encodedBodySize += bytes.byteLength;
              return this.body.push(bytes);
            },
            onComplete() {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              fetchParams.controller.ended = true;
              this.body.push(null);
            },
            onError(error) {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              this.body?.destroy(error);
              fetchParams.controller.terminate(error);
              reject(error);
            },
            onUpgrade(status, headersList, socket) {
              if (status !== 101) {
                return;
              }
              const headers = new Headers();
              for (let n = 0; n < headersList.length; n += 2) {
                const key = headersList[n + 0].toString("latin1");
                const val = headersList[n + 1].toString("latin1");
                headers[kHeadersList].append(key, val);
              }
              resolve5({
                status,
                statusText: STATUS_CODES[status],
                headersList: headers[kHeadersList],
                socket
              });
              return true;
            }
          }
        ));
      }
    }
    module.exports = {
      fetch: fetch2,
      Fetch,
      fetching,
      finalizeAndReportTiming
    };
  }
});

// node_modules/undici/lib/fileapi/symbols.js
var require_symbols3 = __commonJS({
  "node_modules/undici/lib/fileapi/symbols.js"(exports, module) {
    "use strict";
    module.exports = {
      kState: /* @__PURE__ */ Symbol("FileReader state"),
      kResult: /* @__PURE__ */ Symbol("FileReader result"),
      kError: /* @__PURE__ */ Symbol("FileReader error"),
      kLastProgressEventFired: /* @__PURE__ */ Symbol("FileReader last progress event fired timestamp"),
      kEvents: /* @__PURE__ */ Symbol("FileReader events"),
      kAborted: /* @__PURE__ */ Symbol("FileReader aborted")
    };
  }
});

// node_modules/undici/lib/fileapi/progressevent.js
var require_progressevent = __commonJS({
  "node_modules/undici/lib/fileapi/progressevent.js"(exports, module) {
    "use strict";
    var { webidl } = require_webidl();
    var kState = /* @__PURE__ */ Symbol("ProgressEvent state");
    var ProgressEvent = class _ProgressEvent extends Event {
      constructor(type, eventInitDict = {}) {
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
        super(type, eventInitDict);
        this[kState] = {
          lengthComputable: eventInitDict.lengthComputable,
          loaded: eventInitDict.loaded,
          total: eventInitDict.total
        };
      }
      get lengthComputable() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].lengthComputable;
      }
      get loaded() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].loaded;
      }
      get total() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].total;
      }
    };
    webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
      {
        key: "lengthComputable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "loaded",
        converter: webidl.converters["unsigned long long"],
        defaultValue: 0
      },
      {
        key: "total",
        converter: webidl.converters["unsigned long long"],
        defaultValue: 0
      },
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ]);
    module.exports = {
      ProgressEvent
    };
  }
});

// node_modules/undici/lib/fileapi/encoding.js
var require_encoding = __commonJS({
  "node_modules/undici/lib/fileapi/encoding.js"(exports, module) {
    "use strict";
    function getEncoding(label) {
      if (!label) {
        return "failure";
      }
      switch (label.trim().toLowerCase()) {
        case "unicode-1-1-utf-8":
        case "unicode11utf8":
        case "unicode20utf8":
        case "utf-8":
        case "utf8":
        case "x-unicode20utf8":
          return "UTF-8";
        case "866":
        case "cp866":
        case "csibm866":
        case "ibm866":
          return "IBM866";
        case "csisolatin2":
        case "iso-8859-2":
        case "iso-ir-101":
        case "iso8859-2":
        case "iso88592":
        case "iso_8859-2":
        case "iso_8859-2:1987":
        case "l2":
        case "latin2":
          return "ISO-8859-2";
        case "csisolatin3":
        case "iso-8859-3":
        case "iso-ir-109":
        case "iso8859-3":
        case "iso88593":
        case "iso_8859-3":
        case "iso_8859-3:1988":
        case "l3":
        case "latin3":
          return "ISO-8859-3";
        case "csisolatin4":
        case "iso-8859-4":
        case "iso-ir-110":
        case "iso8859-4":
        case "iso88594":
        case "iso_8859-4":
        case "iso_8859-4:1988":
        case "l4":
        case "latin4":
          return "ISO-8859-4";
        case "csisolatincyrillic":
        case "cyrillic":
        case "iso-8859-5":
        case "iso-ir-144":
        case "iso8859-5":
        case "iso88595":
        case "iso_8859-5":
        case "iso_8859-5:1988":
          return "ISO-8859-5";
        case "arabic":
        case "asmo-708":
        case "csiso88596e":
        case "csiso88596i":
        case "csisolatinarabic":
        case "ecma-114":
        case "iso-8859-6":
        case "iso-8859-6-e":
        case "iso-8859-6-i":
        case "iso-ir-127":
        case "iso8859-6":
        case "iso88596":
        case "iso_8859-6":
        case "iso_8859-6:1987":
          return "ISO-8859-6";
        case "csisolatingreek":
        case "ecma-118":
        case "elot_928":
        case "greek":
        case "greek8":
        case "iso-8859-7":
        case "iso-ir-126":
        case "iso8859-7":
        case "iso88597":
        case "iso_8859-7":
        case "iso_8859-7:1987":
        case "sun_eu_greek":
          return "ISO-8859-7";
        case "csiso88598e":
        case "csisolatinhebrew":
        case "hebrew":
        case "iso-8859-8":
        case "iso-8859-8-e":
        case "iso-ir-138":
        case "iso8859-8":
        case "iso88598":
        case "iso_8859-8":
        case "iso_8859-8:1988":
        case "visual":
          return "ISO-8859-8";
        case "csiso88598i":
        case "iso-8859-8-i":
        case "logical":
          return "ISO-8859-8-I";
        case "csisolatin6":
        case "iso-8859-10":
        case "iso-ir-157":
        case "iso8859-10":
        case "iso885910":
        case "l6":
        case "latin6":
          return "ISO-8859-10";
        case "iso-8859-13":
        case "iso8859-13":
        case "iso885913":
          return "ISO-8859-13";
        case "iso-8859-14":
        case "iso8859-14":
        case "iso885914":
          return "ISO-8859-14";
        case "csisolatin9":
        case "iso-8859-15":
        case "iso8859-15":
        case "iso885915":
        case "iso_8859-15":
        case "l9":
          return "ISO-8859-15";
        case "iso-8859-16":
          return "ISO-8859-16";
        case "cskoi8r":
        case "koi":
        case "koi8":
        case "koi8-r":
        case "koi8_r":
          return "KOI8-R";
        case "koi8-ru":
        case "koi8-u":
          return "KOI8-U";
        case "csmacintosh":
        case "mac":
        case "macintosh":
        case "x-mac-roman":
          return "macintosh";
        case "iso-8859-11":
        case "iso8859-11":
        case "iso885911":
        case "tis-620":
        case "windows-874":
          return "windows-874";
        case "cp1250":
        case "windows-1250":
        case "x-cp1250":
          return "windows-1250";
        case "cp1251":
        case "windows-1251":
        case "x-cp1251":
          return "windows-1251";
        case "ansi_x3.4-1968":
        case "ascii":
        case "cp1252":
        case "cp819":
        case "csisolatin1":
        case "ibm819":
        case "iso-8859-1":
        case "iso-ir-100":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "iso_8859-1:1987":
        case "l1":
        case "latin1":
        case "us-ascii":
        case "windows-1252":
        case "x-cp1252":
          return "windows-1252";
        case "cp1253":
        case "windows-1253":
        case "x-cp1253":
          return "windows-1253";
        case "cp1254":
        case "csisolatin5":
        case "iso-8859-9":
        case "iso-ir-148":
        case "iso8859-9":
        case "iso88599":
        case "iso_8859-9":
        case "iso_8859-9:1989":
        case "l5":
        case "latin5":
        case "windows-1254":
        case "x-cp1254":
          return "windows-1254";
        case "cp1255":
        case "windows-1255":
        case "x-cp1255":
          return "windows-1255";
        case "cp1256":
        case "windows-1256":
        case "x-cp1256":
          return "windows-1256";
        case "cp1257":
        case "windows-1257":
        case "x-cp1257":
          return "windows-1257";
        case "cp1258":
        case "windows-1258":
        case "x-cp1258":
          return "windows-1258";
        case "x-mac-cyrillic":
        case "x-mac-ukrainian":
          return "x-mac-cyrillic";
        case "chinese":
        case "csgb2312":
        case "csiso58gb231280":
        case "gb2312":
        case "gb_2312":
        case "gb_2312-80":
        case "gbk":
        case "iso-ir-58":
        case "x-gbk":
          return "GBK";
        case "gb18030":
          return "gb18030";
        case "big5":
        case "big5-hkscs":
        case "cn-big5":
        case "csbig5":
        case "x-x-big5":
          return "Big5";
        case "cseucpkdfmtjapanese":
        case "euc-jp":
        case "x-euc-jp":
          return "EUC-JP";
        case "csiso2022jp":
        case "iso-2022-jp":
          return "ISO-2022-JP";
        case "csshiftjis":
        case "ms932":
        case "ms_kanji":
        case "shift-jis":
        case "shift_jis":
        case "sjis":
        case "windows-31j":
        case "x-sjis":
          return "Shift_JIS";
        case "cseuckr":
        case "csksc56011987":
        case "euc-kr":
        case "iso-ir-149":
        case "korean":
        case "ks_c_5601-1987":
        case "ks_c_5601-1989":
        case "ksc5601":
        case "ksc_5601":
        case "windows-949":
          return "EUC-KR";
        case "csiso2022kr":
        case "hz-gb-2312":
        case "iso-2022-cn":
        case "iso-2022-cn-ext":
        case "iso-2022-kr":
        case "replacement":
          return "replacement";
        case "unicodefffe":
        case "utf-16be":
          return "UTF-16BE";
        case "csunicode":
        case "iso-10646-ucs-2":
        case "ucs-2":
        case "unicode":
        case "unicodefeff":
        case "utf-16":
        case "utf-16le":
          return "UTF-16LE";
        case "x-user-defined":
          return "x-user-defined";
        default:
          return "failure";
      }
    }
    module.exports = {
      getEncoding
    };
  }
});

// node_modules/undici/lib/fileapi/util.js
var require_util4 = __commonJS({
  "node_modules/undici/lib/fileapi/util.js"(exports, module) {
    "use strict";
    var {
      kState,
      kError,
      kResult,
      kAborted,
      kLastProgressEventFired
    } = require_symbols3();
    var { ProgressEvent } = require_progressevent();
    var { getEncoding } = require_encoding();
    var { DOMException: DOMException2 } = require_constants2();
    var { serializeAMimeType, parseMIMEType } = require_dataURL();
    var { types } = __require("util");
    var { StringDecoder } = __require("string_decoder");
    var { btoa } = __require("buffer");
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    function readOperation(fr, blob, type, encodingName) {
      if (fr[kState] === "loading") {
        throw new DOMException2("Invalid state", "InvalidStateError");
      }
      fr[kState] = "loading";
      fr[kResult] = null;
      fr[kError] = null;
      const stream = blob.stream();
      const reader = stream.getReader();
      const bytes = [];
      let chunkPromise = reader.read();
      let isFirstChunk = true;
      (async () => {
        while (!fr[kAborted]) {
          try {
            const { done, value } = await chunkPromise;
            if (isFirstChunk && !fr[kAborted]) {
              queueMicrotask(() => {
                fireAProgressEvent("loadstart", fr);
              });
            }
            isFirstChunk = false;
            if (!done && types.isUint8Array(value)) {
              bytes.push(value);
              if ((fr[kLastProgressEventFired] === void 0 || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {
                fr[kLastProgressEventFired] = Date.now();
                queueMicrotask(() => {
                  fireAProgressEvent("progress", fr);
                });
              }
              chunkPromise = reader.read();
            } else if (done) {
              queueMicrotask(() => {
                fr[kState] = "done";
                try {
                  const result = packageData(bytes, type, blob.type, encodingName);
                  if (fr[kAborted]) {
                    return;
                  }
                  fr[kResult] = result;
                  fireAProgressEvent("load", fr);
                } catch (error) {
                  fr[kError] = error;
                  fireAProgressEvent("error", fr);
                }
                if (fr[kState] !== "loading") {
                  fireAProgressEvent("loadend", fr);
                }
              });
              break;
            }
          } catch (error) {
            if (fr[kAborted]) {
              return;
            }
            queueMicrotask(() => {
              fr[kState] = "done";
              fr[kError] = error;
              fireAProgressEvent("error", fr);
              if (fr[kState] !== "loading") {
                fireAProgressEvent("loadend", fr);
              }
            });
            break;
          }
        }
      })();
    }
    function fireAProgressEvent(e, reader) {
      const event = new ProgressEvent(e, {
        bubbles: false,
        cancelable: false
      });
      reader.dispatchEvent(event);
    }
    function packageData(bytes, type, mimeType, encodingName) {
      switch (type) {
        case "DataURL": {
          let dataURL = "data:";
          const parsed = parseMIMEType(mimeType || "application/octet-stream");
          if (parsed !== "failure") {
            dataURL += serializeAMimeType(parsed);
          }
          dataURL += ";base64,";
          const decoder = new StringDecoder("latin1");
          for (const chunk of bytes) {
            dataURL += btoa(decoder.write(chunk));
          }
          dataURL += btoa(decoder.end());
          return dataURL;
        }
        case "Text": {
          let encoding = "failure";
          if (encodingName) {
            encoding = getEncoding(encodingName);
          }
          if (encoding === "failure" && mimeType) {
            const type2 = parseMIMEType(mimeType);
            if (type2 !== "failure") {
              encoding = getEncoding(type2.parameters.get("charset"));
            }
          }
          if (encoding === "failure") {
            encoding = "UTF-8";
          }
          return decode(bytes, encoding);
        }
        case "ArrayBuffer": {
          const sequence = combineByteSequences(bytes);
          return sequence.buffer;
        }
        case "BinaryString": {
          let binaryString = "";
          const decoder = new StringDecoder("latin1");
          for (const chunk of bytes) {
            binaryString += decoder.write(chunk);
          }
          binaryString += decoder.end();
          return binaryString;
        }
      }
    }
    function decode(ioQueue, encoding) {
      const bytes = combineByteSequences(ioQueue);
      const BOMEncoding = BOMSniffing(bytes);
      let slice = 0;
      if (BOMEncoding !== null) {
        encoding = BOMEncoding;
        slice = BOMEncoding === "UTF-8" ? 3 : 2;
      }
      const sliced = bytes.slice(slice);
      return new TextDecoder(encoding).decode(sliced);
    }
    function BOMSniffing(ioQueue) {
      const [a, b, c] = ioQueue;
      if (a === 239 && b === 187 && c === 191) {
        return "UTF-8";
      } else if (a === 254 && b === 255) {
        return "UTF-16BE";
      } else if (a === 255 && b === 254) {
        return "UTF-16LE";
      }
      return null;
    }
    function combineByteSequences(sequences) {
      const size = sequences.reduce((a, b) => {
        return a + b.byteLength;
      }, 0);
      let offset = 0;
      return sequences.reduce((a, b) => {
        a.set(b, offset);
        offset += b.byteLength;
        return a;
      }, new Uint8Array(size));
    }
    module.exports = {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent
    };
  }
});

// node_modules/undici/lib/fileapi/filereader.js
var require_filereader = __commonJS({
  "node_modules/undici/lib/fileapi/filereader.js"(exports, module) {
    "use strict";
    var {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent
    } = require_util4();
    var {
      kState,
      kError,
      kResult,
      kEvents,
      kAborted
    } = require_symbols3();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var FileReader = class _FileReader extends EventTarget {
      constructor() {
        super();
        this[kState] = "empty";
        this[kResult] = null;
        this[kError] = null;
        this[kEvents] = {
          loadend: null,
          error: null,
          abort: null,
          load: null,
          progress: null,
          loadstart: null
        };
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
       * @param {import('buffer').Blob} blob
       */
      readAsArrayBuffer(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "ArrayBuffer");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#readAsBinaryString
       * @param {import('buffer').Blob} blob
       */
      readAsBinaryString(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "BinaryString");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#readAsDataText
       * @param {import('buffer').Blob} blob
       * @param {string?} encoding
       */
      readAsText(blob, encoding = void 0) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" });
        blob = webidl.converters.Blob(blob, { strict: false });
        if (encoding !== void 0) {
          encoding = webidl.converters.DOMString(encoding);
        }
        readOperation(this, blob, "Text", encoding);
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
       * @param {import('buffer').Blob} blob
       */
      readAsDataURL(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "DataURL");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-abort
       */
      abort() {
        if (this[kState] === "empty" || this[kState] === "done") {
          this[kResult] = null;
          return;
        }
        if (this[kState] === "loading") {
          this[kState] = "done";
          this[kResult] = null;
        }
        this[kAborted] = true;
        fireAProgressEvent("abort", this);
        if (this[kState] !== "loading") {
          fireAProgressEvent("loadend", this);
        }
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
       */
      get readyState() {
        webidl.brandCheck(this, _FileReader);
        switch (this[kState]) {
          case "empty":
            return this.EMPTY;
          case "loading":
            return this.LOADING;
          case "done":
            return this.DONE;
        }
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-result
       */
      get result() {
        webidl.brandCheck(this, _FileReader);
        return this[kResult];
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-error
       */
      get error() {
        webidl.brandCheck(this, _FileReader);
        return this[kError];
      }
      get onloadend() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].loadend;
      }
      set onloadend(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].loadend) {
          this.removeEventListener("loadend", this[kEvents].loadend);
        }
        if (typeof fn === "function") {
          this[kEvents].loadend = fn;
          this.addEventListener("loadend", fn);
        } else {
          this[kEvents].loadend = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].error) {
          this.removeEventListener("error", this[kEvents].error);
        }
        if (typeof fn === "function") {
          this[kEvents].error = fn;
          this.addEventListener("error", fn);
        } else {
          this[kEvents].error = null;
        }
      }
      get onloadstart() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].loadstart;
      }
      set onloadstart(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].loadstart) {
          this.removeEventListener("loadstart", this[kEvents].loadstart);
        }
        if (typeof fn === "function") {
          this[kEvents].loadstart = fn;
          this.addEventListener("loadstart", fn);
        } else {
          this[kEvents].loadstart = null;
        }
      }
      get onprogress() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].progress;
      }
      set onprogress(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].progress) {
          this.removeEventListener("progress", this[kEvents].progress);
        }
        if (typeof fn === "function") {
          this[kEvents].progress = fn;
          this.addEventListener("progress", fn);
        } else {
          this[kEvents].progress = null;
        }
      }
      get onload() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].load;
      }
      set onload(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].load) {
          this.removeEventListener("load", this[kEvents].load);
        }
        if (typeof fn === "function") {
          this[kEvents].load = fn;
          this.addEventListener("load", fn);
        } else {
          this[kEvents].load = null;
        }
      }
      get onabort() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].abort;
      }
      set onabort(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].abort) {
          this.removeEventListener("abort", this[kEvents].abort);
        }
        if (typeof fn === "function") {
          this[kEvents].abort = fn;
          this.addEventListener("abort", fn);
        } else {
          this[kEvents].abort = null;
        }
      }
    };
    FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
    FileReader.LOADING = FileReader.prototype.LOADING = 1;
    FileReader.DONE = FileReader.prototype.DONE = 2;
    Object.defineProperties(FileReader.prototype, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors,
      readAsArrayBuffer: kEnumerableProperty,
      readAsBinaryString: kEnumerableProperty,
      readAsText: kEnumerableProperty,
      readAsDataURL: kEnumerableProperty,
      abort: kEnumerableProperty,
      readyState: kEnumerableProperty,
      result: kEnumerableProperty,
      error: kEnumerableProperty,
      onloadstart: kEnumerableProperty,
      onprogress: kEnumerableProperty,
      onload: kEnumerableProperty,
      onabort: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onloadend: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "FileReader",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(FileReader, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors
    });
    module.exports = {
      FileReader
    };
  }
});

// node_modules/undici/lib/cache/symbols.js
var require_symbols4 = __commonJS({
  "node_modules/undici/lib/cache/symbols.js"(exports, module) {
    "use strict";
    module.exports = {
      kConstruct: require_symbols().kConstruct
    };
  }
});

// node_modules/undici/lib/cache/util.js
var require_util5 = __commonJS({
  "node_modules/undici/lib/cache/util.js"(exports, module) {
    "use strict";
    var assert = __require("assert");
    var { URLSerializer } = require_dataURL();
    var { isValidHeaderName } = require_util2();
    function urlEquals(A, B, excludeFragment = false) {
      const serializedA = URLSerializer(A, excludeFragment);
      const serializedB = URLSerializer(B, excludeFragment);
      return serializedA === serializedB;
    }
    function fieldValues(header) {
      assert(header !== null);
      const values = [];
      for (let value of header.split(",")) {
        value = value.trim();
        if (!value.length) {
          continue;
        } else if (!isValidHeaderName(value)) {
          continue;
        }
        values.push(value);
      }
      return values;
    }
    module.exports = {
      urlEquals,
      fieldValues
    };
  }
});

// node_modules/undici/lib/cache/cache.js
var require_cache = __commonJS({
  "node_modules/undici/lib/cache/cache.js"(exports, module) {
    "use strict";
    var { kConstruct } = require_symbols4();
    var { urlEquals, fieldValues: getFieldValues } = require_util5();
    var { kEnumerableProperty, isDisturbed } = require_util();
    var { kHeadersList } = require_symbols();
    var { webidl } = require_webidl();
    var { Response, cloneResponse } = require_response();
    var { Request } = require_request2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var { fetching } = require_fetch();
    var { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util2();
    var assert = __require("assert");
    var { getGlobalDispatcher } = require_global2();
    var Cache = class _Cache {
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
       * @type {requestResponseList}
       */
      #relevantRequestResponseList;
      constructor() {
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
        this.#relevantRequestResponseList = arguments[1];
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.match" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        const p = await this.matchAll(request, options);
        if (p.length === 0) {
          return;
        }
        return p[0];
      }
      async matchAll(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        if (request !== void 0) request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request !== void 0) {
          if (request instanceof Request) {
            r = request[kState];
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            r = new Request(request)[kState];
          }
        }
        const responses = [];
        if (request === void 0) {
          for (const requestResponse of this.#relevantRequestResponseList) {
            responses.push(requestResponse[1]);
          }
        } else {
          const requestResponses = this.#queryCache(r, options);
          for (const requestResponse of requestResponses) {
            responses.push(requestResponse[1]);
          }
        }
        const responseList = [];
        for (const response of responses) {
          const responseObject = new Response(response.body?.source ?? null);
          const body = responseObject[kState].body;
          responseObject[kState] = response;
          responseObject[kState].body = body;
          responseObject[kHeaders][kHeadersList] = response.headersList;
          responseObject[kHeaders][kGuard] = "immutable";
          responseList.push(responseObject);
        }
        return Object.freeze(responseList);
      }
      async add(request) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.add" });
        request = webidl.converters.RequestInfo(request);
        const requests = [request];
        const responseArrayPromise = this.addAll(requests);
        return await responseArrayPromise;
      }
      async addAll(requests) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });
        requests = webidl.converters["sequence<RequestInfo>"](requests);
        const responsePromises = [];
        const requestList = [];
        for (const request of requests) {
          if (typeof request === "string") {
            continue;
          }
          const r = request[kState];
          if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
            throw webidl.errors.exception({
              header: "Cache.addAll",
              message: "Expected http/s scheme when method is not GET."
            });
          }
        }
        const fetchControllers = [];
        for (const request of requests) {
          const r = new Request(request)[kState];
          if (!urlIsHttpHttpsScheme(r.url)) {
            throw webidl.errors.exception({
              header: "Cache.addAll",
              message: "Expected http/s scheme."
            });
          }
          r.initiator = "fetch";
          r.destination = "subresource";
          requestList.push(r);
          const responsePromise = createDeferredPromise();
          fetchControllers.push(fetching({
            request: r,
            dispatcher: getGlobalDispatcher(),
            processResponse(response) {
              if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) {
                responsePromise.reject(webidl.errors.exception({
                  header: "Cache.addAll",
                  message: "Received an invalid status code or the request failed."
                }));
              } else if (response.headersList.contains("vary")) {
                const fieldValues = getFieldValues(response.headersList.get("vary"));
                for (const fieldValue of fieldValues) {
                  if (fieldValue === "*") {
                    responsePromise.reject(webidl.errors.exception({
                      header: "Cache.addAll",
                      message: "invalid vary field value"
                    }));
                    for (const controller of fetchControllers) {
                      controller.abort();
                    }
                    return;
                  }
                }
              }
            },
            processResponseEndOfBody(response) {
              if (response.aborted) {
                responsePromise.reject(new DOMException("aborted", "AbortError"));
                return;
              }
              responsePromise.resolve(response);
            }
          }));
          responsePromises.push(responsePromise.promise);
        }
        const p = Promise.all(responsePromises);
        const responses = await p;
        const operations = [];
        let index = 0;
        for (const response of responses) {
          const operation = {
            type: "put",
            // 7.3.2
            request: requestList[index],
            // 7.3.3
            response
            // 7.3.4
          };
          operations.push(operation);
          index++;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(void 0);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async put(request, response) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 2, { header: "Cache.put" });
        request = webidl.converters.RequestInfo(request);
        response = webidl.converters.Response(response);
        let innerRequest = null;
        if (request instanceof Request) {
          innerRequest = request[kState];
        } else {
          innerRequest = new Request(request)[kState];
        }
        if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Expected an http/s scheme when method is not GET"
          });
        }
        const innerResponse = response[kState];
        if (innerResponse.status === 206) {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Got 206 status"
          });
        }
        if (innerResponse.headersList.contains("vary")) {
          const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
          for (const fieldValue of fieldValues) {
            if (fieldValue === "*") {
              throw webidl.errors.exception({
                header: "Cache.put",
                message: "Got * vary field value"
              });
            }
          }
        }
        if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Response body is locked or disturbed"
          });
        }
        const clonedResponse = cloneResponse(innerResponse);
        const bodyReadPromise = createDeferredPromise();
        if (innerResponse.body != null) {
          const stream = innerResponse.body.stream;
          const reader = stream.getReader();
          readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
        } else {
          bodyReadPromise.resolve(void 0);
        }
        const operations = [];
        const operation = {
          type: "put",
          // 14.
          request: innerRequest,
          // 15.
          response: clonedResponse
          // 16.
        };
        operations.push(operation);
        const bytes = await bodyReadPromise.promise;
        if (clonedResponse.body != null) {
          clonedResponse.body.source = bytes;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve();
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async delete(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.delete" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request instanceof Request) {
          r = request[kState];
          if (r.method !== "GET" && !options.ignoreMethod) {
            return false;
          }
        } else {
          assert(typeof request === "string");
          r = new Request(request)[kState];
        }
        const operations = [];
        const operation = {
          type: "delete",
          request: r,
          options
        };
        operations.push(operation);
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        let requestResponses;
        try {
          requestResponses = this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(!!requestResponses?.length);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
       * @param {any} request
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @returns {readonly Request[]}
       */
      async keys(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        if (request !== void 0) request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request !== void 0) {
          if (request instanceof Request) {
            r = request[kState];
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            r = new Request(request)[kState];
          }
        }
        const promise = createDeferredPromise();
        const requests = [];
        if (request === void 0) {
          for (const requestResponse of this.#relevantRequestResponseList) {
            requests.push(requestResponse[0]);
          }
        } else {
          const requestResponses = this.#queryCache(r, options);
          for (const requestResponse of requestResponses) {
            requests.push(requestResponse[0]);
          }
        }
        queueMicrotask(() => {
          const requestList = [];
          for (const request2 of requests) {
            const requestObject = new Request("https://a");
            requestObject[kState] = request2;
            requestObject[kHeaders][kHeadersList] = request2.headersList;
            requestObject[kHeaders][kGuard] = "immutable";
            requestObject[kRealm] = request2.client;
            requestList.push(requestObject);
          }
          promise.resolve(Object.freeze(requestList));
        });
        return promise.promise;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
       * @param {CacheBatchOperation[]} operations
       * @returns {requestResponseList}
       */
      #batchCacheOperations(operations) {
        const cache = this.#relevantRequestResponseList;
        const backupCache = [...cache];
        const addedItems = [];
        const resultList = [];
        try {
          for (const operation of operations) {
            if (operation.type !== "delete" && operation.type !== "put") {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: 'operation type does not match "delete" or "put"'
              });
            }
            if (operation.type === "delete" && operation.response != null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "delete operation should not have an associated response"
              });
            }
            if (this.#queryCache(operation.request, operation.options, addedItems).length) {
              throw new DOMException("???", "InvalidStateError");
            }
            let requestResponses;
            if (operation.type === "delete") {
              requestResponses = this.#queryCache(operation.request, operation.options);
              if (requestResponses.length === 0) {
                return [];
              }
              for (const requestResponse of requestResponses) {
                const idx = cache.indexOf(requestResponse);
                assert(idx !== -1);
                cache.splice(idx, 1);
              }
            } else if (operation.type === "put") {
              if (operation.response == null) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "put operation should have an associated response"
                });
              }
              const r = operation.request;
              if (!urlIsHttpHttpsScheme(r.url)) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "expected http or https scheme"
                });
              }
              if (r.method !== "GET") {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "not get method"
                });
              }
              if (operation.options != null) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "options must not be defined"
                });
              }
              requestResponses = this.#queryCache(operation.request);
              for (const requestResponse of requestResponses) {
                const idx = cache.indexOf(requestResponse);
                assert(idx !== -1);
                cache.splice(idx, 1);
              }
              cache.push([operation.request, operation.response]);
              addedItems.push([operation.request, operation.response]);
            }
            resultList.push([operation.request, operation.response]);
          }
          return resultList;
        } catch (e) {
          this.#relevantRequestResponseList.length = 0;
          this.#relevantRequestResponseList = backupCache;
          throw e;
        }
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#query-cache
       * @param {any} requestQuery
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @param {requestResponseList} targetStorage
       * @returns {requestResponseList}
       */
      #queryCache(requestQuery, options, targetStorage) {
        const resultList = [];
        const storage = targetStorage ?? this.#relevantRequestResponseList;
        for (const requestResponse of storage) {
          const [cachedRequest, cachedResponse] = requestResponse;
          if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {
            resultList.push(requestResponse);
          }
        }
        return resultList;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
       * @param {any} requestQuery
       * @param {any} request
       * @param {any | null} response
       * @param {import('../../types/cache').CacheQueryOptions | undefined} options
       * @returns {boolean}
       */
      #requestMatchesCachedItem(requestQuery, request, response = null, options) {
        const queryURL = new URL(requestQuery.url);
        const cachedURL = new URL(request.url);
        if (options?.ignoreSearch) {
          cachedURL.search = "";
          queryURL.search = "";
        }
        if (!urlEquals(queryURL, cachedURL, true)) {
          return false;
        }
        if (response == null || options?.ignoreVary || !response.headersList.contains("vary")) {
          return true;
        }
        const fieldValues = getFieldValues(response.headersList.get("vary"));
        for (const fieldValue of fieldValues) {
          if (fieldValue === "*") {
            return false;
          }
          const requestValue = request.headersList.get(fieldValue);
          const queryValue = requestQuery.headersList.get(fieldValue);
          if (requestValue !== queryValue) {
            return false;
          }
        }
        return true;
      }
    };
    Object.defineProperties(Cache.prototype, {
      [Symbol.toStringTag]: {
        value: "Cache",
        configurable: true
      },
      match: kEnumerableProperty,
      matchAll: kEnumerableProperty,
      add: kEnumerableProperty,
      addAll: kEnumerableProperty,
      put: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    var cacheQueryOptionConverters = [
      {
        key: "ignoreSearch",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "ignoreMethod",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "ignoreVary",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ];
    webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
    webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
      ...cacheQueryOptionConverters,
      {
        key: "cacheName",
        converter: webidl.converters.DOMString
      }
    ]);
    webidl.converters.Response = webidl.interfaceConverter(Response);
    webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(
      webidl.converters.RequestInfo
    );
    module.exports = {
      Cache
    };
  }
});

// node_modules/undici/lib/cache/cachestorage.js
var require_cachestorage = __commonJS({
  "node_modules/undici/lib/cache/cachestorage.js"(exports, module) {
    "use strict";
    var { kConstruct } = require_symbols4();
    var { Cache } = require_cache();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var CacheStorage = class _CacheStorage {
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
       * @type {Map<string, import('./cache').requestResponseList}
       */
      #caches = /* @__PURE__ */ new Map();
      constructor() {
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.MultiCacheQueryOptions(options);
        if (options.cacheName != null) {
          if (this.#caches.has(options.cacheName)) {
            const cacheList = this.#caches.get(options.cacheName);
            const cache = new Cache(kConstruct, cacheList);
            return await cache.match(request, options);
          }
        } else {
          for (const cacheList of this.#caches.values()) {
            const cache = new Cache(kConstruct, cacheList);
            const response = await cache.match(request, options);
            if (response !== void 0) {
              return response;
            }
          }
        }
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async has(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" });
        cacheName = webidl.converters.DOMString(cacheName);
        return this.#caches.has(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
       * @param {string} cacheName
       * @returns {Promise<Cache>}
       */
      async open(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" });
        cacheName = webidl.converters.DOMString(cacheName);
        if (this.#caches.has(cacheName)) {
          const cache2 = this.#caches.get(cacheName);
          return new Cache(kConstruct, cache2);
        }
        const cache = [];
        this.#caches.set(cacheName, cache);
        return new Cache(kConstruct, cache);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async delete(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" });
        cacheName = webidl.converters.DOMString(cacheName);
        return this.#caches.delete(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
       * @returns {string[]}
       */
      async keys() {
        webidl.brandCheck(this, _CacheStorage);
        const keys = this.#caches.keys();
        return [...keys];
      }
    };
    Object.defineProperties(CacheStorage.prototype, {
      [Symbol.toStringTag]: {
        value: "CacheStorage",
        configurable: true
      },
      match: kEnumerableProperty,
      has: kEnumerableProperty,
      open: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    module.exports = {
      CacheStorage
    };
  }
});

// node_modules/undici/lib/cookies/constants.js
var require_constants4 = __commonJS({
  "node_modules/undici/lib/cookies/constants.js"(exports, module) {
    "use strict";
    var maxAttributeValueSize = 1024;
    var maxNameValuePairSize = 4096;
    module.exports = {
      maxAttributeValueSize,
      maxNameValuePairSize
    };
  }
});

// node_modules/undici/lib/cookies/util.js
var require_util6 = __commonJS({
  "node_modules/undici/lib/cookies/util.js"(exports, module) {
    "use strict";
    function isCTLExcludingHtab(value) {
      if (value.length === 0) {
        return false;
      }
      for (const char of value) {
        const code = char.charCodeAt(0);
        if (code >= 0 || code <= 8 || (code >= 10 || code <= 31) || code === 127) {
          return false;
        }
      }
    }
    function validateCookieName(name) {
      for (const char of name) {
        const code = char.charCodeAt(0);
        if (code <= 32 || code > 127 || char === "(" || char === ")" || char === ">" || char === "<" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}") {
          throw new Error("Invalid cookie name");
        }
      }
    }
    function validateCookieValue(value) {
      for (const char of value) {
        const code = char.charCodeAt(0);
        if (code < 33 || // exclude CTLs (0-31)
        code === 34 || code === 44 || code === 59 || code === 92 || code > 126) {
          throw new Error("Invalid header value");
        }
      }
    }
    function validateCookiePath(path12) {
      for (const char of path12) {
        const code = char.charCodeAt(0);
        if (code < 33 || char === ";") {
          throw new Error("Invalid cookie path");
        }
      }
    }
    function validateCookieDomain(domain) {
      if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
        throw new Error("Invalid cookie domain");
      }
    }
    function toIMFDate(date) {
      if (typeof date === "number") {
        date = new Date(date);
      }
      const days = [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
      ];
      const months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      const dayName = days[date.getUTCDay()];
      const day = date.getUTCDate().toString().padStart(2, "0");
      const month = months[date.getUTCMonth()];
      const year = date.getUTCFullYear();
      const hour = date.getUTCHours().toString().padStart(2, "0");
      const minute = date.getUTCMinutes().toString().padStart(2, "0");
      const second = date.getUTCSeconds().toString().padStart(2, "0");
      return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
    }
    function validateCookieMaxAge(maxAge) {
      if (maxAge < 0) {
        throw new Error("Invalid cookie max-age");
      }
    }
    function stringify(cookie) {
      if (cookie.name.length === 0) {
        return null;
      }
      validateCookieName(cookie.name);
      validateCookieValue(cookie.value);
      const out = [`${cookie.name}=${cookie.value}`];
      if (cookie.name.startsWith("__Secure-")) {
        cookie.secure = true;
      }
      if (cookie.name.startsWith("__Host-")) {
        cookie.secure = true;
        cookie.domain = null;
        cookie.path = "/";
      }
      if (cookie.secure) {
        out.push("Secure");
      }
      if (cookie.httpOnly) {
        out.push("HttpOnly");
      }
      if (typeof cookie.maxAge === "number") {
        validateCookieMaxAge(cookie.maxAge);
        out.push(`Max-Age=${cookie.maxAge}`);
      }
      if (cookie.domain) {
        validateCookieDomain(cookie.domain);
        out.push(`Domain=${cookie.domain}`);
      }
      if (cookie.path) {
        validateCookiePath(cookie.path);
        out.push(`Path=${cookie.path}`);
      }
      if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
        out.push(`Expires=${toIMFDate(cookie.expires)}`);
      }
      if (cookie.sameSite) {
        out.push(`SameSite=${cookie.sameSite}`);
      }
      for (const part of cookie.unparsed) {
        if (!part.includes("=")) {
          throw new Error("Invalid unparsed");
        }
        const [key, ...value] = part.split("=");
        out.push(`${key.trim()}=${value.join("=")}`);
      }
      return out.join("; ");
    }
    module.exports = {
      isCTLExcludingHtab,
      validateCookieName,
      validateCookiePath,
      validateCookieValue,
      toIMFDate,
      stringify
    };
  }
});

// node_modules/undici/lib/cookies/parse.js
var require_parse = __commonJS({
  "node_modules/undici/lib/cookies/parse.js"(exports, module) {
    "use strict";
    var { maxNameValuePairSize, maxAttributeValueSize } = require_constants4();
    var { isCTLExcludingHtab } = require_util6();
    var { collectASequenceOfCodePointsFast } = require_dataURL();
    var assert = __require("assert");
    function parseSetCookie(header) {
      if (isCTLExcludingHtab(header)) {
        return null;
      }
      let nameValuePair = "";
      let unparsedAttributes = "";
      let name = "";
      let value = "";
      if (header.includes(";")) {
        const position = { position: 0 };
        nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
        unparsedAttributes = header.slice(position.position);
      } else {
        nameValuePair = header;
      }
      if (!nameValuePair.includes("=")) {
        value = nameValuePair;
      } else {
        const position = { position: 0 };
        name = collectASequenceOfCodePointsFast(
          "=",
          nameValuePair,
          position
        );
        value = nameValuePair.slice(position.position + 1);
      }
      name = name.trim();
      value = value.trim();
      if (name.length + value.length > maxNameValuePairSize) {
        return null;
      }
      return {
        name,
        value,
        ...parseUnparsedAttributes(unparsedAttributes)
      };
    }
    function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
      if (unparsedAttributes.length === 0) {
        return cookieAttributeList;
      }
      assert(unparsedAttributes[0] === ";");
      unparsedAttributes = unparsedAttributes.slice(1);
      let cookieAv = "";
      if (unparsedAttributes.includes(";")) {
        cookieAv = collectASequenceOfCodePointsFast(
          ";",
          unparsedAttributes,
          { position: 0 }
        );
        unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
      } else {
        cookieAv = unparsedAttributes;
        unparsedAttributes = "";
      }
      let attributeName = "";
      let attributeValue = "";
      if (cookieAv.includes("=")) {
        const position = { position: 0 };
        attributeName = collectASequenceOfCodePointsFast(
          "=",
          cookieAv,
          position
        );
        attributeValue = cookieAv.slice(position.position + 1);
      } else {
        attributeName = cookieAv;
      }
      attributeName = attributeName.trim();
      attributeValue = attributeValue.trim();
      if (attributeValue.length > maxAttributeValueSize) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const attributeNameLowercase = attributeName.toLowerCase();
      if (attributeNameLowercase === "expires") {
        const expiryTime = new Date(attributeValue);
        cookieAttributeList.expires = expiryTime;
      } else if (attributeNameLowercase === "max-age") {
        const charCode = attributeValue.charCodeAt(0);
        if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        if (!/^\d+$/.test(attributeValue)) {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        const deltaSeconds = Number(attributeValue);
        cookieAttributeList.maxAge = deltaSeconds;
      } else if (attributeNameLowercase === "domain") {
        let cookieDomain = attributeValue;
        if (cookieDomain[0] === ".") {
          cookieDomain = cookieDomain.slice(1);
        }
        cookieDomain = cookieDomain.toLowerCase();
        cookieAttributeList.domain = cookieDomain;
      } else if (attributeNameLowercase === "path") {
        let cookiePath = "";
        if (attributeValue.length === 0 || attributeValue[0] !== "/") {
          cookiePath = "/";
        } else {
          cookiePath = attributeValue;
        }
        cookieAttributeList.path = cookiePath;
      } else if (attributeNameLowercase === "secure") {
        cookieAttributeList.secure = true;
      } else if (attributeNameLowercase === "httponly") {
        cookieAttributeList.httpOnly = true;
      } else if (attributeNameLowercase === "samesite") {
        let enforcement = "Default";
        const attributeValueLowercase = attributeValue.toLowerCase();
        if (attributeValueLowercase.includes("none")) {
          enforcement = "None";
        }
        if (attributeValueLowercase.includes("strict")) {
          enforcement = "Strict";
        }
        if (attributeValueLowercase.includes("lax")) {
          enforcement = "Lax";
        }
        cookieAttributeList.sameSite = enforcement;
      } else {
        cookieAttributeList.unparsed ??= [];
        cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
      }
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    module.exports = {
      parseSetCookie,
      parseUnparsedAttributes
    };
  }
});

// node_modules/undici/lib/cookies/index.js
var require_cookies = __commonJS({
  "node_modules/undici/lib/cookies/index.js"(exports, module) {
    "use strict";
    var { parseSetCookie } = require_parse();
    var { stringify } = require_util6();
    var { webidl } = require_webidl();
    var { Headers } = require_headers();
    function getCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: "getCookies" });
      webidl.brandCheck(headers, Headers, { strict: false });
      const cookie = headers.get("cookie");
      const out = {};
      if (!cookie) {
        return out;
      }
      for (const piece of cookie.split(";")) {
        const [name, ...value] = piece.split("=");
        out[name.trim()] = value.join("=");
      }
      return out;
    }
    function deleteCookie(headers, name, attributes) {
      webidl.argumentLengthCheck(arguments, 2, { header: "deleteCookie" });
      webidl.brandCheck(headers, Headers, { strict: false });
      name = webidl.converters.DOMString(name);
      attributes = webidl.converters.DeleteCookieAttributes(attributes);
      setCookie(headers, {
        name,
        value: "",
        expires: /* @__PURE__ */ new Date(0),
        ...attributes
      });
    }
    function getSetCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: "getSetCookies" });
      webidl.brandCheck(headers, Headers, { strict: false });
      const cookies = headers.getSetCookie();
      if (!cookies) {
        return [];
      }
      return cookies.map((pair) => parseSetCookie(pair));
    }
    function setCookie(headers, cookie) {
      webidl.argumentLengthCheck(arguments, 2, { header: "setCookie" });
      webidl.brandCheck(headers, Headers, { strict: false });
      cookie = webidl.converters.Cookie(cookie);
      const str = stringify(cookie);
      if (str) {
        headers.append("Set-Cookie", stringify(cookie));
      }
    }
    webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: null
      }
    ]);
    webidl.converters.Cookie = webidl.dictionaryConverter([
      {
        converter: webidl.converters.DOMString,
        key: "name"
      },
      {
        converter: webidl.converters.DOMString,
        key: "value"
      },
      {
        converter: webidl.nullableConverter((value) => {
          if (typeof value === "number") {
            return webidl.converters["unsigned long long"](value);
          }
          return new Date(value);
        }),
        key: "expires",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters["long long"]),
        key: "maxAge",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "secure",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "httpOnly",
        defaultValue: null
      },
      {
        converter: webidl.converters.USVString,
        key: "sameSite",
        allowedValues: ["Strict", "Lax", "None"]
      },
      {
        converter: webidl.sequenceConverter(webidl.converters.DOMString),
        key: "unparsed",
        defaultValue: []
      }
    ]);
    module.exports = {
      getCookies,
      deleteCookie,
      getSetCookies,
      setCookie
    };
  }
});

// node_modules/undici/lib/websocket/constants.js
var require_constants5 = __commonJS({
  "node_modules/undici/lib/websocket/constants.js"(exports, module) {
    "use strict";
    var uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    var states = {
      CONNECTING: 0,
      OPEN: 1,
      CLOSING: 2,
      CLOSED: 3
    };
    var opcodes = {
      CONTINUATION: 0,
      TEXT: 1,
      BINARY: 2,
      CLOSE: 8,
      PING: 9,
      PONG: 10
    };
    var maxUnsigned16Bit = 2 ** 16 - 1;
    var parserStates = {
      INFO: 0,
      PAYLOADLENGTH_16: 2,
      PAYLOADLENGTH_64: 3,
      READ_DATA: 4
    };
    var emptyBuffer = Buffer.allocUnsafe(0);
    module.exports = {
      uid,
      staticPropertyDescriptors,
      states,
      opcodes,
      maxUnsigned16Bit,
      parserStates,
      emptyBuffer
    };
  }
});

// node_modules/undici/lib/websocket/symbols.js
var require_symbols5 = __commonJS({
  "node_modules/undici/lib/websocket/symbols.js"(exports, module) {
    "use strict";
    module.exports = {
      kWebSocketURL: /* @__PURE__ */ Symbol("url"),
      kReadyState: /* @__PURE__ */ Symbol("ready state"),
      kController: /* @__PURE__ */ Symbol("controller"),
      kResponse: /* @__PURE__ */ Symbol("response"),
      kBinaryType: /* @__PURE__ */ Symbol("binary type"),
      kSentClose: /* @__PURE__ */ Symbol("sent close"),
      kReceivedClose: /* @__PURE__ */ Symbol("received close"),
      kByteParser: /* @__PURE__ */ Symbol("byte parser")
    };
  }
});

// node_modules/undici/lib/websocket/events.js
var require_events = __commonJS({
  "node_modules/undici/lib/websocket/events.js"(exports, module) {
    "use strict";
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var { MessagePort } = __require("worker_threads");
    var MessageEvent = class _MessageEvent extends Event {
      #eventInit;
      constructor(type, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" });
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.MessageEventInit(eventInitDict);
        super(type, eventInitDict);
        this.#eventInit = eventInitDict;
      }
      get data() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.data;
      }
      get origin() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.origin;
      }
      get lastEventId() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.lastEventId;
      }
      get source() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.source;
      }
      get ports() {
        webidl.brandCheck(this, _MessageEvent);
        if (!Object.isFrozen(this.#eventInit.ports)) {
          Object.freeze(this.#eventInit.ports);
        }
        return this.#eventInit.ports;
      }
      initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
        webidl.brandCheck(this, _MessageEvent);
        webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" });
        return new _MessageEvent(type, {
          bubbles,
          cancelable,
          data,
          origin,
          lastEventId,
          source,
          ports
        });
      }
    };
    var CloseEvent = class _CloseEvent extends Event {
      #eventInit;
      constructor(type, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" });
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
        super(type, eventInitDict);
        this.#eventInit = eventInitDict;
      }
      get wasClean() {
        webidl.brandCheck(this, _CloseEvent);
        return this.#eventInit.wasClean;
      }
      get code() {
        webidl.brandCheck(this, _CloseEvent);
        return this.#eventInit.code;
      }
      get reason() {
        webidl.brandCheck(this, _CloseEvent);
        return this.#eventInit.reason;
      }
    };
    var ErrorEvent = class _ErrorEvent extends Event {
      #eventInit;
      constructor(type, eventInitDict) {
        webidl.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
        super(type, eventInitDict);
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
        this.#eventInit = eventInitDict;
      }
      get message() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.message;
      }
      get filename() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.filename;
      }
      get lineno() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.lineno;
      }
      get colno() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.colno;
      }
      get error() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.error;
      }
    };
    Object.defineProperties(MessageEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "MessageEvent",
        configurable: true
      },
      data: kEnumerableProperty,
      origin: kEnumerableProperty,
      lastEventId: kEnumerableProperty,
      source: kEnumerableProperty,
      ports: kEnumerableProperty,
      initMessageEvent: kEnumerableProperty
    });
    Object.defineProperties(CloseEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "CloseEvent",
        configurable: true
      },
      reason: kEnumerableProperty,
      code: kEnumerableProperty,
      wasClean: kEnumerableProperty
    });
    Object.defineProperties(ErrorEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "ErrorEvent",
        configurable: true
      },
      message: kEnumerableProperty,
      filename: kEnumerableProperty,
      lineno: kEnumerableProperty,
      colno: kEnumerableProperty,
      error: kEnumerableProperty
    });
    webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
    webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(
      webidl.converters.MessagePort
    );
    var eventInit = [
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ];
    webidl.converters.MessageEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "data",
        converter: webidl.converters.any,
        defaultValue: null
      },
      {
        key: "origin",
        converter: webidl.converters.USVString,
        defaultValue: ""
      },
      {
        key: "lastEventId",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "source",
        // Node doesn't implement WindowProxy or ServiceWorker, so the only
        // valid value for source is a MessagePort.
        converter: webidl.nullableConverter(webidl.converters.MessagePort),
        defaultValue: null
      },
      {
        key: "ports",
        converter: webidl.converters["sequence<MessagePort>"],
        get defaultValue() {
          return [];
        }
      }
    ]);
    webidl.converters.CloseEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "wasClean",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "code",
        converter: webidl.converters["unsigned short"],
        defaultValue: 0
      },
      {
        key: "reason",
        converter: webidl.converters.USVString,
        defaultValue: ""
      }
    ]);
    webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "message",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "filename",
        converter: webidl.converters.USVString,
        defaultValue: ""
      },
      {
        key: "lineno",
        converter: webidl.converters["unsigned long"],
        defaultValue: 0
      },
      {
        key: "colno",
        converter: webidl.converters["unsigned long"],
        defaultValue: 0
      },
      {
        key: "error",
        converter: webidl.converters.any
      }
    ]);
    module.exports = {
      MessageEvent,
      CloseEvent,
      ErrorEvent
    };
  }
});

// node_modules/undici/lib/websocket/util.js
var require_util7 = __commonJS({
  "node_modules/undici/lib/websocket/util.js"(exports, module) {
    "use strict";
    var { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require_symbols5();
    var { states, opcodes } = require_constants5();
    var { MessageEvent, ErrorEvent } = require_events();
    function isEstablished(ws) {
      return ws[kReadyState] === states.OPEN;
    }
    function isClosing(ws) {
      return ws[kReadyState] === states.CLOSING;
    }
    function isClosed(ws) {
      return ws[kReadyState] === states.CLOSED;
    }
    function fireEvent(e, target, eventConstructor = Event, eventInitDict) {
      const event = new eventConstructor(e, eventInitDict);
      target.dispatchEvent(event);
    }
    function websocketMessageReceived(ws, type, data) {
      if (ws[kReadyState] !== states.OPEN) {
        return;
      }
      let dataForEvent;
      if (type === opcodes.TEXT) {
        try {
          dataForEvent = new TextDecoder("utf-8", { fatal: true }).decode(data);
        } catch {
          failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
          return;
        }
      } else if (type === opcodes.BINARY) {
        if (ws[kBinaryType] === "blob") {
          dataForEvent = new Blob([data]);
        } else {
          dataForEvent = new Uint8Array(data).buffer;
        }
      }
      fireEvent("message", ws, MessageEvent, {
        origin: ws[kWebSocketURL].origin,
        data: dataForEvent
      });
    }
    function isValidSubprotocol(protocol) {
      if (protocol.length === 0) {
        return false;
      }
      for (const char of protocol) {
        const code = char.charCodeAt(0);
        if (code < 33 || code > 126 || char === "(" || char === ")" || char === "<" || char === ">" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}" || code === 32 || // SP
        code === 9) {
          return false;
        }
      }
      return true;
    }
    function isValidStatusCode(code) {
      if (code >= 1e3 && code < 1015) {
        return code !== 1004 && // reserved
        code !== 1005 && // "MUST NOT be set as a status code"
        code !== 1006;
      }
      return code >= 3e3 && code <= 4999;
    }
    function failWebsocketConnection(ws, reason) {
      const { [kController]: controller, [kResponse]: response } = ws;
      controller.abort();
      if (response?.socket && !response.socket.destroyed) {
        response.socket.destroy();
      }
      if (reason) {
        fireEvent("error", ws, ErrorEvent, {
          error: new Error(reason)
        });
      }
    }
    module.exports = {
      isEstablished,
      isClosing,
      isClosed,
      fireEvent,
      isValidSubprotocol,
      isValidStatusCode,
      failWebsocketConnection,
      websocketMessageReceived
    };
  }
});

// node_modules/undici/lib/websocket/connection.js
var require_connection = __commonJS({
  "node_modules/undici/lib/websocket/connection.js"(exports, module) {
    "use strict";
    var diagnosticsChannel = __require("diagnostics_channel");
    var { uid, states } = require_constants5();
    var {
      kReadyState,
      kSentClose,
      kByteParser,
      kReceivedClose
    } = require_symbols5();
    var { fireEvent, failWebsocketConnection } = require_util7();
    var { CloseEvent } = require_events();
    var { makeRequest } = require_request2();
    var { fetching } = require_fetch();
    var { Headers } = require_headers();
    var { getGlobalDispatcher } = require_global2();
    var { kHeadersList } = require_symbols();
    var channels = {};
    channels.open = diagnosticsChannel.channel("undici:websocket:open");
    channels.close = diagnosticsChannel.channel("undici:websocket:close");
    channels.socketError = diagnosticsChannel.channel("undici:websocket:socket_error");
    var crypto2;
    try {
      crypto2 = __require("crypto");
    } catch {
    }
    function establishWebSocketConnection(url, protocols, ws, onEstablish, options) {
      const requestURL = url;
      requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
      const request = makeRequest({
        urlList: [requestURL],
        serviceWorkers: "none",
        referrer: "no-referrer",
        mode: "websocket",
        credentials: "include",
        cache: "no-store",
        redirect: "error"
      });
      if (options.headers) {
        const headersList = new Headers(options.headers)[kHeadersList];
        request.headersList = headersList;
      }
      const keyValue = crypto2.randomBytes(16).toString("base64");
      request.headersList.append("sec-websocket-key", keyValue);
      request.headersList.append("sec-websocket-version", "13");
      for (const protocol of protocols) {
        request.headersList.append("sec-websocket-protocol", protocol);
      }
      const permessageDeflate = "";
      const controller = fetching({
        request,
        useParallelQueue: true,
        dispatcher: options.dispatcher ?? getGlobalDispatcher(),
        processResponse(response) {
          if (response.type === "error" || response.status !== 101) {
            failWebsocketConnection(ws, "Received network error or non-101 status code.");
            return;
          }
          if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(ws, "Server did not respond with sent protocols.");
            return;
          }
          if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
            failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
            return;
          }
          if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
            failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
            return;
          }
          const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
          const digest = crypto2.createHash("sha1").update(keyValue + uid).digest("base64");
          if (secWSAccept !== digest) {
            failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
            return;
          }
          const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
          if (secExtension !== null && secExtension !== permessageDeflate) {
            failWebsocketConnection(ws, "Received different permessage-deflate than the one set.");
            return;
          }
          const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
          if (secProtocol !== null && secProtocol !== request.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
            return;
          }
          response.socket.on("data", onSocketData);
          response.socket.on("close", onSocketClose);
          response.socket.on("error", onSocketError);
          if (channels.open.hasSubscribers) {
            channels.open.publish({
              address: response.socket.address(),
              protocol: secProtocol,
              extensions: secExtension
            });
          }
          onEstablish(response);
        }
      });
      return controller;
    }
    function onSocketData(chunk) {
      if (!this.ws[kByteParser].write(chunk)) {
        this.pause();
      }
    }
    function onSocketClose() {
      const { ws } = this;
      const wasClean = ws[kSentClose] && ws[kReceivedClose];
      let code = 1005;
      let reason = "";
      const result = ws[kByteParser].closingInfo;
      if (result) {
        code = result.code ?? 1005;
        reason = result.reason;
      } else if (!ws[kSentClose]) {
        code = 1006;
      }
      ws[kReadyState] = states.CLOSED;
      fireEvent("close", ws, CloseEvent, {
        wasClean,
        code,
        reason
      });
      if (channels.close.hasSubscribers) {
        channels.close.publish({
          websocket: ws,
          code,
          reason
        });
      }
    }
    function onSocketError(error) {
      const { ws } = this;
      ws[kReadyState] = states.CLOSING;
      if (channels.socketError.hasSubscribers) {
        channels.socketError.publish(error);
      }
      this.destroy();
    }
    module.exports = {
      establishWebSocketConnection
    };
  }
});

// node_modules/undici/lib/websocket/frame.js
var require_frame = __commonJS({
  "node_modules/undici/lib/websocket/frame.js"(exports, module) {
    "use strict";
    var { maxUnsigned16Bit } = require_constants5();
    var crypto2;
    try {
      crypto2 = __require("crypto");
    } catch {
    }
    var WebsocketFrameSend = class {
      /**
       * @param {Buffer|undefined} data
       */
      constructor(data) {
        this.frameData = data;
        this.maskKey = crypto2.randomBytes(4);
      }
      createFrame(opcode) {
        const bodyLength = this.frameData?.byteLength ?? 0;
        let payloadLength = bodyLength;
        let offset = 6;
        if (bodyLength > maxUnsigned16Bit) {
          offset += 8;
          payloadLength = 127;
        } else if (bodyLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const buffer = Buffer.allocUnsafe(bodyLength + offset);
        buffer[0] = buffer[1] = 0;
        buffer[0] |= 128;
        buffer[0] = (buffer[0] & 240) + opcode;
        buffer[offset - 4] = this.maskKey[0];
        buffer[offset - 3] = this.maskKey[1];
        buffer[offset - 2] = this.maskKey[2];
        buffer[offset - 1] = this.maskKey[3];
        buffer[1] = payloadLength;
        if (payloadLength === 126) {
          buffer.writeUInt16BE(bodyLength, 2);
        } else if (payloadLength === 127) {
          buffer[2] = buffer[3] = 0;
          buffer.writeUIntBE(bodyLength, 4, 6);
        }
        buffer[1] |= 128;
        for (let i = 0; i < bodyLength; i++) {
          buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];
        }
        return buffer;
      }
    };
    module.exports = {
      WebsocketFrameSend
    };
  }
});

// node_modules/undici/lib/websocket/receiver.js
var require_receiver = __commonJS({
  "node_modules/undici/lib/websocket/receiver.js"(exports, module) {
    "use strict";
    var { Writable } = __require("stream");
    var diagnosticsChannel = __require("diagnostics_channel");
    var { parserStates, opcodes, states, emptyBuffer } = require_constants5();
    var { kReadyState, kSentClose, kResponse, kReceivedClose } = require_symbols5();
    var { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = require_util7();
    var { WebsocketFrameSend } = require_frame();
    var channels = {};
    channels.ping = diagnosticsChannel.channel("undici:websocket:ping");
    channels.pong = diagnosticsChannel.channel("undici:websocket:pong");
    var ByteParser = class extends Writable {
      #buffers = [];
      #byteOffset = 0;
      #state = parserStates.INFO;
      #info = {};
      #fragments = [];
      constructor(ws) {
        super();
        this.ws = ws;
      }
      /**
       * @param {Buffer} chunk
       * @param {() => void} callback
       */
      _write(chunk, _, callback) {
        this.#buffers.push(chunk);
        this.#byteOffset += chunk.length;
        this.run(callback);
      }
      /**
       * Runs whenever a new chunk is received.
       * Callback is called whenever there are no more chunks buffering,
       * or not enough bytes are buffered to parse.
       */
      run(callback) {
        while (true) {
          if (this.#state === parserStates.INFO) {
            if (this.#byteOffset < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            this.#info.fin = (buffer[0] & 128) !== 0;
            this.#info.opcode = buffer[0] & 15;
            this.#info.originalOpcode ??= this.#info.opcode;
            this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION;
            if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {
              failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
              return;
            }
            const payloadLength = buffer[1] & 127;
            if (payloadLength <= 125) {
              this.#info.payloadLength = payloadLength;
              this.#state = parserStates.READ_DATA;
            } else if (payloadLength === 126) {
              this.#state = parserStates.PAYLOADLENGTH_16;
            } else if (payloadLength === 127) {
              this.#state = parserStates.PAYLOADLENGTH_64;
            }
            if (this.#info.fragmented && payloadLength > 125) {
              failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
              return;
            } else if ((this.#info.opcode === opcodes.PING || this.#info.opcode === opcodes.PONG || this.#info.opcode === opcodes.CLOSE) && payloadLength > 125) {
              failWebsocketConnection(this.ws, "Payload length for control frame exceeded 125 bytes.");
              return;
            } else if (this.#info.opcode === opcodes.CLOSE) {
              if (payloadLength === 1) {
                failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
                return;
              }
              const body = this.consume(payloadLength);
              this.#info.closeInfo = this.parseCloseBody(false, body);
              if (!this.ws[kSentClose]) {
                const body2 = Buffer.allocUnsafe(2);
                body2.writeUInt16BE(this.#info.closeInfo.code, 0);
                const closeFrame = new WebsocketFrameSend(body2);
                this.ws[kResponse].socket.write(
                  closeFrame.createFrame(opcodes.CLOSE),
                  (err) => {
                    if (!err) {
                      this.ws[kSentClose] = true;
                    }
                  }
                );
              }
              this.ws[kReadyState] = states.CLOSING;
              this.ws[kReceivedClose] = true;
              this.end();
              return;
            } else if (this.#info.opcode === opcodes.PING) {
              const body = this.consume(payloadLength);
              if (!this.ws[kReceivedClose]) {
                const frame = new WebsocketFrameSend(body);
                this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));
                if (channels.ping.hasSubscribers) {
                  channels.ping.publish({
                    payload: body
                  });
                }
              }
              this.#state = parserStates.INFO;
              if (this.#byteOffset > 0) {
                continue;
              } else {
                callback();
                return;
              }
            } else if (this.#info.opcode === opcodes.PONG) {
              const body = this.consume(payloadLength);
              if (channels.pong.hasSubscribers) {
                channels.pong.publish({
                  payload: body
                });
              }
              if (this.#byteOffset > 0) {
                continue;
              } else {
                callback();
                return;
              }
            }
          } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
            if (this.#byteOffset < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            this.#info.payloadLength = buffer.readUInt16BE(0);
            this.#state = parserStates.READ_DATA;
          } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
            if (this.#byteOffset < 8) {
              return callback();
            }
            const buffer = this.consume(8);
            const upper = buffer.readUInt32BE(0);
            if (upper > 2 ** 31 - 1) {
              failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
              return;
            }
            const lower = buffer.readUInt32BE(4);
            this.#info.payloadLength = (upper << 8) + lower;
            this.#state = parserStates.READ_DATA;
          } else if (this.#state === parserStates.READ_DATA) {
            if (this.#byteOffset < this.#info.payloadLength) {
              return callback();
            } else if (this.#byteOffset >= this.#info.payloadLength) {
              const body = this.consume(this.#info.payloadLength);
              this.#fragments.push(body);
              if (!this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes.CONTINUATION) {
                const fullMessage = Buffer.concat(this.#fragments);
                websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);
                this.#info = {};
                this.#fragments.length = 0;
              }
              this.#state = parserStates.INFO;
            }
          }
          if (this.#byteOffset > 0) {
            continue;
          } else {
            callback();
            break;
          }
        }
      }
      /**
       * Take n bytes from the buffered Buffers
       * @param {number} n
       * @returns {Buffer|null}
       */
      consume(n) {
        if (n > this.#byteOffset) {
          return null;
        } else if (n === 0) {
          return emptyBuffer;
        }
        if (this.#buffers[0].length === n) {
          this.#byteOffset -= this.#buffers[0].length;
          return this.#buffers.shift();
        }
        const buffer = Buffer.allocUnsafe(n);
        let offset = 0;
        while (offset !== n) {
          const next = this.#buffers[0];
          const { length } = next;
          if (length + offset === n) {
            buffer.set(this.#buffers.shift(), offset);
            break;
          } else if (length + offset > n) {
            buffer.set(next.subarray(0, n - offset), offset);
            this.#buffers[0] = next.subarray(n - offset);
            break;
          } else {
            buffer.set(this.#buffers.shift(), offset);
            offset += next.length;
          }
        }
        this.#byteOffset -= n;
        return buffer;
      }
      parseCloseBody(onlyCode, data) {
        let code;
        if (data.length >= 2) {
          code = data.readUInt16BE(0);
        }
        if (onlyCode) {
          if (!isValidStatusCode(code)) {
            return null;
          }
          return { code };
        }
        let reason = data.subarray(2);
        if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
          reason = reason.subarray(3);
        }
        if (code !== void 0 && !isValidStatusCode(code)) {
          return null;
        }
        try {
          reason = new TextDecoder("utf-8", { fatal: true }).decode(reason);
        } catch {
          return null;
        }
        return { code, reason };
      }
      get closingInfo() {
        return this.#info.closeInfo;
      }
    };
    module.exports = {
      ByteParser
    };
  }
});

// node_modules/undici/lib/websocket/websocket.js
var require_websocket = __commonJS({
  "node_modules/undici/lib/websocket/websocket.js"(exports, module) {
    "use strict";
    var { webidl } = require_webidl();
    var { DOMException: DOMException2 } = require_constants2();
    var { URLSerializer } = require_dataURL();
    var { getGlobalOrigin } = require_global();
    var { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants5();
    var {
      kWebSocketURL,
      kReadyState,
      kController,
      kBinaryType,
      kResponse,
      kSentClose,
      kByteParser
    } = require_symbols5();
    var { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require_util7();
    var { establishWebSocketConnection } = require_connection();
    var { WebsocketFrameSend } = require_frame();
    var { ByteParser } = require_receiver();
    var { kEnumerableProperty, isBlobLike } = require_util();
    var { getGlobalDispatcher } = require_global2();
    var { types } = __require("util");
    var experimentalWarned = false;
    var WebSocket = class _WebSocket extends EventTarget {
      #events = {
        open: null,
        error: null,
        close: null,
        message: null
      };
      #bufferedAmount = 0;
      #protocol = "";
      #extensions = "";
      /**
       * @param {string} url
       * @param {string|string[]} protocols
       */
      constructor(url, protocols = []) {
        super();
        webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" });
        if (!experimentalWarned) {
          experimentalWarned = true;
          process.emitWarning("WebSockets are experimental, expect them to change at any time.", {
            code: "UNDICI-WS"
          });
        }
        const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols);
        url = webidl.converters.USVString(url);
        protocols = options.protocols;
        const baseURL = getGlobalOrigin();
        let urlRecord;
        try {
          urlRecord = new URL(url, baseURL);
        } catch (e) {
          throw new DOMException2(e, "SyntaxError");
        }
        if (urlRecord.protocol === "http:") {
          urlRecord.protocol = "ws:";
        } else if (urlRecord.protocol === "https:") {
          urlRecord.protocol = "wss:";
        }
        if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
          throw new DOMException2(
            `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,
            "SyntaxError"
          );
        }
        if (urlRecord.hash || urlRecord.href.endsWith("#")) {
          throw new DOMException2("Got fragment", "SyntaxError");
        }
        if (typeof protocols === "string") {
          protocols = [protocols];
        }
        if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
          throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
          throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        this[kWebSocketURL] = new URL(urlRecord.href);
        this[kController] = establishWebSocketConnection(
          urlRecord,
          protocols,
          this,
          (response) => this.#onConnectionEstablished(response),
          options
        );
        this[kReadyState] = _WebSocket.CONNECTING;
        this[kBinaryType] = "blob";
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-close
       * @param {number|undefined} code
       * @param {string|undefined} reason
       */
      close(code = void 0, reason = void 0) {
        webidl.brandCheck(this, _WebSocket);
        if (code !== void 0) {
          code = webidl.converters["unsigned short"](code, { clamp: true });
        }
        if (reason !== void 0) {
          reason = webidl.converters.USVString(reason);
        }
        if (code !== void 0) {
          if (code !== 1e3 && (code < 3e3 || code > 4999)) {
            throw new DOMException2("invalid code", "InvalidAccessError");
          }
        }
        let reasonByteLength = 0;
        if (reason !== void 0) {
          reasonByteLength = Buffer.byteLength(reason);
          if (reasonByteLength > 123) {
            throw new DOMException2(
              `Reason must be less than 123 bytes; received ${reasonByteLength}`,
              "SyntaxError"
            );
          }
        }
        if (this[kReadyState] === _WebSocket.CLOSING || this[kReadyState] === _WebSocket.CLOSED) {
        } else if (!isEstablished(this)) {
          failWebsocketConnection(this, "Connection was closed before it was established.");
          this[kReadyState] = _WebSocket.CLOSING;
        } else if (!isClosing(this)) {
          const frame = new WebsocketFrameSend();
          if (code !== void 0 && reason === void 0) {
            frame.frameData = Buffer.allocUnsafe(2);
            frame.frameData.writeUInt16BE(code, 0);
          } else if (code !== void 0 && reason !== void 0) {
            frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
            frame.frameData.writeUInt16BE(code, 0);
            frame.frameData.write(reason, 2, "utf-8");
          } else {
            frame.frameData = emptyBuffer;
          }
          const socket = this[kResponse].socket;
          socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
            if (!err) {
              this[kSentClose] = true;
            }
          });
          this[kReadyState] = states.CLOSING;
        } else {
          this[kReadyState] = _WebSocket.CLOSING;
        }
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-send
       * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
       */
      send(data) {
        webidl.brandCheck(this, _WebSocket);
        webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" });
        data = webidl.converters.WebSocketSendData(data);
        if (this[kReadyState] === _WebSocket.CONNECTING) {
          throw new DOMException2("Sent before connected.", "InvalidStateError");
        }
        if (!isEstablished(this) || isClosing(this)) {
          return;
        }
        const socket = this[kResponse].socket;
        if (typeof data === "string") {
          const value = Buffer.from(data);
          const frame = new WebsocketFrameSend(value);
          const buffer = frame.createFrame(opcodes.TEXT);
          this.#bufferedAmount += value.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= value.byteLength;
          });
        } else if (types.isArrayBuffer(data)) {
          const value = Buffer.from(data);
          const frame = new WebsocketFrameSend(value);
          const buffer = frame.createFrame(opcodes.BINARY);
          this.#bufferedAmount += value.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= value.byteLength;
          });
        } else if (ArrayBuffer.isView(data)) {
          const ab = Buffer.from(data, data.byteOffset, data.byteLength);
          const frame = new WebsocketFrameSend(ab);
          const buffer = frame.createFrame(opcodes.BINARY);
          this.#bufferedAmount += ab.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= ab.byteLength;
          });
        } else if (isBlobLike(data)) {
          const frame = new WebsocketFrameSend();
          data.arrayBuffer().then((ab) => {
            const value = Buffer.from(ab);
            frame.frameData = value;
            const buffer = frame.createFrame(opcodes.BINARY);
            this.#bufferedAmount += value.byteLength;
            socket.write(buffer, () => {
              this.#bufferedAmount -= value.byteLength;
            });
          });
        }
      }
      get readyState() {
        webidl.brandCheck(this, _WebSocket);
        return this[kReadyState];
      }
      get bufferedAmount() {
        webidl.brandCheck(this, _WebSocket);
        return this.#bufferedAmount;
      }
      get url() {
        webidl.brandCheck(this, _WebSocket);
        return URLSerializer(this[kWebSocketURL]);
      }
      get extensions() {
        webidl.brandCheck(this, _WebSocket);
        return this.#extensions;
      }
      get protocol() {
        webidl.brandCheck(this, _WebSocket);
        return this.#protocol;
      }
      get onopen() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.open;
      }
      set onopen(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.open) {
          this.removeEventListener("open", this.#events.open);
        }
        if (typeof fn === "function") {
          this.#events.open = fn;
          this.addEventListener("open", fn);
        } else {
          this.#events.open = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.error) {
          this.removeEventListener("error", this.#events.error);
        }
        if (typeof fn === "function") {
          this.#events.error = fn;
          this.addEventListener("error", fn);
        } else {
          this.#events.error = null;
        }
      }
      get onclose() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.close;
      }
      set onclose(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.close) {
          this.removeEventListener("close", this.#events.close);
        }
        if (typeof fn === "function") {
          this.#events.close = fn;
          this.addEventListener("close", fn);
        } else {
          this.#events.close = null;
        }
      }
      get onmessage() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.message;
      }
      set onmessage(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.message) {
          this.removeEventListener("message", this.#events.message);
        }
        if (typeof fn === "function") {
          this.#events.message = fn;
          this.addEventListener("message", fn);
        } else {
          this.#events.message = null;
        }
      }
      get binaryType() {
        webidl.brandCheck(this, _WebSocket);
        return this[kBinaryType];
      }
      set binaryType(type) {
        webidl.brandCheck(this, _WebSocket);
        if (type !== "blob" && type !== "arraybuffer") {
          this[kBinaryType] = "blob";
        } else {
          this[kBinaryType] = type;
        }
      }
      /**
       * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
       */
      #onConnectionEstablished(response) {
        this[kResponse] = response;
        const parser = new ByteParser(this);
        parser.on("drain", function onParserDrain() {
          this.ws[kResponse].socket.resume();
        });
        response.socket.ws = this;
        this[kByteParser] = parser;
        this[kReadyState] = states.OPEN;
        const extensions = response.headersList.get("sec-websocket-extensions");
        if (extensions !== null) {
          this.#extensions = extensions;
        }
        const protocol = response.headersList.get("sec-websocket-protocol");
        if (protocol !== null) {
          this.#protocol = protocol;
        }
        fireEvent("open", this);
      }
    };
    WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
    WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
    WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
    WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
    Object.defineProperties(WebSocket.prototype, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors,
      url: kEnumerableProperty,
      readyState: kEnumerableProperty,
      bufferedAmount: kEnumerableProperty,
      onopen: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onclose: kEnumerableProperty,
      close: kEnumerableProperty,
      onmessage: kEnumerableProperty,
      binaryType: kEnumerableProperty,
      send: kEnumerableProperty,
      extensions: kEnumerableProperty,
      protocol: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "WebSocket",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(WebSocket, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors
    });
    webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(
      webidl.converters.DOMString
    );
    webidl.converters["DOMString or sequence<DOMString>"] = function(V) {
      if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) {
        return webidl.converters["sequence<DOMString>"](V);
      }
      return webidl.converters.DOMString(V);
    };
    webidl.converters.WebSocketInit = webidl.dictionaryConverter([
      {
        key: "protocols",
        converter: webidl.converters["DOMString or sequence<DOMString>"],
        get defaultValue() {
          return [];
        }
      },
      {
        key: "dispatcher",
        converter: (V) => V,
        get defaultValue() {
          return getGlobalDispatcher();
        }
      },
      {
        key: "headers",
        converter: webidl.nullableConverter(webidl.converters.HeadersInit)
      }
    ]);
    webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
      if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) {
        return webidl.converters.WebSocketInit(V);
      }
      return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
    };
    webidl.converters.WebSocketSendData = function(V) {
      if (webidl.util.Type(V) === "Object") {
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }
        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
          return webidl.converters.BufferSource(V);
        }
      }
      return webidl.converters.USVString(V);
    };
    module.exports = {
      WebSocket
    };
  }
});

// node_modules/undici/index.js
var require_undici = __commonJS({
  "node_modules/undici/index.js"(exports, module) {
    "use strict";
    var Client2 = require_client();
    var Dispatcher = require_dispatcher();
    var errors = require_errors();
    var Pool = require_pool();
    var BalancedPool = require_balanced_pool();
    var Agent2 = require_agent();
    var util = require_util();
    var { InvalidArgumentError } = errors;
    var api = require_api();
    var buildConnector = require_connect();
    var MockClient = require_mock_client();
    var MockAgent = require_mock_agent();
    var MockPool = require_mock_pool();
    var mockErrors = require_mock_errors();
    var ProxyAgent = require_proxy_agent();
    var RetryHandler = require_RetryHandler();
    var { getGlobalDispatcher, setGlobalDispatcher } = require_global2();
    var DecoratorHandler = require_DecoratorHandler();
    var RedirectHandler = require_RedirectHandler();
    var createRedirectInterceptor = require_redirectInterceptor();
    var hasCrypto;
    try {
      __require("crypto");
      hasCrypto = true;
    } catch {
      hasCrypto = false;
    }
    Object.assign(Dispatcher.prototype, api);
    module.exports.Dispatcher = Dispatcher;
    module.exports.Client = Client2;
    module.exports.Pool = Pool;
    module.exports.BalancedPool = BalancedPool;
    module.exports.Agent = Agent2;
    module.exports.ProxyAgent = ProxyAgent;
    module.exports.RetryHandler = RetryHandler;
    module.exports.DecoratorHandler = DecoratorHandler;
    module.exports.RedirectHandler = RedirectHandler;
    module.exports.createRedirectInterceptor = createRedirectInterceptor;
    module.exports.buildConnector = buildConnector;
    module.exports.errors = errors;
    function makeDispatcher(fn) {
      return (url, opts, handler) => {
        if (typeof opts === "function") {
          handler = opts;
          opts = null;
        }
        if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
          throw new InvalidArgumentError("invalid url");
        }
        if (opts != null && typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (opts && opts.path != null) {
          if (typeof opts.path !== "string") {
            throw new InvalidArgumentError("invalid opts.path");
          }
          let path12 = opts.path;
          if (!opts.path.startsWith("/")) {
            path12 = `/${path12}`;
          }
          url = new URL(util.parseOrigin(url).origin + path12);
        } else {
          if (!opts) {
            opts = typeof url === "object" ? url : {};
          }
          url = util.parseURL(url);
        }
        const { agent, dispatcher = getGlobalDispatcher() } = opts;
        if (agent) {
          throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
        }
        return fn.call(dispatcher, {
          ...opts,
          origin: url.origin,
          path: url.search ? `${url.pathname}${url.search}` : url.pathname,
          method: opts.method || (opts.body ? "PUT" : "GET")
        }, handler);
      };
    }
    module.exports.setGlobalDispatcher = setGlobalDispatcher;
    module.exports.getGlobalDispatcher = getGlobalDispatcher;
    if (util.nodeMajor > 16 || util.nodeMajor === 16 && util.nodeMinor >= 8) {
      let fetchImpl = null;
      module.exports.fetch = async function fetch2(resource) {
        if (!fetchImpl) {
          fetchImpl = require_fetch().fetch;
        }
        try {
          return await fetchImpl(...arguments);
        } catch (err) {
          if (typeof err === "object") {
            Error.captureStackTrace(err, this);
          }
          throw err;
        }
      };
      module.exports.Headers = require_headers().Headers;
      module.exports.Response = require_response().Response;
      module.exports.Request = require_request2().Request;
      module.exports.FormData = require_formdata().FormData;
      module.exports.File = require_file().File;
      module.exports.FileReader = require_filereader().FileReader;
      const { setGlobalOrigin, getGlobalOrigin } = require_global();
      module.exports.setGlobalOrigin = setGlobalOrigin;
      module.exports.getGlobalOrigin = getGlobalOrigin;
      const { CacheStorage } = require_cachestorage();
      const { kConstruct } = require_symbols4();
      module.exports.caches = new CacheStorage(kConstruct);
    }
    if (util.nodeMajor >= 16) {
      const { deleteCookie, getCookies, getSetCookies, setCookie } = require_cookies();
      module.exports.deleteCookie = deleteCookie;
      module.exports.getCookies = getCookies;
      module.exports.getSetCookies = getSetCookies;
      module.exports.setCookie = setCookie;
      const { parseMIMEType, serializeAMimeType } = require_dataURL();
      module.exports.parseMIMEType = parseMIMEType;
      module.exports.serializeAMimeType = serializeAMimeType;
    }
    if (util.nodeMajor >= 18 && hasCrypto) {
      const { WebSocket } = require_websocket();
      module.exports.WebSocket = WebSocket;
    }
    module.exports.request = makeDispatcher(api.request);
    module.exports.stream = makeDispatcher(api.stream);
    module.exports.pipeline = makeDispatcher(api.pipeline);
    module.exports.connect = makeDispatcher(api.connect);
    module.exports.upgrade = makeDispatcher(api.upgrade);
    module.exports.MockClient = MockClient;
    module.exports.MockPool = MockPool;
    module.exports.MockAgent = MockAgent;
    module.exports.mockErrors = mockErrors;
  }
});

// src/providers/mcp-check-provider.ts
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";
import { SSEClientTransport } from "@modelcontextprotocol/sdk/client/sse.js";
import { StreamableHTTPClientTransport } from "@modelcontextprotocol/sdk/client/streamableHttp.js";
var import_undici, parseTimeoutMs, parseRetryValue, sseAgent, sseFetch, McpCheckProvider;
var init_mcp_check_provider = __esm({
  "src/providers/mcp-check-provider.ts"() {
    "use strict";
    init_check_provider_interface();
    init_logger();
    init_liquid_extensions();
    init_sandbox();
    init_env_resolver();
    init_custom_tool_executor();
    import_undici = __toESM(require_undici());
    parseTimeoutMs = (value, fallback) => {
      if (value === void 0 || value === "") {
        return fallback;
      }
      const parsed = Number(value);
      if (Number.isNaN(parsed) || parsed < 0) {
        return fallback;
      }
      return parsed;
    };
    parseRetryValue = (value, fallback) => {
      if (value === void 0 || value === "") {
        return fallback;
      }
      const parsed = Number(value);
      if (Number.isNaN(parsed) || parsed < 0) {
        return fallback;
      }
      return Math.floor(parsed);
    };
    sseAgent = new import_undici.Agent({
      headersTimeout: parseTimeoutMs(process.env.VISOR_MCP_SSE_HEADERS_TIMEOUT_MS, 3e5),
      // 5 minutes
      bodyTimeout: parseTimeoutMs(process.env.VISOR_MCP_SSE_BODY_TIMEOUT_MS, 6e5),
      // 10 minutes
      keepAliveTimeout: parseTimeoutMs(process.env.VISOR_MCP_SSE_KEEP_ALIVE_TIMEOUT_MS, 6e5)
      // 10 minutes
    });
    sseFetch = (input, init) => {
      return fetch(input, {
        ...init,
        // @ts-expect-error - dispatcher is a Node.js specific option
        dispatcher: sseAgent
      });
    };
    McpCheckProvider = class extends CheckProvider {
      liquid;
      sandbox;
      customToolExecutor;
      isRetryableError(error) {
        const err = error;
        const message = typeof err?.message === "string" ? err.message.toLowerCase() : "";
        const code = typeof err?.code === "string" ? err.code.toLowerCase() : "";
        const cause = err?.cause;
        const causeMessage = typeof cause?.message === "string" ? cause.message.toLowerCase() : "";
        const causeCode = typeof cause?.code === "string" ? cause.code.toLowerCase() : "";
        if (this.isTimeoutError(error)) {
          return true;
        }
        const tokens = [
          "fetch failed",
          "econnreset",
          "econnrefused",
          "ehostunreach",
          "enotfound",
          "socket hang up",
          "connection closed",
          "connection terminated"
        ];
        return tokens.some((t) => message.includes(t)) || tokens.some((t) => causeMessage.includes(t)) || tokens.some((t) => code.includes(t)) || tokens.some((t) => causeCode.includes(t));
      }
      isTimeoutError(error) {
        const err = error;
        const message = typeof err?.message === "string" ? err.message.toLowerCase() : "";
        const code = typeof err?.code === "string" ? err.code.toLowerCase() : "";
        const cause = err?.cause;
        const causeMessage = typeof cause?.message === "string" ? cause.message.toLowerCase() : "";
        const causeCode = typeof cause?.code === "string" ? cause.code.toLowerCase() : "";
        return message.includes("timeout") || code.includes("timeout") || causeMessage.includes("timeout") || causeCode.includes("timeout");
      }
      getTimeoutSeverity() {
        const raw = (process.env.VISOR_MCP_TIMEOUT_SEVERITY || "").trim().toLowerCase();
        if (raw === "info" || raw === "warning" || raw === "error" || raw === "critical") {
          return raw;
        }
        return "error";
      }
      constructor() {
        super();
        this.liquid = createExtendedLiquid({
          cache: false,
          strictFilters: false,
          strictVariables: false
        });
      }
      /**
       * Set custom tools for this provider
       */
      setCustomTools(tools) {
        if (!this.customToolExecutor) {
          this.customToolExecutor = new CustomToolExecutor(tools);
        } else {
          this.customToolExecutor.registerTools(tools);
        }
      }
      /**
       * Create a secure sandbox for JavaScript execution
       * - Uses Sandbox.SAFE_GLOBALS which excludes: Function, eval, require, process, etc.
       * - Only allows explicitly whitelisted prototype methods
       * - No access to filesystem, network, or system resources
       */
      createSecureSandbox() {
        return createSecureSandbox();
      }
      getName() {
        return "mcp";
      }
      getDescription() {
        return "Call MCP tools directly using stdio, SSE, HTTP, or custom YAML-defined tools";
      }
      async validateConfig(config) {
        if (!config || typeof config !== "object") {
          return false;
        }
        const cfg = config;
        if (!cfg.method || typeof cfg.method !== "string") {
          logger.error("MCP check requires a method name");
          return false;
        }
        const transport = cfg.transport || "stdio";
        if (transport === "stdio") {
          if (!cfg.command || typeof cfg.command !== "string") {
            logger.error("MCP stdio transport requires a command");
            return false;
          }
          if (/[;&|`$(){}[\]]/.test(cfg.command)) {
            logger.error("MCP stdio command contains potentially unsafe characters");
            return false;
          }
        } else if (transport === "sse" || transport === "http") {
          if (!cfg.url || typeof cfg.url !== "string") {
            logger.error(`MCP ${transport} transport requires a URL`);
            return false;
          }
          try {
            const parsedUrl = new URL(cfg.url);
            if (parsedUrl.protocol !== "http:" && parsedUrl.protocol !== "https:") {
              logger.error(
                `Invalid URL protocol for MCP ${transport} transport: ${parsedUrl.protocol}. Only http: and https: are allowed.`
              );
              return false;
            }
          } catch {
            logger.error(`Invalid URL format for MCP ${transport} transport: ${cfg.url}`);
            return false;
          }
        } else if (transport === "custom") {
          logger.debug(`MCP custom transport will validate tool '${cfg.method}' at execution time`);
        } else {
          logger.error(
            `Invalid MCP transport: ${transport}. Must be 'stdio', 'sse', 'http', or 'custom'`
          );
          return false;
        }
        return true;
      }
      async execute(prInfo, config, dependencyResults, sessionInfo) {
        const cfg = config;
        try {
          const templateContext = {
            pr: {
              number: prInfo.number,
              title: prInfo.title,
              author: prInfo.author,
              branch: prInfo.head,
              base: prInfo.base
            },
            files: prInfo.files,
            fileCount: prInfo.files.length,
            outputs: this.buildOutputContext(dependencyResults),
            args: sessionInfo?.args || {},
            env: this.getSafeEnvironmentVariables()
          };
          let methodArgs = cfg.methodArgs || {};
          if (cfg.argsTransform) {
            const rendered = await this.liquid.parseAndRender(cfg.argsTransform, templateContext);
            try {
              methodArgs = JSON.parse(rendered);
            } catch (error) {
              logger.error(`Failed to parse argsTransform as JSON: ${error}`);
              return {
                issues: [
                  {
                    file: "mcp",
                    line: 0,
                    ruleId: "mcp/args_transform_error",
                    message: `Failed to parse argsTransform: ${error instanceof Error ? error.message : "Unknown error"}`,
                    severity: "error",
                    category: "logic"
                  }
                ]
              };
            }
          }
          const result = await this.executeMcpMethod(cfg, methodArgs, prInfo, dependencyResults);
          let finalOutput = result;
          if (cfg.transform) {
            try {
              const transformContext = {
                ...templateContext,
                output: result
              };
              const rendered = await this.liquid.parseAndRender(cfg.transform, transformContext);
              try {
                finalOutput = JSON.parse(rendered.trim());
              } catch {
                finalOutput = rendered.trim();
              }
            } catch (error) {
              logger.error(`Failed to apply Liquid transform: ${error}`);
              return {
                issues: [
                  {
                    file: "mcp",
                    line: 0,
                    ruleId: "mcp/transform_error",
                    message: `Failed to apply transform: ${error instanceof Error ? error.message : "Unknown error"}`,
                    severity: "error",
                    category: "logic"
                  }
                ]
              };
            }
          }
          if (cfg.transform_js) {
            try {
              this.sandbox = this.createSecureSandbox();
              const scope = {
                output: finalOutput,
                pr: templateContext.pr,
                files: templateContext.files,
                outputs: templateContext.outputs,
                env: templateContext.env
              };
              finalOutput = compileAndRun(
                this.sandbox,
                `return (${cfg.transform_js});`,
                scope,
                { injectLog: true, wrapFunction: false, logPrefix: "[mcp:transform_js]" }
              );
            } catch (error) {
              logger.error(`Failed to apply JavaScript transform: ${error}`);
              return {
                issues: [
                  {
                    file: "mcp",
                    line: 0,
                    ruleId: "mcp/transform_js_error",
                    message: `Failed to apply JavaScript transform: ${error instanceof Error ? error.message : "Unknown error"}`,
                    severity: "error",
                    category: "logic"
                  }
                ]
              };
            }
          }
          const extracted = this.extractIssuesFromOutput(finalOutput);
          if (extracted) {
            return {
              issues: extracted.issues,
              ...extracted.remainingOutput ? { output: extracted.remainingOutput } : {}
            };
          }
          return {
            issues: [],
            ...finalOutput ? { output: finalOutput } : {}
          };
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : "Unknown error";
          const isTimeout = this.isTimeoutError(error);
          const timeoutSeverity = this.getTimeoutSeverity();
          const severity = isTimeout ? timeoutSeverity : "error";
          const ruleId = isTimeout ? "mcp/timeout" : "mcp/execution_error";
          if (isTimeout && severity !== "error" && severity !== "critical") {
            logger.warn(`MCP check timed out (non-fatal): ${errorMessage}`);
          } else {
            logger.error(`MCP check failed: ${errorMessage}`);
          }
          return {
            issues: [
              {
                file: "mcp",
                line: 0,
                ruleId,
                message: isTimeout ? `MCP check timed out: ${errorMessage}` : `MCP check failed: ${errorMessage}`,
                severity,
                category: "logic"
              }
            ]
          };
        }
      }
      /**
       * Execute an MCP method using the configured transport
       */
      async executeMcpMethod(config, methodArgs, prInfo, dependencyResults) {
        const transport = config.transport || "stdio";
        const timeout = (config.timeout || 60) * 1e3;
        if (transport === "custom") {
          if (!this.customToolExecutor) {
            throw new Error(
              'No custom tools available. Define tools in the "tools" section of your configuration.'
            );
          }
          const tool = this.customToolExecutor.getTool(config.method);
          if (!tool) {
            throw new Error(
              `Custom tool not found: ${config.method}. Available tools: ${this.customToolExecutor.getTools().map((t) => t.name).join(", ")}`
            );
          }
          const context2 = {
            pr: prInfo ? {
              number: prInfo.number,
              title: prInfo.title,
              author: prInfo.author,
              branch: prInfo.head,
              base: prInfo.base
            } : void 0,
            files: prInfo?.files,
            outputs: this.buildOutputContext(dependencyResults),
            env: this.getSafeEnvironmentVariables()
          };
          return await this.customToolExecutor.execute(config.method, methodArgs, context2);
        } else if (transport === "stdio") {
          return await this.executeStdioMethod(config, methodArgs, timeout);
        } else if (transport === "sse") {
          return await this.executeSseMethod(config, methodArgs, timeout);
        } else if (transport === "http") {
          return await this.executeHttpMethod(config, methodArgs, timeout);
        } else {
          throw new Error(`Unsupported transport: ${transport}`);
        }
      }
      /**
       * Generic method to execute MCP method with any transport
       */
      async executeWithTransport(createTransport, config, methodArgs, timeout, transportName) {
        const maxRetries = parseRetryValue(process.env.VISOR_MCP_RETRY_COUNT, 0);
        const baseDelayMs = parseRetryValue(process.env.VISOR_MCP_RETRY_DELAY_MS, 1e3);
        const backoffMs = parseRetryValue(process.env.VISOR_MCP_RETRY_BACKOFF_MS, 0);
        let attempt = 0;
        while (true) {
          const client = new Client(
            {
              name: "visor-mcp-client",
              version: "1.0.0"
            },
            {
              capabilities: {}
            }
          );
          const transport = createTransport();
          try {
            let timeoutId;
            try {
              await Promise.race([
                client.connect(transport),
                new Promise((_, reject) => {
                  timeoutId = setTimeout(() => reject(new Error("Connection timeout")), timeout);
                })
              ]);
            } finally {
              if (timeoutId) {
                clearTimeout(timeoutId);
              }
            }
            logger.debug(`Connected to MCP server via ${transportName}`);
            if (transport instanceof StreamableHTTPClientTransport && transport.sessionId) {
              logger.debug(`MCP Session ID: ${transport.sessionId}`);
            }
            try {
              const toolsResult = await client.listTools();
              logger.debug(`Available MCP tools: ${JSON.stringify(toolsResult?.tools || [])}`);
            } catch (error) {
              logger.debug(`Could not list MCP tools: ${error}`);
            }
            let callTimeoutId;
            try {
              const result = await Promise.race([
                client.callTool({
                  name: config.method,
                  arguments: methodArgs
                }),
                new Promise((_, reject) => {
                  callTimeoutId = setTimeout(() => reject(new Error("Request timeout")), timeout);
                })
              ]);
              logger.debug(`MCP method result: ${JSON.stringify(result)}`);
              return result;
            } finally {
              if (callTimeoutId) {
                clearTimeout(callTimeoutId);
              }
            }
          } catch (error) {
            const retryable = this.isRetryableError(error);
            if (!retryable || attempt >= maxRetries) {
              throw error;
            }
            const delay = baseDelayMs + backoffMs * attempt;
            logger.warn(
              `MCP ${transportName} failed (attempt ${attempt + 1}/${maxRetries + 1}), retrying in ${delay}ms: ${error instanceof Error ? error.message : String(error)}`
            );
            await new Promise((resolve5) => setTimeout(resolve5, delay));
            attempt += 1;
          } finally {
            try {
              await client.close();
            } catch (error) {
              logger.debug(`Error closing MCP client: ${error}`);
            }
          }
        }
      }
      /**
       * Execute MCP method using stdio transport
       */
      async executeStdioMethod(config, methodArgs, timeout) {
        return this.executeWithTransport(
          () => new StdioClientTransport({
            command: config.command,
            args: config.command_args,
            env: config.env,
            cwd: config.workingDirectory
          }),
          config,
          methodArgs,
          timeout,
          `stdio: ${config.command}`
        );
      }
      /**
       * Execute MCP method using SSE transport
       */
      async executeSseMethod(config, methodArgs, timeout) {
        const requestInit = {};
        if (config.headers) {
          requestInit.headers = EnvironmentResolver.resolveHeaders(config.headers);
        }
        return this.executeWithTransport(
          () => new SSEClientTransport(new URL(config.url), {
            requestInit,
            fetch: sseFetch
            // Use custom fetch with longer timeouts
          }),
          config,
          methodArgs,
          timeout,
          `SSE: ${config.url}`
        );
      }
      /**
       * Execute MCP method using Streamable HTTP transport
       */
      async executeHttpMethod(config, methodArgs, timeout) {
        const requestInit = {};
        if (config.headers) {
          requestInit.headers = EnvironmentResolver.resolveHeaders(config.headers);
        }
        return this.executeWithTransport(
          () => new StreamableHTTPClientTransport(new URL(config.url), {
            requestInit,
            sessionId: config.sessionId,
            fetch: sseFetch
            // Use custom fetch with longer timeouts
          }),
          config,
          methodArgs,
          timeout,
          `Streamable HTTP: ${config.url}`
        );
      }
      /**
       * Build output context from dependency results
       */
      buildOutputContext(dependencyResults) {
        if (!dependencyResults) {
          return {};
        }
        const outputs = {};
        for (const [checkName, result] of dependencyResults) {
          const summary = result;
          outputs[checkName] = summary.output !== void 0 ? summary.output : summary;
        }
        return outputs;
      }
      /**
       * Get safe environment variables
       */
      getSafeEnvironmentVariables() {
        const safeVars = {};
        const allowedPrefixes = [];
        const { buildSandboxEnv: buildSandboxEnv2 } = (init_env_exposure(), __toCommonJS(env_exposure_exports));
        const merged = buildSandboxEnv2(process.env);
        for (const [key, value] of Object.entries(merged)) {
          safeVars[key] = String(value);
        }
        safeVars["PWD"] = process.cwd();
        return safeVars;
      }
      /**
       * Extract issues from MCP output
       */
      extractIssuesFromOutput(output) {
        if (output === null || output === void 0) {
          return null;
        }
        if (typeof output === "string") {
          try {
            const parsed = JSON.parse(output);
            return this.extractIssuesFromOutput(parsed);
          } catch {
            return null;
          }
        }
        if (Array.isArray(output)) {
          const issues = this.normalizeIssueArray(output);
          if (issues) {
            return { issues, remainingOutput: void 0 };
          }
          return null;
        }
        if (typeof output === "object") {
          const record = output;
          if (Array.isArray(record.issues)) {
            const issues = this.normalizeIssueArray(record.issues);
            if (!issues) {
              return null;
            }
            const remaining = { ...record };
            delete remaining.issues;
            return {
              issues,
              remainingOutput: Object.keys(remaining).length > 0 ? remaining : void 0
            };
          }
          const singleIssue = this.normalizeIssue(record);
          if (singleIssue) {
            return { issues: [singleIssue], remainingOutput: void 0 };
          }
        }
        return null;
      }
      /**
       * Normalize an array of issues
       */
      normalizeIssueArray(values) {
        const normalized = [];
        for (const value of values) {
          const issue = this.normalizeIssue(value);
          if (!issue) {
            return null;
          }
          normalized.push(issue);
        }
        return normalized;
      }
      /**
       * Normalize a single issue
       */
      normalizeIssue(raw) {
        if (!raw || typeof raw !== "object") {
          return null;
        }
        const data = raw;
        const message = this.toTrimmedString(
          data.message || data.text || data.description || data.summary
        );
        if (!message) {
          return null;
        }
        const allowedSeverities = /* @__PURE__ */ new Set(["info", "warning", "error", "critical"]);
        const severityRaw = this.toTrimmedString(data.severity || data.level || data.priority);
        let severity = "warning";
        if (severityRaw) {
          const lower = severityRaw.toLowerCase();
          if (allowedSeverities.has(lower)) {
            severity = lower;
          }
        }
        const allowedCategories = /* @__PURE__ */ new Set([
          "security",
          "performance",
          "style",
          "logic",
          "documentation"
        ]);
        const categoryRaw = this.toTrimmedString(data.category || data.type || data.group);
        let category = "logic";
        if (categoryRaw && allowedCategories.has(categoryRaw.toLowerCase())) {
          category = categoryRaw.toLowerCase();
        }
        const file = this.toTrimmedString(data.file || data.path || data.filename) || "system";
        const line = this.toNumber(data.line || data.startLine || data.lineNumber) ?? 0;
        const endLine = this.toNumber(data.endLine || data.end_line || data.stopLine);
        const suggestion = this.toTrimmedString(data.suggestion);
        const replacement = this.toTrimmedString(data.replacement);
        const ruleId = this.toTrimmedString(data.ruleId || data.rule || data.id || data.check) || "mcp";
        return {
          file,
          line,
          endLine: endLine ?? void 0,
          ruleId,
          message,
          severity,
          category,
          suggestion: suggestion || void 0,
          replacement: replacement || void 0
        };
      }
      toTrimmedString(value) {
        if (typeof value === "string") {
          const trimmed = value.trim();
          return trimmed.length > 0 ? trimmed : null;
        }
        if (value !== null && value !== void 0 && typeof value.toString === "function") {
          const converted = String(value).trim();
          return converted.length > 0 ? converted : null;
        }
        return null;
      }
      toNumber(value) {
        if (value === null || value === void 0) {
          return null;
        }
        const num = Number(value);
        if (Number.isFinite(num)) {
          return Math.trunc(num);
        }
        return null;
      }
      getSupportedConfigKeys() {
        return [
          "type",
          "transport",
          "command",
          "command_args",
          "env",
          "workingDirectory",
          "url",
          "headers",
          "sessionId",
          "method",
          "methodArgs",
          "argsTransform",
          "transform",
          "transform_js",
          "timeout",
          "depends_on",
          "on",
          "if",
          "group"
        ];
      }
      async isAvailable() {
        return true;
      }
      getRequirements() {
        return ["MCP method name specified", "Transport configuration (stdio: command, sse/http: url)"];
      }
    };
  }
});

// src/utils/interactive-prompt.ts
import * as readline from "readline";
async function acquirePromptLock() {
  if (!activePrompt) {
    activePrompt = true;
    return;
  }
  await new Promise((resolve5) => waiters.push(resolve5));
  activePrompt = true;
}
function releasePromptLock() {
  activePrompt = false;
  const next = waiters.shift();
  if (next) next();
}
async function interactivePrompt(options) {
  await acquirePromptLock();
  return new Promise((resolve5, reject) => {
    const dbg = process.env.VISOR_DEBUG === "true";
    try {
      if (dbg) {
        const counts = {
          data: process.stdin.listenerCount("data"),
          end: process.stdin.listenerCount("end"),
          error: process.stdin.listenerCount("error"),
          readable: process.stdin.listenerCount("readable"),
          close: process.stdin.listenerCount("close")
        };
        console.error(
          `[human-input] starting prompt: isTTY=${!!process.stdin.isTTY} active=${activePrompt} waiters=${waiters.length} listeners=${JSON.stringify(counts)}`
        );
      }
    } catch {
    }
    try {
      if (process.stdin.isTTY && typeof process.stdin.setRawMode === "function") {
        process.stdin.setRawMode(false);
      }
      process.stdin.resume();
    } catch {
    }
    try {
      process.stdin.setEncoding("utf8");
    } catch {
    }
    let rl;
    const allowEmpty = options.allowEmpty ?? false;
    const multiline = options.multiline ?? false;
    const defaultValue = options.defaultValue;
    let timeoutId;
    const cleanup = () => {
      if (timeoutId) clearTimeout(timeoutId);
      try {
        rl?.removeAllListeners();
      } catch {
      }
      try {
        rl?.close();
      } catch {
      }
      try {
        if (process.stdin.isTTY && typeof process.stdin.setRawMode === "function") {
          process.stdin.setRawMode(false);
        }
      } catch {
      }
      try {
        process.stdin.pause();
      } catch {
      }
      try {
        releasePromptLock();
      } catch {
      }
      try {
        if (process.stdout.__restoreWrites) {
          process.stdout.__restoreWrites();
        }
      } catch {
      }
      try {
        if (process.stderr.__restoreWrites) {
          process.stderr.__restoreWrites();
        }
      } catch {
      }
      try {
        if (dbg) {
          const counts = {
            data: process.stdin.listenerCount("data"),
            end: process.stdin.listenerCount("end"),
            error: process.stdin.listenerCount("error"),
            readable: process.stdin.listenerCount("readable"),
            close: process.stdin.listenerCount("close")
          };
          console.error(
            `[human-input] cleanup: isTTY=${!!process.stdin.isTTY} active=false waiters=${waiters.length} listeners=${JSON.stringify(counts)}`
          );
        }
      } catch {
      }
    };
    const finish = (value) => {
      cleanup();
      resolve5(value);
    };
    if (options.timeout && options.timeout > 0) {
      timeoutId = setTimeout(() => {
        cleanup();
        if (defaultValue !== void 0) return resolve5(defaultValue);
        return reject(new Error("Input timeout"));
      }, options.timeout);
    }
    const header = [];
    if (options.prompt && options.prompt.trim()) header.push(options.prompt.trim());
    if (multiline) header.push("(Ctrl+D to submit)");
    if (options.placeholder && !multiline) header.push(options.placeholder);
    const width = Math.max(
      20,
      Math.min(process.stdout && process.stdout.columns || 80, 100)
    );
    const dash = "-".repeat(width);
    try {
      console.log("\n" + dash);
      if (header.length) console.log(header.join("\n"));
      console.log(dash);
    } catch {
    }
    if (multiline) {
      rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
        terminal: true
      });
      let buf = "";
      process.stdout.write("> ");
      rl.on("line", (line) => {
        buf += (buf ? "\n" : "") + line;
        process.stdout.write("> ");
      });
      rl.on("close", () => {
        const trimmed = buf.trim();
        if (!trimmed && !allowEmpty && defaultValue === void 0) {
          return reject(new Error("Empty input not allowed"));
        }
        return finish(trimmed || defaultValue || "");
      });
      rl.on("SIGINT", () => {
        try {
          process.stdout.write("\n");
        } catch {
        }
        cleanup();
        process.exit(130);
      });
    } else {
      const readLineRaw = async () => {
        return new Promise((resolveRaw) => {
          let buf = "";
          const onData = (chunk) => {
            const s = chunk.toString("utf8");
            for (let i = 0; i < s.length; i++) {
              const ch = s[i];
              const code = s.charCodeAt(i);
              if (ch === "\n" || ch === "\r") {
                try {
                  process.stdout.write("\n");
                } catch {
                }
                teardown();
                resolveRaw(buf);
                return;
              }
              if (ch === "\b" || code === 127) {
                if (buf.length > 0) {
                  buf = buf.slice(0, -1);
                  try {
                    process.stdout.write("\b \b");
                  } catch {
                  }
                }
                continue;
              }
              if (code === 3) {
                try {
                  process.stdout.write("\n");
                } catch {
                }
                teardown();
                process.exit(130);
              }
              if (code >= 32) {
                buf += ch;
                try {
                  process.stdout.write(ch);
                } catch {
                }
              }
            }
          };
          const teardown = () => {
            try {
              process.stdin.off("data", onData);
            } catch {
            }
            try {
              if (process.stdin.isTTY && typeof process.stdin.setRawMode === "function") {
                process.stdin.setRawMode(false);
              }
            } catch {
            }
          };
          try {
            if (process.stdin.isTTY && typeof process.stdin.setRawMode === "function") {
              process.stdin.setRawMode(true);
            }
          } catch {
          }
          process.stdin.on("data", onData);
          try {
            process.stdout.write("> ");
          } catch {
          }
        });
      };
      (async () => {
        const answer = await readLineRaw();
        const trimmed = (answer || "").trim();
        if (!trimmed && !allowEmpty && defaultValue === void 0) {
          cleanup();
          return reject(new Error("Empty input not allowed"));
        }
        return finish(trimmed || defaultValue || "");
      })().catch((err) => {
        cleanup();
        reject(err);
      });
    }
  });
}
async function simplePrompt(prompt) {
  return new Promise((resolve5) => {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    rl.on("SIGINT", () => {
      try {
        process.stdout.write("\n");
      } catch {
      }
      rl.close();
      process.exit(130);
    });
    rl.question(`${prompt}
> `, (answer) => {
      rl.close();
      resolve5(answer.trim());
    });
  });
}
var activePrompt, waiters;
var init_interactive_prompt = __esm({
  "src/utils/interactive-prompt.ts"() {
    "use strict";
    activePrompt = false;
    waiters = [];
  }
});

// src/utils/stdin-reader.ts
function isStdinAvailable() {
  return !process.stdin.isTTY;
}
async function readStdin(timeout, maxSize = 1024 * 1024) {
  return new Promise((resolve5, reject) => {
    let data = "";
    let timeoutId;
    if (timeout) {
      timeoutId = setTimeout(() => {
        cleanup();
        reject(new Error(`Stdin read timeout after ${timeout}ms`));
      }, timeout);
    }
    const cleanup = () => {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      process.stdin.removeListener("data", onData);
      process.stdin.removeListener("end", onEnd);
      process.stdin.removeListener("error", onError);
      process.stdin.pause();
    };
    const onData = (chunk) => {
      data += chunk.toString();
      if (data.length > maxSize) {
        cleanup();
        reject(new Error(`Input exceeds maximum size of ${maxSize} bytes`));
      }
    };
    const onEnd = () => {
      cleanup();
      resolve5(data.trim());
    };
    const onError = (err) => {
      cleanup();
      reject(err);
    };
    process.stdin.setEncoding("utf8");
    process.stdin.on("data", onData);
    process.stdin.on("end", onEnd);
    process.stdin.on("error", onError);
    process.stdin.resume();
  });
}
async function tryReadStdin(timeout, maxSize = 1024 * 1024) {
  if (!isStdinAvailable()) {
    return null;
  }
  try {
    return await readStdin(timeout, maxSize);
  } catch {
    return null;
  }
}
var init_stdin_reader = __esm({
  "src/utils/stdin-reader.ts"() {
    "use strict";
  }
});

// src/providers/human-input-check-provider.ts
import * as fs8 from "fs";
import * as path10 from "path";
var HumanInputCheckProvider;
var init_human_input_check_provider = __esm({
  "src/providers/human-input-check-provider.ts"() {
    "use strict";
    init_check_provider_interface();
    init_interactive_prompt();
    init_prompt_state();
    init_liquid_extensions();
    init_stdin_reader();
    HumanInputCheckProvider = class _HumanInputCheckProvider extends CheckProvider {
      liquid;
      /**
       * @deprecated Use ExecutionContext.cliMessage instead
       * Kept for backward compatibility
       */
      static cliMessage;
      /**
       * @deprecated Use ExecutionContext.hooks instead
       * Kept for backward compatibility
       */
      static hooks = {};
      /**
       * Set the CLI message value (from --message argument)
       * @deprecated Use ExecutionContext.cliMessage instead
       */
      static setCLIMessage(message) {
        _HumanInputCheckProvider.cliMessage = message;
      }
      /**
       * Get the current CLI message value
       * @deprecated Use ExecutionContext.cliMessage instead
       */
      static getCLIMessage() {
        return _HumanInputCheckProvider.cliMessage;
      }
      /**
       * Set hooks for SDK mode
       * @deprecated Use ExecutionContext.hooks instead
       */
      static setHooks(hooks) {
        _HumanInputCheckProvider.hooks = hooks;
      }
      getName() {
        return "human-input";
      }
      getDescription() {
        return "Prompts for human input during workflow execution (CLI interactive or SDK hook)";
      }
      async validateConfig(config) {
        if (!config || typeof config !== "object") {
          return false;
        }
        const cfg = config;
        if (cfg.type !== "human-input") {
          return false;
        }
        if (!cfg.prompt || typeof cfg.prompt !== "string") {
          console.error('human-input check requires a "prompt" field');
          return false;
        }
        return true;
      }
      /** Build a template context for Liquid rendering */
      buildTemplateContext(prInfo, dependencyResults, outputHistory, _context) {
        const ctx = {};
        try {
          ctx.pr = {
            number: prInfo.number,
            title: prInfo.title,
            body: prInfo.body,
            author: prInfo.author,
            base: prInfo.base,
            head: prInfo.head,
            files: (prInfo.files || []).map((f) => ({
              filename: f.filename,
              status: f.status,
              additions: f.additions,
              deletions: f.deletions,
              changes: f.changes
            }))
          };
        } catch {
        }
        try {
          const safeEnv = (() => {
            try {
              const { buildSandboxEnv: buildSandboxEnv2 } = (init_env_exposure(), __toCommonJS(env_exposure_exports));
              return buildSandboxEnv2(process.env);
            } catch {
              return {};
            }
          })();
          ctx.event = { event_name: prInfo?.eventType || "manual" };
          ctx.env = safeEnv;
        } catch {
        }
        ctx.utils = {
          now: (/* @__PURE__ */ new Date()).toISOString(),
          today: (/* @__PURE__ */ new Date()).toISOString().split("T")[0]
        };
        const outputs = {};
        const outputsRaw = {};
        if (dependencyResults) {
          for (const [name, res] of dependencyResults.entries()) {
            const summary = res;
            if (typeof name === "string" && name.endsWith("-raw")) {
              outputsRaw[name.slice(0, -4)] = summary.output !== void 0 ? summary.output : summary;
            } else {
              outputs[name] = summary.output !== void 0 ? summary.output : summary;
            }
          }
        }
        ctx.outputs = outputs;
        ctx.outputs_raw = outputsRaw;
        const hist = {};
        if (outputHistory) {
          for (const [k, v] of outputHistory.entries()) hist[k] = Array.isArray(v) ? v : [];
        }
        ctx.outputs_history = hist;
        try {
          const anyCtx = _context;
          const checksMeta = anyCtx?.checksMeta;
          if (checksMeta && typeof checksMeta === "object") {
            ctx.checks_meta = checksMeta;
          }
        } catch {
        }
        return ctx;
      }
      /**
       * Check if a string looks like a file path
       */
      looksLikePath(str) {
        return str.includes("/") || str.includes("\\");
      }
      /**
       * Sanitize user input to prevent injection attacks in dependent checks
       * Removes potentially dangerous characters while preserving useful input
       */
      sanitizeInput(input) {
        const collapseStutter = (s) => {
          if (!s || s.length < 4) return s;
          let dupPairs = 0;
          let pairs = 0;
          for (let i = 0; i + 1 < s.length; i++) {
            const a = s[i];
            const b = s[i + 1];
            if (/^[\x20-\x7E]$/.test(a) && /^[\x20-\x7E]$/.test(b)) {
              pairs++;
              if (a === b) dupPairs++;
            }
          }
          const ratio = pairs > 0 ? dupPairs / pairs : 0;
          if (ratio < 0.5) return s;
          let out = "";
          for (let i = 0; i < s.length; i++) {
            const a = s[i];
            const b = i + 1 < s.length ? s[i + 1] : "";
            if (b && a === b) {
              out += a;
              i++;
            } else {
              out += a;
            }
          }
          return out;
        };
        input = collapseStutter(input);
        let sanitized = input.replace(/\0/g, "");
        sanitized = sanitized.replace(/[\x00-\x08\x0B-\x0C\x0E-\x1F\x7F]/g, "");
        const maxLength = 100 * 1024;
        if (sanitized.length > maxLength) {
          sanitized = sanitized.substring(0, maxLength);
        }
        return sanitized;
      }
      /**
       * Try to read message from file if it exists
       * Validates path to prevent directory traversal attacks
       */
      async tryReadFile(filePath) {
        try {
          const absolutePath = path10.isAbsolute(filePath) ? filePath : path10.resolve(process.cwd(), filePath);
          const normalizedPath = path10.normalize(absolutePath);
          const cwd = process.cwd();
          if (!normalizedPath.startsWith(cwd + path10.sep) && normalizedPath !== cwd) {
            return null;
          }
          try {
            await fs8.promises.access(normalizedPath, fs8.constants.R_OK);
            const stats = await fs8.promises.stat(normalizedPath);
            if (!stats.isFile()) {
              return null;
            }
            const content = await fs8.promises.readFile(normalizedPath, "utf-8");
            return content.trim();
          } catch {
            return null;
          }
        } catch {
        }
        return null;
      }
      /**
       * Get user input through various methods
       */
      async getUserInput(checkName, config, context2) {
        try {
          const payload = context2?.webhookContext?.webhookData?.get(
            config?.endpoint || "/bots/slack/support"
          );
          const ev = payload && payload.event;
          const channel = ev && String(ev.channel || "");
          const threadTs = ev && String(ev.thread_ts || ev.ts || ev.event_ts || "");
          const text = ev && String(ev.text || "");
          if (channel && threadTs) {
            const mgr = getPromptStateManager();
            try {
              const waiting2 = mgr.getWaiting(channel, threadTs);
              const promptsPosted = waiting2?.promptsPosted || 0;
              if (promptsPosted === 0 && mgr.hasUnconsumedFirstMessage(channel, threadTs)) {
                const first = mgr.consumeFirstMessage(channel, threadTs);
                if (first && first.trim().length > 0) {
                  return first;
                }
              }
            } catch {
            }
            const waiting = mgr.getWaiting(channel, threadTs);
            if (waiting && waiting.checkName === checkName) {
              const answer = text.replace(/<@[A-Z0-9]+>/gi, "").trim();
              mgr.clear(channel, threadTs);
              if (!answer && config.allow_empty !== true) {
              } else {
                return answer || config.default || "";
              }
            } else {
              const prompt2 = String(config.prompt || "Please provide input:");
              try {
                await context2?.eventBus?.emit({
                  type: "HumanInputRequested",
                  checkId: checkName,
                  prompt: prompt2,
                  channel,
                  threadTs,
                  threadKey: `${channel}:${threadTs}`
                });
              } catch {
              }
              throw this.buildAwaitingError(checkName, prompt2);
            }
          }
        } catch (e) {
          if (e && e.issues) throw e;
        }
        try {
          const mockVal = context2?.hooks?.mockForStep?.(checkName);
          if (mockVal !== void 0 && mockVal !== null) {
            const s = String(mockVal);
            return s;
          }
        } catch {
        }
        const prompt = config.prompt || "Please provide input:";
        const placeholder = config.placeholder || "Enter your response...";
        const allowEmpty = config.allow_empty ?? false;
        const multiline = config.multiline ?? false;
        const timeout = config.timeout ? config.timeout * 1e3 : void 0;
        const defaultValue = config.default;
        const testMode = String(process.env.VISOR_TEST_MODE || "").toLowerCase() === "true";
        const ciMode = String(process.env.CI || "").toLowerCase() === "true" || String(process.env.GITHUB_ACTIONS || "").toLowerCase() === "true";
        if (testMode || ciMode) {
          const val = config.default || "";
          return val;
        }
        const cliMessage = context2?.cliMessage ?? _HumanInputCheckProvider.cliMessage;
        if (cliMessage !== void 0) {
          const message = cliMessage;
          if (this.looksLikePath(message)) {
            const fileContent = await this.tryReadFile(message);
            if (fileContent !== null) {
              return fileContent;
            }
          }
          return message;
        }
        const stdinInput = await tryReadStdin(timeout);
        if (stdinInput !== null && stdinInput.length > 0) {
          return stdinInput;
        }
        const hooks = context2?.hooks ?? _HumanInputCheckProvider.hooks;
        if (hooks?.onHumanInput) {
          const request = {
            checkId: checkName,
            prompt,
            placeholder,
            allowEmpty,
            multiline,
            timeout,
            default: defaultValue
          };
          try {
            const result = await hooks.onHumanInput(request);
            return result;
          } catch (error) {
            throw new Error(
              `Hook onHumanInput failed: ${error instanceof Error ? error.message : String(error)}`
            );
          }
        }
        if (process.stdin.isTTY) {
          try {
            const result = await interactivePrompt({
              prompt,
              placeholder,
              multiline,
              timeout,
              defaultValue,
              allowEmpty
            });
            return result;
          } catch (error) {
            throw new Error(
              `Interactive prompt failed: ${error instanceof Error ? error.message : String(error)}`
            );
          }
        }
        try {
          const result = await simplePrompt(prompt);
          if (!result && !allowEmpty && !defaultValue) {
            throw new Error("Empty input not allowed");
          }
          return result || defaultValue || "";
        } catch (error) {
          throw new Error(
            `Simple prompt failed: ${error instanceof Error ? error.message : String(error)}`
          );
        }
      }
      /** Build a deterministic, fatal error used to pause Slack-driven runs. */
      buildAwaitingError(checkName, prompt) {
        const err = new Error(`awaiting human input for ${checkName}`);
        err.issues = [
          {
            file: "system",
            line: 0,
            ruleId: `${checkName}/execution_error`,
            message: `Awaiting human input (Slack thread): ${prompt.slice(0, 80)}`,
            severity: "error",
            category: "logic"
          }
        ];
        return err;
      }
      async execute(_prInfo, config, _dependencyResults, context2) {
        const checkName = config.checkName || "human-input";
        try {
          try {
            this.liquid = this.liquid || createExtendedLiquid({ strictVariables: false, strictFilters: false });
            const tctx = this.buildTemplateContext(
              _prInfo,
              _dependencyResults,
              config.__outputHistory,
              context2
            );
            if (typeof config.prompt === "string") {
              let rendered = await this.liquid.parseAndRender(config.prompt, tctx);
              if (/\{\{|\{%/.test(rendered)) {
                try {
                  rendered = await this.liquid.parseAndRender(rendered, tctx);
                } catch {
                }
              }
              try {
                const stepName = config.checkName || "unknown";
                context2?.hooks?.onPromptCaptured?.({
                  step: String(stepName),
                  provider: "human-input",
                  prompt: rendered
                });
              } catch {
              }
              config = { ...config, prompt: rendered };
            }
            if (typeof config.placeholder === "string") {
              let ph = await this.liquid.parseAndRender(config.placeholder, tctx);
              if (/\{\{|\{%/.test(ph)) {
                try {
                  ph = await this.liquid.parseAndRender(ph, tctx);
                } catch {
                }
              }
              config.placeholder = ph;
            }
          } catch (e) {
            const err = e || {};
            const raw = String(config?.prompt || "");
            const lines = raw.split(/\r?\n/);
            const lineNum = Number(err.line || err?.token?.line || err?.location?.line || 0);
            const colNum = Number(err.col || err?.token?.col || err?.location?.col || 0);
            let snippet = "";
            if (lineNum > 0) {
              const start = Math.max(1, lineNum - 3);
              const end = Math.max(lineNum + 2, lineNum);
              const width = String(end).length;
              for (let i = start; i <= Math.min(end, lines.length); i++) {
                const ln = `${String(i).padStart(width, " ")} | ${lines[i - 1] ?? ""}`;
                snippet += ln + "\n";
                if (i === lineNum) {
                  const caretPad = " ".repeat(Math.max(0, colNum > 1 ? colNum - 1 : 0) + width + 3);
                  snippet += caretPad + "^\n";
                }
              }
            }
            try {
              console.error(
                `\u26A0\uFE0F  human-input: Liquid render failed: ${e instanceof Error ? e.message : String(e)}
${snippet}`
              );
            } catch {
            }
          }
          const userInput = await this.getUserInput(checkName, config, context2);
          const sanitizedInput = this.sanitizeInput(userInput);
          return {
            issues: [],
            output: { text: sanitizedInput, ts: Date.now() }
          };
        } catch (error) {
          if (error && error.issues) {
            const summary = {
              issues: error.issues
            };
            summary.awaitingHumanInput = true;
            return summary;
          }
          return {
            issues: [
              {
                file: "",
                line: 0,
                ruleId: "human-input-error",
                message: `Failed to get user input: ${error instanceof Error ? error.message : String(error)}`,
                severity: "error",
                category: "logic"
              }
            ]
          };
        }
      }
      getSupportedConfigKeys() {
        return [
          "type",
          "prompt",
          "placeholder",
          "allow_empty",
          "multiline",
          "timeout",
          "default",
          "depends_on",
          "on",
          "if",
          "group"
        ];
      }
      async isAvailable() {
        return true;
      }
      getRequirements() {
        return [
          "No external dependencies required",
          "Works in CLI mode with --message argument, piped stdin, or interactive prompts",
          "SDK mode requires onHumanInput hook to be configured"
        ];
      }
    };
  }
});

// src/providers/script-check-provider.ts
var ScriptCheckProvider;
var init_script_check_provider = __esm({
  "src/providers/script-check-provider.ts"() {
    "use strict";
    init_check_provider_interface();
    init_liquid_extensions();
    init_logger();
    init_memory_store();
    init_sandbox();
    init_template_context();
    init_script_memory_ops();
    ScriptCheckProvider = class extends CheckProvider {
      liquid;
      constructor() {
        super();
        this.liquid = createExtendedLiquid({
          strictVariables: false,
          strictFilters: false
        });
      }
      createSecureSandbox() {
        return createSecureSandbox();
      }
      getName() {
        return "script";
      }
      getDescription() {
        return "Execute JavaScript with access to PR context, dependency outputs, and memory.";
      }
      async validateConfig(config) {
        if (!config || typeof config !== "object") return false;
        const cfg = config;
        if (typeof cfg.content !== "string") return false;
        const trimmed = cfg.content.trim();
        if (trimmed.length === 0) return false;
        try {
          const bytes = Buffer.byteLength(cfg.content, "utf8");
          if (bytes > 1024 * 1024) return false;
        } catch {
        }
        if (cfg.content.indexOf("\0") >= 0) return false;
        return true;
      }
      async execute(prInfo, config, dependencyResults, _sessionInfo) {
        try {
          const stepName = config.checkName || "unknown";
          const mock = _sessionInfo?.hooks?.mockForStep?.(String(stepName));
          if (mock !== void 0) {
            return { issues: [], output: mock };
          }
        } catch {
        }
        const script = String(config.content || "");
        const memoryStore = MemoryStore.getInstance();
        const ctx = buildProviderTemplateContext(
          prInfo,
          dependencyResults,
          memoryStore,
          config.__outputHistory,
          _sessionInfo?.stageHistoryBase,
          { attachMemoryReadHelpers: false, args: _sessionInfo?.args }
        );
        const inputs = config.workflowInputs || _sessionInfo?.workflowInputs || {};
        ctx.inputs = inputs;
        ctx.env = process.env;
        const { ops, needsSave } = createSyncMemoryOps(memoryStore);
        ctx.memory = ops;
        ctx.escapeXml = (str) => {
          if (str == null) return "";
          return String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
        };
        ctx.btoa = (str) => {
          return Buffer.from(String(str), "binary").toString("base64");
        };
        ctx.atob = (str) => {
          return Buffer.from(String(str), "base64").toString("binary");
        };
        const sandbox = this.createSecureSandbox();
        let result;
        try {
          result = compileAndRun(
            sandbox,
            script,
            { ...ctx },
            {
              injectLog: true,
              wrapFunction: true,
              logPrefix: "[script]"
            }
          );
        } catch (error) {
          const msg = error instanceof Error ? error.message : "Unknown error";
          logger.error(`[script] execution error: ${msg}`);
          return {
            issues: [
              {
                file: "script",
                line: 0,
                ruleId: "script/execution_error",
                message: msg,
                severity: "error",
                category: "logic"
              }
            ],
            output: null
          };
        }
        try {
          if (needsSave() && memoryStore.getConfig().storage === "file" && memoryStore.getConfig().auto_save) {
            await memoryStore.save();
          }
        } catch (e) {
          logger.warn(`[script] memory save failed: ${e instanceof Error ? e.message : String(e)}`);
        }
        try {
          if (process.env.VISOR_DEBUG === "true") {
            const name = String(config.checkName || "");
            const t = typeof result;
            console.error(
              `[script-return] ${name} outputType=${t} hasArray=${Array.isArray(result)} hasObj=${result && typeof result === "object"}`
            );
          }
        } catch {
        }
        const out = { issues: [], output: result };
        try {
          out.__histTracked = true;
        } catch {
        }
        return out;
      }
      getSupportedConfigKeys() {
        return [
          "type",
          "content",
          "depends_on",
          "group",
          "on",
          "if",
          "fail_if",
          "on_fail",
          "on_success"
        ];
      }
      async isAvailable() {
        return true;
      }
      getRequirements() {
        return ["No external dependencies required"];
      }
      // No local buildTemplateContext; uses shared builder above
    };
  }
});

// src/utils/worktree-manager.ts
import * as fs9 from "fs";
import * as fsp2 from "fs/promises";
import * as path11 from "path";
import * as crypto from "crypto";
var WorktreeManager, worktreeManager;
var init_worktree_manager = __esm({
  "src/utils/worktree-manager.ts"() {
    "use strict";
    init_command_executor();
    init_logger();
    WorktreeManager = class _WorktreeManager {
      static instance;
      config;
      activeWorktrees;
      cleanupHandlersRegistered = false;
      constructor() {
        let cwd;
        try {
          cwd = process.cwd() || "/tmp";
        } catch {
          cwd = "/tmp";
        }
        const defaultBasePath = process.env.VISOR_WORKTREE_PATH || path11.join(cwd, ".visor", "worktrees");
        this.config = {
          enabled: true,
          base_path: defaultBasePath,
          cleanup_on_exit: true,
          max_age_hours: 24
        };
        this.activeWorktrees = /* @__PURE__ */ new Map();
        this.ensureDirectories();
        this.registerCleanupHandlers();
      }
      static getInstance() {
        if (!_WorktreeManager.instance) {
          _WorktreeManager.instance = new _WorktreeManager();
        }
        return _WorktreeManager.instance;
      }
      /**
       * Update configuration
       */
      configure(config) {
        this.config = { ...this.config, ...config };
        this.ensureDirectories();
      }
      getConfig() {
        return { ...this.config };
      }
      /**
       * Ensure base directories exist
       */
      ensureDirectories() {
        if (!this.config.base_path) {
          logger.debug("Skipping directory creation: base_path not initialized");
          return;
        }
        const reposDir = this.getReposDir();
        const worktreesDir = this.getWorktreesDir();
        if (!fs9.existsSync(reposDir)) {
          fs9.mkdirSync(reposDir, { recursive: true });
          logger.debug(`Created repos directory: ${reposDir}`);
        }
        if (!fs9.existsSync(worktreesDir)) {
          fs9.mkdirSync(worktreesDir, { recursive: true });
          logger.debug(`Created worktrees directory: ${worktreesDir}`);
        }
      }
      getReposDir() {
        return path11.join(this.config.base_path, "repos");
      }
      getWorktreesDir() {
        return path11.join(this.config.base_path, "worktrees");
      }
      /**
       * Generate a deterministic worktree ID based on repository and ref.
       * This allows worktrees to be reused when the same repo+ref is requested again.
       */
      generateWorktreeId(repository, ref) {
        const sanitizedRepo = repository.replace(/[^a-zA-Z0-9-]/g, "-");
        const sanitizedRef = ref.replace(/[^a-zA-Z0-9-]/g, "-");
        const hash = crypto.createHash("md5").update(`${repository}:${ref}`).digest("hex").substring(0, 8);
        return `${sanitizedRepo}-${sanitizedRef}-${hash}`;
      }
      /**
       * Get or create bare repository
       */
      async getOrCreateBareRepo(repository, repoUrl, token, fetchDepth, cloneTimeoutMs) {
        const reposDir = this.getReposDir();
        const repoName = repository.replace(/\//g, "-");
        const bareRepoPath = path11.join(reposDir, `${repoName}.git`);
        if (fs9.existsSync(bareRepoPath)) {
          logger.debug(`Bare repository already exists: ${bareRepoPath}`);
          const verifyResult = await this.verifyBareRepoRemote(bareRepoPath, repoUrl);
          if (verifyResult === "timeout") {
            logger.info(`Using stale bare repository (verification timed out): ${bareRepoPath}`);
            return bareRepoPath;
          } else if (verifyResult === false) {
            logger.warn(
              `Bare repository at ${bareRepoPath} has incorrect remote, removing and re-cloning`
            );
            await fsp2.rm(bareRepoPath, { recursive: true, force: true });
          } else {
            await this.updateBareRepo(bareRepoPath);
            return bareRepoPath;
          }
        }
        const cloneUrl = this.buildAuthenticatedUrl(repoUrl, token);
        const redactedUrl = this.redactUrl(cloneUrl);
        logger.info(
          `Cloning bare repository: ${redactedUrl}${fetchDepth ? ` (depth: ${fetchDepth})` : ""}`
        );
        let cloneCmd = `git clone --bare`;
        if (fetchDepth && fetchDepth > 0) {
          const depth = parseInt(String(fetchDepth), 10);
          if (isNaN(depth) || depth < 1) {
            throw new Error("fetch_depth must be a positive integer");
          }
          cloneCmd += ` --depth ${depth}`;
        }
        cloneCmd += ` ${this.escapeShellArg(cloneUrl)} ${this.escapeShellArg(bareRepoPath)}`;
        const result = await this.executeGitCommand(cloneCmd, {
          timeout: cloneTimeoutMs || 3e5
          // default 5 minutes
        });
        if (result.exitCode !== 0) {
          const redactedStderr = this.redactUrl(result.stderr);
          throw new Error(`Failed to clone bare repository: ${redactedStderr}`);
        }
        logger.info(`Successfully cloned bare repository to ${bareRepoPath}`);
        return bareRepoPath;
      }
      /**
       * Update bare repository refs
       */
      async updateBareRepo(bareRepoPath) {
        logger.debug(`Updating bare repository: ${bareRepoPath}`);
        try {
          const updateCmd = `git -C ${this.escapeShellArg(bareRepoPath)} remote update --prune`;
          const result = await this.executeGitCommand(updateCmd, { timeout: 6e4 });
          if (result.exitCode !== 0) {
            logger.warn(`Failed to update bare repository: ${result.stderr}`);
          } else {
            logger.debug(`Successfully updated bare repository`);
          }
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          logger.warn(`Failed to update bare repository (will use stale refs): ${errorMessage}`);
        }
      }
      /**
       * Verify that a bare repository has the correct remote URL.
       * This prevents reusing corrupted repos that were cloned from a different repository.
       * Returns: true (valid), false (invalid - should re-clone), or 'timeout' (use stale cache)
       */
      async verifyBareRepoRemote(bareRepoPath, expectedUrl) {
        try {
          const cmd = `git -C ${this.escapeShellArg(bareRepoPath)} remote get-url origin`;
          const result = await this.executeGitCommand(cmd, { timeout: 1e4 });
          if (result.exitCode !== 0) {
            logger.warn(`Failed to get remote URL for ${bareRepoPath}: ${result.stderr}`);
            return false;
          }
          const actualUrl = result.stdout.trim();
          const normalizeUrl = (url) => {
            if (url.startsWith("git@github.com:")) {
              url = url.replace("git@github.com:", "https://github.com/");
            }
            return url.replace(/:\/\/[^@]+@/, "://").replace(/\.git$/, "").replace(/\/$/, "").toLowerCase();
          };
          const normalizedExpected = normalizeUrl(expectedUrl);
          const normalizedActual = normalizeUrl(actualUrl);
          if (normalizedExpected !== normalizedActual) {
            logger.warn(`Bare repo remote mismatch: expected ${expectedUrl}, got ${actualUrl}`);
            return false;
          }
          logger.debug(`Bare repo remote verified: ${actualUrl}`);
          return true;
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          if (errorMessage.includes("timed out")) {
            logger.warn(`Timeout verifying bare repo remote (will use stale cache): ${errorMessage}`);
            return "timeout";
          }
          logger.warn(`Error verifying bare repo remote: ${error}`);
          return false;
        }
      }
      /**
       * Create a new worktree for the given repository/ref.
       *
       * Important: we always create worktrees in a detached HEAD state pinned
       * to a specific commit SHA rather than a named branch like "main". Git
       * only allows a branch to be checked out in a single worktree at a time;
       * using the raw commit (plus --detach) lets multiple workflows safely
       * create independent worktrees for the same branch without hitting
       * errors like:
       *
       *   fatal: 'main' is already used by worktree at '.../TykTechnologies-tyk-docs-main-XXXX'
       */
      async createWorktree(repository, repoUrl, ref, options = {}) {
        this.validateRef(ref);
        const bareRepoPath = await this.getOrCreateBareRepo(
          repository,
          repoUrl,
          options.token,
          options.fetchDepth,
          options.cloneTimeoutMs
        );
        const worktreeId = this.generateWorktreeId(repository, ref);
        let worktreePath = options.workingDirectory || path11.join(this.getWorktreesDir(), worktreeId);
        if (options.workingDirectory) {
          worktreePath = this.validatePath(options.workingDirectory);
        }
        if (fs9.existsSync(worktreePath)) {
          logger.debug(`Worktree already exists: ${worktreePath}`);
          const metadata2 = await this.loadMetadata(worktreePath);
          if (metadata2) {
            if (metadata2.ref === ref) {
              try {
                const bareRepoPath2 = metadata2.bare_repo_path || await this.getOrCreateBareRepo(
                  repository,
                  repoUrl,
                  options.token,
                  options.fetchDepth,
                  options.cloneTimeoutMs
                );
                const fetched2 = await this.fetchRef(bareRepoPath2, ref);
                if (fetched2) {
                  const latestCommit = await this.getCommitShaForRef(bareRepoPath2, ref);
                  if (latestCommit && latestCommit !== metadata2.commit) {
                    logger.info(
                      `Worktree ref ${ref} advanced (${metadata2.commit} -> ${latestCommit}), updating...`
                    );
                    const checkoutCmd = `git -C ${this.escapeShellArg(worktreePath)} checkout --detach ${this.escapeShellArg(latestCommit)}`;
                    const checkoutResult = await this.executeGitCommand(checkoutCmd, {
                      timeout: 6e4
                    });
                    if (checkoutResult.exitCode !== 0) {
                      throw new Error(`Failed to checkout updated ref: ${checkoutResult.stderr}`);
                    }
                    const updatedMetadata = {
                      ...metadata2,
                      commit: latestCommit,
                      created_at: (/* @__PURE__ */ new Date()).toISOString()
                    };
                    await this.saveMetadata(worktreePath, updatedMetadata);
                    if (options.clean) {
                      logger.debug(`Cleaning updated worktree`);
                      await this.cleanWorktree(worktreePath);
                    }
                    this.activeWorktrees.set(worktreeId, updatedMetadata);
                    return {
                      id: worktreeId,
                      path: worktreePath,
                      ref: updatedMetadata.ref,
                      commit: updatedMetadata.commit,
                      metadata: updatedMetadata,
                      locked: false
                    };
                  }
                }
              } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                logger.warn(`Failed to refresh worktree, will reuse existing: ${errorMessage}`);
              }
              if (options.clean) {
                logger.debug(`Cleaning existing worktree`);
                await this.cleanWorktree(worktreePath);
              }
              this.activeWorktrees.set(worktreeId, metadata2);
              return {
                id: worktreeId,
                path: worktreePath,
                ref: metadata2.ref,
                commit: metadata2.commit,
                metadata: metadata2,
                locked: false
              };
            } else {
              logger.info(
                `Worktree exists with different ref (${metadata2.ref} -> ${ref}), updating...`
              );
              try {
                const bareRepoPath2 = metadata2.bare_repo_path || await this.getOrCreateBareRepo(
                  repository,
                  repoUrl,
                  options.token,
                  options.fetchDepth,
                  options.cloneTimeoutMs
                );
                const fetched2 = await this.fetchRef(bareRepoPath2, ref);
                const newCommit = await this.getCommitShaForRef(bareRepoPath2, ref);
                if (!fetched2) {
                  logger.warn(`Using cached ref ${ref} for update; fetch failed`);
                }
                const checkoutCmd = `git -C ${this.escapeShellArg(worktreePath)} checkout --detach ${this.escapeShellArg(newCommit)}`;
                const checkoutResult = await this.executeGitCommand(checkoutCmd, { timeout: 6e4 });
                if (checkoutResult.exitCode !== 0) {
                  throw new Error(`Failed to checkout new ref: ${checkoutResult.stderr}`);
                }
                const updatedMetadata = {
                  ...metadata2,
                  ref,
                  commit: newCommit,
                  created_at: (/* @__PURE__ */ new Date()).toISOString()
                };
                await this.saveMetadata(worktreePath, updatedMetadata);
                if (options.clean) {
                  logger.debug(`Cleaning updated worktree`);
                  await this.cleanWorktree(worktreePath);
                }
                this.activeWorktrees.set(worktreeId, updatedMetadata);
                logger.info(`Successfully updated worktree to ${ref} (${newCommit})`);
                return {
                  id: worktreeId,
                  path: worktreePath,
                  ref,
                  commit: newCommit,
                  metadata: updatedMetadata,
                  locked: false
                };
              } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                logger.warn(`Failed to update worktree, will recreate: ${errorMessage}`);
                await fsp2.rm(worktreePath, { recursive: true, force: true });
              }
            }
          } else {
            logger.info(`Removing stale directory (no metadata): ${worktreePath}`);
            await fsp2.rm(worktreePath, { recursive: true, force: true });
          }
        }
        const fetched = await this.fetchRef(bareRepoPath, ref);
        const commit = await this.getCommitShaForRef(bareRepoPath, ref);
        if (!fetched) {
          logger.warn(`Using cached ref ${ref}; fetch failed`);
        }
        await this.pruneWorktrees(bareRepoPath);
        logger.info(`Creating worktree for ${repository}@${ref} (${commit})`);
        const createCmd = `git -C ${this.escapeShellArg(
          bareRepoPath
        )} worktree add --detach ${this.escapeShellArg(worktreePath)} ${this.escapeShellArg(commit)}`;
        const result = await this.executeGitCommand(createCmd, { timeout: 6e4 });
        if (result.exitCode !== 0) {
          throw new Error(`Failed to create worktree: ${result.stderr}`);
        }
        const metadata = {
          worktree_id: worktreeId,
          created_at: (/* @__PURE__ */ new Date()).toISOString(),
          workflow_id: options.workflowId,
          ref,
          commit,
          repository,
          pid: process.pid,
          cleanup_on_exit: true,
          bare_repo_path: bareRepoPath,
          worktree_path: worktreePath
        };
        await this.saveMetadata(worktreePath, metadata);
        this.activeWorktrees.set(worktreeId, metadata);
        logger.info(`Successfully created worktree: ${worktreePath}`);
        return {
          id: worktreeId,
          path: worktreePath,
          ref,
          commit,
          metadata,
          locked: false
        };
      }
      /**
       * Prune stale worktree entries from a bare repository.
       * This removes entries for worktrees whose directories no longer exist.
       */
      async pruneWorktrees(bareRepoPath) {
        logger.debug(`Pruning stale worktrees for ${bareRepoPath}`);
        const pruneCmd = `git -C ${this.escapeShellArg(bareRepoPath)} worktree prune`;
        const result = await this.executeGitCommand(pruneCmd, { timeout: 1e4 });
        if (result.exitCode !== 0) {
          logger.warn(`Failed to prune worktrees: ${result.stderr}`);
        } else {
          logger.debug(`Successfully pruned stale worktrees`);
        }
      }
      /**
       * Fetch a specific ref in bare repository
       */
      async fetchRef(bareRepoPath, ref) {
        this.validateRef(ref);
        logger.debug(`Fetching ref: ${ref}`);
        const fetchCmd = `git -C ${this.escapeShellArg(bareRepoPath)} fetch origin ${this.escapeShellArg(ref + ":" + ref)} 2>&1`;
        const result = await this.executeGitCommand(fetchCmd, { timeout: 6e4 });
        if (result.exitCode !== 0) {
          logger.warn(`Failed to fetch ref ${ref}: ${result.stderr}`);
          return false;
        }
        return true;
      }
      /**
       * Clean worktree (reset and remove untracked files)
       */
      async cleanWorktree(worktreePath) {
        const resetCmd = `git -C ${this.escapeShellArg(worktreePath)} reset --hard HEAD`;
        await this.executeGitCommand(resetCmd);
        const cleanCmd = `git -C ${this.escapeShellArg(worktreePath)} clean -fdx`;
        await this.executeGitCommand(cleanCmd);
      }
      /**
       * Get commit SHA for a given ref inside a bare repository.
       *
       * This runs after fetchRef so that <ref> should resolve to either a
       * local branch, tag, or remote-tracking ref.
       *
       * If the ref is "main" or "master" and doesn't exist, automatically
       * falls back to the other common default branch name.
       */
      async getCommitShaForRef(bareRepoPath, ref) {
        const cmd = `git -C ${this.escapeShellArg(bareRepoPath)} rev-parse ${this.escapeShellArg(ref)}`;
        const result = await this.executeGitCommand(cmd);
        if (result.exitCode !== 0) {
          const fallbackRefs = {
            main: "master",
            master: "main"
          };
          const fallbackRef = fallbackRefs[ref];
          if (fallbackRef) {
            logger.debug(`Ref '${ref}' not found, trying fallback '${fallbackRef}'`);
            await this.fetchRef(bareRepoPath, fallbackRef);
            const fallbackCmd = `git -C ${this.escapeShellArg(bareRepoPath)} rev-parse ${this.escapeShellArg(fallbackRef)}`;
            const fallbackResult = await this.executeGitCommand(fallbackCmd);
            if (fallbackResult.exitCode === 0) {
              logger.info(`Using fallback branch '${fallbackRef}' instead of '${ref}'`);
              return fallbackResult.stdout.trim();
            }
          }
          throw new Error(`Failed to get commit SHA for ref ${ref}: ${result.stderr}`);
        }
        return result.stdout.trim();
      }
      /**
       * Remove a worktree
       */
      async removeWorktree(worktreeId) {
        const metadata = this.activeWorktrees.get(worktreeId);
        if (!metadata) {
          logger.warn(`Worktree not found in active list: ${worktreeId}`);
          return;
        }
        const { bare_repo_path, worktree_path } = metadata;
        logger.info(`Removing worktree: ${worktree_path}`);
        const removeCmd = `git -C ${this.escapeShellArg(bare_repo_path)} worktree remove ${this.escapeShellArg(worktree_path)} --force`;
        const result = await this.executeGitCommand(removeCmd, { timeout: 3e4 });
        if (result.exitCode !== 0) {
          logger.warn(`Failed to remove worktree via git: ${result.stderr}`);
          if (fs9.existsSync(worktree_path)) {
            logger.debug(`Manually removing worktree directory`);
            fs9.rmSync(worktree_path, { recursive: true, force: true });
          }
        }
        this.activeWorktrees.delete(worktreeId);
        logger.info(`Successfully removed worktree: ${worktreeId}`);
      }
      /**
       * Save worktree metadata
       */
      async saveMetadata(worktreePath, metadata) {
        const metadataPath = path11.join(worktreePath, ".visor-metadata.json");
        fs9.writeFileSync(metadataPath, JSON.stringify(metadata, null, 2), "utf8");
      }
      /**
       * Load worktree metadata
       */
      async loadMetadata(worktreePath) {
        const metadataPath = path11.join(worktreePath, ".visor-metadata.json");
        if (!fs9.existsSync(metadataPath)) {
          return null;
        }
        try {
          const content = fs9.readFileSync(metadataPath, "utf8");
          return JSON.parse(content);
        } catch (error) {
          logger.warn(`Failed to load metadata: ${error}`);
          return null;
        }
      }
      /**
       * List all worktrees
       */
      async listWorktrees() {
        const worktreesDir = this.getWorktreesDir();
        if (!fs9.existsSync(worktreesDir)) {
          return [];
        }
        const entries = fs9.readdirSync(worktreesDir, { withFileTypes: true });
        const worktrees = [];
        for (const entry of entries) {
          if (!entry.isDirectory()) continue;
          const worktreePath = path11.join(worktreesDir, entry.name);
          const metadata = await this.loadMetadata(worktreePath);
          if (metadata) {
            worktrees.push({
              id: metadata.worktree_id,
              path: worktreePath,
              ref: metadata.ref,
              commit: metadata.commit,
              metadata,
              locked: this.isProcessAlive(metadata.pid)
            });
          }
        }
        return worktrees;
      }
      /**
       * Cleanup stale worktrees
       */
      async cleanupStaleWorktrees() {
        logger.debug("Cleaning up stale worktrees");
        const worktrees = await this.listWorktrees();
        const now = /* @__PURE__ */ new Date();
        const maxAgeMs = this.config.max_age_hours * 60 * 60 * 1e3;
        for (const worktree of worktrees) {
          const createdAt = new Date(worktree.metadata.created_at);
          const ageMs = now.getTime() - createdAt.getTime();
          if (worktree.locked) {
            continue;
          }
          if (ageMs > maxAgeMs) {
            logger.info(
              `Removing stale worktree: ${worktree.id} (age: ${Math.round(ageMs / 1e3 / 60)} minutes)`
            );
            await this.removeWorktree(worktree.id);
          }
        }
      }
      /**
       * Cleanup all worktrees for current process
       */
      async cleanupProcessWorktrees() {
        logger.debug("Cleaning up worktrees for current process");
        const currentPid = process.pid;
        const worktrees = await this.listWorktrees();
        for (const worktree of worktrees) {
          if (worktree.metadata.pid === currentPid && worktree.metadata.cleanup_on_exit) {
            logger.info(`Cleaning up worktree: ${worktree.id}`);
            await this.removeWorktree(worktree.id);
          }
        }
      }
      /**
       * Check if a process is alive
       */
      isProcessAlive(pid) {
        try {
          process.kill(pid, 0);
          return true;
        } catch (_error) {
          return false;
        }
      }
      /**
       * Register cleanup handlers
       */
      registerCleanupHandlers() {
        if (this.cleanupHandlersRegistered) {
          return;
        }
        if (this.config.cleanup_on_exit) {
          process.on("exit", () => {
            logger.debug("Process exiting, cleanup handler triggered");
          });
          process.on("SIGINT", async () => {
            logger.info("SIGINT received, cleaning up worktrees");
            await this.cleanupProcessWorktrees();
            process.exit(130);
          });
          process.on("SIGTERM", async () => {
            logger.info("SIGTERM received, cleaning up worktrees");
            await this.cleanupProcessWorktrees();
            process.exit(143);
          });
          process.on("uncaughtException", async (error) => {
            logger.error(`Uncaught exception, cleaning up worktrees: ${error}`);
            await this.cleanupProcessWorktrees();
            process.exit(1);
          });
        }
        this.cleanupHandlersRegistered = true;
      }
      /**
       * Escape shell argument to prevent command injection
       *
       * Uses POSIX-standard single-quote escaping which prevents ALL shell metacharacter
       * interpretation (including $, `, \, ", ;, &, |, etc.)
       *
       * How it works:
       * - Everything is wrapped in single quotes: 'arg'
       * - Single quotes within are escaped as: '  '\''
       *   (close quote, literal escaped quote, open quote)
       *
       * This is safer than double quotes which still allow $expansion and `backticks`
       *
       * Example: "foo'bar"  'foo'\''bar'
       */
      escapeShellArg(arg) {
        return `'${arg.replace(/'/g, "'\\''")}'`;
      }
      /**
       * Validate git ref to prevent command injection
       */
      validateRef(ref) {
        const safeRefPattern = /^[a-zA-Z0-9._/:-]+$/;
        if (!safeRefPattern.test(ref)) {
          throw new Error(
            `Invalid git ref: ${ref}. Refs must only contain alphanumeric characters, dots, underscores, slashes, colons, and hyphens.`
          );
        }
        if (ref.includes("..") || ref.startsWith("-") || ref.endsWith(".lock")) {
          throw new Error(
            `Invalid git ref: ${ref}. Refs cannot contain '..', start with '-', or end with '.lock'.`
          );
        }
        if (ref.length > 256) {
          throw new Error(`Invalid git ref: ${ref}. Refs cannot exceed 256 characters.`);
        }
      }
      /**
       * Validate path to prevent directory traversal
       */
      validatePath(userPath) {
        const resolvedPath = path11.resolve(userPath);
        if (!path11.isAbsolute(resolvedPath)) {
          throw new Error("Path must be absolute");
        }
        const sensitivePatterns = [
          "/etc",
          "/root",
          "/boot",
          "/sys",
          "/proc",
          "/dev",
          "C:\\Windows\\System32",
          "C:\\Program Files"
        ];
        for (const pattern of sensitivePatterns) {
          if (resolvedPath.startsWith(pattern)) {
            throw new Error(`Access to system directory ${pattern} is not allowed`);
          }
        }
        return resolvedPath;
      }
      /**
       * Redact sensitive tokens from URLs for logging
       */
      redactUrl(url) {
        return url.replace(/x-access-token:[^@]+@/g, "x-access-token:[REDACTED]@").replace(/:\/\/[^:]+:[^@]+@/g, "://[REDACTED]:[REDACTED]@");
      }
      /**
       * Execute a git command
       */
      async executeGitCommand(command, options = {}) {
        const gitEnv = {
          ...process.env,
          ...options.env,
          GIT_TERMINAL_PROMPT: "0",
          GIT_SSH_COMMAND: "ssh -o BatchMode=yes -o StrictHostKeyChecking=no"
        };
        const result = await commandExecutor.execute(command, {
          timeout: options.timeout || 3e4,
          env: gitEnv
        });
        return {
          stdout: result.stdout,
          stderr: result.stderr,
          exitCode: result.exitCode
        };
      }
      /**
       * Build authenticated URL with token
       */
      buildAuthenticatedUrl(repoUrl, token) {
        if (!token) {
          return repoUrl;
        }
        if (repoUrl.includes("github.com")) {
          if (repoUrl.startsWith("git@github.com:")) {
            repoUrl = repoUrl.replace("git@github.com:", "https://github.com/");
          }
          if (repoUrl.startsWith("https://")) {
            return repoUrl.replace("https://", `https://x-access-token:${token}@`);
          }
        }
        return repoUrl;
      }
      /**
       * Get repository URL from repository identifier
       */
      getRepositoryUrl(repository, _token) {
        if (repository.startsWith("http://") || repository.startsWith("https://") || repository.startsWith("git@")) {
          return repository;
        }
        return `https://github.com/${repository}.git`;
      }
    };
    worktreeManager = WorktreeManager.getInstance();
  }
});

// src/providers/git-checkout-provider.ts
var GitCheckoutProvider;
var init_git_checkout_provider = __esm({
  "src/providers/git-checkout-provider.ts"() {
    "use strict";
    init_check_provider_interface();
    init_worktree_manager();
    init_logger();
    init_liquid_extensions();
    init_env_exposure();
    GitCheckoutProvider = class extends CheckProvider {
      liquid = createExtendedLiquid();
      getName() {
        return "git-checkout";
      }
      getDescription() {
        return "Checkout code from git repositories using worktrees for efficient multi-workflow execution";
      }
      async validateConfig(config) {
        if (!config || typeof config !== "object") {
          logger.error("Invalid config: must be an object");
          return false;
        }
        const checkoutConfig = config;
        if (!checkoutConfig.ref || typeof checkoutConfig.ref !== "string") {
          logger.error("Invalid config: ref is required and must be a string");
          return false;
        }
        if (checkoutConfig.fetch_depth !== void 0) {
          if (typeof checkoutConfig.fetch_depth !== "number" || checkoutConfig.fetch_depth < 0) {
            logger.error("Invalid config: fetch_depth must be a non-negative number");
            return false;
          }
        }
        if (checkoutConfig.fetch_tags !== void 0 && typeof checkoutConfig.fetch_tags !== "boolean") {
          logger.error("Invalid config: fetch_tags must be a boolean");
          return false;
        }
        if (checkoutConfig.submodules !== void 0) {
          const validSubmoduleValues = [true, false, "recursive"];
          if (!validSubmoduleValues.includes(checkoutConfig.submodules)) {
            logger.error('Invalid config: submodules must be true, false, or "recursive"');
            return false;
          }
        }
        if (checkoutConfig.sparse_checkout !== void 0 && !Array.isArray(checkoutConfig.sparse_checkout)) {
          logger.error("Invalid config: sparse_checkout must be an array");
          return false;
        }
        if (checkoutConfig.clone_timeout_ms !== void 0) {
          if (typeof checkoutConfig.clone_timeout_ms !== "number" || checkoutConfig.clone_timeout_ms <= 0) {
            logger.error("Invalid config: clone_timeout_ms must be a positive number (milliseconds)");
            return false;
          }
        }
        return true;
      }
      async execute(prInfo, config, dependencyResults, context2) {
        const checkoutConfig = config;
        const issues = [];
        try {
          const stepName = config.checkName || "git-checkout";
          if (process.env.VISOR_DEBUG === "true") {
            logger.debug(
              `[GitCheckout] Mock check: stepName=${stepName}, context=${!!context2}, hooks=${!!context2?.hooks}, mockForStep=${!!context2?.hooks?.mockForStep}`
            );
          }
          const mock = context2?.hooks?.mockForStep?.(String(stepName));
          if (process.env.VISOR_DEBUG === "true") {
            logger.debug(
              `[GitCheckout] Mock result: ${mock !== void 0 ? "found" : "not found"}, value=${JSON.stringify(mock)}`
            );
          }
          if (mock !== void 0) {
            if (mock && typeof mock === "object") {
              const mockOutput = mock;
              if (mockOutput.success === false) {
                const errorMsg = String(mockOutput.error || "Mocked checkout failure");
                if (process.env.VISOR_DEBUG === "true") {
                  logger.debug(`[GitCheckout] Returning mock failure: ${errorMsg}`);
                }
                return {
                  issues: [
                    {
                      file: "git-checkout",
                      line: 0,
                      ruleId: "git-checkout/error",
                      message: `Failed to checkout code: ${errorMsg}`,
                      severity: "error",
                      category: "logic"
                    }
                  ],
                  output: mockOutput
                };
              }
              if (process.env.VISOR_DEBUG === "true") {
                logger.debug(`[GitCheckout] Returning mock success: ${JSON.stringify(mockOutput)}`);
              }
              return { issues: [], output: mockOutput };
            }
            if (process.env.VISOR_DEBUG === "true") {
              logger.debug(`[GitCheckout] Returning primitive mock: ${String(mock)}`);
            }
            return { issues: [], output: { success: true, path: String(mock) } };
          }
        } catch {
        }
        try {
          const templateContext = this.buildTemplateContext(
            prInfo,
            dependencyResults,
            context2,
            checkoutConfig
          );
          let resolvedRef = await this.liquid.parseAndRender(checkoutConfig.ref, templateContext);
          if (!resolvedRef || resolvedRef.trim().length === 0) {
            resolvedRef = "HEAD";
          }
          const resolvedRepository = checkoutConfig.repository ? await this.liquid.parseAndRender(checkoutConfig.repository, templateContext) : process.env.GITHUB_REPOSITORY || "unknown/unknown";
          const resolvedToken = checkoutConfig.token ? await this.liquid.parseAndRender(checkoutConfig.token, templateContext) : void 0;
          const resolvedWorkingDirectory = checkoutConfig.working_directory ? await this.liquid.parseAndRender(checkoutConfig.working_directory, templateContext) : void 0;
          logger.info(`Checking out repository: ${resolvedRepository}@${resolvedRef}`);
          const repoUrl = worktreeManager.getRepositoryUrl(resolvedRepository, resolvedToken);
          const worktree = await worktreeManager.createWorktree(
            resolvedRepository,
            repoUrl,
            resolvedRef,
            {
              token: resolvedToken,
              workingDirectory: resolvedWorkingDirectory,
              clean: checkoutConfig.clean !== false,
              // Default: true
              workflowId: context2?.workflowId,
              fetchDepth: checkoutConfig.fetch_depth,
              cloneTimeoutMs: checkoutConfig.clone_timeout_ms
            }
          );
          const output = {
            success: true,
            path: worktree.path,
            ref: resolvedRef,
            commit: worktree.commit,
            worktree_id: worktree.id,
            repository: resolvedRepository,
            is_worktree: true
          };
          const workspace = context2?._parentContext?.workspace;
          const checkName = config?.checkName || "unknown";
          logger.info(`[GitCheckout] Workspace check for '${checkName}':`);
          logger.info(`[GitCheckout]   _parentContext exists: ${!!context2?._parentContext}`);
          logger.info(`[GitCheckout]   workspace exists: ${!!workspace}`);
          logger.info(`[GitCheckout]   workspace.isEnabled(): ${workspace?.isEnabled?.() ?? "N/A"}`);
          if (workspace) {
            const projectCountBefore = workspace.listProjects?.()?.length ?? "N/A";
            logger.debug(`[GitCheckout]   projects before addProject: ${projectCountBefore}`);
          }
          if (workspace?.isEnabled()) {
            try {
              const workspacePath = await workspace.addProject(resolvedRepository, worktree.path);
              output.workspace_path = workspacePath;
              const projectCountAfter = workspace.listProjects?.()?.length ?? "N/A";
              logger.debug(`[GitCheckout] Added project to workspace: ${workspacePath}`);
              logger.debug(`[GitCheckout]   projects after addProject: ${projectCountAfter}`);
            } catch (error) {
              logger.warn(`Failed to add project to workspace: ${error}`);
            }
          } else {
            logger.debug(`[GitCheckout] Workspace not enabled, skipping addProject`);
          }
          logger.info(
            `Successfully checked out ${resolvedRepository}@${resolvedRef} to ${worktree.path}`
          );
          return {
            issues,
            output
          };
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          logger.error(`Git checkout failed: ${errorMessage}`);
          issues.push({
            file: "git-checkout",
            line: 0,
            ruleId: "git-checkout/error",
            message: `Failed to checkout code: ${errorMessage}`,
            severity: "error",
            category: "logic"
          });
          const output = {
            success: false,
            error: errorMessage
          };
          return {
            issues,
            output
          };
        }
      }
      /**
       * Build template context for variable resolution
       */
      buildTemplateContext(prInfo, dependencyResults, context2, config) {
        const outputsObj = {};
        if (dependencyResults) {
          for (const [checkName, result] of dependencyResults.entries()) {
            outputsObj[checkName] = result.output !== void 0 ? result.output : result;
          }
        }
        const outputHistory = config?.__outputHistory;
        const historyObj = {};
        if (outputHistory) {
          for (const [checkName, history] of outputHistory.entries()) {
            historyObj[checkName] = history;
          }
        }
        const safeEnv = buildSandboxEnv(process.env);
        return {
          pr: {
            number: prInfo.number,
            title: prInfo.title,
            author: prInfo.author,
            head: prInfo.head,
            base: prInfo.base,
            repo: process.env.GITHUB_REPOSITORY || "",
            files: prInfo.files
          },
          files: prInfo.files,
          outputs: outputsObj,
          outputs_history: historyObj,
          env: safeEnv,
          // Check config first (set by projectWorkflowToGraph), then fall back to context
          inputs: config?.workflowInputs || context2?.workflowInputs
        };
      }
      getSupportedConfigKeys() {
        return [
          "type",
          "ref",
          "repository",
          "token",
          "fetch_depth",
          "fetch_tags",
          "submodules",
          "working_directory",
          "use_worktree",
          "clean",
          "sparse_checkout",
          "lfs",
          "timeout",
          "criticality",
          "assume",
          "guarantee",
          "cleanup_on_failure",
          "persist_worktree",
          "depends_on",
          "if",
          "fail_if",
          "on"
        ];
      }
      async isAvailable() {
        try {
          const { commandExecutor: commandExecutor2 } = await import("./command-executor-DVVXERLR.mjs");
          const result = await commandExecutor2.execute("git --version", { timeout: 5e3 });
          return result.exitCode === 0;
        } catch (_error) {
          return false;
        }
      }
      getRequirements() {
        return ["git"];
      }
    };
  }
});

// src/providers/check-provider-registry.ts
var check_provider_registry_exports = {};
__export(check_provider_registry_exports, {
  CheckProviderRegistry: () => CheckProviderRegistry
});
var CheckProviderRegistry;
var init_check_provider_registry = __esm({
  "src/providers/check-provider-registry.ts"() {
    init_ai_check_provider();
    init_http_check_provider();
    init_http_input_provider();
    init_http_client_provider();
    init_noop_check_provider();
    init_log_check_provider();
    init_github_ops_provider();
    init_claude_code_check_provider();
    init_command_check_provider();
    init_memory_check_provider();
    init_mcp_check_provider();
    init_human_input_check_provider();
    init_script_check_provider();
    init_workflow_check_provider();
    init_git_checkout_provider();
    CheckProviderRegistry = class _CheckProviderRegistry {
      providers = /* @__PURE__ */ new Map();
      static instance;
      customTools;
      constructor() {
        this.registerDefaultProviders();
      }
      /**
       * Get singleton instance
       */
      static getInstance() {
        if (!_CheckProviderRegistry.instance) {
          _CheckProviderRegistry.instance = new _CheckProviderRegistry();
        }
        return _CheckProviderRegistry.instance;
      }
      /**
       * Register default built-in providers
       */
      registerDefaultProviders() {
        this.register(new AICheckProvider());
        this.register(new CommandCheckProvider());
        this.register(new ScriptCheckProvider());
        this.register(new HttpCheckProvider());
        this.register(new HttpInputProvider());
        this.register(new HttpClientProvider());
        this.register(new NoopCheckProvider());
        this.register(new LogCheckProvider());
        this.register(new MemoryCheckProvider());
        this.register(new GitHubOpsProvider());
        this.register(new HumanInputCheckProvider());
        this.register(new WorkflowCheckProvider());
        this.register(new GitCheckoutProvider());
        try {
          this.register(new ClaudeCodeCheckProvider());
        } catch (error) {
          console.error(
            `Warning: Failed to register ClaudeCodeCheckProvider: ${error instanceof Error ? error.message : "Unknown error"}`
          );
        }
        try {
          const mcpProvider = new McpCheckProvider();
          if (this.customTools) {
            mcpProvider.setCustomTools(this.customTools);
          }
          this.register(mcpProvider);
        } catch (error) {
          console.error(
            `Warning: Failed to register McpCheckProvider: ${error instanceof Error ? error.message : "Unknown error"}`
          );
        }
      }
      /**
       * Register a check provider
       */
      register(provider) {
        const name = provider.getName();
        if (this.providers.has(name)) {
          throw new Error(`Provider '${name}' is already registered`);
        }
        this.providers.set(name, provider);
        if (process.env.VISOR_DEBUG === "true") {
          console.error(`Registered check provider: ${name}`);
        }
      }
      /**
       * Unregister a check provider
       */
      unregister(name) {
        if (!this.providers.has(name)) {
          throw new Error(`Provider '${name}' not found`);
        }
        this.providers.delete(name);
        console.error(`Unregistered check provider: ${name}`);
      }
      /**
       * Get a provider by name
       */
      getProvider(name) {
        return this.providers.get(name);
      }
      /**
       * Get provider or throw if not found
       */
      getProviderOrThrow(name) {
        const provider = this.providers.get(name);
        if (!provider) {
          throw new Error(
            `Check provider '${name}' not found. Available providers: ${this.getAvailableProviders().join(", ")}`
          );
        }
        return provider;
      }
      /**
       * Check if a provider exists
       */
      hasProvider(name) {
        return this.providers.has(name);
      }
      /**
       * Get all registered provider names
       */
      getAvailableProviders() {
        return Array.from(this.providers.keys());
      }
      /**
       * Get all providers
       */
      getAllProviders() {
        return Array.from(this.providers.values());
      }
      /**
       * Set custom tools that can be used by the MCP provider
       */
      setCustomTools(tools) {
        this.customTools = tools;
        const mcpProvider = this.providers.get("mcp");
        if (mcpProvider) {
          mcpProvider.setCustomTools(tools);
        }
      }
      /**
       * Get providers that are currently available (have required dependencies)
       */
      async getActiveProviders() {
        const providers = this.getAllProviders();
        const activeProviders = [];
        for (const provider of providers) {
          if (await provider.isAvailable()) {
            activeProviders.push(provider);
          }
        }
        return activeProviders;
      }
      /**
       * List provider information
       */
      async listProviders() {
        const providers = this.getAllProviders();
        const info = [];
        for (const provider of providers) {
          info.push({
            name: provider.getName(),
            description: provider.getDescription(),
            available: await provider.isAvailable(),
            requirements: provider.getRequirements()
          });
        }
        return info;
      }
      /**
       * Reset registry (mainly for testing)
       */
      reset() {
        this.providers.clear();
        this.registerDefaultProviders();
      }
      /**
       * Clear singleton instance (for testing)
       */
      static clearInstance() {
        _CheckProviderRegistry.instance = void 0;
      }
    };
  }
});

// src/workflow-executor.ts
var WorkflowExecutor;
var init_workflow_executor = __esm({
  "src/workflow-executor.ts"() {
    "use strict";
    init_check_provider_registry();
    init_dependency_resolver();
    init_logger();
    init_sandbox();
    init_liquid_extensions();
    WorkflowExecutor = class {
      providerRegistry = null;
      liquid;
      constructor() {
        this.liquid = createExtendedLiquid();
      }
      /**
       * Lazy-load the provider registry to avoid circular dependency during initialization
       */
      getProviderRegistry() {
        if (!this.providerRegistry) {
          this.providerRegistry = CheckProviderRegistry.getInstance();
        }
        return this.providerRegistry;
      }
      /**
       * Execute a workflow
       */
      async execute(workflow, executionContext, runOptions) {
        const startTime = Date.now();
        executionContext.metadata = {
          startTime,
          status: "running"
        };
        try {
          const executionOrder = this.resolveExecutionOrder(workflow);
          logger.debug(`Workflow ${workflow.id} execution order: ${executionOrder.join(" -> ")}`);
          const stepResults = /* @__PURE__ */ new Map();
          const stepSummaries = [];
          for (const stepId of executionOrder) {
            const step = workflow.steps[stepId];
            if (step.if) {
              const shouldRun = this.evaluateCondition(step.if, {
                inputs: executionContext.inputs,
                outputs: Object.fromEntries(stepResults),
                pr: runOptions.prInfo
              });
              if (!shouldRun) {
                logger.info(`Skipping step '${stepId}' due to condition: ${step.if}`);
                stepSummaries.push({
                  stepId,
                  status: "skipped"
                });
                continue;
              }
            }
            const stepConfig = await this.prepareStepConfig(
              step,
              stepId,
              executionContext,
              stepResults,
              workflow
            );
            try {
              logger.info(`Executing workflow step '${stepId}'`);
              const stepContext = {
                ...runOptions.context,
                workflowInputs: executionContext.inputs
              };
              const result = await this.executeStep(
                stepConfig,
                runOptions.prInfo,
                stepResults,
                stepContext
              );
              stepResults.set(stepId, result);
              stepSummaries.push({
                stepId,
                status: "success",
                issues: result.issues,
                output: result.output
              });
            } catch (error) {
              const errorMessage = error instanceof Error ? error.message : String(error);
              logger.error(`Step '${stepId}' failed: ${errorMessage}`);
              stepSummaries.push({
                stepId,
                status: "failed",
                output: { error: errorMessage }
              });
              if (!runOptions.options?.continueOnError) {
                throw new Error(`Workflow step '${stepId}' failed: ${errorMessage}`);
              }
            }
          }
          const outputs = await this.computeOutputs(
            workflow,
            executionContext,
            stepResults,
            runOptions.prInfo
          );
          executionContext.outputs = outputs;
          const aggregated = this.aggregateResults(stepResults);
          const endTime = Date.now();
          executionContext.metadata.endTime = endTime;
          executionContext.metadata.duration = endTime - startTime;
          executionContext.metadata.status = "completed";
          return {
            success: true,
            score: aggregated.score,
            confidence: aggregated.confidence,
            issues: aggregated.issues,
            comments: aggregated.comments,
            output: outputs,
            status: "completed",
            duration: endTime - startTime,
            stepSummaries
          };
        } catch (error) {
          const endTime = Date.now();
          executionContext.metadata.endTime = endTime;
          executionContext.metadata.duration = endTime - startTime;
          executionContext.metadata.status = "failed";
          executionContext.metadata.error = error instanceof Error ? error.message : String(error);
          return {
            success: false,
            status: "failed",
            duration: endTime - startTime,
            error: error instanceof Error ? error.message : String(error)
          };
        }
      }
      /**
       * Resolve step execution order based on dependencies
       */
      resolveExecutionOrder(workflow) {
        const dependencies = {};
        for (const [stepId, step] of Object.entries(workflow.steps)) {
          const rawDeps = step.depends_on;
          dependencies[stepId] = Array.isArray(rawDeps) ? rawDeps : rawDeps ? [rawDeps] : [];
        }
        const graph = DependencyResolver.buildDependencyGraph(dependencies);
        if (graph.hasCycles) {
          throw new Error(
            `Circular dependency detected in workflow steps: ${graph.cycleNodes?.join(" -> ")}`
          );
        }
        const order = [];
        for (const group of graph.executionOrder) {
          order.push(...group.parallel);
        }
        return order;
      }
      /**
       * Prepare step configuration with input mappings
       */
      async prepareStepConfig(step, stepId, executionContext, stepResults, workflow) {
        const config = {
          ...step,
          type: step.type || "ai",
          checkName: `${executionContext.instanceId}:${stepId}`
        };
        if (step.inputs) {
          for (const [inputName, mapping] of Object.entries(step.inputs)) {
            const value = await this.resolveInputMapping(
              mapping,
              executionContext,
              stepResults,
              workflow
            );
            config[inputName] = value;
          }
        }
        return config;
      }
      /**
       * Resolve input mapping to actual value
       */
      async resolveInputMapping(mapping, executionContext, stepResults, _workflow) {
        if (typeof mapping === "string") {
          return executionContext.inputs[mapping];
        }
        if (typeof mapping === "object" && mapping !== null && "source" in mapping) {
          const typedMapping = mapping;
          switch (typedMapping.source) {
            case "param":
              return executionContext.inputs[String(typedMapping.value)];
            case "step":
              if (!typedMapping.stepId) {
                throw new Error("Step input mapping requires stepId");
              }
              const stepResult = stepResults.get(typedMapping.stepId);
              if (!stepResult) {
                throw new Error(`Step '${typedMapping.stepId}' has not been executed yet`);
              }
              const output = stepResult.output;
              if (typedMapping.outputParam && output) {
                return output[typedMapping.outputParam];
              }
              return output;
            case "constant":
              return typedMapping.value;
            case "expression":
              if (!typedMapping.expression) {
                throw new Error("Expression mapping requires expression field");
              }
              const sandbox = createSecureSandbox();
              return compileAndRun(
                sandbox,
                typedMapping.expression,
                {
                  inputs: executionContext.inputs,
                  outputs: Object.fromEntries(stepResults),
                  steps: Object.fromEntries(
                    Array.from(stepResults.entries()).map(([id, result]) => [
                      id,
                      result.output
                    ])
                  )
                },
                { injectLog: true, logPrefix: "workflow.input.expression" }
              );
            default:
              throw new Error(`Unknown input mapping source: ${typedMapping.source}`);
          }
        }
        if (typeof mapping === "object" && mapping !== null && "template" in mapping) {
          const typedMapping = mapping;
          if (typedMapping.template) {
            return await this.liquid.parseAndRender(typedMapping.template, {
              inputs: executionContext.inputs,
              outputs: Object.fromEntries(stepResults)
            });
          }
        }
        return mapping;
      }
      /**
       * Execute a single step
       */
      async executeStep(config, prInfo, dependencyResults, context2) {
        const provider = await this.getProviderRegistry().getProvider(config.type);
        if (!provider) {
          throw new Error(`Provider '${config.type}' not found`);
        }
        return await provider.execute(prInfo, config, dependencyResults, context2);
      }
      /**
       * Compute workflow outputs
       */
      async computeOutputs(workflow, executionContext, stepResults, prInfo) {
        const outputs = {};
        if (!workflow.outputs) {
          return outputs;
        }
        for (const output of workflow.outputs) {
          if (output.value_js) {
            const sandbox = createSecureSandbox();
            outputs[output.name] = compileAndRun(
              sandbox,
              output.value_js,
              {
                inputs: executionContext.inputs,
                steps: Object.fromEntries(
                  Array.from(stepResults.entries()).map(([id, result]) => [id, result.output])
                ),
                outputs: Object.fromEntries(stepResults),
                pr: prInfo
              },
              { injectLog: true, logPrefix: `workflow.output.${output.name}` }
            );
          } else if (output.value) {
            outputs[output.name] = await this.liquid.parseAndRender(output.value, {
              inputs: executionContext.inputs,
              steps: Object.fromEntries(
                Array.from(stepResults.entries()).map(([id, result]) => [id, result.output])
              ),
              outputs: Object.fromEntries(stepResults),
              pr: prInfo
            });
          }
        }
        return outputs;
      }
      /**
       * Aggregate results from all steps
       */
      aggregateResults(stepResults) {
        let totalScore = 0;
        let scoreCount = 0;
        const allIssues = [];
        const allComments = [];
        let minConfidence = "high";
        for (const result of stepResults.values()) {
          const extResult = result;
          if (typeof extResult.score === "number") {
            totalScore += extResult.score;
            scoreCount++;
          }
          if (result.issues) {
            allIssues.push(...result.issues);
          }
          if (extResult.comments) {
            allComments.push(...extResult.comments);
          }
          if (extResult.confidence) {
            if (extResult.confidence === "low" || extResult.confidence === "medium" && minConfidence === "high") {
              minConfidence = extResult.confidence;
            }
          }
        }
        return {
          score: scoreCount > 0 ? Math.round(totalScore / scoreCount) : 0,
          confidence: minConfidence,
          issues: allIssues,
          comments: allComments
        };
      }
      /**
       * Evaluate a condition expression
       */
      evaluateCondition(condition, context2) {
        try {
          const sandbox = createSecureSandbox();
          const result = compileAndRun(sandbox, condition, context2, {
            injectLog: true,
            logPrefix: "workflow.condition"
          });
          return Boolean(result);
        } catch (error) {
          logger.warn(`Failed to evaluate condition '${condition}': ${error}`);
          return false;
        }
      }
    };
  }
});

// src/state-machine/workflow-projection.ts
var workflow_projection_exports = {};
__export(workflow_projection_exports, {
  buildWorkflowScope: () => buildWorkflowScope,
  extractParentScope: () => extractParentScope,
  getWorkflowIdFromScope: () => getWorkflowIdFromScope,
  isWorkflowStep: () => isWorkflowStep,
  projectWorkflowToGraph: () => projectWorkflowToGraph,
  validateWorkflowDepth: () => validateWorkflowDepth
});
function projectWorkflowToGraph(workflow, workflowInputs, _parentCheckId) {
  if (!workflow.steps || Object.keys(workflow.steps).length === 0) {
    throw new Error(`Workflow '${workflow.id}' has no steps`);
  }
  const checks = {};
  const checksMetadata = {};
  for (const [stepId, step] of Object.entries(workflow.steps)) {
    const scopedCheckId = stepId;
    checks[scopedCheckId] = {
      type: step.type || "ai",
      ...step,
      // Store workflow inputs in the check config so they're accessible
      workflowInputs,
      // Mark this as a workflow step
      _workflowStep: true,
      _workflowId: workflow.id,
      _stepId: stepId
    };
    checksMetadata[scopedCheckId] = {
      tags: step.tags || workflow.tags || [],
      triggers: step.on || workflow.on || [],
      group: step.group,
      providerType: step.type || "ai",
      // Normalize depends_on to array (supports string | string[])
      dependencies: (Array.isArray(step.depends_on) ? step.depends_on : step.depends_on ? [step.depends_on] : []).map((dep) => dep)
    };
  }
  const config = {
    checks,
    version: "1.0",
    output: {
      pr_comment: {
        format: "table",
        group_by: "check",
        collapse: false
      }
    }
  };
  if (logger.isDebugEnabled?.()) {
    logger.debug(
      `[WorkflowProjection] Projected workflow '${workflow.id}' with ${Object.keys(checks).length} steps`
    );
  }
  return { config, checks: checksMetadata };
}
function validateWorkflowDepth(currentDepth, maxDepth, workflowId) {
  if (currentDepth >= maxDepth) {
    throw new Error(
      `Workflow nesting depth limit exceeded (${maxDepth}) for workflow '${workflowId}'. This may indicate a circular workflow reference or excessive nesting.`
    );
  }
}
function buildWorkflowScope(parentScope, workflowCheckId, stepId, foreachIndex) {
  const scope = parentScope ? [...parentScope] : [];
  scope.push({
    check: `${workflowCheckId}:${stepId}`,
    index: foreachIndex ?? 0
  });
  return scope;
}
function extractParentScope(scopedCheckId) {
  const lastColonIndex = scopedCheckId.lastIndexOf(":");
  if (lastColonIndex === -1) {
    return null;
  }
  return {
    parentCheckId: scopedCheckId.substring(0, lastColonIndex),
    stepId: scopedCheckId.substring(lastColonIndex + 1)
  };
}
function isWorkflowStep(checkId) {
  return checkId.includes(":");
}
function getWorkflowIdFromScope(scopedCheckId) {
  const parts = scopedCheckId.split(":");
  if (parts.length >= 2) {
    return parts[0];
  }
  return null;
}
var init_workflow_projection = __esm({
  "src/state-machine/workflow-projection.ts"() {
    "use strict";
    init_logger();
  }
});

// src/providers/workflow-check-provider.ts
var WorkflowCheckProvider;
var init_workflow_check_provider = __esm({
  "src/providers/workflow-check-provider.ts"() {
    init_check_provider_interface();
    init_workflow_registry();
    init_workflow_executor();
    init_logger();
    init_sandbox();
    init_human_id();
    init_liquid_extensions();
    WorkflowCheckProvider = class extends CheckProvider {
      registry;
      executor;
      liquid;
      constructor() {
        super();
        this.registry = WorkflowRegistry.getInstance();
        this.executor = new WorkflowExecutor();
        this.liquid = createExtendedLiquid();
      }
      getName() {
        return "workflow";
      }
      getDescription() {
        return "Executes reusable workflow definitions as checks";
      }
      async validateConfig(config) {
        const cfg = config;
        if (!cfg.workflow && !cfg.config) {
          logger.error('Workflow provider requires either "workflow" (id) or "config" (path)');
          return false;
        }
        if (cfg.workflow) {
          if (!this.registry.has(cfg.workflow)) {
            logger.error(`Workflow '${cfg.workflow}' not found in registry`);
            return false;
          }
        }
        return true;
      }
      async execute(prInfo, config, dependencyResults, context2) {
        const cfg = config;
        const isConfigPathMode = !!cfg.config && !cfg.workflow;
        const stepName = config.checkName || cfg.workflow || cfg.config || "workflow";
        let workflow;
        let workflowId = cfg.workflow;
        if (isConfigPathMode) {
          const parentCwd = context2?._parentContext?.originalWorkingDirectory || context2?._parentContext?.workingDirectory || context2?.originalWorkingDirectory || context2?.workingDirectory || process.cwd();
          workflow = await this.loadWorkflowFromConfigPath(String(cfg.config), parentCwd);
          workflowId = workflow.id;
          logger.info(`Executing workflow from config '${cfg.config}' as '${workflowId}'`);
        } else {
          workflowId = String(cfg.workflow);
          workflow = this.registry.get(workflowId);
          if (!workflow) {
            throw new Error(`Workflow '${workflowId}' not found in registry`);
          }
          logger.info(`Executing workflow '${workflowId}'`);
        }
        const inputs = await this.prepareInputs(workflow, config, prInfo, dependencyResults);
        try {
          const inputsCapture = Object.entries(inputs).map(([k, v]) => `${k}: ${typeof v === "string" ? v : JSON.stringify(v)}`).join("\n\n");
          context2?.hooks?.onPromptCaptured?.({
            step: String(stepName),
            provider: "workflow",
            prompt: inputsCapture
          });
        } catch {
        }
        const validation = this.registry.validateInputs(workflow, inputs);
        if (!validation.valid) {
          const errors = validation.errors?.map((e) => `${e.path}: ${e.message}`).join(", ");
          throw new Error(`Invalid workflow inputs: ${errors}`);
        }
        try {
          const mock = context2?.hooks?.mockForStep?.(String(stepName));
          if (mock !== void 0) {
            const ms = mock;
            const issuesArr = Array.isArray(ms?.issues) ? ms.issues : [];
            const out = ms && typeof ms === "object" && "output" in ms ? ms.output : ms;
            const summary2 = {
              issues: issuesArr,
              output: out,
              ...typeof ms?.content === "string" ? { content: String(ms.content) } : {}
            };
            return summary2;
          }
        } catch {
        }
        const modifiedWorkflow = this.applyOverrides(workflow, config);
        const engineMode = context2?._engineMode;
        if (engineMode === "state-machine") {
          logger.info(`[WorkflowProvider] Delegating workflow '${workflowId}' to state machine engine`);
          return await this.executeViaStateMachine(
            modifiedWorkflow,
            inputs,
            config,
            prInfo,
            dependencyResults,
            context2
          );
        }
        const executionContext = {
          instanceId: `${workflowId}-${Date.now()}`,
          parentCheckId: config.checkName,
          inputs,
          stepResults: /* @__PURE__ */ new Map()
        };
        const result = await this.executor.execute(modifiedWorkflow, executionContext, {
          prInfo,
          dependencyResults,
          context: context2
        });
        const outputs = this.mapOutputs(result, config.output_mapping);
        const summary = {
          issues: result.issues || []
        };
        summary.score = result.score || 0;
        summary.confidence = result.confidence || "medium";
        summary.comments = result.comments || [];
        summary.output = outputs;
        summary.content = this.formatWorkflowResult(workflow, result, outputs);
        return summary;
      }
      getSupportedConfigKeys() {
        return [
          "workflow",
          "config",
          "args",
          "overrides",
          "output_mapping",
          "timeout",
          "env",
          "checkName"
        ];
      }
      async isAvailable() {
        return true;
      }
      getRequirements() {
        return [];
      }
      /**
       * Prepare inputs for workflow execution
       */
      async prepareInputs(workflow, config, prInfo, dependencyResults) {
        const inputs = {};
        if (workflow.inputs) {
          for (const param of workflow.inputs) {
            if (param.default !== void 0) {
              inputs[param.name] = param.default;
            }
          }
        }
        const eventContext = config.eventContext || {};
        logger.debug(`[WorkflowProvider] prepareInputs for ${workflow.id}`);
        logger.debug(
          `[WorkflowProvider] eventContext keys: ${Object.keys(eventContext).join(", ") || "none"}`
        );
        logger.debug(
          `[WorkflowProvider] eventContext.slack: ${eventContext.slack ? "present" : "absent"}`
        );
        logger.debug(
          `[WorkflowProvider] eventContext.conversation: ${eventContext.conversation ? "present" : "absent"}`
        );
        const slack = (() => {
          try {
            const anyCtx = eventContext;
            const slackCtx = anyCtx?.slack;
            if (slackCtx && typeof slackCtx === "object") return slackCtx;
          } catch {
          }
          return void 0;
        })();
        const conversation = (() => {
          try {
            const anyCtx = eventContext;
            if (anyCtx?.slack?.conversation) return anyCtx.slack.conversation;
            if (anyCtx?.github?.conversation) return anyCtx.github.conversation;
            if (anyCtx?.conversation) return anyCtx.conversation;
          } catch {
          }
          return void 0;
        })();
        logger.debug(`[WorkflowProvider] slack extracted: ${slack ? "present" : "absent"}`);
        logger.debug(
          `[WorkflowProvider] conversation extracted: ${conversation ? "present" : "absent"}`
        );
        if (conversation) {
          logger.debug(
            `[WorkflowProvider] conversation.messages count: ${Array.isArray(conversation.messages) ? conversation.messages.length : 0}`
          );
        }
        const outputHistory = config.__outputHistory;
        const outputs_history = {};
        if (outputHistory) {
          for (const [k, v] of outputHistory.entries()) {
            outputs_history[k] = v;
          }
        }
        const outputsMap = {};
        logger.debug(
          `[WorkflowProvider] dependencyResults: ${dependencyResults ? dependencyResults.size : "undefined"} entries`
        );
        if (dependencyResults) {
          for (const [key, result] of dependencyResults.entries()) {
            const extracted = result.output ?? result;
            outputsMap[key] = extracted;
            const extractedKeys = extracted && typeof extracted === "object" ? Object.keys(extracted).join(", ") : "not-object";
            logger.debug(`[WorkflowProvider] outputs['${key}']: keys=[${extractedKeys}]`);
          }
        }
        const parentInputs = config.workflowInputs || {};
        const templateContext = {
          pr: prInfo,
          outputs: outputsMap,
          env: process.env,
          slack,
          conversation,
          outputs_history,
          // Include parent workflow inputs for templates like {{ inputs.question }}
          inputs: parentInputs
        };
        const userInputs = config.args || config.workflow_inputs;
        if (userInputs) {
          for (const [key, value] of Object.entries(userInputs)) {
            if (typeof value === "string") {
              if (value.includes("{{") || value.includes("{%")) {
                inputs[key] = await this.liquid.parseAndRender(value, templateContext);
                if (key === "text" || key === "question" || key === "context") {
                  const rendered = String(inputs[key]);
                  logger.info(
                    `[WorkflowProvider] Rendered '${key}' input (${rendered.length} chars): ${rendered.substring(0, 500)}${rendered.length > 500 ? "..." : ""}`
                  );
                }
              } else {
                inputs[key] = value;
              }
            } else if (typeof value === "object" && value !== null && "expression" in value) {
              const exprValue = value;
              const sandbox = createSecureSandbox();
              inputs[key] = compileAndRun(sandbox, exprValue.expression, templateContext, {
                injectLog: true,
                logPrefix: `workflow.input.${key}`
              });
            } else {
              inputs[key] = value;
              if (Array.isArray(value)) {
                logger.debug(`[WorkflowProvider] Input '${key}' is array with ${value.length} items`);
              } else if (typeof value === "object") {
                logger.debug(
                  `[WorkflowProvider] Input '${key}' is object with keys: ${Object.keys(value).join(", ")}`
                );
              }
            }
          }
        }
        const inputSummary = Object.entries(inputs).map(([k, v]) => `${k}:${Array.isArray(v) ? `array[${v.length}]` : typeof v}`).join(", ");
        logger.debug(`[WorkflowProvider] Final inputs: ${inputSummary}`);
        return inputs;
      }
      /**
       * Apply overrides to workflow steps
       */
      applyOverrides(workflow, config) {
        const overrideConfig = config.overrides || config.workflow_overrides;
        if (!overrideConfig) {
          return workflow;
        }
        const modified = JSON.parse(JSON.stringify(workflow));
        for (const [stepId, overrides] of Object.entries(overrideConfig)) {
          if (modified.steps[stepId]) {
            modified.steps[stepId] = {
              ...modified.steps[stepId],
              ...overrides
            };
          } else {
            logger.warn(`Cannot override non-existent step '${stepId}' in workflow '${workflow.id}'`);
          }
        }
        return modified;
      }
      /**
       * Map workflow outputs to check outputs
       */
      mapOutputs(result, outputMapping) {
        if (!outputMapping) {
          return result.output || {};
        }
        const mapped = {};
        const workflowOutputs = result.output || {};
        for (const [checkOutput, workflowOutput] of Object.entries(outputMapping)) {
          if (workflowOutput in workflowOutputs) {
            mapped[checkOutput] = workflowOutputs[workflowOutput];
          } else if (workflowOutput.includes(".")) {
            const parts = workflowOutput.split(".");
            let value = workflowOutputs;
            for (const part of parts) {
              value = value?.[part];
              if (value === void 0) break;
            }
            mapped[checkOutput] = value;
          }
        }
        return mapped;
      }
      /**
       * Format workflow execution result for display
       */
      /**
       * Execute workflow via state machine engine (M3: nested workflows)
       */
      async executeViaStateMachine(workflow, inputs, config, prInfo, dependencyResults, context2) {
        const {
          projectWorkflowToGraph: projectWorkflowToGraph2,
          validateWorkflowDepth: validateWorkflowDepth2
        } = (init_workflow_projection(), __toCommonJS(workflow_projection_exports));
        const { StateMachineRunner: StateMachineRunner2 } = (init_runner(), __toCommonJS(runner_exports));
        const { ExecutionJournal: ExecutionJournal2 } = (init_snapshot_store(), __toCommonJS(snapshot_store_exports));
        const { MemoryStore: MemoryStore2 } = (init_memory_store(), __toCommonJS(memory_store_exports));
        const parentContext = context2?._parentContext;
        const parentState = context2?._parentState;
        const currentDepth = parentState?.flags?.currentWorkflowDepth || 0;
        const maxDepth = parentState?.flags?.maxWorkflowDepth ?? parentContext?.config?.limits?.max_workflow_depth ?? 3;
        validateWorkflowDepth2(currentDepth, maxDepth, workflow.id);
        const { config: workflowConfig, checks: checksMetadata } = projectWorkflowToGraph2(
          workflow,
          inputs,
          config.checkName || workflow.id
        );
        const parentMemoryCfg = parentContext?.memory && parentContext.memory.getConfig && parentContext.memory.getConfig() || parentContext?.config?.memory;
        const childJournal = new ExecutionJournal2();
        const childMemory = MemoryStore2.createIsolated(parentMemoryCfg);
        try {
          await childMemory.initialize();
        } catch {
        }
        const parentWorkspace = parentContext?.workspace;
        logger.info(`[WorkflowProvider] Workspace propagation for nested workflow '${workflow.id}':`);
        logger.info(`[WorkflowProvider]   parentContext exists: ${!!parentContext}`);
        logger.info(`[WorkflowProvider]   parentContext.workspace exists: ${!!parentWorkspace}`);
        if (parentWorkspace) {
          logger.info(
            `[WorkflowProvider]   parentWorkspace.isEnabled(): ${parentWorkspace.isEnabled?.() ?? "N/A"}`
          );
          const projectCount = parentWorkspace.listProjects?.()?.length ?? "N/A";
          logger.info(`[WorkflowProvider]   parentWorkspace project count: ${projectCount}`);
        } else {
          logger.warn(
            `[WorkflowProvider]   NO WORKSPACE from parent - nested checkouts won't be added to workspace!`
          );
        }
        const childContext = {
          mode: "state-machine",
          config: workflowConfig,
          checks: checksMetadata,
          journal: childJournal,
          memory: childMemory,
          // For nested workflows we continue to execute inside the same logical
          // working directory as the parent run. When workspace isolation is
          // enabled on the parent engine, its WorkspaceManager is also propagated
          // so that nested checks (AI, git-checkout, etc.) see the same isolated
          // workspace and project symlinks instead of falling back to the Visor
          // repository root.
          workingDirectory: parentContext?.workingDirectory || process.cwd(),
          originalWorkingDirectory: parentContext?.originalWorkingDirectory || parentContext?.workingDirectory || process.cwd(),
          workspace: parentWorkspace,
          // Always use a fresh session for nested workflows to isolate history
          sessionId: generateHumanId(),
          event: parentContext?.event || prInfo.eventType,
          debug: parentContext?.debug || false,
          maxParallelism: parentContext?.maxParallelism,
          failFast: parentContext?.failFast,
          // Propagate execution hooks (mocks, octokit, etc.) into the child so
          // nested steps can be mocked/observed by the YAML test runner.
          executionContext: parentContext?.executionContext,
          // Ensure all workflow steps are considered requested to avoid tag/event filtering surprises
          requestedChecks: Object.keys(checksMetadata)
        };
        const runner = new StateMachineRunner2(childContext);
        const childState = runner.getState();
        childState.flags.currentWorkflowDepth = currentDepth + 1;
        childState.flags.maxWorkflowDepth = maxDepth;
        childState.parentContext = parentContext;
        childState.parentScope = parentState?.parentScope;
        logger.info(
          `[WorkflowProvider] Executing nested workflow '${workflow.id}' at depth ${currentDepth + 1}`
        );
        const result = await runner.run();
        const bubbledEvents = childContext._bubbledEvents || [];
        if (bubbledEvents.length > 0 && parentContext) {
          if (parentContext.debug) {
            logger.info(`[WorkflowProvider] Bubbling ${bubbledEvents.length} events to parent context`);
          }
          if (!parentContext._bubbledEvents) {
            parentContext._bubbledEvents = [];
          }
          parentContext._bubbledEvents.push(...bubbledEvents);
        }
        const allIssues = [];
        let totalScore = 0;
        let scoreCount = 0;
        for (const stepResult of Object.values(result.results)) {
          const typedResult = stepResult;
          if (typedResult.issues) {
            allIssues.push(...typedResult.issues);
          }
          if (typedResult.score) {
            totalScore += typedResult.score;
            scoreCount++;
          }
        }
        const outputs = await this.computeWorkflowOutputsFromState(
          workflow,
          inputs,
          result.results,
          prInfo
        );
        const mappedOutputs = this.mapOutputs(
          { output: outputs },
          config.output_mapping
        );
        const summary = {
          issues: allIssues
        };
        summary.score = scoreCount > 0 ? Math.round(totalScore / scoreCount) : 0;
        summary.confidence = "medium";
        summary.output = mappedOutputs;
        summary.content = this.formatWorkflowResultFromStateMachine(
          workflow,
          result,
          mappedOutputs
        );
        return summary;
      }
      /**
       * Compute workflow outputs from state machine execution results
       */
      async computeWorkflowOutputsFromState(workflow, inputs, groupedResults, prInfo) {
        const outputs = {};
        const flat = {};
        try {
          for (const arr of Object.values(groupedResults || {})) {
            for (const item of arr || []) {
              if (!item) continue;
              const name = item.checkName || item.name;
              if (typeof name === "string" && name) {
                flat[name] = { output: item.output, issues: item.issues };
              }
            }
          }
        } catch {
        }
        const outputsMap = Object.fromEntries(
          Object.entries(flat).map(([id, result]) => [id, result.output])
        );
        if (!workflow.outputs || workflow.outputs.length === 0) {
          const stepNames = Object.keys(outputsMap);
          if (stepNames.length === 1) {
            const singleStepOutput = outputsMap[stepNames[0]];
            logger.debug(
              `[WorkflowProvider] No outputs defined for workflow '${workflow.id}', unwrapping single step '${stepNames[0]}' output to top level`
            );
            if (singleStepOutput && typeof singleStepOutput === "object" && !Array.isArray(singleStepOutput)) {
              return singleStepOutput;
            }
            return { result: singleStepOutput };
          }
          logger.debug(
            `[WorkflowProvider] No outputs defined for workflow '${workflow.id}', propagating all step outputs: [${stepNames.join(", ")}]`
          );
          return outputsMap;
        }
        const stepOutputKeys = Object.keys(outputsMap);
        const stepOutputSummary = stepOutputKeys.map((k) => {
          const v = outputsMap[k];
          const keys = v && typeof v === "object" ? Object.keys(v) : [];
          return `${k}:[${keys.join(",")}]`;
        });
        logger.debug(
          `[WorkflowProvider] Computing outputs for '${workflow.id}'. Available steps: ${stepOutputSummary.join(", ") || "(none)"}`
        );
        for (const output of workflow.outputs) {
          if (output.value_js) {
            try {
              const sandbox = createSecureSandbox();
              const result = compileAndRun(
                sandbox,
                output.value_js,
                {
                  inputs,
                  outputs: outputsMap,
                  // Keep 'steps' as alias for backwards compatibility
                  steps: outputsMap,
                  pr: prInfo
                },
                { injectLog: true, logPrefix: `workflow.output.${output.name}` }
              );
              outputs[output.name] = result;
              const resultType = result === null ? "null" : result === void 0 ? "undefined" : typeof result;
              const resultPreview = result && typeof result === "object" ? `{${Object.keys(result).join(",")}}` : String(result).substring(0, 100);
              logger.debug(
                `[WorkflowProvider] Output '${output.name}' value_js result: type=${resultType}, preview=${resultPreview}`
              );
            } catch (valueJsError) {
              const errorMsg = valueJsError instanceof Error ? valueJsError.message : String(valueJsError);
              logger.error(
                `[WorkflowProvider] Output '${output.name}' value_js failed: ${errorMsg}. Setting to null. Available step outputs: [${Object.keys(outputsMap).join(", ")}]`
              );
              outputs[output.name] = null;
            }
          } else if (output.value) {
            outputs[output.name] = await this.liquid.parseAndRender(output.value, {
              inputs,
              outputs: outputsMap,
              // Keep 'steps' as alias for backwards compatibility
              steps: outputsMap,
              pr: prInfo
            });
          }
        }
        const outputKeys = Object.keys(outputs);
        const nullOutputs = outputKeys.filter((k) => outputs[k] === null || outputs[k] === void 0);
        if (nullOutputs.length > 0) {
          logger.warn(
            `[WorkflowProvider] Workflow '${workflow.id}' has null/undefined outputs: [${nullOutputs.join(", ")}]. This may indicate value_js expressions are not finding expected data.`
          );
        }
        return outputs;
      }
      /**
       * Format workflow result from state machine execution
       */
      formatWorkflowResultFromStateMachine(workflow, result, outputs) {
        const lines = [];
        lines.push(`Workflow: ${workflow.name}`);
        if (workflow.description) {
          lines.push(`Description: ${workflow.description}`);
        }
        lines.push("");
        lines.push("Execution Summary (State Machine):");
        lines.push(`- Total Steps: ${Object.keys(result.results || {}).length}`);
        lines.push(`- Duration: ${result.statistics?.totalDuration || 0}ms`);
        if (Object.keys(outputs).length > 0) {
          lines.push("");
          lines.push("Outputs:");
          for (const [key, value] of Object.entries(outputs)) {
            const formatted = typeof value === "object" ? JSON.stringify(value, null, 2) : String(value);
            lines.push(`- ${key}: ${formatted}`);
          }
        }
        return lines.join("\n");
      }
      formatWorkflowResult(workflow, result, outputs) {
        const lines = [];
        lines.push(`Workflow: ${workflow.name}`);
        if (workflow.description) {
          lines.push(`Description: ${workflow.description}`);
        }
        lines.push("");
        lines.push("Execution Summary:");
        lines.push(`- Status: ${result.status || "completed"}`);
        lines.push(`- Score: ${result.score || 0}`);
        lines.push(`- Issues Found: ${result.issues?.length || 0}`);
        if (result.duration) {
          lines.push(`- Duration: ${result.duration}ms`);
        }
        if (Object.keys(outputs).length > 0) {
          lines.push("");
          lines.push("Outputs:");
          for (const [key, value] of Object.entries(outputs)) {
            const formatted = typeof value === "object" ? JSON.stringify(value, null, 2) : String(value);
            lines.push(`- ${key}: ${formatted}`);
          }
        }
        if (result.stepSummaries && result.stepSummaries.length > 0) {
          lines.push("");
          lines.push("Step Results:");
          for (const summary of result.stepSummaries) {
            lines.push(
              `- ${summary.stepId}: ${summary.status} (${summary.issues?.length || 0} issues)`
            );
          }
        }
        return lines.join("\n");
      }
      /**
       * Load a Visor config file (with steps/checks) and wrap it as a WorkflowDefinition
       * so it can be executed by the state machine as a nested workflow.
       */
      async loadWorkflowFromConfigPath(sourcePath, baseDir) {
        const path12 = __require("path");
        const fs10 = __require("fs");
        const yaml = __require("js-yaml");
        const resolved = path12.isAbsolute(sourcePath) ? sourcePath : path12.resolve(baseDir, sourcePath);
        if (!fs10.existsSync(resolved)) {
          throw new Error(`Workflow config not found at: ${resolved}`);
        }
        const rawContent = fs10.readFileSync(resolved, "utf8");
        const rawData = yaml.load(rawContent);
        if (rawData.imports && Array.isArray(rawData.imports)) {
          const configDir = path12.dirname(resolved);
          for (const source of rawData.imports) {
            const results = await this.registry.import(source, {
              basePath: configDir,
              validate: true
            });
            for (const result of results) {
              if (!result.valid && result.errors) {
                const isAlreadyExists = result.errors.every(
                  (e) => e.message.includes("already exists")
                );
                if (isAlreadyExists) {
                  logger.debug(`Workflow from '${source}' already imported, skipping`);
                  continue;
                }
                const errors = result.errors.map((e) => `  ${e.path}: ${e.message}`).join("\n");
                throw new Error(`Failed to import workflow from '${source}':
${errors}`);
              }
            }
            logger.info(`Imported workflows from: ${source}`);
          }
        }
        const { ConfigManager } = (init_config(), __toCommonJS(config_exports));
        const mgr = new ConfigManager();
        const loaded = await mgr.loadConfig(resolved, { validate: false, mergeDefaults: false });
        const steps = loaded.steps || loaded.checks || {};
        if (!steps || Object.keys(steps).length === 0) {
          throw new Error(`Config '${resolved}' does not contain any steps to execute as a workflow`);
        }
        const id = path12.basename(resolved).replace(/\.(ya?ml)$/i, "");
        const name = loaded.name || `Workflow from ${path12.basename(resolved)}`;
        const workflowDef = {
          id,
          name,
          version: loaded.version || "1.0",
          steps,
          description: loaded.description,
          // Inherit optional triggers if present (not required)
          on: loaded.on,
          // Carry over optional inputs/outputs if present so callers can consume them
          inputs: loaded.inputs,
          outputs: loaded.outputs
        };
        return workflowDef;
      }
    };
  }
});

export {
  WorkflowCheckProvider,
  init_workflow_check_provider,
  CheckProviderRegistry,
  init_check_provider_registry,
  StateMachineExecutionEngine,
  init_state_machine_execution_engine
};
/*! Bundled license information:

undici/lib/fetch/body.js:
  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

undici/lib/websocket/frame.js:
  (*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> *)
*/
//# sourceMappingURL=chunk-BYG4OVYV.mjs.map