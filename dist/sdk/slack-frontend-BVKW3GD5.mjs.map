{"version":3,"sources":["../../src/slack/client.ts","../../src/slack/markdown.ts","../../src/frontends/slack-frontend.ts"],"sourcesContent":["// Lightweight Slack Web API wrapper implemented with fetch (no external deps).\n// Only methods needed by SlackFrontend are implemented.\n\nexport class SlackClient {\n  private token: string;\n\n  constructor(botToken: string) {\n    if (!botToken || typeof botToken !== 'string') {\n      throw new Error('SlackClient: botToken is required');\n    }\n    this.token = botToken;\n  }\n\n  public readonly reactions = {\n    add: async ({\n      channel,\n      timestamp,\n      name,\n    }: {\n      channel: string;\n      timestamp: string;\n      name: string;\n    }) => {\n      const resp: any = await this.api('reactions.add', { channel, timestamp, name });\n      if (!resp || resp.ok !== true) {\n        // Non-fatal in CLI/test runs ‚Äì log and continue\n        const err = (resp && resp.error) || 'unknown_error';\n        console.warn(`Slack reactions.add failed (non-fatal): ${err}`);\n        return { ok: false as const };\n      }\n      return { ok: true } as const;\n    },\n    remove: async ({\n      channel,\n      timestamp,\n      name,\n    }: {\n      channel: string;\n      timestamp: string;\n      name: string;\n    }) => {\n      const resp: any = await this.api('reactions.remove', { channel, timestamp, name });\n      if (!resp || resp.ok !== true) {\n        const err = (resp && resp.error) || 'unknown_error';\n        console.warn(`Slack reactions.remove failed (non-fatal): ${err}`);\n        return { ok: false as const };\n      }\n      return { ok: true } as const;\n    },\n  };\n\n  public readonly chat = {\n    postMessage: async ({\n      channel,\n      text,\n      thread_ts,\n    }: {\n      channel: string;\n      text: string;\n      thread_ts?: string;\n    }) => {\n      const resp: any = await this.api('chat.postMessage', { channel, text, thread_ts });\n      if (!resp || resp.ok !== true) {\n        const err = (resp && resp.error) || 'unknown_error';\n        console.warn(`Slack chat.postMessage failed (non-fatal): ${err}`);\n        return {\n          ts: undefined,\n          message: undefined,\n          data: resp,\n        };\n      }\n      // Normalize common fields for tests/frontend\n      return {\n        ts: resp.ts || (resp.message && resp.message.ts) || undefined,\n        message: resp.message,\n        data: resp,\n      };\n    },\n    update: async ({ channel, ts, text }: { channel: string; ts: string; text: string }) => {\n      const resp: any = await this.api('chat.update', { channel, ts, text });\n      if (!resp || resp.ok !== true) {\n        const err = (resp && resp.error) || 'unknown_error';\n        console.warn(`Slack chat.update failed (non-fatal): ${err}`);\n        return { ok: false as const, ts };\n      }\n      return { ok: true as const, ts: resp.ts || ts };\n    },\n  };\n\n  async getBotUserId(): Promise<string> {\n    const resp: any = await this.api('auth.test', {});\n    if (!resp || resp.ok !== true || !resp.user_id) {\n      console.warn('Slack auth.test failed (non-fatal); bot user id unavailable');\n      return 'UNKNOWN_BOT';\n    }\n    return String(resp.user_id);\n  }\n\n  async fetchThreadReplies(\n    channel: string,\n    thread_ts: string,\n    limit: number = 40\n  ): Promise<\n    Array<{ ts: string; user?: string; text?: string; bot_id?: string; thread_ts?: string }>\n  > {\n    try {\n      // Use query-string GET semantics similar to Slack WebClient to avoid\n      // subtle JSON/form encoding issues that can cause invalid_arguments\n      const params = new URLSearchParams({\n        channel,\n        ts: thread_ts,\n        limit: String(limit),\n      });\n      const res = await fetch(`https://slack.com/api/conversations.replies?${params.toString()}`, {\n        method: 'GET',\n        headers: {\n          Authorization: `Bearer ${this.token}`,\n        },\n      });\n      const resp: any = await res.json();\n      if (!resp || resp.ok !== true || !Array.isArray(resp.messages)) {\n        const err = (resp && resp.error) || 'unknown_error';\n        console.warn(\n          `Slack conversations.replies failed (non-fatal): ${err} (channel=${channel}, ts=${thread_ts}, limit=${limit})`\n        );\n        return [];\n      }\n      return resp.messages.map((m: any) => ({\n        ts: String(m.ts || ''),\n        user: m.user,\n        text: m.text,\n        bot_id: m.bot_id,\n        thread_ts: m.thread_ts,\n      }));\n    } catch (e) {\n      console.warn(\n        `Slack conversations.replies failed (non-fatal): ${\n          e instanceof Error ? e.message : String(e)\n        } (channel=${channel}, ts=${thread_ts}, limit=${limit})`\n      );\n      return [];\n    }\n  }\n\n  public readonly files = {\n    /**\n     * Upload a file to Slack using files.uploadV2 API\n     * @param options Upload options including file content, filename, channel, and thread_ts\n     */\n    uploadV2: async ({\n      content,\n      filename,\n      channel,\n      thread_ts,\n      title,\n      initial_comment,\n    }: {\n      content: Buffer;\n      filename: string;\n      channel: string;\n      thread_ts?: string;\n      title?: string;\n      initial_comment?: string;\n    }): Promise<{ ok: boolean; file?: { id: string; permalink?: string } }> => {\n      try {\n        // Step 1: Get upload URL\n        const getUrlResp: any = await this.api('files.getUploadURLExternal', {\n          filename,\n          length: content.length,\n        });\n        if (!getUrlResp || getUrlResp.ok !== true || !getUrlResp.upload_url) {\n          console.warn(\n            `Slack files.getUploadURLExternal failed: ${getUrlResp?.error || 'unknown'}`\n          );\n          return { ok: false };\n        }\n\n        // Step 2: Upload file content to the URL\n        const uploadResp = await fetch(getUrlResp.upload_url, {\n          method: 'POST',\n          body: content,\n        });\n        if (!uploadResp.ok) {\n          console.warn(`Slack file upload to URL failed: ${uploadResp.status}`);\n          return { ok: false };\n        }\n\n        // Step 3: Complete the upload and share to channel\n        const completeResp: any = await this.api('files.completeUploadExternal', {\n          files: [{ id: getUrlResp.file_id, title: title || filename }],\n          channel_id: channel,\n          thread_ts,\n          initial_comment,\n        });\n        if (!completeResp || completeResp.ok !== true) {\n          console.warn(\n            `Slack files.completeUploadExternal failed: ${completeResp?.error || 'unknown'}`\n          );\n          return { ok: false };\n        }\n\n        return {\n          ok: true,\n          file: completeResp.files?.[0] || { id: getUrlResp.file_id },\n        };\n      } catch (e) {\n        console.warn(`Slack file upload failed: ${e instanceof Error ? e.message : String(e)}`);\n        return { ok: false };\n      }\n    },\n  };\n\n  getWebClient(): any {\n    return {\n      conversations: {\n        history: async ({ channel, limit }: { channel: string; limit?: number }) =>\n          (await this.api('conversations.history', { channel, limit })) as any,\n        open: async ({ users }: { users: string }) =>\n          (await this.api('conversations.open', { users })) as any,\n        replies: async ({ channel, ts, limit }: { channel: string; ts: string; limit?: number }) =>\n          (await this.api('conversations.replies', { channel, ts, limit })) as any,\n      },\n    };\n  }\n\n  private async api(method: string, body: Record<string, unknown>): Promise<unknown> {\n    // Node 18+ global fetch\n    const res = await fetch(`https://slack.com/api/${method}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json; charset=utf-8',\n        Authorization: `Bearer ${this.token}`,\n      },\n      body: JSON.stringify(body),\n    });\n    return (await res.json()) as unknown;\n  }\n}\n","// Lightweight Markdown ‚Üí Slack mrkdwn formatter.\n// The goal is to make common Markdown output from AI steps look natural in Slack\n// without pulling in a full Markdown parser.\n//\n// Supported conversions:\n// - # Header / ## Header  ‚Üí *Header* (bold with visual separation)\n// - **bold** / __bold__   ‚Üí *bold*\n// - [label](url)          ‚Üí <url|label>\n// - ![alt](url)           ‚Üí <url|alt>\n// - *italic* (inline)     ‚Üí _italic_\n// - ```mermaid blocks     ‚Üí rendered to PNG and uploaded to Slack\n//\n// Everything else is passed through unchanged; Slack will still render many\n// Markdown-like constructs (lists, code fences, etc.) natively.\n\nimport { spawn } from 'child_process';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as os from 'os';\n\n/**\n * Represents an extracted mermaid diagram\n */\nexport interface MermaidDiagram {\n  /** The full match including ```mermaid and ``` */\n  fullMatch: string;\n  /** The mermaid code content */\n  code: string;\n  /** Start index in the original text */\n  startIndex: number;\n  /** End index in the original text */\n  endIndex: number;\n}\n\n/**\n * Extract all mermaid code blocks from text\n */\nexport function extractMermaidDiagrams(text: string): MermaidDiagram[] {\n  const diagrams: MermaidDiagram[] = [];\n  // Match ```mermaid followed by newline, content, and closing ```\n  const regex = /```mermaid\\s*\\n([\\s\\S]*?)```/g;\n  let match;\n  while ((match = regex.exec(text)) !== null) {\n    diagrams.push({\n      fullMatch: match[0],\n      code: match[1].trim(),\n      startIndex: match.index,\n      endIndex: match.index + match[0].length,\n    });\n  }\n  return diagrams;\n}\n\n/**\n * Render a mermaid diagram to PNG using mmdc CLI (@mermaid-js/mermaid-cli).\n *\n * Requirements:\n * - Node.js and npx must be available in PATH\n * - Network access on first run (npx downloads the package)\n * - Puppeteer/Chromium dependencies (mermaid-cli uses headless browser)\n *\n * On Linux, you may need to install chromium dependencies:\n *   apt-get install -y chromium-browser libatk-bridge2.0-0 libgtk-3-0\n *\n * On Docker/CI, consider using a base image with puppeteer support or\n * pre-installing @mermaid-js/mermaid-cli globally.\n *\n * @param mermaidCode The mermaid diagram code\n * @returns Buffer containing PNG data, or null if rendering failed\n */\nexport async function renderMermaidToPng(mermaidCode: string): Promise<Buffer | null> {\n  // Create temp files for input and output\n  const tmpDir = os.tmpdir();\n  const inputFile = path.join(\n    tmpDir,\n    `mermaid-${Date.now()}-${Math.random().toString(36).slice(2)}.mmd`\n  );\n  const outputFile = path.join(\n    tmpDir,\n    `mermaid-${Date.now()}-${Math.random().toString(36).slice(2)}.png`\n  );\n\n  try {\n    // Write mermaid code to temp file\n    fs.writeFileSync(inputFile, mermaidCode, 'utf-8');\n\n    // Detect system chromium for puppeteer (mermaid-cli dependency)\n    // Without this, puppeteer may hang trying to download its own chromium\n    const chromiumPaths = [\n      '/usr/bin/chromium',\n      '/usr/bin/chromium-browser',\n      '/usr/bin/google-chrome',\n      '/usr/bin/chrome',\n    ];\n    let chromiumPath: string | undefined;\n    for (const p of chromiumPaths) {\n      if (fs.existsSync(p)) {\n        chromiumPath = p;\n        break;\n      }\n    }\n\n    // Build environment with chromium path if found\n    const env = { ...process.env };\n    if (chromiumPath) {\n      env.PUPPETEER_EXECUTABLE_PATH = chromiumPath;\n    }\n\n    // Run mmdc to render PNG\n    const result = await new Promise<{ success: boolean; error?: string }>(resolve => {\n      const proc = spawn(\n        'npx',\n        [\n          '--yes',\n          '@mermaid-js/mermaid-cli',\n          '-i',\n          inputFile,\n          '-o',\n          outputFile,\n          '-e',\n          'png',\n          '-b',\n          'white',\n          '-w',\n          '1200',\n        ],\n        {\n          timeout: 60000, // 60 second timeout (first run may download packages)\n          stdio: ['pipe', 'pipe', 'pipe'],\n          env,\n        }\n      );\n\n      let stderr = '';\n      proc.stderr?.on('data', data => {\n        stderr += data.toString();\n      });\n\n      proc.on('close', code => {\n        if (code === 0) {\n          resolve({ success: true });\n        } else {\n          resolve({ success: false, error: stderr || `Exit code ${code}` });\n        }\n      });\n\n      proc.on('error', err => {\n        resolve({ success: false, error: err.message });\n      });\n    });\n\n    if (!result.success) {\n      console.warn(`Mermaid rendering failed: ${result.error}`);\n      return null;\n    }\n\n    // Read the output PNG\n    if (!fs.existsSync(outputFile)) {\n      console.warn('Mermaid output file not created');\n      return null;\n    }\n\n    const pngBuffer = fs.readFileSync(outputFile);\n    return pngBuffer;\n  } catch (e) {\n    console.warn(`Mermaid rendering error: ${e instanceof Error ? e.message : String(e)}`);\n    return null;\n  } finally {\n    // Cleanup temp files\n    try {\n      if (fs.existsSync(inputFile)) fs.unlinkSync(inputFile);\n      if (fs.existsSync(outputFile)) fs.unlinkSync(outputFile);\n    } catch {\n      // Ignore cleanup errors\n    }\n  }\n}\n\n/**\n * Replace mermaid blocks in text with a placeholder message\n * @param text Original text\n * @param diagrams Extracted diagrams\n * @param replacement Text to replace each diagram with (or a function that returns replacement for each index)\n */\nexport function replaceMermaidBlocks(\n  text: string,\n  diagrams: MermaidDiagram[],\n  replacement: string | ((index: number) => string) = '_(See diagram above)_'\n): string {\n  if (diagrams.length === 0) return text;\n\n  // Sort by start index descending to replace from end to start (preserves indices)\n  const sorted = [...diagrams].sort((a, b) => b.startIndex - a.startIndex);\n\n  let result = text;\n  sorted.forEach((diagram, sortedIndex) => {\n    // Calculate original index (since we sorted in reverse)\n    const originalIndex = diagrams.length - 1 - sortedIndex;\n    const rep = typeof replacement === 'function' ? replacement(originalIndex) : replacement;\n    result = result.slice(0, diagram.startIndex) + rep + result.slice(diagram.endIndex);\n  });\n\n  return result;\n}\n\nexport function markdownToSlack(text: string): string {\n  if (!text || typeof text !== 'string') return '';\n\n  let out = text;\n\n  // Images: ![alt](url) ‚Üí <url|alt>\n  // We intentionally keep only the URL + alt text; Slack will usually unfurl.\n  out = out.replace(\n    /!\\[([^\\]]*)\\]\\(([^)\\s]+)(?:\\s+\"[^\"]*\")?\\)/g,\n    (_m, alt: string, url: string) => `<${url}|${alt || 'image'}>`\n  );\n\n  // Links: [label](url) ‚Üí <url|label>\n  out = out.replace(\n    /\\[([^\\]]+)\\]\\(([^)\\s]+)(?:\\s+\"[^\"]*\")?\\)/g,\n    (_m, label: string, url: string) => `<${url}|${label}>`\n  );\n\n  // Bold: **text** or __text__ ‚Üí *text*\n  out = out.replace(/\\*\\*([^*]+)\\*\\*/g, (_m, inner: string) => `*${inner}*`);\n  out = out.replace(/__([^_]+)__/g, (_m, inner: string) => `*${inner}*`);\n\n  // Process lines for headers and bullet lists.\n  // Slack's mrkdwn handles \"‚Ä¢\" bullets more naturally than raw \"-\" Markdown.\n  const lines = out.split(/\\r?\\n/);\n  let inCodeBlock = false;\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const trimmed = line.trimStart();\n    // Track fenced code blocks and avoid rewriting inside them\n    if (/^```/.test(trimmed)) {\n      inCodeBlock = !inCodeBlock;\n      continue;\n    }\n    if (inCodeBlock) continue;\n\n    // Headers: # Header ‚Üí *Header* (Slack doesn't have native headers)\n    // Match 1-6 # at start of line, followed by space and text\n    const headerMatch = /^(#{1,6})\\s+(.+)$/.exec(trimmed);\n    if (headerMatch) {\n      const [, hashes, headerText] = headerMatch;\n      // For h1/h2, add extra emphasis with newline before (if not first line\n      // and previous line is not empty/header/code-fence)\n      const prevLine = i > 0 ? lines[i - 1].trim() : '';\n      const prevIsHeaderOrFence =\n        /^#{1,6}\\s+/.test(prevLine) || /^\\*[^*]+\\*$/.test(prevLine) || /^```/.test(prevLine);\n      if (hashes.length <= 2 && i > 0 && prevLine !== '' && !prevIsHeaderOrFence) {\n        lines[i] = `\\n*${headerText.trim()}*`;\n      } else {\n        lines[i] = `*${headerText.trim()}*`;\n      }\n      continue;\n    }\n\n    // Bullet lists: \"- item\" or \"* item\" ‚Üí \"‚Ä¢ item\" (preserve indentation)\n    const bulletMatch = /^(\\s*)([-*])\\s+(.+)$/.exec(line);\n    if (bulletMatch) {\n      const [, indent, , rest] = bulletMatch;\n      lines[i] = `${indent}‚Ä¢ ${rest}`;\n    }\n  }\n  out = lines.join('\\n');\n\n  return out;\n}\n\nexport function formatSlackText(text: string): string {\n  return markdownToSlack(text);\n}\n","/**\n * Slack Frontend for Visor workflows.\n *\n * Features:\n * - Posts AI replies to Slack threads\n * - Converts Markdown to Slack mrkdwn format\n * - Renders mermaid diagrams to PNG and uploads as images\n * - Manages üëÄ/üëç reactions for acknowledgement\n * - Handles human input prompts via prompt-state\n *\n * Mermaid Diagram Rendering:\n * - Detects ```mermaid code blocks in AI responses\n * - Renders to PNG using @mermaid-js/mermaid-cli (mmdc)\n * - Uploads rendered images to Slack thread\n * - Replaces mermaid blocks with \"_(See diagram above)_\" placeholder\n *\n * Requirements for mermaid rendering:\n * - Node.js and npx in PATH\n * - Puppeteer/Chromium dependencies (mermaid-cli uses headless browser)\n * - On Linux: apt-get install chromium-browser libatk-bridge2.0-0 libgtk-3-0\n */\nimport type { Frontend, FrontendContext } from './host';\nimport { SlackClient } from '../slack/client';\nimport {\n  formatSlackText,\n  extractMermaidDiagrams,\n  renderMermaidToPng,\n  replaceMermaidBlocks,\n} from '../slack/markdown';\nimport { context as otContext, trace } from '../telemetry/lazy-otel';\n\ntype SlackFrontendConfig = {\n  defaultChannel?: string;\n  groupChannels?: Record<string, string>;\n  debounceMs?: number;\n  maxWaitMs?: number;\n  showRawOutput?: boolean;\n  telemetry?: {\n    enabled?: boolean;\n  };\n};\n\nexport class SlackFrontend implements Frontend {\n  public readonly name = 'slack';\n  private subs: Array<{ unsubscribe(): void }> = [];\n  private cfg: SlackFrontendConfig;\n  // Reactions ack/done per run (inbound Slack events only)\n  private acked: boolean = false;\n  private ackRef: { channel: string; ts: string } | null = null;\n  private ackName: string = 'eyes';\n  private doneName: string = 'thumbsup';\n\n  constructor(config?: SlackFrontendConfig) {\n    this.cfg = config || {};\n  }\n\n  start(ctx: FrontendContext): void {\n    const bus = ctx.eventBus;\n\n    // Info-level boot log\n    try {\n      const hasClient = !!(\n        (ctx as any).slack ||\n        (ctx as any).slackClient ||\n        (this.cfg as any)?.botToken ||\n        process.env.SLACK_BOT_TOKEN\n      );\n      ctx.logger.info(`[slack-frontend] started; hasClient=${hasClient} defaultChannel=unset`);\n    } catch {}\n\n    // If this run was triggered by a Slack event, log key attributes\n    try {\n      const payload = this.getInboundSlackPayload(ctx);\n      if (payload) {\n        const ev: any = payload.event || {};\n        const ch = String(ev.channel || '-');\n        const ts = String(ev.ts || ev.event_ts || '-');\n        const user = String(ev.user || ev.bot_id || '-');\n        const type = String(ev.type || '-');\n        const thread = String(ev.thread_ts || '');\n        ctx.logger.info(\n          `[slack-frontend] inbound event received: type=${type} channel=${ch} ts=${ts}` +\n            (thread ? ` thread_ts=${thread}` : '') +\n            ` user=${user}`\n        );\n      }\n    } catch {}\n\n    // Listen to check lifecycle; we only post on completion/error (no queued placeholders)\n    this.subs.push(\n      bus.on('CheckCompleted', async (env: any) => {\n        const ev = (env && env.payload) || env;\n        // For chat-style AI checks, post direct replies into the Slack thread\n        await this.maybePostDirectReply(ctx, ev.checkId, ev.result).catch(() => {});\n      })\n    );\n\n    // On terminal state, replace üëÄ with üëç if we acked an inbound Slack message\n    this.subs.push(\n      bus.on('StateTransition', async (env: any) => {\n        const ev = (env && env.payload) || env;\n        if (ev && (ev.to === 'Completed' || ev.to === 'Error')) {\n          await this.finalizeReactions(ctx).catch(() => {});\n        }\n      })\n    );\n    // Add üëÄ acknowledgement as soon as first check is scheduled for Slack-driven runs\n    this.subs.push(\n      bus.on('CheckScheduled', async () => {\n        await this.ensureAcknowledgement(ctx).catch(() => {});\n      })\n    );\n\n    // Human-input requests: post prompt to Slack and mark waiting using prompt-state\n    this.subs.push(\n      bus.on('HumanInputRequested', async (env: any) => {\n        try {\n          const ev = (env && env.payload) || env;\n          if (!ev || typeof ev.prompt !== 'string' || !ev.checkId) return;\n          // Determine channel/thread (Slack SocketMode); if we can't, just ignore.\n          let channel = ev.channel as string | undefined;\n          let threadTs = ev.threadTs as string | undefined;\n          if (!channel || !threadTs) {\n            const payload = this.getInboundSlackPayload(ctx);\n            const e: any = payload?.event;\n            const derivedTs = String(e?.thread_ts || e?.ts || e?.event_ts || '');\n            const derivedCh = String(e?.channel || '');\n            if (derivedCh && derivedTs) {\n              channel = channel || derivedCh;\n              threadTs = threadTs || derivedTs;\n            }\n          }\n          if (!channel || !threadTs) return;\n\n          // Mark waiting in prompt-state without posting the prompt text to Slack.\n          const { getPromptStateManager } = await import('../slack/prompt-state');\n          const mgr = getPromptStateManager();\n          const prev = mgr.getWaiting(channel, threadTs);\n          const text = String(ev.prompt);\n          mgr.setWaiting(channel, threadTs, {\n            checkName: String(ev.checkId),\n            prompt: text,\n            promptMessageTs: prev?.promptMessageTs,\n            promptsPosted: ((prev?.promptsPosted || 0) + 1) as any,\n          });\n          try {\n            ctx.logger.info(\n              `[slack-frontend] registered human-input waiting state for ${channel} thread=${threadTs}`\n            );\n          } catch {}\n        } catch (e) {\n          try {\n            ctx.logger.warn(\n              `[slack-frontend] HumanInputRequested handling failed: ${\n                e instanceof Error ? e.message : String(e)\n              }`\n            );\n          } catch {}\n        }\n      })\n    );\n\n    // SnapshotSaved: attach snapshot path to waiting entry for this thread\n    this.subs.push(\n      bus.on('SnapshotSaved', async (env: any) => {\n        try {\n          const ev = (env && env.payload) || env;\n          const channel = String(ev?.channel || '');\n          const threadTs = String(ev?.threadTs || '');\n          const filePath = String(ev?.filePath || '');\n          if (!channel || !threadTs || !filePath) return;\n          const { getPromptStateManager } = await import('../slack/prompt-state');\n          const mgr = getPromptStateManager();\n          mgr.update(channel, threadTs, { snapshotPath: filePath });\n          try {\n            ctx.logger.info(\n              `[slack-frontend] snapshot path attached to waiting prompt: ${filePath}`\n            );\n          } catch {}\n        } catch {}\n      })\n    );\n  }\n\n  stop(): void {\n    for (const s of this.subs) s.unsubscribe();\n    this.subs = [];\n  }\n\n  private getSlack(ctx: FrontendContext): any | undefined {\n    // Prefer injected fake client in tests: ctx.slack or ctx.slackClient\n    const injected = (ctx as any).slack || (ctx as any).slackClient;\n    if (injected) return injected;\n    // Else try to lazy-create from env or frontend config\n    try {\n      const token = (this.cfg as any)?.botToken || process.env.SLACK_BOT_TOKEN;\n      if (typeof token === 'string' && token.trim()) {\n        return new SlackClient(token.trim());\n      }\n    } catch {}\n    return undefined;\n  }\n\n  private getInboundSlackPayload(ctx: FrontendContext): any | null {\n    try {\n      const anyCfg: any = ctx.config || {};\n      const slackCfg: any = anyCfg.slack || {};\n      const endpoint: string = slackCfg.endpoint || '/bots/slack/support';\n      const payload: any = (ctx as any).webhookContext?.webhookData?.get(endpoint);\n      return payload || null;\n    } catch {\n      return null;\n    }\n  }\n\n  private getInboundSlackEvent(ctx: FrontendContext): { channel: string; ts: string } | null {\n    try {\n      const payload = this.getInboundSlackPayload(ctx);\n      const ev: any = payload?.event;\n      const channel = String(ev?.channel || '');\n      const ts = String(ev?.ts || ev?.event_ts || '');\n      if (channel && ts) return { channel, ts };\n    } catch {}\n    return null;\n  }\n\n  private async ensureAcknowledgement(ctx: FrontendContext): Promise<void> {\n    if (this.acked) return;\n    const ref = this.getInboundSlackEvent(ctx);\n    if (!ref) return;\n    const slack = this.getSlack(ctx);\n    if (!slack) return;\n    // Skip ack for bot messages to avoid loops\n    try {\n      const payload = this.getInboundSlackPayload(ctx);\n      const ev: any = payload?.event;\n      if (ev?.subtype === 'bot_message') return;\n      // If we can resolve bot user id, skip if the sender is the bot\n      try {\n        const botId = await slack.getBotUserId?.();\n        if (botId && ev?.user && String(ev.user) === String(botId)) return;\n      } catch {}\n    } catch {}\n    // Allow overrides via config\n    try {\n      const anyCfg: any = ctx.config || {};\n      const slackCfg: any = anyCfg.slack || {};\n      if (slackCfg?.reactions?.enabled === false) return;\n      this.ackName = slackCfg?.reactions?.ack || this.ackName;\n      this.doneName = slackCfg?.reactions?.done || this.doneName;\n    } catch {}\n    await slack.reactions.add({ channel: ref.channel, timestamp: ref.ts, name: this.ackName });\n    try {\n      ctx.logger.info(\n        `[slack-frontend] added acknowledgement reaction :${this.ackName}: channel=${ref.channel} ts=${ref.ts}`\n      );\n    } catch {}\n    this.acked = true;\n    this.ackRef = ref;\n  }\n\n  private async finalizeReactions(ctx: FrontendContext): Promise<void> {\n    if (!this.acked || !this.ackRef) return;\n    const slack = this.getSlack(ctx);\n    if (!slack) return;\n    try {\n      try {\n        await slack.reactions.remove({\n          channel: this.ackRef.channel,\n          timestamp: this.ackRef.ts,\n          name: this.ackName,\n        });\n      } catch {}\n      await slack.reactions.add({\n        channel: this.ackRef.channel,\n        timestamp: this.ackRef.ts,\n        name: this.doneName,\n      });\n      try {\n        ctx.logger.info(\n          `[slack-frontend] replaced acknowledgement with completion reaction :${this.doneName}: channel=${this.ackRef.channel} ts=${this.ackRef.ts}`\n        );\n      } catch {}\n    } finally {\n      // Reset for safety\n      this.acked = false;\n      this.ackRef = null;\n    }\n  }\n\n  /**\n   * Post direct replies into the originating Slack thread when appropriate.\n   * This is independent of summary messages and is intended for chat-style flows\n   * (e.g., AI answers and explicit chat/notify steps).\n   */\n  private async maybePostDirectReply(\n    ctx: FrontendContext,\n    checkId: string,\n    result: { output?: any; content?: string }\n  ): Promise<void> {\n    try {\n      const cfg: any = ctx.config || {};\n      const checkCfg: any = cfg.checks?.[checkId];\n      if (!checkCfg) return;\n\n      // Per-workflow / per-frontend flag to allow posting raw JSON\n      // outputs for AI steps (useful for debugging router outputs).\n      const slackRoot: any = (cfg as any).slack || {};\n      const showRawOutput =\n        slackRoot.show_raw_output === true || (this.cfg as any)?.showRawOutput === true;\n      const telemetryCfg = slackRoot.telemetry ?? (this.cfg as any)?.telemetry;\n\n      const providerType = (checkCfg.type as string) || '';\n      const isAi = providerType === 'ai';\n      const isLogChat = providerType === 'log' && checkCfg.group === 'chat';\n      if (!isAi && !isLogChat) return;\n\n      // Skip internal steps - they're intermediate processing and shouldn't post to Slack\n      if (checkCfg.criticality === 'internal') return;\n\n      // For AI checks, only post when using simple/unstructured schemas (or none).\n      if (isAi) {\n        const schema = checkCfg.schema;\n        // String schemas: allow only simple/plain ones\n        if (typeof schema === 'string') {\n          const simpleSchemas = ['code-review', 'markdown', 'text', 'plain'];\n          if (!simpleSchemas.includes(schema)) return;\n        }\n        // Object schemas (custom JSON): treat as structured; require output.text\n      }\n\n      const slack = this.getSlack(ctx);\n      if (!slack) return;\n\n      const payload = this.getInboundSlackPayload(ctx);\n      const ev: any = payload?.event;\n      const channel = String(ev?.channel || '');\n      const threadTs = String(ev?.thread_ts || ev?.ts || ev?.event_ts || '');\n      if (!channel || !threadTs) return;\n\n      // Prefer output.text; fall back to content ONLY for string/simple schemas.\n      const out: any = (result as any)?.output;\n      let text: string | undefined;\n      if (out && typeof out.text === 'string' && out.text.trim().length > 0) {\n        text = out.text.trim();\n      } else if (isAi && typeof checkCfg.schema === 'string') {\n        if (\n          typeof (result as any)?.content === 'string' &&\n          (result as any).content.trim().length > 0\n        ) {\n          text = (result as any).content.trim();\n        }\n      } else if (isLogChat && typeof (result as any)?.logOutput === 'string') {\n        // For log-based chat checks, render the formatted log output as the\n        // Slack message when no structured text field is present.\n        const raw = (result as any).logOutput;\n        if (raw.trim().length > 0) {\n          text = raw.trim();\n        }\n      } else if (isAi && showRawOutput && out !== undefined) {\n        try {\n          text = JSON.stringify(out, null, 2);\n        } catch {\n          text = String(out);\n        }\n      }\n      if (!text) return;\n\n      // Extract and render mermaid diagrams before posting\n      const diagrams = extractMermaidDiagrams(text);\n      let processedText = text;\n\n      if (diagrams.length > 0) {\n        try {\n          ctx.logger.info(\n            `[slack-frontend] found ${diagrams.length} mermaid diagram(s) to render for ${checkId}`\n          );\n        } catch {}\n\n        // Render and upload each diagram\n        const uploadedCount: number[] = [];\n        for (let i = 0; i < diagrams.length; i++) {\n          const diagram = diagrams[i];\n          try {\n            ctx.logger.info(`[slack-frontend] rendering mermaid diagram ${i + 1}...`);\n            const pngBuffer = await renderMermaidToPng(diagram.code);\n            if (pngBuffer) {\n              ctx.logger.info(\n                `[slack-frontend] rendered diagram ${i + 1}, size=${pngBuffer.length} bytes, uploading...`\n              );\n              const filename = `diagram-${i + 1}.png`;\n              const uploadResult = await slack.files.uploadV2({\n                content: pngBuffer,\n                filename,\n                channel,\n                thread_ts: threadTs,\n                title: `Diagram ${i + 1}`,\n              });\n              if (uploadResult.ok) {\n                uploadedCount.push(i);\n                ctx.logger.info(`[slack-frontend] uploaded mermaid diagram ${i + 1} to ${channel}`);\n              } else {\n                ctx.logger.warn(`[slack-frontend] upload failed for diagram ${i + 1}`);\n              }\n            } else {\n              ctx.logger.warn(\n                `[slack-frontend] mermaid rendering returned null for diagram ${i + 1} (mmdc failed or not installed)`\n              );\n            }\n          } catch (e) {\n            ctx.logger.warn(\n              `[slack-frontend] failed to render/upload mermaid diagram ${i + 1}: ${\n                e instanceof Error ? e.message : String(e)\n              }`\n            );\n          }\n        }\n\n        // Replace mermaid blocks with placeholder text\n        if (uploadedCount.length > 0) {\n          processedText = replaceMermaidBlocks(text, diagrams, idx =>\n            uploadedCount.includes(idx) ? '_(See diagram above)_' : '_(Diagram rendering failed)_'\n          );\n        }\n      }\n\n      let decoratedText = processedText;\n      const telemetryEnabled =\n        telemetryCfg === true ||\n        (telemetryCfg && typeof telemetryCfg === 'object' && telemetryCfg.enabled === true);\n      if (telemetryEnabled) {\n        const traceInfo = this.getTraceInfo();\n        if (traceInfo?.traceId) {\n          const suffix = `\\`trace_id: ${traceInfo.traceId}\\``;\n          decoratedText = `${decoratedText}\\n\\n${suffix}`;\n        }\n      }\n\n      const formattedText = formatSlackText(decoratedText);\n      await slack.chat.postMessage({ channel, text: formattedText, thread_ts: threadTs });\n      ctx.logger.info(\n        `[slack-frontend] posted AI reply for ${checkId} to ${channel} thread=${threadTs}`\n      );\n    } catch (outerErr) {\n      // Log errors instead of silently swallowing them\n      try {\n        ctx.logger.warn(\n          `[slack-frontend] maybePostDirectReply failed for ${checkId}: ${\n            outerErr instanceof Error ? outerErr.message : String(outerErr)\n          }`\n        );\n      } catch {}\n    }\n  }\n\n  private getTraceInfo(): { traceId: string; spanId: string } | null {\n    try {\n      const span = trace.getSpan(otContext.active());\n      if (!span) return null;\n      const ctx = span.spanContext();\n      if (!ctx || !ctx.traceId) return null;\n      return { traceId: ctx.traceId, spanId: ctx.spanId };\n    } catch {\n      return null;\n    }\n  }\n}\n"],"mappings":"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","names":[]}