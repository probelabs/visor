{"version":3,"sources":["../../src/slack/client.ts","../../src/slack/markdown.ts","../../src/frontends/slack-frontend.ts"],"sourcesContent":["// Lightweight Slack Web API wrapper implemented with fetch (no external deps).\n// Only methods needed by SlackFrontend are implemented.\n\nexport class SlackClient {\n  private token: string;\n\n  constructor(botToken: string) {\n    if (!botToken || typeof botToken !== 'string') {\n      throw new Error('SlackClient: botToken is required');\n    }\n    this.token = botToken;\n  }\n\n  public readonly reactions = {\n    add: async ({\n      channel,\n      timestamp,\n      name,\n    }: {\n      channel: string;\n      timestamp: string;\n      name: string;\n    }) => {\n      const resp: any = await this.api('reactions.add', { channel, timestamp, name });\n      if (!resp || resp.ok !== true) {\n        // Non-fatal in CLI/test runs â€“ log and continue\n        const err = (resp && resp.error) || 'unknown_error';\n        console.warn(`Slack reactions.add failed (non-fatal): ${err}`);\n        return { ok: false as const };\n      }\n      return { ok: true } as const;\n    },\n    remove: async ({\n      channel,\n      timestamp,\n      name,\n    }: {\n      channel: string;\n      timestamp: string;\n      name: string;\n    }) => {\n      const resp: any = await this.api('reactions.remove', { channel, timestamp, name });\n      if (!resp || resp.ok !== true) {\n        const err = (resp && resp.error) || 'unknown_error';\n        console.warn(`Slack reactions.remove failed (non-fatal): ${err}`);\n        return { ok: false as const };\n      }\n      return { ok: true } as const;\n    },\n  };\n\n  public readonly chat = {\n    postMessage: async ({\n      channel,\n      text,\n      thread_ts,\n    }: {\n      channel: string;\n      text: string;\n      thread_ts?: string;\n    }) => {\n      const resp: any = await this.api('chat.postMessage', { channel, text, thread_ts });\n      if (!resp || resp.ok !== true) {\n        const err = (resp && resp.error) || 'unknown_error';\n        console.warn(`Slack chat.postMessage failed (non-fatal): ${err}`);\n        return {\n          ts: undefined,\n          message: undefined,\n          data: resp,\n        };\n      }\n      // Normalize common fields for tests/frontend\n      return {\n        ts: resp.ts || (resp.message && resp.message.ts) || undefined,\n        message: resp.message,\n        data: resp,\n      };\n    },\n    update: async ({ channel, ts, text }: { channel: string; ts: string; text: string }) => {\n      const resp: any = await this.api('chat.update', { channel, ts, text });\n      if (!resp || resp.ok !== true) {\n        const err = (resp && resp.error) || 'unknown_error';\n        console.warn(`Slack chat.update failed (non-fatal): ${err}`);\n        return { ok: false as const, ts };\n      }\n      return { ok: true as const, ts: resp.ts || ts };\n    },\n  };\n\n  async getBotUserId(): Promise<string> {\n    const resp: any = await this.api('auth.test', {});\n    if (!resp || resp.ok !== true || !resp.user_id) {\n      console.warn('Slack auth.test failed (non-fatal); bot user id unavailable');\n      return 'UNKNOWN_BOT';\n    }\n    return String(resp.user_id);\n  }\n\n  async fetchThreadReplies(\n    channel: string,\n    thread_ts: string,\n    limit: number = 40\n  ): Promise<\n    Array<{ ts: string; user?: string; text?: string; bot_id?: string; thread_ts?: string }>\n  > {\n    try {\n      // Use query-string GET semantics similar to Slack WebClient to avoid\n      // subtle JSON/form encoding issues that can cause invalid_arguments\n      const params = new URLSearchParams({\n        channel,\n        ts: thread_ts,\n        limit: String(limit),\n      });\n      const res = await fetch(`https://slack.com/api/conversations.replies?${params.toString()}`, {\n        method: 'GET',\n        headers: {\n          Authorization: `Bearer ${this.token}`,\n        },\n      });\n      const resp: any = await res.json();\n      if (!resp || resp.ok !== true || !Array.isArray(resp.messages)) {\n        const err = (resp && resp.error) || 'unknown_error';\n        console.warn(\n          `Slack conversations.replies failed (non-fatal): ${err} (channel=${channel}, ts=${thread_ts}, limit=${limit})`\n        );\n        return [];\n      }\n      return resp.messages.map((m: any) => ({\n        ts: String(m.ts || ''),\n        user: m.user,\n        text: m.text,\n        bot_id: m.bot_id,\n        thread_ts: m.thread_ts,\n      }));\n    } catch (e) {\n      console.warn(\n        `Slack conversations.replies failed (non-fatal): ${\n          e instanceof Error ? e.message : String(e)\n        } (channel=${channel}, ts=${thread_ts}, limit=${limit})`\n      );\n      return [];\n    }\n  }\n\n  getWebClient(): any {\n    return {\n      conversations: {\n        history: async ({ channel, limit }: { channel: string; limit?: number }) =>\n          (await this.api('conversations.history', { channel, limit })) as any,\n        open: async ({ users }: { users: string }) =>\n          (await this.api('conversations.open', { users })) as any,\n        replies: async ({ channel, ts, limit }: { channel: string; ts: string; limit?: number }) =>\n          (await this.api('conversations.replies', { channel, ts, limit })) as any,\n      },\n    };\n  }\n\n  private async api(method: string, body: Record<string, unknown>): Promise<unknown> {\n    // Node 18+ global fetch\n    const res = await fetch(`https://slack.com/api/${method}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json; charset=utf-8',\n        Authorization: `Bearer ${this.token}`,\n      },\n      body: JSON.stringify(body),\n    });\n    return (await res.json()) as unknown;\n  }\n}\n","// Lightweight Markdown â†’ Slack mrkdwn formatter.\n// The goal is to make common Markdown output from AI steps look natural in Slack\n// without pulling in a full Markdown parser.\n//\n// Supported conversions:\n// - **bold** / __bold__   â†’ *bold*\n// - [label](url)          â†’ <url|label>\n// - ![alt](url)           â†’ <url|alt>\n// - *italic* (inline)     â†’ _italic_\n//\n// Everything else is passed through unchanged; Slack will still render many\n// Markdown-like constructs (lists, code fences, etc.) natively.\n\nexport function markdownToSlack(text: string): string {\n  if (!text || typeof text !== 'string') return '';\n\n  let out = text;\n\n  // Images: ![alt](url) â†’ <url|alt>\n  // We intentionally keep only the URL + alt text; Slack will usually unfurl.\n  out = out.replace(\n    /!\\[([^\\]]*)\\]\\(([^)\\s]+)(?:\\s+\"[^\"]*\")?\\)/g,\n    (_m, alt: string, url: string) => `<${url}|${alt || 'image'}>`\n  );\n\n  // Links: [label](url) â†’ <url|label>\n  out = out.replace(\n    /\\[([^\\]]+)\\]\\(([^)\\s]+)(?:\\s+\"[^\"]*\")?\\)/g,\n    (_m, label: string, url: string) => `<${url}|${label}>`\n  );\n\n  // Bold: **text** or __text__ â†’ *text*\n  out = out.replace(/\\*\\*([^*]+)\\*\\*/g, (_m, inner: string) => `*${inner}*`);\n  out = out.replace(/__([^_]+)__/g, (_m, inner: string) => `*${inner}*`);\n\n  // Bullet lists: \"- item\" or \"* item\" â†’ \"â€¢ item\" (preserve indentation).\n  // Slack's mrkdwn handles \"â€¢\" bullets more naturally than raw \"-\" Markdown.\n  const lines = out.split(/\\r?\\n/);\n  let inCodeBlock = false;\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const trimmed = line.trimStart();\n    // Track fenced code blocks and avoid rewriting inside them\n    if (/^```/.test(trimmed)) {\n      inCodeBlock = !inCodeBlock;\n      continue;\n    }\n    if (inCodeBlock) continue;\n    const match = /^(\\s*)([-*])\\s+(.+)$/.exec(line);\n    if (match) {\n      const [, indent, , rest] = match;\n      lines[i] = `${indent}â€¢ ${rest}`;\n    }\n  }\n  out = lines.join('\\n');\n\n  return out;\n}\n\nexport function formatSlackText(text: string): string {\n  return markdownToSlack(text);\n}\n","import type { Frontend, FrontendContext } from './host';\nimport { SlackClient } from '../slack/client';\nimport { formatSlackText } from '../slack/markdown';\n\ntype SlackFrontendConfig = {\n  defaultChannel?: string;\n  groupChannels?: Record<string, string>;\n  debounceMs?: number;\n  maxWaitMs?: number;\n  showRawOutput?: boolean;\n};\n\nexport class SlackFrontend implements Frontend {\n  public readonly name = 'slack';\n  private subs: Array<{ unsubscribe(): void }> = [];\n  private cfg: SlackFrontendConfig;\n  // Reactions ack/done per run (inbound Slack events only)\n  private acked: boolean = false;\n  private ackRef: { channel: string; ts: string } | null = null;\n  private ackName: string = 'eyes';\n  private doneName: string = 'thumbsup';\n\n  constructor(config?: SlackFrontendConfig) {\n    this.cfg = config || {};\n  }\n\n  start(ctx: FrontendContext): void {\n    const bus = ctx.eventBus;\n\n    // Info-level boot log\n    try {\n      const hasClient = !!(\n        (ctx as any).slack ||\n        (ctx as any).slackClient ||\n        (this.cfg as any)?.botToken ||\n        process.env.SLACK_BOT_TOKEN\n      );\n      ctx.logger.info(`[slack-frontend] started; hasClient=${hasClient} defaultChannel=unset`);\n    } catch {}\n\n    // If this run was triggered by a Slack event, log key attributes\n    try {\n      const payload = this.getInboundSlackPayload(ctx);\n      if (payload) {\n        const ev: any = payload.event || {};\n        const ch = String(ev.channel || '-');\n        const ts = String(ev.ts || ev.event_ts || '-');\n        const user = String(ev.user || ev.bot_id || '-');\n        const type = String(ev.type || '-');\n        const thread = String(ev.thread_ts || '');\n        ctx.logger.info(\n          `[slack-frontend] inbound event received: type=${type} channel=${ch} ts=${ts}` +\n            (thread ? ` thread_ts=${thread}` : '') +\n            ` user=${user}`\n        );\n      }\n    } catch {}\n\n    // Listen to check lifecycle; we only post on completion/error (no queued placeholders)\n    this.subs.push(\n      bus.on('CheckCompleted', async (env: any) => {\n        const ev = (env && env.payload) || env;\n        // For chat-style AI checks, post direct replies into the Slack thread\n        await this.maybePostDirectReply(ctx, ev.checkId, ev.result).catch(() => {});\n      })\n    );\n\n    // On terminal state, replace ðŸ‘€ with ðŸ‘ if we acked an inbound Slack message\n    this.subs.push(\n      bus.on('StateTransition', async (env: any) => {\n        const ev = (env && env.payload) || env;\n        if (ev && (ev.to === 'Completed' || ev.to === 'Error')) {\n          await this.finalizeReactions(ctx).catch(() => {});\n        }\n      })\n    );\n    // Add ðŸ‘€ acknowledgement as soon as first check is scheduled for Slack-driven runs\n    this.subs.push(\n      bus.on('CheckScheduled', async () => {\n        await this.ensureAcknowledgement(ctx).catch(() => {});\n      })\n    );\n\n    // Human-input requests: post prompt to Slack and mark waiting using prompt-state\n    this.subs.push(\n      bus.on('HumanInputRequested', async (env: any) => {\n        try {\n          const ev = (env && env.payload) || env;\n          if (!ev || typeof ev.prompt !== 'string' || !ev.checkId) return;\n          // Determine channel/thread (Slack SocketMode); if we can't, just ignore.\n          let channel = ev.channel as string | undefined;\n          let threadTs = ev.threadTs as string | undefined;\n          if (!channel || !threadTs) {\n            const payload = this.getInboundSlackPayload(ctx);\n            const e: any = payload?.event;\n            const derivedTs = String(e?.thread_ts || e?.ts || e?.event_ts || '');\n            const derivedCh = String(e?.channel || '');\n            if (derivedCh && derivedTs) {\n              channel = channel || derivedCh;\n              threadTs = threadTs || derivedTs;\n            }\n          }\n          if (!channel || !threadTs) return;\n\n          // Mark waiting in prompt-state without posting the prompt text to Slack.\n          const { getPromptStateManager } = await import('../slack/prompt-state');\n          const mgr = getPromptStateManager();\n          const prev = mgr.getWaiting(channel, threadTs);\n          const text = String(ev.prompt);\n          mgr.setWaiting(channel, threadTs, {\n            checkName: String(ev.checkId),\n            prompt: text,\n            promptMessageTs: prev?.promptMessageTs,\n            promptsPosted: ((prev?.promptsPosted || 0) + 1) as any,\n          });\n          try {\n            ctx.logger.info(\n              `[slack-frontend] registered human-input waiting state for ${channel} thread=${threadTs}`\n            );\n          } catch {}\n        } catch (e) {\n          try {\n            ctx.logger.warn(\n              `[slack-frontend] HumanInputRequested handling failed: ${\n                e instanceof Error ? e.message : String(e)\n              }`\n            );\n          } catch {}\n        }\n      })\n    );\n\n    // SnapshotSaved: attach snapshot path to waiting entry for this thread\n    this.subs.push(\n      bus.on('SnapshotSaved', async (env: any) => {\n        try {\n          const ev = (env && env.payload) || env;\n          const channel = String(ev?.channel || '');\n          const threadTs = String(ev?.threadTs || '');\n          const filePath = String(ev?.filePath || '');\n          if (!channel || !threadTs || !filePath) return;\n          const { getPromptStateManager } = await import('../slack/prompt-state');\n          const mgr = getPromptStateManager();\n          mgr.update(channel, threadTs, { snapshotPath: filePath });\n          try {\n            ctx.logger.info(\n              `[slack-frontend] snapshot path attached to waiting prompt: ${filePath}`\n            );\n          } catch {}\n        } catch {}\n      })\n    );\n  }\n\n  stop(): void {\n    for (const s of this.subs) s.unsubscribe();\n    this.subs = [];\n  }\n\n  private getSlack(ctx: FrontendContext): any | undefined {\n    // Prefer injected fake client in tests: ctx.slack or ctx.slackClient\n    const injected = (ctx as any).slack || (ctx as any).slackClient;\n    if (injected) return injected;\n    // Else try to lazy-create from env or frontend config\n    try {\n      const token = (this.cfg as any)?.botToken || process.env.SLACK_BOT_TOKEN;\n      if (typeof token === 'string' && token.trim()) {\n        return new SlackClient(token.trim());\n      }\n    } catch {}\n    return undefined;\n  }\n\n  private getInboundSlackPayload(ctx: FrontendContext): any | null {\n    try {\n      const anyCfg: any = ctx.config || {};\n      const slackCfg: any = anyCfg.slack || {};\n      const endpoint: string = slackCfg.endpoint || '/bots/slack/support';\n      const payload: any = (ctx as any).webhookContext?.webhookData?.get(endpoint);\n      return payload || null;\n    } catch {\n      return null;\n    }\n  }\n\n  private getInboundSlackEvent(ctx: FrontendContext): { channel: string; ts: string } | null {\n    try {\n      const payload = this.getInboundSlackPayload(ctx);\n      const ev: any = payload?.event;\n      const channel = String(ev?.channel || '');\n      const ts = String(ev?.ts || ev?.event_ts || '');\n      if (channel && ts) return { channel, ts };\n    } catch {}\n    return null;\n  }\n\n  private async ensureAcknowledgement(ctx: FrontendContext): Promise<void> {\n    if (this.acked) return;\n    const ref = this.getInboundSlackEvent(ctx);\n    if (!ref) return;\n    const slack = this.getSlack(ctx);\n    if (!slack) return;\n    // Skip ack for bot messages to avoid loops\n    try {\n      const payload = this.getInboundSlackPayload(ctx);\n      const ev: any = payload?.event;\n      if (ev?.subtype === 'bot_message') return;\n      // If we can resolve bot user id, skip if the sender is the bot\n      try {\n        const botId = await slack.getBotUserId?.();\n        if (botId && ev?.user && String(ev.user) === String(botId)) return;\n      } catch {}\n    } catch {}\n    // Allow overrides via config\n    try {\n      const anyCfg: any = ctx.config || {};\n      const slackCfg: any = anyCfg.slack || {};\n      if (slackCfg?.reactions?.enabled === false) return;\n      this.ackName = slackCfg?.reactions?.ack || this.ackName;\n      this.doneName = slackCfg?.reactions?.done || this.doneName;\n    } catch {}\n    await slack.reactions.add({ channel: ref.channel, timestamp: ref.ts, name: this.ackName });\n    try {\n      ctx.logger.info(\n        `[slack-frontend] added acknowledgement reaction :${this.ackName}: channel=${ref.channel} ts=${ref.ts}`\n      );\n    } catch {}\n    this.acked = true;\n    this.ackRef = ref;\n  }\n\n  private async finalizeReactions(ctx: FrontendContext): Promise<void> {\n    if (!this.acked || !this.ackRef) return;\n    const slack = this.getSlack(ctx);\n    if (!slack) return;\n    try {\n      try {\n        await slack.reactions.remove({\n          channel: this.ackRef.channel,\n          timestamp: this.ackRef.ts,\n          name: this.ackName,\n        });\n      } catch {}\n      await slack.reactions.add({\n        channel: this.ackRef.channel,\n        timestamp: this.ackRef.ts,\n        name: this.doneName,\n      });\n      try {\n        ctx.logger.info(\n          `[slack-frontend] replaced acknowledgement with completion reaction :${this.doneName}: channel=${this.ackRef.channel} ts=${this.ackRef.ts}`\n        );\n      } catch {}\n    } finally {\n      // Reset for safety\n      this.acked = false;\n      this.ackRef = null;\n    }\n  }\n\n  /**\n   * Post direct replies into the originating Slack thread when appropriate.\n   * This is independent of summary messages and is intended for chat-style flows\n   * (e.g., AI answers and explicit chat/notify steps).\n   */\n  private async maybePostDirectReply(\n    ctx: FrontendContext,\n    checkId: string,\n    result: { output?: any; content?: string }\n  ): Promise<void> {\n    try {\n      const cfg: any = ctx.config || {};\n      const checkCfg: any = cfg.checks?.[checkId];\n      if (!checkCfg) return;\n\n      // Per-workflow / per-frontend flag to allow posting raw JSON\n      // outputs for AI steps (useful for debugging router outputs).\n      const slackRoot: any = (cfg as any).slack || {};\n      const showRawOutput =\n        slackRoot.show_raw_output === true || (this.cfg as any)?.showRawOutput === true;\n\n      const providerType = (checkCfg.type as string) || '';\n      const isAi = providerType === 'ai';\n      const isLogChat = providerType === 'log' && checkCfg.group === 'chat';\n      if (!isAi && !isLogChat) return;\n\n      // For AI checks, only post when using simple/unstructured schemas (or none).\n      if (isAi) {\n        const schema = checkCfg.schema;\n        // String schemas: allow only simple/plain ones\n        if (typeof schema === 'string') {\n          const simpleSchemas = ['code-review', 'markdown', 'text', 'plain'];\n          if (!simpleSchemas.includes(schema)) return;\n        }\n        // Object schemas (custom JSON): treat as structured; require output.text\n      }\n\n      const slack = this.getSlack(ctx);\n      if (!slack) return;\n\n      const payload = this.getInboundSlackPayload(ctx);\n      const ev: any = payload?.event;\n      const channel = String(ev?.channel || '');\n      const threadTs = String(ev?.thread_ts || ev?.ts || ev?.event_ts || '');\n      if (!channel || !threadTs) return;\n\n      // Prefer output.text; fall back to content ONLY for string/simple schemas.\n      const out: any = (result as any)?.output;\n      let text: string | undefined;\n      if (out && typeof out.text === 'string' && out.text.trim().length > 0) {\n        text = out.text.trim();\n      } else if (isAi && typeof checkCfg.schema === 'string') {\n        if (\n          typeof (result as any)?.content === 'string' &&\n          (result as any).content.trim().length > 0\n        ) {\n          text = (result as any).content.trim();\n        }\n      } else if (isAi && showRawOutput && out !== undefined) {\n        try {\n          text = JSON.stringify(out, null, 2);\n        } catch {\n          text = String(out);\n        }\n      }\n      if (!text) return;\n\n      const formattedText = formatSlackText(text);\n      await slack.chat.postMessage({ channel, text: formattedText, thread_ts: threadTs });\n      try {\n        ctx.logger.info(\n          `[slack-frontend] posted AI reply for ${checkId} to ${channel} thread=${threadTs}`\n        );\n      } catch {}\n    } catch {}\n  }\n}\n"],"mappings":"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","names":[]}