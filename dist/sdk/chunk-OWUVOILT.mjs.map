{"version":3,"sources":["../../src/dependency-resolver.ts","../../src/workflow-registry.ts"],"sourcesContent":["/**\n * Dependency resolution and execution ordering for checks\n */\n\nexport interface CheckNode {\n  id: string;\n  dependencies: string[];\n  dependents: string[];\n  depth: number;\n}\n\nexport interface ExecutionGroup {\n  /** Checks that can run in parallel */\n  parallel: string[];\n  /** Execution level/wave (0 = no dependencies, 1 = depends on level 0, etc.) */\n  level: number;\n}\n\nexport interface DependencyGraph {\n  nodes: Map<string, CheckNode>;\n  executionOrder: ExecutionGroup[];\n  hasCycles: boolean;\n  cycleNodes?: string[];\n}\n\nexport class DependencyResolver {\n  /**\n   * Build dependency graph from check dependencies\n   */\n  static buildDependencyGraph(checkDependencies: Record<string, string[]>): DependencyGraph {\n    const nodes = new Map<string, CheckNode>();\n\n    // Initialize all nodes\n    for (const checkId of Object.keys(checkDependencies)) {\n      nodes.set(checkId, {\n        id: checkId,\n        dependencies: checkDependencies[checkId] || [],\n        dependents: [],\n        depth: 0,\n      });\n    }\n\n    // Build bidirectional relationships\n    for (const [checkId, dependencies] of Object.entries(checkDependencies)) {\n      for (const depId of dependencies || []) {\n        if (!nodes.has(depId)) {\n          throw new Error(`Check \"${checkId}\" depends on \"${depId}\" but \"${depId}\" is not defined`);\n        }\n\n        const depNode = nodes.get(depId)!;\n        depNode.dependents.push(checkId);\n      }\n    }\n\n    // Detect cycles using DFS\n    const cycleDetection = this.detectCycles(nodes);\n    if (cycleDetection.hasCycles) {\n      return {\n        nodes,\n        executionOrder: [],\n        hasCycles: true,\n        cycleNodes: cycleDetection.cycleNodes,\n      };\n    }\n\n    // Calculate execution order using topological sort\n    const executionOrder = this.topologicalSort(nodes);\n\n    return {\n      nodes,\n      executionOrder,\n      hasCycles: false,\n    };\n  }\n\n  /**\n   * Detect cycles in the dependency graph using DFS\n   */\n  private static detectCycles(nodes: Map<string, CheckNode>): {\n    hasCycles: boolean;\n    cycleNodes?: string[];\n  } {\n    const visited = new Set<string>();\n    const recursionStack = new Set<string>();\n    const cycleNodes: string[] = [];\n\n    const dfs = (nodeId: string): boolean => {\n      if (recursionStack.has(nodeId)) {\n        cycleNodes.push(nodeId);\n        return true;\n      }\n      if (visited.has(nodeId)) {\n        return false;\n      }\n\n      visited.add(nodeId);\n      recursionStack.add(nodeId);\n\n      const node = nodes.get(nodeId);\n      if (node) {\n        for (const depId of node.dependencies) {\n          if (dfs(depId)) {\n            cycleNodes.push(nodeId);\n            return true;\n          }\n        }\n      }\n\n      recursionStack.delete(nodeId);\n      return false;\n    };\n\n    for (const nodeId of nodes.keys()) {\n      if (!visited.has(nodeId)) {\n        if (dfs(nodeId)) {\n          return { hasCycles: true, cycleNodes: [...new Set(cycleNodes)] };\n        }\n      }\n    }\n\n    return { hasCycles: false };\n  }\n\n  /**\n   * Perform topological sort to determine execution order\n   * Groups checks that can run in parallel at each level\n   */\n  private static topologicalSort(nodes: Map<string, CheckNode>): ExecutionGroup[] {\n    const remainingNodes = new Map(nodes);\n    const executionGroups: ExecutionGroup[] = [];\n    let level = 0;\n\n    while (remainingNodes.size > 0) {\n      // Find nodes with no remaining dependencies\n      const readyNodes: string[] = [];\n\n      for (const [nodeId, node] of remainingNodes.entries()) {\n        const unmetDependencies = node.dependencies.filter(depId => remainingNodes.has(depId));\n        if (unmetDependencies.length === 0) {\n          readyNodes.push(nodeId);\n        }\n      }\n\n      if (readyNodes.length === 0) {\n        // This shouldn't happen if cycle detection worked correctly\n        throw new Error('Unable to resolve dependencies - possible circular dependency detected');\n      }\n\n      // Add this group to execution order\n      executionGroups.push({\n        parallel: readyNodes,\n        level,\n      });\n\n      // Remove processed nodes\n      for (const nodeId of readyNodes) {\n        remainingNodes.delete(nodeId);\n      }\n\n      level++;\n    }\n\n    return executionGroups;\n  }\n\n  /**\n   * Validate that all dependencies exist\n   */\n  static validateDependencies(\n    checkIds: string[],\n    dependencies: Record<string, string[]>\n  ): { valid: boolean; errors: string[] } {\n    const errors: string[] = [];\n    const checkIdSet = new Set(checkIds);\n\n    for (const [checkId, deps] of Object.entries(dependencies)) {\n      if (!checkIdSet.has(checkId)) {\n        errors.push(`Check \"${checkId}\" is not in the list of available checks`);\n        continue;\n      }\n\n      for (const depId of deps || []) {\n        if (!checkIdSet.has(depId)) {\n          errors.push(`Check \"${checkId}\" depends on \"${depId}\" which is not available`);\n        }\n      }\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n    };\n  }\n\n  /**\n   * Get all transitive dependencies (ancestors) for a given check\n   * This returns all checks that must complete before the given check can run,\n   * not just the direct dependencies.\n   *\n   * For example, if A -> B -> C, then:\n   * - getAllDependencies(C) returns [A, B]\n   * - getAllDependencies(B) returns [A]\n   * - getAllDependencies(A) returns []\n   *\n   * @param checkId The check to find dependencies for\n   * @param nodes The dependency graph nodes\n   * @returns Array of all transitive dependency IDs\n   */\n  static getAllDependencies(checkId: string, nodes: Map<string, CheckNode>): string[] {\n    const allDeps = new Set<string>();\n    const visited = new Set<string>();\n\n    const collectDependencies = (currentId: string) => {\n      if (visited.has(currentId)) {\n        return;\n      }\n      visited.add(currentId);\n\n      const node = nodes.get(currentId);\n      if (!node) {\n        return;\n      }\n\n      // Add direct dependencies and recurse\n      for (const depId of node.dependencies) {\n        allDeps.add(depId);\n        collectDependencies(depId);\n      }\n    };\n\n    collectDependencies(checkId);\n    return Array.from(allDeps);\n  }\n\n  /**\n   * Get execution statistics for debugging\n   */\n  static getExecutionStats(graph: DependencyGraph): {\n    totalChecks: number;\n    parallelLevels: number;\n    maxParallelism: number;\n    averageParallelism: number;\n    checksWithDependencies: number;\n  } {\n    const totalChecks = graph.nodes.size;\n    const parallelLevels = graph.executionOrder.length;\n    const maxParallelism = Math.max(...graph.executionOrder.map(group => group.parallel.length));\n    const averageParallelism = totalChecks / parallelLevels;\n    const checksWithDependencies = Array.from(graph.nodes.values()).filter(\n      node => node.dependencies.length > 0\n    ).length;\n\n    return {\n      totalChecks,\n      parallelLevels,\n      maxParallelism,\n      averageParallelism,\n      checksWithDependencies,\n    };\n  }\n}\n","/**\n * Workflow registry for managing reusable workflow definitions\n */\n\nimport {\n  WorkflowDefinition,\n  WorkflowRegistryEntry,\n  WorkflowValidationResult,\n  WorkflowImportOptions,\n  JsonSchema,\n} from './types/workflow';\nimport { promises as fs } from 'fs';\nimport * as path from 'path';\nimport * as yaml from 'js-yaml';\nimport { logger } from './logger';\nimport { DependencyResolver } from './dependency-resolver';\nimport Ajv from 'ajv';\nimport addFormats from 'ajv-formats';\n\n/**\n * Registry for managing workflow definitions\n */\nexport class WorkflowRegistry {\n  private static instance: WorkflowRegistry;\n  private workflows: Map<string, WorkflowRegistryEntry> = new Map();\n  private ajv: Ajv;\n\n  private constructor() {\n    this.ajv = new Ajv({ allErrors: true, strict: false });\n    addFormats(this.ajv);\n  }\n\n  /**\n   * Get the singleton instance of the workflow registry\n   */\n  public static getInstance(): WorkflowRegistry {\n    if (!WorkflowRegistry.instance) {\n      WorkflowRegistry.instance = new WorkflowRegistry();\n    }\n    return WorkflowRegistry.instance;\n  }\n\n  /**\n   * Register a workflow definition\n   */\n  public register(\n    workflow: WorkflowDefinition,\n    source: string = 'inline',\n    options?: { override?: boolean }\n  ): WorkflowValidationResult {\n    // Validate the workflow\n    const validation = this.validateWorkflow(workflow);\n    if (!validation.valid) {\n      return validation;\n    }\n\n    // Check if workflow already exists\n    if (this.workflows.has(workflow.id) && !options?.override) {\n      return {\n        valid: false,\n        errors: [\n          {\n            path: 'id',\n            message: `Workflow with ID '${workflow.id}' already exists`,\n            value: workflow.id,\n          },\n        ],\n      };\n    }\n\n    // Register the workflow\n    this.workflows.set(workflow.id, {\n      definition: workflow,\n      source,\n      registeredAt: new Date(),\n      usage: {\n        count: 0,\n      },\n    });\n\n    logger.debug(`Registered workflow '${workflow.id}' from ${source}`);\n    return { valid: true };\n  }\n\n  /**\n   * Get a workflow by ID\n   */\n  public get(id: string): WorkflowDefinition | undefined {\n    const entry = this.workflows.get(id);\n    if (entry) {\n      // Update usage statistics\n      entry.usage = entry.usage || { count: 0 };\n      entry.usage.count++;\n      entry.usage.lastUsed = new Date();\n    }\n    return entry?.definition;\n  }\n\n  /**\n   * Check if a workflow exists\n   */\n  public has(id: string): boolean {\n    return this.workflows.has(id);\n  }\n\n  /**\n   * List all registered workflows\n   */\n  public list(): WorkflowDefinition[] {\n    return Array.from(this.workflows.values()).map(entry => entry.definition);\n  }\n\n  /**\n   * Get workflow metadata\n   */\n  public getMetadata(id: string): WorkflowRegistryEntry | undefined {\n    return this.workflows.get(id);\n  }\n\n  /**\n   * Remove a workflow from the registry\n   */\n  public unregister(id: string): boolean {\n    return this.workflows.delete(id);\n  }\n\n  /**\n   * Clear all workflows\n   */\n  public clear(): void {\n    this.workflows.clear();\n  }\n\n  /**\n   * Import workflows from a file or URL\n   */\n  public async import(\n    source: string,\n    options?: WorkflowImportOptions\n  ): Promise<WorkflowValidationResult[]> {\n    const results: WorkflowValidationResult[] = [];\n\n    try {\n      // Load the workflow file\n      const content = await this.loadWorkflowContent(source, options?.basePath);\n      const data = this.parseWorkflowContent(content, source);\n\n      // Handle both single workflow and multiple workflows\n      const workflows: WorkflowDefinition[] = Array.isArray(data) ? data : [data];\n\n      for (const workflow of workflows) {\n        // Validate if requested\n        if (options?.validate !== false) {\n          const validation = this.validateWorkflow(workflow);\n          if (!validation.valid) {\n            results.push(validation);\n            continue;\n          }\n\n          // Run custom validators if provided\n          if (options?.validators) {\n            for (const validator of options.validators) {\n              const customValidation = validator(workflow);\n              if (!customValidation.valid) {\n                results.push(customValidation);\n                continue;\n              }\n            }\n          }\n        }\n\n        // Strip out 'tests' field before registering - tests are only for standalone execution\n        const workflowWithoutTests = { ...workflow };\n        delete (workflowWithoutTests as any).tests;\n\n        // Register the workflow (without tests)\n        const result = this.register(workflowWithoutTests, source, { override: options?.override });\n        results.push(result);\n      }\n    } catch (error) {\n      results.push({\n        valid: false,\n        errors: [\n          {\n            path: 'source',\n            message: `Failed to import workflows from '${source}': ${error instanceof Error ? error.message : String(error)}`,\n            value: source,\n          },\n        ],\n      });\n    }\n\n    return results;\n  }\n\n  /**\n   * Import multiple workflow sources\n   */\n  public async importMany(\n    sources: string[],\n    options?: WorkflowImportOptions\n  ): Promise<Map<string, WorkflowValidationResult[]>> {\n    const results = new Map<string, WorkflowValidationResult[]>();\n\n    for (const source of sources) {\n      const importResults = await this.import(source, options);\n      results.set(source, importResults);\n    }\n\n    return results;\n  }\n\n  /**\n   * Validate a workflow definition\n   */\n  public validateWorkflow(workflow: WorkflowDefinition): WorkflowValidationResult {\n    const errors: Array<{ path: string; message: string; value?: unknown }> = [];\n    const warnings: Array<{ path: string; message: string }> = [];\n\n    // Validate required fields\n    if (!workflow.id) {\n      errors.push({ path: 'id', message: 'Workflow ID is required' });\n    }\n\n    if (!workflow.name) {\n      errors.push({ path: 'name', message: 'Workflow name is required' });\n    }\n\n    if (!workflow.steps || Object.keys(workflow.steps).length === 0) {\n      errors.push({ path: 'steps', message: 'Workflow must have at least one step' });\n    }\n\n    // Validate input parameters\n    if (workflow.inputs) {\n      for (let i = 0; i < workflow.inputs.length; i++) {\n        const input = workflow.inputs[i];\n        if (!input.name) {\n          errors.push({ path: `inputs[${i}].name`, message: 'Input parameter name is required' });\n        }\n        if (!input.schema) {\n          warnings.push({\n            path: `inputs[${i}].schema`,\n            message: 'Input parameter schema is recommended',\n          });\n        }\n      }\n    }\n\n    // Validate output parameters\n    if (workflow.outputs) {\n      for (let i = 0; i < workflow.outputs.length; i++) {\n        const output = workflow.outputs[i];\n        if (!output.name) {\n          errors.push({ path: `outputs[${i}].name`, message: 'Output parameter name is required' });\n        }\n        if (!output.value && !output.value_js) {\n          errors.push({\n            path: `outputs[${i}]`,\n            message: 'Output parameter must have either value or value_js',\n          });\n        }\n      }\n    }\n\n    // Validate steps\n    for (const [stepId, step] of Object.entries(workflow.steps || {})) {\n      // Validate step dependencies\n      if (step.depends_on) {\n        for (const dep of step.depends_on) {\n          if (!workflow.steps[dep]) {\n            errors.push({\n              path: `steps.${stepId}.depends_on`,\n              message: `Step '${stepId}' depends on non-existent step '${dep}'`,\n              value: dep,\n            });\n          }\n        }\n      }\n\n      // Validate input mappings\n      if (step.inputs) {\n        for (const [inputName, mapping] of Object.entries(step.inputs)) {\n          if (typeof mapping === 'object' && mapping !== null && 'source' in mapping) {\n            const typedMapping = mapping as any;\n            if (typedMapping.source === 'step' && !typedMapping.stepId) {\n              errors.push({\n                path: `steps.${stepId}.inputs.${inputName}`,\n                message: 'Step input mapping with source \"step\" must have stepId',\n              });\n            }\n            if (typedMapping.source === 'param') {\n              // Validate that the parameter exists\n              const paramExists = workflow.inputs?.some(p => p.name === typedMapping.value);\n              if (!paramExists) {\n                errors.push({\n                  path: `steps.${stepId}.inputs.${inputName}`,\n                  message: `Step input references non-existent parameter '${typedMapping.value}'`,\n                  value: typedMapping.value,\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Check for circular dependencies\n    const circularDeps = this.detectCircularDependencies(workflow);\n    if (circularDeps.length > 0) {\n      errors.push({\n        path: 'steps',\n        message: `Circular dependencies detected: ${circularDeps.join(' -> ')}`,\n      });\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors: errors.length > 0 ? errors : undefined,\n      warnings: warnings.length > 0 ? warnings : undefined,\n    };\n  }\n\n  /**\n   * Validate input values against workflow input schema\n   */\n  public validateInputs(\n    workflow: WorkflowDefinition,\n    inputs: Record<string, unknown>\n  ): WorkflowValidationResult {\n    const errors: Array<{ path: string; message: string; value?: unknown }> = [];\n\n    if (!workflow.inputs) {\n      return { valid: true };\n    }\n\n    // Check required inputs\n    for (const param of workflow.inputs) {\n      if (param.required !== false && !(param.name in inputs) && param.default === undefined) {\n        errors.push({\n          path: `inputs.${param.name}`,\n          message: `Required input '${param.name}' is missing`,\n        });\n      }\n    }\n\n    // Validate input schemas\n    for (const param of workflow.inputs) {\n      if (param.name in inputs && param.schema) {\n        const value = inputs[param.name];\n        const valid = this.validateAgainstSchema(value, param.schema);\n        if (!valid.valid) {\n          errors.push({\n            path: `inputs.${param.name}`,\n            message: valid.error || 'Invalid input value',\n            value,\n          });\n        }\n      }\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors: errors.length > 0 ? errors : undefined,\n    };\n  }\n\n  /**\n   * Load workflow content from file or URL\n   */\n  private async loadWorkflowContent(source: string, basePath?: string): Promise<string> {\n    // Handle URLs\n    if (source.startsWith('http://') || source.startsWith('https://')) {\n      const response = await fetch(source);\n      if (!response.ok) {\n        throw new Error(`Failed to fetch workflow from ${source}: ${response.statusText}`);\n      }\n      return await response.text();\n    }\n\n    // Handle file paths\n    const filePath = path.isAbsolute(source)\n      ? source\n      : path.resolve(basePath || process.cwd(), source);\n    return await fs.readFile(filePath, 'utf-8');\n  }\n\n  /**\n   * Parse workflow content (YAML or JSON)\n   */\n  private parseWorkflowContent(content: string, source: string): any {\n    // Try JSON first\n    try {\n      return JSON.parse(content);\n    } catch {\n      // Try YAML\n      try {\n        return yaml.load(content);\n      } catch (error) {\n        throw new Error(\n          `Failed to parse workflow file ${source}: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n  }\n\n  /**\n   * Detect circular dependencies in workflow steps using DependencyResolver\n   */\n  private detectCircularDependencies(workflow: WorkflowDefinition): string[] {\n    // Build dependency map\n    const dependencies: Record<string, string[]> = {};\n    for (const [stepId, step] of Object.entries(workflow.steps || {})) {\n      dependencies[stepId] = step.depends_on || [];\n    }\n\n    try {\n      // Use DependencyResolver to check for cycles\n      const graph = DependencyResolver.buildDependencyGraph(dependencies);\n\n      if (graph.hasCycles && graph.cycleNodes) {\n        return graph.cycleNodes;\n      }\n\n      return [];\n    } catch {\n      // DependencyResolver throws error for non-existent dependencies\n      // This should be caught by the dependency validation in validateWorkflow\n      // Return empty array here and let the validation handle it\n      return [];\n    }\n  }\n\n  /**\n   * Validate a value against a JSON schema\n   */\n  private validateAgainstSchema(\n    value: unknown,\n    schema: JsonSchema\n  ): { valid: boolean; error?: string } {\n    try {\n      const validate = this.ajv.compile(schema as any);\n      const valid = validate(value);\n      if (!valid) {\n        const errors = validate.errors\n          ?.map(e => `${e.instancePath || '/'}: ${e.message}`)\n          .join(', ');\n        return { valid: false, error: errors };\n      }\n      return { valid: true };\n    } catch (error) {\n      return { valid: false, error: error instanceof Error ? error.message : String(error) };\n    }\n  }\n}\n"],"mappings":"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","names":[]}