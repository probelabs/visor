{"version":3,"sources":["../../src/utils/author-permissions.ts","../../src/memory-store.ts","../../src/liquid-extensions.ts"],"sourcesContent":["/**\n * Author permission utilities for checking GitHub author associations\n *\n * GitHub provides author_association field with these values (in order of privilege):\n * - OWNER: Repository owner\n * - MEMBER: Organization member\n * - COLLABORATOR: Invited collaborator\n * - CONTRIBUTOR: Has contributed before\n * - FIRST_TIME_CONTRIBUTOR: First PR to this repo\n * - FIRST_TIMER: First GitHub contribution ever\n * - NONE: No association\n */\n\nexport type AuthorAssociation =\n  | 'OWNER'\n  | 'MEMBER'\n  | 'COLLABORATOR'\n  | 'CONTRIBUTOR'\n  | 'FIRST_TIME_CONTRIBUTOR'\n  | 'FIRST_TIMER'\n  | 'NONE';\n\n/**\n * Permission hierarchy (from highest to lowest privilege)\n */\nconst PERMISSION_HIERARCHY: AuthorAssociation[] = [\n  'OWNER',\n  'MEMBER',\n  'COLLABORATOR',\n  'CONTRIBUTOR',\n  'FIRST_TIME_CONTRIBUTOR',\n  'FIRST_TIMER',\n  'NONE',\n];\n\n/**\n * Get permission level (0 = highest, higher number = lower privilege)\n */\nfunction getPermissionLevel(association: string | undefined): number {\n  if (!association) return PERMISSION_HIERARCHY.length; // Treat unknown as lowest\n  const index = PERMISSION_HIERARCHY.indexOf(association.toUpperCase() as AuthorAssociation);\n  return index === -1 ? PERMISSION_HIERARCHY.length : index;\n}\n\n/**\n * Check if author has at least the specified permission level (>= logic)\n *\n * @param authorAssociation - The author's association from GitHub API\n * @param minPermission - Minimum required permission level\n * @param isLocalMode - Whether running in local/CLI mode (defaults to true for local runs)\n * @returns true if author has at least the specified permission level\n *\n * @example\n * hasMinPermission('MEMBER', 'MEMBER') // true (exact match)\n * hasMinPermission('OWNER', 'MEMBER') // true (owner >= member)\n * hasMinPermission('COLLABORATOR', 'MEMBER') // false (collaborator < member)\n * hasMinPermission(undefined, 'OWNER', true) // true (local mode)\n */\nexport function hasMinPermission(\n  authorAssociation: string | undefined,\n  minPermission: AuthorAssociation,\n  isLocalMode: boolean = false\n): boolean {\n  // In local mode (not GitHub Actions), treat as owner\n  if (isLocalMode) {\n    return true;\n  }\n\n  const authorLevel = getPermissionLevel(authorAssociation);\n  const minLevel = getPermissionLevel(minPermission);\n\n  // Lower number = higher privilege, so author must have equal or lower number\n  return authorLevel <= minLevel;\n}\n\n/**\n * Check if author is exactly the repository owner\n */\nexport function isOwner(\n  authorAssociation: string | undefined,\n  isLocalMode: boolean = false\n): boolean {\n  if (isLocalMode) return true;\n  return authorAssociation?.toUpperCase() === 'OWNER';\n}\n\n/**\n * Check if author is an organization member or owner\n */\nexport function isMember(\n  authorAssociation: string | undefined,\n  isLocalMode: boolean = false\n): boolean {\n  if (isLocalMode) return true;\n  return hasMinPermission(authorAssociation, 'MEMBER', isLocalMode);\n}\n\n/**\n * Check if author is a collaborator (or higher)\n */\nexport function isCollaborator(\n  authorAssociation: string | undefined,\n  isLocalMode: boolean = false\n): boolean {\n  if (isLocalMode) return true;\n  return hasMinPermission(authorAssociation, 'COLLABORATOR', isLocalMode);\n}\n\n/**\n * Check if author is a contributor (has contributed before)\n */\nexport function isContributor(\n  authorAssociation: string | undefined,\n  isLocalMode: boolean = false\n): boolean {\n  if (isLocalMode) return true;\n  return hasMinPermission(authorAssociation, 'CONTRIBUTOR', isLocalMode);\n}\n\n/**\n * Check if author is a first-time contributor (to this repo or GitHub)\n */\nexport function isFirstTimer(\n  authorAssociation: string | undefined,\n  isLocalMode: boolean = false\n): boolean {\n  if (isLocalMode) return false; // In local mode, not a first-timer\n  const assoc = authorAssociation?.toUpperCase();\n  return assoc === 'FIRST_TIME_CONTRIBUTOR' || assoc === 'FIRST_TIMER';\n}\n\n/**\n * Create permission helper functions bound to a specific author association\n * This is used to inject functions into JavaScript execution contexts\n *\n * @param authorAssociation - The author's association from PR data\n * @param isLocalMode - Whether running in local/CLI mode\n */\nexport function createPermissionHelpers(\n  authorAssociation: string | undefined,\n  isLocalMode: boolean = false\n) {\n  return {\n    hasMinPermission: (minPermission: AuthorAssociation) =>\n      hasMinPermission(authorAssociation, minPermission, isLocalMode),\n    isOwner: () => isOwner(authorAssociation, isLocalMode),\n    isMember: () => isMember(authorAssociation, isLocalMode),\n    isCollaborator: () => isCollaborator(authorAssociation, isLocalMode),\n    isContributor: () => isContributor(authorAssociation, isLocalMode),\n    isFirstTimer: () => isFirstTimer(authorAssociation, isLocalMode),\n  };\n}\n\n/**\n * Determine if we're running in local mode (not GitHub Actions)\n */\nexport function detectLocalMode(): boolean {\n  return !process.env.GITHUB_ACTIONS;\n}\n\n/**\n * Resolve the most relevant GitHub author association from an event context.\n * Prefers commenter association for issue_comment events, then issue/PR author,\n * and finally falls back to the provided default association.\n */\nexport function resolveAssociationFromEvent(\n  eventContext: any | undefined,\n  fallback?: string\n): string | undefined {\n  try {\n    const ec = eventContext || {};\n    return (\n      ec?.comment?.author_association ||\n      ec?.issue?.author_association ||\n      ec?.pull_request?.author_association ||\n      fallback\n    );\n  } catch {\n    return fallback;\n  }\n}\n","import fs from 'fs/promises';\nimport path from 'path';\nimport { MemoryConfig } from './types/config';\nimport { logger } from './logger';\n\n/**\n * Memory store for persistent key-value storage across checks\n * Supports namespaces for isolation and both in-memory and file-based persistence\n */\nexport class MemoryStore {\n  private static instance: MemoryStore;\n  private data: Map<string, Map<string, unknown>>; // namespace -> key -> value\n  private config: MemoryConfig;\n  private initialized = false;\n\n  private constructor(config?: MemoryConfig) {\n    this.data = new Map();\n    this.config = this.normalizeConfig(config);\n  }\n\n  /**\n   * Get singleton instance\n   */\n  static getInstance(config?: MemoryConfig): MemoryStore {\n    if (!MemoryStore.instance) {\n      MemoryStore.instance = new MemoryStore(config);\n    } else if (config && !MemoryStore.instance.initialized) {\n      // Update config if not yet initialized\n      MemoryStore.instance.config = MemoryStore.instance.normalizeConfig(config);\n    }\n    return MemoryStore.instance;\n  }\n\n  /**\n   * Reset singleton instance (for testing)\n   */\n  static resetInstance(): void {\n    MemoryStore.instance = undefined!;\n  }\n\n  /**\n   * Initialize memory store (load from file if configured)\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      return;\n    }\n\n    // Auto-load if file storage is configured\n    if (this.config.storage === 'file' && this.config.auto_load && this.config.file) {\n      try {\n        await this.load();\n        logger.debug(`Memory store loaded from ${this.config.file}`);\n      } catch (error) {\n        // If file doesn't exist, that's ok - we'll create it on first save\n        if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {\n          logger.warn(\n            `Failed to load memory store from ${this.config.file}: ${\n              error instanceof Error ? error.message : 'Unknown error'\n            }`\n          );\n        }\n      }\n    }\n\n    this.initialized = true;\n  }\n\n  /**\n   * Normalize and apply defaults to config\n   */\n  private normalizeConfig(config?: MemoryConfig): MemoryConfig {\n    const storage = config?.storage || 'memory';\n    return {\n      storage,\n      format: config?.format || 'json',\n      file: config?.file,\n      namespace: config?.namespace || 'default',\n      auto_load: config?.auto_load !== false,\n      auto_save: config?.auto_save !== false,\n    };\n  }\n\n  /**\n   * Get the default namespace\n   */\n  getDefaultNamespace(): string {\n    return this.config.namespace || 'default';\n  }\n\n  /**\n   * Get a value from memory\n   */\n  get(key: string, namespace?: string): unknown {\n    const ns = namespace || this.getDefaultNamespace();\n    const nsData = this.data.get(ns);\n    return nsData?.get(key);\n  }\n\n  /**\n   * Check if a key exists in memory\n   */\n  has(key: string, namespace?: string): boolean {\n    const ns = namespace || this.getDefaultNamespace();\n    const nsData = this.data.get(ns);\n    return nsData?.has(key) || false;\n  }\n\n  /**\n   * Set a value in memory (override existing)\n   */\n  async set(key: string, value: unknown, namespace?: string): Promise<void> {\n    const ns = namespace || this.getDefaultNamespace();\n\n    // Ensure namespace exists\n    if (!this.data.has(ns)) {\n      this.data.set(ns, new Map());\n    }\n\n    const nsData = this.data.get(ns)!;\n    nsData.set(key, value);\n\n    try {\n      if (process.env.VISOR_DEBUG === 'true' || process.env.JEST_WORKER_ID !== undefined) {\n        if (ns === 'fact-validation' && (key === 'total_validations' || key === 'all_valid')) {\n          console.log('[MemoryStore] SET ' + ns + '.' + key + ' = ' + JSON.stringify(value));\n        }\n      }\n    } catch {}\n\n    try {\n      if (process.env.VISOR_DEBUG === 'true' || process.env.JEST_WORKER_ID !== undefined) {\n        if (ns === 'fact-validation' && (key === 'total_validations' || key === 'all_valid')) {\n          console.log();\n        }\n      }\n    } catch {}\n\n    // Auto-save if configured\n    if (this.config.storage === 'file' && this.config.auto_save) {\n      await this.save();\n    }\n  }\n\n  /**\n   * Append a value to an array in memory\n   * If key doesn't exist, creates a new array\n   * If key exists but is not an array, converts it to an array\n   */\n  async append(key: string, value: unknown, namespace?: string): Promise<void> {\n    const ns = namespace || this.getDefaultNamespace();\n    const existing = this.get(key, ns);\n\n    let newValue: unknown[];\n    if (existing === undefined) {\n      // Create new array\n      newValue = [value];\n    } else if (Array.isArray(existing)) {\n      // Append to existing array\n      newValue = [...existing, value];\n    } else {\n      // Convert single value to array with both values\n      newValue = [existing, value];\n    }\n\n    await this.set(key, newValue, ns);\n  }\n\n  /**\n   * Increment a numeric value in memory\n   * If key doesn't exist, initializes to 0 before incrementing\n   * If key exists but is not a number, throws an error\n   */\n  async increment(key: string, amount = 1, namespace?: string): Promise<number> {\n    const ns = namespace || this.getDefaultNamespace();\n    const existing = this.get(key, ns);\n\n    let newValue: number;\n    if (existing === undefined || existing === null) {\n      // Initialize to 0 and then increment\n      newValue = amount;\n    } else if (typeof existing === 'number') {\n      // Increment existing number\n      newValue = existing + amount;\n    } else {\n      throw new Error(\n        `Cannot increment non-numeric value at key '${key}' (type: ${typeof existing})`\n      );\n    }\n\n    await this.set(key, newValue, ns);\n    return newValue;\n  }\n\n  /**\n   * Delete a key from memory\n   */\n  async delete(key: string, namespace?: string): Promise<boolean> {\n    const ns = namespace || this.getDefaultNamespace();\n    const nsData = this.data.get(ns);\n\n    if (!nsData) {\n      return false;\n    }\n\n    const deleted = nsData.delete(key);\n\n    // Auto-save if configured\n    if (deleted && this.config.storage === 'file' && this.config.auto_save) {\n      await this.save();\n    }\n\n    return deleted;\n  }\n\n  /**\n   * Clear all keys in a namespace (or all namespaces if none specified)\n   */\n  async clear(namespace?: string): Promise<void> {\n    if (namespace) {\n      // Clear specific namespace\n      this.data.delete(namespace);\n    } else {\n      // Clear all namespaces\n      this.data.clear();\n    }\n\n    // Auto-save if configured\n    if (this.config.storage === 'file' && this.config.auto_save) {\n      await this.save();\n    }\n  }\n\n  /**\n   * List all keys in a namespace\n   */\n  list(namespace?: string): string[] {\n    const ns = namespace || this.getDefaultNamespace();\n    const nsData = this.data.get(ns);\n    return nsData ? Array.from(nsData.keys()) : [];\n  }\n\n  /**\n   * List all namespaces\n   */\n  listNamespaces(): string[] {\n    return Array.from(this.data.keys());\n  }\n\n  /**\n   * Get all data in a namespace\n   */\n  getAll(namespace?: string): Record<string, unknown> {\n    const ns = namespace || this.getDefaultNamespace();\n    const nsData = this.data.get(ns);\n    if (!nsData) {\n      return {};\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const [key, value] of nsData.entries()) {\n      result[key] = value;\n    }\n    return result;\n  }\n\n  /**\n   * Load data from file\n   */\n  async load(): Promise<void> {\n    if (!this.config.file) {\n      throw new Error('No file path configured for memory store');\n    }\n\n    const filePath = path.resolve(process.cwd(), this.config.file);\n    const content = await fs.readFile(filePath, 'utf-8');\n\n    if (this.config.format === 'json') {\n      await this.loadFromJson(content);\n    } else if (this.config.format === 'csv') {\n      await this.loadFromCsv(content);\n    } else {\n      throw new Error(`Unsupported format: ${this.config.format}`);\n    }\n  }\n\n  /**\n   * Save data to file\n   */\n  async save(): Promise<void> {\n    if (!this.config.file) {\n      throw new Error('No file path configured for memory store');\n    }\n\n    const filePath = path.resolve(process.cwd(), this.config.file);\n\n    // Ensure directory exists\n    const dir = path.dirname(filePath);\n    await fs.mkdir(dir, { recursive: true });\n\n    let content: string;\n    if (this.config.format === 'json') {\n      content = this.saveToJson();\n    } else if (this.config.format === 'csv') {\n      content = this.saveToCsv();\n    } else {\n      throw new Error(`Unsupported format: ${this.config.format}`);\n    }\n\n    await fs.writeFile(filePath, content, 'utf-8');\n  }\n\n  /**\n   * Load data from JSON format\n   */\n  private async loadFromJson(content: string): Promise<void> {\n    const data = JSON.parse(content);\n\n    // Clear existing data\n    this.data.clear();\n\n    // Load namespaces\n    for (const [namespace, nsData] of Object.entries(data)) {\n      if (typeof nsData === 'object' && nsData !== null && !Array.isArray(nsData)) {\n        const nsMap = new Map<string, unknown>();\n        for (const [key, value] of Object.entries(nsData)) {\n          nsMap.set(key, value);\n        }\n        this.data.set(namespace, nsMap);\n      }\n    }\n  }\n\n  /**\n   * Save data to JSON format\n   */\n  private saveToJson(): string {\n    const result: Record<string, Record<string, unknown>> = {};\n\n    for (const [namespace, nsData] of this.data.entries()) {\n      const nsObj: Record<string, unknown> = {};\n      for (const [key, value] of nsData.entries()) {\n        nsObj[key] = value;\n      }\n      result[namespace] = nsObj;\n    }\n\n    return JSON.stringify(result, null, 2);\n  }\n\n  /**\n   * Load data from CSV format\n   * CSV format: namespace,key,value,type\n   */\n  private async loadFromCsv(content: string): Promise<void> {\n    const lines = content.split('\\n').filter(line => line.trim());\n\n    // Skip header if present\n    let startIndex = 0;\n    if (lines[0]?.startsWith('namespace,')) {\n      startIndex = 1;\n    }\n\n    // Clear existing data\n    this.data.clear();\n\n    // Track arrays (keys that have multiple values)\n    const arrays = new Map<string, Map<string, unknown[]>>(); // namespace -> key -> values[]\n\n    for (let i = startIndex; i < lines.length; i++) {\n      const line = lines[i];\n      const parts = this.parseCsvLine(line);\n\n      if (parts.length < 3) {\n        logger.warn(`Invalid CSV line ${i + 1}: ${line}`);\n        continue;\n      }\n\n      const [namespace, key, valueStr, typeStr] = parts;\n      const value = this.parseCsvValue(valueStr, typeStr);\n\n      // Ensure namespace exists in data\n      if (!this.data.has(namespace)) {\n        this.data.set(namespace, new Map());\n        arrays.set(namespace, new Map());\n      }\n\n      const nsData = this.data.get(namespace)!;\n      const nsArrays = arrays.get(namespace)!;\n\n      // Check if this is a duplicate key (array)\n      if (nsData.has(key)) {\n        // Convert to array if not already\n        if (!nsArrays.has(key)) {\n          const existingValue = nsData.get(key);\n          nsArrays.set(key, [existingValue]);\n        }\n        nsArrays.get(key)!.push(value);\n        nsData.set(key, nsArrays.get(key)!);\n      } else {\n        // First occurrence\n        nsData.set(key, value);\n      }\n    }\n  }\n\n  /**\n   * Save data to CSV format\n   */\n  private saveToCsv(): string {\n    const lines: string[] = ['namespace,key,value,type'];\n\n    for (const [namespace, nsData] of this.data.entries()) {\n      for (const [key, value] of nsData.entries()) {\n        if (Array.isArray(value)) {\n          // Multiple rows for arrays\n          for (const item of value) {\n            lines.push(this.formatCsvLine(namespace, key, item));\n          }\n        } else {\n          // Single row\n          lines.push(this.formatCsvLine(namespace, key, value));\n        }\n      }\n    }\n\n    return lines.join('\\n') + '\\n';\n  }\n\n  /**\n   * Parse a CSV line, handling quoted values with commas\n   */\n  private parseCsvLine(line: string): string[] {\n    const parts: string[] = [];\n    let current = '';\n    let inQuotes = false;\n\n    for (let i = 0; i < line.length; i++) {\n      const char = line[i];\n\n      if (char === '\"') {\n        if (inQuotes && line[i + 1] === '\"') {\n          // Escaped quote\n          current += '\"';\n          i++;\n        } else {\n          // Toggle quotes\n          inQuotes = !inQuotes;\n        }\n      } else if (char === ',' && !inQuotes) {\n        // End of field\n        parts.push(current);\n        current = '';\n      } else {\n        current += char;\n      }\n    }\n\n    // Add last field\n    parts.push(current);\n\n    return parts;\n  }\n\n  /**\n   * Format a CSV line with proper escaping\n   */\n  private formatCsvLine(namespace: string, key: string, value: unknown): string {\n    const type = this.getValueType(value);\n    const valueStr = this.formatCsvValue(value);\n\n    return `${this.escapeCsv(namespace)},${this.escapeCsv(key)},${valueStr},${type}`;\n  }\n\n  /**\n   * Escape a CSV value\n   */\n  private escapeCsv(value: string): string {\n    if (value.includes(',') || value.includes('\"') || value.includes('\\n')) {\n      return `\"${value.replace(/\"/g, '\"\"')}\"`;\n    }\n    return value;\n  }\n\n  /**\n   * Format a value for CSV storage\n   */\n  private formatCsvValue(value: unknown): string {\n    if (value === null) {\n      return '\"\"';\n    }\n    if (value === undefined) {\n      return '\"\"';\n    }\n    if (typeof value === 'string') {\n      return this.escapeCsv(value);\n    }\n    if (typeof value === 'number' || typeof value === 'boolean') {\n      return this.escapeCsv(String(value));\n    }\n    // Objects and arrays are serialized as JSON\n    return this.escapeCsv(JSON.stringify(value));\n  }\n\n  /**\n   * Parse a CSV value based on its type\n   */\n  private parseCsvValue(valueStr: string, typeStr?: string): unknown {\n    if (!typeStr || typeStr === 'string') {\n      return valueStr;\n    }\n    if (typeStr === 'number') {\n      return Number(valueStr);\n    }\n    if (typeStr === 'boolean') {\n      return valueStr === 'true';\n    }\n    if (typeStr === 'object' || typeStr === 'array') {\n      try {\n        return JSON.parse(valueStr);\n      } catch {\n        return valueStr;\n      }\n    }\n    return valueStr;\n  }\n\n  /**\n   * Get the type of a value for CSV storage\n   */\n  private getValueType(value: unknown): string {\n    if (value === null || value === undefined) {\n      return 'string';\n    }\n    if (typeof value === 'number') {\n      return 'number';\n    }\n    if (typeof value === 'boolean') {\n      return 'boolean';\n    }\n    if (Array.isArray(value)) {\n      return 'array';\n    }\n    if (typeof value === 'object') {\n      return 'object';\n    }\n    return 'string';\n  }\n\n  /**\n   * Get the current configuration\n   */\n  getConfig(): MemoryConfig {\n    return { ...this.config };\n  }\n}\n","import { Liquid, TagToken, Context, TopLevelToken, Tag, Value, Emitter } from 'liquidjs';\nimport { AsyncLocalStorage } from 'async_hooks';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport {\n  hasMinPermission,\n  isOwner,\n  isMember,\n  isCollaborator,\n  isContributor,\n  isFirstTimer,\n  detectLocalMode,\n} from './utils/author-permissions';\nimport { MemoryStore } from './memory-store';\n\n/**\n * Sanitize label strings to only allow [A-Za-z0-9:/\\- ] characters (including spaces and hyphens)\n * @param value - Label value to sanitize\n * @returns Sanitized label string\n */\nexport function sanitizeLabel(value: unknown): string {\n  if (value == null) return '';\n  const s = String(value);\n  // Keep only alphanumerics, colon, slash, hyphen, and space; collapse repeated slashes and trim\n  return s\n    .replace(/[^A-Za-z0-9:\\/\\- ]/g, '')\n    .replace(/\\/{2,}/g, '/')\n    .trim();\n}\n\n/**\n * Sanitize an array of labels\n * @param labels - Array of label values\n * @returns Array of sanitized, non-empty label strings\n */\nexport function sanitizeLabelList(labels: unknown): string[] {\n  if (!Array.isArray(labels)) return [];\n  return (labels as unknown[]).map(v => sanitizeLabel(v)).filter(s => s.length > 0);\n}\n\n/**\n * Custom ReadFile tag for Liquid templates\n * Usage: {% readfile \"path/to/file.txt\" %}\n * or with variable: {% readfile filename %}\n */\nexport class ReadFileTag extends Tag {\n  private filepath: Value;\n\n  constructor(token: TagToken, remainTokens: TopLevelToken[], liquid: Liquid) {\n    super(token, remainTokens, liquid);\n    this.filepath = new Value(token.args, liquid);\n  }\n\n  *render(ctx: Context, emitter: Emitter): Generator<unknown, void, unknown> {\n    const filePath = yield this.filepath.value(ctx, false);\n\n    // Validate the path\n    if (!filePath || typeof filePath !== 'string') {\n      emitter.write('[Error: Invalid file path]');\n      return;\n    }\n\n    // Security: Resolve path relative to project root to prevent directory traversal\n    const projectRoot = process.cwd();\n    const resolvedPath = path.resolve(projectRoot, filePath.toString());\n\n    // Ensure the resolved path is within the project directory\n    if (!resolvedPath.startsWith(projectRoot)) {\n      emitter.write('[Error: File path escapes project directory]');\n      return;\n    }\n\n    // Read the file content\n    try {\n      const content = yield fs.readFile(resolvedPath, 'utf-8');\n      emitter.write(content);\n    } catch (error) {\n      // Handle file read errors gracefully\n      const errorMessage =\n        error instanceof Error\n          ? error.message\n          : (error as NodeJS.ErrnoException)?.code || 'Unknown error';\n      emitter.write(`[Error reading file: ${errorMessage}]`);\n    }\n  }\n}\n\n// Async-local permissions context for filters (per-render)\nconst permissionsALS = new AsyncLocalStorage<{ authorAssociation?: string }>();\n\nexport async function withPermissionsContext<T>(\n  ctx: { authorAssociation?: string },\n  fn: () => Promise<T>\n): Promise<T> {\n  return await permissionsALS.run(ctx, fn as any);\n}\n\n/**\n * Configure a Liquid instance with custom extensions\n */\nexport function configureLiquidWithExtensions(liquid: Liquid): void {\n  // Register the readfile tag\n  liquid.registerTag('readfile', ReadFileTag);\n\n  // Register parse_json filter to parse JSON strings into objects\n  liquid.registerFilter('parse_json', (value: string) => {\n    if (typeof value !== 'string') {\n      return value;\n    }\n    try {\n      return JSON.parse(value);\n    } catch {\n      // Return original value if parsing fails\n      return value;\n    }\n  });\n\n  // Register to_json filter as alias for json (for consistency)\n  liquid.registerFilter('to_json', (value: unknown) => {\n    try {\n      return JSON.stringify(value);\n    } catch {\n      return '[Error: Unable to serialize to JSON]';\n    }\n  });\n\n  // Sanitize a label to allowed characters only: [A-Za-z0-9:/]\n  liquid.registerFilter('safe_label', (value: unknown) => sanitizeLabel(value));\n\n  // Sanitize an array of labels\n  liquid.registerFilter('safe_label_list', (value: unknown) => sanitizeLabelList(value));\n\n  // Convert literal escape sequences (e.g., \"\\n\") into actual newlines\n  liquid.registerFilter('unescape_newlines', (value: unknown) => {\n    if (value == null) return '';\n    const s = String(value);\n    return s.replace(/\\\\n/g, '\\n').replace(/\\\\r/g, '\\r').replace(/\\\\t/g, '\\t');\n  });\n\n  // Register author permission filters (from main)\n  // These filters check the author's permission level; detect local mode for tests\n  const isLocal = detectLocalMode();\n\n  const resolveAssoc = (val: unknown): string | undefined => {\n    if (typeof val === 'string' && val.length > 0) return val;\n    const store = permissionsALS.getStore();\n    return store?.authorAssociation;\n  };\n\n  liquid.registerFilter('has_min_permission', (authorAssociation: unknown, level: string) => {\n    return hasMinPermission(resolveAssoc(authorAssociation), level as any, isLocal);\n  });\n\n  liquid.registerFilter('is_owner', (authorAssociation: unknown) => {\n    return isOwner(resolveAssoc(authorAssociation), isLocal);\n  });\n\n  liquid.registerFilter('is_member', (authorAssociation: unknown) => {\n    return isMember(resolveAssoc(authorAssociation), isLocal);\n  });\n\n  liquid.registerFilter('is_collaborator', (authorAssociation: unknown) => {\n    return isCollaborator(resolveAssoc(authorAssociation), isLocal);\n  });\n\n  liquid.registerFilter('is_contributor', (authorAssociation: unknown) => {\n    return isContributor(resolveAssoc(authorAssociation), isLocal);\n  });\n\n  liquid.registerFilter('is_first_timer', (authorAssociation: unknown) => {\n    return isFirstTimer(resolveAssoc(authorAssociation), isLocal);\n  });\n\n  // Register memory filters for accessing memory store\n  const memoryStore = MemoryStore.getInstance();\n\n  liquid.registerFilter('memory_get', (key: string, namespace?: string) => {\n    if (typeof key !== 'string') {\n      return undefined;\n    }\n    return memoryStore.get(key, namespace);\n  });\n\n  liquid.registerFilter('memory_has', (key: string, namespace?: string) => {\n    if (typeof key !== 'string') {\n      return false;\n    }\n    const has = memoryStore.has(key, namespace);\n    try {\n      if (process.env.VISOR_DEBUG === 'true' && key === 'fact_validation_issues') {\n        console.error(\n          `[liquid] memory_has('${key}', ns='${namespace || memoryStore.getDefaultNamespace()}') => ${String(\n            has\n          )}`\n        );\n      }\n    } catch {}\n    return has;\n  });\n\n  liquid.registerFilter('memory_list', (namespace?: string) => {\n    return memoryStore.list(namespace);\n  });\n\n  // Generic helpers to radically simplify templates\n\n  // get: safe nested access using dot-path (e.g., obj | get: 'a.b.c')\n  liquid.registerFilter('get', (obj: any, pathExpr: unknown) => {\n    if (obj == null) return undefined;\n    const path = typeof pathExpr === 'string' ? pathExpr : String(pathExpr || '');\n    if (!path) return obj;\n    const parts = path.split('.');\n    let cur: any = obj;\n    for (const p of parts) {\n      if (cur == null) return undefined;\n      cur = cur[p as keyof typeof cur];\n    }\n    return cur;\n  });\n\n  // not_empty: true when value is a non-empty array/string/object with keys\n  liquid.registerFilter('not_empty', (v: unknown) => {\n    if (Array.isArray(v)) return v.length > 0;\n    if (typeof v === 'string') return v.length > 0;\n    if (v && typeof v === 'object') return Object.keys(v as object).length > 0;\n    return false;\n  });\n\n  // coalesce: pick first argument (value or candidates) that is a non-empty array/object/string\n  // Usage: a | coalesce: b, c, d\n  liquid.registerFilter('coalesce', (first: unknown, ...rest: unknown[]) => {\n    const all = [first, ...rest];\n    for (const v of all) {\n      if (Array.isArray(v) && v.length > 0) return v;\n      if (typeof v === 'string' && v.length > 0) return v;\n      if (v && typeof v === 'object' && Object.keys(v as object).length > 0) return v;\n    }\n    return Array.isArray(first) ? [] : (first ?? undefined);\n  });\n\n  // where_exp: generic expression-based filter (Shopify-style)\n  // Usage: array | where_exp: 'i', 'i.is_valid != true and i.confidence != \"high\"'\n  liquid.registerFilter('where_exp', (items: unknown, varName: string, expr: string) => {\n    const arr = Array.isArray(items) ? (items as any[]) : [];\n    const name = typeof varName === 'string' && varName.trim() ? varName.trim() : 'i';\n    const body = String(expr || '');\n    try {\n      // Build a tiny predicate; expose only item, idx, arr\n\n      const fn = new Function(\n        name,\n        'idx',\n        'arr',\n        `try { return (${body}); } catch { return false; }`\n      );\n      const out: any[] = [];\n      for (let idx = 0; idx < arr.length; idx++) {\n        const i = arr[idx];\n        let ok = false;\n        try {\n          ok = !!(fn as any)(i, idx, arr);\n        } catch {\n          ok = false;\n        }\n        if (ok) out.push(i);\n      }\n      return out;\n    } catch {\n      return [];\n    }\n  });\n\n  // Removed: merge_sort_by filter (unused)\n}\n\n/**\n * Create a new Liquid instance with custom extensions\n */\nexport function createExtendedLiquid(options: Record<string, unknown> = {}): Liquid {\n  const liquid = new Liquid({\n    cache: false,\n    strictFilters: false,\n    strictVariables: false,\n    ...options,\n  });\n\n  configureLiquidWithExtensions(liquid);\n  return liquid;\n}\n"],"mappings":"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","names":["fs","path"]}