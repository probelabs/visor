{"version":3,"sources":["../../src/github-comments.ts","../../src/footer.ts","../../src/reviewer.ts"],"sourcesContent":["import { Octokit } from '@octokit/rest';\nimport { v4 as uuidv4 } from 'uuid';\nimport { logger } from './logger';\nimport { generateFooter } from './footer';\n\nexport interface Comment {\n  id: number;\n  body: string;\n  user: {\n    login: string;\n  };\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface RetryConfig {\n  maxRetries: number;\n  baseDelay: number;\n  maxDelay: number;\n  backoffFactor: number;\n}\n\nexport interface CommentMetadata {\n  commentId: string;\n  lastUpdated: string;\n  triggeredBy: string;\n  commitSha?: string;\n}\n\ninterface GitHubApiError {\n  status?: number;\n  response?: {\n    status?: number;\n    data?: {\n      message?: string;\n    };\n  };\n}\n\n/**\n * Manages GitHub PR comments with dynamic updating capabilities\n */\nexport class CommentManager {\n  private octokit: Octokit;\n  private retryConfig: RetryConfig;\n\n  constructor(octokit: Octokit, retryConfig?: Partial<RetryConfig>) {\n    this.octokit = octokit;\n    this.retryConfig = {\n      maxRetries: 3,\n      baseDelay: 1000,\n      maxDelay: 10000,\n      backoffFactor: 2,\n      ...retryConfig,\n    };\n  }\n\n  /**\n   * Find existing Visor comment by comment ID marker\n   */\n  public async findVisorComment(\n    owner: string,\n    repo: string,\n    prNumber: number,\n    commentId?: string\n  ): Promise<Comment | null> {\n    try {\n      const comments = await this.octokit.rest.issues.listComments({\n        owner,\n        repo,\n        issue_number: prNumber,\n        per_page: 100, // GitHub default max\n      });\n\n      for (const comment of comments.data) {\n        if (comment.body && this.isVisorComment(comment.body, commentId)) {\n          return comment as Comment;\n        }\n      }\n\n      return null;\n    } catch (error) {\n      if (\n        this.isRateLimitError(\n          error as { status?: number; response?: { data?: { message?: string } } }\n        )\n      ) {\n        await this.handleRateLimit(error as { response?: { headers?: Record<string, string> } });\n        return this.findVisorComment(owner, repo, prNumber, commentId);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Update existing comment or create new one with collision detection\n   */\n  public async updateOrCreateComment(\n    owner: string,\n    repo: string,\n    prNumber: number,\n    content: string,\n    options: {\n      commentId?: string;\n      triggeredBy?: string;\n      allowConcurrentUpdates?: boolean;\n      commitSha?: string;\n    } = {}\n  ): Promise<Comment> {\n    const {\n      commentId = this.generateCommentId(),\n      triggeredBy = 'unknown',\n      allowConcurrentUpdates = false,\n      commitSha,\n    } = options;\n\n    return this.withRetry(async () => {\n      const existingComment = await this.findVisorComment(owner, repo, prNumber, commentId);\n\n      const formattedContent = this.formatCommentWithMetadata(content, {\n        commentId,\n        lastUpdated: new Date().toISOString(),\n        triggeredBy,\n        commitSha,\n      });\n\n      if (existingComment) {\n        // Check for collision if not allowing concurrent updates\n        if (!allowConcurrentUpdates) {\n          const currentComment = await this.octokit.rest.issues.getComment({\n            owner,\n            repo,\n            comment_id: existingComment.id,\n          });\n\n          if (currentComment.data.updated_at !== existingComment.updated_at) {\n            throw new Error(\n              `Comment collision detected for comment ${commentId}. Another process may have updated it.`\n            );\n          }\n        }\n\n        const updatedComment = await this.octokit.rest.issues.updateComment({\n          owner,\n          repo,\n          comment_id: existingComment.id,\n          body: formattedContent,\n        });\n\n        logger.info(\n          `‚úÖ Successfully updated comment (ID: ${commentId}, GitHub ID: ${existingComment.id}) on PR #${prNumber} in ${owner}/${repo}`\n        );\n\n        return updatedComment.data as Comment;\n      } else {\n        const newComment = await this.octokit.rest.issues.createComment({\n          owner,\n          repo,\n          issue_number: prNumber,\n          body: formattedContent,\n        });\n\n        logger.info(\n          `‚úÖ Successfully created comment (ID: ${commentId}, GitHub ID: ${newComment.data.id}) on PR #${prNumber} in ${owner}/${repo}`\n        );\n\n        return newComment.data as Comment;\n      }\n    });\n  }\n\n  /**\n   * Format comment content with metadata markers\n   */\n  public formatCommentWithMetadata(content: string, metadata: CommentMetadata): string {\n    const { commentId, lastUpdated, triggeredBy, commitSha } = metadata;\n\n    const footer = generateFooter({\n      includeMetadata: {\n        lastUpdated,\n        triggeredBy,\n        commitSha,\n      },\n    });\n\n    return `<!-- visor-comment-id:${commentId} -->\n${content}\n\n${footer}\n<!-- /visor-comment-id:${commentId} -->`;\n  }\n\n  /**\n   * Create collapsible sections for comment content\n   */\n  public createCollapsibleSection(\n    title: string,\n    content: string,\n    isExpanded: boolean = false\n  ): string {\n    const openAttribute = isExpanded ? ' open' : '';\n    return `<details${openAttribute}>\n<summary>${title}</summary>\n\n${content}\n\n</details>`;\n  }\n\n  /**\n   * Group review results by check type with collapsible sections\n   */\n  public formatGroupedResults(\n    results: Array<{ checkType: string; content: string; score?: number; issuesFound?: number }>,\n    groupBy: 'check' | 'severity' = 'check'\n  ): string {\n    const grouped = this.groupResults(results, groupBy);\n    const sections: string[] = [];\n\n    for (const [groupKey, items] of Object.entries(grouped)) {\n      const totalScore = items.reduce((sum, item) => sum + (item.score || 0), 0) / items.length;\n      const totalIssues = items.reduce((sum, item) => sum + (item.issuesFound || 0), 0);\n\n      const title = this.formatGroupTitle(groupKey, totalScore, totalIssues);\n\n      const sectionContent = items.map(item => item.content).join('\\n\\n');\n      sections.push(this.createCollapsibleSection(title, sectionContent, totalIssues > 0));\n    }\n\n    return sections.join('\\n\\n');\n  }\n\n  /**\n   * Generate unique comment ID\n   */\n  private generateCommentId(): string {\n    return uuidv4().substring(0, 8);\n  }\n\n  /**\n   * Check if comment is a Visor comment\n   */\n  private isVisorComment(body: string, commentId?: string): boolean {\n    if (commentId) {\n      // Check for the new format with exact matching - look for the exact ID followed by space or \" -->\"\n      if (\n        body.includes(`visor-comment-id:${commentId} `) ||\n        body.includes(`visor-comment-id:${commentId} -->`)\n      ) {\n        return true;\n      }\n      // Check for legacy format (visor-review-* pattern) for backwards compatibility\n      if (commentId.startsWith('pr-review-') && body.includes('visor-review-')) {\n        return true;\n      }\n      // If we have a specific commentId but no exact match, return false\n      return false;\n    }\n    // General Visor comment detection (only when no specific commentId provided)\n    return (\n      (body.includes('visor-comment-id:') && body.includes('<!-- /visor-comment-id:')) ||\n      body.includes('visor-review-')\n    );\n  }\n\n  /**\n   * Extract comment ID from comment body\n   */\n  public extractCommentId(body: string): string | null {\n    const match = body.match(/visor-comment-id:([a-f0-9-]+)/);\n    return match ? match[1] : null;\n  }\n\n  /**\n   * Handle rate limiting with exponential backoff\n   */\n  private async handleRateLimit(error: {\n    response?: { headers?: Record<string, string> };\n  }): Promise<void> {\n    const resetTime = error.response?.headers?.['x-ratelimit-reset'];\n    if (resetTime) {\n      const resetDate = new Date(parseInt(resetTime) * 1000);\n      const waitTime = Math.max(resetDate.getTime() - Date.now(), this.retryConfig.baseDelay);\n      console.log(`Rate limit exceeded. Waiting ${Math.round(waitTime / 1000)}s until reset...`);\n      await this.sleep(Math.min(waitTime, this.retryConfig.maxDelay));\n    } else {\n      await this.sleep(this.retryConfig.baseDelay);\n    }\n  }\n\n  /**\n   * Check if error is a rate limit error\n   */\n  private isRateLimitError(error: GitHubApiError): boolean {\n    return error.status === 403 && (error.response?.data?.message?.includes('rate limit') ?? false);\n  }\n\n  /**\n   * Check if error should not be retried (auth errors, not found, etc.)\n   */\n  private isNonRetryableError(error: GitHubApiError): boolean {\n    // Don't retry auth errors, not found, etc., but allow rate limit errors to be handled separately\n    const nonRetryableStatuses = [401, 404, 422]; // Unauthorized, Not Found, Unprocessable Entity\n    const status = error.status || error.response?.status;\n\n    // 403 is non-retryable unless it's a rate limit error\n    if (status === 403) {\n      return !this.isRateLimitError(error);\n    }\n\n    return status !== undefined && nonRetryableStatuses.includes(status);\n  }\n\n  /**\n   * Retry wrapper with exponential backoff\n   */\n  private async withRetry<T>(operation: () => Promise<T>): Promise<T> {\n    let lastError: Error = new Error('Unknown error');\n\n    for (let attempt = 0; attempt <= this.retryConfig.maxRetries; attempt++) {\n      try {\n        return await operation();\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n\n        if (attempt === this.retryConfig.maxRetries) {\n          break;\n        }\n\n        if (\n          this.isRateLimitError(\n            error as { status?: number; response?: { data?: { message?: string } } }\n          )\n        ) {\n          await this.handleRateLimit(error as { response?: { headers?: Record<string, string> } });\n        } else if (this.isNonRetryableError(error as GitHubApiError)) {\n          // Don't retry auth errors, not found errors, etc.\n          throw error;\n        } else {\n          const computed =\n            this.retryConfig.baseDelay * Math.pow(this.retryConfig.backoffFactor, attempt);\n          const delay =\n            computed > this.retryConfig.maxDelay\n              ? Math.max(0, this.retryConfig.maxDelay - 1)\n              : computed;\n          await this.sleep(delay);\n        }\n      }\n    }\n\n    throw lastError;\n  }\n\n  /**\n   * Sleep utility\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => {\n      const t = setTimeout(resolve, ms);\n      if (typeof (t as any).unref === 'function') {\n        try {\n          (t as any).unref();\n        } catch {}\n      }\n    });\n  }\n\n  /**\n   * Group results by specified criteria\n   */\n  private groupResults(\n    results: Array<{ checkType: string; content: string; score?: number; issuesFound?: number }>,\n    groupBy: 'check' | 'severity'\n  ): Record<\n    string,\n    Array<{ checkType: string; content: string; score?: number; issuesFound?: number }>\n  > {\n    const grouped: Record<\n      string,\n      Array<{ checkType: string; content: string; score?: number; issuesFound?: number }>\n    > = {};\n\n    for (const result of results) {\n      const key = groupBy === 'check' ? result.checkType : this.getSeverityGroup(result.score);\n      if (!grouped[key]) {\n        grouped[key] = [];\n      }\n      grouped[key].push(result);\n    }\n\n    return grouped;\n  }\n\n  /**\n   * Get severity group based on score\n   */\n  private getSeverityGroup(score?: number): string {\n    if (!score) return 'Unknown';\n    if (score >= 90) return 'Excellent';\n    if (score >= 75) return 'Good';\n    if (score >= 50) return 'Needs Improvement';\n    return 'Critical Issues';\n  }\n\n  // Emoji helper removed: plain titles are used in group headers\n\n  /**\n   * Format group title with score and issue count\n   */\n  private formatGroupTitle(groupKey: string, score: number, issuesFound: number): string {\n    const formattedScore = Math.round(score);\n    return `${groupKey} Review (Score: ${formattedScore}/100)${issuesFound > 0 ? ` - ${issuesFound} issues found` : ''}`;\n  }\n}\n","/**\n * Centralized footer generation for Visor comments and outputs\n */\n\nexport interface FooterOptions {\n  /**\n   * Include metadata like lastUpdated, triggeredBy, commitSha\n   */\n  includeMetadata?: {\n    lastUpdated: string;\n    triggeredBy: string;\n    commitSha?: string;\n  };\n  /**\n   * Include horizontal rule separator before footer\n   */\n  includeSeparator?: boolean;\n}\n\n/**\n * Generate a standard Visor footer with branding and optional tip\n */\nexport function generateFooter(options: FooterOptions = {}): string {\n  const { includeMetadata, includeSeparator = true } = options;\n\n  const parts: string[] = [];\n\n  // Add separator\n  if (includeSeparator) {\n    parts.push('---');\n    parts.push('');\n  }\n\n  // Add branding\n  parts.push(\n    '*Powered by [Visor](https://probelabs.com/visor) from [Probelabs](https://probelabs.com)*'\n  );\n\n  // Add metadata if provided\n  if (includeMetadata) {\n    const { lastUpdated, triggeredBy, commitSha } = includeMetadata;\n    const commitInfo = commitSha ? ` | Commit: ${commitSha.substring(0, 7)}` : '';\n    parts.push('');\n    parts.push(`*Last updated: ${lastUpdated} | Triggered by: ${triggeredBy}${commitInfo}*`);\n  }\n\n  // Add tip\n  parts.push('');\n  parts.push('üí° **TIP:** You can chat with Visor using `/visor ask <your question>`');\n\n  return parts.join('\\n');\n}\n\n/**\n * Check if a string contains a Visor footer\n */\nexport function hasVisorFooter(text: string): boolean {\n  return (\n    text.includes('*Powered by [Visor](https://probelabs.com/visor)') ||\n    text.includes('*Powered by [Visor](https://github.com/probelabs/visor)')\n  );\n}\n","import { Octokit } from '@octokit/rest';\nimport { PRInfo } from './pr-analyzer';\nimport { CommentManager } from './github-comments';\nimport { AIReviewService, AIDebugInfo } from './ai-review-service';\n\nexport interface ReviewIssue {\n  // Location\n  file: string;\n  line: number;\n  endLine?: number;\n  // Issue details\n  ruleId: string;\n  message: string;\n  severity: 'info' | 'warning' | 'error' | 'critical';\n  category: 'security' | 'performance' | 'style' | 'logic' | 'documentation';\n  // Check identification - which check created this issue\n  checkName?: string;\n  // Group and schema for comment separation\n  group?: string;\n  schema?: string;\n  // Timestamp when the issue was created (for ordering)\n  timestamp?: number;\n  // Optional enhancement\n  suggestion?: string;\n  replacement?: string;\n}\n\n// Legacy interface - ONLY for GitHub integration compatibility\nexport interface ReviewComment {\n  file: string;\n  line: number;\n  message: string;\n  severity: 'info' | 'warning' | 'error' | 'critical';\n  category: 'security' | 'performance' | 'style' | 'logic' | 'documentation';\n  suggestion?: string;\n  replacement?: string;\n  ruleId?: string;\n}\n\n// Individual check result - each check produces one of these\nexport interface CheckResult {\n  checkName: string;\n  content: string; // Rendered output for this specific check\n  group: string; // Which group this check belongs to\n  // Optional structured output for custom schemas (e.g., overview, issue-assistant)\n  output?: unknown;\n  debug?: AIDebugInfo;\n  issues?: ReviewIssue[]; // Structured issues alongside rendered content\n}\n\n// Results grouped by group name\nexport interface GroupedCheckResults {\n  [groupName: string]: CheckResult[];\n}\n\n// Legacy interface - only for backward compatibility\nexport interface ReviewSummary {\n  issues?: ReviewIssue[];\n  debug?: AIDebugInfo;\n  /** Session ID created for this check (for cleanup tracking) */\n  sessionId?: string;\n}\n\n// Test utility function - Convert old ReviewSummary to new GroupedCheckResults format\n// This is for backward compatibility with tests only\nexport function convertReviewSummaryToGroupedResults(\n  reviewSummary: ReviewSummary,\n  checkName: string = 'test-check',\n  groupName: string = 'default'\n): GroupedCheckResults {\n  // Create a simple content string from issues\n  let content = '';\n\n  if (reviewSummary.issues && reviewSummary.issues.length > 0) {\n    content += `## Issues Found (${reviewSummary.issues.length})\\n\\n`;\n    reviewSummary.issues.forEach(issue => {\n      content += `- **${issue.severity.toUpperCase()}**: ${issue.message} (${issue.file}:${issue.line})\\n`;\n    });\n    content += '\\n';\n  }\n\n  if (!content) {\n    content = 'No issues found.';\n  }\n\n  const checkResult: CheckResult = {\n    checkName,\n    content: content.trim(),\n    group: groupName,\n    debug: reviewSummary.debug,\n    issues: reviewSummary.issues, // Include structured issues\n  };\n\n  const groupedResults: GroupedCheckResults = {};\n  groupedResults[groupName] = [checkResult];\n\n  return groupedResults;\n}\n\n// Helper functions for GitHub checks - ONLY for structured schemas that have issues\n// These are the ONLY acceptable hardcoded schema dependencies, and only for GitHub integration\nexport function calculateTotalIssues(issues?: ReviewIssue[]): number {\n  return (issues || []).length;\n}\n\nexport function calculateCriticalIssues(issues?: ReviewIssue[]): number {\n  return (issues || []).filter(i => i.severity === 'critical').length;\n}\n\n// Legacy converter - ONLY for GitHub integration compatibility\nexport function convertIssuesToComments(issues: ReviewIssue[]): ReviewComment[] {\n  return issues.map(issue => ({\n    file: issue.file,\n    line: issue.line,\n    message: issue.message,\n    severity: issue.severity,\n    category: issue.category,\n    suggestion: issue.suggestion,\n    replacement: issue.replacement,\n    ruleId: issue.ruleId,\n  }));\n}\n\nexport interface ReviewOptions {\n  focus?: string;\n  format?: 'table' | 'json' | 'markdown' | 'sarif';\n  debug?: boolean;\n  config?: import('./types/config').VisorConfig;\n  checks?: string[];\n  parallelExecution?: boolean;\n  // Optional tag filter to include/exclude checks by tags when running via GitHub Action path\n  tagFilter?: import('./types/config').TagFilter;\n}\n\nexport class PRReviewer {\n  private commentManager: CommentManager;\n  private aiReviewService: AIReviewService;\n\n  constructor(private octokit: Octokit) {\n    this.commentManager = new CommentManager(octokit);\n    this.aiReviewService = new AIReviewService();\n  }\n\n  async reviewPR(\n    owner: string,\n    repo: string,\n    prNumber: number,\n    prInfo: PRInfo,\n    options: ReviewOptions = {}\n  ): Promise<GroupedCheckResults> {\n    const { debug = false, config, checks } = options;\n\n    if (config && checks && checks.length > 0) {\n      const { StateMachineExecutionEngine } = await import('./state-machine-execution-engine');\n      const engine = new StateMachineExecutionEngine();\n      const { results } = await engine.executeGroupedChecks(\n        prInfo,\n        checks,\n        undefined,\n        config,\n        undefined,\n        debug,\n        undefined,\n        undefined,\n        options.tagFilter\n      );\n      return results;\n    }\n\n    throw new Error(\n      'No configuration provided. Please create a .visor.yaml file with check definitions. ' +\n        'Built-in prompts have been removed - all checks must be explicitly configured.'\n    );\n  }\n\n  /**\n   * Helper to check if a schema is comment-generating\n   * Comment-generating schemas include:\n   * - Built-in schemas: code-review, overview, plain, text\n   * - Custom schemas with a \"text\" field in properties\n   */\n  private async isCommentGeneratingSchema(\n    schema: string | Record<string, unknown>\n  ): Promise<boolean> {\n    try {\n      // Check for built-in comment-generating schemas\n      if (typeof schema === 'string') {\n        // Well-known comment-generating schemas\n        if (['code-review', 'overview', 'plain', 'text'].includes(schema)) {\n          return true;\n        }\n\n        // Try to load and check custom string schema\n        const fs = require('fs').promises;\n        const path = require('path');\n\n        // Sanitize schema name\n        const sanitizedSchemaName = schema.replace(/[^a-zA-Z0-9-]/g, '');\n        if (!sanitizedSchemaName || sanitizedSchemaName !== schema) {\n          return false;\n        }\n\n        // Locate built-in schema JSON. In Actions, schemas live under dist/output (relative to __dirname).\n        // In local dev/tests, schemas live under project/output (relative to CWD).\n        const candidatePaths = [\n          path.join(__dirname, 'output', sanitizedSchemaName, 'schema.json'),\n          path.join(process.cwd(), 'output', sanitizedSchemaName, 'schema.json'),\n        ];\n\n        for (const schemaPath of candidatePaths) {\n          try {\n            const schemaContent = await fs.readFile(schemaPath, 'utf-8');\n            const schemaObj = JSON.parse(schemaContent);\n\n            // Check if schema has a \"text\" field in properties\n            const properties = schemaObj.properties as Record<string, unknown> | undefined;\n            return !!(properties && 'text' in properties);\n          } catch {\n            // try next location\n          }\n        }\n        // Schema file not found in any known location, not comment-generating\n        return false;\n      } else {\n        // Inline schema object - check if it has a \"text\" field in properties\n        const properties = schema.properties as Record<string, unknown> | undefined;\n        return !!(properties && 'text' in properties);\n      }\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Filter check results to only include those that should post GitHub comments\n   */\n  private async filterCommentGeneratingChecks(\n    checkResults: CheckResult[],\n    config: import('./types/config').VisorConfig\n  ): Promise<CheckResult[]> {\n    const filtered: CheckResult[] = [];\n\n    for (const r of checkResults) {\n      const cfg = config.checks?.[r.checkName];\n      const type = cfg?.type || 'ai'; // Default to 'ai' if not specified\n      const schema = cfg?.schema;\n\n      // Determine if this check should generate a comment\n      // Include checks with:\n      // 1. type: 'ai' or 'claude-code' with no schema or comment-generating schemas\n      // 2. Other types ONLY if they have explicit comment-generating schemas\n      let shouldPostComment = false;\n\n      // AI-powered checks generate comments by default\n      const isAICheck = type === 'ai' || type === 'claude-code';\n\n      if (!schema || schema === '') {\n        // No schema specified - only AI checks generate comments by default\n        // Other types (github, command, http, etc.) without schema are for orchestration\n        shouldPostComment = isAICheck;\n      } else {\n        // Check if the schema is comment-generating (built-in or custom with text field)\n        shouldPostComment = await this.isCommentGeneratingSchema(schema);\n      }\n\n      if (shouldPostComment) {\n        filtered.push(r);\n      }\n    }\n\n    return filtered;\n  }\n\n  async postReviewComment(\n    owner: string,\n    repo: string,\n    prNumber: number,\n    groupedResults: GroupedCheckResults,\n    options: ReviewOptions & {\n      commentId?: string;\n      triggeredBy?: string;\n      commitSha?: string;\n      octokitOverride?: Octokit;\n    } = {}\n  ): Promise<void> {\n    // Post separate comments for each group\n    for (const [groupName, checkResults] of Object.entries(groupedResults)) {\n      // Only checks with comment-generating schemas should post PR comments\n      // AI checks (ai, claude-code) generate comments by default\n      // Other types need explicit comment-generating schemas\n      let filteredResults = options.config\n        ? await this.filterCommentGeneratingChecks(checkResults, options.config)\n        : checkResults;\n\n      // Collapse results to avoid concatenating mutually-exclusive or duplicate posts.\n      // For fact-validation flow, both 'post-verified-response' and 'post-unverified-warning'\n      // can appear across waves. Prefer the final intended output and drop earlier entries.\n      if (groupName === 'github-output' && filteredResults && filteredResults.length > 1) {\n        // Keep only the last occurrence per checkName.\n        const byName = new Map<string, any>();\n        for (const cr of filteredResults) byName.set(cr.checkName, cr);\n        let collapsed = Array.from(byName.values());\n        const hasVerified = collapsed.some((r: any) => r.checkName === 'post-verified-response');\n        if (hasVerified) {\n          collapsed = collapsed.filter((r: any) => r.checkName !== 'post-unverified-warning');\n        }\n        filteredResults = collapsed as any;\n      }\n\n      // If nothing to report after filtering, skip this group\n      if (!filteredResults || filteredResults.length === 0) {\n        continue;\n      }\n\n      const comment = await this.formatGroupComment(filteredResults, options, {\n        owner,\n        repo,\n        prNumber,\n        commitSha: options.commitSha,\n      });\n\n      // Generate comment ID - use unique ID for \"dynamic\" group\n      let commentId: string;\n      if (groupName === 'dynamic') {\n        // Dynamic group creates a new comment each time with timestamp-based ID\n        const timestamp = Date.now();\n        commentId = `visor-dynamic-${timestamp}`;\n      } else {\n        // Regular groups use static IDs that get updated\n        commentId = options.commentId\n          ? `${options.commentId}-${groupName}`\n          : `visor-review-${groupName}`;\n      }\n\n      // Do not post empty comments (possible if content is blank after fallbacks)\n      if (!comment || !comment.trim()) continue;\n\n      const manager = options.octokitOverride\n        ? new CommentManager(options.octokitOverride)\n        : this.commentManager;\n      await manager.updateOrCreateComment(owner, repo, prNumber, comment, {\n        commentId,\n        triggeredBy: options.triggeredBy || 'unknown',\n        allowConcurrentUpdates: false,\n        commitSha: options.commitSha,\n      });\n    }\n  }\n\n  private async formatGroupComment(\n    checkResults: CheckResult[],\n    _options: ReviewOptions,\n    _githubContext?: { owner: string; repo: string; prNumber: number; commitSha?: string }\n  ): Promise<string> {\n    // Concatenate all check outputs in this group; fall back to structured output fields\n    const normalize = (s: string) => s.replace(/\\\\n/g, '\\n');\n    const checkContents = checkResults\n      .map(result => {\n        const trimmed = result.content?.trim();\n        if (trimmed) return normalize(trimmed);\n        // Fallback: if provider returned structured output with a common text field\n        const out = (result as unknown as { debug?: unknown; issues?: unknown; output?: any })\n          .output;\n        if (out) {\n          if (typeof out === 'string' && out.trim()) return normalize(out.trim());\n          if (typeof out === 'object') {\n            const txt = (out.text || out.response || out.message) as unknown;\n            if (typeof txt === 'string' && txt.trim()) return normalize(txt.trim());\n          }\n        }\n        return '';\n      })\n      .filter(content => content && content.trim());\n\n    // Add debug info if any check has it\n    const debugInfo = checkResults.find(result => result.debug)?.debug;\n\n    // Only generate comment if there's actual content or debug info\n    if (checkContents.length === 0 && !debugInfo) {\n      return '';\n    }\n\n    let comment = '';\n    comment += `## üîç Code Analysis Results\\n\\n`;\n    comment += checkContents.join('\\n\\n');\n\n    if (debugInfo) {\n      comment += '\\n\\n' + this.formatDebugSection(debugInfo);\n      comment += '\\n\\n';\n    }\n\n    // Footer will be added by formatCommentWithMetadata in github-comments.ts\n    return comment;\n  }\n\n  private formatDebugSection(debug: AIDebugInfo): string {\n    const formattedContent = [\n      `**Provider:** ${debug.provider}`,\n      `**Model:** ${debug.model}`,\n      `**API Key Source:** ${debug.apiKeySource}`,\n      `**Processing Time:** ${debug.processingTime}ms`,\n      `**Timestamp:** ${debug.timestamp}`,\n      `**Prompt Length:** ${debug.promptLength} characters`,\n      `**Response Length:** ${debug.responseLength} characters`,\n      `**JSON Parse Success:** ${debug.jsonParseSuccess ? '‚úÖ' : '‚ùå'}`,\n    ];\n\n    if (debug.errors && debug.errors.length > 0) {\n      formattedContent.push('', '### Errors');\n      debug.errors.forEach(error => {\n        formattedContent.push(`- ${error}`);\n      });\n    }\n\n    const fullDebugContent = [\n      ...formattedContent,\n      '',\n      '### AI Prompt',\n      '```',\n      debug.prompt,\n      '```',\n      '',\n      '### Raw AI Response',\n      '```json',\n      debug.rawResponse,\n      '```',\n    ].join('\\n');\n\n    if (fullDebugContent.length > 60000) {\n      const artifactPath = this.saveDebugArtifact(debug);\n      formattedContent.push('');\n      formattedContent.push('### Debug Details');\n      formattedContent.push('‚ö†Ô∏è Debug information is too large for GitHub comments.');\n      if (artifactPath) {\n        formattedContent.push(\n          `üìÅ **Full debug information saved to artifact:** \\`${artifactPath}\\``\n        );\n        formattedContent.push('');\n        const runId = process.env.GITHUB_RUN_ID;\n        const repoUrl =\n          process.env.GITHUB_SERVER_URL && process.env.GITHUB_REPOSITORY\n            ? `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}`\n            : null;\n        if (runId && repoUrl) {\n          formattedContent.push(\n            `üîó **Download Link:** [visor-debug-${process.env.GITHUB_RUN_NUMBER || runId}](${repoUrl}/actions/runs/${runId})`\n          );\n        }\n        formattedContent.push(\n          'üí° Go to the GitHub Action run above and download the debug artifact to view complete prompts and responses.'\n        );\n      } else {\n        formattedContent.push('üìù **Prompt preview:** ' + debug.prompt.substring(0, 500) + '...');\n        formattedContent.push(\n          'üìù **Response preview:** ' + debug.rawResponse.substring(0, 500) + '...'\n        );\n      }\n    } else {\n      formattedContent.push('');\n      formattedContent.push('### AI Prompt');\n      formattedContent.push('```');\n      formattedContent.push(debug.prompt);\n      formattedContent.push('```');\n      formattedContent.push('');\n      formattedContent.push('### Raw AI Response');\n      formattedContent.push('```json');\n      formattedContent.push(debug.rawResponse);\n      formattedContent.push('```');\n    }\n\n    return this.commentManager.createCollapsibleSection(\n      'üêõ Debug Information',\n      formattedContent.join('\\n'),\n      false\n    );\n  }\n\n  private saveDebugArtifact(debug: AIDebugInfo): string | null {\n    try {\n      const fs = require('fs');\n      const path = require('path');\n      const debugDir = path.join(process.cwd(), 'debug-artifacts');\n      if (!fs.existsSync(debugDir)) {\n        fs.mkdirSync(debugDir, { recursive: true });\n      }\n\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n      const filename = `visor-debug-${timestamp}.md`;\n      const filepath = path.join(debugDir, filename);\n\n      const content = [\n        `# Visor Debug Information`,\n        ``,\n        `**Timestamp:** ${debug.timestamp}`,\n        `**Provider:** ${debug.provider}`,\n        `**Model:** ${debug.model}`,\n        `**Processing Time:** ${debug.processingTime}ms`,\n        ``,\n        `## AI Prompt`,\n        ``,\n        '```',\n        debug.prompt,\n        '```',\n        ``,\n        `## Raw AI Response`,\n        ``,\n        '```json',\n        debug.rawResponse,\n        '```',\n      ].join('\\n');\n\n      fs.writeFileSync(filepath, content, 'utf8');\n      return filename;\n    } catch (error) {\n      console.error('Failed to save debug artifact:', error);\n      return null;\n    }\n  }\n}\n"],"mappings":"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","names":[]}