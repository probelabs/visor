{"version":3,"sources":["../../src/telemetry/lazy-otel.ts","../../src/telemetry/fallback-ndjson.ts","../../src/telemetry/trace-helpers.ts","../../src/telemetry/metrics.ts","../../src/utils/sandbox.ts","../../src/utils/author-permissions.ts","../../src/failure-condition-evaluator.ts","../../src/snapshot-store.ts","../../src/state-machine/states/routing.ts"],"sourcesContent":["/**\n * Lazy-loading wrapper for OpenTelemetry API.\n * Returns no-op implementations if OpenTelemetry is not installed.\n * Uses hardcoded module name for security - no dynamic module loading.\n */\n\nlet otelApi: any = null;\nlet otelApiAttempted = false;\n\n// Hardcoded allowed module name to prevent module loading attacks\nconst OTEL_API_MODULE = '@opentelemetry/api';\n\nfunction getOtelApi() {\n  if (otelApiAttempted) return otelApi;\n  otelApiAttempted = true;\n\n  try {\n    // Security: Only load the specific @opentelemetry/api module\n    // Use dynamic require to prevent bundlers from including this module\n\n    otelApi = (function (name: string) {\n      return require(name);\n    })(OTEL_API_MODULE);\n  } catch {\n    // OpenTelemetry not installed - provide no-op implementations\n    otelApi = null;\n  }\n\n  return otelApi;\n}\n\n// Export lazy-loaded trace API\nexport const trace = {\n  getTracer(name: string, version?: string) {\n    const api = getOtelApi();\n    if (!api) return createNoOpTracer();\n    return api.trace.getTracer(name, version);\n  },\n  getSpan(context: any) {\n    const api = getOtelApi();\n    if (!api) return undefined;\n    return api.trace.getSpan(context);\n  },\n  getActiveSpan() {\n    const api = getOtelApi();\n    if (!api) return undefined;\n    return api.trace.getActiveSpan();\n  },\n};\n\n// Export lazy-loaded context API\nexport const context = {\n  active() {\n    const api = getOtelApi();\n    if (!api) return {};\n    return api.context.active();\n  },\n  with(context: any, fn: Function, thisArg?: any, ...args: any[]) {\n    const api = getOtelApi();\n    if (!api) return fn.call(thisArg, ...args);\n    return api.context.with(context, fn, thisArg, ...args);\n  },\n};\n\n// Export lazy-loaded metrics API\nexport const metrics = {\n  getMeter(name: string, version?: string) {\n    const api = getOtelApi();\n    if (!api?.metrics) return createNoOpMeter();\n    return api.metrics.getMeter(name, version);\n  },\n};\n\n// Export types and enums\nexport const SpanStatusCode = {\n  get UNSET() {\n    const api = getOtelApi();\n    return api?.SpanStatusCode?.UNSET ?? 0;\n  },\n  get OK() {\n    const api = getOtelApi();\n    return api?.SpanStatusCode?.OK ?? 1;\n  },\n  get ERROR() {\n    const api = getOtelApi();\n    return api?.SpanStatusCode?.ERROR ?? 2;\n  },\n};\n\nexport const SpanKind = {\n  get INTERNAL() {\n    const api = getOtelApi();\n    return api?.SpanKind?.INTERNAL ?? 0;\n  },\n  get SERVER() {\n    const api = getOtelApi();\n    return api?.SpanKind?.SERVER ?? 1;\n  },\n  get CLIENT() {\n    const api = getOtelApi();\n    return api?.SpanKind?.CLIENT ?? 2;\n  },\n  get PRODUCER() {\n    const api = getOtelApi();\n    return api?.SpanKind?.PRODUCER ?? 3;\n  },\n  get CONSUMER() {\n    const api = getOtelApi();\n    return api?.SpanKind?.CONSUMER ?? 4;\n  },\n};\n\n// Export diag API\nexport const diag = {\n  setLogger(logger: any, level?: any) {\n    const api = getOtelApi();\n    if (!api) return;\n    return api.diag.setLogger(logger, level);\n  },\n};\n\n// Lazy-loaded DiagConsoleLogger and DiagLogLevel for consistency\nexport const DiagConsoleLogger = {\n  get() {\n    const api = getOtelApi();\n    return api?.DiagConsoleLogger;\n  },\n};\n\nexport const DiagLogLevel = {\n  get NONE() {\n    const api = getOtelApi();\n    return api?.DiagLogLevel?.NONE ?? 0;\n  },\n  get ERROR() {\n    const api = getOtelApi();\n    return api?.DiagLogLevel?.ERROR ?? 30;\n  },\n  get WARN() {\n    const api = getOtelApi();\n    return api?.DiagLogLevel?.WARN ?? 50;\n  },\n  get INFO() {\n    const api = getOtelApi();\n    return api?.DiagLogLevel?.INFO ?? 60;\n  },\n  get DEBUG() {\n    const api = getOtelApi();\n    return api?.DiagLogLevel?.DEBUG ?? 70;\n  },\n  get VERBOSE() {\n    const api = getOtelApi();\n    return api?.DiagLogLevel?.VERBOSE ?? 80;\n  },\n  get ALL() {\n    const api = getOtelApi();\n    return api?.DiagLogLevel?.ALL ?? 9999;\n  },\n};\n\n// Type exports for TypeScript\nexport type Span = any;\nexport type Attributes = Record<string, any>;\nexport type HrTime = [number, number];\n\n// No-op implementations\nfunction createNoOpTracer() {\n  return {\n    startSpan: () => createNoOpSpan(),\n    // Support both OTel v1 and v2 overloads:\n    // - startActiveSpan(name, callback)\n    // - startActiveSpan(name, options, callback)\n    // - startActiveSpan(name, options, context, callback)\n    startActiveSpan: (name: string, arg2?: any, arg3?: any, arg4?: any) => {\n      const span = createNoOpSpan();\n      let cb: any = undefined;\n      if (typeof arg2 === 'function') cb = arg2;\n      else if (typeof arg3 === 'function') cb = arg3;\n      else if (typeof arg4 === 'function') cb = arg4;\n      if (typeof cb === 'function') {\n        try {\n          return cb(span);\n        } catch {\n          // swallow errors in no-op implementation\n          return undefined;\n        }\n      }\n      // No callback supplied: return a no-op span like the real API would\n      return span;\n    },\n  };\n}\n\nfunction createNoOpSpan() {\n  return {\n    spanContext: () => ({ traceId: '', spanId: '', traceFlags: 0 }),\n    setAttribute: () => {},\n    setAttributes: () => {},\n    addEvent: () => {},\n    setStatus: () => {},\n    updateName: () => {},\n    end: () => {},\n    isRecording: () => false,\n    recordException: () => {},\n  };\n}\n\nfunction createNoOpMeter() {\n  return {\n    createCounter: () => ({ add: () => {} }),\n    createHistogram: () => ({ record: () => {} }),\n    createUpDownCounter: () => ({ add: () => {} }),\n    createObservableGauge: () => {},\n    createObservableCounter: () => {},\n    createObservableUpDownCounter: () => {},\n  };\n}\n","import * as fs from 'fs';\nimport * as path from 'path';\n\nlet CURRENT_FILE: string | null = null;\nlet dirReady = false;\nlet writeChain: Promise<void> = Promise.resolve();\nfunction resolveTargetPath(outDir: string): string {\n  if (process.env.VISOR_FALLBACK_TRACE_FILE) {\n    CURRENT_FILE = process.env.VISOR_FALLBACK_TRACE_FILE;\n    return CURRENT_FILE;\n  }\n  if (CURRENT_FILE) return CURRENT_FILE;\n  const ts = new Date().toISOString().replace(/[:.]/g, '-');\n  CURRENT_FILE = path.join(outDir, `${ts}.ndjson`);\n  return CURRENT_FILE;\n}\n\nfunction isEnabled(): boolean {\n  // Enable when CLI set a fallback file (serverless mode), or when explicit file sink is enabled\n  if (process.env.VISOR_FALLBACK_TRACE_FILE) return true;\n  return (\n    process.env.VISOR_TELEMETRY_ENABLED === 'true' &&\n    (process.env.VISOR_TELEMETRY_SINK || 'file') === 'file'\n  );\n}\n\nfunction appendAsync(outDir: string, line: string): void {\n  writeChain = writeChain\n    .then(async () => {\n      if (!dirReady) {\n        try {\n          await fs.promises.mkdir(outDir, { recursive: true });\n        } catch {}\n        dirReady = true;\n      }\n      const target = resolveTargetPath(outDir);\n      await fs.promises.appendFile(target, line, 'utf8');\n    })\n    .catch(() => {});\n}\n\nexport async function flushNdjson(): Promise<void> {\n  try {\n    await writeChain;\n  } catch {}\n}\n\nexport function emitNdjsonFallback(name: string, attrs: Record<string, unknown>): void {\n  try {\n    if (!isEnabled()) return;\n    const outDir = process.env.VISOR_TRACE_DIR || path.join(process.cwd(), 'output', 'traces');\n    const line = JSON.stringify({ name, attributes: attrs }) + '\\n';\n    appendAsync(outDir, line);\n  } catch {\n    // ignore\n  }\n}\n\nexport function emitNdjsonSpanWithEvents(\n  name: string,\n  attrs: Record<string, unknown>,\n  events: Array<{ name: string; attrs?: Record<string, unknown> }>\n): void {\n  try {\n    if (!isEnabled()) return;\n    const outDir = process.env.VISOR_TRACE_DIR || path.join(process.cwd(), 'output', 'traces');\n    const line = JSON.stringify({ name, attributes: attrs, events }) + '\\n';\n    appendAsync(outDir, line);\n  } catch {\n    // ignore\n  }\n}\n","import { context as otContext, Span, SpanStatusCode, trace, Attributes } from './lazy-otel';\n\nexport function getTracer() {\n  return trace.getTracer('visor');\n}\n\nexport async function withActiveSpan<T>(\n  name: string,\n  attrs: Record<string, unknown> | undefined,\n  fn: (span: Span) => Promise<T>\n): Promise<T> {\n  const tracer = getTracer();\n  // Preserve parent context via tracer API; avoid logging parent IDs to stdout\n  // Avoid noisy stdout logs that break JSON consumers\n  return await new Promise<T>((resolve, reject) => {\n    const callback = async (span: Span) => {\n      // console.debug(`[trace] Span callback invoked for: [trace_id=${ctx.traceId} span_id=${ctx.spanId}] ${name} span: true`);\n      try {\n        const res = await fn(span);\n        // console.debug('[trace] Span execution completed for:', name);\n        resolve(res);\n      } catch (err) {\n        // console.debug('[trace] Span execution errored for:', name, err);\n        try {\n          if (err instanceof Error) span.recordException(err);\n          span.setStatus({ code: SpanStatusCode.ERROR });\n        } catch {}\n        reject(err);\n      } finally {\n        try {\n          // console.debug('[trace] Ending span:', name);\n          span.end();\n        } catch {}\n      }\n    };\n    // startActiveSpan should use the current active context to set parent automatically\n    const options = attrs ? { attributes: attrs as Attributes } : {};\n    tracer.startActiveSpan(name, options, callback);\n  });\n}\n\nexport function addEvent(name: string, attrs?: Record<string, unknown>): void {\n  const span = trace.getSpan(otContext.active());\n  if (span) {\n    try {\n      span.addEvent(name, attrs as Attributes);\n    } catch {\n      // ignore\n    }\n  }\n  // Fallback NDJSON emission for serverless/file sink when SDK may be inactive\n  try {\n    const { emitNdjsonSpanWithEvents } = require('./fallback-ndjson');\n    emitNdjsonSpanWithEvents('visor.event', {}, [{ name, attrs }]);\n    if (name === 'fail_if.triggered') {\n      emitNdjsonSpanWithEvents('visor.event', {}, [\n        { name: 'fail_if.evaluated', attrs },\n        { name: 'fail_if.triggered', attrs },\n      ]);\n    }\n  } catch {}\n}\n\nexport function setSpanAttributes(attrs: Record<string, unknown>): void {\n  const span = trace.getSpan(otContext.active());\n  if (!span) return;\n  try {\n    for (const [k, v] of Object.entries(attrs)) span.setAttribute(k, v as never);\n  } catch {\n    // ignore\n  }\n}\n\nexport function setSpanError(err: unknown): void {\n  const span = trace.getSpan(otContext.active());\n  if (!span) return;\n  try {\n    if (err instanceof Error) span.recordException(err);\n    span.setStatus({ code: SpanStatusCode.ERROR });\n  } catch {\n    // ignore\n  }\n}\n\n// Internal helper for tests: write a minimal run marker to NDJSON when using file sink\nlet __ndjsonPath: string | null = null;\nexport function __getOrCreateNdjsonPath(): string | null {\n  try {\n    // If sink is explicitly set to non-file, skip. If unset, still allow when a trace dir/file is configured.\n    if (process.env.VISOR_TELEMETRY_SINK && process.env.VISOR_TELEMETRY_SINK !== 'file')\n      return null;\n    const path = require('path');\n    const fs = require('fs');\n    // Prefer explicit fallback file path if set by the CLI\n    if (process.env.VISOR_FALLBACK_TRACE_FILE) {\n      __ndjsonPath = process.env.VISOR_FALLBACK_TRACE_FILE;\n      const dir = path.dirname(__ndjsonPath);\n      if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\n      return __ndjsonPath;\n    }\n    const outDir = process.env.VISOR_TRACE_DIR || path.join(process.cwd(), 'output', 'traces');\n    if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });\n    if (!__ndjsonPath) {\n      const ts = new Date().toISOString().replace(/[:.]/g, '-');\n      __ndjsonPath = path.join(outDir, `${ts}.ndjson`);\n    }\n    return __ndjsonPath;\n  } catch {\n    return null;\n  }\n}\nexport function _appendRunMarker(): void {\n  try {\n    const fs = require('fs');\n    const p = __getOrCreateNdjsonPath();\n    if (!p) return;\n    const line = { name: 'visor.run', attributes: { started: true } };\n    fs.appendFileSync(p, JSON.stringify(line) + '\\n', 'utf8');\n  } catch {}\n}\n","import { metrics } from './lazy-otel';\n\nlet initialized = false;\nconst meter = metrics.getMeter('visor');\n\n// Test helpers (enabled with VISOR_TEST_METRICS=true)\nconst TEST_ENABLED = process.env.VISOR_TEST_METRICS === 'true';\nconst TEST_SNAPSHOT: { [k: string]: number } = { fail_if_triggered: 0 };\n\n// Instruments (lazily created when first used)\nlet checkDurationHist: ReturnType<typeof meter.createHistogram> | undefined;\nlet providerDurationHist: ReturnType<typeof meter.createHistogram> | undefined;\nlet foreachDurationHist: ReturnType<typeof meter.createHistogram> | undefined;\nlet issuesCounter: ReturnType<typeof meter.createCounter> | undefined;\nlet activeChecks: ReturnType<typeof meter.createUpDownCounter> | undefined;\nlet failIfCounter: ReturnType<typeof meter.createCounter> | undefined;\nlet diagramBlocks: ReturnType<typeof meter.createCounter> | undefined;\n\nfunction ensureInstruments() {\n  if (initialized) return;\n  try {\n    checkDurationHist = meter.createHistogram('visor.check.duration_ms', {\n      description: 'Duration of a check execution in milliseconds',\n      unit: 'ms',\n    });\n    providerDurationHist = meter.createHistogram('visor.provider.duration_ms', {\n      description: 'Duration of provider execution in milliseconds',\n      unit: 'ms',\n    });\n    foreachDurationHist = meter.createHistogram('visor.foreach.item.duration_ms', {\n      description: 'Duration of a forEach item execution in milliseconds',\n      unit: 'ms',\n    });\n    issuesCounter = meter.createCounter('visor.check.issues', {\n      description: 'Number of issues produced by checks',\n      unit: '1',\n    });\n    activeChecks = meter.createUpDownCounter('visor.run.active_checks', {\n      description: 'Number of checks actively running',\n      unit: '1',\n    });\n    failIfCounter = meter.createCounter('visor.fail_if.triggered', {\n      description: 'Number of times fail_if condition triggered',\n      unit: '1',\n    });\n    diagramBlocks = meter.createCounter('visor.diagram.blocks', {\n      description: 'Number of Mermaid diagram blocks emitted',\n      unit: '1',\n    });\n    initialized = true;\n  } catch {\n    // Metrics may be unavailable if SDK not initialized; ignore gracefully\n  }\n}\n\nexport function recordCheckDuration(check: string, durationMs: number, group?: string) {\n  ensureInstruments();\n  try {\n    checkDurationHist?.record(durationMs, {\n      'visor.check.id': check,\n      'visor.check.group': group || 'default',\n    });\n  } catch {}\n}\n\nexport function recordProviderDuration(check: string, providerType: string, durationMs: number) {\n  ensureInstruments();\n  try {\n    providerDurationHist?.record(durationMs, {\n      'visor.check.id': check,\n      'visor.provider.type': providerType,\n    });\n  } catch {}\n}\n\nexport function recordForEachDuration(\n  check: string,\n  index: number,\n  total: number,\n  durationMs: number\n) {\n  ensureInstruments();\n  try {\n    foreachDurationHist?.record(durationMs, {\n      'visor.check.id': check,\n      'visor.foreach.index': index,\n      'visor.foreach.total': total,\n    });\n  } catch {}\n}\n\nexport function addIssues(check: string, severity: string, count = 1) {\n  ensureInstruments();\n  try {\n    issuesCounter?.add(count, {\n      'visor.check.id': check,\n      severity,\n    });\n  } catch {}\n}\n\nexport function incActiveCheck(check: string) {\n  ensureInstruments();\n  try {\n    activeChecks?.add(1, { 'visor.check.id': check });\n  } catch {}\n}\n\nexport function decActiveCheck(check: string) {\n  ensureInstruments();\n  try {\n    activeChecks?.add(-1, { 'visor.check.id': check });\n  } catch {}\n}\n\nexport function addFailIfTriggered(check: string, scope: 'global' | 'check') {\n  ensureInstruments();\n  try {\n    failIfCounter?.add(1, { 'visor.check.id': check, scope });\n  } catch {}\n  if (TEST_ENABLED) TEST_SNAPSHOT.fail_if_triggered++;\n}\n\nexport function addDiagramBlock(origin: 'content' | 'issue') {\n  ensureInstruments();\n  try {\n    diagramBlocks?.add(1, { origin });\n  } catch {}\n}\n\nexport function getTestMetricsSnapshot() {\n  return { ...TEST_SNAPSHOT };\n}\n\nexport function resetTestMetricsSnapshot() {\n  Object.keys(TEST_SNAPSHOT).forEach(k => (TEST_SNAPSHOT[k] = 0));\n}\n","import Sandbox from '@nyariv/sandboxjs';\n\n/**\n * Centralized helpers for creating and using SandboxJS instances consistently\n * across providers. The goal is to have one place to define allowed globals\n * and prototype whitelists, and to offer a small helper to inject a `log`\n * utility inside user-provided JS snippets.\n */\n\nexport interface CompileOptions {\n  injectLog?: boolean;\n  logPrefix?: string;\n  /** When true, wrap the code in a function and `return` its result */\n  wrapFunction?: boolean;\n}\n\n/**\n * Create a hardened Sandbox with a consistent set of globals and prototype\n * whitelists. This is a superset of the sets previously used by individual\n * providers, kept intentionally minimal and sideâ€‘effect free.\n */\nexport function createSecureSandbox(): Sandbox {\n  const globals = {\n    ...Sandbox.SAFE_GLOBALS,\n    Math,\n    JSON,\n    // Provide console with limited surface. Use trampolines so that any test\n    // spies (e.g., jest.spyOn(console, 'log')) see calls made inside the sandbox.\n    console: {\n      log: (...args: unknown[]) => {\n        try {\n          (console as any).log(...args);\n        } catch {}\n      },\n      warn: (...args: unknown[]) => {\n        try {\n          (console as any).warn(...args);\n        } catch {}\n      },\n      error: (...args: unknown[]) => {\n        try {\n          (console as any).error(...args);\n        } catch {}\n      },\n    },\n  } as Record<string, unknown>;\n\n  const prototypeWhitelist = new Map(Sandbox.SAFE_PROTOTYPES);\n\n  // Arrays â€” union of methods used around the codebase\n  const arrayMethods = new Set<string>([\n    // Query/iteration\n    'some',\n    'every',\n    'filter',\n    'map',\n    'reduce',\n    'reduceRight',\n    'find',\n    'findIndex',\n    'findLast',\n    'findLastIndex',\n    'includes',\n    'indexOf',\n    'lastIndexOf',\n    'keys',\n    'values',\n    'entries',\n    'forEach',\n    // Nonâ€‘mutating ES2023 additions\n    'toReversed',\n    'toSorted',\n    'toSpliced',\n    'with',\n    'at',\n    // Mutators and common ops\n    'slice',\n    'concat',\n    'join',\n    'push',\n    'pop',\n    'shift',\n    'unshift',\n    'sort',\n    'reverse',\n    'copyWithin',\n    'fill',\n    // Flattening\n    'flat',\n    'flatMap',\n    // Meta\n    'length',\n  ]);\n  prototypeWhitelist.set(Array.prototype, arrayMethods);\n\n  // Strings â€” allow common, safe manipulation helpers\n  const stringMethods = new Set<string>([\n    'toLowerCase',\n    'toUpperCase',\n    'includes',\n    'indexOf',\n    'lastIndexOf',\n    'startsWith',\n    'endsWith',\n    'slice',\n    'substring',\n    'substr',\n    'trim',\n    'trimStart',\n    'trimEnd',\n    'split',\n    'replace',\n    'replaceAll',\n    'match',\n    'matchAll',\n    'charAt',\n    'charCodeAt',\n    'codePointAt',\n    'normalize',\n    'repeat',\n    'padStart',\n    'padEnd',\n    'at',\n    'length',\n  ]);\n  prototypeWhitelist.set(String.prototype, stringMethods);\n\n  // Objects â€” keep to basic safe operations\n  const objectMethods = new Set<string>([\n    'hasOwnProperty',\n    'propertyIsEnumerable',\n    'toString',\n    'valueOf',\n  ]);\n  prototypeWhitelist.set(Object.prototype, objectMethods);\n\n  // Keep native constructors from SAFE_GLOBALS; rely on prototype whitelists above.\n\n  // Maps and Sets â€” allow common, safe operations\n  const mapMethods = new Set<string>([\n    'get',\n    'set',\n    'has',\n    'delete',\n    'entries',\n    'keys',\n    'values',\n    'forEach',\n  ]);\n  // @ts-ignore - sandbox typings accept Map.prototype as a key\n  prototypeWhitelist.set((Map as any).prototype, mapMethods);\n\n  const setMethods = new Set<string>([\n    'add',\n    'has',\n    'delete',\n    'entries',\n    'keys',\n    'values',\n    'forEach',\n  ]);\n  // @ts-ignore\n  prototypeWhitelist.set((Set as any).prototype, setMethods);\n\n  // Date and RegExp â€” readâ€‘only helpers\n  const dateMethods = new Set<string>(['toISOString', 'toJSON', 'getTime']);\n  // @ts-ignore\n  prototypeWhitelist.set((Date as any).prototype, dateMethods);\n\n  const regexpMethods = new Set<string>(['test', 'exec']);\n  // @ts-ignore\n  prototypeWhitelist.set((RegExp as any).prototype, regexpMethods);\n\n  return new Sandbox({ globals, prototypeWhitelist });\n}\n\n/**\n * Compile and execute user-provided JS inside the sandbox with optional\n * helper injection. By default, code is wrapped in a function to keep the\n * global scope clean.\n */\nexport function compileAndRun<T = unknown>(\n  sandbox: Sandbox,\n  userCode: string,\n  scope: Record<string, unknown>,\n  opts: CompileOptions = { injectLog: true, wrapFunction: true, logPrefix: '[sandbox]' }\n): T {\n  const inject = opts?.injectLog === true;\n  let safePrefix = String(opts?.logPrefix ?? '[sandbox]');\n  // Sanitize prefix aggressively: drop control chars and risky tokens, limit length\n  safePrefix = safePrefix\n    .replace(/[\\r\\n\\t\\0]/g, '')\n    .replace(/[`$\\\\]/g, '') // strip backticks, dollar (template) and backslashes\n    .replace(/\\$\\{/g, '') // remove template openings if present\n    .slice(0, 64);\n  // Build a safe header without string concatenation inside user code\n  const header = inject\n    ? `const __lp = ${JSON.stringify(safePrefix)}; const log = (...a) => { try { console.log(__lp, ...a); } catch {} };\\n`\n    : '';\n  // When wrapping, execute user code inside an IIFE and return its value.\n  // This reliably captures the value of the last expression or any explicit\n  // return statements inside the script, without requiring the caller to\n  // manually `return` at top level.\n  // Wrapper heuristic:\n  // - If the snippet contains an explicit `return`, semicolons or newlines (likely a block),\n  //   run it inside an IIFE so `return` works:  (() => { code })()\n  // - Otherwise treat it as a pure expression and return its value directly.\n  const src = String(userCode);\n  const looksLikeBlock = /\\breturn\\b/.test(src) || /;/.test(src) || /\\n/.test(src);\n  // Heuristic: if the snippet itself looks like an IIFE/callable expression\n  // (e.g., `(() => { ... })()` or `(function(){ ... })()`), return its value\n  // directly to avoid swallowing the result by nesting it inside another block.\n  const looksLikeIife = /\\)\\s*\\(\\s*\\)\\s*;?$/.test(src.trim());\n  const body = opts.wrapFunction\n    ? looksLikeBlock\n      ? looksLikeIife\n        ? `return (\\n${src}\\n);\\n`\n        : `return (() => {\\n${src}\\n})();\\n`\n      : `return (\\n${src}\\n);\\n`\n    : `${src}`;\n  const code = `${header}${body}`;\n  let exec: ReturnType<typeof sandbox.compile>;\n  try {\n    exec = sandbox.compile(code);\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    throw new Error(`sandbox_compile_error: ${msg}`);\n  }\n\n  let out: any;\n  try {\n    out = exec(scope);\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    throw new Error(`sandbox_execution_error: ${msg}`);\n  }\n\n  if (out && typeof out.run === 'function') {\n    try {\n      return out.run();\n    } catch (e) {\n      const msg = e instanceof Error ? e.message : String(e);\n      throw new Error(`sandbox_runner_error: ${msg}`);\n    }\n  }\n  return out as T;\n}\n","/**\n * Author permission utilities for checking GitHub author associations\n *\n * GitHub provides author_association field with these values (in order of privilege):\n * - OWNER: Repository owner\n * - MEMBER: Organization member\n * - COLLABORATOR: Invited collaborator\n * - CONTRIBUTOR: Has contributed before\n * - FIRST_TIME_CONTRIBUTOR: First PR to this repo\n * - FIRST_TIMER: First GitHub contribution ever\n * - NONE: No association\n */\n\nexport type AuthorAssociation =\n  | 'OWNER'\n  | 'MEMBER'\n  | 'COLLABORATOR'\n  | 'CONTRIBUTOR'\n  | 'FIRST_TIME_CONTRIBUTOR'\n  | 'FIRST_TIMER'\n  | 'NONE';\n\n/**\n * Permission hierarchy (from highest to lowest privilege)\n */\nconst PERMISSION_HIERARCHY: AuthorAssociation[] = [\n  'OWNER',\n  'MEMBER',\n  'COLLABORATOR',\n  'CONTRIBUTOR',\n  'FIRST_TIME_CONTRIBUTOR',\n  'FIRST_TIMER',\n  'NONE',\n];\n\n/**\n * Get permission level (0 = highest, higher number = lower privilege)\n */\nfunction getPermissionLevel(association: string | undefined): number {\n  if (!association) return PERMISSION_HIERARCHY.length; // Treat unknown as lowest\n  const index = PERMISSION_HIERARCHY.indexOf(association.toUpperCase() as AuthorAssociation);\n  return index === -1 ? PERMISSION_HIERARCHY.length : index;\n}\n\n/**\n * Check if author has at least the specified permission level (>= logic)\n *\n * @param authorAssociation - The author's association from GitHub API\n * @param minPermission - Minimum required permission level\n * @param isLocalMode - Whether running in local/CLI mode (defaults to true for local runs)\n * @returns true if author has at least the specified permission level\n *\n * @example\n * hasMinPermission('MEMBER', 'MEMBER') // true (exact match)\n * hasMinPermission('OWNER', 'MEMBER') // true (owner >= member)\n * hasMinPermission('COLLABORATOR', 'MEMBER') // false (collaborator < member)\n * hasMinPermission(undefined, 'OWNER', true) // true (local mode)\n */\nexport function hasMinPermission(\n  authorAssociation: string | undefined,\n  minPermission: AuthorAssociation,\n  isLocalMode: boolean = false\n): boolean {\n  // In local mode (not GitHub Actions), treat as owner\n  if (isLocalMode) {\n    return true;\n  }\n\n  const authorLevel = getPermissionLevel(authorAssociation);\n  const minLevel = getPermissionLevel(minPermission);\n\n  // Lower number = higher privilege, so author must have equal or lower number\n  return authorLevel <= minLevel;\n}\n\n/**\n * Check if author is exactly the repository owner\n */\nexport function isOwner(\n  authorAssociation: string | undefined,\n  isLocalMode: boolean = false\n): boolean {\n  if (isLocalMode) return true;\n  return authorAssociation?.toUpperCase() === 'OWNER';\n}\n\n/**\n * Check if author is an organization member or owner\n */\nexport function isMember(\n  authorAssociation: string | undefined,\n  isLocalMode: boolean = false\n): boolean {\n  if (isLocalMode) return true;\n  return hasMinPermission(authorAssociation, 'MEMBER', isLocalMode);\n}\n\n/**\n * Check if author is a collaborator (or higher)\n */\nexport function isCollaborator(\n  authorAssociation: string | undefined,\n  isLocalMode: boolean = false\n): boolean {\n  if (isLocalMode) return true;\n  return hasMinPermission(authorAssociation, 'COLLABORATOR', isLocalMode);\n}\n\n/**\n * Check if author is a contributor (has contributed before)\n */\nexport function isContributor(\n  authorAssociation: string | undefined,\n  isLocalMode: boolean = false\n): boolean {\n  if (isLocalMode) return true;\n  return hasMinPermission(authorAssociation, 'CONTRIBUTOR', isLocalMode);\n}\n\n/**\n * Check if author is a first-time contributor (to this repo or GitHub)\n */\nexport function isFirstTimer(\n  authorAssociation: string | undefined,\n  isLocalMode: boolean = false\n): boolean {\n  if (isLocalMode) return false; // In local mode, not a first-timer\n  const assoc = authorAssociation?.toUpperCase();\n  return assoc === 'FIRST_TIME_CONTRIBUTOR' || assoc === 'FIRST_TIMER';\n}\n\n/**\n * Create permission helper functions bound to a specific author association\n * This is used to inject functions into JavaScript execution contexts\n *\n * @param authorAssociation - The author's association from PR data\n * @param isLocalMode - Whether running in local/CLI mode\n */\nexport function createPermissionHelpers(\n  authorAssociation: string | undefined,\n  isLocalMode: boolean = false\n) {\n  return {\n    hasMinPermission: (minPermission: AuthorAssociation) =>\n      hasMinPermission(authorAssociation, minPermission, isLocalMode),\n    isOwner: () => isOwner(authorAssociation, isLocalMode),\n    isMember: () => isMember(authorAssociation, isLocalMode),\n    isCollaborator: () => isCollaborator(authorAssociation, isLocalMode),\n    isContributor: () => isContributor(authorAssociation, isLocalMode),\n    isFirstTimer: () => isFirstTimer(authorAssociation, isLocalMode),\n  };\n}\n\n/**\n * Determine if we're running in local mode (not GitHub Actions)\n */\nexport function detectLocalMode(): boolean {\n  return !process.env.GITHUB_ACTIONS;\n}\n\n/**\n * Resolve the most relevant GitHub author association from an event context.\n * Prefers commenter association for issue_comment events, then issue/PR author,\n * and finally falls back to the provided default association.\n */\nexport function resolveAssociationFromEvent(\n  eventContext: any | undefined,\n  fallback?: string\n): string | undefined {\n  try {\n    const ec = eventContext || {};\n    return (\n      ec?.comment?.author_association ||\n      ec?.issue?.author_association ||\n      ec?.pull_request?.author_association ||\n      fallback\n    );\n  } catch {\n    return fallback;\n  }\n}\n","/**\n * Failure condition evaluation engine using SandboxJS for secure expression evaluation\n */\n\nimport { ReviewSummary } from './reviewer';\nimport { addEvent } from './telemetry/trace-helpers';\nimport { addFailIfTriggered } from './telemetry/metrics';\nimport {\n  FailureConditions,\n  FailureCondition,\n  FailureConditionContext,\n  FailureConditionResult,\n  FailureConditionSeverity,\n} from './types/config';\nimport Sandbox from '@nyariv/sandboxjs';\nimport { createSecureSandbox } from './utils/sandbox';\nimport { createPermissionHelpers, detectLocalMode } from './utils/author-permissions';\nimport { MemoryStore } from './memory-store';\n\n/**\n * Evaluates failure conditions using SandboxJS for secure evaluation\n */\nexport class FailureConditionEvaluator {\n  private sandbox?: Sandbox;\n\n  constructor() {}\n\n  /**\n   * Create a secure sandbox with whitelisted functions and globals\n   */\n  private createSecureSandbox(): Sandbox {\n    return createSecureSandbox();\n  }\n\n  /**\n   * Evaluate simple fail_if condition\n   */\n  async evaluateSimpleCondition(\n    checkName: string,\n    checkSchema: string,\n    checkGroup: string,\n    reviewSummary: ReviewSummary,\n    expression: string,\n    previousOutputs?: Record<string, ReviewSummary>,\n    authorAssociation?: string\n  ): Promise<boolean> {\n    const context = this.buildEvaluationContext(\n      checkName,\n      checkSchema,\n      checkGroup,\n      reviewSummary,\n      previousOutputs,\n      authorAssociation\n    );\n\n    try {\n      try {\n        const isObj = context.output && typeof context.output === 'object';\n        const keys = isObj ? Object.keys(context.output as any).join(',') : typeof context.output;\n        let errorVal: unknown = undefined;\n        if (isObj && (context.output as any).error !== undefined)\n          errorVal = (context.output as any).error;\n        require('./logger').logger.debug(\n          `  fail_if: evaluating '${expression}' with output keys=${keys} error=${String(errorVal)}`\n        );\n      } catch {}\n      const res = this.evaluateExpression(expression, context);\n      if (res === true) {\n        try {\n          addEvent('fail_if.triggered', {\n            check: checkName,\n            scope: 'check',\n            name: `${checkName}_fail_if`,\n            expression,\n            severity: 'error',\n          });\n        } catch {}\n        try {\n          const { emitNdjsonSpanWithEvents } = require('./telemetry/fallback-ndjson');\n          emitNdjsonSpanWithEvents(\n            'visor.fail_if',\n            { check: checkName, scope: 'check', name: `${checkName}_fail_if` },\n            [\n              {\n                name: 'fail_if.triggered',\n                attrs: {\n                  check: checkName,\n                  scope: 'check',\n                  name: `${checkName}_fail_if`,\n                  expression,\n                  severity: 'error',\n                },\n              },\n            ]\n          );\n        } catch {}\n      }\n      return res;\n    } catch (error) {\n      console.warn(`Failed to evaluate fail_if expression: ${error}`);\n      return false; // Don't fail on evaluation errors\n    }\n  }\n\n  /**\n   * Determine if the event is related to pull requests\n   */\n  private determineIfPullRequest(eventType?: string): boolean {\n    if (!eventType) return false;\n\n    const prEvents = ['pr_opened', 'pr_updated', 'pr_closed', 'pull_request'];\n    return prEvents.includes(eventType) || eventType.startsWith('pr_');\n  }\n\n  /**\n   * Determine if the event is related to issues\n   */\n  private determineIfIssue(eventType?: string): boolean {\n    if (!eventType) return false;\n\n    const issueEvents = ['issue_opened', 'issue_comment', 'issues'];\n    return issueEvents.includes(eventType) || eventType.startsWith('issue_');\n  }\n\n  /**\n   * Evaluate if condition to determine whether a check should run\n   */\n  async evaluateIfCondition(\n    checkName: string,\n    expression: string,\n    contextData?: {\n      branch?: string;\n      baseBranch?: string;\n      filesChanged?: string[];\n      event?: string;\n      environment?: Record<string, string>;\n      previousResults?: Map<string, ReviewSummary>;\n      authorAssociation?: string;\n      workflowInputs?: Record<string, unknown>;\n    }\n  ): Promise<boolean> {\n    // Build context for if evaluation\n    const context = {\n      // Check metadata\n      checkName,\n\n      // Git context\n      branch: contextData?.branch || 'unknown',\n      baseBranch: contextData?.baseBranch || 'main',\n      filesChanged: contextData?.filesChanged || [],\n      filesCount: contextData?.filesChanged?.length || 0,\n\n      // GitHub event context\n      event: {\n        event_name: contextData?.event || 'manual',\n        action: undefined, // Would be populated from actual GitHub context\n        repository: undefined, // Would be populated from actual GitHub context\n      },\n\n      // Environment variables\n      env: contextData?.environment || {},\n\n      // Previous check results (unwrap output field like templates do)\n      outputs: contextData?.previousResults\n        ? (() => {\n            const outputs: Record<string, unknown> = {};\n            for (const [checkName, result] of contextData.previousResults) {\n              // If the result has a direct output field, use it directly\n              // Otherwise, expose the entire result as-is\n              const summary = result as ReviewSummary & { output?: unknown };\n              outputs[checkName] = summary.output !== undefined ? summary.output : summary;\n            }\n            return outputs;\n          })()\n        : {},\n\n      // Workflow inputs (for workflows)\n      inputs: contextData?.workflowInputs || {},\n\n      // Required output property (empty for if conditions)\n      output: {\n        issues: [],\n      },\n      // Author association (used by permission helpers)\n      authorAssociation: contextData?.authorAssociation,\n\n      // Utility metadata\n      metadata: {\n        checkName,\n        schema: '',\n        group: '',\n        criticalIssues: 0,\n        errorIssues: 0,\n        warningIssues: 0,\n        infoIssues: 0,\n        totalIssues: 0,\n        hasChanges: (contextData?.filesChanged?.length || 0) > 0,\n        branch: contextData?.branch || 'unknown',\n        event: contextData?.event || 'manual',\n      },\n    };\n\n    try {\n      const res = this.evaluateExpression(expression, context);\n      try {\n        if (process.env.VISOR_DEBUG === 'true') {\n          const envMap = context.env || {};\n\n          console.error(\n            `[if-eval] check=${checkName} expr=\"${expression}\" env.ENABLE_FACT_VALIDATION=${String(\n              (envMap as any).ENABLE_FACT_VALIDATION\n            )} event=${context.event?.event_name} result=${String(res)}`\n          );\n        }\n      } catch {}\n      return res;\n    } catch (error) {\n      console.warn(`Failed to evaluate if expression for check '${checkName}': ${error}`);\n      // Fail-secure: do not run the check on evaluation errors\n      return false;\n    }\n  }\n\n  /**\n   * Evaluate all failure conditions for a check result\n   */\n  async evaluateConditions(\n    checkName: string,\n    checkSchema: string,\n    checkGroup: string,\n    reviewSummary: ReviewSummary,\n    globalConditions?: FailureConditions,\n    checkConditions?: FailureConditions,\n    previousOutputs?: Record<string, ReviewSummary>,\n    authorAssociation?: string\n  ): Promise<FailureConditionResult[]> {\n    const context = this.buildEvaluationContext(\n      checkName,\n      checkSchema,\n      checkGroup,\n      reviewSummary,\n      previousOutputs,\n      authorAssociation\n    );\n\n    const results: FailureConditionResult[] = [];\n\n    // Evaluate global conditions first\n    if (globalConditions) {\n      const globalResults = await this.evaluateConditionSet(globalConditions, context, 'global');\n      results.push(...globalResults);\n    }\n\n    // Evaluate check-specific conditions (these override global ones with same name)\n    if (checkConditions) {\n      const checkResults = await this.evaluateConditionSet(checkConditions, context, 'check');\n\n      // Remove global conditions that are overridden by check-specific ones\n      const overriddenConditions = new Set(Object.keys(checkConditions));\n      const filteredResults = results.filter(\n        result => !overriddenConditions.has(result.conditionName)\n      );\n\n      results.length = 0;\n      results.push(...filteredResults, ...checkResults);\n    }\n\n    try {\n      if (checkName === 'B') {\n        console.error(\n          `ðŸ”§ Debug: fail_if results for ${checkName}: ${JSON.stringify(results)} context.output=${JSON.stringify(\n            context.output\n          )}`\n        );\n      }\n    } catch {}\n    return results;\n  }\n\n  /**\n   * Evaluate a set of failure conditions\n   */\n  private async evaluateConditionSet(\n    conditions: FailureConditions,\n    context: FailureConditionContext,\n    source: 'global' | 'check'\n  ): Promise<FailureConditionResult[]> {\n    const results: FailureConditionResult[] = [];\n\n    for (const [conditionName, condition] of Object.entries(conditions)) {\n      try {\n        addEvent('fail_if.evaluated', {\n          check: context.checkName,\n          scope: source,\n          name: conditionName,\n          expression: this.extractExpression(condition),\n        });\n      } catch {}\n\n      // File fallback: append an NDJSON span with the evaluation event\n      try {\n        const { emitNdjsonSpanWithEvents } = require('./telemetry/fallback-ndjson');\n        emitNdjsonSpanWithEvents(\n          'visor.fail_if',\n          { check: context.checkName || 'unknown', scope: source, name: conditionName },\n          [\n            {\n              name: 'fail_if.evaluated',\n              attrs: {\n                check: context.checkName,\n                scope: source,\n                name: conditionName,\n                expression: this.extractExpression(condition),\n              },\n            },\n          ]\n        );\n      } catch {}\n\n      try {\n        const result = await this.evaluateSingleCondition(conditionName, condition, context);\n        results.push(result);\n\n        if (result.failed) {\n          try {\n            addEvent('fail_if.triggered', {\n              check: context.checkName,\n              scope: source,\n              name: conditionName,\n              expression: result.expression,\n              severity: result.severity,\n              halt_execution: result.haltExecution,\n            });\n          } catch {}\n          try {\n            addFailIfTriggered(context.checkName || 'unknown', source);\n          } catch {}\n        }\n      } catch (error) {\n        // If evaluation fails, create an error result\n        results.push({\n          conditionName,\n          failed: false,\n          expression: this.extractExpression(condition),\n          severity: 'error',\n          haltExecution: false,\n          error: `Failed to evaluate ${source} condition '${conditionName}': ${\n            error instanceof Error ? error.message : String(error)\n          }`,\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Evaluate a single failure condition\n   */\n  private async evaluateSingleCondition(\n    conditionName: string,\n    condition: FailureCondition,\n    context: FailureConditionContext\n  ): Promise<FailureConditionResult> {\n    const expression = this.extractExpression(condition);\n    const config = this.extractConditionConfig(condition);\n\n    try {\n      const failed = this.evaluateExpression(expression, context);\n\n      return {\n        conditionName,\n        failed,\n        expression,\n        message: config.message,\n        severity: config.severity || 'error',\n        haltExecution: config.halt_execution || false,\n      };\n    } catch (error) {\n      throw new Error(\n        `Expression evaluation error: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Secure expression evaluation using SandboxJS\n   * Supports the same GitHub Actions-style functions as the previous implementation\n   */\n  private evaluateExpression(condition: string, context: FailureConditionContext): boolean {\n    try {\n      // Normalize multi-line or semicolon-separated expressions.\n      // Allows writing debug statements on separate lines, e.g.:\n      //   log(\"start\")\n      //   log(outputs)\n      //   outputs[\"fetch-tickets\"].issueType === 'Bug'\n      // We convert to a single expression using the comma operator so the\n      // final expression determines the boolean result.\n      const normalize = (expr: string): string => {\n        const trimmed = expr.trim();\n        // If it's already a single-line expression without semicolons, keep it.\n        if (!/[\\n;]/.test(trimmed)) return trimmed;\n\n        // Split on newlines/semicolons, drop empty and comment-only lines.\n        const parts = trimmed\n          .split(/[\\n;]+/)\n          .map(s => s.trim())\n          .filter(s => s.length > 0 && !s.startsWith('//'));\n\n        if (parts.length === 0) return 'true';\n\n        // Support an explicit return in the last statement.\n        const lastRaw = parts.pop() as string;\n        const last = lastRaw.replace(/^return\\s+/i, '').trim();\n\n        // Join leading statements with comma operator; last expression returns value.\n        if (parts.length === 0) return last;\n        return `(${parts.join(', ')}, ${last})`;\n      };\n\n      // note: normalization happens later only if raw compilation fails\n      // Helper functions for GitHub Actions-style expressions\n      const contains = (searchString: string, searchValue: string): boolean =>\n        String(searchString).toLowerCase().includes(String(searchValue).toLowerCase());\n\n      const startsWith = (searchString: string, searchValue: string): boolean =>\n        String(searchString).toLowerCase().startsWith(String(searchValue).toLowerCase());\n\n      const endsWith = (searchString: string, searchValue: string): boolean =>\n        String(searchString).toLowerCase().endsWith(String(searchValue).toLowerCase());\n\n      const length = (value: string | unknown[] | Record<string, unknown>): number => {\n        if (typeof value === 'string' || Array.isArray(value)) {\n          return value.length;\n        }\n        if (value && typeof value === 'object') {\n          return Object.keys(value).length;\n        }\n        return 0;\n      };\n\n      const always = (): boolean => true;\n      const success = (): boolean => true;\n      const failure = (): boolean => false;\n\n      // Debug logging function for printing to console\n      const log = (...args: unknown[]): void => {\n        console.log('ðŸ” Debug:', ...args);\n      };\n\n      // Helper functions for array operations\n      const hasIssue = (issues: unknown[], field: string, value: unknown): boolean => {\n        if (!Array.isArray(issues)) return false;\n        return issues.some(issue => (issue as Record<string, unknown>)[field] === value);\n      };\n\n      const countIssues = (issues: unknown[], field: string, value: unknown): number => {\n        if (!Array.isArray(issues)) return 0;\n        return issues.filter(issue => (issue as Record<string, unknown>)[field] === value).length;\n      };\n\n      const hasFileMatching = (issues: unknown[], pattern: string): boolean => {\n        if (!Array.isArray(issues)) return false;\n        return issues.some(issue => (issue as { file?: string }).file?.includes(pattern));\n      };\n\n      // Backward compatibility aliases\n      const hasIssueWith = hasIssue;\n      const hasFileWith = hasFileMatching;\n\n      // Permission helper functions\n      const permissionHelpers = createPermissionHelpers(\n        context.authorAssociation,\n        detectLocalMode()\n      );\n      const hasMinPermission = permissionHelpers.hasMinPermission;\n      const isOwner = permissionHelpers.isOwner;\n      const isMember = permissionHelpers.isMember;\n      const isCollaborator = permissionHelpers.isCollaborator;\n      const isContributor = permissionHelpers.isContributor;\n      const isFirstTimer = permissionHelpers.isFirstTimer;\n\n      // Extract context variables\n      const output = context.output || {};\n      const issues = output.issues || [];\n\n      // Backward compatibility: provide metadata for transition period\n      // TODO: Remove after all configurations are updated\n      const metadata = context.metadata || {\n        checkName: context.checkName || '',\n        schema: context.schema || '',\n        group: context.group || '',\n        criticalIssues: issues.filter((i: { severity?: string }) => i.severity === 'critical')\n          .length,\n        errorIssues: issues.filter((i: { severity?: string }) => i.severity === 'error').length,\n        warningIssues: issues.filter((i: { severity?: string }) => i.severity === 'warning').length,\n        infoIssues: issues.filter((i: { severity?: string }) => i.severity === 'info').length,\n        totalIssues: issues.length,\n        hasChanges: context.hasChanges || false,\n      };\n\n      // Legacy variables for backward compatibility\n      const criticalIssues = metadata.criticalIssues;\n      const errorIssues = metadata.errorIssues;\n      const totalIssues = metadata.totalIssues;\n      const warningIssues = metadata.warningIssues;\n      const infoIssues = metadata.infoIssues;\n\n      // Additional context for 'if' conditions and some failure conditions\n      const checkName = context.checkName || '';\n      const schema = context.schema || '';\n      const group = context.group || '';\n      const branch = context.branch || 'unknown';\n      const baseBranch = context.baseBranch || 'main';\n      const filesChanged = context.filesChanged || [];\n      const filesCount = context.filesCount || 0;\n      const event = context.event || 'manual';\n      const env = context.env || {};\n      const outputs = context.outputs || {};\n      const debugData = context.debug || null;\n\n      // Get memory store and create accessor for fail_if expressions\n      const memoryStore = MemoryStore.getInstance();\n      const memoryAccessor = {\n        get: (key: string, ns?: string) => memoryStore.get(key, ns),\n        has: (key: string, ns?: string) => memoryStore.has(key, ns),\n        list: (ns?: string) => memoryStore.list(ns),\n        getAll: (ns?: string) => memoryStore.getAll(ns),\n      };\n\n      // Create scope with all context variables and helper functions\n      const scope = {\n        // Primary context variables\n        output,\n        outputs,\n        debug: debugData,\n        // Memory accessor for fail_if expressions\n        memory: memoryAccessor,\n        // Legacy compatibility variables\n        issues,\n        metadata,\n        criticalIssues,\n        errorIssues,\n        totalIssues,\n        warningIssues,\n        infoIssues,\n        // If condition context\n        checkName,\n        schema,\n        group,\n        branch,\n        baseBranch,\n        filesChanged,\n        filesCount,\n        event,\n        env,\n        // Helper functions\n        contains,\n        startsWith,\n        endsWith,\n        length,\n        always,\n        success,\n        failure,\n        log,\n        hasIssue,\n        countIssues,\n        hasFileMatching,\n        hasIssueWith,\n        hasFileWith,\n        // Permission helpers\n        hasMinPermission,\n        isOwner,\n        isMember,\n        isCollaborator,\n        isContributor,\n        isFirstTimer,\n      };\n\n      // Compile and execute the expression in the sandbox\n      const raw = condition.trim();\n      if (!this.sandbox) {\n        this.sandbox = this.createSecureSandbox();\n      }\n      let exec: ReturnType<typeof this.sandbox.compile>;\n      try {\n        // Try compiling the raw expression as-is first (supports multi-line logical expressions)\n        exec = this.sandbox.compile(`return (${raw});`);\n      } catch {\n        // Fallback: normalize multi-line statements into a comma-chain expression\n        const normalizedExpr = normalize(condition);\n        exec = this.sandbox.compile(`return (${normalizedExpr});`);\n      }\n      const result = exec(scope).run();\n      try {\n        require('./logger').logger.debug(`  fail_if: result=${Boolean(result)}`);\n      } catch {}\n      // Ensure we return a boolean\n      return Boolean(result);\n    } catch (error) {\n      console.error('âŒ Failed to evaluate expression:', condition, error);\n      // Re-throw the error so it can be caught at a higher level for error reporting\n      throw error;\n    }\n  }\n\n  /**\n   * Extract the expression from a failure condition\n   */\n  private extractExpression(condition: FailureCondition): string {\n    if (typeof condition === 'string') {\n      return condition;\n    }\n    return condition.condition;\n  }\n\n  /**\n   * Extract configuration from a failure condition\n   */\n  private extractConditionConfig(condition: FailureCondition): {\n    message?: string;\n    severity?: FailureConditionSeverity;\n    halt_execution?: boolean;\n  } {\n    if (typeof condition === 'string') {\n      return {};\n    }\n    return {\n      message: condition.message,\n      severity: condition.severity,\n      halt_execution: condition.halt_execution,\n    };\n  }\n\n  /**\n   * Build the evaluation context for expressions\n   */\n  private buildEvaluationContext(\n    checkName: string,\n    checkSchema: string,\n    checkGroup: string,\n    reviewSummary: ReviewSummary,\n    previousOutputs?: Record<string, ReviewSummary>,\n    authorAssociation?: string\n  ): FailureConditionContext {\n    const { issues, debug } = reviewSummary;\n    const reviewSummaryWithOutput = reviewSummary as ReviewSummary & { output?: unknown };\n\n    // Extract output field to avoid nesting (output.output)\n    const {\n      output: extractedOutput,\n      // Exclude issues from otherFields since we handle it separately\n      issues: _issues, // eslint-disable-line @typescript-eslint/no-unused-vars\n      ...otherFields\n    } = reviewSummaryWithOutput as any;\n\n    // Build output object with safety for array-based outputs (forEach aggregation)\n    const aggregatedOutput: Record<string, unknown> = {\n      issues: (issues || []).map(issue => ({\n        file: issue.file,\n        line: issue.line,\n        endLine: issue.endLine,\n        ruleId: issue.ruleId,\n        message: issue.message,\n        severity: issue.severity,\n        category: issue.category,\n        group: issue.group,\n        schema: issue.schema,\n        suggestion: issue.suggestion,\n        replacement: issue.replacement,\n      })),\n      // Include additional schema-specific data from reviewSummary\n      ...otherFields,\n    };\n\n    if (Array.isArray(extractedOutput)) {\n      // Preserve items array and lift common flags for convenience (e.g., output.error)\n      aggregatedOutput.items = extractedOutput;\n      const anyError = extractedOutput.find(\n        it => it && typeof it === 'object' && (it as Record<string, unknown>).error\n      ) as Record<string, unknown> | undefined;\n      if (anyError && anyError.error !== undefined) {\n        aggregatedOutput.error = anyError.error;\n      }\n    } else if (extractedOutput && typeof extractedOutput === 'object') {\n      Object.assign(aggregatedOutput, extractedOutput as Record<string, unknown>);\n    }\n\n    // If provider attached a raw transform snapshot, merge its fields generically.\n    try {\n      const raw = (reviewSummaryWithOutput as any).__raw;\n      if (raw && typeof raw === 'object') {\n        Object.assign(aggregatedOutput, raw as Record<string, unknown>);\n      }\n    } catch {}\n\n    // If output is a string, try to parse JSON (full or from end) to enrich context,\n    // and also derive common boolean flags generically (e.g., key:true/false) for fail_if usage.\n    try {\n      if (typeof extractedOutput === 'string') {\n        const parsed =\n          this.tryExtractJsonFromEnd(extractedOutput) ??\n          (() => {\n            try {\n              return JSON.parse(extractedOutput);\n            } catch {\n              return null;\n            }\n          })();\n        if (parsed !== null) {\n          if (Array.isArray(parsed)) {\n            (aggregatedOutput as any).items = parsed;\n          } else if (typeof parsed === 'object') {\n            Object.assign(aggregatedOutput, parsed as Record<string, unknown>);\n          }\n        }\n        // Generic boolean key extraction for simple text outputs (no special provider cases)\n        const lower = extractedOutput.toLowerCase();\n        const boolFrom = (key: string): boolean | null => {\n          const reTrue = new RegExp(\n            `(?:^|[^a-z0-9_])${key}[^a-z0-9_]*[:=][^a-z0-9_]*true(?:[^a-z0-9_]|$)`\n          );\n          const reFalse = new RegExp(\n            `(?:^|[^a-z0-9_])${key}[^a-z0-9_]*[:=][^a-z0-9_]*false(?:[^a-z0-9_]|$)`\n          );\n          if (reTrue.test(lower)) return true;\n          if (reFalse.test(lower)) return false;\n          return null;\n        };\n        const keys = ['error'];\n        for (const k of keys) {\n          const v = boolFrom(k);\n          if (v !== null && (aggregatedOutput as any)[k] === undefined) {\n            (aggregatedOutput as any)[k] = v;\n          }\n        }\n      }\n    } catch {}\n\n    // Try to parse JSON from content as a last resort when no structured output is present\n    try {\n      const rsAny = reviewSummaryWithOutput as any;\n      const hasStructuredOutput = extractedOutput !== undefined && extractedOutput !== null;\n      if (!hasStructuredOutput && typeof rsAny?.content === 'string') {\n        const parsedFromContent = this.tryExtractJsonFromEnd(rsAny.content);\n        if (parsedFromContent !== null && parsedFromContent !== undefined) {\n          if (Array.isArray(parsedFromContent)) {\n            (aggregatedOutput as any).items = parsedFromContent;\n          } else if (typeof parsedFromContent === 'object') {\n            Object.assign(aggregatedOutput, parsedFromContent as Record<string, unknown>);\n          }\n        }\n      }\n    } catch {}\n\n    // Get memory store instance\n    const memoryStore = MemoryStore.getInstance();\n\n    const context: FailureConditionContext = {\n      output: aggregatedOutput,\n      outputs: (() => {\n        if (!previousOutputs) return {};\n        const outputs: Record<string, unknown> = {};\n        for (const [checkName, result] of Object.entries(previousOutputs)) {\n          // If the result has a direct output field, use it directly\n          // Otherwise, expose the entire result as-is\n          const summary = result as ReviewSummary & { output?: unknown };\n          outputs[checkName] = summary.output !== undefined ? summary.output : summary;\n        }\n        return outputs;\n      })(),\n      // Add memory accessor for fail_if expressions\n      memory: {\n        get: (key: string, ns?: string) => memoryStore.get(key, ns),\n        has: (key: string, ns?: string) => memoryStore.has(key, ns),\n        list: (ns?: string) => memoryStore.list(ns),\n        getAll: (ns?: string) => memoryStore.getAll(ns),\n      } as any,\n      // Add basic context info for failure conditions\n      checkName: checkName,\n      schema: checkSchema,\n      group: checkGroup,\n      authorAssociation: authorAssociation,\n    };\n\n    // Add debug information if available\n    if (debug) {\n      context.debug = {\n        errors: debug.errors || [],\n        processingTime: debug.processingTime || 0,\n        provider: debug.provider || 'unknown',\n        model: debug.model || 'unknown',\n      };\n    }\n\n    return context;\n  }\n\n  // Minimal JSON-from-end extractor for fail_if context fallback\n  private tryExtractJsonFromEnd(text: string): unknown | null {\n    try {\n      const lines = text.split('\\n');\n      for (let i = lines.length - 1; i >= 0; i--) {\n        const t = lines[i].trim();\n        if (t.startsWith('{') || t.startsWith('[')) {\n          const candidate = lines.slice(i).join('\\n').trim();\n          if (\n            (candidate.startsWith('{') && candidate.endsWith('}')) ||\n            (candidate.startsWith('[') && candidate.endsWith(']'))\n          ) {\n            return JSON.parse(candidate);\n          }\n        }\n      }\n    } catch {}\n    return null;\n  }\n\n  /**\n   * Check if any failure condition requires halting execution\n   */\n  static shouldHaltExecution(results: FailureConditionResult[]): boolean {\n    return results.some(result => result.failed && result.haltExecution);\n  }\n\n  /**\n   * Get all failed conditions\n   */\n  static getFailedConditions(results: FailureConditionResult[]): FailureConditionResult[] {\n    return results.filter(result => result.failed);\n  }\n\n  /**\n   * Group results by severity\n   */\n  static groupResultsBySeverity(results: FailureConditionResult[]): {\n    error: FailureConditionResult[];\n    warning: FailureConditionResult[];\n    info: FailureConditionResult[];\n  } {\n    return {\n      // Only 'error' severity now (no backward compatibility needed here as this is internal)\n      error: results.filter(r => r.severity === 'error'),\n      warning: results.filter(r => r.severity === 'warning'),\n      info: results.filter(r => r.severity === 'info'),\n    };\n  }\n\n  /**\n   * Format results for display\n   */\n  static formatResults(results: FailureConditionResult[]): string {\n    const failed = FailureConditionEvaluator.getFailedConditions(results);\n\n    if (failed.length === 0) {\n      return 'âœ… All failure conditions passed';\n    }\n\n    const grouped = FailureConditionEvaluator.groupResultsBySeverity(failed);\n    const sections: string[] = [];\n\n    if (grouped.error.length > 0) {\n      sections.push(`âŒ **Error severity conditions (${grouped.error.length}):**`);\n      grouped.error.forEach(result => {\n        sections.push(`  - ${result.conditionName}: ${result.message || result.expression}`);\n      });\n    }\n\n    if (grouped.warning.length > 0) {\n      sections.push(`âš ï¸ **Warning conditions (${grouped.warning.length}):**`);\n      grouped.warning.forEach(result => {\n        sections.push(`  - ${result.conditionName}: ${result.message || result.expression}`);\n      });\n    }\n\n    if (grouped.info.length > 0) {\n      sections.push(`â„¹ï¸ **Info conditions (${grouped.info.length}):**`);\n      grouped.info.forEach(result => {\n        sections.push(`  - ${result.conditionName}: ${result.message || result.expression}`);\n      });\n    }\n\n    return sections.join('\\n');\n  }\n}\n","/*\n * Internal snapshot store for incremental adoption of snapshot+scope execution.\n * Phase 0: journal only â€” no behavior change, used for future visibility work.\n */\n\nimport type { ReviewSummary } from './reviewer';\nimport type { EventTrigger } from './types/config';\n\nexport type ScopePath = Array<{ check: string; index: number }>;\n\nexport interface JournalEntry {\n  commitId: number;\n  sessionId: string;\n  scope: ScopePath;\n  checkId: string;\n  event: EventTrigger | undefined;\n  result: ReviewSummary & { output?: unknown; content?: string };\n}\n\nexport class ExecutionJournal {\n  private commit = 0;\n  private entries: JournalEntry[] = [];\n\n  beginSnapshot(): number {\n    return this.commit;\n  }\n\n  commitEntry(entry: {\n    sessionId: string;\n    scope: ScopePath;\n    checkId: string;\n    result: ReviewSummary & { output?: unknown; content?: string };\n    event?: EventTrigger;\n  }): JournalEntry {\n    const committed: JournalEntry = {\n      sessionId: entry.sessionId,\n      scope: entry.scope,\n      checkId: entry.checkId,\n      result: entry.result,\n      event: entry.event,\n      commitId: ++this.commit,\n    };\n    this.entries.push(committed);\n    return committed;\n  }\n\n  readVisible(sessionId: string, commitMax: number, event?: EventTrigger): JournalEntry[] {\n    return this.entries.filter(\n      e =>\n        e.sessionId === sessionId && e.commitId <= commitMax && (event ? e.event === event : true)\n    );\n  }\n\n  // Lightweight helpers for debugging/metrics\n  size(): number {\n    return this.entries.length;\n  }\n}\n\nexport class ContextView {\n  constructor(\n    private journal: ExecutionJournal,\n    private sessionId: string,\n    private snapshotId: number,\n    private scope: ScopePath,\n    private event?: EventTrigger\n  ) {}\n\n  /** Return the nearest result for a check in this scope (exact item â†’ ancestor â†’ latest). */\n  get(checkId: string): (ReviewSummary & { output?: unknown; content?: string }) | undefined {\n    const visible = this.journal\n      .readVisible(this.sessionId, this.snapshotId, this.event)\n      .filter(e => e.checkId === checkId);\n    if (visible.length === 0) return undefined;\n\n    // exact scope match\n    const exact = visible.find(e => this.sameScope(e.scope, this.scope));\n    if (exact) return exact.result;\n\n    // nearest ancestor (shortest distance)\n    let best: { entry: JournalEntry; dist: number } | undefined;\n    for (const e of visible) {\n      const dist = this.ancestorDistance(e.scope, this.scope);\n      if (dist >= 0 && (best === undefined || dist < best.dist)) {\n        best = { entry: e, dist };\n      }\n    }\n    if (best) return best.entry.result;\n\n    // fallback to latest committed result\n    return visible[visible.length - 1]?.result;\n  }\n\n  /** Return an aggregate (raw) result â€“ the shallowest scope for this check. */\n  getRaw(checkId: string): (ReviewSummary & { output?: unknown; content?: string }) | undefined {\n    const visible = this.journal\n      .readVisible(this.sessionId, this.snapshotId, this.event)\n      .filter(e => e.checkId === checkId);\n    if (visible.length === 0) return undefined;\n    let shallow = visible[0];\n    for (const e of visible) {\n      if (e.scope.length < shallow.scope.length) shallow = e;\n    }\n    return shallow.result;\n  }\n\n  /** All results for a check up to this snapshot. */\n  getHistory(checkId: string): Array<ReviewSummary & { output?: unknown; content?: string }> {\n    return this.journal\n      .readVisible(this.sessionId, this.snapshotId, this.event)\n      .filter(e => e.checkId === checkId)\n      .map(e => e.result);\n  }\n\n  private sameScope(a: ScopePath, b: ScopePath): boolean {\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (a[i].check !== b[i].check || a[i].index !== b[i].index) return false;\n    }\n    return true;\n  }\n\n  // distance from ancestor to current; -1 if not ancestor\n  private ancestorDistance(ancestor: ScopePath, current: ScopePath): number {\n    if (ancestor.length > current.length) return -1;\n    // Treat root scope ([]) as non-ancestor for unrelated branches\n    if (ancestor.length === 0 && current.length > 0) return -1;\n    for (let i = 0; i < ancestor.length; i++) {\n      if (ancestor[i].check !== current[i].check || ancestor[i].index !== current[i].index)\n        return -1;\n    }\n    return current.length - ancestor.length;\n  }\n}\n","/**\n * Routing State Handler\n *\n * Responsibilities:\n * - Evaluate fail_if conditions after check execution\n * - Process on_success, on_fail, on_finish triggers\n * - Enqueue ForwardRunRequested events for goto\n * - Enqueue WaveRetry events for routing loops\n * - Transition back to WavePlanning or Completed\n *\n * M2: Core routing logic implementation\n */\n\nimport type {\n  EngineContext,\n  RunState,\n  EngineState,\n  EngineEvent\n} from '../../types/engine';\nimport type { ReviewSummary, ReviewIssue } from '../../reviewer';\nimport type { CheckConfig, OnFailConfig } from '../../types/config';\nimport { logger } from '../../logger';\nimport { FailureConditionEvaluator } from '../../failure-condition-evaluator';\nimport { createSecureSandbox, compileAndRun } from '../../utils/sandbox';\n\n/**\n * Context for a check that just completed and needs routing evaluation\n */\ninterface RoutingContext {\n  checkId: string;\n  scope: Array<{ check: string; index: number }>;\n  result: ReviewSummary;\n  checkConfig: CheckConfig;\n  success: boolean; // true if no fatal issues\n}\n\n/**\n * Handle routing state - evaluate conditions and decide next actions\n */\nexport async function handleRouting(\n  context: EngineContext,\n  state: RunState,\n  transition: (newState: EngineState) => void,\n  emitEvent: (event: EngineEvent) => void,\n  routingContext: RoutingContext\n): Promise<void> {\n  const { checkId, scope, result, checkConfig, success } = routingContext;\n\n  if (context.debug) {\n    logger.info(`[Routing] Evaluating routing for check: ${checkId}, success: ${success}`);\n  }\n\n  // Step 1: Evaluate fail_if conditions\n  const failIfTriggered = await evaluateFailIf(\n    checkId,\n    result,\n    checkConfig,\n    context,\n    state\n  );\n\n  if (failIfTriggered) {\n    if (context.debug) {\n      logger.info(`[Routing] fail_if triggered for ${checkId}`);\n    }\n\n    // Treat as failure for routing purposes\n    await processOnFail(checkId, scope, result, checkConfig, context, state, emitEvent);\n  } else if (success) {\n    // Step 2: Process on_success routing\n    await processOnSuccess(checkId, scope, result, checkConfig, context, state, emitEvent);\n  } else {\n    // Step 3: Process on_fail routing\n    await processOnFail(checkId, scope, result, checkConfig, context, state, emitEvent);\n  }\n\n  // Step 4: Check if this is a forEach parent with on_finish\n  // M4: Basic on_finish support for loop budget enforcement\n  // NOTE: For forEach parent checks, on_finish is processed AFTER the forEach children complete\n  // (see level-dispatch.ts executeCheckWithForEachItems), not immediately after the parent completes.\n  // This ensures outputs_history contains the forEach children results.\n  // Only process on_finish here for non-forEach checks OR forEach checks that won't spawn children.\n  // A forEach check will spawn children only if it has isForEach flag and there are checks depending on it.\n  // If the result has forEachItems but no dependent checks will execute, process on_finish here.\n  const willSpawnForEachChildren = checkConfig.forEach && (result as any).isForEach;\n\n  if (checkConfig.on_finish && !willSpawnForEachChildren) {\n    await processOnFinish(checkId, scope, result, checkConfig, context, state, emitEvent);\n  }\n\n  // Transition back to WavePlanning to process queued events\n  transition('WavePlanning');\n}\n\n/**\n * Process on_finish routing\n */\nasync function processOnFinish(\n  checkId: string,\n  scope: Array<{ check: string; index: number }>,\n  result: ReviewSummary,\n  checkConfig: CheckConfig,\n  context: EngineContext,\n  state: RunState,\n  emitEvent: (event: EngineEvent) => void\n): Promise<void> {\n  const onFinish = checkConfig.on_finish;\n\n  if (!onFinish) {\n    return; // No on_finish configuration\n  }\n\n  // Log at info level so it's visible in test output\n  logger.info(`Processing on_finish for ${checkId}`);\n\n  // Process on_finish.run\n  if (onFinish.run && onFinish.run.length > 0) {\n    for (const targetCheck of onFinish.run) {\n      // Check loop budget before scheduling\n      if (checkLoopBudget(context, state, 'on_finish', 'run')) {\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_finish run`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return;\n      }\n\n      if (context.debug) {\n        logger.info(`[Routing] on_finish.run: scheduling ${targetCheck}`);\n      }\n\n      // Increment loop count\n      state.routingLoopCount++;\n\n      emitEvent({\n        type: 'ForwardRunRequested',\n        target: targetCheck,\n        scope,\n      });\n    }\n  }\n\n  // Process on_finish.run_js\n  if (onFinish.run_js) {\n    const dynamicTargets = await evaluateRunJs(\n      onFinish.run_js,\n      checkId,\n      checkConfig,\n      result,\n      context,\n      state\n    );\n\n    for (const targetCheck of dynamicTargets) {\n      // Check loop budget before scheduling\n      if (checkLoopBudget(context, state, 'on_finish', 'run')) {\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_finish run`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return;\n      }\n\n      if (context.debug) {\n        logger.info(`[Routing] on_finish.run_js: scheduling ${targetCheck}`);\n      }\n\n      // Increment loop count\n      state.routingLoopCount++;\n\n      emitEvent({\n        type: 'ForwardRunRequested',\n        target: targetCheck,\n        scope,\n      });\n    }\n  }\n\n  // Process on_finish.goto / goto_js\n  const gotoTarget = await evaluateGoto(\n    onFinish.goto_js,\n    onFinish.goto,\n    checkId,\n    checkConfig,\n    result,\n    context,\n    state\n  );\n\n  if (gotoTarget) {\n    // Check loop budget before scheduling goto\n    if (checkLoopBudget(context, state, 'on_finish', 'goto')) {\n      const errorIssue: ReviewIssue = {\n        file: 'system',\n        line: 0,\n        ruleId: `${checkId}/routing/loop_budget_exceeded`,\n        message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_finish goto`,\n        severity: 'error',\n        category: 'logic',\n      };\n      result.issues = [...(result.issues || []), errorIssue];\n      return;\n    }\n\n    if (context.debug) {\n      logger.info(`[Routing] on_finish.goto: ${gotoTarget}`);\n    }\n\n    // Increment loop count\n    state.routingLoopCount++;\n\n    // Enqueue forward run event\n    emitEvent({\n      type: 'ForwardRunRequested',\n      target: gotoTarget,\n      scope,\n    });\n\n    // Mark that we've seen a forward run\n    state.flags.forwardRunRequested = true;\n  }\n}\n\n/**\n * Evaluate fail_if conditions for a check\n */\nasync function evaluateFailIf(\n  checkId: string,\n  result: ReviewSummary,\n  checkConfig: CheckConfig,\n  context: EngineContext,\n  state: RunState\n): Promise<boolean> {\n  const config = context.config;\n\n  // Check for fail_if at global or check level\n  const globalFailIf = config.fail_if;\n  const checkFailIf = checkConfig.fail_if;\n\n  if (!globalFailIf && !checkFailIf) {\n    return false; // No fail_if conditions\n  }\n\n  const evaluator = new FailureConditionEvaluator();\n\n  // Build outputs record from state\n  const outputsRecord: Record<string, ReviewSummary> = {};\n  for (const [key] of state.stats.entries()) {\n    // Try to get the actual result from context.journal if available\n    try {\n      const snapshotId = context.journal.beginSnapshot();\n      const contextView = new (require('../../snapshot-store').ContextView)(\n        context.journal,\n        context.sessionId,\n        snapshotId,\n        [],\n        context.event\n      );\n      const journalResult = contextView.get(key);\n      if (journalResult) {\n        outputsRecord[key] = journalResult as ReviewSummary;\n      }\n    } catch {\n      // Fallback to empty result\n      outputsRecord[key] = { issues: [] };\n    }\n  }\n\n  const checkSchema = typeof checkConfig.schema === 'object' ? 'custom' : checkConfig.schema || '';\n  const checkGroup = checkConfig.group || '';\n\n  // Evaluate global fail_if\n  if (globalFailIf) {\n    try {\n      const failed = await evaluator.evaluateSimpleCondition(\n        checkId,\n        checkSchema,\n        checkGroup,\n        result,\n        globalFailIf,\n        outputsRecord\n      );\n\n      if (failed) {\n        logger.warn(`[Routing] Global fail_if triggered for ${checkId}: ${globalFailIf}`);\n\n        // Add fail_if issue to result\n        const failIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: 'global_fail_if',\n          message: `Global failure condition met: ${globalFailIf}`,\n          severity: 'error',\n          category: 'logic',\n        };\n\n        result.issues = [...(result.issues || []), failIssue];\n        return true;\n      }\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : String(error);\n      logger.error(`[Routing] Error evaluating global fail_if: ${msg}`);\n    }\n  }\n\n  // Evaluate check-specific fail_if\n  if (checkFailIf) {\n    try {\n      const failed = await evaluator.evaluateSimpleCondition(\n        checkId,\n        checkSchema,\n        checkGroup,\n        result,\n        checkFailIf,\n        outputsRecord\n      );\n\n      if (failed) {\n        logger.warn(`[Routing] Check fail_if triggered for ${checkId}: ${checkFailIf}`);\n\n        // Add fail_if issue to result\n        const failIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}_fail_if`,\n          message: `Check failure condition met: ${checkFailIf}`,\n          severity: 'error',\n          category: 'logic',\n        };\n\n        result.issues = [...(result.issues || []), failIssue];\n        return true;\n      }\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : String(error);\n      logger.error(`[Routing] Error evaluating check fail_if: ${msg}`);\n    }\n  }\n\n  return false;\n}\n\n/**\n * Check if routing loop budget is exceeded\n */\nexport function checkLoopBudget(\n  context: EngineContext,\n  state: RunState,\n  origin: 'on_success' | 'on_fail' | 'on_finish',\n  action: 'run' | 'goto'\n): boolean {\n  const maxLoops = context.config.routing?.max_loops ?? 10;\n\n  if (state.routingLoopCount >= maxLoops) {\n    const msg = `Routing loop budget exceeded (max_loops=${maxLoops}) during ${origin} ${action}`;\n    logger.error(`[Routing] ${msg}`);\n    return true; // Budget exceeded\n  }\n\n  return false; // Budget OK\n}\n\n/**\n * Process on_success routing\n */\nasync function processOnSuccess(\n  checkId: string,\n  scope: Array<{ check: string; index: number }>,\n  result: ReviewSummary,\n  checkConfig: CheckConfig,\n  context: EngineContext,\n  state: RunState,\n  emitEvent: (event: EngineEvent) => void\n): Promise<void> {\n  const onSuccess = checkConfig.on_success;\n\n  if (!onSuccess) {\n    return; // No on_success configuration\n  }\n\n  if (context.debug) {\n    logger.info(`[Routing] Processing on_success for ${checkId}`);\n  }\n\n  // Process on_success.run\n  if (onSuccess.run && onSuccess.run.length > 0) {\n    for (const targetCheck of onSuccess.run) {\n      // Check loop budget before scheduling\n      if (checkLoopBudget(context, state, 'on_success', 'run')) {\n        // Add error issue to result\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_success run`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return; // Stop processing\n      }\n\n      if (context.debug) {\n        logger.info(`[Routing] on_success.run: scheduling ${targetCheck}`);\n      }\n\n      // Increment loop count\n      state.routingLoopCount++;\n\n      // Enqueue the check to run in next wave\n      emitEvent({\n        type: 'ForwardRunRequested',\n        target: targetCheck,\n        scope,\n      });\n    }\n  }\n\n  // Process on_success.run_js\n  if (onSuccess.run_js) {\n    const dynamicTargets = await evaluateRunJs(\n      onSuccess.run_js,\n      checkId,\n      checkConfig,\n      result,\n      context,\n      state\n    );\n\n    for (const targetCheck of dynamicTargets) {\n      // Check loop budget before scheduling\n      if (checkLoopBudget(context, state, 'on_success', 'run')) {\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_success run`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return;\n      }\n\n      if (context.debug) {\n        logger.info(`[Routing] on_success.run_js: scheduling ${targetCheck}`);\n      }\n\n      // Increment loop count\n      state.routingLoopCount++;\n\n      emitEvent({\n        type: 'ForwardRunRequested',\n        target: targetCheck,\n        scope,\n      });\n    }\n  }\n\n  // Process on_success.goto / goto_js\n  const gotoTarget = await evaluateGoto(\n    onSuccess.goto_js,\n    onSuccess.goto,\n    checkId,\n    checkConfig,\n    result,\n    context,\n    state\n  );\n\n  if (gotoTarget) {\n    // Check loop budget before scheduling goto\n    if (checkLoopBudget(context, state, 'on_success', 'goto')) {\n      const errorIssue: ReviewIssue = {\n        file: 'system',\n        line: 0,\n        ruleId: `${checkId}/routing/loop_budget_exceeded`,\n        message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_success goto`,\n        severity: 'error',\n        category: 'logic',\n      };\n      result.issues = [...(result.issues || []), errorIssue];\n      return;\n    }\n\n    if (context.debug) {\n      logger.info(`[Routing] on_success.goto: ${gotoTarget}`);\n    }\n\n    // Increment loop count\n    state.routingLoopCount++;\n\n    // Enqueue forward run event with optional event override\n    emitEvent({\n      type: 'ForwardRunRequested',\n      target: gotoTarget,\n      gotoEvent: onSuccess.goto_event,\n      scope,\n    });\n\n    // Mark that we've seen a forward run\n    state.flags.forwardRunRequested = true;\n  }\n}\n\n/**\n * Process on_fail routing\n */\nasync function processOnFail(\n  checkId: string,\n  scope: Array<{ check: string; index: number }>,\n  result: ReviewSummary,\n  checkConfig: CheckConfig,\n  context: EngineContext,\n  state: RunState,\n  emitEvent: (event: EngineEvent) => void\n): Promise<void> {\n  // Merge defaults with check-specific on_fail\n  const defaults = context.config.routing?.defaults?.on_fail || {};\n  const onFail: OnFailConfig | undefined = checkConfig.on_fail\n    ? { ...defaults, ...checkConfig.on_fail }\n    : undefined;\n\n  if (!onFail) {\n    return; // No on_fail configuration\n  }\n\n  if (context.debug) {\n    logger.info(`[Routing] Processing on_fail for ${checkId}`);\n  }\n\n  // Process on_fail.run\n  if (onFail.run && onFail.run.length > 0) {\n    for (const targetCheck of onFail.run) {\n      // Check loop budget before scheduling\n      if (checkLoopBudget(context, state, 'on_fail', 'run')) {\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_fail run`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return;\n      }\n\n      if (context.debug) {\n        logger.info(`[Routing] on_fail.run: scheduling ${targetCheck}`);\n      }\n\n      // Increment loop count\n      state.routingLoopCount++;\n\n      emitEvent({\n        type: 'ForwardRunRequested',\n        target: targetCheck,\n        scope,\n      });\n    }\n  }\n\n  // Process on_fail.run_js\n  if (onFail.run_js) {\n    const dynamicTargets = await evaluateRunJs(\n      onFail.run_js,\n      checkId,\n      checkConfig,\n      result,\n      context,\n      state\n    );\n\n    for (const targetCheck of dynamicTargets) {\n      // Check loop budget before scheduling\n      if (checkLoopBudget(context, state, 'on_fail', 'run')) {\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_fail run`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return;\n      }\n\n      if (context.debug) {\n        logger.info(`[Routing] on_fail.run_js: scheduling ${targetCheck}`);\n      }\n\n      // Increment loop count\n      state.routingLoopCount++;\n\n      emitEvent({\n        type: 'ForwardRunRequested',\n        target: targetCheck,\n        scope,\n      });\n    }\n  }\n\n  // Process on_fail.goto / goto_js\n  const gotoTarget = await evaluateGoto(\n    onFail.goto_js,\n    onFail.goto,\n    checkId,\n    checkConfig,\n    result,\n    context,\n    state\n  );\n\n  if (gotoTarget) {\n    // Check loop budget before scheduling goto\n    if (checkLoopBudget(context, state, 'on_fail', 'goto')) {\n      const errorIssue: ReviewIssue = {\n        file: 'system',\n        line: 0,\n        ruleId: `${checkId}/routing/loop_budget_exceeded`,\n        message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_fail goto`,\n        severity: 'error',\n        category: 'logic',\n      };\n      result.issues = [...(result.issues || []), errorIssue];\n      return;\n    }\n\n    if (context.debug) {\n      logger.info(`[Routing] on_fail.goto: ${gotoTarget}`);\n    }\n\n    // Increment loop count\n    state.routingLoopCount++;\n\n    // Enqueue forward run event with optional event override\n    emitEvent({\n      type: 'ForwardRunRequested',\n      target: gotoTarget,\n      gotoEvent: onFail.goto_event,\n      scope,\n    });\n\n    // Mark that we've seen a forward run\n    state.flags.forwardRunRequested = true;\n  }\n}\n\n/**\n * Evaluate run_js expression to get dynamic check targets\n */\nasync function evaluateRunJs(\n  runJs: string,\n  checkId: string,\n  checkConfig: CheckConfig,\n  result: ReviewSummary,\n  context: EngineContext,\n  state: RunState\n): Promise<string[]> {\n  try {\n    const sandbox = createSecureSandbox();\n\n    // Build outputs record and outputs_history\n    const snapshotId = context.journal.beginSnapshot();\n    const contextView = new (require('../../snapshot-store').ContextView)(\n      context.journal,\n      context.sessionId,\n      snapshotId,\n      [],\n      context.event\n    );\n\n    const outputsRecord: Record<string, any> = {};\n    const outputsHistory: Record<string, any[]> = {};\n\n    // Get all visible journal entries to build complete history\n    const allEntries = context.journal.readVisible(context.sessionId, snapshotId, context.event);\n    const uniqueCheckIds = new Set(allEntries.map(e => e.checkId));\n\n    for (const checkIdFromJournal of uniqueCheckIds) {\n      try {\n        // Get current output for this check\n        const journalResult = contextView.get(checkIdFromJournal);\n        if (journalResult) {\n          outputsRecord[checkIdFromJournal] = journalResult;\n        }\n      } catch {\n        outputsRecord[checkIdFromJournal] = { issues: [] };\n      }\n\n      // Build history for this check\n      try {\n        const history = contextView.getHistory(checkIdFromJournal);\n        if (history && history.length > 0) {\n          // Extract outputs from history (prefer output field if available)\n          outputsHistory[checkIdFromJournal] = history.map((r: any) => r.output !== undefined ? r.output : r);\n        }\n      } catch {\n        // Ignore history errors\n      }\n    }\n\n    const scopeObj: any = {\n      step: {\n        id: checkId,\n        tags: checkConfig.tags || [],\n        group: checkConfig.group\n      },\n      outputs: outputsRecord,\n      outputs_history: outputsHistory,\n      output: (result as any)?.output,\n      event: {\n        name: context.event || 'manual'\n      },\n    };\n\n    const code = `\n      const step = scope.step;\n      const outputs = scope.outputs;\n      const outputs_history = scope.outputs_history;\n      const output = scope.output;\n      const event = scope.event;\n      const log = (...args) => console.log('ðŸ” Debug:', ...args);\n      const __fn = () => {\n        ${runJs}\n      };\n      const __res = __fn();\n      return Array.isArray(__res) ? __res.filter(x => typeof x === 'string' && x) : [];\n    `;\n\n    const evalResult = compileAndRun<string[]>(\n      sandbox,\n      code,\n      { scope: scopeObj },\n      { injectLog: false, wrapFunction: false }\n    );\n\n    return Array.isArray(evalResult) ? evalResult.filter(Boolean) : [];\n  } catch (error) {\n    const msg = error instanceof Error ? error.message : String(error);\n    logger.error(`[Routing] Error evaluating run_js: ${msg}`);\n    return [];\n  }\n}\n\n/**\n * Evaluate goto_js or return static goto target\n */\nexport async function evaluateGoto(\n  gotoJs: string | undefined,\n  gotoStatic: string | undefined,\n  checkId: string,\n  checkConfig: CheckConfig,\n  result: ReviewSummary,\n  context: EngineContext,\n  state: RunState\n): Promise<string | null> {\n  // Evaluate goto_js first\n  if (gotoJs) {\n    try {\n      const sandbox = createSecureSandbox();\n\n      // Build outputs record and outputs_history\n      const snapshotId = context.journal.beginSnapshot();\n      const contextView = new (require('../../snapshot-store').ContextView)(\n        context.journal,\n        context.sessionId,\n        snapshotId,\n        [],\n        context.event\n      );\n\n      const outputsRecord: Record<string, any> = {};\n      const outputsHistory: Record<string, any[]> = {};\n\n      // Get all visible journal entries to build complete history\n      const allEntries = context.journal.readVisible(context.sessionId, snapshotId, context.event);\n      const uniqueCheckIds = new Set(allEntries.map(e => e.checkId));\n\n      for (const checkIdFromJournal of uniqueCheckIds) {\n        try {\n          // Get current output for this check\n          const journalResult = contextView.get(checkIdFromJournal);\n          if (journalResult) {\n            outputsRecord[checkIdFromJournal] = journalResult;\n          }\n        } catch {\n          outputsRecord[checkIdFromJournal] = { issues: [] };\n        }\n\n        // Build history for this check\n        try {\n          const history = contextView.getHistory(checkIdFromJournal);\n          if (history && history.length > 0) {\n            // Extract outputs from history (prefer output field if available)\n            outputsHistory[checkIdFromJournal] = history.map((r: any) => r.output !== undefined ? r.output : r);\n          }\n        } catch {\n          // Ignore history errors\n        }\n      }\n\n      const scopeObj: any = {\n        step: {\n          id: checkId,\n          tags: checkConfig.tags || [],\n          group: checkConfig.group\n        },\n        outputs: outputsRecord,\n        outputs_history: outputsHistory,\n        output: (result as any)?.output,\n        event: {\n          name: context.event || 'manual'\n        },\n      };\n\n      // Debug: Log outputs_history\n      if (context.debug) {\n        logger.info(`[Routing] evaluateGoto: checkId=${checkId}, outputs_history keys=${Object.keys(outputsHistory).join(',')}`);\n        for (const [key, values] of Object.entries(outputsHistory)) {\n          logger.info(`[Routing]   ${key}: ${values.length} items`);\n        }\n      }\n\n      const code = `\n        const step = scope.step;\n        const outputs = scope.outputs;\n        const outputs_history = scope.outputs_history;\n        const output = scope.output;\n        const event = scope.event;\n        const log = (...args) => console.log('ðŸ” Debug:', ...args);\n        ${gotoJs}\n      `;\n\n      const evalResult = compileAndRun<string | null>(\n        sandbox,\n        code,\n        { scope: scopeObj },\n        { injectLog: false, wrapFunction: true }\n      );\n\n      if (context.debug) {\n        logger.info(`[Routing] evaluateGoto result: ${evalResult}`);\n      }\n\n      if (typeof evalResult === 'string' && evalResult) {\n        return evalResult;\n      }\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : String(error);\n      logger.error(`[Routing] Error evaluating goto_js: ${msg}`);\n\n      // Fall back to static goto if available\n      if (gotoStatic) {\n        logger.info(`[Routing] Falling back to static goto: ${gotoStatic}`);\n        return gotoStatic;\n      }\n    }\n  }\n\n  // Return static goto\n  return gotoStatic || null;\n}\n"],"mappings":"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","names":["context","emitNdjsonSpanWithEvents","context","emitNdjsonSpanWithEvents","checkName","issues","hasMinPermission","isOwner","isMember","isCollaborator","isContributor","isFirstTimer","context"]}