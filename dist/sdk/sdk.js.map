{"version":3,"sources":["../../src/logger.ts","../../src/footer.ts","../../src/github-comments.ts","../../src/utils/tracer-init.ts","../../src/session-registry.ts","../../src/utils/diff-processor.ts","../../src/ai-review-service.ts","../../src/reviewer.ts","../../src/utils/file-exclusion.ts","../../src/git-repository-analyzer.ts","../../src/pr-analyzer.ts","../../src/providers/check-provider.interface.ts","../../src/utils/env-resolver.ts","../../src/issue-filter.ts","../../src/utils/author-permissions.ts","../../src/memory-store.ts","../../src/liquid-extensions.ts","../../src/telemetry/lazy-otel.ts","../../src/telemetry/state-capture.ts","../../src/telemetry/fallback-ndjson.ts","../../src/providers/ai-check-provider.ts","../../src/providers/http-check-provider.ts","../../src/providers/http-input-provider.ts","../../src/providers/http-client-provider.ts","../../src/providers/noop-check-provider.ts","../../src/providers/log-check-provider.ts","../../src/utils/sandbox.ts","../../src/test-runner/recorders/global-recorder.ts","../../src/providers/github-ops-provider.ts","../../src/providers/claude-code-types.ts","../../src/providers/claude-code-check-provider.ts","../../src/utils/command-executor.ts","../../src/utils/env-exposure.ts","../../src/providers/command-check-provider.ts","../../src/utils/template-context.ts","../../src/utils/script-memory-ops.ts","../../src/providers/memory-check-provider.ts","../../src/providers/custom-tool-executor.ts","../../src/providers/mcp-check-provider.ts","../../src/utils/interactive-prompt.ts","../../src/utils/stdin-reader.ts","../../src/providers/human-input-check-provider.ts","../../src/providers/script-check-provider.ts","../../src/dependency-resolver.ts","../../src/workflow-registry.ts","../../src/workflow-executor.ts","../../src/providers/workflow-check-provider.ts","../../src/providers/check-provider-registry.ts","../../src/telemetry/trace-helpers.ts","../../src/telemetry/metrics.ts","../../src/failure-condition-evaluator.ts","../../src/github-check-service.ts","../../src/snapshot-store.ts","../../src/engine/on-finish/utils.ts","../../src/engine/on-finish/orchestrator.ts","../../src/utils/mermaid-telemetry.ts","../../src/check-execution-engine.ts","../../src/utils/config-merger.ts","../../src/generated/config-schema.ts","../../src/sdk.ts","../../src/config.ts","../../src/utils/config-loader.ts"],"sourcesContent":["/*\n * Centralized logger for Visor CLI and Action modes.\n * - Respects output format (suppresses info in JSON/SARIF unless debug)\n * - Supports levels: silent < error < warn < info < verbose < debug\n * - Routes logs to stderr to keep stdout clean for machine-readable output\n */\n\nexport type LogLevel = 'silent' | 'error' | 'warn' | 'info' | 'verbose' | 'debug';\n\nfunction levelToNumber(level: LogLevel): number {\n  switch (level) {\n    case 'silent':\n      return 0;\n    case 'error':\n      return 10;\n    case 'warn':\n      return 20;\n    case 'info':\n      return 30;\n    case 'verbose':\n      return 40;\n    case 'debug':\n      return 50;\n  }\n}\n\nclass Logger {\n  private level: LogLevel = 'info';\n  private isJsonLike: boolean = false;\n  private isTTY: boolean = typeof process !== 'undefined' ? !!process.stderr.isTTY : false;\n\n  configure(\n    opts: {\n      outputFormat?: string;\n      level?: LogLevel;\n      debug?: boolean;\n      verbose?: boolean;\n      quiet?: boolean;\n    } = {}\n  ): void {\n    // Determine base level\n    let lvl: LogLevel = 'info';\n\n    if (opts.debug || process.env.VISOR_DEBUG === 'true') {\n      lvl = 'debug';\n    } else if (opts.verbose || process.env.VISOR_LOG_LEVEL === 'verbose') {\n      lvl = 'verbose';\n    } else if (opts.quiet || process.env.VISOR_LOG_LEVEL === 'quiet') {\n      lvl = 'warn';\n    } else if (opts.level) {\n      lvl = opts.level;\n    } else if (process.env.VISOR_LOG_LEVEL) {\n      const envLvl = process.env.VISOR_LOG_LEVEL as LogLevel;\n      if (['silent', 'error', 'warn', 'info', 'verbose', 'debug'].includes(envLvl)) {\n        lvl = envLvl as LogLevel;\n      }\n    }\n\n    this.level = lvl;\n    const output = opts.outputFormat || process.env.VISOR_OUTPUT_FORMAT || 'table';\n    // In JSON/SARIF we suppress non-error logs unless explicitly verbose/debug\n    this.isJsonLike = output === 'json' || output === 'sarif';\n  }\n\n  private shouldLog(level: LogLevel): boolean {\n    const desired = levelToNumber(level);\n    const current = levelToNumber(this.level);\n    if (desired > current) return false;\n    if (\n      this.isJsonLike &&\n      desired < levelToNumber('error') &&\n      this.level !== 'debug' &&\n      this.level !== 'verbose'\n    ) {\n      // In JSON/SARIF, hide info/warn unless explicitly verbose/debug\n      return false;\n    }\n    return true;\n  }\n\n  private write(msg: string): void {\n    // Always route to stderr to keep stdout clean for results\n    try {\n      process.stderr.write(msg + '\\n');\n    } catch {\n      // Ignore write errors\n    }\n  }\n\n  info(msg: string): void {\n    if (this.shouldLog('info')) this.write(msg);\n  }\n\n  warn(msg: string): void {\n    if (this.shouldLog('warn')) this.write(msg);\n  }\n\n  error(msg: string): void {\n    if (this.shouldLog('error')) this.write(msg);\n  }\n\n  verbose(msg: string): void {\n    if (this.shouldLog('verbose')) this.write(msg);\n  }\n\n  debug(msg: string): void {\n    if (this.shouldLog('debug')) this.write(msg);\n  }\n\n  step(msg: string): void {\n    // High-level phase indicator\n    if (this.shouldLog('info')) this.write(`‚ñ∂ ${msg}`);\n  }\n\n  success(msg: string): void {\n    if (this.shouldLog('info')) this.write(`‚úî ${msg}`);\n  }\n}\n\n// Singleton instance\nexport const logger = new Logger();\n\n// Helper to configure from CLI options in a single place\nexport function configureLoggerFromCli(options: {\n  output?: string;\n  debug?: boolean;\n  verbose?: boolean;\n  quiet?: boolean;\n}): void {\n  logger.configure({\n    outputFormat: options.output,\n    debug: options.debug,\n    verbose: options.verbose,\n    quiet: options.quiet,\n  });\n\n  // Expose output format and debug to process env for modules that need to gate\n  // stdout emissions without plumbing the value through every call site.\n  try {\n    if (options.output) process.env.VISOR_OUTPUT_FORMAT = String(options.output);\n    if (typeof options.debug === 'boolean') {\n      process.env.VISOR_DEBUG = options.debug ? 'true' : 'false';\n    }\n  } catch {\n    // ignore\n  }\n}\n","/**\n * Centralized footer generation for Visor comments and outputs\n */\n\nexport interface FooterOptions {\n  /**\n   * Include metadata like lastUpdated, triggeredBy, commitSha\n   */\n  includeMetadata?: {\n    lastUpdated: string;\n    triggeredBy: string;\n    commitSha?: string;\n  };\n  /**\n   * Include horizontal rule separator before footer\n   */\n  includeSeparator?: boolean;\n}\n\n/**\n * Generate a standard Visor footer with branding and optional tip\n */\nexport function generateFooter(options: FooterOptions = {}): string {\n  const { includeMetadata, includeSeparator = true } = options;\n\n  const parts: string[] = [];\n\n  // Add separator\n  if (includeSeparator) {\n    parts.push('---');\n    parts.push('');\n  }\n\n  // Add branding\n  parts.push(\n    '*Powered by [Visor](https://probelabs.com/visor) from [Probelabs](https://probelabs.com)*'\n  );\n\n  // Add metadata if provided\n  if (includeMetadata) {\n    const { lastUpdated, triggeredBy, commitSha } = includeMetadata;\n    const commitInfo = commitSha ? ` | Commit: ${commitSha.substring(0, 7)}` : '';\n    parts.push('');\n    parts.push(`*Last updated: ${lastUpdated} | Triggered by: ${triggeredBy}${commitInfo}*`);\n  }\n\n  // Add tip\n  parts.push('');\n  parts.push('üí° **TIP:** You can chat with Visor using `/visor ask <your question>`');\n\n  return parts.join('\\n');\n}\n\n/**\n * Check if a string contains a Visor footer\n */\nexport function hasVisorFooter(text: string): boolean {\n  return (\n    text.includes('*Powered by [Visor](https://probelabs.com/visor)') ||\n    text.includes('*Powered by [Visor](https://github.com/probelabs/visor)')\n  );\n}\n","import { Octokit } from '@octokit/rest';\nimport { v4 as uuidv4 } from 'uuid';\nimport { logger } from './logger';\nimport { generateFooter } from './footer';\n\nexport interface Comment {\n  id: number;\n  body: string;\n  user: {\n    login: string;\n  };\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface RetryConfig {\n  maxRetries: number;\n  baseDelay: number;\n  maxDelay: number;\n  backoffFactor: number;\n}\n\nexport interface CommentMetadata {\n  commentId: string;\n  lastUpdated: string;\n  triggeredBy: string;\n  commitSha?: string;\n}\n\ninterface GitHubApiError {\n  status?: number;\n  response?: {\n    status?: number;\n    data?: {\n      message?: string;\n    };\n  };\n}\n\n/**\n * Manages GitHub PR comments with dynamic updating capabilities\n */\nexport class CommentManager {\n  private octokit: Octokit;\n  private retryConfig: RetryConfig;\n\n  constructor(octokit: Octokit, retryConfig?: Partial<RetryConfig>) {\n    this.octokit = octokit;\n    this.retryConfig = {\n      maxRetries: 3,\n      baseDelay: 1000,\n      maxDelay: 10000,\n      backoffFactor: 2,\n      ...retryConfig,\n    };\n  }\n\n  /**\n   * Find existing Visor comment by comment ID marker\n   */\n  public async findVisorComment(\n    owner: string,\n    repo: string,\n    prNumber: number,\n    commentId?: string\n  ): Promise<Comment | null> {\n    try {\n      const comments = await this.octokit.rest.issues.listComments({\n        owner,\n        repo,\n        issue_number: prNumber,\n        per_page: 100, // GitHub default max\n      });\n\n      for (const comment of comments.data) {\n        if (comment.body && this.isVisorComment(comment.body, commentId)) {\n          return comment as Comment;\n        }\n      }\n\n      return null;\n    } catch (error) {\n      if (\n        this.isRateLimitError(\n          error as { status?: number; response?: { data?: { message?: string } } }\n        )\n      ) {\n        await this.handleRateLimit(error as { response?: { headers?: Record<string, string> } });\n        return this.findVisorComment(owner, repo, prNumber, commentId);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Update existing comment or create new one with collision detection\n   */\n  public async updateOrCreateComment(\n    owner: string,\n    repo: string,\n    prNumber: number,\n    content: string,\n    options: {\n      commentId?: string;\n      triggeredBy?: string;\n      allowConcurrentUpdates?: boolean;\n      commitSha?: string;\n    } = {}\n  ): Promise<Comment> {\n    const {\n      commentId = this.generateCommentId(),\n      triggeredBy = 'unknown',\n      allowConcurrentUpdates = false,\n      commitSha,\n    } = options;\n\n    return this.withRetry(async () => {\n      const existingComment = await this.findVisorComment(owner, repo, prNumber, commentId);\n\n      const formattedContent = this.formatCommentWithMetadata(content, {\n        commentId,\n        lastUpdated: new Date().toISOString(),\n        triggeredBy,\n        commitSha,\n      });\n\n      if (existingComment) {\n        // Check for collision if not allowing concurrent updates\n        if (!allowConcurrentUpdates) {\n          const currentComment = await this.octokit.rest.issues.getComment({\n            owner,\n            repo,\n            comment_id: existingComment.id,\n          });\n\n          if (currentComment.data.updated_at !== existingComment.updated_at) {\n            throw new Error(\n              `Comment collision detected for comment ${commentId}. Another process may have updated it.`\n            );\n          }\n        }\n\n        const updatedComment = await this.octokit.rest.issues.updateComment({\n          owner,\n          repo,\n          comment_id: existingComment.id,\n          body: formattedContent,\n        });\n\n        logger.info(\n          `‚úÖ Successfully updated comment (ID: ${commentId}, GitHub ID: ${existingComment.id}) on PR #${prNumber} in ${owner}/${repo}`\n        );\n\n        return updatedComment.data as Comment;\n      } else {\n        const newComment = await this.octokit.rest.issues.createComment({\n          owner,\n          repo,\n          issue_number: prNumber,\n          body: formattedContent,\n        });\n\n        logger.info(\n          `‚úÖ Successfully created comment (ID: ${commentId}, GitHub ID: ${newComment.data.id}) on PR #${prNumber} in ${owner}/${repo}`\n        );\n\n        return newComment.data as Comment;\n      }\n    });\n  }\n\n  /**\n   * Format comment content with metadata markers\n   */\n  public formatCommentWithMetadata(content: string, metadata: CommentMetadata): string {\n    const { commentId, lastUpdated, triggeredBy, commitSha } = metadata;\n\n    const footer = generateFooter({\n      includeMetadata: {\n        lastUpdated,\n        triggeredBy,\n        commitSha,\n      },\n    });\n\n    return `<!-- visor-comment-id:${commentId} -->\n${content}\n\n${footer}\n<!-- /visor-comment-id:${commentId} -->`;\n  }\n\n  /**\n   * Create collapsible sections for comment content\n   */\n  public createCollapsibleSection(\n    title: string,\n    content: string,\n    isExpanded: boolean = false\n  ): string {\n    const openAttribute = isExpanded ? ' open' : '';\n    return `<details${openAttribute}>\n<summary>${title}</summary>\n\n${content}\n\n</details>`;\n  }\n\n  /**\n   * Group review results by check type with collapsible sections\n   */\n  public formatGroupedResults(\n    results: Array<{ checkType: string; content: string; score?: number; issuesFound?: number }>,\n    groupBy: 'check' | 'severity' = 'check'\n  ): string {\n    const grouped = this.groupResults(results, groupBy);\n    const sections: string[] = [];\n\n    for (const [groupKey, items] of Object.entries(grouped)) {\n      const totalScore = items.reduce((sum, item) => sum + (item.score || 0), 0) / items.length;\n      const totalIssues = items.reduce((sum, item) => sum + (item.issuesFound || 0), 0);\n\n      const title = this.formatGroupTitle(groupKey, totalScore, totalIssues);\n\n      const sectionContent = items.map(item => item.content).join('\\n\\n');\n      sections.push(this.createCollapsibleSection(title, sectionContent, totalIssues > 0));\n    }\n\n    return sections.join('\\n\\n');\n  }\n\n  /**\n   * Generate unique comment ID\n   */\n  private generateCommentId(): string {\n    return uuidv4().substring(0, 8);\n  }\n\n  /**\n   * Check if comment is a Visor comment\n   */\n  private isVisorComment(body: string, commentId?: string): boolean {\n    if (commentId) {\n      // Check for the new format with exact matching - look for the exact ID followed by space or \" -->\"\n      if (\n        body.includes(`visor-comment-id:${commentId} `) ||\n        body.includes(`visor-comment-id:${commentId} -->`)\n      ) {\n        return true;\n      }\n      // Check for legacy format (visor-review-* pattern) for backwards compatibility\n      if (commentId.startsWith('pr-review-') && body.includes('visor-review-')) {\n        return true;\n      }\n      // If we have a specific commentId but no exact match, return false\n      return false;\n    }\n    // General Visor comment detection (only when no specific commentId provided)\n    return (\n      (body.includes('visor-comment-id:') && body.includes('<!-- /visor-comment-id:')) ||\n      body.includes('visor-review-')\n    );\n  }\n\n  /**\n   * Extract comment ID from comment body\n   */\n  public extractCommentId(body: string): string | null {\n    const match = body.match(/visor-comment-id:([a-f0-9-]+)/);\n    return match ? match[1] : null;\n  }\n\n  /**\n   * Handle rate limiting with exponential backoff\n   */\n  private async handleRateLimit(error: {\n    response?: { headers?: Record<string, string> };\n  }): Promise<void> {\n    const resetTime = error.response?.headers?.['x-ratelimit-reset'];\n    if (resetTime) {\n      const resetDate = new Date(parseInt(resetTime) * 1000);\n      const waitTime = Math.max(resetDate.getTime() - Date.now(), this.retryConfig.baseDelay);\n      console.log(`Rate limit exceeded. Waiting ${Math.round(waitTime / 1000)}s until reset...`);\n      await this.sleep(Math.min(waitTime, this.retryConfig.maxDelay));\n    } else {\n      await this.sleep(this.retryConfig.baseDelay);\n    }\n  }\n\n  /**\n   * Check if error is a rate limit error\n   */\n  private isRateLimitError(error: GitHubApiError): boolean {\n    return error.status === 403 && (error.response?.data?.message?.includes('rate limit') ?? false);\n  }\n\n  /**\n   * Check if error should not be retried (auth errors, not found, etc.)\n   */\n  private isNonRetryableError(error: GitHubApiError): boolean {\n    // Don't retry auth errors, not found, etc., but allow rate limit errors to be handled separately\n    const nonRetryableStatuses = [401, 404, 422]; // Unauthorized, Not Found, Unprocessable Entity\n    const status = error.status || error.response?.status;\n\n    // 403 is non-retryable unless it's a rate limit error\n    if (status === 403) {\n      return !this.isRateLimitError(error);\n    }\n\n    return status !== undefined && nonRetryableStatuses.includes(status);\n  }\n\n  /**\n   * Retry wrapper with exponential backoff\n   */\n  private async withRetry<T>(operation: () => Promise<T>): Promise<T> {\n    let lastError: Error = new Error('Unknown error');\n\n    for (let attempt = 0; attempt <= this.retryConfig.maxRetries; attempt++) {\n      try {\n        return await operation();\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n\n        if (attempt === this.retryConfig.maxRetries) {\n          break;\n        }\n\n        if (\n          this.isRateLimitError(\n            error as { status?: number; response?: { data?: { message?: string } } }\n          )\n        ) {\n          await this.handleRateLimit(error as { response?: { headers?: Record<string, string> } });\n        } else if (this.isNonRetryableError(error as GitHubApiError)) {\n          // Don't retry auth errors, not found errors, etc.\n          throw error;\n        } else {\n          const computed =\n            this.retryConfig.baseDelay * Math.pow(this.retryConfig.backoffFactor, attempt);\n          const delay =\n            computed > this.retryConfig.maxDelay\n              ? Math.max(0, this.retryConfig.maxDelay - 1)\n              : computed;\n          await this.sleep(delay);\n        }\n      }\n    }\n\n    throw lastError;\n  }\n\n  /**\n   * Sleep utility\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => {\n      const t = setTimeout(resolve, ms);\n      if (typeof (t as any).unref === 'function') {\n        try {\n          (t as any).unref();\n        } catch {}\n      }\n    });\n  }\n\n  /**\n   * Group results by specified criteria\n   */\n  private groupResults(\n    results: Array<{ checkType: string; content: string; score?: number; issuesFound?: number }>,\n    groupBy: 'check' | 'severity'\n  ): Record<\n    string,\n    Array<{ checkType: string; content: string; score?: number; issuesFound?: number }>\n  > {\n    const grouped: Record<\n      string,\n      Array<{ checkType: string; content: string; score?: number; issuesFound?: number }>\n    > = {};\n\n    for (const result of results) {\n      const key = groupBy === 'check' ? result.checkType : this.getSeverityGroup(result.score);\n      if (!grouped[key]) {\n        grouped[key] = [];\n      }\n      grouped[key].push(result);\n    }\n\n    return grouped;\n  }\n\n  /**\n   * Get severity group based on score\n   */\n  private getSeverityGroup(score?: number): string {\n    if (!score) return 'Unknown';\n    if (score >= 90) return 'Excellent';\n    if (score >= 75) return 'Good';\n    if (score >= 50) return 'Needs Improvement';\n    return 'Critical Issues';\n  }\n\n  // Emoji helper removed: plain titles are used in group headers\n\n  /**\n   * Format group title with score and issue count\n   */\n  private formatGroupTitle(groupKey: string, score: number, issuesFound: number): string {\n    const formattedScore = Math.round(score);\n    return `${groupKey} Review (Score: ${formattedScore}/100)${issuesFound > 0 ? ` - ${issuesFound} issues found` : ''}`;\n  }\n}\n","import * as path from 'path';\nimport * as fs from 'fs';\n\n/**\n * Safely initialize a tracer for ProbeAgent with proper path sanitization\n * Uses SimpleTelemetry for lightweight tracing\n * This prevents path traversal vulnerabilities by sanitizing the checkName\n */\ntype ProbeModule =\n  | {\n      SimpleTelemetry?: new (opts: {\n        enableFile: boolean;\n        filePath: string;\n        enableConsole?: boolean;\n      }) => unknown;\n      SimpleAppTracer?: new (telemetry: unknown, sessionId: string) => unknown;\n    }\n  | undefined;\n\nexport async function initializeTracer(\n  sessionId: string,\n  checkName?: string\n): Promise<{ tracer: unknown; telemetryConfig: unknown; filePath: string } | null> {\n  try {\n    // Load Probe lib in a way that works in both ESM and CJS bundles\n    let ProbeLib: ProbeModule;\n    try {\n      ProbeLib = (await import('@probelabs/probe')) as ProbeModule;\n    } catch {\n      try {\n        // Fallback to CJS require if available\n\n        ProbeLib = require('@probelabs/probe') as ProbeModule;\n      } catch {\n        ProbeLib = {} as unknown as ProbeModule;\n      }\n    }\n\n    // Use SimpleTelemetry (probe no longer exports full OpenTelemetry classes)\n    const SimpleTelemetry = ProbeLib?.SimpleTelemetry;\n    const SimpleAppTracer = ProbeLib?.SimpleAppTracer;\n    if (SimpleTelemetry && SimpleAppTracer) {\n      // SECURITY: Sanitize checkName to prevent path traversal attacks\n      const sanitizedCheckName = checkName ? path.basename(checkName) : 'check';\n\n      // Create trace file path in debug-artifacts directory\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n      const traceDir = process.env.GITHUB_WORKSPACE\n        ? path.join(process.env.GITHUB_WORKSPACE, 'debug-artifacts')\n        : path.join(process.cwd(), 'debug-artifacts');\n\n      // Create traces directory if it doesn't exist\n      if (!fs.existsSync(traceDir)) {\n        fs.mkdirSync(traceDir, { recursive: true });\n      }\n\n      // SECURITY: Use path.join to safely construct the path\n      const traceFilePath = path.join(traceDir, `trace-${sanitizedCheckName}-${timestamp}.jsonl`);\n\n      // SECURITY: Verify the resolved path is within the intended directory\n      const resolvedTracePath = path.resolve(traceFilePath);\n      const resolvedTraceDir = path.resolve(traceDir);\n      if (!resolvedTracePath.startsWith(resolvedTraceDir)) {\n        console.error(\n          `‚ö†Ô∏è Security: Attempted path traversal detected. Check name: ${checkName}, resolved path: ${resolvedTracePath}`\n        );\n        return null;\n      }\n\n      // Initialize simple telemetry\n      const telemetry = new SimpleTelemetry({\n        enableFile: true,\n        filePath: traceFilePath,\n        enableConsole: false,\n      });\n\n      const tracer = new SimpleAppTracer(telemetry, sessionId);\n\n      console.error(`üìä Simple tracing enabled, will save to: ${traceFilePath}`);\n\n      // If in GitHub Actions, log the path for artifact upload\n      if (process.env.GITHUB_ACTIONS) {\n        console.log(`::notice title=AI Trace::Trace will be saved to ${traceFilePath}`);\n        console.log(`::set-output name=trace-path::${traceFilePath}`);\n      }\n\n      // Return with SimpleTelemetry\n      return {\n        tracer,\n        telemetryConfig: telemetry,\n        filePath: traceFilePath,\n      };\n    }\n\n    console.error('‚ö†Ô∏è Telemetry classes not available in ProbeAgent, skipping tracing');\n    return null;\n  } catch (error) {\n    console.error('‚ö†Ô∏è Warning: Failed to initialize tracing:', error);\n    return null;\n  }\n}\n","import { ProbeAgent } from '@probelabs/probe';\n\n/**\n * Extended ProbeAgent interface that includes tracing properties\n */\ninterface TracedProbeAgent extends ProbeAgent {\n  tracer?: any; // AppTracer removed from probe\n  _telemetryConfig?: any; // TelemetryConfig removed from probe\n  _traceFilePath?: string;\n}\n\n/**\n * Registry to manage active ProbeAgent sessions for session reuse\n */\nexport class SessionRegistry {\n  private static instance: SessionRegistry;\n  private sessions: Map<string, TracedProbeAgent> = new Map();\n  private exitHandlerRegistered = false;\n\n  private constructor() {\n    // Register process exit handlers to cleanup sessions\n    this.registerExitHandlers();\n  }\n\n  /**\n   * Get the singleton instance of SessionRegistry\n   */\n  public static getInstance(): SessionRegistry {\n    if (!SessionRegistry.instance) {\n      SessionRegistry.instance = new SessionRegistry();\n    }\n    return SessionRegistry.instance;\n  }\n\n  /**\n   * Register a ProbeAgent session\n   */\n  public registerSession(sessionId: string, agent: TracedProbeAgent): void {\n    console.error(`üîÑ Registering AI session: ${sessionId}`);\n    this.sessions.set(sessionId, agent);\n  }\n\n  /**\n   * Get an existing ProbeAgent session\n   */\n  public getSession(sessionId: string): TracedProbeAgent | undefined {\n    const agent = this.sessions.get(sessionId);\n    if (agent) {\n      console.error(`‚ôªÔ∏è  Reusing AI session: ${sessionId}`);\n    }\n    return agent;\n  }\n\n  /**\n   * Remove a session from the registry\n   */\n  public unregisterSession(sessionId: string): void {\n    if (this.sessions.has(sessionId)) {\n      console.error(`üóëÔ∏è  Unregistering AI session: ${sessionId}`);\n      const agent = this.sessions.get(sessionId);\n      this.sessions.delete(sessionId);\n\n      // Cleanup the ProbeAgent instance to prevent hanging processes\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      if (agent && typeof (agent as any).cleanup === 'function') {\n        try {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (agent as any).cleanup();\n        } catch (error) {\n          console.error(`‚ö†Ô∏è  Warning: Failed to cleanup ProbeAgent: ${error}`);\n        }\n      }\n    }\n  }\n\n  /**\n   * Clear all sessions (useful for cleanup)\n   */\n  public clearAllSessions(): void {\n    console.error(`üßπ Clearing all AI sessions (${this.sessions.size} sessions)`);\n\n    // Cleanup each ProbeAgent instance before clearing\n    for (const [, agent] of this.sessions.entries()) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      if (agent && typeof (agent as any).cleanup === 'function') {\n        try {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (agent as any).cleanup();\n        } catch {\n          // Silent fail during bulk cleanup\n        }\n      }\n    }\n\n    this.sessions.clear();\n  }\n\n  /**\n   * Get all active session IDs\n   */\n  public getActiveSessionIds(): string[] {\n    return Array.from(this.sessions.keys());\n  }\n\n  /**\n   * Check if a session exists\n   */\n  public hasSession(sessionId: string): boolean {\n    return this.sessions.has(sessionId);\n  }\n\n  /**\n   * Clone a session with a new session ID using ProbeAgent's official clone() method\n   * This uses ProbeAgent's built-in cloning which automatically handles:\n   * - Intelligent filtering of internal messages (schema reminders, tool prompts, etc.)\n   * - Preserving system message for cache efficiency\n   * - Deep copying conversation history\n   * - Copying agent configuration\n   */\n  public async cloneSession(\n    sourceSessionId: string,\n    newSessionId: string,\n    checkName?: string\n  ): Promise<ProbeAgent | undefined> {\n    const sourceAgent = this.sessions.get(sourceSessionId);\n    if (!sourceAgent) {\n      console.error(`‚ö†Ô∏è  Cannot clone session: ${sourceSessionId} not found`);\n      return undefined;\n    }\n\n    try {\n      // Use ProbeAgent's official clone() method with options\n      // This handles intelligent message filtering automatically\n      const clonedAgent = (sourceAgent as any).clone({\n        sessionId: newSessionId,\n        stripInternalMessages: true, // Remove schema reminders, tool prompts, etc.\n        keepSystemMessage: true, // Keep for cache efficiency\n        deepCopy: true, // Safe deep copy of history\n      }) as TracedProbeAgent;\n\n      // Set up tracing for cloned session if debug mode is enabled\n      if ((sourceAgent as any).debug && checkName) {\n        try {\n          const { initializeTracer } = await import('./utils/tracer-init');\n          const tracerResult = await initializeTracer(newSessionId, checkName);\n          if (tracerResult) {\n            clonedAgent.tracer = tracerResult.tracer;\n            // Store telemetry config and trace file path for proper shutdown\n            clonedAgent._telemetryConfig = tracerResult.telemetryConfig;\n            clonedAgent._traceFilePath = tracerResult.filePath;\n          }\n        } catch (traceError) {\n          console.error(\n            '‚ö†Ô∏è  Warning: Failed to initialize tracing for cloned session:',\n            traceError\n          );\n        }\n      }\n\n      // Initialize MCP tools if the source agent had them initialized\n      if (\n        (sourceAgent as any)._mcpInitialized &&\n        typeof (clonedAgent as any).initialize === 'function'\n      ) {\n        try {\n          await (clonedAgent as any).initialize();\n          console.error(`üîß Initialized MCP tools for cloned session`);\n        } catch (initError) {\n          console.error(`‚ö†Ô∏è  Warning: Failed to initialize cloned agent: ${initError}`);\n        }\n      }\n\n      // Get history length for logging\n      const historyLength = (clonedAgent as any).history?.length || 0;\n\n      console.error(\n        `üìã Cloned session ${sourceSessionId} ‚Üí ${newSessionId} using ProbeAgent.clone() (${historyLength} messages, internal messages filtered)`\n      );\n\n      // Register the cloned session\n      this.registerSession(newSessionId, clonedAgent);\n\n      return clonedAgent;\n    } catch (error) {\n      console.error(`‚ö†Ô∏è  Failed to clone session ${sourceSessionId}:`, error);\n      return undefined;\n    }\n  }\n\n  /**\n   * Register process exit handlers to cleanup sessions on exit\n   */\n  private registerExitHandlers(): void {\n    if (this.exitHandlerRegistered) {\n      return;\n    }\n\n    const cleanupAndExit = (signal: string) => {\n      if (this.sessions.size > 0) {\n        console.error(`\\nüßπ [${signal}] Cleaning up ${this.sessions.size} active AI sessions...`);\n        this.clearAllSessions();\n      }\n    };\n\n    // Handle normal process exit\n    process.on('exit', () => {\n      if (this.sessions.size > 0) {\n        console.error(`üßπ [exit] Cleaning up ${this.sessions.size} active AI sessions...`);\n        // Note: async operations won't complete here, but sync cleanup methods will\n        for (const [, agent] of this.sessions.entries()) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          if (agent && typeof (agent as any).cleanup === 'function') {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              (agent as any).cleanup();\n            } catch {\n              // Silent fail on exit\n            }\n          }\n        }\n        this.sessions.clear();\n      }\n    });\n\n    // Handle SIGINT (Ctrl+C)\n    process.on('SIGINT', () => {\n      cleanupAndExit('SIGINT');\n      process.exit(0);\n    });\n\n    // Handle SIGTERM\n    process.on('SIGTERM', () => {\n      cleanupAndExit('SIGTERM');\n      process.exit(0);\n    });\n\n    this.exitHandlerRegistered = true;\n  }\n}\n","import { extract } from '@probelabs/probe';\nimport * as path from 'path';\n\n/**\n * Process diff content using the outline-diff format from @probelabs/probe\n * This extracts a structured outline from the diff without requiring a temporary file\n */\nexport async function processDiffWithOutline(diffContent: string): Promise<string> {\n  if (!diffContent || diffContent.trim().length === 0) {\n    return diffContent;\n  }\n\n  try {\n    // Set PROBE_PATH to use the bundled binary with outline-diff support\n    // The SDK by default may download an older binary that doesn't support outline-diff\n    const originalProbePath = process.env.PROBE_PATH;\n\n    // Try multiple possible locations for the probe binary\n    // When bundled with ncc, __dirname may not be reliable\n    const fs = require('fs');\n    const possiblePaths = [\n      // Relative to current working directory (most common in production)\n      path.join(process.cwd(), 'node_modules/@probelabs/probe/bin/probe-binary'),\n      // Relative to __dirname (for unbundled development)\n      path.join(__dirname, '../..', 'node_modules/@probelabs/probe/bin/probe-binary'),\n      // Relative to dist directory (for bundled CLI)\n      path.join(__dirname, 'node_modules/@probelabs/probe/bin/probe-binary'),\n    ];\n\n    let probeBinaryPath: string | undefined;\n    for (const candidatePath of possiblePaths) {\n      if (fs.existsSync(candidatePath)) {\n        probeBinaryPath = candidatePath;\n        break;\n      }\n    }\n\n    // Only process if binary exists, otherwise fall back to original diff\n    if (!probeBinaryPath) {\n      if (process.env.DEBUG === '1' || process.env.VERBOSE === '1') {\n        console.error('Probe binary not found. Tried:', possiblePaths);\n      }\n      return diffContent;\n    }\n\n    process.env.PROBE_PATH = probeBinaryPath;\n\n    // Use extract with content parameter (can be string or Buffer)\n    // The TypeScript types haven't been updated yet, but the runtime supports it\n    // Add timeout to avoid hanging\n    const extractPromise = (extract as any)({\n      content: diffContent,\n      format: 'outline-diff',\n      allowTests: true, // Allow test files and test code blocks in extraction results\n    });\n\n    const timeoutPromise = new Promise((_, reject) => {\n      setTimeout(() => reject(new Error('Extract timeout after 30s')), 30000);\n    });\n\n    const result = await Promise.race([extractPromise, timeoutPromise]);\n\n    // Restore original PROBE_PATH\n    if (originalProbePath !== undefined) {\n      process.env.PROBE_PATH = originalProbePath;\n    } else {\n      delete process.env.PROBE_PATH;\n    }\n\n    // Return the processed outline diff\n    return typeof result === 'string' ? result : JSON.stringify(result);\n  } catch (error) {\n    // If outline-diff processing fails, fall back to the original diff\n    // Use console.error instead of console.warn to avoid polluting JSON output\n    if (process.env.DEBUG === '1' || process.env.VERBOSE === '1') {\n      console.error('Failed to process diff with outline-diff format:', error);\n    }\n    return diffContent;\n  }\n}\n","import { ProbeAgent } from '@probelabs/probe';\nimport type { ProbeAgentOptions } from '@probelabs/probe';\nimport { PRInfo } from './pr-analyzer';\nimport { ReviewSummary, ReviewIssue } from './reviewer';\nimport { SessionRegistry } from './session-registry';\nimport { logger } from './logger';\nimport { initializeTracer } from './utils/tracer-init';\nimport { processDiffWithOutline } from './utils/diff-processor';\n\n/**\n * Helper function to log debug messages using the centralized logger\n */\nfunction log(...args: unknown[]): void {\n  logger.debug(args.join(' '));\n}\n\n/**\n * Extended ProbeAgent interface that includes tracing properties\n */\ninterface TracedProbeAgent extends ProbeAgent {\n  tracer?: unknown; // SimpleTelemetry tracer (probe removed AppTracer)\n  _telemetryConfig?: unknown; // SimpleTelemetry config (probe removed TelemetryConfig)\n  _traceFilePath?: string;\n}\n\n/**\n * Extended ProbeAgentOptions interface that includes tracing properties\n */\ninterface TracedProbeAgentOptions extends ProbeAgentOptions {\n  tracer?: unknown; // SimpleTelemetry tracer\n  _telemetryConfig?: unknown; // SimpleTelemetry config\n  _traceFilePath?: string;\n  customPrompt?: string;\n}\n\nexport interface AIReviewConfig {\n  apiKey?: string; // From env: GOOGLE_API_KEY, ANTHROPIC_API_KEY, OPENAI_API_KEY, CLAUDE_CODE_API_KEY, or AWS credentials\n  model?: string; // From env: MODEL_NAME (e.g., gemini-2.5-pro-preview-06-05)\n  timeout?: number; // Default: 600000ms (10 minutes)\n  provider?: 'google' | 'anthropic' | 'openai' | 'bedrock' | 'mock' | 'claude-code';\n  debug?: boolean; // Enable debug mode\n  tools?: Array<{ name: string; [key: string]: unknown }>; // (unused) Legacy tool listing\n  // Pass-through MCP server configuration for ProbeAgent\n  mcpServers?: Record<string, import('./types/config').McpServerConfig>;\n  // Enable delegate tool for task distribution to subagents\n  enableDelegate?: boolean;\n  // ProbeAgent persona/prompt family (e.g., 'engineer', 'code-review', 'architect')\n  promptType?: string;\n  // System prompt to prepend (baseline/preamble). Replaces legacy customPrompt\n  systemPrompt?: string;\n  // Backward-compat: legacy key still accepted internally\n  customPrompt?: string;\n  // Retry configuration for AI provider calls\n  retry?: import('./types/config').AIRetryConfig;\n  // Fallback configuration for provider failures\n  fallback?: import('./types/config').AIFallbackConfig;\n  // Enable Edit and Create tools for file modification\n  allowEdit?: boolean;\n  // Filter allowed tools - supports whitelist, exclusion (!prefix), or raw AI mode (empty array)\n  allowedTools?: string[];\n  // Disable all tools for raw AI mode (alternative to allowedTools: [])\n  disableTools?: boolean;\n  // Enable bash command execution (shorthand for bashConfig.enabled)\n  allowBash?: boolean;\n  // Advanced bash command execution configuration\n  bashConfig?: import('./types/config').BashConfig;\n}\n\nexport interface AIDebugInfo {\n  /** The prompt sent to the AI */\n  prompt: string;\n  /** Raw response from the AI service */\n  rawResponse: string;\n  /** Provider used (google, anthropic, openai) */\n  provider: string;\n  /** Model used */\n  model: string;\n  /** API key source (for privacy, just show which env var) */\n  apiKeySource: string;\n  /** Processing time in milliseconds */\n  processingTime: number;\n  /** Prompt length in characters */\n  promptLength: number;\n  /** Response length in characters */\n  responseLength: number;\n  /** Any errors encountered */\n  errors?: string[];\n  /** Whether JSON parsing succeeded */\n  jsonParseSuccess: boolean;\n  /** Schema used for response validation */\n  schema?: string;\n  /** Schema name/type requested */\n  schemaName?: string;\n  /** Checks executed during this review */\n  checksExecuted?: string[];\n  /** Whether parallel execution was used */\n  parallelExecution?: boolean;\n  /** Timestamp when request was made */\n  timestamp: string;\n  /** Total API calls made */\n  totalApiCalls?: number;\n  /** Details about API calls made */\n  apiCallDetails?: Array<{\n    checkName: string;\n    provider: string;\n    model: string;\n    processingTime: number;\n    success: boolean;\n  }>;\n}\n\n// REMOVED: ReviewFocus type - only use custom prompts from .visor.yaml\n\ninterface AIResponseFormat {\n  // Array of issues for code review\n  issues?: Array<{\n    file: string;\n    line: number;\n    endLine?: number;\n    ruleId: string;\n    message: string;\n    severity: 'info' | 'warning' | 'error' | 'critical';\n    category: 'security' | 'performance' | 'style' | 'logic' | 'documentation';\n    suggestion?: string;\n    replacement?: string;\n  }>;\n}\n\nexport class AIReviewService {\n  private config: AIReviewConfig;\n  private sessionRegistry: SessionRegistry;\n\n  constructor(config: AIReviewConfig = {}) {\n    this.config = {\n      timeout: 600000, // Increased timeout to 10 minutes for AI responses\n      ...config,\n    };\n\n    this.sessionRegistry = SessionRegistry.getInstance();\n\n    // If debug was not explicitly provided, honor standard env flags so tests/CLI\n    // can enable provider-level debug without modifying per-check configs.\n    if (typeof this.config.debug === 'undefined') {\n      try {\n        if (process.env.VISOR_PROVIDER_DEBUG === 'true' || process.env.VISOR_DEBUG === 'true') {\n          this.config.debug = true;\n        }\n      } catch {}\n    }\n\n    // Respect explicit provider if set (e.g., 'mock' during tests) ‚Äî do not override from env\n    const providerExplicit =\n      typeof this.config.provider === 'string' && this.config.provider.length > 0;\n\n    // Auto-detect provider and API key from environment only when provider not explicitly set\n    if (!providerExplicit) {\n      if (!this.config.apiKey) {\n        if (process.env.CLAUDE_CODE_API_KEY) {\n          this.config.apiKey = process.env.CLAUDE_CODE_API_KEY;\n          this.config.provider = 'claude-code';\n        } else if (process.env.GOOGLE_API_KEY) {\n          this.config.apiKey = process.env.GOOGLE_API_KEY;\n          this.config.provider = 'google';\n        } else if (process.env.ANTHROPIC_API_KEY) {\n          this.config.apiKey = process.env.ANTHROPIC_API_KEY;\n          this.config.provider = 'anthropic';\n        } else if (process.env.OPENAI_API_KEY) {\n          this.config.apiKey = process.env.OPENAI_API_KEY;\n          this.config.provider = 'openai';\n        } else if (\n          // Check for AWS Bedrock credentials\n          (process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY) ||\n          process.env.AWS_BEDROCK_API_KEY\n        ) {\n          // For Bedrock, we don't set apiKey as it uses AWS credentials\n          // ProbeAgent will handle the authentication internally\n          this.config.provider = 'bedrock';\n          // Set a placeholder to pass validation\n          this.config.apiKey = 'AWS_CREDENTIALS';\n        }\n      }\n    }\n\n    // Auto-detect model from environment\n    if (!this.config.model && process.env.MODEL_NAME) {\n      this.config.model = process.env.MODEL_NAME;\n    }\n  }\n\n  // NOTE: per request, no additional redaction/encryption helpers are used.\n\n  /**\n   * Execute AI review using probe agent\n   */\n  async executeReview(\n    prInfo: PRInfo,\n    customPrompt: string,\n    schema?: string | Record<string, unknown>,\n    checkName?: string,\n    sessionId?: string\n  ): Promise<ReviewSummary> {\n    const startTime = Date.now();\n    const timestamp = new Date().toISOString();\n\n    // Build prompt from custom instructions\n    // Respect provider-level skip_code_context by skipping PR context wrapper when requested\n    const prompt = await this.buildCustomPrompt(prInfo, customPrompt, schema, {\n      skipPRContext: (this.config as any)?.skip_code_context === true,\n    });\n\n    log(`Executing AI review with ${this.config.provider} provider...`);\n    log(`üîß Debug: Raw schema parameter: ${JSON.stringify(schema)} (type: ${typeof schema})`);\n    log(`Schema type: ${schema || 'none (no schema)'}`);\n\n    let debugInfo: AIDebugInfo | undefined;\n    if (this.config.debug) {\n      debugInfo = {\n        prompt,\n        rawResponse: '',\n        provider: this.config.provider || 'unknown',\n        model: this.config.model || 'default',\n        apiKeySource: this.getApiKeySource(),\n        processingTime: 0,\n        promptLength: prompt.length,\n        responseLength: 0,\n        errors: [],\n        jsonParseSuccess: false,\n        timestamp,\n        schemaName: typeof schema === 'object' ? 'custom' : schema,\n        schema: undefined, // Will be populated when schema is loaded\n      };\n    }\n\n    // Handle mock model/provider first (no API key needed)\n    if (this.config.model === 'mock' || this.config.provider === 'mock') {\n      log('üé≠ Using mock AI model/provider for testing - skipping API key validation');\n    } else {\n      // Hydrate API key from environment even when provider is explicitly set\n      if (!this.config.apiKey) {\n        try {\n          if (this.config.provider === 'google' && process.env.GOOGLE_API_KEY) {\n            this.config.apiKey = process.env.GOOGLE_API_KEY;\n          } else if (this.config.provider === 'anthropic' && process.env.ANTHROPIC_API_KEY) {\n            this.config.apiKey = process.env.ANTHROPIC_API_KEY;\n          } else if (this.config.provider === 'openai' && process.env.OPENAI_API_KEY) {\n            this.config.apiKey = process.env.OPENAI_API_KEY;\n          } else if (this.config.provider === 'claude-code' && process.env.CLAUDE_CODE_API_KEY) {\n            this.config.apiKey = process.env.CLAUDE_CODE_API_KEY;\n          }\n        } catch {}\n      }\n      // Check if API key is available for real AI models\n      if (!this.config.apiKey) {\n        const errorMessage =\n          'No API key configured. Please set GOOGLE_API_KEY, ANTHROPIC_API_KEY, OPENAI_API_KEY environment variable, or configure AWS credentials for Bedrock (AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY).';\n\n        // In debug mode, proceed to call the (mocked) provider so tests can assert prompt/session behavior\n        if (debugInfo) {\n          debugInfo.errors = [errorMessage];\n          debugInfo.rawResponse = 'API call attempted in debug without API key (test mode)';\n          // Continue without returning; ProbeAgent is typically mocked under tests.\n        } else {\n          throw new Error(errorMessage);\n        }\n      }\n    }\n\n    try {\n      const call = this.callProbeAgent(prompt, schema, debugInfo, checkName, sessionId);\n      const timeoutMs = Math.max(0, this.config.timeout || 0);\n      const { response, effectiveSchema } =\n        timeoutMs > 0 ? await this.withTimeout(call, timeoutMs, 'AI review') : await call;\n      const processingTime = Date.now() - startTime;\n\n      if (debugInfo) {\n        debugInfo.rawResponse = response;\n        debugInfo.responseLength = response.length;\n        debugInfo.processingTime = processingTime;\n      }\n\n      const result = this.parseAIResponse(response, debugInfo, effectiveSchema);\n\n      if (debugInfo) {\n        result.debug = debugInfo;\n      }\n\n      return result;\n    } catch (error) {\n      if (debugInfo) {\n        debugInfo.errors = [error instanceof Error ? error.message : String(error)];\n        debugInfo.processingTime = Date.now() - startTime;\n\n        // In debug mode, return a review with the error captured\n        return {\n          issues: [\n            {\n              file: 'system',\n              line: 0,\n              ruleId: 'system/ai-execution-error',\n              message: error instanceof Error ? error.message : String(error),\n              severity: 'error',\n              category: 'logic',\n            },\n          ],\n          debug: debugInfo,\n        };\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Execute AI review using session reuse - reuses an existing ProbeAgent session\n   * @param sessionMode - 'clone' (default) clones history, 'append' shares history\n   */\n  async executeReviewWithSessionReuse(\n    prInfo: PRInfo,\n    customPrompt: string,\n    parentSessionId: string,\n    schema?: string | Record<string, unknown>,\n    checkName?: string,\n    sessionMode: 'clone' | 'append' = 'clone'\n  ): Promise<ReviewSummary> {\n    const startTime = Date.now();\n    const timestamp = new Date().toISOString();\n\n    // Ensure API key is hydrated from environment for explicit providers\n    if (!this.config.apiKey) {\n      try {\n        if (this.config.provider === 'google' && process.env.GOOGLE_API_KEY) {\n          this.config.apiKey = process.env.GOOGLE_API_KEY;\n        } else if (this.config.provider === 'anthropic' && process.env.ANTHROPIC_API_KEY) {\n          this.config.apiKey = process.env.ANTHROPIC_API_KEY;\n        } else if (this.config.provider === 'openai' && process.env.OPENAI_API_KEY) {\n          this.config.apiKey = process.env.OPENAI_API_KEY;\n        } else if (this.config.provider === 'claude-code' && process.env.CLAUDE_CODE_API_KEY) {\n          this.config.apiKey = process.env.CLAUDE_CODE_API_KEY;\n        }\n      } catch {}\n    }\n    // Get the existing session\n    const existingAgent = this.sessionRegistry.getSession(parentSessionId);\n    if (!existingAgent) {\n      throw new Error(\n        `Session not found for reuse: ${parentSessionId}. Ensure the parent check completed successfully.`\n      );\n    }\n\n    // Build prompt from custom instructions\n    // When reusing session, skip PR context since it's already in the conversation history\n    const prompt = await this.buildCustomPrompt(prInfo, customPrompt, schema, {\n      skipPRContext: true,\n    });\n\n    // Determine which agent to use based on session mode\n    let agentToUse: typeof existingAgent;\n    let currentSessionId: string;\n\n    if (sessionMode === 'clone') {\n      // Clone the session - creates a new agent with copied history\n      // Include check name in the session ID for better tracing\n      currentSessionId = `${checkName}-session-${Date.now()}`;\n      log(\n        `üìã Cloning AI session ${parentSessionId} ‚Üí ${currentSessionId} for ${checkName} check...`\n      );\n\n      const clonedAgent = await this.sessionRegistry.cloneSession(\n        parentSessionId,\n        currentSessionId,\n        checkName // Pass checkName for tracing\n      );\n      if (!clonedAgent) {\n        throw new Error(`Failed to clone session ${parentSessionId}`);\n      }\n      agentToUse = clonedAgent;\n    } else {\n      // Append mode - use the same agent instance\n      log(`üîÑ Appending to AI session ${parentSessionId} (shared history)...`);\n      agentToUse = existingAgent;\n      currentSessionId = parentSessionId;\n    }\n\n    log(`üîß Debug: Raw schema parameter: ${JSON.stringify(schema)} (type: ${typeof schema})`);\n    log(`üìã Schema for this check: ${schema || 'none (no schema)'}`);\n    if (sessionMode === 'clone') {\n      log(`‚úÖ Cloned agent will use NEW schema (${schema}) - parent schema does not persist`);\n      log(`üîÑ Clone operation ensures fresh agent with copied history but new configuration`);\n    } else {\n      log(`üîÑ Append mode - using existing agent instance with shared history and configuration`);\n    }\n\n    let debugInfo: AIDebugInfo | undefined;\n    if (this.config.debug) {\n      debugInfo = {\n        prompt,\n        rawResponse: '',\n        provider: this.config.provider || 'unknown',\n        model: this.config.model || 'default',\n        apiKeySource: this.getApiKeySource(),\n        processingTime: 0,\n        promptLength: prompt.length,\n        responseLength: 0,\n        errors: [],\n        jsonParseSuccess: false,\n        timestamp,\n        schemaName: typeof schema === 'object' ? 'custom' : schema,\n        schema: undefined, // Will be populated when schema is loaded\n      };\n    }\n\n    try {\n      // Use the determined agent (cloned or original)\n      const call = this.callProbeAgentWithExistingSession(\n        agentToUse,\n        prompt,\n        schema,\n        debugInfo,\n        checkName\n      );\n      const timeoutMs = Math.max(0, this.config.timeout || 0);\n      const { response, effectiveSchema } =\n        timeoutMs > 0 ? await this.withTimeout(call, timeoutMs, 'AI review (session)') : await call;\n      const processingTime = Date.now() - startTime;\n\n      if (debugInfo) {\n        debugInfo.rawResponse = response;\n        debugInfo.responseLength = response.length;\n        debugInfo.processingTime = processingTime;\n      }\n\n      const result = this.parseAIResponse(response, debugInfo, effectiveSchema);\n\n      // Expose the session ID used for this call so the engine can clean it up\n      try {\n        (result as any).sessionId = currentSessionId;\n      } catch {}\n\n      if (debugInfo) {\n        result.debug = debugInfo;\n      }\n\n      // Include the session ID in the result for cleanup tracking\n      // Only include if we created a new cloned session\n      if (sessionMode === 'clone' && currentSessionId !== parentSessionId) {\n        result.sessionId = currentSessionId;\n      }\n\n      return result;\n    } catch (error) {\n      if (debugInfo) {\n        debugInfo.errors = [error instanceof Error ? error.message : String(error)];\n        debugInfo.processingTime = Date.now() - startTime;\n\n        // In debug mode, return a review with the error captured\n        return {\n          issues: [\n            {\n              file: 'system',\n              line: 0,\n              ruleId: 'system/ai-session-reuse-error',\n              message: error instanceof Error ? error.message : String(error),\n              severity: 'error',\n              category: 'logic',\n            },\n          ],\n          debug: debugInfo,\n        };\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Promise timeout helper that rejects after ms if unresolved\n   */\n  private async withTimeout<T>(p: Promise<T>, ms: number, label = 'operation'): Promise<T> {\n    let timer: NodeJS.Timeout | undefined;\n    try {\n      const timeout = new Promise<never>((_, reject) => {\n        timer = setTimeout(() => reject(new Error(`${label} timed out after ${ms}ms`)), ms);\n      });\n      return (await Promise.race([p, timeout])) as T;\n    } finally {\n      if (timer) clearTimeout(timer);\n    }\n  }\n\n  /**\n   * Register a new AI session in the session registry\n   */\n  registerSession(sessionId: string, agent: TracedProbeAgent): void {\n    this.sessionRegistry.registerSession(sessionId, agent);\n  }\n\n  /**\n   * Cleanup a session from the registry\n   */\n  cleanupSession(sessionId: string): void {\n    this.sessionRegistry.unregisterSession(sessionId);\n  }\n\n  /**\n   * Build a custom prompt for AI review with XML-formatted data\n   */\n  private async buildCustomPrompt(\n    prInfo: PRInfo,\n    customInstructions: string,\n    schema?: string | Record<string, unknown>,\n    options?: { skipPRContext?: boolean; checkName?: string }\n  ): Promise<string> {\n    // When reusing sessions, skip PR context to avoid sending duplicate diff data\n    const skipPRContext = options?.skipPRContext === true;\n\n    // Check if we're using the code-review schema\n    const isCodeReviewSchema = schema === 'code-review';\n\n    const prContext = skipPRContext ? '' : await this.formatPRContext(prInfo, isCodeReviewSchema);\n    const isIssue = (prInfo as PRInfo & { isIssue?: boolean }).isIssue === true;\n\n    if (isIssue) {\n      // Issue context - no code analysis needed\n      if (skipPRContext) {\n        // Session reuse: just send new instructions\n        return `<instructions>\n${customInstructions}\n</instructions>`;\n      }\n\n      return `<review_request>\n  <instructions>\n${customInstructions}\n  </instructions>\n\n  <context>\n${prContext}\n  </context>\n\n  <rules>\n    <rule>Understand the issue context and requirements from the XML data structure</rule>\n    <rule>Provide helpful, actionable guidance based on the issue details</rule>\n    <rule>Be constructive and supportive in your analysis</rule>\n    <rule>Consider project conventions and patterns when making recommendations</rule>\n    <rule>Suggest practical solutions or next steps that address the specific concern</rule>\n    <rule>Focus on addressing the specific concern raised in the issue</rule>\n    <rule>Reference relevant XML elements like metadata, description, labels, assignees when providing context</rule>\n  </rules>\n</review_request>`;\n    }\n\n    // Only add review_request wrapper and PR-specific rules for code-review schema\n    if (isCodeReviewSchema) {\n      // PR context with code-review schema - structured XML format\n      const analysisType = prInfo.isIncremental ? 'INCREMENTAL' : 'FULL';\n\n      if (skipPRContext) {\n        // Session reuse: just send new instructions without repeating the context\n        return `<instructions>\n${customInstructions}\n</instructions>\n\n<reminder>\n  <rule>The code context and diff were provided in the previous message</rule>\n  <rule>Focus on the new analysis instructions above</rule>\n  <rule>Only analyze code that appears with + (additions) or - (deletions) in the diff sections</rule>\n  <rule>STRICT OUTPUT POLICY: Report only actual problems, risks, or deficiencies</rule>\n  <rule>SEVERITY ASSIGNMENT: Assign severity ONLY to problems introduced or left unresolved by this change</rule>\n</reminder>`;\n      }\n\n      return `<review_request>\n  <analysis_type>${analysisType}</analysis_type>\n\n  <analysis_focus>\n    ${\n      analysisType === 'INCREMENTAL'\n        ? 'You are analyzing a NEW COMMIT added to an existing PR. Focus on the changes in the commit_diff section for this specific commit.'\n        : 'You are analyzing the COMPLETE PR. Review all changes in the full_diff section.'\n    }\n  </analysis_focus>\n\n  <instructions>\n${customInstructions}\n  </instructions>\n\n  <context>\n${prContext}\n  </context>\n\n  <rules>\n    <rule>Only analyze code that appears with + (additions) or - (deletions) in the diff sections</rule>\n    <rule>Ignore unchanged code unless directly relevant to understanding a change</rule>\n    <rule>Line numbers in your response should match actual file line numbers from the diff</rule>\n    <rule>Focus on real issues, not nitpicks or cosmetic concerns</rule>\n    <rule>Provide actionable, specific feedback with clear remediation steps</rule>\n    <rule>For INCREMENTAL analysis, ONLY review changes in commit_diff section</rule>\n    <rule>For FULL analysis, review all changes in full_diff section</rule>\n    <rule>Reference specific XML elements like files_summary, metadata when providing context</rule>\n    <rule>STRICT OUTPUT POLICY: Report only actual problems, risks, or deficiencies. Do not write praise, congratulations, or celebratory text. Do not create issues that merely restate improvements or say \"no action needed\".</rule>\n    <rule>SEVERITY ASSIGNMENT: Assign severity ONLY to problems introduced or left unresolved by this change (critical/error/warning/info as appropriate). Do NOT create issue entries solely to acknowledge improvements; if no problems exist, return zero issues.</rule>\n  </rules>\n</review_request>`;\n    }\n\n    // For non-code-review schemas, just provide instructions and context without review-specific wrapper\n    if (skipPRContext) {\n      // Session reuse: just send new instructions\n      return `<instructions>\n${customInstructions}\n</instructions>`;\n    }\n\n    return `<instructions>\n${customInstructions}\n</instructions>\n\n<context>\n${prContext}\n</context>`;\n  }\n\n  // REMOVED: Built-in prompts - only use custom prompts from .visor.yaml\n\n  // REMOVED: getFocusInstructions - only use custom prompts from .visor.yaml\n\n  /**\n   * Format PR or Issue context for the AI using XML structure\n   */\n  private async formatPRContext(prInfo: PRInfo, isCodeReviewSchema?: boolean): Promise<string> {\n    // Check if this is an issue (not a PR)\n    const prContextInfo = prInfo as PRInfo & {\n      isPRContext?: boolean;\n      includeCodeContext?: boolean;\n    };\n    const isIssue = prContextInfo.isIssue === true;\n\n    // Check if we should include code context (diffs)\n    const isPRContext = prContextInfo.isPRContext === true;\n    // In PR context, always include diffs. Otherwise check the flag.\n    const includeCodeContext = isPRContext || prContextInfo.includeCodeContext !== false;\n\n    // Log the decision for transparency (debug level)\n    if (isPRContext) {\n      log('üîç Including full code diffs in AI context (PR mode)');\n    } else if (!includeCodeContext) {\n      log('üìä Including only file summary in AI context (no diffs)');\n    } else {\n      log('üîç Including code diffs in AI context');\n    }\n\n    if (isIssue) {\n      // Format as issue context\n      let context = `<issue>\n  <!-- Core issue metadata including identification, status, and timeline information -->\n  <metadata>\n    <number>${prInfo.number}</number>\n    <title>${this.escapeXml(prInfo.title)}</title>\n    <author>${prInfo.author}</author>\n    <state>${(prInfo as PRInfo & { eventContext?: { issue?: { state?: string; created_at?: string; updated_at?: string; comments?: number } } }).eventContext?.issue?.state || 'open'}</state>\n    <created_at>${(prInfo as PRInfo & { eventContext?: { issue?: { state?: string; created_at?: string; updated_at?: string; comments?: number } } }).eventContext?.issue?.created_at || ''}</created_at>\n    <updated_at>${(prInfo as PRInfo & { eventContext?: { issue?: { state?: string; updated_at?: string; comments?: number } } }).eventContext?.issue?.updated_at || ''}</updated_at>\n    <comments_count>${(prInfo as PRInfo & { eventContext?: { issue?: { comments?: number } } }).eventContext?.issue?.comments || 0}</comments_count>\n  </metadata>`;\n\n      // Add issue body/description if available\n      if (prInfo.body) {\n        context += `\n  <!-- Full issue description and body text provided by the issue author -->\n  <description>\n${this.escapeXml(prInfo.body)}\n  </description>`;\n      }\n\n      // Add labels if available\n      const eventContext = prInfo as PRInfo & {\n        eventContext?: { issue?: { labels?: Array<{ name?: string } | string> } };\n      };\n      const labels = eventContext.eventContext?.issue?.labels;\n      if (labels && labels.length > 0) {\n        context += `\n  <!-- Applied labels for issue categorization and organization -->\n  <labels>`;\n        labels.forEach((label: { name?: string } | string) => {\n          const labelName = typeof label === 'string' ? label : label.name || 'unknown';\n          context += `\n    <label>${this.escapeXml(labelName)}</label>`;\n        });\n        context += `\n  </labels>`;\n      }\n\n      // Add assignees if available\n      const assignees = (\n        prInfo as PRInfo & {\n          eventContext?: { issue?: { assignees?: Array<{ login?: string } | string> } };\n        }\n      ).eventContext?.issue?.assignees;\n      if (assignees && assignees.length > 0) {\n        context += `\n  <!-- Users assigned to work on this issue -->\n  <assignees>`;\n        assignees.forEach((assignee: { login?: string } | string) => {\n          const assigneeName =\n            typeof assignee === 'string' ? assignee : assignee.login || 'unknown';\n          context += `\n    <assignee>${this.escapeXml(assigneeName)}</assignee>`;\n        });\n        context += `\n  </assignees>`;\n      }\n\n      // Add milestone if available\n      const milestone = (\n        prInfo as PRInfo & {\n          eventContext?: {\n            issue?: { milestone?: { title?: string; state?: string; due_on?: string } };\n          };\n        }\n      ).eventContext?.issue?.milestone;\n      if (milestone) {\n        context += `\n  <!-- Associated project milestone information -->\n  <milestone>\n    <title>${this.escapeXml(milestone.title || '')}</title>\n    <state>${milestone.state || 'open'}</state>\n    <due_on>${milestone.due_on || ''}</due_on>\n  </milestone>`;\n      }\n\n      // Add current/triggering comment if this is a comment event\n      const triggeringComment = (\n        prInfo as PRInfo & {\n          eventContext?: {\n            comment?: {\n              user?: { login?: string };\n              created_at?: string;\n              body?: string;\n              id?: number;\n            };\n          };\n        }\n      ).eventContext?.comment;\n      if (triggeringComment) {\n        context += `\n  <!-- The comment that triggered this analysis -->\n  <triggering_comment>\n    <author>${this.escapeXml(triggeringComment.user?.login || 'unknown')}</author>\n    <created_at>${triggeringComment.created_at || ''}</created_at>\n    <body>${this.escapeXml(triggeringComment.body || '')}</body>\n  </triggering_comment>`;\n      }\n\n      // Add comment history (excluding the current comment if it exists)\n      const issueComments = (\n        prInfo as PRInfo & {\n          comments?: Array<{ id?: number; author?: string; body?: string; createdAt?: string }>;\n        }\n      ).comments;\n      if (issueComments && issueComments.length > 0) {\n        // Filter out the triggering comment from history if present\n        let historicalComments = triggeringComment\n          ? issueComments.filter(c => c.id !== triggeringComment.id)\n          : issueComments;\n\n        // For code-review schema checks, filter out previous Visor code-review comments to avoid self-bias\n        // Comment IDs look like: <!-- visor-comment-id:pr-review-244-review -->\n        if (isCodeReviewSchema) {\n          historicalComments = historicalComments.filter(\n            c => !c.body || !c.body.includes('visor-comment-id:pr-review-')\n          );\n        }\n\n        if (historicalComments.length > 0) {\n          context += `\n  <!-- Previous comments in chronological order (excluding triggering comment) -->\n  <comment_history>`;\n          historicalComments.forEach(comment => {\n            context += `\n    <comment>\n      <author>${this.escapeXml(comment.author || 'unknown')}</author>\n      <created_at>${comment.createdAt || ''}</created_at>\n      <body>${this.escapeXml(comment.body || '')}</body>\n    </comment>`;\n          });\n          context += `\n  </comment_history>`;\n        }\n      }\n\n      // Close the issue tag\n      context += `\n</issue>`;\n\n      return context;\n    }\n\n    // Original PR context formatting\n    let context = `<pull_request>\n  <!-- Core pull request metadata including identification, branches, and change statistics -->\n  <metadata>\n    <number>${prInfo.number}</number>\n    <title>${this.escapeXml(prInfo.title)}</title>\n    <author>${prInfo.author}</author>\n    <base_branch>${prInfo.base}</base_branch>\n    <target_branch>${prInfo.head}</target_branch>\n    <total_additions>${prInfo.totalAdditions}</total_additions>\n    <total_deletions>${prInfo.totalDeletions}</total_deletions>\n    <files_changed_count>${prInfo.files.length}</files_changed_count>\n  </metadata>`;\n\n    // Include a small raw diff header snippet for compatibility with tools/tests\n    try {\n      const firstFile = (prInfo.files || [])[0];\n      if (firstFile && firstFile.filename) {\n        context += `\\n  <raw_diff_header>\\n${this.escapeXml(`diff --git a/${firstFile.filename} b/${firstFile.filename}`)}\\n  </raw_diff_header>`;\n      }\n    } catch {}\n\n    // Add PR description if available\n    if (prInfo.body) {\n      context += `\n  <!-- Full pull request description provided by the author -->\n  <description>\n${this.escapeXml(prInfo.body)}\n  </description>`;\n    }\n\n    // Add diffs only if includeCodeContext is true (or in PR mode)\n    if (includeCodeContext) {\n      // Add full diff if available (for complete PR review)\n      if (prInfo.fullDiff) {\n        // Process the diff with outline-diff format for better structure\n        const processedFullDiff = await processDiffWithOutline(prInfo.fullDiff);\n        context += `\n  <!-- Complete unified diff showing all changes in the pull request (processed with outline-diff) -->\n  <full_diff>\n${this.escapeXml(processedFullDiff)}\n  </full_diff>`;\n      }\n\n      // Add incremental commit diff if available (for new commit analysis)\n      if (prInfo.isIncremental) {\n        if (prInfo.commitDiff && prInfo.commitDiff.length > 0) {\n          // Process the commit diff with outline-diff format for better structure\n          const processedCommitDiff = await processDiffWithOutline(prInfo.commitDiff);\n          context += `\n  <!-- Diff of only the latest commit for incremental analysis (processed with outline-diff) -->\n  <commit_diff>\n${this.escapeXml(processedCommitDiff)}\n  </commit_diff>`;\n        } else {\n          // Process the fallback full diff with outline-diff format\n          const processedFallbackDiff = prInfo.fullDiff\n            ? await processDiffWithOutline(prInfo.fullDiff)\n            : '';\n          context += `\n  <!-- Commit diff could not be retrieved - falling back to full diff analysis (processed with outline-diff) -->\n  <commit_diff>\n${this.escapeXml(processedFallbackDiff)}\n  </commit_diff>`;\n        }\n      }\n    } else {\n      // When not including diffs, add a note about it\n      context += `\n  <!-- Code diffs excluded to reduce token usage (no code-review schema detected or disabled by flag) -->`;\n    }\n\n    // Add file summary for context\n    if (prInfo.files.length > 0) {\n      context += `\n  <!-- Summary of all files changed with statistics -->\n  <files_summary>`;\n      prInfo.files.forEach(file => {\n        context += `\n    <file>\n      <filename>${this.escapeXml(file.filename)}</filename>\n      <status>${file.status}</status>\n      <additions>${file.additions}</additions>\n      <deletions>${file.deletions}</deletions>\n    </file>`;\n      });\n      context += `\n  </files_summary>`;\n    }\n\n    // Add current/triggering comment if this is a comment event\n    const triggeringComment = (\n      prInfo as PRInfo & {\n        eventContext?: {\n          comment?: { user?: { login?: string }; created_at?: string; body?: string; id?: number };\n        };\n      }\n    ).eventContext?.comment;\n    if (triggeringComment) {\n      context += `\n  <!-- The comment that triggered this analysis -->\n  <triggering_comment>\n    <author>${this.escapeXml(triggeringComment.user?.login || 'unknown')}</author>\n    <created_at>${triggeringComment.created_at || ''}</created_at>\n    <body>${this.escapeXml(triggeringComment.body || '')}</body>\n  </triggering_comment>`;\n    }\n\n    // Add comment history (excluding the current comment if it exists)\n    const prComments = (\n      prInfo as PRInfo & {\n        comments?: Array<{ id?: number; author?: string; body?: string; createdAt?: string }>;\n      }\n    ).comments;\n    if (prComments && prComments.length > 0) {\n      // Filter out the triggering comment from history if present\n      let historicalComments = triggeringComment\n        ? prComments.filter(c => c.id !== triggeringComment.id)\n        : prComments;\n\n      // For code-review schema checks, filter out previous Visor code-review comments to avoid self-bias\n      // Comment IDs look like: <!-- visor-comment-id:pr-review-244-review -->\n      if (isCodeReviewSchema) {\n        historicalComments = historicalComments.filter(\n          c => !c.body || !c.body.includes('visor-comment-id:pr-review-')\n        );\n      }\n\n      if (historicalComments.length > 0) {\n        context += `\n  <!-- Previous PR comments in chronological order (excluding triggering comment) -->\n  <comment_history>`;\n        historicalComments.forEach(comment => {\n          context += `\n    <comment>\n      <author>${this.escapeXml(comment.author || 'unknown')}</author>\n      <created_at>${comment.createdAt || ''}</created_at>\n      <body>${this.escapeXml(comment.body || '')}</body>\n    </comment>`;\n        });\n        context += `\n  </comment_history>`;\n      }\n    }\n\n    context += `\n</pull_request>`;\n\n    return context;\n  }\n\n  /**\n   * No longer escaping XML - returning text as-is\n   */\n  private escapeXml(text: string): string {\n    return text;\n  }\n\n  /**\n   * Call ProbeAgent with an existing session\n   */\n  private async callProbeAgentWithExistingSession(\n    agent: TracedProbeAgent,\n    prompt: string,\n    schema?: string | Record<string, unknown>,\n    debugInfo?: AIDebugInfo,\n    _checkName?: string\n  ): Promise<{ response: string; effectiveSchema?: string }> {\n    // Handle mock model/provider for testing\n    if (this.config.model === 'mock' || this.config.provider === 'mock') {\n      log('üé≠ Using mock AI model/provider for testing (session reuse)');\n      const response = await this.generateMockResponse(prompt, _checkName, schema);\n      return { response, effectiveSchema: typeof schema === 'object' ? 'custom' : schema };\n    }\n\n    log('üîÑ Reusing existing ProbeAgent session for AI review...');\n    log(`üìù Prompt length: ${prompt.length} characters`);\n    log(`‚öôÔ∏è Model: ${this.config.model || 'default'}, Provider: ${this.config.provider || 'auto'}`);\n\n    try {\n      log('üöÄ Calling existing ProbeAgent with answer()...');\n\n      // Load and pass the actual schema content if provided (skip for plain schema)\n      let schemaString: string | undefined = undefined;\n      let effectiveSchema: string | undefined = typeof schema === 'object' ? 'custom' : schema;\n\n      if (schema && schema !== 'plain') {\n        try {\n          schemaString = await this.loadSchemaContent(schema);\n          log(`üìã Loaded schema content for: ${schema}`);\n          log(`üìÑ Raw schema JSON:\\n${schemaString}`);\n        } catch (error) {\n          log(`‚ö†Ô∏è Failed to load schema ${schema}, proceeding without schema:`, error);\n          schemaString = undefined;\n          effectiveSchema = undefined; // Schema loading failed, treat as no schema\n          if (debugInfo && debugInfo.errors) {\n            debugInfo.errors.push(`Failed to load schema: ${error}`);\n          }\n        }\n      } else if (schema === 'plain') {\n        log(`üìã Using plain schema - no JSON validation will be applied`);\n      }\n\n      // Pass schema in options object with 'schema' property\n      const schemaOptions = schemaString ? { schema: schemaString } : undefined;\n\n      // Store the exact schema options being passed to ProbeAgent in debug info\n      if (debugInfo && schemaOptions) {\n        debugInfo.schema = JSON.stringify(schemaOptions, null, 2);\n      }\n\n      // Log the schema options being passed to ProbeAgent\n      if (schemaOptions) {\n        log(`üéØ Schema options passed to ProbeAgent.answer() (session reuse):`);\n        log(JSON.stringify(schemaOptions, null, 2));\n      }\n\n      // Save prompt and debug info for session reuse too (only if debug enabled)\n      if (process.env.VISOR_DEBUG_AI_SESSIONS === 'true') {\n        try {\n          const fs = require('fs');\n          const path = require('path');\n          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n          const provider = this.config.provider || 'auto';\n          const model = this.config.model || 'default';\n\n          // Try to extract conversation history from ProbeAgent\n          let conversationHistory: any[] = [];\n          try {\n            // ProbeAgent stores history in different ways depending on version\n            const agentAny = agent as any;\n            if (agentAny.history) {\n              conversationHistory = agentAny.history;\n            } else if (agentAny.messages) {\n              conversationHistory = agentAny.messages;\n            } else if (agentAny._messages) {\n              conversationHistory = agentAny._messages;\n            }\n          } catch {\n            // Ignore if we can't access history\n          }\n\n          const debugData = {\n            timestamp: timestamp,\n            checkName: _checkName || 'unknown',\n            provider: provider,\n            model: model,\n            schema: effectiveSchema,\n            schemaOptions: schemaOptions || 'none',\n            sessionInfo: {\n              isSessionReuse: true,\n              historyMessageCount: conversationHistory.length,\n            },\n            currentPromptLength: prompt.length,\n            currentPrompt: prompt,\n            conversationHistory: conversationHistory,\n          };\n\n          const debugJson = JSON.stringify(debugData, null, 2);\n\n          // Also create a human-readable version with clear separators\n          let readableVersion = `=============================================================\\n`;\n          readableVersion += `VISOR DEBUG REPORT - SESSION REUSE\\n`;\n          readableVersion += `=============================================================\\n`;\n          readableVersion += `Timestamp: ${timestamp}\\n`;\n          readableVersion += `Check Name: ${_checkName || 'unknown'}\\n`;\n          readableVersion += `Provider: ${provider}\\n`;\n          readableVersion += `Model: ${model}\\n`;\n          readableVersion += `Schema: ${effectiveSchema}\\n`;\n          readableVersion += `Schema Options: ${schemaOptions ? 'provided' : 'none'}\\n`;\n          readableVersion += `History Messages: ${conversationHistory.length}\\n`;\n          readableVersion += `=============================================================\\n\\n`;\n\n          // Add schema details if provided\n          if (schemaOptions) {\n            readableVersion += `\\n${'='.repeat(60)}\\n`;\n            readableVersion += `SCHEMA CONFIGURATION\\n`;\n            readableVersion += `${'='.repeat(60)}\\n`;\n            readableVersion += JSON.stringify(schemaOptions, null, 2);\n            readableVersion += `\\n`;\n          }\n\n          // Add conversation history with clear separators\n          if (conversationHistory.length > 0) {\n            readableVersion += `\\n${'='.repeat(60)}\\n`;\n            readableVersion += `CONVERSATION HISTORY (${conversationHistory.length} messages)\\n`;\n            readableVersion += `${'='.repeat(60)}\\n`;\n            conversationHistory.forEach((msg: any, index: number) => {\n              readableVersion += `\\n${'-'.repeat(60)}\\n`;\n              readableVersion += `MESSAGE #${index + 1}\\n`;\n              readableVersion += `Role: ${msg.role || 'unknown'}\\n`;\n              if (msg.content) {\n                const contentStr =\n                  typeof msg.content === 'string'\n                    ? msg.content\n                    : JSON.stringify(msg.content, null, 2);\n                readableVersion += `Length: ${contentStr.length} characters\\n`;\n                readableVersion += `${'-'.repeat(60)}\\n`;\n                readableVersion += `${contentStr}\\n`;\n              }\n            });\n          }\n\n          // Add current prompt\n          readableVersion += `\\n${'='.repeat(60)}\\n`;\n          readableVersion += `CURRENT PROMPT (NEW MESSAGE)\\n`;\n          readableVersion += `${'='.repeat(60)}\\n`;\n          readableVersion += `Length: ${prompt.length} characters\\n`;\n          readableVersion += `${'-'.repeat(60)}\\n`;\n          readableVersion += `${prompt}\\n`;\n          readableVersion += `\\n${'='.repeat(60)}\\n`;\n          readableVersion += `END OF DEBUG REPORT\\n`;\n          readableVersion += `${'='.repeat(60)}\\n`;\n\n          const debugArtifactsDir =\n            process.env.VISOR_DEBUG_ARTIFACTS || path.join(process.cwd(), 'debug-artifacts');\n          if (!fs.existsSync(debugArtifactsDir)) {\n            fs.mkdirSync(debugArtifactsDir, { recursive: true });\n          }\n\n          // Save JSON version\n          const debugFile = path.join(\n            debugArtifactsDir,\n            `prompt-${_checkName || 'unknown'}-${timestamp}.json`\n          );\n          fs.writeFileSync(debugFile, debugJson, 'utf-8');\n\n          // Save readable version\n          const readableFile = path.join(\n            debugArtifactsDir,\n            `prompt-${_checkName || 'unknown'}-${timestamp}.txt`\n          );\n          fs.writeFileSync(readableFile, readableVersion, 'utf-8');\n\n          log(`\\nüíæ Full debug info saved to:`);\n          log(`   JSON: ${debugFile}`);\n          log(`   TXT:  ${readableFile}`);\n          log(`   - Includes: full conversation history, schema, current prompt`);\n        } catch (error) {\n          log(`‚ö†Ô∏è Could not save debug file: ${error}`);\n        }\n      }\n\n      // Use existing agent's answer method - this reuses the conversation context\n      // Wrap in a span for hierarchical tracing\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const agentAny = agent as any;\n      let response: string;\n      if (agentAny.tracer && typeof agentAny.tracer.withSpan === 'function') {\n        response = await agentAny.tracer.withSpan(\n          'visor.ai_check_reuse',\n          async () => {\n            return await agent.answer(prompt, undefined, schemaOptions);\n          },\n          {\n            'check.name': _checkName || 'unknown',\n            'check.mode': 'session_reuse',\n            'prompt.length': prompt.length,\n            'schema.type': effectiveSchema || 'none',\n          }\n        );\n      } else {\n        response = schemaOptions\n          ? await agent.answer(prompt, undefined, schemaOptions)\n          : await agent.answer(prompt);\n      }\n\n      log('‚úÖ ProbeAgent session reuse completed successfully');\n      log(`üì§ Response length: ${response.length} characters`);\n\n      // Save COMPLETE conversation history AFTER AI response (only if debug enabled)\n      if (process.env.VISOR_DEBUG_AI_SESSIONS === 'true') {\n        try {\n          const fs = require('fs');\n          const path = require('path');\n          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n\n          // Extract FULL conversation history AFTER the AI call\n          const agentAny = agent as any;\n          let fullHistory: any[] = [];\n\n          // Try multiple properties to get complete history\n          if (agentAny.history) {\n            fullHistory = agentAny.history;\n          } else if (agentAny.messages) {\n            fullHistory = agentAny.messages;\n          } else if (agentAny._messages) {\n            fullHistory = agentAny._messages;\n          }\n\n          const debugArtifactsDir =\n            process.env.VISOR_DEBUG_ARTIFACTS || path.join(process.cwd(), 'debug-artifacts');\n          // do not enforce directory perms here\n\n          // Save complete session history (all messages sent and received)\n          const sessionBase = path.join(\n            debugArtifactsDir,\n            `session-${_checkName || 'unknown'}-${timestamp}`\n          );\n          const sessionData = {\n            timestamp,\n            checkName: _checkName || 'unknown',\n            provider: this.config.provider || 'auto',\n            model: this.config.model || 'default',\n            schema: effectiveSchema,\n            totalMessages: fullHistory.length,\n          };\n          fs.writeFileSync(sessionBase + '.json', JSON.stringify(sessionData, null, 2), 'utf-8');\n\n          // Redacted textual summary\n          let readable = `=============================================================\n`;\n          readable += `COMPLETE AI SESSION HISTORY (AFTER RESPONSE)\n`;\n          readable += `=============================================================\n`;\n          readable += `Timestamp: ${timestamp}\n`;\n          readable += `Check: ${_checkName || 'unknown'}\n`;\n          readable += `Total Messages: ${fullHistory.length}\n`;\n          readable += `=============================================================\n\n`;\n          fullHistory.forEach((msg: any, idx: number) => {\n            const role = msg.role || 'unknown';\n            const content =\n              typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content, null, 2);\n            readable += `\n${'='.repeat(60)}\nMESSAGE ${idx + 1}/${fullHistory.length}\nRole: ${role}\n${'='.repeat(60)}\n`;\n            readable += content + '\\n';\n          });\n          fs.writeFileSync(sessionBase + '.summary.txt', readable, 'utf-8');\n\n          log(`üíæ Complete session history saved:`);\n          // (paths omitted)\n          log(`   - Contains ALL ${fullHistory.length} messages (prompts + responses)`);\n        } catch (error) {\n          log(`‚ö†Ô∏è Could not save complete session history: ${error}`);\n        }\n      }\n\n      // Save response if debug is enabled\n      if (process.env.VISOR_DEBUG_AI_SESSIONS === 'true') {\n        try {\n          const fs = require('fs');\n          const path = require('path');\n          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n\n          const debugArtifactsDir =\n            process.env.VISOR_DEBUG_ARTIFACTS || path.join(process.cwd(), 'debug-artifacts');\n\n          // Create a response file with the same timestamp pattern\n          const responseFile = path.join(\n            debugArtifactsDir,\n            `response-${_checkName || 'unknown'}-${timestamp}.txt`\n          );\n\n          let responseContent = `=============================================================\\n`;\n          responseContent += `VISOR AI RESPONSE - SESSION REUSE\\n`;\n          responseContent += `=============================================================\\n`;\n          responseContent += `Timestamp: ${timestamp}\\n`;\n          responseContent += `Check Name: ${_checkName || 'unknown'}\\n`;\n          responseContent += `Response Length: ${response.length} characters\\n`;\n          responseContent += `=============================================================\\n\\n`;\n          responseContent += `${'='.repeat(60)}\\n`;\n          responseContent += `AI RESPONSE\\n`;\n          responseContent += `${'='.repeat(60)}\\n`;\n          responseContent += response;\n          responseContent += `\\n${'='.repeat(60)}\\n`;\n          responseContent += `END OF RESPONSE\\n`;\n          responseContent += `${'='.repeat(60)}\\n`;\n\n          fs.writeFileSync(responseFile, responseContent, 'utf-8');\n          log(`üíæ Response saved to: ${responseFile}`);\n        } catch (error) {\n          log(`‚ö†Ô∏è Could not save response file: ${error}`);\n        }\n      }\n\n      // Finalize and save trace if this is a cloned session with tracing enabled\n      // Properly flush and shutdown OpenTelemetry to ensure all spans are exported\n      if (agentAny._traceFilePath && agentAny._telemetryConfig) {\n        try {\n          // First flush the tracer to export pending spans\n          if (agentAny.tracer && typeof agentAny.tracer.flush === 'function') {\n            await agentAny.tracer.flush();\n            log(`üîÑ Flushed tracer spans for cloned session`);\n          }\n\n          // Then shutdown the telemetry config to finalize all exporters\n          if (\n            agentAny._telemetryConfig &&\n            typeof agentAny._telemetryConfig.shutdown === 'function'\n          ) {\n            await agentAny._telemetryConfig.shutdown();\n            log(`üìä OpenTelemetry trace saved to: ${agentAny._traceFilePath}`);\n\n            // In GitHub Actions, also log file size for verification\n            if (process.env.GITHUB_ACTIONS) {\n              const fs = require('fs');\n              if (fs.existsSync(agentAny._traceFilePath)) {\n                const stats = fs.statSync(agentAny._traceFilePath);\n                console.log(\n                  `::notice title=AI Trace Saved::${agentAny._traceFilePath} (${stats.size} bytes)`\n                );\n              }\n            }\n          } else if (agentAny.tracer && typeof agentAny.tracer.shutdown === 'function') {\n            // Fallback for SimpleTelemetry\n            await agentAny.tracer.shutdown();\n            log(`üìä Trace saved to: ${agentAny._traceFilePath}`);\n          }\n        } catch (exportError) {\n          logger.warn(`‚ö†Ô∏è  Warning: Failed to export trace for cloned session: ${exportError}`);\n        }\n      }\n\n      return { response, effectiveSchema };\n    } catch (error) {\n      logger.error(\n        `‚ùå ProbeAgent session reuse failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n      throw new Error(\n        `ProbeAgent session reuse failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Call ProbeAgent SDK with built-in schema validation\n   */\n  private async callProbeAgent(\n    prompt: string,\n    schema?: string | Record<string, unknown>,\n    debugInfo?: AIDebugInfo,\n    _checkName?: string,\n    providedSessionId?: string\n  ): Promise<{ response: string; effectiveSchema?: string }> {\n    // Handle mock model/provider\n    if (this.config.model === 'mock' || this.config.provider === 'mock') {\n      const inJest = !!process.env.JEST_WORKER_ID;\n      log('üé≠ Using mock AI model/provider');\n      if (!inJest) {\n        // Fast path for CLI/integration: synthesize a mock response without invoking ProbeAgent\n        const response = await this.generateMockResponse(prompt, _checkName, schema);\n        return { response, effectiveSchema: typeof schema === 'object' ? 'custom' : schema };\n      }\n      // In unit tests, still invoke ProbeAgent so tests can assert on options (schema) passed in\n      // Fall through to normal flow below\n    }\n\n    // Create ProbeAgent instance with proper options\n    const sessionId =\n      providedSessionId ||\n      (() => {\n        const timestamp = new Date().toISOString();\n        return `visor-${timestamp.replace(/[:.]/g, '-')}-${_checkName || 'unknown'}`;\n      })();\n\n    log('ü§ñ Creating ProbeAgent for AI review...');\n    log(`üÜî Session ID: ${sessionId}`);\n    log(`üìù Prompt length: ${prompt.length} characters`);\n    log(`‚öôÔ∏è Model: ${this.config.model || 'default'}, Provider: ${this.config.provider || 'auto'}`);\n\n    // Store original env vars to restore later\n    const originalEnv: Record<string, string | undefined> = {\n      CLAUDE_CODE_API_KEY: process.env.CLAUDE_CODE_API_KEY,\n      GOOGLE_API_KEY: process.env.GOOGLE_API_KEY,\n      ANTHROPIC_API_KEY: process.env.ANTHROPIC_API_KEY,\n      OPENAI_API_KEY: process.env.OPENAI_API_KEY,\n    };\n\n    try {\n      // Set environment variables for ProbeAgent\n      // ProbeAgent SDK expects these to be in the environment\n      if (this.config.provider === 'claude-code' && this.config.apiKey) {\n        process.env.CLAUDE_CODE_API_KEY = this.config.apiKey;\n        // Also set ANTHROPIC_API_KEY as fallback since Claude Code uses Anthropic API\n        process.env.ANTHROPIC_API_KEY = this.config.apiKey;\n      } else if (this.config.provider === 'google' && this.config.apiKey) {\n        process.env.GOOGLE_API_KEY = this.config.apiKey;\n      } else if (this.config.provider === 'anthropic' && this.config.apiKey) {\n        process.env.ANTHROPIC_API_KEY = this.config.apiKey;\n      } else if (this.config.provider === 'openai' && this.config.apiKey) {\n        process.env.OPENAI_API_KEY = this.config.apiKey;\n      } else if (this.config.provider === 'bedrock') {\n        // For Bedrock, ProbeAgent will use AWS credentials from environment\n        // No need to set apiKey as it uses AWS SDK authentication\n        // ProbeAgent will check for AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, etc.\n      }\n      const explicitPromptType = (process.env.VISOR_PROMPT_TYPE || '').trim();\n      const options: TracedProbeAgentOptions = {\n        sessionId: sessionId,\n        // Prefer config promptType, then env override, else fallback to code-review when schema is set\n        promptType:\n          this.config.promptType && this.config.promptType.trim()\n            ? (this.config.promptType.trim() as any)\n            : explicitPromptType\n              ? (explicitPromptType as any)\n              : schema === 'code-review'\n                ? ('code-review-template' as any)\n                : undefined,\n        allowEdit: false, // We don't want the agent to modify files\n        debug: this.config.debug || false,\n        // Map systemPrompt to Probe customPrompt until SDK exposes a first-class field\n        customPrompt: this.config.systemPrompt || this.config.customPrompt,\n      };\n\n      // Enable tracing in debug mode for better diagnostics\n      // This uses SimpleTelemetry for lightweight tracing\n      let traceFilePath = '';\n      let telemetryConfig: unknown = null;\n      if (this.config.debug) {\n        const tracerResult = await initializeTracer(sessionId, _checkName);\n        if (tracerResult) {\n          options.tracer = tracerResult.tracer;\n          telemetryConfig = tracerResult.telemetryConfig;\n          traceFilePath = tracerResult.filePath;\n        }\n      }\n\n      // Wire MCP configuration when provided\n      if (this.config.mcpServers && Object.keys(this.config.mcpServers).length > 0) {\n        (options as any).enableMcp = true;\n        (options as any).mcpConfig = { mcpServers: this.config.mcpServers };\n      }\n\n      // Enable delegate tool if configured\n      if (this.config.enableDelegate !== undefined) {\n        (options as any).enableDelegate = this.config.enableDelegate;\n      }\n\n      // Pass retry configuration to ProbeAgent\n      if (this.config.retry) {\n        (options as any).retry = this.config.retry;\n      }\n\n      // Pass fallback configuration to ProbeAgent\n      if (this.config.fallback) {\n        (options as any).fallback = this.config.fallback;\n      }\n\n      // Enable Edit and Create tools if configured\n      if (this.config.allowEdit !== undefined) {\n        (options as any).allowEdit = this.config.allowEdit;\n      }\n\n      // Pass tool filtering options to ProbeAgent\n      if (this.config.allowedTools !== undefined) {\n        (options as any).allowedTools = this.config.allowedTools;\n      }\n      if (this.config.disableTools !== undefined) {\n        (options as any).disableTools = this.config.disableTools;\n      }\n\n      // Pass bash command execution configuration to ProbeAgent\n      // Pass allowBash and bashConfig separately (following allowEdit pattern)\n      if (this.config.allowBash !== undefined) {\n        (options as any).allowBash = this.config.allowBash;\n      }\n      if (this.config.bashConfig !== undefined) {\n        (options as any).bashConfig = this.config.bashConfig;\n      }\n\n      // Add provider-specific options if configured\n      if (this.config.provider) {\n        // Map claude-code to anthropic for ProbeAgent compatibility\n        // Map bedrock to anthropic temporarily until ProbeAgent adds bedrock type\n        const providerOverride: ProbeAgentOptions['provider'] | undefined =\n          this.config.provider === 'claude-code' || this.config.provider === 'bedrock'\n            ? 'anthropic'\n            : this.config.provider === 'anthropic' ||\n                this.config.provider === 'openai' ||\n                this.config.provider === 'google'\n              ? this.config.provider\n              : undefined;\n\n        if (providerOverride) {\n          options.provider = providerOverride;\n        }\n      }\n      if (this.config.model) {\n        options.model = this.config.model;\n      }\n\n      const agent = new ProbeAgent(options);\n\n      log('üöÄ Calling ProbeAgent...');\n      // Load and pass the actual schema content if provided (skip for plain schema)\n      let schemaString: string | undefined = undefined;\n      let effectiveSchema: string | undefined = typeof schema === 'object' ? 'custom' : schema;\n\n      if (schema && schema !== 'plain') {\n        try {\n          schemaString = await this.loadSchemaContent(schema);\n          log(`üìã Loaded schema content for: ${schema}`);\n          log(`üìÑ Raw schema JSON:\\n${schemaString}`);\n        } catch (error) {\n          log(`‚ö†Ô∏è Failed to load schema ${schema}, proceeding without schema:`, error);\n          schemaString = undefined;\n          effectiveSchema = undefined; // Schema loading failed, treat as no schema\n          if (debugInfo && debugInfo.errors) {\n            debugInfo.errors.push(`Failed to load schema: ${error}`);\n          }\n        }\n      } else if (schema === 'plain') {\n        log(`üìã Using plain schema - no JSON validation will be applied`);\n      }\n\n      // ProbeAgent now handles schema formatting internally!\n      // Pass schema in options object with 'schema' property\n      const schemaOptions = schemaString ? { schema: schemaString } : undefined;\n\n      // Store the exact schema options being passed to ProbeAgent in debug info\n      if (debugInfo && schemaOptions) {\n        debugInfo.schema = JSON.stringify(schemaOptions, null, 2);\n      }\n\n      // Log the schema options being passed to ProbeAgent\n      if (schemaOptions) {\n        log(`üéØ Schema options passed to ProbeAgent.answer():`);\n        log(JSON.stringify(schemaOptions, null, 2));\n      }\n\n      // Log the equivalent CLI command for local reproduction\n      const provider = this.config.provider || 'auto';\n      const model = this.config.model || 'default';\n\n      // Save prompt to a temp file AND debug artifacts for easier reproduction (only if debug enabled)\n      if (process.env.VISOR_DEBUG_AI_SESSIONS === 'true') {\n        try {\n          const fs = require('fs');\n          const path = require('path');\n          const os = require('os');\n          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n\n          // Prepare debug info with full details\n          const debugData = {\n            timestamp,\n            checkName: _checkName || 'unknown',\n            provider,\n            model,\n            schema: effectiveSchema,\n            schemaOptions: schemaOptions || 'none',\n            sessionInfo: {\n              isSessionReuse: false,\n              isNewSession: true,\n            },\n            promptLength: prompt.length,\n            prompt: prompt,\n          };\n\n          const debugJson = JSON.stringify(debugData, null, 2);\n\n          // Create human-readable version with clear separators\n          let readableVersion = `=============================================================\\n`;\n          readableVersion += `VISOR DEBUG REPORT - NEW SESSION\\n`;\n          readableVersion += `=============================================================\\n`;\n          readableVersion += `Timestamp: ${timestamp}\\n`;\n          readableVersion += `Check Name: ${_checkName || 'unknown'}\\n`;\n          readableVersion += `Provider: ${provider}\\n`;\n          readableVersion += `Model: ${model}\\n`;\n          readableVersion += `Schema: ${effectiveSchema}\\n`;\n          readableVersion += `Schema Options: ${schemaOptions ? 'provided' : 'none'}\\n`;\n          readableVersion += `Session Type: New Session (no history)\\n`;\n          readableVersion += `=============================================================\\n\\n`;\n\n          // Add schema details if provided\n          if (schemaOptions) {\n            readableVersion += `\\n${'='.repeat(60)}\\n`;\n            readableVersion += `SCHEMA CONFIGURATION\\n`;\n            readableVersion += `${'='.repeat(60)}\\n`;\n            readableVersion += JSON.stringify(schemaOptions, null, 2);\n            readableVersion += `\\n`;\n          }\n\n          // Add prompt\n          readableVersion += `\\n${'='.repeat(60)}\\n`;\n          readableVersion += `PROMPT\\n`;\n          readableVersion += `${'='.repeat(60)}\\n`;\n          readableVersion += `Length: ${prompt.length} characters\\n`;\n          readableVersion += `${'-'.repeat(60)}\\n`;\n          readableVersion += `${prompt}\\n`;\n          readableVersion += `\\n${'='.repeat(60)}\\n`;\n          readableVersion += `END OF DEBUG REPORT\\n`;\n          readableVersion += `${'='.repeat(60)}\\n`;\n\n          // Save to temp directory\n          const tempDir = os.tmpdir();\n          const promptFile = path.join(tempDir, `visor-prompt-${timestamp}.txt`);\n          fs.writeFileSync(promptFile, prompt, 'utf-8');\n          log(`\\nüíæ Prompt saved to: ${promptFile}`);\n\n          // Also save to debug-artifacts directory if available\n          const debugArtifactsDir =\n            process.env.VISOR_DEBUG_ARTIFACTS || path.join(process.cwd(), 'debug-artifacts');\n          try {\n            // do not enforce fs permissions here\n            const base = path.join(\n              debugArtifactsDir,\n              `prompt-${_checkName || 'unknown'}-${timestamp}`\n            );\n            fs.writeFileSync(base + '.json', debugJson, 'utf-8');\n            fs.writeFileSync(base + '.summary.txt', readableVersion, 'utf-8');\n            log(`\nüíæ Full debug info saved to directory: ${debugArtifactsDir}`);\n          } catch {\n            // Ignore if we can't write to debug-artifacts\n          }\n\n          log(`\\nüìù To reproduce locally, run:`);\n\n          let cliCommand = `npx @probelabs/probe@latest agent`;\n          cliCommand += ` --provider ${provider}`;\n          if (model !== 'default') {\n            cliCommand += ` --model ${model}`;\n          }\n          if (schema) {\n            cliCommand += ` --schema output/${schema}/schema.json`;\n          }\n          cliCommand += ` \"${promptFile}\"`;\n\n          log(`\\n$ ${cliCommand}\\n`);\n        } catch (error) {\n          log(`‚ö†Ô∏è Could not save prompt file: ${error}`);\n        }\n      }\n\n      // Wrap the agent.answer() call in a span for hierarchical tracing\n      // This creates a parent span that will contain all ProbeAgent's child spans\n      let response: string;\n      const tracer = options.tracer as {\n        withSpan?: (\n          name: string,\n          fn: () => Promise<string>,\n          attrs?: Record<string, unknown>\n        ) => Promise<string>;\n      };\n      if (tracer && typeof tracer.withSpan === 'function') {\n        response = await tracer.withSpan(\n          'visor.ai_check',\n          async () => {\n            return await agent.answer(prompt, undefined, schemaOptions);\n          },\n          {\n            'check.name': _checkName || 'unknown',\n            'check.session_id': sessionId,\n            'prompt.length': prompt.length,\n            'schema.type': effectiveSchema || 'none',\n          }\n        );\n      } else {\n        response = schemaOptions\n          ? await agent.answer(prompt, undefined, schemaOptions)\n          : await agent.answer(prompt);\n      }\n\n      log('‚úÖ ProbeAgent completed successfully');\n      log(`üì§ Response length: ${response.length} characters`);\n\n      // Save COMPLETE conversation history AFTER AI response (only if debug enabled)\n      if (process.env.VISOR_DEBUG_AI_SESSIONS === 'true') {\n        try {\n          const fs = require('fs');\n          const path = require('path');\n          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n\n          // Extract FULL conversation history AFTER the AI call\n          const agentAny = agent as any;\n          let fullHistory: any[] = [];\n\n          // Try multiple properties to get complete history\n          if (agentAny.history) {\n            fullHistory = agentAny.history;\n          } else if (agentAny.messages) {\n            fullHistory = agentAny.messages;\n          } else if (agentAny._messages) {\n            fullHistory = agentAny._messages;\n          }\n\n          const debugArtifactsDir =\n            process.env.VISOR_DEBUG_ARTIFACTS || path.join(process.cwd(), 'debug-artifacts');\n          // do not enforce fs permissions here\n\n          // Save complete session history (all messages sent and received)\n          const sessionBase = path.join(\n            debugArtifactsDir,\n            `session-${_checkName || 'unknown'}-${timestamp}`\n          );\n          const sessionData = {\n            timestamp,\n            checkName: _checkName || 'unknown',\n            provider: this.config.provider || 'auto',\n            model: this.config.model || 'default',\n            schema: effectiveSchema,\n            totalMessages: fullHistory.length,\n          };\n          fs.writeFileSync(sessionBase + '.json', JSON.stringify(sessionData, null, 2), 'utf-8');\n\n          // Redacted textual summary\n          let readable = `=============================================================\n`;\n          readable += `COMPLETE AI SESSION HISTORY (AFTER RESPONSE)\n`;\n          readable += `=============================================================\n`;\n          readable += `Timestamp: ${timestamp}\n`;\n          readable += `Check: ${_checkName || 'unknown'}\n`;\n          readable += `Total Messages: ${fullHistory.length}\n`;\n          readable += `=============================================================\n\n`;\n          fullHistory.forEach((msg: any, idx: number) => {\n            const role = msg.role || 'unknown';\n            const content =\n              typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content, null, 2);\n            readable += `\n${'='.repeat(60)}\nMESSAGE ${idx + 1}/${fullHistory.length}\nRole: ${role}\n${'='.repeat(60)}\n`;\n            readable += content + '\\n';\n          });\n          fs.writeFileSync(sessionBase + '.summary.txt', readable, 'utf-8');\n\n          log(`üíæ Complete session history saved:`);\n          // (paths omitted)\n          log(`   - Contains ALL ${fullHistory.length} messages (prompts + responses)`);\n        } catch (error) {\n          log(`‚ö†Ô∏è Could not save complete session history: ${error}`);\n        }\n      }\n\n      // Save response if debug is enabled\n      if (process.env.VISOR_DEBUG_AI_SESSIONS === 'true') {\n        try {\n          const fs = require('fs');\n          const path = require('path');\n          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n\n          const debugArtifactsDir =\n            process.env.VISOR_DEBUG_ARTIFACTS || path.join(process.cwd(), 'debug-artifacts');\n\n          // Create a response file\n          const responseFile = path.join(\n            debugArtifactsDir,\n            `response-${_checkName || 'unknown'}-${timestamp}.txt`\n          );\n\n          let responseContent = `=============================================================\\n`;\n          responseContent += `VISOR AI RESPONSE - NEW SESSION\\n`;\n          responseContent += `=============================================================\\n`;\n          responseContent += `Timestamp: ${timestamp}\\n`;\n          responseContent += `Check Name: ${_checkName || 'unknown'}\\n`;\n          responseContent += `Response Length: ${response.length} characters\\n`;\n          responseContent += `=============================================================\\n\\n`;\n          responseContent += `${'='.repeat(60)}\\n`;\n          responseContent += `AI RESPONSE\\n`;\n          responseContent += `${'='.repeat(60)}\\n`;\n          responseContent += response;\n          responseContent += `\\n${'='.repeat(60)}\\n`;\n          responseContent += `END OF RESPONSE\\n`;\n          responseContent += `${'='.repeat(60)}\\n`;\n\n          fs.writeFileSync(responseFile, responseContent, 'utf-8');\n          log(`üíæ Response saved to: ${responseFile}`);\n        } catch (error) {\n          log(`‚ö†Ô∏è Could not save response file: ${error}`);\n        }\n      }\n\n      // Finalize and save trace if enabled\n      // Properly flush and shutdown telemetry to ensure all spans are exported\n      if (traceFilePath && telemetryConfig) {\n        try {\n          // Cast telemetryConfig to have optional methods\n          const telemetry = telemetryConfig as {\n            flush?: () => Promise<void>;\n            shutdown?: () => Promise<void>;\n          };\n          const tracerWithMethods = tracer as {\n            flush?: () => Promise<void>;\n            shutdown?: () => Promise<void>;\n          };\n\n          // First flush the tracer to export pending spans\n          if (tracerWithMethods && typeof tracerWithMethods.flush === 'function') {\n            await tracerWithMethods.flush();\n            log(`üîÑ Flushed tracer spans`);\n          }\n\n          // Then shutdown the telemetry config to finalize all exporters\n          if (telemetry && typeof telemetry.shutdown === 'function') {\n            await telemetry.shutdown();\n            log(`üìä OpenTelemetry trace saved to: ${traceFilePath}`);\n\n            // In GitHub Actions, also log file size for verification\n            if (process.env.GITHUB_ACTIONS) {\n              const fs = require('fs');\n              if (fs.existsSync(traceFilePath)) {\n                const stats = fs.statSync(traceFilePath);\n                console.log(\n                  `::notice title=AI Trace Saved::OpenTelemetry trace file size: ${stats.size} bytes`\n                );\n              }\n            }\n          } else if (tracerWithMethods && typeof tracerWithMethods.shutdown === 'function') {\n            // Fallback for SimpleTelemetry\n            await tracerWithMethods.shutdown();\n            log(`üìä Trace saved to: ${traceFilePath}`);\n          }\n        } catch (exportError) {\n          logger.warn(`‚ö†Ô∏è  Warning: Failed to export trace: ${exportError}`);\n        }\n      }\n\n      // Register the session for potential reuse by dependent checks\n      if (_checkName) {\n        // ProbeAgent.clone() will handle history filtering when this session is cloned\n        this.registerSession(sessionId, agent);\n        log(`üîß Debug: Registered AI session for potential reuse: ${sessionId}`);\n      }\n\n      return { response, effectiveSchema };\n    } catch (error) {\n      console.error('‚ùå ProbeAgent failed:', error);\n      throw new Error(\n        `ProbeAgent execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    } finally {\n      // Restore original environment variables\n      Object.keys(originalEnv).forEach(key => {\n        if (originalEnv[key] === undefined) {\n          delete process.env[key];\n        } else {\n          process.env[key] = originalEnv[key];\n        }\n      });\n    }\n  }\n\n  /**\n   * Load schema content from schema files or inline definitions\n   */\n  private async loadSchemaContent(schema: string | Record<string, unknown>): Promise<string> {\n    const fs = require('fs').promises;\n    const path = require('path');\n\n    // Check if schema is already an object (inline definition from YAML)\n    if (typeof schema === 'object' && schema !== null) {\n      // It's already a schema object, convert to JSON string\n      log('üìã Using inline schema object from configuration');\n      return JSON.stringify(schema);\n    }\n\n    // Check if schema string is already a JSON schema (inline JSON string)\n    // This happens when a schema is passed directly as JSON instead of a reference\n    try {\n      const parsed = JSON.parse(schema);\n      if (typeof parsed === 'object' && parsed !== null) {\n        // It's already a valid JSON schema, return it as-is\n        log('üìã Using inline schema JSON string');\n        return schema;\n      }\n    } catch {\n      // Not JSON, treat as schema name reference or file path\n    }\n\n    // Check if it's a file path (starts with ./ or contains .json but not absolute paths)\n    if ((schema.startsWith('./') || schema.includes('.json')) && !path.isAbsolute(schema)) {\n      // It's a relative file path to a custom schema\n      // Validate the path to prevent traversal attacks\n      if (schema.includes('..') || schema.includes('\\x00')) {\n        throw new Error('Invalid schema path: path traversal not allowed');\n      }\n\n      try {\n        const schemaPath = path.resolve(process.cwd(), schema);\n        log(`üìã Loading custom schema from file: ${schemaPath}`);\n        const schemaContent = await fs.readFile(schemaPath, 'utf-8');\n        return schemaContent.trim();\n      } catch (error) {\n        throw new Error(\n          `Failed to load custom schema from ${schema}: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n      }\n    }\n\n    // Otherwise, treat as a built-in schema name\n    // Sanitize schema name to prevent path traversal attacks\n    const sanitizedSchemaName = schema.replace(/[^a-zA-Z0-9-]/g, '');\n    if (!sanitizedSchemaName || sanitizedSchemaName !== schema) {\n      throw new Error('Invalid schema name');\n    }\n\n    // Built-in schemas are bundled under dist/output when running as a GitHub Action.\n    // In local dev (ts-node/jest), schemas may live under project/output.\n    // Try dist-relative first, then fall back to CWD.\n    const candidatePaths = [\n      // GitHub Action bundle location\n      path.join(__dirname, 'output', sanitizedSchemaName, 'schema.json'),\n      // Historical fallback when src/output was inadvertently bundled as output1/\n      path.join(__dirname, 'output1', sanitizedSchemaName, 'schema.json'),\n      // Local dev (repo root)\n      path.join(process.cwd(), 'output', sanitizedSchemaName, 'schema.json'),\n    ];\n\n    for (const schemaPath of candidatePaths) {\n      try {\n        const schemaContent = await fs.readFile(schemaPath, 'utf-8');\n        return schemaContent.trim();\n      } catch {\n        // try next\n      }\n    }\n\n    // If neither path works, surface a helpful error\n    const distPath = path.join(__dirname, 'output', sanitizedSchemaName, 'schema.json');\n    const distAltPath = path.join(__dirname, 'output1', sanitizedSchemaName, 'schema.json');\n    const cwdPath = path.join(process.cwd(), 'output', sanitizedSchemaName, 'schema.json');\n    throw new Error(\n      `Failed to load schema '${sanitizedSchemaName}'. Tried: ${distPath}, ${distAltPath}, and ${cwdPath}. ` +\n        `Ensure build copies 'output/' into dist (build:cli), or provide a custom schema file/path.`\n    );\n  }\n\n  /**\n   * Parse AI response JSON\n   */\n  private parseAIResponse(\n    response: string,\n    debugInfo?: AIDebugInfo,\n    _schema?: string\n  ): ReviewSummary {\n    log('üîç Parsing AI response...');\n    log(`üìä Raw response length: ${response.length} characters`);\n\n    // Log first and last 200 chars for debugging\n    if (response.length > 400) {\n      log('üìã Response preview (first 200 chars):', response.substring(0, 200));\n      log('üìã Response preview (last 200 chars):', response.substring(response.length - 200));\n    } else {\n      log('üìã Full response preview:', response);\n    }\n\n    // Note: Removed overly aggressive Liquid template check that was causing false positives\n    // JSON parsing below will catch actual malformed responses\n\n    try {\n      // Handle different schema types differently\n      let reviewData: AIResponseFormat;\n\n      // Handle plain schema or no schema - no JSON parsing, return response as-is\n      if (_schema === 'plain' || !_schema) {\n        log(\n          `üìã ${_schema === 'plain' ? 'Plain' : 'No'} schema detected - returning raw response without JSON parsing`\n        );\n\n        // For plain schema, return the raw response as an issue\n\n        return {\n          issues: [\n            {\n              file: 'AI_RESPONSE',\n              line: 1,\n              ruleId: 'ai/raw_response',\n              message: response,\n              severity: 'info',\n              category: 'documentation',\n            },\n          ],\n          debug: debugInfo,\n        };\n      }\n\n      {\n        // For other schemas (code-review, etc.), extract and parse JSON with boundary detection\n        log('üîç Extracting JSON from AI response...');\n\n        // Try direct parsing first - if AI returned pure JSON\n        try {\n          reviewData = JSON.parse(response.trim());\n          log('‚úÖ Successfully parsed direct JSON response');\n          if (debugInfo) debugInfo.jsonParseSuccess = true;\n        } catch {\n          log('üîç Direct parsing failed, trying to extract JSON from response...');\n\n          // If the response starts with \"I cannot\" or similar, it's likely a refusal\n          if (\n            response.toLowerCase().includes('i cannot') ||\n            response.toLowerCase().includes('unable to')\n          ) {\n            console.error('üö´ AI refused to analyze - returning empty result');\n            return {\n              issues: [],\n            };\n          }\n\n          // Try to extract JSON using improved method with proper bracket matching\n          const jsonString = this.extractJsonFromResponse(response);\n\n          if (jsonString) {\n            try {\n              reviewData = JSON.parse(jsonString);\n              log('‚úÖ Successfully parsed extracted JSON');\n              if (debugInfo) debugInfo.jsonParseSuccess = true;\n            } catch {\n              log('üîß Extracted JSON parsing failed, falling back to plain text handling...');\n\n              // Check if response is plain text and doesn't contain structured data\n              if (!response.includes('{') && !response.includes('}')) {\n                log('üîß Plain text response detected, creating structured fallback...');\n\n                reviewData = {\n                  issues: [\n                    {\n                      file: 'AI_RESPONSE',\n                      line: 1,\n                      ruleId: 'ai/raw_response',\n                      message: response,\n                      severity: 'info',\n                      category: 'documentation',\n                    },\n                  ],\n                };\n              } else {\n                // Fallback: treat the entire response as an issue\n                log('üîß Creating fallback response from non-JSON content...');\n                reviewData = {\n                  issues: [\n                    {\n                      file: 'AI_RESPONSE',\n                      line: 1,\n                      ruleId: 'ai/raw_response',\n                      message: response,\n                      severity: 'info',\n                      category: 'documentation',\n                    },\n                  ],\n                };\n              }\n            }\n          } else {\n            // No JSON found at all - treat as plain text response\n            log('üîß No JSON found in response, treating as plain text...');\n            reviewData = {\n              issues: [\n                {\n                  file: 'AI_RESPONSE',\n                  line: 1,\n                  ruleId: 'ai/raw_response',\n                  message: response,\n                  severity: 'info',\n                  category: 'documentation',\n                },\n              ],\n            };\n          }\n        }\n      }\n\n      // Decide how to interpret the parsed JSON based on the effective schema and the shape of data\n      // Built-ins:\n      //  - 'code-review' ‚Üí expects { issues: [...] }\n      //  - 'overview' / assistants ‚Üí expects { text: string, ... }\n      //  - 'plain' ‚Üí handled earlier\n      //  - custom (object/file path) ‚Üí free-form object, ensure output.text fallback\n      const looksLikeTextOutput =\n        reviewData &&\n        typeof reviewData === 'object' &&\n        typeof (reviewData as any).text === 'string' &&\n        String((reviewData as any).text).trim().length > 0;\n\n      // Treat as custom/text-style when:\n      //  - explicit custom schema\n      //  - schema is any non code-review built-in like 'overview', 'issue-assistant', 'comment-assistant'\n      //  - or schema is unknown/undefined but the payload clearly contains a text field\n      const isCustomSchema =\n        _schema === 'custom' ||\n        (_schema && (_schema.startsWith('./') || _schema.endsWith('.json'))) ||\n        (_schema && _schema !== 'code-review' && !_schema.includes('output/')) ||\n        (!_schema && looksLikeTextOutput);\n\n      const _debugSchemaLogging =\n        this.config.debug === true || process.env.VISOR_DEBUG_AI_SESSIONS === 'true';\n      if (_debugSchemaLogging) {\n        const details = {\n          schema: _schema,\n          isCustomSchema,\n          isCustomLiteral: _schema === 'custom',\n          startsWithDotSlash: typeof _schema === 'string' ? _schema.startsWith('./') : false,\n          endsWithJson: typeof _schema === 'string' ? _schema.endsWith('.json') : false,\n          notCodeReview: _schema !== 'code-review',\n          noOutputPrefix: typeof _schema === 'string' ? !_schema.includes('output/') : false,\n        };\n        try {\n          log(`üîç Schema detection: ${JSON.stringify(details)}`);\n        } catch {\n          // Fallback if JSON.stringify throws on unexpected values\n          log(\n            `üîç Schema detection: _schema=\"${String(_schema)}\", isCustomSchema=${isCustomSchema}`\n          );\n        }\n      }\n\n      if (isCustomSchema) {\n        // For custom schemas, preserve ALL fields from the parsed JSON and make sure\n        // we always have something renderable in templates (e.g., output.text).\n        log('üìã Custom schema detected - preserving all fields from parsed JSON');\n        log(`üìä Schema: ${_schema}`);\n        try {\n          log(`üìä Custom schema keys: ${Object.keys(reviewData).join(', ')}`);\n        } catch {}\n\n        // Ensure \"output\" is an object and has a sensible text fallback for templates\n        const out: Record<string, unknown> =\n          reviewData && typeof reviewData === 'object' ? (reviewData as any) : ({} as any);\n\n        const hasText =\n          typeof (out as any).text === 'string' && String((out as any).text).trim().length > 0;\n        if (!hasText) {\n          // Build a fallback string from the raw response or issue messages if available\n          let fallbackText = '';\n          try {\n            if (\n              Array.isArray((reviewData as any)?.issues) &&\n              (reviewData as any).issues.length > 0\n            ) {\n              // Join issue messages into a readable block\n              fallbackText = (reviewData as any).issues\n                .map((i: any) => (i && (i.message || i.text || i.response)) as string)\n                .filter((s: any) => typeof s === 'string' && s.trim().length > 0)\n                .join('\\n');\n            }\n          } catch {}\n          if (!fallbackText && typeof response === 'string' && response.trim()) {\n            // Use raw provider response (trim and bound length for safety)\n            fallbackText = response.trim().slice(0, 60000);\n          }\n          if (fallbackText) {\n            (out as any).text = fallbackText;\n          }\n        }\n\n        const result: ReviewSummary & { output?: unknown } = {\n          // Keep issues empty for custom-schema rendering; consumers read from output.*\n          issues: [],\n          output: out,\n        };\n\n        log(\n          '‚úÖ Successfully created ReviewSummary with custom schema output (with fallback text when needed)'\n        );\n        return result;\n      }\n\n      // Standard code-review schema processing (only when schema is explicitly code-review\n      // or when the payload clearly has an issues array)\n      log('üîç Validating parsed review data...');\n      log(`üìä Overall score: ${0}`);\n      log(`üìã Total issues: ${reviewData.issues?.length || 0}`);\n      log(\n        `üö® Critical issues: ${reviewData.issues?.filter((i: { severity?: string }) => i.severity === 'critical').length || 0}`\n      );\n      log(`üí¨ Comments count: ${Array.isArray(reviewData.issues) ? reviewData.issues.length : 0}`);\n\n      // Process issues from the simplified format; if we don't have issues and the\n      // data looks like a text-style output, route through the custom path above.\n      const processedIssues = Array.isArray((reviewData as any).issues)\n        ? (reviewData as any).issues.map((issue: any, index: number) => {\n            log(`üîç Processing issue ${index + 1}:`, issue);\n            return {\n              file: issue.file || 'unknown',\n              line: issue.line || 1,\n              endLine: issue.endLine,\n              ruleId: issue.ruleId || `${issue.category || 'general'}/unknown`,\n              message: issue.message || '',\n              severity: issue.severity,\n              category: issue.category,\n              suggestion: issue.suggestion,\n              replacement: issue.replacement,\n            } as ReviewIssue;\n          })\n        : [];\n\n      // Validate and convert to ReviewSummary format\n      const result: ReviewSummary = {\n        issues: processedIssues,\n      };\n\n      // Log issue counts\n      const criticalCount = (result.issues || []).filter(i => i.severity === 'critical').length;\n      if (criticalCount > 0) {\n        log(`üö® Found ${criticalCount} critical severity issue(s)`);\n      }\n      log(`üìà Total issues: ${(result.issues || []).length}`);\n\n      log('‚úÖ Successfully created ReviewSummary');\n      return result;\n    } catch (error) {\n      const detailed = this.config.debug === true || process.env.VISOR_DEBUG_AI_SESSIONS === 'true';\n      const message = error instanceof Error ? error.message : String(error);\n\n      if (detailed) {\n        logger.debug(`‚ùå Failed to parse AI response: ${message}`);\n        logger.debug('üìÑ FULL RAW RESPONSE:');\n        logger.debug('='.repeat(80));\n        logger.debug(response);\n        logger.debug('='.repeat(80));\n        logger.debug(`üìè Response length: ${response.length} characters`);\n\n        if (error instanceof SyntaxError) {\n          logger.debug('üîç JSON parsing error - the response may not be valid JSON');\n          logger.debug(`üîç Error details: ${error.message}`);\n\n          const errorMatch = error.message.match(/position (\\d+)/);\n          if (errorMatch) {\n            const position = parseInt(errorMatch[1]);\n            logger.debug(`üîç Error at position ${position}:`);\n            const start = Math.max(0, position - 50);\n            const end = Math.min(response.length, position + 50);\n            logger.debug(`üîç Context: \"${response.substring(start, end)}\"`);\n            logger.debug(`üîç Response beginning: \"${response.substring(0, 100)}\"`);\n          }\n\n          if (response.includes('I cannot')) {\n            logger.debug('üîç Response appears to be a refusal/explanation rather than JSON');\n          }\n          if (response.includes('```')) {\n            logger.debug('üîç Response appears to contain markdown code blocks');\n          }\n          if (response.startsWith('<')) {\n            logger.debug('üîç Response appears to start with XML/HTML');\n          }\n        }\n      } else {\n        logger.error(`‚ùå Failed to parse AI response: ${message}`);\n      }\n\n      throw new Error(\n        `Invalid AI response format: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Extract JSON from a response that might contain surrounding text\n   * Uses proper bracket matching to find valid JSON objects or arrays\n   */\n  private extractJsonFromResponse(response: string): string | null {\n    const text = response.trim();\n\n    // Try to find JSON objects first (higher priority)\n    let bestJson = this.findJsonWithBracketMatching(text, '{', '}');\n\n    // If no object found, try arrays\n    if (!bestJson) {\n      bestJson = this.findJsonWithBracketMatching(text, '[', ']');\n    }\n\n    return bestJson;\n  }\n\n  /**\n   * Find JSON with proper bracket matching to avoid false positives\n   */\n  private findJsonWithBracketMatching(\n    text: string,\n    openChar: string,\n    closeChar: string\n  ): string | null {\n    const firstIndex = text.indexOf(openChar);\n    if (firstIndex === -1) return null;\n\n    let depth = 0;\n    let inString = false;\n    let escaping = false;\n\n    for (let i = firstIndex; i < text.length; i++) {\n      const char = text[i];\n\n      if (escaping) {\n        escaping = false;\n        continue;\n      }\n\n      if (char === '\\\\' && inString) {\n        escaping = true;\n        continue;\n      }\n\n      if (char === '\"' && !escaping) {\n        inString = !inString;\n        continue;\n      }\n\n      if (!inString) {\n        if (char === openChar) {\n          depth++;\n        } else if (char === closeChar) {\n          depth--;\n          if (depth === 0) {\n            // Found matching closing bracket\n            const candidate = text.substring(firstIndex, i + 1);\n            try {\n              JSON.parse(candidate); // Validate it's actually valid JSON\n              return candidate;\n            } catch {\n              // This wasn't valid JSON, keep looking\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Generate mock response for testing\n   */\n  private async generateMockResponse(\n    _prompt: string,\n    _checkName?: string,\n    _schema?: string | Record<string, unknown>\n  ): Promise<string> {\n    // Simulate some processing time\n    await new Promise(resolve => setTimeout(resolve, 500));\n\n    // Schema-accurate mocks for default flows\n    const name = (_checkName || '').toLowerCase();\n    if (name.includes('extract-facts')) {\n      const arr = Array.from({ length: 6 }, (_, i) => ({\n        id: `fact-${i + 1}`,\n        category: 'Feature',\n        claim: `claim-${i + 1}`,\n        verifiable: true,\n        refs: [{ path: 'src/check-execution-engine.ts', lines: '6400-6460' }],\n      }));\n      return JSON.stringify(arr);\n    }\n    if (name.includes('validate-fact')) {\n      const idMatch = _prompt.match(/Fact ID:\\s*([\\w\\-]+)/i);\n      const claimMatch = _prompt.match(/\\*\\*Claim:\\*\\*\\s*(.+)/i);\n      const attemptMatch = _prompt.match(/Attempt:\\s*(\\d+)/i);\n      const factId = idMatch ? idMatch[1] : 'fact-1';\n      const claim = claimMatch ? claimMatch[1].trim() : 'unknown-claim';\n      const n = Number(factId.split('-')[1] || '0');\n      const attempt = attemptMatch ? Number(attemptMatch[1]) : 0;\n      const isValid = attempt >= 1 ? true : !(n >= 1 && n <= 3);\n      return JSON.stringify({\n        fact_id: factId,\n        claim,\n        is_valid: isValid,\n        confidence: 'high',\n        evidence: isValid ? 'verified' : 'not found',\n        correction: isValid ? null : `correct ${claim}`,\n      });\n    }\n    if (name.includes('issue-assistant') || name.includes('comment-assistant')) {\n      const text = '### Assistant Reply';\n      const intent = name.includes('issue') ? 'issue_triage' : 'comment_reply';\n      return JSON.stringify({ text, intent });\n    }\n    // Fallback\n    const mockResponse = { content: JSON.stringify({ issues: [], summary: { totalIssues: 0 } }) };\n    return JSON.stringify(mockResponse);\n  }\n\n  /**\n   * Get the API key source for debugging (without revealing the key)\n   */\n  private getApiKeySource(): string {\n    if (process.env.CLAUDE_CODE_API_KEY && this.config.provider === 'claude-code') {\n      return 'CLAUDE_CODE_API_KEY';\n    }\n    if (process.env.GOOGLE_API_KEY && this.config.provider === 'google') {\n      return 'GOOGLE_API_KEY';\n    }\n    if (process.env.ANTHROPIC_API_KEY && this.config.provider === 'anthropic') {\n      return 'ANTHROPIC_API_KEY';\n    }\n    if (process.env.OPENAI_API_KEY && this.config.provider === 'openai') {\n      return 'OPENAI_API_KEY';\n    }\n    if (this.config.provider === 'bedrock') {\n      if (process.env.AWS_BEDROCK_API_KEY) {\n        return 'AWS_BEDROCK_API_KEY';\n      }\n      if (process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY) {\n        return 'AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY';\n      }\n    }\n    return 'unknown';\n  }\n}\n","import { Octokit } from '@octokit/rest';\nimport { PRInfo } from './pr-analyzer';\nimport { CommentManager } from './github-comments';\nimport { AIReviewService, AIDebugInfo } from './ai-review-service';\n\nexport interface ReviewIssue {\n  // Location\n  file: string;\n  line: number;\n  endLine?: number;\n  // Issue details\n  ruleId: string;\n  message: string;\n  severity: 'info' | 'warning' | 'error' | 'critical';\n  category: 'security' | 'performance' | 'style' | 'logic' | 'documentation';\n  // Check identification - which check created this issue\n  checkName?: string;\n  // Group and schema for comment separation\n  group?: string;\n  schema?: string;\n  // Timestamp when the issue was created (for ordering)\n  timestamp?: number;\n  // Optional enhancement\n  suggestion?: string;\n  replacement?: string;\n}\n\n// Legacy interface - ONLY for GitHub integration compatibility\nexport interface ReviewComment {\n  file: string;\n  line: number;\n  message: string;\n  severity: 'info' | 'warning' | 'error' | 'critical';\n  category: 'security' | 'performance' | 'style' | 'logic' | 'documentation';\n  suggestion?: string;\n  replacement?: string;\n  ruleId?: string;\n}\n\n// Individual check result - each check produces one of these\nexport interface CheckResult {\n  checkName: string;\n  content: string; // Rendered output for this specific check\n  group: string; // Which group this check belongs to\n  // Optional structured output for custom schemas (e.g., overview, issue-assistant)\n  output?: unknown;\n  debug?: AIDebugInfo;\n  issues?: ReviewIssue[]; // Structured issues alongside rendered content\n}\n\n// Results grouped by group name\nexport interface GroupedCheckResults {\n  [groupName: string]: CheckResult[];\n}\n\n// Legacy interface - only for backward compatibility\nexport interface ReviewSummary {\n  issues?: ReviewIssue[];\n  debug?: AIDebugInfo;\n  /** Session ID created for this check (for cleanup tracking) */\n  sessionId?: string;\n}\n\n// Test utility function - Convert old ReviewSummary to new GroupedCheckResults format\n// This is for backward compatibility with tests only\nexport function convertReviewSummaryToGroupedResults(\n  reviewSummary: ReviewSummary,\n  checkName: string = 'test-check',\n  groupName: string = 'default'\n): GroupedCheckResults {\n  // Create a simple content string from issues\n  let content = '';\n\n  if (reviewSummary.issues && reviewSummary.issues.length > 0) {\n    content += `## Issues Found (${reviewSummary.issues.length})\\n\\n`;\n    reviewSummary.issues.forEach(issue => {\n      content += `- **${issue.severity.toUpperCase()}**: ${issue.message} (${issue.file}:${issue.line})\\n`;\n    });\n    content += '\\n';\n  }\n\n  if (!content) {\n    content = 'No issues found.';\n  }\n\n  const checkResult: CheckResult = {\n    checkName,\n    content: content.trim(),\n    group: groupName,\n    debug: reviewSummary.debug,\n    issues: reviewSummary.issues, // Include structured issues\n  };\n\n  const groupedResults: GroupedCheckResults = {};\n  groupedResults[groupName] = [checkResult];\n\n  return groupedResults;\n}\n\n// Helper functions for GitHub checks - ONLY for structured schemas that have issues\n// These are the ONLY acceptable hardcoded schema dependencies, and only for GitHub integration\nexport function calculateTotalIssues(issues?: ReviewIssue[]): number {\n  return (issues || []).length;\n}\n\nexport function calculateCriticalIssues(issues?: ReviewIssue[]): number {\n  return (issues || []).filter(i => i.severity === 'critical').length;\n}\n\n// Legacy converter - ONLY for GitHub integration compatibility\nexport function convertIssuesToComments(issues: ReviewIssue[]): ReviewComment[] {\n  return issues.map(issue => ({\n    file: issue.file,\n    line: issue.line,\n    message: issue.message,\n    severity: issue.severity,\n    category: issue.category,\n    suggestion: issue.suggestion,\n    replacement: issue.replacement,\n    ruleId: issue.ruleId,\n  }));\n}\n\nexport interface ReviewOptions {\n  focus?: string;\n  format?: 'table' | 'json' | 'markdown' | 'sarif';\n  debug?: boolean;\n  config?: import('./types/config').VisorConfig;\n  checks?: string[];\n  parallelExecution?: boolean;\n  // Optional tag filter to include/exclude checks by tags when running via GitHub Action path\n  tagFilter?: import('./types/config').TagFilter;\n}\n\nexport class PRReviewer {\n  private commentManager: CommentManager;\n  private aiReviewService: AIReviewService;\n\n  constructor(private octokit: Octokit) {\n    this.commentManager = new CommentManager(octokit);\n    this.aiReviewService = new AIReviewService();\n  }\n\n  async reviewPR(\n    owner: string,\n    repo: string,\n    prNumber: number,\n    prInfo: PRInfo,\n    options: ReviewOptions = {}\n  ): Promise<GroupedCheckResults> {\n    const { debug = false, config, checks } = options;\n\n    if (config && checks && checks.length > 0) {\n      const { CheckExecutionEngine } = await import('./check-execution-engine');\n      const engine = new CheckExecutionEngine();\n      const { results } = await engine.executeGroupedChecks(\n        prInfo,\n        checks,\n        undefined,\n        config,\n        undefined,\n        debug,\n        undefined,\n        undefined,\n        options.tagFilter\n      );\n      return results;\n    }\n\n    throw new Error(\n      'No configuration provided. Please create a .visor.yaml file with check definitions. ' +\n        'Built-in prompts have been removed - all checks must be explicitly configured.'\n    );\n  }\n\n  /**\n   * Helper to check if a schema is comment-generating\n   * Comment-generating schemas include:\n   * - Built-in schemas: code-review, overview, plain, text\n   * - Custom schemas with a \"text\" field in properties\n   */\n  private async isCommentGeneratingSchema(\n    schema: string | Record<string, unknown>\n  ): Promise<boolean> {\n    try {\n      // Check for built-in comment-generating schemas\n      if (typeof schema === 'string') {\n        // Well-known comment-generating schemas\n        if (['code-review', 'overview', 'plain', 'text'].includes(schema)) {\n          return true;\n        }\n\n        // Try to load and check custom string schema\n        const fs = require('fs').promises;\n        const path = require('path');\n\n        // Sanitize schema name\n        const sanitizedSchemaName = schema.replace(/[^a-zA-Z0-9-]/g, '');\n        if (!sanitizedSchemaName || sanitizedSchemaName !== schema) {\n          return false;\n        }\n\n        // Locate built-in schema JSON. In Actions, schemas live under dist/output (relative to __dirname).\n        // In local dev/tests, schemas live under project/output (relative to CWD).\n        const candidatePaths = [\n          path.join(__dirname, 'output', sanitizedSchemaName, 'schema.json'),\n          path.join(process.cwd(), 'output', sanitizedSchemaName, 'schema.json'),\n        ];\n\n        for (const schemaPath of candidatePaths) {\n          try {\n            const schemaContent = await fs.readFile(schemaPath, 'utf-8');\n            const schemaObj = JSON.parse(schemaContent);\n\n            // Check if schema has a \"text\" field in properties\n            const properties = schemaObj.properties as Record<string, unknown> | undefined;\n            return !!(properties && 'text' in properties);\n          } catch {\n            // try next location\n          }\n        }\n        // Schema file not found in any known location, not comment-generating\n        return false;\n      } else {\n        // Inline schema object - check if it has a \"text\" field in properties\n        const properties = schema.properties as Record<string, unknown> | undefined;\n        return !!(properties && 'text' in properties);\n      }\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Filter check results to only include those that should post GitHub comments\n   */\n  private async filterCommentGeneratingChecks(\n    checkResults: CheckResult[],\n    config: import('./types/config').VisorConfig\n  ): Promise<CheckResult[]> {\n    const filtered: CheckResult[] = [];\n\n    for (const r of checkResults) {\n      const cfg = config.checks?.[r.checkName];\n      const type = cfg?.type || 'ai'; // Default to 'ai' if not specified\n      const schema = cfg?.schema;\n\n      // Determine if this check should generate a comment\n      // Include checks with:\n      // 1. type: 'ai' or 'claude-code' with no schema or comment-generating schemas\n      // 2. Other types ONLY if they have explicit comment-generating schemas\n      let shouldPostComment = false;\n\n      // AI-powered checks generate comments by default\n      const isAICheck = type === 'ai' || type === 'claude-code';\n\n      if (!schema || schema === '') {\n        // No schema specified - only AI checks generate comments by default\n        // Other types (github, command, http, etc.) without schema are for orchestration\n        shouldPostComment = isAICheck;\n      } else {\n        // Check if the schema is comment-generating (built-in or custom with text field)\n        shouldPostComment = await this.isCommentGeneratingSchema(schema);\n      }\n\n      if (shouldPostComment) {\n        filtered.push(r);\n      }\n    }\n\n    return filtered;\n  }\n\n  async postReviewComment(\n    owner: string,\n    repo: string,\n    prNumber: number,\n    groupedResults: GroupedCheckResults,\n    options: ReviewOptions & {\n      commentId?: string;\n      triggeredBy?: string;\n      commitSha?: string;\n      octokitOverride?: Octokit;\n    } = {}\n  ): Promise<void> {\n    // Post separate comments for each group\n    for (const [groupName, checkResults] of Object.entries(groupedResults)) {\n      // Only checks with comment-generating schemas should post PR comments\n      // AI checks (ai, claude-code) generate comments by default\n      // Other types need explicit comment-generating schemas\n      let filteredResults = options.config\n        ? await this.filterCommentGeneratingChecks(checkResults, options.config)\n        : checkResults;\n\n      // Collapse results to avoid concatenating mutually-exclusive or duplicate posts.\n      // For fact-validation flow, both 'post-verified-response' and 'post-unverified-warning'\n      // can appear across waves. Prefer the final intended output and drop earlier entries.\n      if (groupName === 'github-output' && filteredResults && filteredResults.length > 1) {\n        // Keep only the last occurrence per checkName.\n        const byName = new Map<string, any>();\n        for (const cr of filteredResults) byName.set(cr.checkName, cr);\n        let collapsed = Array.from(byName.values());\n        const hasVerified = collapsed.some((r: any) => r.checkName === 'post-verified-response');\n        if (hasVerified) {\n          collapsed = collapsed.filter((r: any) => r.checkName !== 'post-unverified-warning');\n        }\n        filteredResults = collapsed as any;\n      }\n\n      // If nothing to report after filtering, skip this group\n      if (!filteredResults || filteredResults.length === 0) {\n        continue;\n      }\n\n      const comment = await this.formatGroupComment(filteredResults, options, {\n        owner,\n        repo,\n        prNumber,\n        commitSha: options.commitSha,\n      });\n\n      // Generate comment ID - use unique ID for \"dynamic\" group\n      let commentId: string;\n      if (groupName === 'dynamic') {\n        // Dynamic group creates a new comment each time with timestamp-based ID\n        const timestamp = Date.now();\n        commentId = `visor-dynamic-${timestamp}`;\n      } else {\n        // Regular groups use static IDs that get updated\n        commentId = options.commentId\n          ? `${options.commentId}-${groupName}`\n          : `visor-review-${groupName}`;\n      }\n\n      // Do not post empty comments (possible if content is blank after fallbacks)\n      if (!comment || !comment.trim()) continue;\n\n      const manager = options.octokitOverride\n        ? new CommentManager(options.octokitOverride)\n        : this.commentManager;\n      await manager.updateOrCreateComment(owner, repo, prNumber, comment, {\n        commentId,\n        triggeredBy: options.triggeredBy || 'unknown',\n        allowConcurrentUpdates: false,\n        commitSha: options.commitSha,\n      });\n    }\n  }\n\n  private async formatGroupComment(\n    checkResults: CheckResult[],\n    _options: ReviewOptions,\n    _githubContext?: { owner: string; repo: string; prNumber: number; commitSha?: string }\n  ): Promise<string> {\n    // Concatenate all check outputs in this group; fall back to structured output fields\n    const normalize = (s: string) => s.replace(/\\\\n/g, '\\n');\n    const checkContents = checkResults\n      .map(result => {\n        const trimmed = result.content?.trim();\n        if (trimmed) return normalize(trimmed);\n        // Fallback: if provider returned structured output with a common text field\n        const out = (result as unknown as { debug?: unknown; issues?: unknown; output?: any })\n          .output;\n        if (out) {\n          if (typeof out === 'string' && out.trim()) return normalize(out.trim());\n          if (typeof out === 'object') {\n            const txt = (out.text || out.response || out.message) as unknown;\n            if (typeof txt === 'string' && txt.trim()) return normalize(txt.trim());\n          }\n        }\n        return '';\n      })\n      .filter(content => content && content.trim());\n\n    // Add debug info if any check has it\n    const debugInfo = checkResults.find(result => result.debug)?.debug;\n\n    // Only generate comment if there's actual content or debug info\n    if (checkContents.length === 0 && !debugInfo) {\n      return '';\n    }\n\n    let comment = '';\n    comment += `## üîç Code Analysis Results\\n\\n`;\n    comment += checkContents.join('\\n\\n');\n\n    if (debugInfo) {\n      comment += '\\n\\n' + this.formatDebugSection(debugInfo);\n      comment += '\\n\\n';\n    }\n\n    // Footer will be added by formatCommentWithMetadata in github-comments.ts\n    return comment;\n  }\n\n  private formatDebugSection(debug: AIDebugInfo): string {\n    const formattedContent = [\n      `**Provider:** ${debug.provider}`,\n      `**Model:** ${debug.model}`,\n      `**API Key Source:** ${debug.apiKeySource}`,\n      `**Processing Time:** ${debug.processingTime}ms`,\n      `**Timestamp:** ${debug.timestamp}`,\n      `**Prompt Length:** ${debug.promptLength} characters`,\n      `**Response Length:** ${debug.responseLength} characters`,\n      `**JSON Parse Success:** ${debug.jsonParseSuccess ? '‚úÖ' : '‚ùå'}`,\n    ];\n\n    if (debug.errors && debug.errors.length > 0) {\n      formattedContent.push('', '### Errors');\n      debug.errors.forEach(error => {\n        formattedContent.push(`- ${error}`);\n      });\n    }\n\n    const fullDebugContent = [\n      ...formattedContent,\n      '',\n      '### AI Prompt',\n      '```',\n      debug.prompt,\n      '```',\n      '',\n      '### Raw AI Response',\n      '```json',\n      debug.rawResponse,\n      '```',\n    ].join('\\n');\n\n    if (fullDebugContent.length > 60000) {\n      const artifactPath = this.saveDebugArtifact(debug);\n      formattedContent.push('');\n      formattedContent.push('### Debug Details');\n      formattedContent.push('‚ö†Ô∏è Debug information is too large for GitHub comments.');\n      if (artifactPath) {\n        formattedContent.push(\n          `üìÅ **Full debug information saved to artifact:** \\`${artifactPath}\\``\n        );\n        formattedContent.push('');\n        const runId = process.env.GITHUB_RUN_ID;\n        const repoUrl =\n          process.env.GITHUB_SERVER_URL && process.env.GITHUB_REPOSITORY\n            ? `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}`\n            : null;\n        if (runId && repoUrl) {\n          formattedContent.push(\n            `üîó **Download Link:** [visor-debug-${process.env.GITHUB_RUN_NUMBER || runId}](${repoUrl}/actions/runs/${runId})`\n          );\n        }\n        formattedContent.push(\n          'üí° Go to the GitHub Action run above and download the debug artifact to view complete prompts and responses.'\n        );\n      } else {\n        formattedContent.push('üìù **Prompt preview:** ' + debug.prompt.substring(0, 500) + '...');\n        formattedContent.push(\n          'üìù **Response preview:** ' + debug.rawResponse.substring(0, 500) + '...'\n        );\n      }\n    } else {\n      formattedContent.push('');\n      formattedContent.push('### AI Prompt');\n      formattedContent.push('```');\n      formattedContent.push(debug.prompt);\n      formattedContent.push('```');\n      formattedContent.push('');\n      formattedContent.push('### Raw AI Response');\n      formattedContent.push('```json');\n      formattedContent.push(debug.rawResponse);\n      formattedContent.push('```');\n    }\n\n    return this.commentManager.createCollapsibleSection(\n      'üêõ Debug Information',\n      formattedContent.join('\\n'),\n      false\n    );\n  }\n\n  private saveDebugArtifact(debug: AIDebugInfo): string | null {\n    try {\n      const fs = require('fs');\n      const path = require('path');\n      const debugDir = path.join(process.cwd(), 'debug-artifacts');\n      if (!fs.existsSync(debugDir)) {\n        fs.mkdirSync(debugDir, { recursive: true });\n      }\n\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n      const filename = `visor-debug-${timestamp}.md`;\n      const filepath = path.join(debugDir, filename);\n\n      const content = [\n        `# Visor Debug Information`,\n        ``,\n        `**Timestamp:** ${debug.timestamp}`,\n        `**Provider:** ${debug.provider}`,\n        `**Model:** ${debug.model}`,\n        `**Processing Time:** ${debug.processingTime}ms`,\n        ``,\n        `## AI Prompt`,\n        ``,\n        '```',\n        debug.prompt,\n        '```',\n        ``,\n        `## Raw AI Response`,\n        ``,\n        '```json',\n        debug.rawResponse,\n        '```',\n      ].join('\\n');\n\n      fs.writeFileSync(filepath, content, 'utf8');\n      return filename;\n    } catch (error) {\n      console.error('Failed to save debug artifact:', error);\n      return null;\n    }\n  }\n}\n","import ignore from 'ignore';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n/**\n * Default exclusion patterns for common build artifacts and dependencies.\n * These can be overridden by providing custom patterns to the constructor.\n */\nconst DEFAULT_EXCLUSION_PATTERNS = [\n  'dist/',\n  'build/',\n  '.next/',\n  'out/',\n  'node_modules/',\n  'coverage/',\n  '.turbo/',\n  'bundled/',\n];\n\n/**\n * Shared utility for filtering files based on .gitignore patterns\n *\n * Design Decision: Synchronous I/O in Constructor\n * ------------------------------------------------\n * This class intentionally uses synchronous file I/O in the constructor for the following reasons:\n *\n * 1. **Initialization Context**: The constructor is called once during application startup,\n *    not in request handling or performance-critical paths.\n *\n * 2. **Small File Sizes**: .gitignore files are typically <10KB. Even in large monorepos,\n *    they rarely exceed 100KB. Reading such small files synchronously has negligible impact.\n *\n * 3. **Immediate Availability**: The exclusion patterns must be ready immediately for use.\n *    Asynchronous initialization would require either:\n *    - Async factory method (adds API complexity)\n *    - Lazy loading (race conditions, repeated checks)\n *    - Promise-based initialization (complicates usage across codebase)\n *\n * 4. **Simplicity**: Synchronous loading keeps the API simple and prevents async contagion\n *    throughout the codebase. Methods like shouldExcludeFile() remain synchronous.\n *\n * 5. **No DoS Risk**: The file reading happens exactly once per instance during construction.\n *    Attackers cannot trigger repeated synchronous reads.\n *\n * 6. **Consistency**: This follows the same pattern as other configuration loaders in Node.js\n *    ecosystem (e.g., require(), cosmiconfig's sync mode).\n *\n * Alternative Considered: Async factory pattern would add complexity without meaningful benefit\n * given the usage patterns and file sizes involved.\n */\nexport class FileExclusionHelper {\n  private gitignore: ReturnType<typeof ignore> | null = null;\n  private workingDirectory: string;\n\n  /**\n   * @param workingDirectory - Directory to search for .gitignore\n   * @param additionalPatterns - Additional patterns to include (optional, defaults to common build artifacts)\n   */\n  constructor(\n    workingDirectory: string = process.cwd(),\n    additionalPatterns: string[] | null = DEFAULT_EXCLUSION_PATTERNS\n  ) {\n    // Validate and normalize workingDirectory to prevent path traversal\n    const normalizedPath = path.resolve(workingDirectory);\n\n    // Ensure path doesn't contain suspicious patterns after normalization\n    // Check for null bytes which could be used for injection\n    if (normalizedPath.includes('\\0')) {\n      throw new Error('Invalid workingDirectory: contains null bytes');\n    }\n\n    this.workingDirectory = normalizedPath;\n\n    // Load gitignore synchronously during construction\n    // This is acceptable because:\n    // 1. Constructor is called once during initialization\n    // 2. .gitignore files are typically small (<10KB)\n    // 3. Synchronous loading ensures patterns are ready immediately\n    // 4. Avoids async constructor complexity\n    this.loadGitignore(additionalPatterns);\n  }\n\n  /**\n   * Load .gitignore patterns from the working directory (called once in constructor)\n   * @param additionalPatterns - Additional patterns to add to gitignore rules\n   */\n  private loadGitignore(additionalPatterns: string[] | null): void {\n    // Resolve both paths to absolute, normalized forms\n    const gitignorePath = path.resolve(this.workingDirectory, '.gitignore');\n    const resolvedWorkingDir = path.resolve(this.workingDirectory);\n\n    try {\n      // Robust path validation using path.relative()\n      // This handles symlinks and edge cases better than string comparison\n      const relativePath = path.relative(resolvedWorkingDir, gitignorePath);\n\n      // Security check: ensure .gitignore is within working directory\n      // Reject if:\n      // - Starts with '..' (parent directory)\n      // - Is an absolute path (should be relative after path.relative())\n      if (relativePath.startsWith('..') || path.isAbsolute(relativePath)) {\n        throw new Error('Invalid gitignore path: path traversal detected');\n      }\n\n      // Additionally verify it's exactly '.gitignore' (no subdirectories)\n      if (relativePath !== '.gitignore') {\n        throw new Error('Invalid gitignore path: must be .gitignore in working directory');\n      }\n\n      this.gitignore = ignore();\n\n      // Add additional patterns first (lower priority)\n      if (additionalPatterns && additionalPatterns.length > 0) {\n        this.gitignore.add(additionalPatterns);\n      }\n\n      // Load and add .gitignore patterns (higher priority)\n      if (fs.existsSync(gitignorePath)) {\n        const rawContent = fs.readFileSync(gitignorePath, 'utf8');\n\n        // Comprehensive sanitization to prevent injection attacks\n        const gitignoreContent = rawContent\n          .replace(/[\\r\\n]+/g, '\\n') // Normalize line endings first\n          .replace(/[\\x00-\\x09\\x0B-\\x1F\\x7F]/g, '') // Remove control chars except \\n (0x0A)\n          .split('\\n')\n          .filter(line => line.length < 1000) // Reject extremely long lines that could cause DoS\n          .join('\\n')\n          .trim();\n\n        this.gitignore.add(gitignoreContent);\n        if (process.env.VISOR_DEBUG === 'true') {\n          console.error('‚úÖ Loaded .gitignore patterns for file filtering');\n        }\n      } else if (additionalPatterns && additionalPatterns.length > 0) {\n        // Always emit a user-visible warning so callers can assert this behavior in tests\n        console.error('No .gitignore found, using default exclusion patterns');\n        console.warn('No .gitignore found, using default exclusion patterns');\n      }\n    } catch (error) {\n      // Always emit a warning with the error for visibility and tests\n      console.warn('Failed to load .gitignore:', error instanceof Error ? error.message : error);\n    }\n  }\n\n  /**\n   * Check if a file should be excluded based on .gitignore patterns\n   */\n  shouldExcludeFile(filename: string): boolean {\n    // Check against .gitignore patterns if loaded\n    if (this.gitignore) {\n      return this.gitignore.ignores(filename);\n    }\n\n    return false;\n  }\n}\n","import { simpleGit, SimpleGit, type DefaultLogFields, type ListLogLine } from 'simple-git';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport { PRInfo, PRDiff } from './pr-analyzer';\nimport { FileExclusionHelper } from './utils/file-exclusion';\n\nexport interface GitFileChange {\n  filename: string;\n  status: 'added' | 'removed' | 'modified' | 'renamed';\n  additions: number;\n  deletions: number;\n  changes: number;\n  content?: string;\n  patch?: string;\n  truncated?: boolean;\n}\n\n// Maximum patch size in bytes (50KB) - helps prevent token limit issues\nconst MAX_PATCH_SIZE = 50 * 1024;\n\nexport interface GitRepositoryInfo {\n  title: string;\n  body: string;\n  author: string;\n  base: string;\n  head: string;\n  files: GitFileChange[];\n  totalAdditions: number;\n  totalDeletions: number;\n  isGitRepository: boolean;\n  workingDirectory: string;\n}\n\nexport class GitRepositoryAnalyzer {\n  private git: SimpleGit;\n  private cwd: string;\n  private fileExclusionHelper: FileExclusionHelper;\n\n  constructor(workingDirectory: string = process.cwd()) {\n    this.cwd = workingDirectory;\n    this.git = simpleGit(workingDirectory);\n    this.fileExclusionHelper = new FileExclusionHelper(workingDirectory);\n  }\n\n  /**\n   * Analyze the current git repository state and return data compatible with PRInfo interface\n   */\n  async analyzeRepository(\n    includeContext: boolean = true,\n    enableBranchDiff: boolean = false\n  ): Promise<GitRepositoryInfo> {\n    // Check if we're in a git repository\n    const isRepo = await this.isGitRepository();\n    if (!isRepo) {\n      return this.createEmptyRepositoryInfo('Not a git repository');\n    }\n\n    try {\n      // Get current branch and status\n      const [status, currentBranch, baseBranch] = await Promise.all([\n        this.git.status(),\n        this.getCurrentBranch(),\n        this.getBaseBranch(),\n      ]);\n\n      // Determine if we're on a feature branch\n      const isFeatureBranch =\n        currentBranch !== baseBranch && currentBranch !== 'main' && currentBranch !== 'master';\n\n      // Get uncommitted changes first\n      let uncommittedFiles = await this.getUncommittedChanges(includeContext);\n\n      // If branch diff is explicitly enabled, use branch diff (ignoring uncommitted changes)\n      // Otherwise, if on a feature branch with no uncommitted changes AND branch diff is enabled, get diff vs base branch\n      if (isFeatureBranch && includeContext && enableBranchDiff) {\n        if (uncommittedFiles.length > 0) {\n          console.error(`üìä Feature branch detected: ${currentBranch}`);\n          console.error(\n            `‚ö†Ô∏è  Ignoring ${uncommittedFiles.length} uncommitted file(s) due to --analyze-branch-diff flag`\n          );\n        } else {\n          console.error(`üìä Feature branch detected: ${currentBranch}`);\n        }\n        console.error(\n          `üìÇ Analyzing diff vs ${baseBranch} (${uncommittedFiles.length > 0 ? 'forced by --analyze-branch-diff' : 'auto-enabled for code-review schemas'})`\n        );\n        uncommittedFiles = await this.getBranchDiff(baseBranch, includeContext);\n      } else if (uncommittedFiles.length > 0) {\n        console.error(`üìù Analyzing uncommitted changes (${uncommittedFiles.length} files)`);\n      }\n\n      // Get recent commit info (handle repos with no commits)\n      let lastCommit: (ListLogLine & DefaultLogFields) | null = null;\n      try {\n        const recentCommits = await this.git.log({ maxCount: 1 });\n        lastCommit = recentCommits.latest;\n      } catch {\n        // Repository has no commits yet - this is OK\n        console.error('üìù Repository has no commits yet, analyzing uncommitted changes');\n      }\n\n      // Get author from git config if no commits exist\n      let author = lastCommit?.author_name;\n      if (!author) {\n        try {\n          // Read ONLY repository-local config to avoid leaking global user identity into tests\n          const [userName, userEmail] = await Promise.all([\n            this.git.raw(['config', '--local', 'user.name']).catch(() => null),\n            this.git.raw(['config', '--local', 'user.email']).catch(() => null),\n          ]);\n          author = userName?.trim() || userEmail?.trim() || 'unknown';\n        } catch {\n          author = 'unknown';\n        }\n      }\n\n      // Create repository info\n      const repositoryInfo: GitRepositoryInfo = {\n        title: this.generateTitle(status, currentBranch),\n        body: this.generateDescription(status, lastCommit),\n        author,\n        base: baseBranch,\n        head: currentBranch,\n        files: uncommittedFiles,\n        totalAdditions: uncommittedFiles.reduce((sum, file) => sum + file.additions, 0),\n        totalDeletions: uncommittedFiles.reduce((sum, file) => sum + file.deletions, 0),\n        isGitRepository: true,\n        workingDirectory: this.cwd,\n      };\n\n      return repositoryInfo;\n    } catch (error) {\n      // Don't log the full error object to avoid confusing stack traces\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      console.error('Error analyzing git repository:', errorMessage);\n      return this.createEmptyRepositoryInfo('Error analyzing git repository');\n    }\n  }\n\n  /**\n   * Convert GitRepositoryInfo to PRInfo format for compatibility with existing PRReviewer\n   */\n  toPRInfo(repositoryInfo: GitRepositoryInfo, includeContext: boolean = true): PRInfo {\n    const files = repositoryInfo.files.map(\n      (file): PRDiff => ({\n        filename: file.filename,\n        additions: file.additions,\n        deletions: file.deletions,\n        changes: file.changes,\n        patch: includeContext ? file.patch : undefined,\n        status: file.status,\n      })\n    );\n\n    // Generate fullDiff from patches if includeContext is true\n    let fullDiff: string | undefined;\n    if (includeContext) {\n      fullDiff = files\n        .filter(file => file.patch)\n        .map(file => `--- ${file.filename}\\n${file.patch}`)\n        .join('\\n\\n');\n    }\n\n    return {\n      number: 0, // Local analysis doesn't have PR number\n      title: repositoryInfo.title,\n      body: repositoryInfo.body,\n      author: repositoryInfo.author,\n      base: repositoryInfo.base,\n      head: repositoryInfo.head,\n      files,\n      totalAdditions: repositoryInfo.totalAdditions,\n      totalDeletions: repositoryInfo.totalDeletions,\n      fullDiff,\n    };\n  }\n\n  private async isGitRepository(): Promise<boolean> {\n    try {\n      await this.git.checkIsRepo();\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  private async getCurrentBranch(): Promise<string> {\n    try {\n      const branchSummary = await this.git.branch();\n      return branchSummary.current || 'unknown';\n    } catch {\n      return 'unknown';\n    }\n  }\n\n  private async getBaseBranch(): Promise<string> {\n    try {\n      // Try to get the default branch from remote\n      const branches = await this.git.branch(['-r']);\n      const mainBranches = ['origin/main', 'origin/master', 'origin/develop'];\n\n      for (const mainBranch of mainBranches) {\n        if (branches.all.includes(mainBranch)) {\n          return mainBranch.replace('origin/', '');\n        }\n      }\n\n      // Fallback to main/master\n      return 'main';\n    } catch {\n      return 'main';\n    }\n  }\n\n  /**\n   * Truncate a patch if it exceeds MAX_PATCH_SIZE\n   */\n  private truncatePatch(patch: string, filename: string): { patch: string; truncated: boolean } {\n    const patchSize = Buffer.byteLength(patch, 'utf8');\n\n    if (patchSize <= MAX_PATCH_SIZE) {\n      return { patch, truncated: false };\n    }\n\n    // Truncate to MAX_PATCH_SIZE and add a notice\n    const truncated = patch.substring(0, MAX_PATCH_SIZE);\n    const truncatedPatch = `${truncated}\\n\\n... [TRUNCATED: Diff too large (${(patchSize / 1024).toFixed(1)}KB), showing first ${(MAX_PATCH_SIZE / 1024).toFixed(0)}KB] ...`;\n\n    console.error(\n      `‚ö†Ô∏è  Truncated diff for ${filename} (${(patchSize / 1024).toFixed(1)}KB ‚Üí ${(MAX_PATCH_SIZE / 1024).toFixed(0)}KB)`\n    );\n\n    return { patch: truncatedPatch, truncated: true };\n  }\n\n  private async getRemoteInfo(): Promise<{ name: string; url: string } | null> {\n    try {\n      const remotes = await this.git.getRemotes(true);\n      const origin = remotes.find(r => r.name === 'origin');\n      return origin\n        ? { name: origin.name, url: origin.refs.fetch || origin.refs.push || '' }\n        : null;\n    } catch {\n      return null;\n    }\n  }\n\n  private async getUncommittedChanges(includeContext: boolean = true): Promise<GitFileChange[]> {\n    try {\n      const status = await this.git.status();\n      const changes: GitFileChange[] = [];\n\n      // Process different types of changes\n      const fileChanges = [\n        ...status.created.map(f => ({ file: f, status: 'added' as const })),\n        ...status.deleted.map(f => ({ file: f, status: 'removed' as const })),\n        ...status.modified.map(f => ({ file: f, status: 'modified' as const })),\n        ...status.renamed.map(f => ({\n          file: typeof f === 'string' ? f : f.to || f.from,\n          status: 'renamed' as const,\n        })),\n      ];\n\n      for (const { file, status } of fileChanges) {\n        // Skip files that should be excluded from analysis\n        // FileExclusionHelper uses .gitignore patterns, which is sufficient\n        if (this.fileExclusionHelper.shouldExcludeFile(file)) {\n          console.error(`‚è≠Ô∏è  Skipping excluded file: ${file}`);\n          continue;\n        }\n\n        const filePath = path.join(this.cwd, file);\n        const fileChange = await this.analyzeFileChange(file, status, filePath, includeContext);\n        changes.push(fileChange);\n      }\n\n      return changes;\n    } catch (error) {\n      console.error('Error getting uncommitted changes:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Get diff between current branch and base branch (for feature branch analysis)\n   */\n  private async getBranchDiff(\n    baseBranch: string,\n    includeContext: boolean = true\n  ): Promise<GitFileChange[]> {\n    try {\n      // Get the list of changed files between base and current branch\n      const diffSummary = await this.git.diffSummary([baseBranch]);\n      const changes: GitFileChange[] = [];\n\n      if (!diffSummary || !diffSummary.files) {\n        return [];\n      }\n\n      for (const file of diffSummary.files) {\n        // Skip files that should be excluded from analysis\n        // FileExclusionHelper uses .gitignore patterns, which is sufficient\n        if (this.fileExclusionHelper.shouldExcludeFile(file.file)) {\n          console.error(`‚è≠Ô∏è  Skipping excluded file: ${file.file}`);\n          continue;\n        }\n\n        // Handle different file types (binary files don't have insertions/deletions)\n        const isBinary = 'binary' in file && file.binary;\n        const insertions = 'insertions' in file ? file.insertions : 0;\n        const deletions = 'deletions' in file ? file.deletions : 0;\n        const fileChanges = 'changes' in file ? file.changes : 0;\n\n        // Determine status based on insertions/deletions\n        let status: 'added' | 'removed' | 'modified' | 'renamed';\n        if (isBinary) {\n          status = 'modified';\n        } else if (insertions > 0 && deletions === 0) {\n          status = 'added';\n        } else if (insertions === 0 && deletions > 0) {\n          status = 'removed';\n        } else {\n          status = 'modified';\n        }\n\n        // Get the actual diff patch if needed\n        let patch: string | undefined;\n        let truncated = false;\n        if (includeContext && !isBinary) {\n          try {\n            const rawPatch = await this.git.diff([baseBranch, '--', file.file]);\n            if (rawPatch) {\n              const result = this.truncatePatch(rawPatch, file.file);\n              patch = result.patch;\n              truncated = result.truncated;\n            }\n          } catch {\n            // Ignore diff errors for specific files\n          }\n        }\n\n        const fileChange: GitFileChange = {\n          filename: file.file,\n          additions: insertions,\n          deletions: deletions,\n          changes: fileChanges,\n          status,\n          patch,\n          truncated,\n        };\n\n        changes.push(fileChange);\n      }\n\n      return changes;\n    } catch (error) {\n      console.error('Error getting branch diff:', error);\n      return [];\n    }\n  }\n\n  private async analyzeFileChange(\n    filename: string,\n    status: 'added' | 'removed' | 'modified' | 'renamed',\n    filePath: string,\n    includeContext: boolean = true\n  ): Promise<GitFileChange> {\n    let additions = 0;\n    let deletions = 0;\n    let patch: string | undefined;\n    let content: string | undefined;\n    let truncated = false;\n\n    try {\n      // Get diff for the file if it exists and is not binary\n      if (includeContext && status !== 'added' && fs.existsSync(filePath)) {\n        const diff = await this.git.diff(['--', filename]).catch(() => '');\n        if (diff) {\n          const result = this.truncatePatch(diff, filename);\n          patch = result.patch;\n          truncated = result.truncated;\n          // Count additions and deletions from diff\n          const lines = diff.split('\\n');\n          additions = lines.filter(line => line.startsWith('+')).length;\n          deletions = lines.filter(line => line.startsWith('-')).length;\n        }\n      } else if (status !== 'added' && fs.existsSync(filePath)) {\n        // If not including context, still count changes for statistics\n        const diff = await this.git.diff(['--', filename]).catch(() => '');\n        if (diff) {\n          const lines = diff.split('\\n');\n          additions = lines.filter(line => line.startsWith('+')).length;\n          deletions = lines.filter(line => line.startsWith('-')).length;\n        }\n      }\n\n      // For added files\n      if (status === 'added' && fs.existsSync(filePath)) {\n        try {\n          const stats = fs.statSync(filePath);\n          if (stats.isFile() && stats.size < 1024 * 1024) {\n            // Skip files larger than 1MB\n            if (includeContext) {\n              content = fs.readFileSync(filePath, 'utf8');\n              const result = this.truncatePatch(content, filename);\n              patch = result.patch; // For new files, the entire content is the \"patch\"\n              truncated = result.truncated;\n            }\n            // Always count additions for statistics\n            const fileContent = includeContext ? content : fs.readFileSync(filePath, 'utf8');\n            additions = fileContent!.split('\\n').length;\n          }\n        } catch {\n          // Skip binary or unreadable files\n        }\n      }\n\n      // For removed files, we can't easily count the lines without the previous version\n      if (status === 'removed') {\n        deletions = 1; // Placeholder - in real git we'd need the previous version\n      }\n    } catch (error) {\n      console.error(`Error analyzing file change for ${filename}:`, error);\n    }\n\n    return {\n      filename,\n      status,\n      additions,\n      deletions,\n      changes: additions + deletions,\n      content,\n      patch,\n      truncated,\n    };\n  }\n\n  private generateTitle(status: import('simple-git').StatusResult, branch: string): string {\n    if (status.files.length === 0) {\n      return `Local Analysis: ${branch} (No changes)`;\n    }\n\n    const changeTypes = [];\n    if (status.created.length > 0) changeTypes.push(`${status.created.length} added`);\n    if (status.modified.length > 0) changeTypes.push(`${status.modified.length} modified`);\n    if (status.deleted.length > 0) changeTypes.push(`${status.deleted.length} deleted`);\n    if (status.renamed.length > 0) changeTypes.push(`${status.renamed.length} renamed`);\n\n    return `Local Analysis: ${branch} (${changeTypes.join(', ')})`;\n  }\n\n  private generateDescription(\n    status: import('simple-git').StatusResult,\n    lastCommit: import('simple-git').DefaultLogFields | null\n  ): string {\n    let description = `Analysis of local git repository working directory.\\n\\n`;\n\n    if (lastCommit) {\n      description += `**Last Commit:** ${lastCommit.message}\\n`;\n      description += `**Author:** ${lastCommit.author_name} <${lastCommit.author_email}>\\n`;\n      description += `**Date:** ${lastCommit.date}\\n\\n`;\n    }\n\n    if (status.files.length === 0) {\n      description += `**Status:** Working directory is clean - no uncommitted changes found.\\n`;\n    } else {\n      description += `**Changes Summary:**\\n`;\n      description += `- Files to be committed: ${status.staged.length}\\n`;\n      description += `- Modified files: ${status.modified.length}\\n`;\n      description += `- Untracked files: ${status.not_added.length}\\n`;\n\n      if (status.conflicted.length > 0) {\n        description += `- Conflicted files: ${status.conflicted.length}\\n`;\n      }\n    }\n\n    return description;\n  }\n\n  private createEmptyRepositoryInfo(reason: string): GitRepositoryInfo {\n    return {\n      title: `Local Analysis: ${reason}`,\n      body: `Unable to analyze repository: ${reason}`,\n      author: 'system',\n      base: 'main',\n      head: 'HEAD',\n      files: [],\n      totalAdditions: 0,\n      totalDeletions: 0,\n      isGitRepository: false,\n      workingDirectory: this.cwd,\n    };\n  }\n}\n","import { Octokit } from '@octokit/rest';\nimport * as path from 'path';\nimport { FileExclusionHelper } from './utils/file-exclusion';\n\nexport interface PRFile {\n  filename: string;\n  additions: number;\n  deletions: number;\n  changes: number;\n  patch?: string;\n  status: 'added' | 'removed' | 'modified' | 'renamed';\n}\n\nexport interface PRDiff {\n  filename: string;\n  additions: number;\n  deletions: number;\n  changes: number;\n  patch?: string;\n  status: 'added' | 'removed' | 'modified' | 'renamed';\n}\n\nexport interface PRComment {\n  id: number;\n  author: string;\n  body: string;\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface PRInfo {\n  number: number;\n  title: string;\n  body: string;\n  author: string;\n  authorAssociation?: string; // GitHub author_association: OWNER, MEMBER, COLLABORATOR, CONTRIBUTOR, etc.\n  base: string;\n  head: string;\n  files: PRDiff[];\n  totalAdditions: number;\n  totalDeletions: number;\n  eventType?: import('./types/config').EventTrigger;\n  fullDiff?: string;\n  commitDiff?: string;\n  isIncremental?: boolean; // Flag to indicate if this was intended as incremental analysis\n  isIssue?: boolean; // Flag to indicate this is an issue, not a PR\n  eventContext?: Record<string, unknown>; // GitHub event context for templates\n  comments?: PRComment[]; // Comments added dynamically\n  labels?: string[]; // Labels applied to the PR (for behavior overrides)\n}\n\ninterface NetworkError {\n  code?: string;\n  message?: string;\n  status?: number;\n}\n\nexport class PRAnalyzer {\n  private fileExclusionHelper: FileExclusionHelper;\n\n  constructor(\n    private octokit: Octokit,\n    private maxRetries: number = 3,\n    workingDirectory: string = path.resolve(process.cwd())\n  ) {\n    this.fileExclusionHelper = new FileExclusionHelper(workingDirectory);\n  }\n\n  /**\n   * Fetch commit diff for incremental analysis\n   */\n  async fetchCommitDiff(owner: string, repo: string, commitSha: string): Promise<string> {\n    try {\n      const { data: commit } = await this.withRetry(() =>\n        this.octokit.rest.repos.getCommit({\n          owner,\n          repo,\n          ref: commitSha,\n        })\n      );\n\n      // Extract patches from all files in the commit\n      const patches =\n        commit.files\n          ?.filter(file => file.patch)\n          .map(file => `--- ${file.filename}\\n${file.patch}`)\n          .join('\\n\\n') || '';\n\n      return patches;\n    } catch (error) {\n      console.warn(`Failed to fetch commit diff for ${commitSha}:`, error);\n      return '';\n    }\n  }\n\n  /**\n   * Generate unified diff for all PR files\n   */\n  private generateFullDiff(files: PRDiff[]): string {\n    return files\n      .filter(file => file.patch)\n      .map(file => `--- ${file.filename}\\n${file.patch}`)\n      .join('\\n\\n');\n  }\n\n  async fetchPRDiff(\n    owner: string,\n    repo: string,\n    prNumber: number,\n    commitSha?: string,\n    eventType?: import('./types/config').EventTrigger\n  ): Promise<PRInfo> {\n    const [prData, filesData] = await Promise.all([\n      this.withRetry(() =>\n        this.octokit.rest.pulls.get({\n          owner,\n          repo,\n          pull_number: prNumber,\n        })\n      ),\n      this.withRetry(() =>\n        this.octokit.rest.pulls.listFiles({\n          owner,\n          repo,\n          pull_number: prNumber,\n        })\n      ),\n    ]);\n\n    const pr = prData?.data;\n    const files = filesData?.data || [];\n\n    // Handle missing or malformed PR data gracefully\n    if (!pr) {\n      throw new Error('Invalid or missing pull request data');\n    }\n\n    // Validate critical fields and provide defaults for missing data\n    const title = typeof pr.title === 'string' ? pr.title : pr.title ? String(pr.title) : 'MISSING';\n    const body = typeof pr.body === 'string' ? pr.body : pr.body ? String(pr.body) : '';\n    const author =\n      pr.user && typeof pr.user === 'object' && pr.user.login\n        ? typeof pr.user.login === 'string'\n          ? pr.user.login\n          : String(pr.user.login)\n        : 'unknown';\n    const authorAssociation =\n      pr.author_association && typeof pr.author_association === 'string'\n        ? pr.author_association\n        : undefined;\n    const base =\n      pr.base && typeof pr.base === 'object' && pr.base.ref\n        ? typeof pr.base.ref === 'string'\n          ? pr.base.ref\n          : String(pr.base.ref)\n        : 'main';\n    const head =\n      pr.head && typeof pr.head === 'object' && pr.head.ref\n        ? typeof pr.head.ref === 'string'\n          ? pr.head.ref\n          : String(pr.head.ref)\n        : 'feature';\n\n    // Filter out malformed files and handle invalid data types\n    // Apply exclusion filtering early to avoid unnecessary processing\n    let skippedCount = 0;\n    const validFiles = files\n      ? files\n          .filter(file => file && typeof file === 'object' && file.filename)\n          .filter(file => {\n            // Early filtering: check exclusion before processing\n            const filename =\n              typeof file.filename === 'string'\n                ? file.filename\n                : String(file.filename || 'unknown');\n            if (!filename || this.fileExclusionHelper.shouldExcludeFile(filename)) {\n              skippedCount++;\n              return false;\n            }\n            return true;\n          })\n          .map(file => ({\n            filename:\n              typeof file.filename === 'string'\n                ? file.filename\n                : String(file.filename || 'unknown'),\n            additions: typeof file.additions === 'number' ? Math.max(0, file.additions) : 0,\n            deletions: typeof file.deletions === 'number' ? Math.max(0, file.deletions) : 0,\n            changes: typeof file.changes === 'number' ? Math.max(0, file.changes) : 0,\n            patch: typeof file.patch === 'string' ? file.patch : undefined,\n            status: (['added', 'removed', 'modified', 'renamed'].includes(file.status)\n              ? file.status\n              : 'modified') as 'added' | 'removed' | 'modified' | 'renamed',\n          }))\n      : [];\n\n    // Log skipped files summary\n    if (skippedCount > 0) {\n      console.log(`‚è≠Ô∏è  Skipped ${skippedCount} excluded file(s)`);\n    }\n\n    const prInfo: PRInfo = {\n      number: typeof pr.number === 'number' ? pr.number : parseInt(String(pr.number || 1), 10),\n      title,\n      body,\n      author,\n      authorAssociation,\n      base,\n      head,\n      files: validFiles,\n      totalAdditions: validFiles.reduce((sum, file) => sum + file.additions, 0),\n      totalDeletions: validFiles.reduce((sum, file) => sum + file.deletions, 0),\n      fullDiff: this.generateFullDiff(validFiles),\n      eventType,\n    };\n\n    // Fetch comment history for better context\n    try {\n      console.log(`üí¨ Fetching comment history for PR #${prInfo.number}`);\n      const comments = await this.fetchPRComments(owner, repo, prInfo.number);\n      (prInfo as PRInfo & { comments: PRComment[] }).comments = comments;\n      console.log(`‚úÖ Retrieved ${comments.length} comments`);\n    } catch (error) {\n      console.warn(\n        `‚ö†Ô∏è Could not fetch comments: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n      (prInfo as PRInfo & { comments: PRComment[] }).comments = [];\n    }\n\n    // Add commit diff for incremental analysis\n    if (commitSha) {\n      console.log(`üîß Fetching incremental diff for commit: ${commitSha}`);\n      prInfo.commitDiff = await this.fetchCommitDiff(owner, repo, commitSha);\n      prInfo.isIncremental = true;\n      if (!prInfo.commitDiff || prInfo.commitDiff.length === 0) {\n        console.warn(\n          `‚ö†Ô∏è No commit diff retrieved for ${commitSha}, will use full diff as fallback`\n        );\n      } else {\n        console.log(`‚úÖ Incremental diff retrieved (${prInfo.commitDiff.length} chars)`);\n      }\n    } else {\n      prInfo.isIncremental = false;\n    }\n\n    return prInfo;\n  }\n\n  async fetchPRComments(owner: string, repo: string, prNumber: number) {\n    const { data: comments } = await this.withRetry(() =>\n      this.octokit.rest.issues.listComments({\n        owner,\n        repo,\n        issue_number: prNumber,\n      })\n    );\n\n    return comments.map(comment => ({\n      id: comment.id,\n      author: comment.user?.login || 'unknown',\n      body: comment.body || '',\n      createdAt: comment.created_at,\n      updatedAt: comment.updated_at,\n    }));\n  }\n\n  private async withRetry<T>(operation: () => Promise<T>): Promise<T> {\n    let lastError: Error = new Error('Unknown error');\n\n    for (let attempt = 0; attempt <= this.maxRetries; attempt++) {\n      try {\n        return await operation();\n      } catch (error) {\n        // Preserve the original error object if possible\n        if (error instanceof Error) {\n          lastError = error;\n        } else if (typeof error === 'object' && error !== null) {\n          // For objects like {code: 'ETIMEDOUT', message: 'Network timeout'}\n          const errorObj = error as NetworkError;\n          const message = errorObj.message || errorObj.code || 'Unknown error';\n          lastError = new Error(String(message));\n          // Preserve important properties\n          Object.assign(lastError, error);\n        } else {\n          lastError = new Error(String(error));\n        }\n\n        // Don't retry on the last attempt\n        if (attempt === this.maxRetries) {\n          break;\n        }\n\n        // Check if this is a retryable error\n        if (this.isRetryableError(error)) {\n          const delay = Math.min(1000 * Math.pow(2, attempt), 5000); // Exponential backoff, max 5s\n          await new Promise(resolve => setTimeout(resolve, delay));\n        } else {\n          // Non-retryable error, fail immediately with original error\n          throw error;\n        }\n      }\n    }\n\n    throw lastError;\n  }\n\n  private isRetryableError(error: unknown): boolean {\n    // Retry on network timeouts, connection errors, and temporary server errors\n    const retryableErrors = ['ETIMEDOUT', 'ECONNRESET', 'ECONNREFUSED', 'ENOTFOUND', 'EAI_AGAIN'];\n    const retryableStatuses = [408, 429, 500, 502, 503, 504];\n\n    // Type guard for error objects\n    if (typeof error !== 'object' || error === null) {\n      return false;\n    }\n\n    const err = error as NetworkError & { response?: { status?: number } };\n\n    return (\n      (err.code !== undefined && retryableErrors.includes(err.code)) ||\n      (err.status !== undefined && retryableStatuses.includes(err.status)) ||\n      (err.response?.status !== undefined && retryableStatuses.includes(err.response.status))\n    );\n  }\n}\n","import { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { EnvConfig, HumanInputRequest } from '../types/config';\n\n/**\n * Configuration for a check provider\n */\nexport interface CheckProviderConfig {\n  type: string;\n  prompt?: string;\n  eventContext?: Record<string, unknown>;\n  focus?: string;\n  command?: string; // For PR comment triggers\n  exec?: string; // For command execution (supports Liquid templates)\n  stdin?: string; // Optional stdin input (supports Liquid templates)\n  args?: string[] | Record<string, unknown>; // string[] deprecated for command args; Record for workflow inputs\n  command_args?: string[]; // MCP stdio command arguments\n  interpreter?: string;\n  url?: string;\n  method?: string;\n  headers?: Record<string, string>;\n  timeout?: number;\n  metadata?: Record<string, unknown>;\n  workingDirectory?: string;\n  env?: EnvConfig;\n  ai?: import('../types/config').AIProviderConfig;\n  /** AI model to use for this check - overrides global setting */\n  ai_model?: string;\n  /** AI provider to use for this check - overrides global setting */\n  ai_provider?: 'google' | 'anthropic' | 'openai' | string;\n  /** Check name for sessionID and logging purposes */\n  checkName?: string;\n  /** Session ID for AI session management */\n  sessionId?: string;\n  /** Script content for 'script' provider */\n  content?: string;\n  [key: string]: unknown;\n}\n\n/**\n * Execution context passed to check providers\n */\nexport interface ExecutionContext {\n  /** Session information for AI session reuse */\n  parentSessionId?: string;\n  reuseSession?: boolean;\n  /** CLI message value (from --message argument) */\n  cliMessage?: string;\n  /**\n   * Stage-local baseline of output history lengths per check name.\n   * When present, providers should expose an `outputs_history_stage` object in\n   * Liquid/JS contexts that slices the global history from this baseline.\n   * This enables stage-scoped assertions in the YAML test runner without\n   * relying on global execution history.\n   */\n  stageHistoryBase?: Record<string, number>;\n  /** Workflow inputs - available when executing within a workflow */\n  workflowInputs?: Record<string, unknown>;\n  /** SDK hooks for human input */\n  hooks?: {\n    onHumanInput?: (request: HumanInputRequest) => Promise<string>;\n    onPromptCaptured?: (info: { step: string; provider: string; prompt: string }) => void;\n    mockForStep?: (step: string) => unknown | undefined;\n  };\n  /**\n   * Optional execution mode hints. The core engine does not read environment\n   * variables directly; callers (CLI, test runner) can set these flags to\n   * request certain behaviors without polluting core logic with test-specific\n   * branches.\n   */\n  mode?: {\n    /** true when running under the YAML test runner */\n    test?: boolean;\n    /** post review comments from grouped execution paths (used by tests) */\n    postGroupedComments?: boolean;\n    /** reset per-run guard state before grouped execution */\n    resetPerRunState?: boolean;\n  };\n}\n\n/**\n * Abstract base class for all check providers\n * Implementing classes provide specific check functionality (AI, tool, script, etc.)\n */\nexport abstract class CheckProvider {\n  /**\n   * Get the unique name/type of this provider\n   */\n  abstract getName(): string;\n\n  /**\n   * Get a human-readable description of this provider\n   */\n  abstract getDescription(): string;\n\n  /**\n   * Validate provider-specific configuration\n   * @param config The configuration to validate\n   * @returns true if configuration is valid, false otherwise\n   */\n  abstract validateConfig(config: unknown): Promise<boolean>;\n\n  /**\n   * Execute the check on the given PR information\n   * @param prInfo Information about the pull request\n   * @param config Provider-specific configuration\n   * @param dependencyResults Optional results from dependency checks that this check depends on\n   * @param context Optional execution context with session info, hooks, and CLI state\n   * @returns Review summary with scores, issues, and comments\n   */\n  abstract execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    context?: ExecutionContext\n  ): Promise<ReviewSummary>;\n\n  /**\n   * Get the list of configuration keys this provider supports\n   * Used for documentation and validation\n   */\n  abstract getSupportedConfigKeys(): string[];\n\n  /**\n   * Check if this provider is available (e.g., has required API keys)\n   * @returns true if provider can be used, false otherwise\n   */\n  abstract isAvailable(): Promise<boolean>;\n\n  /**\n   * Get provider requirements (e.g., environment variables needed)\n   */\n  abstract getRequirements(): string[];\n\n  /**\n   * Set webhook context for providers that need access to webhook data\n   * This is optional and only used by http_input providers\n   * @param webhookContext Map of endpoint paths to webhook data\n   */\n  setWebhookContext?(webhookContext: Map<string, unknown>): void;\n}\n","/**\n * Environment variable resolution utilities\n * Supports GitHub Actions-like syntax for referencing environment variables\n */\n\nimport { EnvConfig } from '../types/config';\n\n/**\n * Resolves environment variables in configuration values\n * Supports the following syntaxes:\n * - ${{ env.VARIABLE_NAME }} (GitHub Actions style)\n * - ${VARIABLE_NAME} (shell style)\n * - $VARIABLE_NAME (simple shell style)\n * - Direct environment variable names\n */\nexport class EnvironmentResolver {\n  /**\n   * Resolves a single configuration value that may contain environment variable references\n   */\n  static resolveValue(value: string | number | boolean): string | number | boolean {\n    if (typeof value !== 'string') {\n      return value;\n    }\n\n    // GitHub Actions style: ${{ env.VARIABLE_NAME }}\n    let resolved = value.replace(/\\$\\{\\{\\s*env\\.([A-Z_][A-Z0-9_]*)\\s*\\}\\}/g, (match, envVar) => {\n      return process.env[envVar] || match;\n    });\n\n    // Shell style: ${VARIABLE_NAME}\n    resolved = resolved.replace(/\\$\\{([A-Z_][A-Z0-9_]*)\\}/g, (match, envVar) => {\n      return process.env[envVar] || match;\n    });\n\n    // Simple shell style: $VARIABLE_NAME\n    resolved = resolved.replace(/\\$([A-Z_][A-Z0-9_]*)/g, (match, envVar) => {\n      return process.env[envVar] || match;\n    });\n\n    return resolved;\n  }\n\n  /**\n   * Resolves all environment variables in an EnvConfig object\n   */\n  static resolveEnvConfig(envConfig: EnvConfig): EnvConfig {\n    const resolved: EnvConfig = {};\n\n    for (const [key, value] of Object.entries(envConfig)) {\n      resolved[key] = this.resolveValue(value);\n    }\n\n    return resolved;\n  }\n\n  /**\n   * Applies environment configuration to the process environment\n   * This allows checks to access their specific environment variables\n   */\n  static applyEnvConfig(envConfig: EnvConfig): void {\n    const resolved = this.resolveEnvConfig(envConfig);\n\n    for (const [key, value] of Object.entries(resolved)) {\n      if (value !== undefined) {\n        process.env[key] = String(value);\n      }\n    }\n  }\n\n  /**\n   * Creates a temporary environment for a specific check execution\n   * Returns a cleanup function to restore the original environment\n   */\n  static withTemporaryEnv<T>(envConfig: EnvConfig, callback: () => T | Promise<T>): T | Promise<T> {\n    const resolved = this.resolveEnvConfig(envConfig);\n    const originalValues: Record<string, string | undefined> = {};\n\n    // Store original values and apply new ones\n    for (const [key, value] of Object.entries(resolved)) {\n      originalValues[key] = process.env[key];\n      if (value !== undefined) {\n        process.env[key] = String(value);\n      }\n    }\n\n    try {\n      const result = callback();\n\n      // If callback returns a promise, handle cleanup after it resolves\n      if (result instanceof Promise) {\n        return result.finally(() => {\n          // Restore original values\n          for (const [key, originalValue] of Object.entries(originalValues)) {\n            if (originalValue === undefined) {\n              delete process.env[key];\n            } else {\n              process.env[key] = originalValue;\n            }\n          }\n        });\n      }\n\n      // Restore original values immediately for sync callbacks\n      for (const [key, originalValue] of Object.entries(originalValues)) {\n        if (originalValue === undefined) {\n          delete process.env[key];\n        } else {\n          process.env[key] = originalValue;\n        }\n      }\n\n      return result;\n    } catch (error) {\n      // Restore original values on error\n      for (const [key, originalValue] of Object.entries(originalValues)) {\n        if (originalValue === undefined) {\n          delete process.env[key];\n        } else {\n          process.env[key] = originalValue;\n        }\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Validates that all required environment variables are available\n   */\n  static validateRequiredEnvVars(envConfig: EnvConfig, requiredVars: string[]): string[] {\n    const resolved = this.resolveEnvConfig(envConfig);\n    const missing: string[] = [];\n\n    for (const varName of requiredVars) {\n      const value = resolved[varName] || process.env[varName];\n      if (!value) {\n        missing.push(varName);\n      }\n    }\n\n    return missing;\n  }\n\n  /**\n   * Resolves environment variables in HTTP headers\n   * Each header value is processed through resolveValue to replace env var references\n   */\n  static resolveHeaders(headers: Record<string, string>): Record<string, string> {\n    const resolved: Record<string, string> = {};\n    for (const [key, value] of Object.entries(headers)) {\n      resolved[key] = String(this.resolveValue(value));\n    }\n    return resolved;\n  }\n\n  /**\n   * Sanitizes headers for logging/telemetry by redacting sensitive values\n   * Headers like Authorization, API keys, and cookies are replaced with [REDACTED]\n   */\n  static sanitizeHeaders(headers: Record<string, string>): Record<string, string> {\n    const sensitiveHeaders = ['authorization', 'x-api-key', 'cookie', 'set-cookie'];\n    const sanitized: Record<string, string> = {};\n\n    for (const [key, value] of Object.entries(headers)) {\n      if (sensitiveHeaders.includes(key.toLowerCase())) {\n        sanitized[key] = '[REDACTED]';\n      } else {\n        sanitized[key] = value;\n      }\n    }\n\n    return sanitized;\n  }\n}\n","import * as fs from 'fs';\nimport * as path from 'path';\nimport { ReviewIssue } from './reviewer';\n\n/**\n * Filter for suppressing Visor issues based on special comments in code\n */\nexport class IssueFilter {\n  private fileCache: Map<string, string[]> = new Map();\n  private suppressionEnabled: boolean;\n\n  constructor(suppressionEnabled: boolean = true) {\n    this.suppressionEnabled = suppressionEnabled;\n  }\n\n  /**\n   * Filter out issues that have suppression comments\n   * @param issues Array of issues to filter\n   * @param workingDir Working directory for resolving file paths\n   * @returns Filtered array of issues with suppressed ones removed\n   */\n  public filterIssues(issues: ReviewIssue[], workingDir: string = process.cwd()): ReviewIssue[] {\n    if (!this.suppressionEnabled || !issues || issues.length === 0) {\n      return issues;\n    }\n\n    const filteredIssues: ReviewIssue[] = [];\n    const suppressedCount: { [file: string]: number } = {};\n\n    for (const issue of issues) {\n      if (this.shouldSuppressIssue(issue, workingDir)) {\n        // Track suppressed issues for logging\n        suppressedCount[issue.file] = (suppressedCount[issue.file] || 0) + 1;\n      } else {\n        filteredIssues.push(issue);\n      }\n    }\n\n    // Log suppression summary if any issues were suppressed\n    const totalSuppressed = Object.values(suppressedCount).reduce((sum, count) => sum + count, 0);\n    if (totalSuppressed > 0) {\n      console.log(`üîá Suppressed ${totalSuppressed} issue(s) via visor-disable comments:`);\n      for (const [file, count] of Object.entries(suppressedCount)) {\n        console.log(`   - ${file}: ${count} issue(s)`);\n      }\n    }\n\n    return filteredIssues;\n  }\n\n  /**\n   * Check if an issue should be suppressed based on comments in the file\n   */\n  private shouldSuppressIssue(issue: ReviewIssue, workingDir: string): boolean {\n    // Skip system-level issues or issues without file/line info\n    if (!issue.file || issue.file === 'system' || issue.file === 'webhook' || issue.line === 0) {\n      return false;\n    }\n\n    const lines = this.getFileLines(issue.file, workingDir);\n    if (!lines || lines.length === 0) {\n      return false;\n    }\n\n    // Check for file-level suppression (visor-disable-file in first 5 lines)\n    const firstFiveLines = lines.slice(0, 5).join('\\n').toLowerCase();\n    if (firstFiveLines.includes('visor-disable-file')) {\n      return true;\n    }\n\n    // Check for line-level suppression (visor-disable within ¬±2 lines)\n    const lineIndex = issue.line - 1; // Convert to 0-based index\n    const startLine = Math.max(0, lineIndex - 2);\n    const endLine = Math.min(lines.length - 1, lineIndex + 2);\n\n    for (let i = startLine; i <= endLine; i++) {\n      if (lines[i].toLowerCase().includes('visor-disable')) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Get file lines from cache or read from disk\n   */\n  private getFileLines(filePath: string, workingDir: string): string[] | null {\n    // Check cache first\n    if (this.fileCache.has(filePath)) {\n      return this.fileCache.get(filePath)!;\n    }\n\n    try {\n      // Resolve the file path\n      const resolvedPath = path.isAbsolute(filePath) ? filePath : path.join(workingDir, filePath);\n\n      if (!fs.existsSync(resolvedPath)) {\n        // Try without working directory if the file doesn't exist\n        if (fs.existsSync(filePath)) {\n          const content = fs.readFileSync(filePath, 'utf8');\n          const lines = content.split('\\n');\n          this.fileCache.set(filePath, lines);\n          return lines;\n        }\n        return null;\n      }\n\n      const content = fs.readFileSync(resolvedPath, 'utf8');\n      const lines = content.split('\\n');\n      this.fileCache.set(filePath, lines);\n      return lines;\n    } catch {\n      // Silently skip files that can't be read\n      return null;\n    }\n  }\n\n  /**\n   * Clear the file cache (useful for testing or long-running processes)\n   */\n  public clearCache(): void {\n    this.fileCache.clear();\n  }\n}\n","/**\n * Author permission utilities for checking GitHub author associations\n *\n * GitHub provides author_association field with these values (in order of privilege):\n * - OWNER: Repository owner\n * - MEMBER: Organization member\n * - COLLABORATOR: Invited collaborator\n * - CONTRIBUTOR: Has contributed before\n * - FIRST_TIME_CONTRIBUTOR: First PR to this repo\n * - FIRST_TIMER: First GitHub contribution ever\n * - NONE: No association\n */\n\nexport type AuthorAssociation =\n  | 'OWNER'\n  | 'MEMBER'\n  | 'COLLABORATOR'\n  | 'CONTRIBUTOR'\n  | 'FIRST_TIME_CONTRIBUTOR'\n  | 'FIRST_TIMER'\n  | 'NONE';\n\n/**\n * Permission hierarchy (from highest to lowest privilege)\n */\nconst PERMISSION_HIERARCHY: AuthorAssociation[] = [\n  'OWNER',\n  'MEMBER',\n  'COLLABORATOR',\n  'CONTRIBUTOR',\n  'FIRST_TIME_CONTRIBUTOR',\n  'FIRST_TIMER',\n  'NONE',\n];\n\n/**\n * Get permission level (0 = highest, higher number = lower privilege)\n */\nfunction getPermissionLevel(association: string | undefined): number {\n  if (!association) return PERMISSION_HIERARCHY.length; // Treat unknown as lowest\n  const index = PERMISSION_HIERARCHY.indexOf(association.toUpperCase() as AuthorAssociation);\n  return index === -1 ? PERMISSION_HIERARCHY.length : index;\n}\n\n/**\n * Check if author has at least the specified permission level (>= logic)\n *\n * @param authorAssociation - The author's association from GitHub API\n * @param minPermission - Minimum required permission level\n * @param isLocalMode - Whether running in local/CLI mode (defaults to true for local runs)\n * @returns true if author has at least the specified permission level\n *\n * @example\n * hasMinPermission('MEMBER', 'MEMBER') // true (exact match)\n * hasMinPermission('OWNER', 'MEMBER') // true (owner >= member)\n * hasMinPermission('COLLABORATOR', 'MEMBER') // false (collaborator < member)\n * hasMinPermission(undefined, 'OWNER', true) // true (local mode)\n */\nexport function hasMinPermission(\n  authorAssociation: string | undefined,\n  minPermission: AuthorAssociation,\n  isLocalMode: boolean = false\n): boolean {\n  // In local mode (not GitHub Actions), treat as owner\n  if (isLocalMode) {\n    return true;\n  }\n\n  const authorLevel = getPermissionLevel(authorAssociation);\n  const minLevel = getPermissionLevel(minPermission);\n\n  // Lower number = higher privilege, so author must have equal or lower number\n  return authorLevel <= minLevel;\n}\n\n/**\n * Check if author is exactly the repository owner\n */\nexport function isOwner(\n  authorAssociation: string | undefined,\n  isLocalMode: boolean = false\n): boolean {\n  if (isLocalMode) return true;\n  return authorAssociation?.toUpperCase() === 'OWNER';\n}\n\n/**\n * Check if author is an organization member or owner\n */\nexport function isMember(\n  authorAssociation: string | undefined,\n  isLocalMode: boolean = false\n): boolean {\n  if (isLocalMode) return true;\n  return hasMinPermission(authorAssociation, 'MEMBER', isLocalMode);\n}\n\n/**\n * Check if author is a collaborator (or higher)\n */\nexport function isCollaborator(\n  authorAssociation: string | undefined,\n  isLocalMode: boolean = false\n): boolean {\n  if (isLocalMode) return true;\n  return hasMinPermission(authorAssociation, 'COLLABORATOR', isLocalMode);\n}\n\n/**\n * Check if author is a contributor (has contributed before)\n */\nexport function isContributor(\n  authorAssociation: string | undefined,\n  isLocalMode: boolean = false\n): boolean {\n  if (isLocalMode) return true;\n  return hasMinPermission(authorAssociation, 'CONTRIBUTOR', isLocalMode);\n}\n\n/**\n * Check if author is a first-time contributor (to this repo or GitHub)\n */\nexport function isFirstTimer(\n  authorAssociation: string | undefined,\n  isLocalMode: boolean = false\n): boolean {\n  if (isLocalMode) return false; // In local mode, not a first-timer\n  const assoc = authorAssociation?.toUpperCase();\n  return assoc === 'FIRST_TIME_CONTRIBUTOR' || assoc === 'FIRST_TIMER';\n}\n\n/**\n * Create permission helper functions bound to a specific author association\n * This is used to inject functions into JavaScript execution contexts\n *\n * @param authorAssociation - The author's association from PR data\n * @param isLocalMode - Whether running in local/CLI mode\n */\nexport function createPermissionHelpers(\n  authorAssociation: string | undefined,\n  isLocalMode: boolean = false\n) {\n  return {\n    hasMinPermission: (minPermission: AuthorAssociation) =>\n      hasMinPermission(authorAssociation, minPermission, isLocalMode),\n    isOwner: () => isOwner(authorAssociation, isLocalMode),\n    isMember: () => isMember(authorAssociation, isLocalMode),\n    isCollaborator: () => isCollaborator(authorAssociation, isLocalMode),\n    isContributor: () => isContributor(authorAssociation, isLocalMode),\n    isFirstTimer: () => isFirstTimer(authorAssociation, isLocalMode),\n  };\n}\n\n/**\n * Determine if we're running in local mode (not GitHub Actions)\n */\nexport function detectLocalMode(): boolean {\n  return !process.env.GITHUB_ACTIONS;\n}\n\n/**\n * Resolve the most relevant GitHub author association from an event context.\n * Prefers commenter association for issue_comment events, then issue/PR author,\n * and finally falls back to the provided default association.\n */\nexport function resolveAssociationFromEvent(\n  eventContext: any | undefined,\n  fallback?: string\n): string | undefined {\n  try {\n    const ec = eventContext || {};\n    return (\n      ec?.comment?.author_association ||\n      ec?.issue?.author_association ||\n      ec?.pull_request?.author_association ||\n      fallback\n    );\n  } catch {\n    return fallback;\n  }\n}\n","import fs from 'fs/promises';\nimport path from 'path';\nimport { MemoryConfig } from './types/config';\nimport { logger } from './logger';\n\n/**\n * Memory store for persistent key-value storage across checks\n * Supports namespaces for isolation and both in-memory and file-based persistence\n */\nexport class MemoryStore {\n  private static instance: MemoryStore;\n  private data: Map<string, Map<string, unknown>>; // namespace -> key -> value\n  private config: MemoryConfig;\n  private initialized = false;\n\n  private constructor(config?: MemoryConfig) {\n    this.data = new Map();\n    this.config = this.normalizeConfig(config);\n  }\n\n  /**\n   * Get singleton instance\n   */\n  static getInstance(config?: MemoryConfig): MemoryStore {\n    if (!MemoryStore.instance) {\n      MemoryStore.instance = new MemoryStore(config);\n    } else if (config && !MemoryStore.instance.initialized) {\n      // Update config if not yet initialized\n      MemoryStore.instance.config = MemoryStore.instance.normalizeConfig(config);\n    }\n    return MemoryStore.instance;\n  }\n\n  /**\n   * Reset singleton instance (for testing)\n   */\n  static resetInstance(): void {\n    MemoryStore.instance = undefined!;\n  }\n\n  /**\n   * Initialize memory store (load from file if configured)\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      return;\n    }\n\n    // Auto-load if file storage is configured\n    if (this.config.storage === 'file' && this.config.auto_load && this.config.file) {\n      try {\n        await this.load();\n        logger.debug(`Memory store loaded from ${this.config.file}`);\n      } catch (error) {\n        // If file doesn't exist, that's ok - we'll create it on first save\n        if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {\n          logger.warn(\n            `Failed to load memory store from ${this.config.file}: ${\n              error instanceof Error ? error.message : 'Unknown error'\n            }`\n          );\n        }\n      }\n    }\n\n    this.initialized = true;\n  }\n\n  /**\n   * Normalize and apply defaults to config\n   */\n  private normalizeConfig(config?: MemoryConfig): MemoryConfig {\n    const storage = config?.storage || 'memory';\n    return {\n      storage,\n      format: config?.format || 'json',\n      file: config?.file,\n      namespace: config?.namespace || 'default',\n      auto_load: config?.auto_load !== false,\n      auto_save: config?.auto_save !== false,\n    };\n  }\n\n  /**\n   * Get the default namespace\n   */\n  getDefaultNamespace(): string {\n    return this.config.namespace || 'default';\n  }\n\n  /**\n   * Get a value from memory\n   */\n  get(key: string, namespace?: string): unknown {\n    const ns = namespace || this.getDefaultNamespace();\n    const nsData = this.data.get(ns);\n    return nsData?.get(key);\n  }\n\n  /**\n   * Check if a key exists in memory\n   */\n  has(key: string, namespace?: string): boolean {\n    const ns = namespace || this.getDefaultNamespace();\n    const nsData = this.data.get(ns);\n    return nsData?.has(key) || false;\n  }\n\n  /**\n   * Set a value in memory (override existing)\n   */\n  async set(key: string, value: unknown, namespace?: string): Promise<void> {\n    const ns = namespace || this.getDefaultNamespace();\n\n    // Ensure namespace exists\n    if (!this.data.has(ns)) {\n      this.data.set(ns, new Map());\n    }\n\n    const nsData = this.data.get(ns)!;\n    nsData.set(key, value);\n\n    try {\n      if (process.env.VISOR_DEBUG === 'true' || process.env.JEST_WORKER_ID !== undefined) {\n        if (ns === 'fact-validation' && (key === 'total_validations' || key === 'all_valid')) {\n          console.log('[MemoryStore] SET ' + ns + '.' + key + ' = ' + JSON.stringify(value));\n        }\n      }\n    } catch {}\n\n    try {\n      if (process.env.VISOR_DEBUG === 'true' || process.env.JEST_WORKER_ID !== undefined) {\n        if (ns === 'fact-validation' && (key === 'total_validations' || key === 'all_valid')) {\n          console.log();\n        }\n      }\n    } catch {}\n\n    // Auto-save if configured\n    if (this.config.storage === 'file' && this.config.auto_save) {\n      await this.save();\n    }\n  }\n\n  /**\n   * Append a value to an array in memory\n   * If key doesn't exist, creates a new array\n   * If key exists but is not an array, converts it to an array\n   */\n  async append(key: string, value: unknown, namespace?: string): Promise<void> {\n    const ns = namespace || this.getDefaultNamespace();\n    const existing = this.get(key, ns);\n\n    let newValue: unknown[];\n    if (existing === undefined) {\n      // Create new array\n      newValue = [value];\n    } else if (Array.isArray(existing)) {\n      // Append to existing array\n      newValue = [...existing, value];\n    } else {\n      // Convert single value to array with both values\n      newValue = [existing, value];\n    }\n\n    await this.set(key, newValue, ns);\n  }\n\n  /**\n   * Increment a numeric value in memory\n   * If key doesn't exist, initializes to 0 before incrementing\n   * If key exists but is not a number, throws an error\n   */\n  async increment(key: string, amount = 1, namespace?: string): Promise<number> {\n    const ns = namespace || this.getDefaultNamespace();\n    const existing = this.get(key, ns);\n\n    let newValue: number;\n    if (existing === undefined || existing === null) {\n      // Initialize to 0 and then increment\n      newValue = amount;\n    } else if (typeof existing === 'number') {\n      // Increment existing number\n      newValue = existing + amount;\n    } else {\n      throw new Error(\n        `Cannot increment non-numeric value at key '${key}' (type: ${typeof existing})`\n      );\n    }\n\n    await this.set(key, newValue, ns);\n    return newValue;\n  }\n\n  /**\n   * Delete a key from memory\n   */\n  async delete(key: string, namespace?: string): Promise<boolean> {\n    const ns = namespace || this.getDefaultNamespace();\n    const nsData = this.data.get(ns);\n\n    if (!nsData) {\n      return false;\n    }\n\n    const deleted = nsData.delete(key);\n\n    // Auto-save if configured\n    if (deleted && this.config.storage === 'file' && this.config.auto_save) {\n      await this.save();\n    }\n\n    return deleted;\n  }\n\n  /**\n   * Clear all keys in a namespace (or all namespaces if none specified)\n   */\n  async clear(namespace?: string): Promise<void> {\n    if (namespace) {\n      // Clear specific namespace\n      this.data.delete(namespace);\n    } else {\n      // Clear all namespaces\n      this.data.clear();\n    }\n\n    // Auto-save if configured\n    if (this.config.storage === 'file' && this.config.auto_save) {\n      await this.save();\n    }\n  }\n\n  /**\n   * List all keys in a namespace\n   */\n  list(namespace?: string): string[] {\n    const ns = namespace || this.getDefaultNamespace();\n    const nsData = this.data.get(ns);\n    return nsData ? Array.from(nsData.keys()) : [];\n  }\n\n  /**\n   * List all namespaces\n   */\n  listNamespaces(): string[] {\n    return Array.from(this.data.keys());\n  }\n\n  /**\n   * Get all data in a namespace\n   */\n  getAll(namespace?: string): Record<string, unknown> {\n    const ns = namespace || this.getDefaultNamespace();\n    const nsData = this.data.get(ns);\n    if (!nsData) {\n      return {};\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const [key, value] of nsData.entries()) {\n      result[key] = value;\n    }\n    return result;\n  }\n\n  /**\n   * Load data from file\n   */\n  async load(): Promise<void> {\n    if (!this.config.file) {\n      throw new Error('No file path configured for memory store');\n    }\n\n    const filePath = path.resolve(process.cwd(), this.config.file);\n    const content = await fs.readFile(filePath, 'utf-8');\n\n    if (this.config.format === 'json') {\n      await this.loadFromJson(content);\n    } else if (this.config.format === 'csv') {\n      await this.loadFromCsv(content);\n    } else {\n      throw new Error(`Unsupported format: ${this.config.format}`);\n    }\n  }\n\n  /**\n   * Save data to file\n   */\n  async save(): Promise<void> {\n    if (!this.config.file) {\n      throw new Error('No file path configured for memory store');\n    }\n\n    const filePath = path.resolve(process.cwd(), this.config.file);\n\n    // Ensure directory exists\n    const dir = path.dirname(filePath);\n    await fs.mkdir(dir, { recursive: true });\n\n    let content: string;\n    if (this.config.format === 'json') {\n      content = this.saveToJson();\n    } else if (this.config.format === 'csv') {\n      content = this.saveToCsv();\n    } else {\n      throw new Error(`Unsupported format: ${this.config.format}`);\n    }\n\n    await fs.writeFile(filePath, content, 'utf-8');\n  }\n\n  /**\n   * Load data from JSON format\n   */\n  private async loadFromJson(content: string): Promise<void> {\n    const data = JSON.parse(content);\n\n    // Clear existing data\n    this.data.clear();\n\n    // Load namespaces\n    for (const [namespace, nsData] of Object.entries(data)) {\n      if (typeof nsData === 'object' && nsData !== null && !Array.isArray(nsData)) {\n        const nsMap = new Map<string, unknown>();\n        for (const [key, value] of Object.entries(nsData)) {\n          nsMap.set(key, value);\n        }\n        this.data.set(namespace, nsMap);\n      }\n    }\n  }\n\n  /**\n   * Save data to JSON format\n   */\n  private saveToJson(): string {\n    const result: Record<string, Record<string, unknown>> = {};\n\n    for (const [namespace, nsData] of this.data.entries()) {\n      const nsObj: Record<string, unknown> = {};\n      for (const [key, value] of nsData.entries()) {\n        nsObj[key] = value;\n      }\n      result[namespace] = nsObj;\n    }\n\n    return JSON.stringify(result, null, 2);\n  }\n\n  /**\n   * Load data from CSV format\n   * CSV format: namespace,key,value,type\n   */\n  private async loadFromCsv(content: string): Promise<void> {\n    const lines = content.split('\\n').filter(line => line.trim());\n\n    // Skip header if present\n    let startIndex = 0;\n    if (lines[0]?.startsWith('namespace,')) {\n      startIndex = 1;\n    }\n\n    // Clear existing data\n    this.data.clear();\n\n    // Track arrays (keys that have multiple values)\n    const arrays = new Map<string, Map<string, unknown[]>>(); // namespace -> key -> values[]\n\n    for (let i = startIndex; i < lines.length; i++) {\n      const line = lines[i];\n      const parts = this.parseCsvLine(line);\n\n      if (parts.length < 3) {\n        logger.warn(`Invalid CSV line ${i + 1}: ${line}`);\n        continue;\n      }\n\n      const [namespace, key, valueStr, typeStr] = parts;\n      const value = this.parseCsvValue(valueStr, typeStr);\n\n      // Ensure namespace exists in data\n      if (!this.data.has(namespace)) {\n        this.data.set(namespace, new Map());\n        arrays.set(namespace, new Map());\n      }\n\n      const nsData = this.data.get(namespace)!;\n      const nsArrays = arrays.get(namespace)!;\n\n      // Check if this is a duplicate key (array)\n      if (nsData.has(key)) {\n        // Convert to array if not already\n        if (!nsArrays.has(key)) {\n          const existingValue = nsData.get(key);\n          nsArrays.set(key, [existingValue]);\n        }\n        nsArrays.get(key)!.push(value);\n        nsData.set(key, nsArrays.get(key)!);\n      } else {\n        // First occurrence\n        nsData.set(key, value);\n      }\n    }\n  }\n\n  /**\n   * Save data to CSV format\n   */\n  private saveToCsv(): string {\n    const lines: string[] = ['namespace,key,value,type'];\n\n    for (const [namespace, nsData] of this.data.entries()) {\n      for (const [key, value] of nsData.entries()) {\n        if (Array.isArray(value)) {\n          // Multiple rows for arrays\n          for (const item of value) {\n            lines.push(this.formatCsvLine(namespace, key, item));\n          }\n        } else {\n          // Single row\n          lines.push(this.formatCsvLine(namespace, key, value));\n        }\n      }\n    }\n\n    return lines.join('\\n') + '\\n';\n  }\n\n  /**\n   * Parse a CSV line, handling quoted values with commas\n   */\n  private parseCsvLine(line: string): string[] {\n    const parts: string[] = [];\n    let current = '';\n    let inQuotes = false;\n\n    for (let i = 0; i < line.length; i++) {\n      const char = line[i];\n\n      if (char === '\"') {\n        if (inQuotes && line[i + 1] === '\"') {\n          // Escaped quote\n          current += '\"';\n          i++;\n        } else {\n          // Toggle quotes\n          inQuotes = !inQuotes;\n        }\n      } else if (char === ',' && !inQuotes) {\n        // End of field\n        parts.push(current);\n        current = '';\n      } else {\n        current += char;\n      }\n    }\n\n    // Add last field\n    parts.push(current);\n\n    return parts;\n  }\n\n  /**\n   * Format a CSV line with proper escaping\n   */\n  private formatCsvLine(namespace: string, key: string, value: unknown): string {\n    const type = this.getValueType(value);\n    const valueStr = this.formatCsvValue(value);\n\n    return `${this.escapeCsv(namespace)},${this.escapeCsv(key)},${valueStr},${type}`;\n  }\n\n  /**\n   * Escape a CSV value\n   */\n  private escapeCsv(value: string): string {\n    if (value.includes(',') || value.includes('\"') || value.includes('\\n')) {\n      return `\"${value.replace(/\"/g, '\"\"')}\"`;\n    }\n    return value;\n  }\n\n  /**\n   * Format a value for CSV storage\n   */\n  private formatCsvValue(value: unknown): string {\n    if (value === null) {\n      return '\"\"';\n    }\n    if (value === undefined) {\n      return '\"\"';\n    }\n    if (typeof value === 'string') {\n      return this.escapeCsv(value);\n    }\n    if (typeof value === 'number' || typeof value === 'boolean') {\n      return this.escapeCsv(String(value));\n    }\n    // Objects and arrays are serialized as JSON\n    return this.escapeCsv(JSON.stringify(value));\n  }\n\n  /**\n   * Parse a CSV value based on its type\n   */\n  private parseCsvValue(valueStr: string, typeStr?: string): unknown {\n    if (!typeStr || typeStr === 'string') {\n      return valueStr;\n    }\n    if (typeStr === 'number') {\n      return Number(valueStr);\n    }\n    if (typeStr === 'boolean') {\n      return valueStr === 'true';\n    }\n    if (typeStr === 'object' || typeStr === 'array') {\n      try {\n        return JSON.parse(valueStr);\n      } catch {\n        return valueStr;\n      }\n    }\n    return valueStr;\n  }\n\n  /**\n   * Get the type of a value for CSV storage\n   */\n  private getValueType(value: unknown): string {\n    if (value === null || value === undefined) {\n      return 'string';\n    }\n    if (typeof value === 'number') {\n      return 'number';\n    }\n    if (typeof value === 'boolean') {\n      return 'boolean';\n    }\n    if (Array.isArray(value)) {\n      return 'array';\n    }\n    if (typeof value === 'object') {\n      return 'object';\n    }\n    return 'string';\n  }\n\n  /**\n   * Get the current configuration\n   */\n  getConfig(): MemoryConfig {\n    return { ...this.config };\n  }\n}\n","import { Liquid, TagToken, Context, TopLevelToken, Tag, Value, Emitter } from 'liquidjs';\nimport { AsyncLocalStorage } from 'async_hooks';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport {\n  hasMinPermission,\n  isOwner,\n  isMember,\n  isCollaborator,\n  isContributor,\n  isFirstTimer,\n  detectLocalMode,\n} from './utils/author-permissions';\nimport { MemoryStore } from './memory-store';\n\n/**\n * Sanitize label strings to only allow [A-Za-z0-9:/\\- ] characters (including spaces and hyphens)\n * @param value - Label value to sanitize\n * @returns Sanitized label string\n */\nexport function sanitizeLabel(value: unknown): string {\n  if (value == null) return '';\n  const s = String(value);\n  // Keep only alphanumerics, colon, slash, hyphen, and space; collapse repeated slashes and trim\n  return s\n    .replace(/[^A-Za-z0-9:\\/\\- ]/g, '')\n    .replace(/\\/{2,}/g, '/')\n    .trim();\n}\n\n/**\n * Sanitize an array of labels\n * @param labels - Array of label values\n * @returns Array of sanitized, non-empty label strings\n */\nexport function sanitizeLabelList(labels: unknown): string[] {\n  if (!Array.isArray(labels)) return [];\n  return (labels as unknown[]).map(v => sanitizeLabel(v)).filter(s => s.length > 0);\n}\n\n/**\n * Custom ReadFile tag for Liquid templates\n * Usage: {% readfile \"path/to/file.txt\" %}\n * or with variable: {% readfile filename %}\n */\nexport class ReadFileTag extends Tag {\n  private filepath: Value;\n\n  constructor(token: TagToken, remainTokens: TopLevelToken[], liquid: Liquid) {\n    super(token, remainTokens, liquid);\n    this.filepath = new Value(token.args, liquid);\n  }\n\n  *render(ctx: Context, emitter: Emitter): Generator<unknown, void, unknown> {\n    const filePath = yield this.filepath.value(ctx, false);\n\n    // Validate the path\n    if (!filePath || typeof filePath !== 'string') {\n      emitter.write('[Error: Invalid file path]');\n      return;\n    }\n\n    // Security: Resolve path relative to project root to prevent directory traversal\n    const projectRoot = process.cwd();\n    const resolvedPath = path.resolve(projectRoot, filePath.toString());\n\n    // Ensure the resolved path is within the project directory\n    if (!resolvedPath.startsWith(projectRoot)) {\n      emitter.write('[Error: File path escapes project directory]');\n      return;\n    }\n\n    // Read the file content\n    try {\n      const content = yield fs.readFile(resolvedPath, 'utf-8');\n      emitter.write(content);\n    } catch (error) {\n      // Handle file read errors gracefully\n      const errorMessage =\n        error instanceof Error\n          ? error.message\n          : (error as NodeJS.ErrnoException)?.code || 'Unknown error';\n      emitter.write(`[Error reading file: ${errorMessage}]`);\n    }\n  }\n}\n\n// Async-local permissions context for filters (per-render)\nconst permissionsALS = new AsyncLocalStorage<{ authorAssociation?: string }>();\n\nexport async function withPermissionsContext<T>(\n  ctx: { authorAssociation?: string },\n  fn: () => Promise<T>\n): Promise<T> {\n  return await permissionsALS.run(ctx, fn as any);\n}\n\n/**\n * Configure a Liquid instance with custom extensions\n */\nexport function configureLiquidWithExtensions(liquid: Liquid): void {\n  // Register the readfile tag\n  liquid.registerTag('readfile', ReadFileTag);\n\n  // Register parse_json filter to parse JSON strings into objects\n  liquid.registerFilter('parse_json', (value: string) => {\n    if (typeof value !== 'string') {\n      return value;\n    }\n    try {\n      return JSON.parse(value);\n    } catch {\n      // Return original value if parsing fails\n      return value;\n    }\n  });\n\n  // Register to_json filter as alias for json (for consistency)\n  liquid.registerFilter('to_json', (value: unknown) => {\n    try {\n      return JSON.stringify(value);\n    } catch {\n      return '[Error: Unable to serialize to JSON]';\n    }\n  });\n\n  // Sanitize a label to allowed characters only: [A-Za-z0-9:/]\n  liquid.registerFilter('safe_label', (value: unknown) => sanitizeLabel(value));\n\n  // Sanitize an array of labels\n  liquid.registerFilter('safe_label_list', (value: unknown) => sanitizeLabelList(value));\n\n  // Convert literal escape sequences (e.g., \"\\n\") into actual newlines\n  liquid.registerFilter('unescape_newlines', (value: unknown) => {\n    if (value == null) return '';\n    const s = String(value);\n    return s.replace(/\\\\n/g, '\\n').replace(/\\\\r/g, '\\r').replace(/\\\\t/g, '\\t');\n  });\n\n  // Register author permission filters (from main)\n  // These filters check the author's permission level; detect local mode for tests\n  const isLocal = detectLocalMode();\n\n  const resolveAssoc = (val: unknown): string | undefined => {\n    if (typeof val === 'string' && val.length > 0) return val;\n    const store = permissionsALS.getStore();\n    return store?.authorAssociation;\n  };\n\n  liquid.registerFilter('has_min_permission', (authorAssociation: unknown, level: string) => {\n    return hasMinPermission(resolveAssoc(authorAssociation), level as any, isLocal);\n  });\n\n  liquid.registerFilter('is_owner', (authorAssociation: unknown) => {\n    return isOwner(resolveAssoc(authorAssociation), isLocal);\n  });\n\n  liquid.registerFilter('is_member', (authorAssociation: unknown) => {\n    return isMember(resolveAssoc(authorAssociation), isLocal);\n  });\n\n  liquid.registerFilter('is_collaborator', (authorAssociation: unknown) => {\n    return isCollaborator(resolveAssoc(authorAssociation), isLocal);\n  });\n\n  liquid.registerFilter('is_contributor', (authorAssociation: unknown) => {\n    return isContributor(resolveAssoc(authorAssociation), isLocal);\n  });\n\n  liquid.registerFilter('is_first_timer', (authorAssociation: unknown) => {\n    return isFirstTimer(resolveAssoc(authorAssociation), isLocal);\n  });\n\n  // Register memory filters for accessing memory store\n  const memoryStore = MemoryStore.getInstance();\n\n  liquid.registerFilter('memory_get', (key: string, namespace?: string) => {\n    if (typeof key !== 'string') {\n      return undefined;\n    }\n    return memoryStore.get(key, namespace);\n  });\n\n  liquid.registerFilter('memory_has', (key: string, namespace?: string) => {\n    if (typeof key !== 'string') {\n      return false;\n    }\n    const has = memoryStore.has(key, namespace);\n    try {\n      if (process.env.VISOR_DEBUG === 'true' && key === 'fact_validation_issues') {\n        console.error(\n          `[liquid] memory_has('${key}', ns='${namespace || memoryStore.getDefaultNamespace()}') => ${String(\n            has\n          )}`\n        );\n      }\n    } catch {}\n    return has;\n  });\n\n  liquid.registerFilter('memory_list', (namespace?: string) => {\n    return memoryStore.list(namespace);\n  });\n\n  // Generic helpers to radically simplify templates\n\n  // get: safe nested access using dot-path (e.g., obj | get: 'a.b.c')\n  liquid.registerFilter('get', (obj: any, pathExpr: unknown) => {\n    if (obj == null) return undefined;\n    const path = typeof pathExpr === 'string' ? pathExpr : String(pathExpr || '');\n    if (!path) return obj;\n    const parts = path.split('.');\n    let cur: any = obj;\n    for (const p of parts) {\n      if (cur == null) return undefined;\n      cur = cur[p as keyof typeof cur];\n    }\n    return cur;\n  });\n\n  // not_empty: true when value is a non-empty array/string/object with keys\n  liquid.registerFilter('not_empty', (v: unknown) => {\n    if (Array.isArray(v)) return v.length > 0;\n    if (typeof v === 'string') return v.length > 0;\n    if (v && typeof v === 'object') return Object.keys(v as object).length > 0;\n    return false;\n  });\n\n  // coalesce: pick first argument (value or candidates) that is a non-empty array/object/string\n  // Usage: a | coalesce: b, c, d\n  liquid.registerFilter('coalesce', (first: unknown, ...rest: unknown[]) => {\n    const all = [first, ...rest];\n    for (const v of all) {\n      if (Array.isArray(v) && v.length > 0) return v;\n      if (typeof v === 'string' && v.length > 0) return v;\n      if (v && typeof v === 'object' && Object.keys(v as object).length > 0) return v;\n    }\n    return Array.isArray(first) ? [] : (first ?? undefined);\n  });\n\n  // where_exp: generic expression-based filter (Shopify-style)\n  // Usage: array | where_exp: 'i', 'i.is_valid != true and i.confidence != \"high\"'\n  liquid.registerFilter('where_exp', (items: unknown, varName: string, expr: string) => {\n    const arr = Array.isArray(items) ? (items as any[]) : [];\n    const name = typeof varName === 'string' && varName.trim() ? varName.trim() : 'i';\n    const body = String(expr || '');\n    try {\n      // Build a tiny predicate; expose only item, idx, arr\n\n      const fn = new Function(\n        name,\n        'idx',\n        'arr',\n        `try { return (${body}); } catch { return false; }`\n      );\n      const out: any[] = [];\n      for (let idx = 0; idx < arr.length; idx++) {\n        const i = arr[idx];\n        let ok = false;\n        try {\n          ok = !!(fn as any)(i, idx, arr);\n        } catch {\n          ok = false;\n        }\n        if (ok) out.push(i);\n      }\n      return out;\n    } catch {\n      return [];\n    }\n  });\n\n  // Removed: merge_sort_by filter (unused)\n}\n\n/**\n * Create a new Liquid instance with custom extensions\n */\nexport function createExtendedLiquid(options: Record<string, unknown> = {}): Liquid {\n  const liquid = new Liquid({\n    cache: false,\n    strictFilters: false,\n    strictVariables: false,\n    ...options,\n  });\n\n  configureLiquidWithExtensions(liquid);\n  return liquid;\n}\n","/**\n * Lazy-loading wrapper for OpenTelemetry API.\n * Returns no-op implementations if OpenTelemetry is not installed.\n * Uses hardcoded module name for security - no dynamic module loading.\n */\n\nlet otelApi: any = null;\nlet otelApiAttempted = false;\n\n// Hardcoded allowed module name to prevent module loading attacks\nconst OTEL_API_MODULE = '@opentelemetry/api';\n\nfunction getOtelApi() {\n  if (otelApiAttempted) return otelApi;\n  otelApiAttempted = true;\n\n  try {\n    // Security: Only load the specific @opentelemetry/api module\n    // Use dynamic require to prevent bundlers from including this module\n\n    otelApi = (function (name: string) {\n      return require(name);\n    })(OTEL_API_MODULE);\n  } catch {\n    // OpenTelemetry not installed - provide no-op implementations\n    otelApi = null;\n  }\n\n  return otelApi;\n}\n\n// Export lazy-loaded trace API\nexport const trace = {\n  getTracer(name: string, version?: string) {\n    const api = getOtelApi();\n    if (!api) return createNoOpTracer();\n    return api.trace.getTracer(name, version);\n  },\n  getSpan(context: any) {\n    const api = getOtelApi();\n    if (!api) return undefined;\n    return api.trace.getSpan(context);\n  },\n  getActiveSpan() {\n    const api = getOtelApi();\n    if (!api) return undefined;\n    return api.trace.getActiveSpan();\n  },\n};\n\n// Export lazy-loaded context API\nexport const context = {\n  active() {\n    const api = getOtelApi();\n    if (!api) return {};\n    return api.context.active();\n  },\n  with(context: any, fn: Function, thisArg?: any, ...args: any[]) {\n    const api = getOtelApi();\n    if (!api) return fn.call(thisArg, ...args);\n    return api.context.with(context, fn, thisArg, ...args);\n  },\n};\n\n// Export lazy-loaded metrics API\nexport const metrics = {\n  getMeter(name: string, version?: string) {\n    const api = getOtelApi();\n    if (!api?.metrics) return createNoOpMeter();\n    return api.metrics.getMeter(name, version);\n  },\n};\n\n// Export types and enums\nexport const SpanStatusCode = {\n  get UNSET() {\n    const api = getOtelApi();\n    return api?.SpanStatusCode?.UNSET ?? 0;\n  },\n  get OK() {\n    const api = getOtelApi();\n    return api?.SpanStatusCode?.OK ?? 1;\n  },\n  get ERROR() {\n    const api = getOtelApi();\n    return api?.SpanStatusCode?.ERROR ?? 2;\n  },\n};\n\nexport const SpanKind = {\n  get INTERNAL() {\n    const api = getOtelApi();\n    return api?.SpanKind?.INTERNAL ?? 0;\n  },\n  get SERVER() {\n    const api = getOtelApi();\n    return api?.SpanKind?.SERVER ?? 1;\n  },\n  get CLIENT() {\n    const api = getOtelApi();\n    return api?.SpanKind?.CLIENT ?? 2;\n  },\n  get PRODUCER() {\n    const api = getOtelApi();\n    return api?.SpanKind?.PRODUCER ?? 3;\n  },\n  get CONSUMER() {\n    const api = getOtelApi();\n    return api?.SpanKind?.CONSUMER ?? 4;\n  },\n};\n\n// Export diag API\nexport const diag = {\n  setLogger(logger: any, level?: any) {\n    const api = getOtelApi();\n    if (!api) return;\n    return api.diag.setLogger(logger, level);\n  },\n};\n\n// Lazy-loaded DiagConsoleLogger and DiagLogLevel for consistency\nexport const DiagConsoleLogger = {\n  get() {\n    const api = getOtelApi();\n    return api?.DiagConsoleLogger;\n  },\n};\n\nexport const DiagLogLevel = {\n  get NONE() {\n    const api = getOtelApi();\n    return api?.DiagLogLevel?.NONE ?? 0;\n  },\n  get ERROR() {\n    const api = getOtelApi();\n    return api?.DiagLogLevel?.ERROR ?? 30;\n  },\n  get WARN() {\n    const api = getOtelApi();\n    return api?.DiagLogLevel?.WARN ?? 50;\n  },\n  get INFO() {\n    const api = getOtelApi();\n    return api?.DiagLogLevel?.INFO ?? 60;\n  },\n  get DEBUG() {\n    const api = getOtelApi();\n    return api?.DiagLogLevel?.DEBUG ?? 70;\n  },\n  get VERBOSE() {\n    const api = getOtelApi();\n    return api?.DiagLogLevel?.VERBOSE ?? 80;\n  },\n  get ALL() {\n    const api = getOtelApi();\n    return api?.DiagLogLevel?.ALL ?? 9999;\n  },\n};\n\n// Type exports for TypeScript\nexport type Span = any;\nexport type Attributes = Record<string, any>;\nexport type HrTime = [number, number];\n\n// No-op implementations\nfunction createNoOpTracer() {\n  return {\n    startSpan: () => createNoOpSpan(),\n    // Support both OTel v1 and v2 overloads:\n    // - startActiveSpan(name, callback)\n    // - startActiveSpan(name, options, callback)\n    // - startActiveSpan(name, options, context, callback)\n    startActiveSpan: (name: string, arg2?: any, arg3?: any, arg4?: any) => {\n      const span = createNoOpSpan();\n      let cb: any = undefined;\n      if (typeof arg2 === 'function') cb = arg2;\n      else if (typeof arg3 === 'function') cb = arg3;\n      else if (typeof arg4 === 'function') cb = arg4;\n      if (typeof cb === 'function') {\n        try {\n          return cb(span);\n        } catch {\n          // swallow errors in no-op implementation\n          return undefined;\n        }\n      }\n      // No callback supplied: return a no-op span like the real API would\n      return span;\n    },\n  };\n}\n\nfunction createNoOpSpan() {\n  return {\n    spanContext: () => ({ traceId: '', spanId: '', traceFlags: 0 }),\n    setAttribute: () => {},\n    setAttributes: () => {},\n    addEvent: () => {},\n    setStatus: () => {},\n    updateName: () => {},\n    end: () => {},\n    isRecording: () => false,\n    recordException: () => {},\n  };\n}\n\nfunction createNoOpMeter() {\n  return {\n    createCounter: () => ({ add: () => {} }),\n    createHistogram: () => ({ record: () => {} }),\n    createUpDownCounter: () => ({ add: () => {} }),\n    createObservableGauge: () => {},\n    createObservableCounter: () => {},\n    createObservableUpDownCounter: () => {},\n  };\n}\n","/**\n * Enhanced state capture for OTEL spans to enable interactive debugging.\n *\n * This module provides utilities to capture complete execution state in span\n * attributes, enabling time-travel debugging and full state inspection.\n */\n\nimport { Span } from './lazy-otel';\n\nconst MAX_ATTRIBUTE_LENGTH = 10000; // Truncate large values\nconst MAX_ARRAY_ITEMS = 100; // Limit array size in attributes\n\n/**\n * Safely serialize a value for OTEL span attributes.\n * Handles truncation, circular refs, and type conversions.\n */\nfunction safeSerialize(value: unknown, maxLength = MAX_ATTRIBUTE_LENGTH): string {\n  try {\n    if (value === undefined || value === null) return String(value);\n\n    // Detect circular references\n    const seen = new WeakSet();\n    const json = JSON.stringify(value, (key, val) => {\n      if (typeof val === 'object' && val !== null) {\n        if (seen.has(val)) return '[Circular]';\n        seen.add(val);\n      }\n      // Truncate long strings\n      if (typeof val === 'string' && val.length > maxLength) {\n        return val.substring(0, maxLength) + '...[truncated]';\n      }\n      return val;\n    });\n\n    if (json.length > maxLength) {\n      return json.substring(0, maxLength) + '...[truncated]';\n    }\n    return json;\n  } catch (err) {\n    return `[Error serializing: ${err instanceof Error ? err.message : String(err)}]`;\n  }\n}\n\n/**\n * Capture check input context (Liquid template variables) in span.\n */\nexport function captureCheckInputContext(span: Span, context: Record<string, unknown>): void {\n  try {\n    // Capture key context variables\n    const keys = Object.keys(context);\n    span.setAttribute('visor.check.input.keys', keys.join(','));\n    span.setAttribute('visor.check.input.count', keys.length);\n\n    // Capture full context as JSON (with size limit)\n    span.setAttribute('visor.check.input.context', safeSerialize(context));\n\n    // Capture specific important variables separately for easy querying\n    if (context.pr) {\n      span.setAttribute('visor.check.input.pr', safeSerialize(context.pr, 1000));\n    }\n    if (context.outputs) {\n      span.setAttribute('visor.check.input.outputs', safeSerialize(context.outputs, 5000));\n    }\n    if (context.env) {\n      span.setAttribute('visor.check.input.env_keys', Object.keys(context.env as object).join(','));\n    }\n  } catch (err) {\n    try {\n      span.setAttribute('visor.check.input.error', String(err));\n    } catch {\n      // Ignore if we can't even set the error attribute\n    }\n  }\n}\n\n/**\n * Capture check output in span.\n */\nexport function captureCheckOutput(span: Span, output: unknown): void {\n  try {\n    span.setAttribute('visor.check.output.type', typeof output);\n\n    if (Array.isArray(output)) {\n      span.setAttribute('visor.check.output.length', output.length);\n      // Store first few items for preview\n      const preview = output.slice(0, 10);\n      span.setAttribute('visor.check.output.preview', safeSerialize(preview, 2000));\n    }\n\n    // Full output (truncated if needed)\n    span.setAttribute('visor.check.output', safeSerialize(output));\n  } catch (err) {\n    try {\n      span.setAttribute('visor.check.output.error', String(err));\n    } catch {\n      // Ignore if we can't even set the error attribute\n    }\n  }\n}\n\n/**\n * Capture forEach iteration state.\n */\nexport function captureForEachState(\n  span: Span,\n  items: unknown[],\n  index: number,\n  currentItem: unknown\n): void {\n  try {\n    span.setAttribute('visor.foreach.total', items.length);\n    span.setAttribute('visor.foreach.index', index);\n    span.setAttribute('visor.foreach.current_item', safeSerialize(currentItem, 500));\n\n    // Store all items if not too large\n    if (items.length <= MAX_ARRAY_ITEMS) {\n      span.setAttribute('visor.foreach.items', safeSerialize(items));\n    } else {\n      span.setAttribute(\n        'visor.foreach.items.preview',\n        safeSerialize(items.slice(0, MAX_ARRAY_ITEMS))\n      );\n      span.setAttribute('visor.foreach.items.truncated', true);\n    }\n  } catch (err) {\n    span.setAttribute('visor.foreach.error', String(err));\n  }\n}\n\n/**\n * Capture Liquid template evaluation details.\n */\nexport function captureLiquidEvaluation(\n  span: Span,\n  template: string,\n  context: Record<string, unknown>,\n  result: string\n): void {\n  try {\n    span.setAttribute('visor.liquid.template', template.substring(0, 1000));\n    span.setAttribute('visor.liquid.template.length', template.length);\n    span.setAttribute('visor.liquid.result', result.substring(0, 2000));\n    span.setAttribute('visor.liquid.result.length', result.length);\n    span.setAttribute('visor.liquid.context', safeSerialize(context, 3000));\n  } catch (err) {\n    span.setAttribute('visor.liquid.error', String(err));\n  }\n}\n\n/**\n * Capture JavaScript transform execution.\n */\nexport function captureTransformJS(\n  span: Span,\n  code: string,\n  input: unknown,\n  output: unknown\n): void {\n  try {\n    // Truncate long code while keeping plain string (no JSON quoting)\n    const codePreview = code.length > 2000 ? code.substring(0, 2000) + '...[truncated]' : code;\n    span.setAttribute('visor.transform.code', codePreview);\n    span.setAttribute('visor.transform.code.length', code.length);\n    span.setAttribute('visor.transform.input', safeSerialize(input, 2000));\n    span.setAttribute('visor.transform.output', safeSerialize(output, 2000));\n  } catch (err) {\n    span.setAttribute('visor.transform.error', String(err));\n  }\n}\n\n/**\n * Capture provider request/response summary (safe, no raw AI content).\n */\nexport function captureProviderCall(\n  span: Span,\n  providerType: string,\n  request: { prompt?: string; model?: string; [key: string]: unknown },\n  response: { content?: string; tokens?: number; [key: string]: unknown }\n): void {\n  try {\n    span.setAttribute('visor.provider.type', providerType);\n\n    // Request summary\n    if (request.model) span.setAttribute('visor.provider.request.model', String(request.model));\n    if (request.prompt) {\n      span.setAttribute('visor.provider.request.prompt.length', request.prompt.length);\n      span.setAttribute('visor.provider.request.prompt.preview', request.prompt.substring(0, 500));\n    }\n\n    // Response summary\n    if (response.content) {\n      span.setAttribute('visor.provider.response.length', response.content.length);\n      span.setAttribute('visor.provider.response.preview', response.content.substring(0, 500));\n    }\n    if (response.tokens) {\n      span.setAttribute('visor.provider.response.tokens', response.tokens);\n    }\n  } catch (err) {\n    span.setAttribute('visor.provider.error', String(err));\n  }\n}\n\n/**\n * Capture conditional evaluation (if/fail_if).\n */\nexport function captureConditionalEvaluation(\n  span: Span,\n  condition: string,\n  result: boolean,\n  context: Record<string, unknown>\n): void {\n  try {\n    span.setAttribute('visor.condition.expression', condition.substring(0, 500));\n    span.setAttribute('visor.condition.result', result);\n    span.setAttribute('visor.condition.context', safeSerialize(context, 2000));\n  } catch (err) {\n    span.setAttribute('visor.condition.error', String(err));\n  }\n}\n\n/**\n * Capture routing decision (retry/goto/run).\n */\nexport function captureRoutingDecision(\n  span: Span,\n  action: 'retry' | 'goto' | 'run',\n  target: string | string[],\n  condition?: string\n): void {\n  try {\n    span.setAttribute('visor.routing.action', action);\n    span.setAttribute('visor.routing.target', Array.isArray(target) ? target.join(',') : target);\n    if (condition) {\n      span.setAttribute('visor.routing.condition', condition.substring(0, 500));\n    }\n  } catch (err) {\n    span.setAttribute('visor.routing.error', String(err));\n  }\n}\n\n/**\n * Create a snapshot of the entire execution state at a point in time.\n * This is added as a span event for time-travel debugging.\n */\nexport function captureStateSnapshot(\n  span: Span,\n  checkId: string,\n  outputs: Record<string, unknown>,\n  memory: Record<string, unknown>\n): void {\n  try {\n    span.addEvent('state.snapshot', {\n      'visor.snapshot.check_id': checkId,\n      'visor.snapshot.outputs': safeSerialize(outputs, 5000),\n      'visor.snapshot.memory': safeSerialize(memory, 5000),\n      'visor.snapshot.timestamp': new Date().toISOString(),\n    });\n  } catch (err) {\n    span.setAttribute('visor.snapshot.error', String(err));\n  }\n}\n","import * as fs from 'fs';\nimport * as path from 'path';\n\nlet CURRENT_FILE: string | null = null;\nlet dirReady = false;\nlet writeChain: Promise<void> = Promise.resolve();\nfunction resolveTargetPath(outDir: string): string {\n  if (process.env.VISOR_FALLBACK_TRACE_FILE) {\n    CURRENT_FILE = process.env.VISOR_FALLBACK_TRACE_FILE;\n    return CURRENT_FILE;\n  }\n  if (CURRENT_FILE) return CURRENT_FILE;\n  const ts = new Date().toISOString().replace(/[:.]/g, '-');\n  CURRENT_FILE = path.join(outDir, `${ts}.ndjson`);\n  return CURRENT_FILE;\n}\n\nfunction isEnabled(): boolean {\n  // Enable when CLI set a fallback file (serverless mode), or when explicit file sink is enabled\n  if (process.env.VISOR_FALLBACK_TRACE_FILE) return true;\n  return (\n    process.env.VISOR_TELEMETRY_ENABLED === 'true' &&\n    (process.env.VISOR_TELEMETRY_SINK || 'file') === 'file'\n  );\n}\n\nfunction appendAsync(outDir: string, line: string): void {\n  writeChain = writeChain\n    .then(async () => {\n      if (!dirReady) {\n        try {\n          await fs.promises.mkdir(outDir, { recursive: true });\n        } catch {}\n        dirReady = true;\n      }\n      const target = resolveTargetPath(outDir);\n      await fs.promises.appendFile(target, line, 'utf8');\n    })\n    .catch(() => {});\n}\n\nexport async function flushNdjson(): Promise<void> {\n  try {\n    await writeChain;\n  } catch {}\n}\n\nexport function emitNdjsonFallback(name: string, attrs: Record<string, unknown>): void {\n  try {\n    if (!isEnabled()) return;\n    const outDir = process.env.VISOR_TRACE_DIR || path.join(process.cwd(), 'output', 'traces');\n    const line = JSON.stringify({ name, attributes: attrs }) + '\\n';\n    appendAsync(outDir, line);\n  } catch {\n    // ignore\n  }\n}\n\nexport function emitNdjsonSpanWithEvents(\n  name: string,\n  attrs: Record<string, unknown>,\n  events: Array<{ name: string; attrs?: Record<string, unknown> }>\n): void {\n  try {\n    if (!isEnabled()) return;\n    const outDir = process.env.VISOR_TRACE_DIR || path.join(process.cwd(), 'output', 'traces');\n    const line = JSON.stringify({ name, attributes: attrs, events }) + '\\n';\n    appendAsync(outDir, line);\n  } catch {\n    // ignore\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { AIReviewService, AIReviewConfig } from '../ai-review-service';\nimport { EnvironmentResolver } from '../utils/env-resolver';\nimport { IssueFilter } from '../issue-filter';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { trace, context as otContext } from '../telemetry/lazy-otel';\nimport {\n  captureCheckInputContext,\n  captureCheckOutput,\n  captureProviderCall,\n} from '../telemetry/state-capture';\n\n/**\n * AI-powered check provider using probe agent\n */\nexport class AICheckProvider extends CheckProvider {\n  private aiReviewService: AIReviewService;\n  private liquidEngine: Liquid;\n\n  constructor() {\n    super();\n    this.aiReviewService = new AIReviewService();\n    this.liquidEngine = createExtendedLiquid();\n  }\n\n  getName(): string {\n    return 'ai';\n  }\n\n  getDescription(): string {\n    return 'AI-powered code review using Google Gemini, Anthropic Claude, OpenAI GPT, or AWS Bedrock models';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'ai'\n    if (cfg.type !== 'ai') {\n      return false;\n    }\n\n    // Check for prompt or focus\n    const prompt = cfg.prompt || cfg.focus;\n    if (typeof prompt !== 'string') {\n      return false;\n    }\n\n    // Focus is now config-driven - any string value is acceptable\n    // No validation needed here as focus is just a hint to the AI\n\n    // Validate AI provider config if present\n    if (cfg.ai) {\n      if (\n        cfg.ai.provider &&\n        !['google', 'anthropic', 'openai', 'bedrock', 'mock'].includes(cfg.ai.provider as string)\n      ) {\n        return false;\n      }\n\n      // Validate mcpServers if present\n      if (cfg.ai.mcpServers) {\n        if (!this.validateMcpServers(cfg.ai.mcpServers)) {\n          return false;\n        }\n      }\n    }\n\n    // Validate check-level MCP servers if present\n    const checkLevelMcpServers = (cfg as CheckProviderConfig & { ai_mcp_servers?: unknown })\n      .ai_mcp_servers;\n    if (checkLevelMcpServers) {\n      if (!this.validateMcpServers(checkLevelMcpServers)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Validate MCP servers configuration\n   */\n  private validateMcpServers(mcpServers: unknown): boolean {\n    if (typeof mcpServers !== 'object' || mcpServers === null) {\n      return false;\n    }\n\n    for (const serverConfig of Object.values(mcpServers)) {\n      if (!serverConfig || typeof serverConfig !== 'object') {\n        return false;\n      }\n      const config = serverConfig as { command?: unknown; args?: unknown };\n      if (typeof config.command !== 'string') {\n        return false;\n      }\n      if (config.args !== undefined && !Array.isArray(config.args)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Group files by their file extension for template context\n   */\n  private groupFilesByExtension(\n    files: import('../pr-analyzer').PRFile[]\n  ): Record<string, import('../pr-analyzer').PRFile[]> {\n    const grouped: Record<string, import('../pr-analyzer').PRFile[]> = {};\n\n    files.forEach(file => {\n      const parts = file.filename.split('.');\n      const ext = parts.length > 1 ? parts.pop()?.toLowerCase() || 'noext' : 'noext';\n      if (!grouped[ext]) {\n        grouped[ext] = [];\n      }\n      grouped[ext].push(file);\n    });\n\n    return grouped;\n  }\n\n  /**\n   * Process prompt configuration to resolve final prompt string\n   */\n  private async processPrompt(\n    promptConfig: string,\n    prInfo: PRInfo,\n    eventContext?: Record<string, unknown>,\n    dependencyResults?: Map<string, ReviewSummary>,\n    outputHistory?: Map<string, unknown[]>\n  ): Promise<string> {\n    let promptContent: string;\n\n    // Auto-detect if it's a file path or inline content\n    if (await this.isFilePath(promptConfig)) {\n      promptContent = await this.loadPromptFromFile(promptConfig);\n    } else {\n      promptContent = promptConfig;\n    }\n\n    // Process Liquid templates in the prompt\n    return await this.renderPromptTemplate(\n      promptContent,\n      prInfo,\n      eventContext,\n      dependencyResults,\n      outputHistory\n    );\n  }\n\n  /**\n   * Detect if a string is likely a file path and if the file exists\n   */\n  private async isFilePath(str: string): Promise<boolean> {\n    // Quick checks to exclude obvious non-file-path content\n    if (!str || str.trim() !== str || str.length > 512) {\n      return false;\n    }\n\n    // Exclude strings that are clearly content (contain common content indicators)\n    // But be more careful with paths that might contain common words as directory names\n    if (\n      /\\s{2,}/.test(str) || // Multiple consecutive spaces\n      /\\n/.test(str) || // Contains newlines\n      /^(please|analyze|review|check|find|identify|look|search)/i.test(str.trim()) || // Starts with command words\n      str.split(' ').length > 8 // Too many words for a typical file path\n    ) {\n      return false;\n    }\n\n    // For strings with path separators, be more lenient about common words\n    // as they might be legitimate directory names\n    if (!/[\\/\\\\]/.test(str)) {\n      // Only apply strict English word filter to non-path strings\n      if (/\\b(the|and|or|but|for|with|by|from|in|on|at|as)\\b/i.test(str)) {\n        return false;\n      }\n    }\n\n    // Positive indicators for file paths\n    const hasFileExtension = /\\.[a-zA-Z0-9]{1,10}$/i.test(str);\n    const hasPathSeparators = /[\\/\\\\]/.test(str);\n    const isRelativePath = /^\\.{1,2}\\//.test(str);\n    const isAbsolutePath = path.isAbsolute(str);\n    const hasTypicalFileChars = /^[a-zA-Z0-9._\\-\\/\\\\:~]+$/.test(str);\n\n    // Must have at least one strong indicator\n    if (!(hasFileExtension || isRelativePath || isAbsolutePath || hasPathSeparators)) {\n      return false;\n    }\n\n    // Must contain only typical file path characters\n    if (!hasTypicalFileChars) {\n      return false;\n    }\n\n    // Additional validation for suspected file paths\n    try {\n      // Try to resolve and check if file exists\n      let resolvedPath: string;\n\n      if (path.isAbsolute(str)) {\n        resolvedPath = path.normalize(str);\n      } else {\n        // Resolve relative to current working directory\n        resolvedPath = path.resolve(process.cwd(), str);\n      }\n\n      // Check if file exists\n      const fs = require('fs').promises;\n      try {\n        const stat = await fs.stat(resolvedPath);\n        return stat.isFile();\n      } catch {\n        // File doesn't exist, but might still be a valid file path format\n        // Return true if it has strong file path indicators\n        return hasFileExtension && (isRelativePath || isAbsolutePath || hasPathSeparators);\n      }\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Load prompt content from file with security validation\n   */\n  private async loadPromptFromFile(promptPath: string): Promise<string> {\n    // Enforce .liquid file extension for all prompt files\n    if (!promptPath.endsWith('.liquid')) {\n      throw new Error('Prompt file must have .liquid extension');\n    }\n\n    let resolvedPath: string;\n\n    if (path.isAbsolute(promptPath)) {\n      // Absolute path - use as-is\n      resolvedPath = promptPath;\n    } else {\n      // Relative path - resolve relative to current working directory\n      resolvedPath = path.resolve(process.cwd(), promptPath);\n    }\n\n    // Security: For relative paths, ensure they don't escape the current directory\n    if (!path.isAbsolute(promptPath)) {\n      const normalizedPath = path.normalize(resolvedPath);\n      const currentDir = path.resolve(process.cwd());\n      if (!normalizedPath.startsWith(currentDir)) {\n        throw new Error('Invalid prompt file path: path traversal detected');\n      }\n    }\n\n    // Security: Check for obvious path traversal patterns\n    if (promptPath.includes('../..')) {\n      throw new Error('Invalid prompt file path: path traversal detected');\n    }\n\n    try {\n      const promptContent = await fs.readFile(resolvedPath, 'utf-8');\n      return promptContent;\n    } catch (error) {\n      throw new Error(\n        `Failed to load prompt from ${resolvedPath}: ${\n          error instanceof Error ? error.message : 'Unknown error'\n        }`\n      );\n    }\n  }\n\n  /**\n   * Render Liquid template in prompt with comprehensive event context\n   */\n  private async renderPromptTemplate(\n    promptContent: string,\n    prInfo: PRInfo,\n    eventContext?: Record<string, unknown>,\n    dependencyResults?: Map<string, ReviewSummary>,\n    outputHistory?: Map<string, unknown[]>\n  ): Promise<string> {\n    // Build outputs_raw from -raw keys (aggregate parent values)\n    const outputsRaw: Record<string, unknown> = {};\n    if (dependencyResults) {\n      for (const [k, v] of dependencyResults.entries()) {\n        if (typeof k !== 'string') continue;\n        if (k.endsWith('-raw')) {\n          const name = k.slice(0, -4);\n          const summary = v as ReviewSummary & { output?: unknown };\n          outputsRaw[name] = summary.output !== undefined ? summary.output : summary;\n        }\n      }\n    }\n\n    // Note: We intentionally do NOT expose any special `fact_validation` object\n    // in the template context. Templates should derive everything from\n    // outputs / outputs_history / memory helpers to avoid hidden magic.\n\n    // Create comprehensive template context with PR and event information\n    const templateContext = {\n      // PR Information\n      pr: {\n        number: prInfo.number,\n        title: prInfo.title,\n        body: prInfo.body,\n        author: prInfo.author,\n        baseBranch: prInfo.base,\n        headBranch: prInfo.head,\n        isIncremental: prInfo.isIncremental,\n        filesChanged: prInfo.files?.map(f => f.filename) || [],\n        totalAdditions: prInfo.files?.reduce((sum, f) => sum + f.additions, 0) || 0,\n        totalDeletions: prInfo.files?.reduce((sum, f) => sum + f.deletions, 0) || 0,\n        totalChanges: prInfo.files?.reduce((sum, f) => sum + f.changes, 0) || 0,\n        base: prInfo.base,\n        head: prInfo.head,\n      },\n\n      // File Details\n      files: prInfo.files || [],\n      description: prInfo.body || '',\n\n      // GitHub Event Context\n      event: eventContext\n        ? {\n            name: eventContext.event_name || 'unknown',\n            action: eventContext.action,\n            isPullRequest: !prInfo.isIssue, // Set based on whether this is a PR or an issue\n\n            // Repository Info\n            repository: eventContext.repository\n              ? {\n                  owner: (eventContext.repository as { owner?: { login?: string } })?.owner?.login,\n                  name: (eventContext.repository as { name?: string })?.name,\n                  fullName: eventContext.repository\n                    ? `${(eventContext.repository as { owner?: { login?: string } })?.owner?.login}/${(eventContext.repository as { name?: string })?.name}`\n                    : undefined,\n                }\n              : undefined,\n\n            // Comment Data (for comment events)\n            comment: eventContext.comment\n              ? {\n                  body: (eventContext.comment as { body?: string })?.body,\n                  author: (eventContext.comment as { user?: { login?: string } })?.user?.login,\n                }\n              : undefined,\n\n            // Issue Data (for issue events)\n            issue: eventContext.issue\n              ? {\n                  number: (eventContext.issue as { number?: number })?.number,\n                  title: (eventContext.issue as { title?: string })?.title,\n                  body: (eventContext.issue as { body?: string })?.body,\n                  state: (eventContext.issue as { state?: string })?.state,\n                  author: (eventContext.issue as { user?: { login?: string } })?.user?.login,\n                  labels: (eventContext.issue as { labels?: unknown[] })?.labels || [],\n                  assignees:\n                    (\n                      eventContext as { issue?: { assignees?: Array<{ login: string }> } }\n                    )?.issue?.assignees?.map(a => a.login) || [],\n                  createdAt: (eventContext.issue as { created_at?: string })?.created_at,\n                  updatedAt: (eventContext.issue as { updated_at?: string })?.updated_at,\n                  isPullRequest: !!(eventContext.issue as { pull_request?: unknown })?.pull_request,\n                }\n              : undefined,\n\n            // Pull Request Event Data\n            pullRequest: eventContext.pull_request\n              ? {\n                  number: (eventContext.pull_request as { number?: number })?.number,\n                  state: (eventContext.pull_request as { state?: string })?.state,\n                  draft: (eventContext.pull_request as { draft?: boolean })?.draft,\n                  headSha: (eventContext.pull_request as { head?: { sha?: string } })?.head?.sha,\n                  headRef: (eventContext.pull_request as { head?: { ref?: string } })?.head?.ref,\n                  baseSha: (eventContext.pull_request as { base?: { sha?: string } })?.base?.sha,\n                  baseRef: (eventContext.pull_request as { base?: { ref?: string } })?.base?.ref,\n                }\n              : undefined,\n\n            // Raw event payload for advanced use cases\n            payload: eventContext,\n          }\n        : undefined,\n\n      // Utility data for templates\n      utils: {\n        // Date/time helpers\n        now: new Date().toISOString(),\n        today: new Date().toISOString().split('T')[0],\n\n        // Dynamic file grouping by extension\n        filesByExtension: this.groupFilesByExtension(prInfo.files || []),\n\n        // File status categorizations\n        addedFiles: (prInfo.files || []).filter(f => f.status === 'added'),\n        modifiedFiles: (prInfo.files || []).filter(f => f.status === 'modified'),\n        removedFiles: (prInfo.files || []).filter(f => f.status === 'removed'),\n        renamedFiles: (prInfo.files || []).filter(f => f.status === 'renamed'),\n\n        // Change analysis\n        hasLargeChanges: (prInfo.files || []).some(f => f.changes > 50),\n        totalFiles: (prInfo.files || []).length,\n      },\n\n      // Previous check outputs (dependency results)\n      // Expose raw output directly if available, otherwise expose the result as-is\n      outputs: dependencyResults\n        ? Object.fromEntries(\n            Array.from(dependencyResults.entries()).map(([checkName, result]) => [\n              checkName,\n              (() => {\n                const summary = result as ReviewSummary & { output?: unknown };\n                return summary.output !== undefined ? summary.output : summary;\n              })(),\n            ])\n          )\n        : {},\n      // Alias for consistency with other providers\n      outputs_history: (() => {\n        const hist: Record<string, unknown[]> = {};\n        if (outputHistory) {\n          for (const [k, v] of outputHistory.entries()) hist[k] = v;\n        }\n        return hist;\n      })(),\n      // Stage-scoped history slice calculated from baseline captured by the flow runner.\n      outputs_history_stage: (() => {\n        const stage: Record<string, unknown[]> = {};\n        try {\n          const base = (eventContext as any)?.__stageHistoryBase as\n            | Record<string, number>\n            | undefined;\n          if (!outputHistory || !base) return stage;\n          for (const [k, v] of outputHistory.entries()) {\n            const start = base[k] || 0;\n            const arr = Array.isArray(v) ? (v as unknown[]) : [];\n            stage[k] = arr.slice(start);\n          }\n        } catch {}\n        return stage;\n      })(),\n      // New: outputs_raw exposes aggregate values (e.g., full arrays for forEach parents)\n      outputs_raw: outputsRaw,\n    };\n\n    try {\n      if (process.env.VISOR_DEBUG === 'true') {\n        console.error(\n          `[prompt-ctx] outputs.keys=${Object.keys((templateContext as any).outputs || {}).join(', ')} hist.validate-fact.len=${(() => {\n            try {\n              const h = (templateContext as any).outputs_history || {};\n              const v = h['validate-fact'];\n              return Array.isArray(v) ? v.length : 0;\n            } catch {\n              return 0;\n            }\n          })()}`\n        );\n      }\n    } catch {}\n\n    try {\n      return await this.liquidEngine.parseAndRender(promptContent, templateContext);\n    } catch (error) {\n      // Always show a helpful snippet with a caret, similar to YAML errors\n      const err: any = error || {};\n      const lines = String(promptContent || '').split(/\\r?\\n/);\n      const lineNum: number = Number(err.line || err?.token?.line || err?.location?.line || 0);\n      const colNum: number = Number(err.col || err?.token?.col || err?.location?.col || 0);\n      let snippet = '';\n      if (lineNum > 0) {\n        const start = Math.max(1, lineNum - 3);\n        const end = Math.max(lineNum + 2, lineNum);\n        const width = String(end).length;\n        for (let i = start; i <= Math.min(end, lines.length); i++) {\n          const ln = `${String(i).padStart(width, ' ')} | ${lines[i - 1] ?? ''}`;\n          snippet += ln + '\\n';\n          if (i === lineNum) {\n            const caretPad = ' '.repeat(Math.max(0, colNum > 1 ? colNum - 1 : 0) + width + 3);\n            snippet += caretPad + '^\\n';\n          }\n        }\n      } else {\n        // Fallback preview of the first 20 lines\n        const preview = lines\n          .slice(0, 20)\n          .map((l, i) => `${(i + 1).toString().padStart(3, ' ')} | ${l}`)\n          .join('\\n');\n        snippet = preview + '\\n';\n      }\n      const msg = `Failed to render prompt template: ${\n        error instanceof Error ? error.message : 'Unknown error'\n      }`;\n      // Print a clear, user-friendly error with context\n      try {\n        console.error('\\n[prompt-error] ' + msg + '\\n' + snippet);\n      } catch {}\n      throw new Error(msg);\n    }\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    _dependencyResults?: Map<string, ReviewSummary>,\n    sessionInfo?: { parentSessionId?: string; reuseSession?: boolean }\n  ): Promise<ReviewSummary> {\n    // Apply environment configuration if present\n    if (config.env) {\n      const result = EnvironmentResolver.withTemporaryEnv(config.env, () => {\n        // This will be executed with the temporary environment\n        return this.executeWithConfig(prInfo, config, _dependencyResults, sessionInfo);\n      });\n\n      if (result instanceof Promise) {\n        return result;\n      }\n      return result;\n    }\n\n    return this.executeWithConfig(prInfo, config, _dependencyResults, sessionInfo);\n  }\n\n  private async executeWithConfig(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    _dependencyResults?: Map<string, ReviewSummary>,\n    sessionInfo?: {\n      parentSessionId?: string;\n      reuseSession?: boolean;\n    } & import('./check-provider.interface').ExecutionContext\n  ): Promise<ReviewSummary> {\n    try {\n      if (process.env.VISOR_DEBUG === 'true') {\n        console.error(`[ai-exec] step=${String((config as any).checkName || 'unknown')}`);\n      }\n    } catch {}\n    // Extract AI configuration - only set properties that are explicitly provided\n    const aiConfig: AIReviewConfig = {};\n\n    // Check-level AI configuration (ai object)\n    if (config.ai) {\n      // Only set properties that are actually defined to avoid overriding env vars\n      if (config.ai.apiKey !== undefined) {\n        aiConfig.apiKey = config.ai.apiKey as string;\n      }\n      if (config.ai.model !== undefined) {\n        aiConfig.model = config.ai.model as string;\n      }\n      if (config.ai.timeout !== undefined) {\n        aiConfig.timeout = config.ai.timeout as number;\n      }\n      if (config.ai.provider !== undefined) {\n        aiConfig.provider = config.ai.provider as\n          | 'google'\n          | 'anthropic'\n          | 'openai'\n          | 'bedrock'\n          | 'mock';\n      }\n      if (config.ai.debug !== undefined) {\n        aiConfig.debug = config.ai.debug as boolean;\n      }\n      if (config.ai.enableDelegate !== undefined) {\n        aiConfig.enableDelegate = config.ai.enableDelegate as boolean;\n      }\n      if (config.ai.allowEdit !== undefined) {\n        aiConfig.allowEdit = config.ai.allowEdit as boolean;\n      }\n      if (config.ai.allowedTools !== undefined) {\n        aiConfig.allowedTools = config.ai.allowedTools as string[];\n      }\n      if (config.ai.disableTools !== undefined) {\n        aiConfig.disableTools = config.ai.disableTools as boolean;\n      }\n      if (config.ai.allowBash !== undefined) {\n        aiConfig.allowBash = config.ai.allowBash as boolean;\n      }\n      if (config.ai.bashConfig !== undefined) {\n        aiConfig.bashConfig = config.ai.bashConfig as import('../types/config').BashConfig;\n      }\n      if (config.ai.skip_code_context !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (aiConfig as any).skip_code_context = config.ai.skip_code_context as boolean;\n      }\n      if (config.ai.retry !== undefined) {\n        aiConfig.retry = config.ai.retry as import('../types/config').AIRetryConfig;\n      }\n      if (config.ai.fallback !== undefined) {\n        aiConfig.fallback = config.ai.fallback as import('../types/config').AIFallbackConfig;\n      }\n    }\n\n    // Check-level AI model and provider (top-level properties)\n    if (config.ai_model !== undefined) {\n      aiConfig.model = config.ai_model as string;\n    }\n    if (config.ai_provider !== undefined) {\n      aiConfig.provider = config.ai_provider as\n        | 'google'\n        | 'anthropic'\n        | 'openai'\n        | 'bedrock'\n        | 'mock';\n    }\n\n    // Get custom prompt from config - REQUIRED, no fallbacks\n    const customPrompt = config.prompt;\n\n    if (!customPrompt) {\n      throw new Error(\n        `No prompt defined for check. All checks must have prompts defined in .visor.yaml configuration.`\n      );\n    }\n\n    // Setup MCP tools from multiple configuration levels\n    const mcpServers: Record<string, import('../types/config').McpServerConfig> = {};\n\n    // 1. Start with global MCP servers (from visor config root)\n    const globalConfig = config as CheckProviderConfig & {\n      ai_mcp_servers?: Record<string, import('../types/config').McpServerConfig>;\n    };\n    if (globalConfig.ai_mcp_servers) {\n      Object.assign(mcpServers, globalConfig.ai_mcp_servers);\n    }\n\n    // 2. Add check-level MCP servers (overrides global)\n    if (config.ai_mcp_servers) {\n      Object.assign(mcpServers, config.ai_mcp_servers);\n    }\n\n    // 3. Add ai.mcpServers (overrides everything)\n    if (config.ai?.mcpServers) {\n      Object.assign(mcpServers, config.ai.mcpServers);\n    }\n\n    // Pass MCP server config directly to AI service (unless tools are disabled)\n    if (Object.keys(mcpServers).length > 0 && !config.ai?.disableTools) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (aiConfig as any).mcpServers = mcpServers;\n      // no noisy diagnostics here\n    } else if (config.ai?.disableTools) {\n      // silently skip MCP when tools disabled\n    }\n\n    // Build template context for state capture\n    const templateContext = {\n      pr: {\n        number: prInfo.number,\n        title: prInfo.title,\n        author: prInfo.author,\n        branch: prInfo.head,\n        base: prInfo.base,\n      },\n      files: prInfo.files,\n      outputs: _dependencyResults\n        ? Object.fromEntries(\n            Array.from(_dependencyResults.entries()).map(([checkName, result]) => [\n              checkName,\n              (result as any).output !== undefined ? (result as any).output : result,\n            ])\n          )\n        : {},\n    };\n\n    // Capture input context in active OTEL span\n    try {\n      const span = trace.getSpan(otContext.active());\n      if (span) {\n        captureCheckInputContext(span, templateContext);\n      }\n    } catch {\n      // Ignore telemetry errors\n    }\n    // Fallback NDJSON for input context (non-OTEL environments)\n    try {\n      const checkId = (config as any).checkName || (config as any).id || 'unknown';\n      const ctxJson = JSON.stringify(templateContext);\n      const { emitNdjsonSpanWithEvents } = require('../telemetry/fallback-ndjson');\n      emitNdjsonSpanWithEvents(\n        'visor.check',\n        { 'visor.check.id': checkId, 'visor.check.input.context': ctxJson },\n        []\n      );\n    } catch {}\n\n    // Process prompt with Liquid templates and file loading\n    // Do NOT strip event context on skip_code_context ‚Äî that flag only controls\n    // whether we embed PR diffs/large code context later in AIReviewService.\n    // Keep repository/comment metadata available for prompts and tests.\n    const eventContext = config.eventContext || {};\n    // Thread stageHistoryBase via eventContext for prompt rendering so\n    // Liquid templates can get outputs_history_stage (computed from baseline).\n    const ctxWithStage = {\n      ...(eventContext || {}),\n      __stageHistoryBase: (sessionInfo as any)?.stageHistoryBase as\n        | Record<string, number>\n        | undefined,\n    } as Record<string, unknown>;\n\n    const processedPrompt = await this.processPrompt(\n      customPrompt,\n      prInfo,\n      ctxWithStage,\n      _dependencyResults,\n      (config as any).__outputHistory as Map<string, unknown[]> | undefined\n    );\n\n    // Optional persona (vendor extension): ai.ai_persona or ai_persona.\n    // This is a light-weight preamble, not a rewriting of the user's prompt.\n    const aiAny = (config.ai || {}) as any;\n    // Persona (underscore only)\n    const persona = (aiAny?.ai_persona || (config as any).ai_persona || '').toString().trim();\n    const finalPrompt = persona ? `Persona: ${persona}\\n\\n${processedPrompt}` : processedPrompt;\n    // Expose promptType to AIReviewService via env (bridge until ProbeAgent supports it in our SDK surface)\n    try {\n      const pt = ((config.ai as any)?.promptType || (config as any).ai_prompt_type || '')\n        .toString()\n        .trim();\n      if (pt) process.env.VISOR_PROMPT_TYPE = pt;\n    } catch {}\n\n    // Test hook: capture the FINAL prompt (with PR context) before provider invocation\n    try {\n      const stepName = (config as any).checkName || 'unknown';\n      const serviceForCapture = new AIReviewService(aiConfig);\n      const finalPromptCapture = await (serviceForCapture as any).buildCustomPrompt(\n        prInfo,\n        finalPrompt,\n        config.schema,\n        {\n          checkName: (config as any).checkName,\n          skipPRContext: (config.ai as any)?.skip_code_context === true,\n        }\n      );\n      sessionInfo?.hooks?.onPromptCaptured?.({\n        step: String(stepName),\n        provider: 'ai',\n        prompt: finalPromptCapture,\n      });\n      // capture hook retained; no extra console diagnostics\n    } catch {}\n\n    // Test hook: mock output for this step (short-circuit provider)\n    try {\n      const stepName = (config as any).checkName || 'unknown';\n      const mock = sessionInfo?.hooks?.mockForStep?.(String(stepName));\n      if (mock !== undefined) {\n        return { issues: [], output: mock } as ReviewSummary & { output: unknown };\n      }\n    } catch {}\n\n    // Create AI service with config - environment variables will be used if aiConfig is empty\n    try {\n      const pt = (aiAny?.prompt_type || (config as any).ai_prompt_type || '').toString().trim();\n      if (pt) (aiConfig as any).promptType = pt;\n      // Prefer new system_prompt; fall back to legacy custom_prompt for backward compatibility\n      const sys = (aiAny?.system_prompt || (config as any).ai_system_prompt || '')\n        .toString()\n        .trim();\n      const legacy = (aiAny?.custom_prompt || (config as any).ai_custom_prompt || '')\n        .toString()\n        .trim();\n      if (sys) (aiConfig as any).systemPrompt = sys;\n      else if (legacy) (aiConfig as any).systemPrompt = legacy;\n    } catch {}\n    const service = new AIReviewService(aiConfig);\n\n    // Pass the custom prompt and schema - no fallbacks\n    const schema = config.schema as string | Record<string, unknown> | undefined;\n\n    // Removed verbose AICheckProvider console diagnostics; rely on logger.debug when needed\n\n    try {\n      // No extra console diagnostics here\n\n      let result: ReviewSummary;\n\n      // Check if we should use session reuse (only if explicitly enabled on this check)\n      // No extra reuse_ai_session console diagnostics\n      const reuseEnabled =\n        (config as any).reuse_ai_session === true ||\n        typeof (config as any).reuse_ai_session === 'string';\n      if (sessionInfo?.reuseSession && sessionInfo.parentSessionId && reuseEnabled) {\n        // Safety: only reuse if the parent session actually exists\n        try {\n          const { SessionRegistry } = require('../session-registry');\n          const reg = SessionRegistry.getInstance();\n          if (!reg.hasSession(sessionInfo.parentSessionId)) {\n            if (aiConfig.debug || process.env.VISOR_DEBUG === 'true') {\n              console.warn(\n                `‚ö†Ô∏è  Parent session ${sessionInfo.parentSessionId} not found; creating a new session for ${config.checkName}`\n              );\n            }\n            // Fall back to new session\n            const fresh = await service.executeReview(\n              prInfo,\n              processedPrompt,\n              schema,\n              config.checkName,\n              config.sessionId\n            );\n            return {\n              ...fresh,\n              issues: new IssueFilter(config.suppressionEnabled !== false).filterIssues(\n                fresh.issues || [],\n                process.cwd()\n              ),\n            };\n          }\n        } catch {}\n        // Get session_mode from config, default to 'clone'\n        const sessionMode = (config.session_mode as 'clone' | 'append') || 'clone';\n\n        if (aiConfig.debug) {\n          console.error(\n            `üîÑ Debug: Using session reuse with parent session: ${sessionInfo.parentSessionId} (mode: ${sessionMode})`\n          );\n        }\n        result = await service.executeReviewWithSessionReuse(\n          prInfo,\n          processedPrompt,\n          sessionInfo.parentSessionId,\n          schema,\n          config.checkName,\n          sessionMode\n        );\n      } else {\n        if (aiConfig.debug) {\n          console.error(`üÜï Debug: Creating new AI session for check: ${config.checkName}`);\n        }\n        result = await service.executeReview(\n          prInfo,\n          finalPrompt,\n          schema,\n          config.checkName,\n          config.sessionId\n        );\n      }\n\n      // Apply issue suppression filtering\n      const suppressionEnabled = config.suppressionEnabled !== false;\n      const issueFilter = new IssueFilter(suppressionEnabled);\n      const filteredIssues = issueFilter.filterIssues(result.issues || [], process.cwd());\n\n      const finalResult = {\n        ...result,\n        issues: filteredIssues,\n      };\n\n      // Capture AI provider call and output in active OTEL span\n      try {\n        const span = trace.getSpan(otContext.active());\n        if (span) {\n          captureProviderCall(\n            span,\n            'ai',\n            {\n              prompt: processedPrompt.substring(0, 500), // Preview only\n              model: aiConfig.model,\n            },\n            {\n              content: JSON.stringify(finalResult).substring(0, 500),\n              tokens: (result as any).usage?.totalTokens,\n            }\n          );\n          const outputForSpan = (finalResult as { output?: unknown }).output ?? finalResult;\n          captureCheckOutput(span, outputForSpan);\n        }\n      } catch {\n        // Ignore telemetry errors\n      }\n      // Fallback NDJSON for output (non-OTEL environments)\n      try {\n        const checkId = (config as any).checkName || (config as any).id || 'unknown';\n        const outJson = JSON.stringify((finalResult as any).output ?? finalResult);\n        const { emitNdjsonSpanWithEvents } = require('../telemetry/fallback-ndjson');\n        emitNdjsonSpanWithEvents(\n          'visor.check',\n          { 'visor.check.id': checkId, 'visor.check.output': outJson },\n          []\n        );\n      } catch {}\n\n      return finalResult;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n\n      // Log detailed error information\n      console.error(`‚ùå AI Check Provider Error for check: ${errorMessage}`);\n\n      // Check if this is a critical error (authentication, rate limits, etc)\n      const isCriticalError =\n        errorMessage.includes('API rate limit') ||\n        errorMessage.includes('403') ||\n        errorMessage.includes('401') ||\n        errorMessage.includes('authentication') ||\n        errorMessage.includes('API key');\n\n      if (isCriticalError) {\n        console.error(`üö® CRITICAL ERROR: AI provider authentication or rate limit issue detected`);\n        console.error(`üö® This check cannot proceed without valid API credentials`);\n      }\n\n      // Re-throw with more context\n      throw new Error(`AI analysis failed: ${errorMessage}`);\n    }\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'prompt',\n      'focus',\n      'schema',\n      'group',\n      'ai.provider',\n      'ai.model',\n      'ai.apiKey',\n      'ai.timeout',\n      'ai.mcpServers',\n      'ai.enableDelegate',\n      // legacy persona/prompt keys supported in config\n      'ai_persona',\n      'ai_prompt_type',\n      'ai_custom_prompt',\n      'ai_system_prompt',\n      // new provider resilience and tools toggles\n      'ai.retry',\n      'ai.fallback',\n      'ai.allowEdit',\n      'ai.allowedTools',\n      'ai.disableTools',\n      'ai.allowBash',\n      'ai.bashConfig',\n      'ai_model',\n      'ai_provider',\n      'ai_mcp_servers',\n      'env',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // Check if any AI API key is available\n    return !!(\n      process.env.GOOGLE_API_KEY ||\n      process.env.ANTHROPIC_API_KEY ||\n      process.env.OPENAI_API_KEY ||\n      // AWS Bedrock credentials check\n      (process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY) ||\n      process.env.AWS_BEDROCK_API_KEY\n    );\n  }\n\n  getRequirements(): string[] {\n    return [\n      'At least one of: GOOGLE_API_KEY, ANTHROPIC_API_KEY, OPENAI_API_KEY, or AWS credentials (AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY)',\n      'Optional: MODEL_NAME environment variable',\n      'Optional: AWS_REGION for Bedrock provider',\n      'Network access to AI provider APIs',\n    ];\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary, ReviewIssue } from '../reviewer';\nimport { IssueFilter } from '../issue-filter';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { trace, context as otContext } from '../telemetry/lazy-otel';\nimport {\n  captureCheckInputContext,\n  captureCheckOutput,\n  captureProviderCall,\n} from '../telemetry/state-capture';\nimport { EnvironmentResolver } from '../utils/env-resolver';\n\n/**\n * Check provider that sends data to an HTTP endpoint, typically used as an output/notification provider\n */\nexport class HttpCheckProvider extends CheckProvider {\n  private liquid: Liquid;\n\n  constructor() {\n    super();\n    this.liquid = createExtendedLiquid();\n  }\n  getName(): string {\n    return 'http';\n  }\n\n  getDescription(): string {\n    return 'Send data to external HTTP endpoint for notifications or integration';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'http'\n    if (cfg.type !== 'http') {\n      return false;\n    }\n\n    // Must have URL specified\n    if (typeof cfg.url !== 'string' || !cfg.url) {\n      return false;\n    }\n\n    // Must have body template specified\n    if (typeof cfg.body !== 'string' || !cfg.body) {\n      return false;\n    }\n\n    // Validate URL format\n    try {\n      new URL(cfg.url as string);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    _sessionInfo?: { parentSessionId?: string; reuseSession?: boolean }\n  ): Promise<ReviewSummary> {\n    const url = config.url as string;\n    const bodyTemplate = config.body as string;\n    const method = (config.method as string) || 'POST';\n    const headers = (config.headers as Record<string, string>) || {};\n    const timeout = (config.timeout as number) || 30000;\n\n    // Prepare template context with all available data\n    const templateContext = {\n      pr: {\n        number: prInfo.number,\n        title: prInfo.title,\n        body: prInfo.body,\n        author: prInfo.author,\n        base: prInfo.base,\n        head: prInfo.head,\n        totalAdditions: prInfo.totalAdditions,\n        totalDeletions: prInfo.totalDeletions,\n      },\n      files: prInfo.files.map(f => ({\n        filename: f.filename,\n        status: f.status,\n        additions: f.additions,\n        deletions: f.deletions,\n        changes: f.changes,\n        patch: f.patch,\n      })),\n      outputs: dependencyResults ? Object.fromEntries(dependencyResults) : {},\n      metadata: config.metadata || {},\n    };\n\n    // Capture input context in active OTEL span\n    try {\n      const span = trace.getSpan(otContext.active());\n      if (span) {\n        captureCheckInputContext(span, templateContext);\n      }\n    } catch {\n      // Ignore telemetry errors\n    }\n\n    // Render the body template\n    let payload: Record<string, unknown>;\n    try {\n      const renderedBody = await this.liquid.parseAndRender(bodyTemplate, templateContext);\n      // Try to parse as JSON, otherwise send as plain text\n      try {\n        payload = JSON.parse(renderedBody);\n      } catch {\n        payload = { message: renderedBody };\n      }\n    } catch (error) {\n      return this.createErrorResult(\n        url,\n        new Error(\n          `Template rendering failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n        )\n      );\n    }\n\n    try {\n      // Resolve environment variables in headers\n      const resolvedHeaders = EnvironmentResolver.resolveHeaders(headers);\n\n      // Send webhook request\n      const response = await this.sendWebhookRequest(\n        url,\n        method,\n        resolvedHeaders,\n        payload,\n        timeout\n      );\n\n      // Parse webhook response\n      const result = this.parseWebhookResponse(response, url);\n\n      // Apply issue suppression filtering\n      const suppressionEnabled = config.suppressionEnabled !== false;\n      const issueFilter = new IssueFilter(suppressionEnabled);\n      const filteredIssues = issueFilter.filterIssues(result.issues || [], process.cwd());\n\n      const finalResult = {\n        ...result,\n        issues: filteredIssues,\n      };\n\n      // Capture HTTP provider call and output in active OTEL span\n      try {\n        const span = trace.getSpan(otContext.active());\n        if (span) {\n          // Sanitize headers for telemetry to avoid exposing sensitive data\n          const sanitizedHeaders = EnvironmentResolver.sanitizeHeaders(resolvedHeaders);\n          captureProviderCall(\n            span,\n            'http',\n            {\n              url,\n              method,\n              headers: sanitizedHeaders,\n              body: JSON.stringify(payload).substring(0, 500),\n            },\n            {\n              content: JSON.stringify(response).substring(0, 500),\n            }\n          );\n          const outputForSpan = (finalResult as { output?: unknown }).output ?? finalResult;\n          captureCheckOutput(span, outputForSpan);\n        }\n      } catch {\n        // Ignore telemetry errors\n      }\n\n      return finalResult;\n    } catch (error) {\n      return this.createErrorResult(url, error);\n    }\n  }\n\n  private async sendWebhookRequest(\n    url: string,\n    method: string,\n    headers: Record<string, string>,\n    payload: Record<string, unknown>,\n    timeout: number\n  ): Promise<Record<string, unknown>> {\n    // Check if fetch is available (Node 18+)\n    if (typeof fetch === 'undefined') {\n      throw new Error('Webhook provider requires Node.js 18+ or node-fetch package');\n    }\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n    try {\n      const response = await fetch(url, {\n        method,\n        headers: {\n          'Content-Type': 'application/json',\n          ...headers,\n        },\n        body: JSON.stringify(payload),\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        throw new Error(`Webhook returned ${response.status}: ${response.statusText}`);\n      }\n\n      return (await response.json()) as Record<string, unknown>;\n    } catch (error: unknown) {\n      clearTimeout(timeoutId);\n\n      if (error instanceof Error && error.name === 'AbortError') {\n        throw new Error(`Webhook request timed out after ${timeout}ms`);\n      }\n\n      throw error;\n    }\n  }\n\n  private parseWebhookResponse(response: Record<string, unknown>, url: string): ReviewSummary {\n    // Validate and normalize the webhook response\n    if (!response || typeof response !== 'object') {\n      return this.createErrorResult(url, new Error('Invalid webhook response format'));\n    }\n\n    const issues: ReviewIssue[] = Array.isArray(response.comments)\n      ? (response.comments as Array<Record<string, unknown>>).map(c => ({\n          file: (c.file as string) || 'unknown',\n          line: (c.line as number) || 0,\n          endLine: c.endLine as number | undefined,\n          ruleId: (c.ruleId as string) || `webhook/${this.validateCategory(c.category)}`,\n          message: (c.message as string) || '',\n          severity: this.validateSeverity(c.severity),\n          category: this.validateCategory(c.category),\n          suggestion: c.suggestion as string | undefined,\n          replacement: c.replacement as string | undefined,\n        }))\n      : [];\n\n    return {\n      issues,\n    };\n  }\n\n  private createErrorResult(url: string, error: unknown): ReviewSummary {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\n    return {\n      issues: [\n        {\n          file: 'webhook',\n          line: 0,\n          endLine: undefined,\n          ruleId: 'webhook/error',\n          message: `Webhook execution error: ${errorMessage}`,\n          severity: 'error',\n          category: 'logic',\n          suggestion: undefined,\n          replacement: undefined,\n        },\n      ],\n    };\n  }\n\n  private validateSeverity(severity: unknown): 'info' | 'warning' | 'error' | 'critical' {\n    const valid = ['info', 'warning', 'error', 'critical'];\n    return valid.includes(severity as string)\n      ? (severity as 'info' | 'warning' | 'error' | 'critical')\n      : 'info';\n  }\n\n  private validateCategory(\n    category: unknown\n  ): 'security' | 'performance' | 'style' | 'logic' | 'documentation' {\n    const valid = ['security', 'performance', 'style', 'logic', 'documentation'];\n    return valid.includes(category as string)\n      ? (category as 'security' | 'performance' | 'style' | 'logic' | 'documentation')\n      : 'logic';\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'url',\n      'body',\n      'method',\n      'headers',\n      'timeout',\n      'metadata',\n      'depends_on',\n      'on',\n      'if',\n      'group',\n      'schedule',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // HTTP provider is available if fetch is available\n    return typeof fetch !== 'undefined';\n  }\n\n  getRequirements(): string[] {\n    return [\n      'Valid HTTP URL',\n      'Body template (Liquid) for payload construction',\n      'Network access to HTTP endpoint',\n      'Optional: Dependencies for accessing their outputs in templates',\n    ];\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { logger } from '../logger';\n\n/**\n * Check provider that receives input from HTTP webhooks and makes it available to dependent checks\n */\nexport class HttpInputProvider extends CheckProvider {\n  private liquid: Liquid;\n  private webhookContext?: Map<string, unknown>;\n\n  constructor() {\n    super();\n    this.liquid = createExtendedLiquid();\n  }\n\n  /**\n   * Set webhook context for accessing webhook data\n   */\n  setWebhookContext(webhookContext: Map<string, unknown>): void {\n    this.webhookContext = webhookContext;\n  }\n\n  getName(): string {\n    return 'http_input';\n  }\n\n  getDescription(): string {\n    return 'Receive and process HTTP webhook input data for use by dependent checks';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'http_input'\n    if (cfg.type !== 'http_input') {\n      return false;\n    }\n\n    // Must have endpoint specified\n    if (typeof cfg.endpoint !== 'string' || !cfg.endpoint) {\n      return false;\n    }\n\n    // Transform is optional but must be string if provided\n    if (cfg.transform !== undefined && typeof cfg.transform !== 'string') {\n      return false;\n    }\n\n    return true;\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    _dependencyResults?: Map<string, ReviewSummary>,\n    _sessionInfo?: { parentSessionId?: string; reuseSession?: boolean }\n  ): Promise<ReviewSummary> {\n    const endpoint = config.endpoint as string;\n    const transform = config.transform as string | undefined;\n\n    // In actual implementation, this would receive data from the webhook server\n    // For now, we'll check if there's webhook data in the execution context\n    const webhookData = this.getWebhookData(endpoint);\n\n    if (!webhookData) {\n      return {\n        issues: [],\n      };\n    }\n\n    // Apply transformation if specified\n    let processedData = webhookData;\n    if (transform) {\n      try {\n        const templateContext = {\n          webhook: webhookData,\n          pr: {\n            number: prInfo.number,\n            title: prInfo.title,\n            author: prInfo.author,\n            base: prInfo.base,\n            head: prInfo.head,\n          },\n        };\n        const rendered = await this.liquid.parseAndRender(transform, templateContext);\n        processedData = JSON.parse(rendered);\n        logger.verbose(`‚úì Applied webhook transform successfully`);\n      } catch (error) {\n        logger.error(\n          `‚úó Failed to transform webhook data: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n        return {\n          issues: [\n            {\n              file: 'webhook_input',\n              line: 0,\n              ruleId: 'webhook_input/transform_error',\n              message: `Failed to transform webhook data: ${error instanceof Error ? error.message : 'Unknown error'}`,\n              severity: 'error',\n              category: 'logic',\n            },\n          ],\n        };\n      }\n    }\n\n    // Return the processed data as a custom field for dependent checks to access\n    // This will be available in outputs for dependent checks\n    return {\n      issues: [],\n      // Add custom data field that will be passed through\n      data: processedData,\n    } as ReviewSummary & { data: unknown };\n  }\n\n  private getWebhookData(endpoint: string): Record<string, unknown> | null {\n    // Use webhook context if available (preferred method)\n    if (this.webhookContext) {\n      return (this.webhookContext.get(endpoint) as Record<string, unknown>) || null;\n    }\n\n    // Fallback to global store for backwards compatibility\n    // This should be removed once all usages are migrated\n    const globalWebhookStore = (global as Record<string, unknown>).__visor_webhook_data as\n      | Map<string, Record<string, unknown>>\n      | undefined;\n    if (globalWebhookStore && globalWebhookStore.get) {\n      console.warn(\n        'HttpInputProvider: Using deprecated global webhook store. Please use webhook context instead.'\n      );\n      return globalWebhookStore.get(endpoint) || null;\n    }\n\n    return null;\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return ['type', 'endpoint', 'transform', 'on', 'depends_on', 'if', 'group'];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // Available if webhook server is configured and running\n    return true;\n  }\n\n  getRequirements(): string[] {\n    return [\n      'HTTP server must be configured and running',\n      'Valid endpoint path specified',\n      'Optional: Transform template for data processing',\n    ];\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { EnvironmentResolver } from '../utils/env-resolver';\n\n/**\n * Check provider that fetches data from HTTP endpoints\n */\nexport class HttpClientProvider extends CheckProvider {\n  private liquid: Liquid;\n\n  constructor() {\n    super();\n    this.liquid = createExtendedLiquid();\n  }\n\n  getName(): string {\n    return 'http_client';\n  }\n\n  getDescription(): string {\n    return 'Fetch data from HTTP endpoints for use by dependent checks';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'http_client'\n    if (cfg.type !== 'http_client') {\n      return false;\n    }\n\n    // Must have URL specified\n    if (typeof cfg.url !== 'string' || !cfg.url) {\n      return false;\n    }\n\n    // Validate URL format\n    try {\n      new URL(cfg.url as string);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    context?: import('./check-provider.interface').ExecutionContext\n  ): Promise<ReviewSummary> {\n    const url = config.url as string;\n    const method = (config.method as string) || 'GET';\n    const headers = (config.headers as Record<string, string>) || {};\n    const timeout = (config.timeout as number) || 30000;\n    const transform = config.transform as string | undefined;\n    const bodyTemplate = config.body as string | undefined;\n\n    try {\n      // Prepare template context for URL and body\n      const templateContext = {\n        pr: {\n          number: prInfo.number,\n          title: prInfo.title,\n          body: prInfo.body,\n          author: prInfo.author,\n          base: prInfo.base,\n          head: prInfo.head,\n          totalAdditions: prInfo.totalAdditions,\n          totalDeletions: prInfo.totalDeletions,\n        },\n        outputs: dependencyResults ? Object.fromEntries(dependencyResults) : {},\n        env: process.env,\n      };\n\n      // Render URL with template if it contains liquid syntax\n      let renderedUrl = url;\n      if (url.includes('{{') || url.includes('{%')) {\n        renderedUrl = await this.liquid.parseAndRender(url, templateContext);\n      }\n\n      // Prepare request body if provided\n      let requestBody: string | undefined;\n      if (bodyTemplate) {\n        const renderedBody = await this.liquid.parseAndRender(bodyTemplate, templateContext);\n        requestBody = renderedBody;\n      }\n\n      // Resolve environment variables in headers\n      const resolvedHeaders = EnvironmentResolver.resolveHeaders(headers);\n\n      // Test hook: mock HTTP response for this step\n      const stepName = (config as any).checkName || 'unknown';\n      const mock = context?.hooks?.mockForStep?.(String(stepName));\n      const data =\n        mock !== undefined\n          ? mock\n          : await this.fetchData(renderedUrl, method, resolvedHeaders, requestBody, timeout);\n\n      // Apply transformation if specified\n      let processedData = data;\n      if (transform) {\n        try {\n          const transformContext = {\n            response: data,\n            pr: templateContext.pr,\n            outputs: templateContext.outputs,\n          };\n          const rendered = await this.liquid.parseAndRender(transform, transformContext);\n          // Try to parse as JSON if the transform result looks like JSON\n          if (rendered.trim().startsWith('{') || rendered.trim().startsWith('[')) {\n            processedData = JSON.parse(rendered);\n          } else {\n            processedData = rendered;\n          }\n        } catch (error) {\n          return {\n            issues: [\n              {\n                file: 'http_client',\n                line: 0,\n                ruleId: 'http_client/transform_error',\n                message: `Failed to transform response data: ${error instanceof Error ? error.message : 'Unknown error'}`,\n                severity: 'error',\n                category: 'logic',\n              },\n            ],\n          };\n        }\n      }\n\n      // Return the fetched data as a custom field for dependent checks to access\n      return {\n        issues: [],\n        // Add custom data field that will be passed through to dependent checks\n        data: processedData,\n      } as ReviewSummary & { data: unknown };\n    } catch (error) {\n      return {\n        issues: [\n          {\n            file: 'http_client',\n            line: 0,\n            ruleId: 'http_client/fetch_error',\n            message: `Failed to fetch from ${url}: ${error instanceof Error ? error.message : 'Unknown error'}`,\n            severity: 'error',\n            category: 'logic',\n          },\n        ],\n      };\n    }\n  }\n\n  private async fetchData(\n    url: string,\n    method: string,\n    headers: Record<string, string>,\n    body?: string,\n    timeout: number = 30000\n  ): Promise<unknown> {\n    // Check if fetch is available (Node 18+)\n    if (typeof fetch === 'undefined') {\n      throw new Error('HTTP client provider requires Node.js 18+ or node-fetch package');\n    }\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n    try {\n      const requestOptions: RequestInit = {\n        method,\n        headers: {\n          ...headers,\n        },\n        signal: controller.signal,\n      };\n\n      // Add body for non-GET requests\n      if (method !== 'GET' && body) {\n        requestOptions.body = body;\n        // Set Content-Type if not already set\n        if (!headers['Content-Type'] && !headers['content-type']) {\n          requestOptions.headers = {\n            ...requestOptions.headers,\n            'Content-Type': 'application/json',\n          };\n        }\n      }\n\n      const response = await fetch(url, requestOptions);\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      // Try to parse as JSON first\n      const contentType = response.headers.get('content-type');\n      if (contentType && contentType.includes('application/json')) {\n        return await response.json();\n      }\n\n      // Otherwise return as text\n      const text = await response.text();\n\n      // Try to parse as JSON if it looks like JSON\n      if (text.trim().startsWith('{') || text.trim().startsWith('[')) {\n        try {\n          return JSON.parse(text);\n        } catch {\n          // Not JSON, return as text\n          return text;\n        }\n      }\n\n      return text;\n    } catch (error: unknown) {\n      clearTimeout(timeoutId);\n\n      if (error instanceof Error && error.name === 'AbortError') {\n        throw new Error(`Request timed out after ${timeout}ms`);\n      }\n\n      throw error;\n    }\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'url',\n      'method',\n      'headers',\n      'body',\n      'transform',\n      'timeout',\n      'depends_on',\n      'on',\n      'if',\n      'group',\n      'schedule',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // HTTP client is available if fetch is available\n    return typeof fetch !== 'undefined';\n  }\n\n  getRequirements(): string[] {\n    return [\n      'Valid HTTP/HTTPS URL to fetch from',\n      'Network access to the endpoint',\n      'Optional: Transform template for processing response data',\n      'Optional: Body template for POST/PUT requests',\n    ];\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\n\n/**\n * No-operation check provider that doesn't perform any analysis.\n *\n * This provider is designed for command orchestration - it allows creating\n * checks that exist purely to trigger other checks through dependencies.\n *\n * Example use case: A \"/review\" command that triggers multiple analysis checks\n * without performing any analysis itself.\n */\nexport class NoopCheckProvider extends CheckProvider {\n  getName(): string {\n    return 'noop';\n  }\n\n  getDescription(): string {\n    return 'No-operation provider for command orchestration and dependency triggering';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'noop'\n    if (cfg.type !== 'noop') {\n      return false;\n    }\n\n    return true;\n  }\n\n  async execute(\n    _prInfo: PRInfo,\n    _config: CheckProviderConfig,\n    _dependencyResults?: Map<string, ReviewSummary>,\n    _sessionInfo?: { parentSessionId?: string; reuseSession?: boolean }\n  ): Promise<ReviewSummary> {\n    // Noop provider doesn't perform any analysis\n    // It exists purely for command orchestration and dependency triggering\n    return {\n      issues: [],\n    };\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return ['type', 'command', 'depends_on', 'on', 'if', 'group'];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // Noop provider is always available\n    return true;\n  }\n\n  getRequirements(): string[] {\n    return [\n      'No external dependencies required',\n      'Used for command orchestration and dependency triggering',\n    ];\n  }\n}\n","import { CheckProvider, CheckProviderConfig, ExecutionContext } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { logger } from '../logger';\n\n/**\n * Log levels supported by the log provider\n */\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\n/**\n * Check provider that outputs debugging and logging information.\n * Useful for troubleshooting check workflows and understanding execution flow.\n */\nexport class LogCheckProvider extends CheckProvider {\n  private liquid: Liquid;\n\n  constructor() {\n    super();\n    this.liquid = createExtendedLiquid({\n      strictVariables: false,\n      strictFilters: false,\n    });\n  }\n\n  getName(): string {\n    return 'log';\n  }\n\n  getDescription(): string {\n    return 'Output debugging and logging information for troubleshooting check workflows';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'log'\n    if (cfg.type !== 'log') {\n      return false;\n    }\n\n    // Message is required\n    if (!cfg.message || typeof cfg.message !== 'string') {\n      return false;\n    }\n\n    // Validate log level if provided\n    if (cfg.level && !['debug', 'info', 'warn', 'error'].includes(cfg.level as string)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    context?: ExecutionContext\n  ): Promise<ReviewSummary> {\n    const message = config.message as string;\n    const level = (config.level as LogLevel) || 'info';\n    const includePrContext = config.include_pr_context !== false;\n    const includeDependencies = config.include_dependencies !== false;\n    const includeMetadata = config.include_metadata !== false;\n\n    // Prepare template context\n    const templateContext = this.buildTemplateContext(\n      prInfo,\n      dependencyResults,\n      includePrContext,\n      includeDependencies,\n      includeMetadata,\n      config.__outputHistory as Map<string, unknown[]> | undefined,\n      context\n    );\n\n    // Render the log message template\n    const renderedMessage = await this.liquid.parseAndRender(message, templateContext);\n\n    // Build the log output\n    const logOutput = this.formatLogOutput(\n      level,\n      renderedMessage,\n      templateContext,\n      includePrContext,\n      includeDependencies,\n      includeMetadata\n    );\n\n    // Route through centralized logger to keep stdout clean in JSON/SARIF\n    if (level === 'error') logger.error(logOutput);\n    else if (level === 'warn') logger.warn(logOutput);\n    else if (level === 'debug') logger.debug(logOutput);\n    else logger.info(logOutput);\n\n    // Return with the log content as custom data for dependent checks\n    return {\n      issues: [],\n      // Add log output as custom field\n      logOutput,\n    } as ReviewSummary & { logOutput: string };\n  }\n\n  private buildTemplateContext(\n    prInfo: PRInfo,\n    dependencyResults?: Map<string, ReviewSummary>,\n    _includePrContext: boolean = true,\n    _includeDependencies: boolean = true,\n    includeMetadata: boolean = true,\n    outputHistory?: Map<string, unknown[]>,\n    executionContext?: ExecutionContext\n  ): Record<string, unknown> {\n    const context: Record<string, unknown> = {};\n\n    // Always provide pr context for template rendering\n    context.pr = {\n      number: prInfo.number,\n      title: prInfo.title,\n      body: prInfo.body,\n      author: prInfo.author,\n      base: prInfo.base,\n      head: prInfo.head,\n      totalAdditions: prInfo.totalAdditions,\n      totalDeletions: prInfo.totalDeletions,\n      files: prInfo.files.map(f => ({\n        filename: f.filename,\n        status: f.status,\n        additions: f.additions,\n        deletions: f.deletions,\n        changes: f.changes,\n      })),\n    };\n\n    // Add convenience data\n    context.filenames = prInfo.files.map(f => f.filename);\n    context.fileCount = prInfo.files.length;\n\n    // Always provide dependency data for template rendering\n    if (dependencyResults) {\n      const dependencies: Record<string, unknown> = {};\n      const outputs: Record<string, unknown> = {};\n      const outputsRaw: Record<string, unknown> = {};\n      const history: Record<string, unknown[]> = {};\n      context.dependencyCount = dependencyResults.size;\n\n      for (const [checkName, result] of dependencyResults.entries()) {\n        if (typeof checkName !== 'string') continue;\n        dependencies[checkName] = {\n          issueCount: result.issues?.length || 0,\n          suggestionCount: 0,\n          issues: result.issues || [],\n        };\n\n        // Add outputs namespace for accessing dependency results directly\n        const summary = result as import('../reviewer').ReviewSummary & { output?: unknown };\n        if (typeof checkName === 'string' && checkName.endsWith('-raw')) {\n          const name = checkName.slice(0, -4);\n          outputsRaw[name] = summary.output !== undefined ? summary.output : summary;\n        } else {\n          outputs[checkName] = summary.output !== undefined ? summary.output : summary;\n        }\n      }\n\n      // Add history for each check if available\n      if (outputHistory) {\n        for (const [checkName, historyArray] of outputHistory) {\n          history[checkName] = historyArray;\n        }\n      }\n\n      // Attach history to the outputs object\n      (outputs as any).history = history;\n\n      context.dependencies = dependencies;\n      context.outputs = outputs;\n      // Alias: outputs_history mirrors outputs.history for consistency\n      (context as any).outputs_history = history;\n      // New: outputs_raw exposes aggregate values (e.g., arrays) for forEach parents\n      (context as any).outputs_raw = outputsRaw;\n    }\n\n    if (includeMetadata) {\n      context.metadata = {\n        timestamp: new Date().toISOString(),\n        executionTime: Date.now(),\n        nodeVersion: process.version,\n        platform: process.platform,\n        workingDirectory: process.cwd(),\n      };\n    }\n\n    // Add workflow inputs if available\n    const workflowInputs = executionContext?.workflowInputs || {};\n    logger.debug(\n      `[LogProvider] Adding ${Object.keys(workflowInputs).length} workflow inputs to context`\n    );\n    context.inputs = workflowInputs;\n\n    return context;\n  }\n\n  private formatLogOutput(\n    level: LogLevel,\n    message: string,\n    templateContext: Record<string, unknown>,\n    includePrContext: boolean,\n    includeDependencies: boolean,\n    includeMetadata: boolean\n  ): string {\n    const sections: string[] = [];\n\n    // Log level and message\n    const levelEmoji = this.getLevelEmoji(level);\n    sections.push(`${levelEmoji} **${level.toUpperCase()}**: ${message}`);\n\n    // PR context section\n    if (includePrContext && templateContext.pr) {\n      const pr = templateContext.pr as Record<string, unknown>;\n      sections.push('');\n      sections.push('### PR Context');\n      sections.push(`- **PR #${pr.number}**: ${pr.title}`);\n      sections.push(`- **Author**: ${pr.author}`);\n      sections.push(`- **Base**: ${pr.base} ‚Üí **Head**: ${pr.head}`);\n      sections.push(`- **Changes**: +${pr.totalAdditions} -${pr.totalDeletions}`);\n      sections.push(`- **Files Modified**: ${templateContext.fileCount}`);\n    }\n\n    // Dependencies section\n    if (includeDependencies && templateContext.dependencies) {\n      const deps = templateContext.dependencies as Record<string, Record<string, unknown>>;\n      sections.push('');\n      sections.push('### Dependency Results');\n\n      if (Object.keys(deps).length === 0) {\n        sections.push('- No dependency results available');\n      } else {\n        for (const [checkName, result] of Object.entries(deps)) {\n          sections.push(\n            `- **${checkName}**: ${result.issueCount} issues, ${result.suggestionCount} suggestions`\n          );\n        }\n      }\n    }\n\n    // Metadata section\n    if (includeMetadata && templateContext.metadata) {\n      const meta = templateContext.metadata as Record<string, unknown>;\n      sections.push('');\n      sections.push('### Execution Metadata');\n      sections.push(`- **Timestamp**: ${meta.timestamp}`);\n      sections.push(`- **Node Version**: ${meta.nodeVersion}`);\n      sections.push(`- **Platform**: ${meta.platform}`);\n      sections.push(`- **Working Directory**: ${meta.workingDirectory}`);\n    }\n\n    return sections.join('\\n');\n  }\n\n  private getLevelEmoji(level: LogLevel): string {\n    switch (level) {\n      case 'debug':\n        return 'üêõ';\n      case 'info':\n        return '‚ÑπÔ∏è';\n      case 'warn':\n        return '‚ö†Ô∏è';\n      case 'error':\n        return '‚ùå';\n      default:\n        return '‚ÑπÔ∏è';\n    }\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'message',\n      'level',\n      'include_pr_context',\n      'include_dependencies',\n      'include_metadata',\n      'group',\n      'command',\n      'depends_on',\n      'on',\n      'if',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // Log provider is always available\n    return true;\n  }\n\n  getRequirements(): string[] {\n    return [\n      'No external dependencies required',\n      'Used for debugging and logging check execution flow',\n    ];\n  }\n}\n","import Sandbox from '@nyariv/sandboxjs';\n\n/**\n * Centralized helpers for creating and using SandboxJS instances consistently\n * across providers. The goal is to have one place to define allowed globals\n * and prototype whitelists, and to offer a small helper to inject a `log`\n * utility inside user-provided JS snippets.\n */\n\nexport interface CompileOptions {\n  injectLog?: boolean;\n  logPrefix?: string;\n  /** When true, wrap the code in a function and `return` its result */\n  wrapFunction?: boolean;\n}\n\n/**\n * Create a hardened Sandbox with a consistent set of globals and prototype\n * whitelists. This is a superset of the sets previously used by individual\n * providers, kept intentionally minimal and side‚Äëeffect free.\n */\nexport function createSecureSandbox(): Sandbox {\n  const globals = {\n    ...Sandbox.SAFE_GLOBALS,\n    Math,\n    JSON,\n    // Provide console with limited surface. Use trampolines so that any test\n    // spies (e.g., jest.spyOn(console, 'log')) see calls made inside the sandbox.\n    console: {\n      log: (...args: unknown[]) => {\n        try {\n          (console as any).log(...args);\n        } catch {}\n      },\n      warn: (...args: unknown[]) => {\n        try {\n          (console as any).warn(...args);\n        } catch {}\n      },\n      error: (...args: unknown[]) => {\n        try {\n          (console as any).error(...args);\n        } catch {}\n      },\n    },\n  } as Record<string, unknown>;\n\n  const prototypeWhitelist = new Map(Sandbox.SAFE_PROTOTYPES);\n\n  // Arrays ‚Äî union of methods used around the codebase\n  const arrayMethods = new Set<string>([\n    // Query/iteration\n    'some',\n    'every',\n    'filter',\n    'map',\n    'reduce',\n    'reduceRight',\n    'find',\n    'findIndex',\n    'findLast',\n    'findLastIndex',\n    'includes',\n    'indexOf',\n    'lastIndexOf',\n    'keys',\n    'values',\n    'entries',\n    'forEach',\n    // Non‚Äëmutating ES2023 additions\n    'toReversed',\n    'toSorted',\n    'toSpliced',\n    'with',\n    'at',\n    // Mutators and common ops\n    'slice',\n    'concat',\n    'join',\n    'push',\n    'pop',\n    'shift',\n    'unshift',\n    'sort',\n    'reverse',\n    'copyWithin',\n    'fill',\n    // Flattening\n    'flat',\n    'flatMap',\n    // Meta\n    'length',\n  ]);\n  prototypeWhitelist.set(Array.prototype, arrayMethods);\n\n  // Strings ‚Äî allow common, safe manipulation helpers\n  const stringMethods = new Set<string>([\n    'toLowerCase',\n    'toUpperCase',\n    'includes',\n    'indexOf',\n    'lastIndexOf',\n    'startsWith',\n    'endsWith',\n    'slice',\n    'substring',\n    'substr',\n    'trim',\n    'trimStart',\n    'trimEnd',\n    'split',\n    'replace',\n    'replaceAll',\n    'match',\n    'matchAll',\n    'charAt',\n    'charCodeAt',\n    'codePointAt',\n    'normalize',\n    'repeat',\n    'padStart',\n    'padEnd',\n    'at',\n    'length',\n  ]);\n  prototypeWhitelist.set(String.prototype, stringMethods);\n\n  // Objects ‚Äî keep to basic safe operations\n  const objectMethods = new Set<string>([\n    'hasOwnProperty',\n    'propertyIsEnumerable',\n    'toString',\n    'valueOf',\n  ]);\n  prototypeWhitelist.set(Object.prototype, objectMethods);\n\n  // Keep native constructors from SAFE_GLOBALS; rely on prototype whitelists above.\n\n  // Maps and Sets ‚Äî allow common, safe operations\n  const mapMethods = new Set<string>([\n    'get',\n    'set',\n    'has',\n    'delete',\n    'entries',\n    'keys',\n    'values',\n    'forEach',\n  ]);\n  // @ts-ignore - sandbox typings accept Map.prototype as a key\n  prototypeWhitelist.set((Map as any).prototype, mapMethods);\n\n  const setMethods = new Set<string>([\n    'add',\n    'has',\n    'delete',\n    'entries',\n    'keys',\n    'values',\n    'forEach',\n  ]);\n  // @ts-ignore\n  prototypeWhitelist.set((Set as any).prototype, setMethods);\n\n  // Date and RegExp ‚Äî read‚Äëonly helpers\n  const dateMethods = new Set<string>(['toISOString', 'toJSON', 'getTime']);\n  // @ts-ignore\n  prototypeWhitelist.set((Date as any).prototype, dateMethods);\n\n  const regexpMethods = new Set<string>(['test', 'exec']);\n  // @ts-ignore\n  prototypeWhitelist.set((RegExp as any).prototype, regexpMethods);\n\n  return new Sandbox({ globals, prototypeWhitelist });\n}\n\n/**\n * Compile and execute user-provided JS inside the sandbox with optional\n * helper injection. By default, code is wrapped in a function to keep the\n * global scope clean.\n */\nexport function compileAndRun<T = unknown>(\n  sandbox: Sandbox,\n  userCode: string,\n  scope: Record<string, unknown>,\n  opts: CompileOptions = { injectLog: true, wrapFunction: true, logPrefix: '[sandbox]' }\n): T {\n  const inject = opts?.injectLog === true;\n  let safePrefix = String(opts?.logPrefix ?? '[sandbox]');\n  // Sanitize prefix aggressively: drop control chars and risky tokens, limit length\n  safePrefix = safePrefix\n    .replace(/[\\r\\n\\t\\0]/g, '')\n    .replace(/[`$\\\\]/g, '') // strip backticks, dollar (template) and backslashes\n    .replace(/\\$\\{/g, '') // remove template openings if present\n    .slice(0, 64);\n  // Build a safe header without string concatenation inside user code\n  const header = inject\n    ? `const __lp = ${JSON.stringify(safePrefix)}; const log = (...a) => { try { console.log(__lp, ...a); } catch {} };\\n`\n    : '';\n  // When wrapping, execute user code inside an IIFE and return its value.\n  // This reliably captures the value of the last expression or any explicit\n  // return statements inside the script, without requiring the caller to\n  // manually `return` at top level.\n  // Wrapper heuristic:\n  // - If the snippet contains an explicit `return`, semicolons or newlines (likely a block),\n  //   run it inside an IIFE so `return` works:  (() => { code })()\n  // - Otherwise treat it as a pure expression and return its value directly.\n  const src = String(userCode);\n  const looksLikeBlock = /\\breturn\\b/.test(src) || /;/.test(src) || /\\n/.test(src);\n  // Heuristic: if the snippet itself looks like an IIFE/callable expression\n  // (e.g., `(() => { ... })()` or `(function(){ ... })()`), return its value\n  // directly to avoid swallowing the result by nesting it inside another block.\n  const looksLikeIife = /\\)\\s*\\(\\s*\\)\\s*;?$/.test(src.trim());\n  const body = opts.wrapFunction\n    ? looksLikeBlock\n      ? looksLikeIife\n        ? `return (\\n${src}\\n);\\n`\n        : `return (() => {\\n${src}\\n})();\\n`\n      : `return (\\n${src}\\n);\\n`\n    : `${src}`;\n  const code = `${header}${body}`;\n  let exec: ReturnType<typeof sandbox.compile>;\n  try {\n    exec = sandbox.compile(code);\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    throw new Error(`sandbox_compile_error: ${msg}`);\n  }\n\n  let out: any;\n  try {\n    out = exec(scope);\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    throw new Error(`sandbox_execution_error: ${msg}`);\n  }\n\n  if (out && typeof out.run === 'function') {\n    try {\n      return out.run();\n    } catch (e) {\n      const msg = e instanceof Error ? e.message : String(e);\n      throw new Error(`sandbox_runner_error: ${msg}`);\n    }\n  }\n  return out as T;\n}\n","import type { RecordingOctokit } from './github-recorder';\n\nlet __rec: RecordingOctokit | null = null;\n\nexport function setGlobalRecorder(r: RecordingOctokit | null): void {\n  __rec = r;\n}\n\nexport function getGlobalRecorder(): RecordingOctokit | null {\n  return __rec;\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport Sandbox from '@nyariv/sandboxjs';\nimport { createSecureSandbox, compileAndRun } from '../utils/sandbox';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { logger } from '../logger';\n\nexport class GitHubOpsProvider extends CheckProvider {\n  private sandbox?: Sandbox;\n\n  getName(): string {\n    return 'github';\n  }\n\n  getDescription(): string {\n    return 'Native GitHub operations (labels, comments, reviewers) executed via Octokit';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') return false;\n    const cfg = config as CheckProviderConfig & { op?: string };\n    return typeof cfg.op === 'string' && cfg.op.length > 0;\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return ['op', 'values', 'value', 'value_js'];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // Available when running in GitHub context or when a token is provided\n    return Boolean(\n      process.env.GITHUB_TOKEN || process.env['INPUT_GITHUB-TOKEN'] || process.env.GITHUB_REPOSITORY\n    );\n  }\n\n  getRequirements(): string[] {\n    return ['GITHUB_TOKEN or INPUT_GITHUB-TOKEN', 'GITHUB_REPOSITORY'];\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>\n  ): Promise<ReviewSummary> {\n    const cfg = config as CheckProviderConfig & {\n      op: string;\n      values?: string[] | string;\n      value?: string;\n      value_js?: string;\n    };\n\n    // IMPORTANT: Always prefer authenticated octokit from event context (GitHub App or token)\n    // This ensures proper bot identity in reactions, labels, and comments\n    let octokit: import('@octokit/rest').Octokit | undefined = config.eventContext?.octokit as\n      | import('@octokit/rest').Octokit\n      | undefined;\n    if (process.env.VISOR_DEBUG === 'true') {\n      try {\n        logger.debug(`[github-ops] pre-fallback octokit? ${!!octokit}`);\n      } catch {}\n    }\n    // Test runner fallback: use global recorder if eventContext is missing octokit\n    if (!octokit) {\n      try {\n        const { getGlobalRecorder } = require('../test-runner/recorders/global-recorder');\n        const rec = getGlobalRecorder && getGlobalRecorder();\n        if (rec) octokit = rec as any;\n      } catch {}\n    }\n\n    if (!octokit) {\n      if (process.env.VISOR_DEBUG === 'true') {\n        try {\n          console.error('[github-ops] missing octokit after fallback ‚Äî returning issue');\n        } catch {}\n      }\n      return {\n        issues: [\n          {\n            file: 'system',\n            line: 0,\n            ruleId: 'github/missing_octokit',\n            message:\n              'No authenticated Octokit instance available in event context. GitHub operations require proper authentication context.',\n            severity: 'error',\n            category: 'logic',\n          },\n        ],\n      };\n    }\n\n    const repoEnv = process.env.GITHUB_REPOSITORY || '';\n    let owner = '';\n    let repo = '';\n    if (repoEnv.includes('/')) {\n      [owner, repo] = repoEnv.split('/') as [string, string];\n    } else {\n      try {\n        const ec: any = config.eventContext || {};\n        owner = ec?.repository?.owner?.login || owner;\n        repo = ec?.repository?.name || repo;\n      } catch {}\n    }\n    try {\n      if (process.env.VISOR_DEBUG === 'true') {\n        logger.info(\n          `[github-ops] context octokit? ${!!octokit} repo=${owner}/${repo} pr#=${prInfo?.number}`\n        );\n      }\n    } catch {}\n    if (!owner || !repo || !prInfo?.number) {\n      return {\n        issues: [\n          {\n            file: 'system',\n            line: 0,\n            ruleId: 'github/missing_context',\n            message: 'Missing owner/repo or PR number; GitHub operations require Action context',\n            severity: 'error',\n            category: 'logic',\n          },\n        ],\n      };\n    }\n\n    // Build values list (allow string or array), render Liquid templates if present, and normalize\n    let valuesRaw: string[] = [];\n    if (Array.isArray(cfg.values)) valuesRaw = (cfg.values as unknown[]).map(v => String(v));\n    else if (typeof cfg.values === 'string') valuesRaw = [cfg.values];\n    else if (typeof cfg.value === 'string') valuesRaw = [cfg.value];\n    try {\n      if (process.env.VISOR_DEBUG === 'true') {\n        logger.info(`[github-ops] op=${cfg.op} valuesRaw(before)=${JSON.stringify(valuesRaw)}`);\n      }\n    } catch {}\n\n    // Liquid render helper for values\n    const renderValues = async (arr: string[]): Promise<string[]> => {\n      if (!arr || arr.length === 0) return [];\n      const liq = createExtendedLiquid({\n        cache: false,\n        strictFilters: false,\n        strictVariables: false,\n      });\n      const outputs: Record<string, unknown> = {};\n      if (dependencyResults) {\n        for (const [name, result] of dependencyResults.entries()) {\n          const summary = result as ReviewSummary & { output?: unknown };\n          outputs[name] = summary.output !== undefined ? summary.output : summary;\n        }\n      }\n      // Fallback: if outputs missing but engine provided history, use last output snapshot\n      try {\n        const hist = (config as any).__outputHistory as Map<string, unknown[]> | undefined;\n        if (hist) {\n          for (const [name, arr] of hist.entries()) {\n            if (!outputs[name] && Array.isArray(arr) && arr.length > 0) {\n              outputs[name] = arr[arr.length - 1];\n            }\n          }\n        }\n      } catch {}\n      const ctx = {\n        pr: {\n          number: prInfo.number,\n          title: prInfo.title,\n          author: prInfo.author,\n          branch: prInfo.head,\n          base: prInfo.base,\n          authorAssociation: prInfo.authorAssociation,\n        },\n        outputs,\n      };\n      try {\n        if (process.env.VISOR_DEBUG === 'true') {\n          logger.info(`[github-ops] deps keys=${Object.keys(outputs).join(', ')}`);\n          const ov = outputs['overview'] as any;\n          if (ov) {\n            logger.info(`[github-ops] outputs.overview.keys=${Object.keys(ov).join(',')}`);\n            if (ov.tags) {\n              logger.info(\n                `[github-ops] outputs.overview.tags keys=${Object.keys(ov.tags).join(',')}`\n              );\n              try {\n                logger.info(\n                  `[github-ops] outputs.overview.tags['review-effort']=${String(ov.tags['review-effort'])}`\n                );\n              } catch {}\n            }\n          }\n        }\n      } catch {}\n      const out: string[] = [];\n      for (const item of arr) {\n        if (typeof item === 'string' && (item.includes('{{') || item.includes('{%'))) {\n          try {\n            const rendered = await liq.parseAndRender(item, ctx);\n            out.push(rendered);\n          } catch (e) {\n            // If Liquid fails, surface as a provider error\n            const msg = e instanceof Error ? e.message : String(e);\n            if (process.env.VISOR_DEBUG === 'true') {\n              logger.warn(`[github-ops] liquid_render_error: ${msg}`);\n            }\n            return Promise.reject({\n              issues: [\n                {\n                  file: 'system',\n                  line: 0,\n                  ruleId: 'github/liquid_render_error',\n                  message: `Failed to render template: ${msg}`,\n                  severity: 'error',\n                  category: 'logic',\n                },\n              ],\n            } as ReviewSummary);\n          }\n        } else {\n          out.push(String(item));\n        }\n      }\n      return out;\n    };\n\n    let values: string[] = await renderValues(valuesRaw);\n\n    // Expose dependency outputs to value_js for convenience (generic map)\n    const depOutputs: Record<string, unknown> = {};\n    if (dependencyResults) {\n      for (const [name, result] of dependencyResults.entries()) {\n        const summary = result as ReviewSummary & { output?: unknown };\n        depOutputs[name] = summary.output !== undefined ? summary.output : summary;\n      }\n    }\n\n    if (cfg.value_js && cfg.value_js.trim()) {\n      try {\n        // Evaluate user-provided value_js in a restricted sandbox (no process/global exposure)\n        const sandbox = this.getSecureSandbox();\n\n        const res = compileAndRun<unknown>(\n          sandbox,\n          cfg.value_js,\n          { pr: prInfo, values, outputs: depOutputs },\n          { injectLog: true, wrapFunction: true, logPrefix: '[github:value_js]' }\n        );\n        if (typeof res === 'string') values = [res];\n        else if (Array.isArray(res)) values = (res as unknown[]).map(v => String(v));\n      } catch (e) {\n        // Generic fallback: keep pre-rendered values as-is (no hardcoded deps)\n        // Never hardcode a particular step like 'issue-assistant'.\n        const msg = e instanceof Error ? e.message : String(e);\n        if (process.env.VISOR_DEBUG === 'true') logger.warn(`[github-ops] value_js_error: ${msg}`);\n        // Normalize strings; leave empty if no values were provided.\n        values = Array.isArray(values)\n          ? values.map(v => String(v ?? '').trim()).filter(Boolean)\n          : [];\n      }\n    }\n\n    // Fallback: if values are still empty, try deriving from dependency outputs\n    // 1) Common pattern: outputs.<dep>.labels (e.g., from issue-assistant)\n    if (values.length === 0 && Object.keys(depOutputs).length > 0) {\n      try {\n        const lbls: string[] = [];\n        for (const obj of Object.values(depOutputs)) {\n          const labelsAny = (obj as any)?.labels;\n          if (Array.isArray(labelsAny)) {\n            for (const v of labelsAny) lbls.push(String(v ?? ''));\n          }\n        }\n        const norm = lbls\n          .map(s => s.trim())\n          .filter(Boolean)\n          .map(s => s.replace(/[^A-Za-z0-9:\\/\\- ]/g, '').replace(/\\/{2,}/g, '/'));\n        values = Array.from(new Set(norm));\n        if (process.env.VISOR_DEBUG === 'true') {\n          logger.info(`[github-ops] derived values from deps.labels: ${JSON.stringify(values)}`);\n        }\n      } catch {}\n    }\n\n    // 2) Fallback: outputs.<dep>.tags based derivation (overview-style)\n    // Fallback: if values are still empty, try deriving from dependency outputs (common pattern: outputs.<dep>.tags)\n    if (values.length === 0 && dependencyResults && dependencyResults.size > 0) {\n      try {\n        const derived: string[] = [];\n        for (const result of dependencyResults.values()) {\n          const out = (result as ReviewSummary & { output?: unknown })?.output ?? result;\n          const tags = (out as Record<string, unknown>)?.['tags'] as\n            | Record<string, unknown>\n            | undefined;\n          if (tags && typeof tags === 'object') {\n            const label = tags['label'];\n            const effort = (tags as Record<string, unknown>)['review-effort'];\n            if (label != null) derived.push(String(label));\n            if (effort !== undefined && effort !== null)\n              derived.push(`review/effort:${String(effort)}`);\n          }\n        }\n        values = derived;\n        if (process.env.VISOR_DEBUG === 'true') {\n          logger.info(`[github-ops] derived values from deps: ${JSON.stringify(values)}`);\n        }\n      } catch {}\n    }\n\n    // Trim, drop empty, and de-duplicate values regardless of source\n    values = values.map(v => v.trim()).filter(v => v.length > 0);\n    values = Array.from(new Set(values));\n\n    try {\n      // Minimal debug to help diagnose label flow under tests\n      if (process.env.NODE_ENV === 'test' || process.env.VISOR_DEBUG === 'true') {\n        logger.info(`[github-ops] ${cfg.op} resolved values: ${JSON.stringify(values)}`);\n      }\n    } catch {}\n\n    try {\n      switch (cfg.op) {\n        case 'labels.add': {\n          if (values.length === 0) break; // no-op if nothing to add\n          try {\n            if (process.env.VISOR_OUTPUT_FORMAT !== 'json')\n              logger.step(`[github-ops] labels.add -> ${JSON.stringify(values)}`);\n          } catch {}\n          await octokit.rest.issues.addLabels({\n            owner,\n            repo,\n            issue_number: prInfo.number,\n            labels: values,\n          });\n          break;\n        }\n        case 'labels.remove': {\n          for (const l of values) {\n            await octokit.rest.issues.removeLabel({\n              owner,\n              repo,\n              issue_number: prInfo.number,\n              name: l,\n            });\n          }\n          break;\n        }\n        case 'comment.create': {\n          const body = values.join('\\n').trim();\n          if (body)\n            await octokit.rest.issues.createComment({\n              owner,\n              repo,\n              issue_number: prInfo.number,\n              body,\n            });\n          break;\n        }\n        default:\n          return {\n            issues: [\n              {\n                file: 'system',\n                line: 0,\n                ruleId: 'github/unsupported_op',\n                message: `Unsupported GitHub op: ${cfg.op}`,\n                severity: 'error',\n                category: 'logic',\n              },\n            ],\n          };\n      }\n\n      return { issues: [] };\n    } catch (e) {\n      const msg = e instanceof Error ? e.message : String(e);\n      try {\n        logger.error(`[github-ops] op_failed ${cfg.op}: ${msg}`);\n      } catch {}\n      return {\n        issues: [\n          {\n            file: 'system',\n            line: 0,\n            ruleId: 'github/op_failed',\n            message: `GitHub operation failed (${cfg.op}): ${msg}`,\n            severity: 'error',\n            category: 'logic',\n          },\n        ],\n      };\n    }\n  }\n\n  /**\n   * Create a secure sandbox for evaluating small expressions without access to process/env\n   */\n  private getSecureSandbox(): Sandbox {\n    if (this.sandbox) return this.sandbox;\n    this.sandbox = createSecureSandbox();\n    return this.sandbox;\n  }\n}\n","/**\n * Type definitions for Claude Code SDK and MCP SDK\n * These are placeholder types for when the packages aren't installed\n */\n\n// Claude Code SDK types\nexport interface ClaudeCodeQuery {\n  query: string;\n  tools?: Array<{\n    name: string;\n    [key: string]: unknown;\n  }>;\n  subagent?: string;\n  maxTurns?: number;\n  systemPrompt?: string;\n  sessionId?: string;\n}\n\nexport interface ClaudeCodeResponse {\n  content: string;\n  usage?: {\n    input_tokens: number;\n    output_tokens: number;\n  };\n  turn_count?: number;\n  session_id?: string;\n}\n\nexport interface ClaudeCodeClient {\n  query(options: ClaudeCodeQuery): Promise<ClaudeCodeResponse>;\n}\n\n// MCP Server configuration interface\nexport interface McpServerConfig {\n  command: string;\n  args?: string[];\n  env?: Record<string, string>;\n}\n\n// MCP Tool interface\nexport interface McpTool {\n  name: string;\n  description?: string;\n  inputSchema?: Record<string, unknown>;\n  handler?: (args: Record<string, unknown>) => Promise<unknown>;\n}\n\n// MCP Server interface\nexport interface McpServer {\n  name: string;\n  command?: string;\n  args?: string[];\n  env?: Record<string, string>;\n  tools?: McpTool[];\n}\n\n// MCP Server Instance interface\nexport interface McpServerInstance {\n  name: string;\n  listTools(): Promise<McpTool[]>;\n  callTool(name: string, args: Record<string, unknown>): Promise<unknown>;\n  close(): Promise<void>;\n}\n\n// Claude Code configuration interface\nexport interface ClaudeCodeConfig {\n  allowedTools?: string[];\n  maxTurns?: number;\n  systemPrompt?: string;\n  mcpServers?: Record<string, McpServerConfig>;\n  subagent?: string;\n  hooks?: {\n    onStart?: string;\n    onEnd?: string;\n    onError?: string;\n  };\n}\n\n/**\n * Utility function to safely import optional dependencies\n */\nexport async function safeImport<T>(moduleName: string): Promise<T | null> {\n  try {\n    return await import(moduleName);\n  } catch {\n    return null;\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { EnvironmentResolver } from '../utils/env-resolver';\nimport { IssueFilter } from '../issue-filter';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport {\n  ClaudeCodeQuery,\n  ClaudeCodeResponse,\n  ClaudeCodeConfig,\n  ClaudeCodeClient,\n  safeImport,\n} from './claude-code-types';\n\ntype ClaudeCodeConstructor = new (options: { apiKey: string }) => ClaudeCodeClient;\n\nfunction isClaudeCodeConstructor(value: unknown): value is ClaudeCodeConstructor {\n  return typeof value === 'function';\n}\n\n/**\n * Error thrown when Claude Code SDK is not installed\n */\nexport class ClaudeCodeSDKNotInstalledError extends Error {\n  constructor() {\n    super(\n      'Claude Code SDK is not installed. Install with: npm install @anthropic/claude-code-sdk @modelcontextprotocol/sdk'\n    );\n    this.name = 'ClaudeCodeSDKNotInstalledError';\n  }\n}\n\n/**\n * Error thrown when Claude Code API key is not configured\n */\nexport class ClaudeCodeAPIKeyMissingError extends Error {\n  constructor() {\n    super(\n      'No API key found for Claude Code provider. Set CLAUDE_CODE_API_KEY or ANTHROPIC_API_KEY environment variable.'\n    );\n    this.name = 'ClaudeCodeAPIKeyMissingError';\n  }\n}\n\n/**\n * Claude Code check provider using the Claude Code TypeScript SDK\n * Supports MCP tools and streaming responses\n */\nexport class ClaudeCodeCheckProvider extends CheckProvider {\n  private liquidEngine: Liquid;\n  private claudeCodeClient: ClaudeCodeClient | null = null;\n\n  constructor() {\n    super();\n    this.liquidEngine = createExtendedLiquid();\n  }\n\n  getName(): string {\n    return 'claude-code';\n  }\n\n  getDescription(): string {\n    return 'AI-powered code review using Claude Code with MCP tools support';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'claude-code'\n    if (cfg.type !== 'claude-code') {\n      return false;\n    }\n\n    // Check for prompt\n    if (!cfg.prompt || typeof cfg.prompt !== 'string') {\n      return false;\n    }\n\n    // Validate Claude Code specific configuration\n    if (cfg.claude_code) {\n      const claudeCodeConfig = cfg.claude_code as ClaudeCodeConfig;\n\n      // Validate allowedTools if present\n      if (claudeCodeConfig.allowedTools && !Array.isArray(claudeCodeConfig.allowedTools)) {\n        return false;\n      }\n\n      // Validate maxTurns if present\n      if (claudeCodeConfig.maxTurns && typeof claudeCodeConfig.maxTurns !== 'number') {\n        return false;\n      }\n\n      // Validate systemPrompt if present\n      if (claudeCodeConfig.systemPrompt && typeof claudeCodeConfig.systemPrompt !== 'string') {\n        return false;\n      }\n\n      // Validate mcpServers if present\n      if (claudeCodeConfig.mcpServers) {\n        if (typeof claudeCodeConfig.mcpServers !== 'object') {\n          return false;\n        }\n\n        for (const serverConfig of Object.values(claudeCodeConfig.mcpServers)) {\n          if (!serverConfig.command || typeof serverConfig.command !== 'string') {\n            return false;\n          }\n          if (serverConfig.args && !Array.isArray(serverConfig.args)) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Initialize Claude Code SDK client\n   */\n  private async initializeClaudeCodeClient(): Promise<ClaudeCodeClient> {\n    if (this.claudeCodeClient) {\n      return this.claudeCodeClient;\n    }\n\n    // Use safe import to avoid TypeScript compilation errors\n    const claudeCodeModule = await safeImport<{\n      ClaudeCode?: unknown;\n      default?: { ClaudeCode?: unknown };\n    }>('@anthropic/claude-code-sdk');\n\n    if (!claudeCodeModule) {\n      throw new ClaudeCodeSDKNotInstalledError();\n    }\n\n    const ClaudeCodeCtor = claudeCodeModule.ClaudeCode || claudeCodeModule.default?.ClaudeCode;\n\n    if (!isClaudeCodeConstructor(ClaudeCodeCtor)) {\n      throw new Error('ClaudeCode class not found in @anthropic/claude-code-sdk');\n    }\n\n    // Initialize with API key from environment\n    const apiKey = process.env.CLAUDE_CODE_API_KEY || process.env.ANTHROPIC_API_KEY;\n    if (!apiKey) {\n      throw new ClaudeCodeAPIKeyMissingError();\n    }\n\n    try {\n      const client = new ClaudeCodeCtor({\n        apiKey,\n      }) as ClaudeCodeClient;\n\n      this.claudeCodeClient = client;\n      return client;\n    } catch (error) {\n      throw new Error(\n        `Failed to initialize Claude Code SDK: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Group files by their file extension for template context\n   */\n  private groupFilesByExtension(\n    files: import('../pr-analyzer').PRFile[]\n  ): Record<string, import('../pr-analyzer').PRFile[]> {\n    const grouped: Record<string, import('../pr-analyzer').PRFile[]> = {};\n\n    files.forEach(file => {\n      const parts = file.filename.split('.');\n      const ext = parts.length > 1 ? parts.pop()?.toLowerCase() || 'noext' : 'noext';\n      if (!grouped[ext]) {\n        grouped[ext] = [];\n      }\n      grouped[ext].push(file);\n    });\n\n    return grouped;\n  }\n\n  /**\n   * Process prompt configuration to resolve final prompt string\n   */\n  private async processPrompt(\n    promptConfig: string,\n    prInfo: PRInfo,\n    eventContext?: Record<string, unknown>,\n    dependencyResults?: Map<string, ReviewSummary>\n  ): Promise<string> {\n    let promptContent: string;\n\n    // Auto-detect if it's a file path or inline content\n    if (await this.isFilePath(promptConfig)) {\n      promptContent = await this.loadPromptFromFile(promptConfig);\n    } else {\n      promptContent = promptConfig;\n    }\n\n    // Process Liquid templates in the prompt\n    return await this.renderPromptTemplate(promptContent, prInfo, eventContext, dependencyResults);\n  }\n\n  /**\n   * Detect if a string is likely a file path and if the file exists\n   */\n  private async isFilePath(str: string): Promise<boolean> {\n    // Quick checks to exclude obvious non-file-path content\n    if (!str || str.trim() !== str || str.length > 512) {\n      return false;\n    }\n\n    // Exclude strings that are clearly content (contain common content indicators)\n    if (\n      /\\s{2,}/.test(str) || // Multiple consecutive spaces\n      /\\n/.test(str) || // Contains newlines\n      /^(please|analyze|review|check|find|identify|look|search)/i.test(str.trim()) || // Starts with command words\n      str.split(' ').length > 8 // Too many words for a typical file path\n    ) {\n      return false;\n    }\n\n    // For strings with path separators, be more lenient about common words\n    if (!/[\\/\\\\]/.test(str)) {\n      // Only apply strict English word filter to non-path strings\n      if (/\\b(the|and|or|but|for|with|by|from|in|on|at|as)\\b/i.test(str)) {\n        return false;\n      }\n    }\n\n    // Positive indicators for file paths\n    const hasFileExtension = /\\.[a-zA-Z0-9]{1,10}$/i.test(str);\n    const hasPathSeparators = /[\\/\\\\]/.test(str);\n    const isRelativePath = /^\\.{1,2}\\//.test(str);\n    const isAbsolutePath = path.isAbsolute(str);\n    const hasTypicalFileChars = /^[a-zA-Z0-9._\\-\\/\\\\:~]+$/.test(str);\n\n    // Must have at least one strong indicator\n    if (!(hasFileExtension || isRelativePath || isAbsolutePath || hasPathSeparators)) {\n      return false;\n    }\n\n    // Must contain only typical file path characters\n    if (!hasTypicalFileChars) {\n      return false;\n    }\n\n    // Additional validation for suspected file paths\n    try {\n      // Try to resolve and check if file exists\n      let resolvedPath: string;\n\n      if (path.isAbsolute(str)) {\n        resolvedPath = path.normalize(str);\n      } else {\n        // Resolve relative to current working directory\n        resolvedPath = path.resolve(process.cwd(), str);\n      }\n\n      // Check if file exists\n      try {\n        const stat = await fs.stat(resolvedPath);\n        return stat.isFile();\n      } catch {\n        // File doesn't exist, but might still be a valid file path format\n        return hasFileExtension && (isRelativePath || isAbsolutePath || hasPathSeparators);\n      }\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Load prompt content from file with security validation\n   */\n  private async loadPromptFromFile(promptPath: string): Promise<string> {\n    // Enforce .liquid file extension for all prompt files\n    if (!promptPath.endsWith('.liquid')) {\n      throw new Error('Prompt file must have .liquid extension');\n    }\n\n    let resolvedPath: string;\n\n    if (path.isAbsolute(promptPath)) {\n      // Absolute path - use as-is\n      resolvedPath = promptPath;\n    } else {\n      // Relative path - resolve relative to current working directory\n      resolvedPath = path.resolve(process.cwd(), promptPath);\n    }\n\n    // Security: For relative paths, ensure they don't escape the current directory\n    if (!path.isAbsolute(promptPath)) {\n      const normalizedPath = path.normalize(resolvedPath);\n      const currentDir = path.resolve(process.cwd());\n      if (!normalizedPath.startsWith(currentDir)) {\n        throw new Error('Invalid prompt file path: path traversal detected');\n      }\n    }\n\n    // Security: Check for obvious path traversal patterns\n    if (promptPath.includes('../..')) {\n      throw new Error('Invalid prompt file path: path traversal detected');\n    }\n\n    try {\n      const promptContent = await fs.readFile(resolvedPath, 'utf-8');\n      return promptContent;\n    } catch (error) {\n      throw new Error(\n        `Failed to load prompt from ${resolvedPath}: ${\n          error instanceof Error ? error.message : 'Unknown error'\n        }`\n      );\n    }\n  }\n\n  /**\n   * Render Liquid template in prompt with comprehensive context\n   */\n  private async renderPromptTemplate(\n    promptContent: string,\n    prInfo: PRInfo,\n    eventContext?: Record<string, unknown>,\n    dependencyResults?: Map<string, ReviewSummary>\n  ): Promise<string> {\n    // Create comprehensive template context with PR and event information\n    const templateContext = {\n      // PR Information\n      pr: {\n        number: prInfo.number,\n        title: prInfo.title,\n        body: prInfo.body,\n        author: prInfo.author,\n        baseBranch: prInfo.base,\n        headBranch: prInfo.head,\n        isIncremental: prInfo.isIncremental,\n        filesChanged: prInfo.files?.map(f => f.filename) || [],\n        totalAdditions: prInfo.files?.reduce((sum, f) => sum + f.additions, 0) || 0,\n        totalDeletions: prInfo.files?.reduce((sum, f) => sum + f.deletions, 0) || 0,\n        totalChanges: prInfo.files?.reduce((sum, f) => sum + f.changes, 0) || 0,\n        base: prInfo.base,\n        head: prInfo.head,\n      },\n\n      // File Details\n      files: prInfo.files || [],\n      description: prInfo.body || '',\n\n      // GitHub Event Context\n      event: eventContext\n        ? {\n            name: eventContext.event_name || 'unknown',\n            action: eventContext.action,\n            isPullRequest: !prInfo.isIssue,\n\n            // Repository Info\n            repository: eventContext.repository\n              ? {\n                  owner: (eventContext.repository as { owner?: { login?: string } })?.owner?.login,\n                  name: (eventContext.repository as { name?: string })?.name,\n                  fullName: eventContext.repository\n                    ? `${(eventContext.repository as { owner?: { login?: string } })?.owner?.login}/${(eventContext.repository as { name?: string })?.name}`\n                    : undefined,\n                }\n              : undefined,\n\n            // Comment Data (for comment events)\n            comment: eventContext.comment\n              ? {\n                  body: (eventContext.comment as { body?: string })?.body,\n                  author: (eventContext.comment as { user?: { login?: string } })?.user?.login,\n                }\n              : undefined,\n\n            // Raw event payload for advanced use cases\n            payload: eventContext,\n          }\n        : undefined,\n\n      // Utility data for templates\n      utils: {\n        // Date/time helpers\n        now: new Date().toISOString(),\n        today: new Date().toISOString().split('T')[0],\n\n        // Dynamic file grouping by extension\n        filesByExtension: this.groupFilesByExtension(prInfo.files || []),\n\n        // File status categorizations\n        addedFiles: (prInfo.files || []).filter(f => f.status === 'added'),\n        modifiedFiles: (prInfo.files || []).filter(f => f.status === 'modified'),\n        removedFiles: (prInfo.files || []).filter(f => f.status === 'removed'),\n        renamedFiles: (prInfo.files || []).filter(f => f.status === 'renamed'),\n\n        // Change analysis\n        hasLargeChanges: (prInfo.files || []).some(f => f.changes > 50),\n        totalFiles: (prInfo.files || []).length,\n      },\n\n      // Previous check outputs (dependency results)\n      // Expose raw output directly if available, otherwise expose the result as-is\n      outputs: dependencyResults\n        ? Object.fromEntries(\n            Array.from(dependencyResults.entries()).map(([checkName, result]) => [\n              checkName,\n              // If the result has a direct output field, use it directly\n              // Otherwise, expose the entire result\n              (() => {\n                const summary = result as ReviewSummary & { output?: unknown };\n                return summary.output !== undefined ? summary.output : summary;\n              })(),\n            ])\n          )\n        : {},\n    };\n\n    try {\n      return await this.liquidEngine.parseAndRender(promptContent, templateContext);\n    } catch (error) {\n      throw new Error(\n        `Failed to render prompt template: ${\n          error instanceof Error ? error.message : 'Unknown error'\n        }`\n      );\n    }\n  }\n\n  /**\n   * Parse structured response from Claude Code\n   */\n  private parseStructuredResponse(content: string): ReviewSummary {\n    try {\n      // Try to parse as JSON first\n      const parsed = JSON.parse(content);\n\n      // Convert to ReviewSummary format\n      return {\n        issues: parsed.issues || [],\n      };\n    } catch {\n      // If not JSON, treat as plain text comment\n      return {\n        issues: [],\n      };\n    }\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    sessionInfo?: { parentSessionId?: string; reuseSession?: boolean }\n  ): Promise<ReviewSummary> {\n    // Apply environment configuration if present\n    if (config.env) {\n      const result = EnvironmentResolver.withTemporaryEnv(config.env, () => {\n        return this.executeWithConfig(prInfo, config, dependencyResults, sessionInfo);\n      });\n\n      if (result instanceof Promise) {\n        return result;\n      }\n      return result;\n    }\n\n    return this.executeWithConfig(prInfo, config, dependencyResults, sessionInfo);\n  }\n\n  private async executeWithConfig(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    sessionInfo?: { parentSessionId?: string; reuseSession?: boolean }\n  ): Promise<ReviewSummary> {\n    // Extract Claude Code configuration\n    const claudeCodeConfig = (config.claude_code as ClaudeCodeConfig) || {};\n\n    // Get custom prompt from config - REQUIRED\n    const customPrompt = config.prompt;\n    if (!customPrompt) {\n      throw new Error(\n        `No prompt defined for check. All checks must have prompts defined in .visor.yaml configuration.`\n      );\n    }\n\n    // Process prompt with Liquid templates and file loading\n    const processedPrompt = await this.processPrompt(\n      customPrompt,\n      prInfo,\n      config.eventContext,\n      dependencyResults\n    );\n\n    const startTime = Date.now();\n\n    try {\n      // Initialize Claude Code client\n      const client = await this.initializeClaudeCodeClient();\n\n      // Prepare query object with MCP servers passed directly to SDK\n      const query: ClaudeCodeQuery = {\n        query: processedPrompt,\n        maxTurns: claudeCodeConfig.maxTurns || 5,\n        systemPrompt: claudeCodeConfig.systemPrompt,\n        subagent: claudeCodeConfig.subagent,\n      };\n\n      // Add allowed tools if specified\n      if (claudeCodeConfig.allowedTools && claudeCodeConfig.allowedTools.length > 0) {\n        query.tools = claudeCodeConfig.allowedTools.map(name => ({ name }));\n      }\n\n      // Pass MCP servers directly to the SDK - let it handle spawning and tool discovery\n      if (claudeCodeConfig.mcpServers && Object.keys(claudeCodeConfig.mcpServers).length > 0) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (query as any).mcpServers = claudeCodeConfig.mcpServers;\n      }\n\n      // Execute query with Claude Code\n      let response: ClaudeCodeResponse;\n\n      if (sessionInfo?.reuseSession && sessionInfo.parentSessionId) {\n        // Use session reuse if available\n        response = await client.query({\n          ...query,\n          sessionId: sessionInfo.parentSessionId,\n        });\n      } else {\n        // Create new session\n        response = await client.query(query);\n      }\n\n      // Parse the response\n      const result = this.parseStructuredResponse(response.content) as ReviewSummary & {\n        debug?: import('../ai-review-service').AIDebugInfo & {\n          sessionId?: string;\n          turnCount?: number;\n          usage?: unknown;\n          toolsUsed?: string[];\n        };\n      };\n\n      result.debug = {\n        prompt: processedPrompt,\n        rawResponse: response.content,\n        provider: 'claude-code',\n        model: 'claude-code',\n        apiKeySource: 'CLAUDE_CODE_API_KEY',\n        processingTime: Date.now() - startTime,\n        promptLength: processedPrompt.length,\n        responseLength: response.content.length,\n        jsonParseSuccess: true,\n        errors: [],\n        checksExecuted: [config.checkName || 'claude-code-check'],\n        parallelExecution: false,\n        timestamp: new Date().toISOString(),\n        // Claude Code specific debug info\n        sessionId: response.session_id,\n        turnCount: response.turn_count,\n        usage: response.usage,\n      };\n\n      // Apply issue suppression filtering\n      const suppressionEnabled = config.suppressionEnabled !== false;\n      const issueFilter = new IssueFilter(suppressionEnabled);\n      const filteredIssues = issueFilter.filterIssues(result.issues || [], process.cwd());\n\n      return {\n        ...result,\n        issues: filteredIssues,\n      };\n    } catch (error) {\n      // Re-throw setup/configuration errors that should terminate the application\n      if (\n        error instanceof ClaudeCodeSDKNotInstalledError ||\n        error instanceof ClaudeCodeAPIKeyMissingError\n      ) {\n        throw error;\n      }\n\n      const errorMessage = error instanceof Error ? error.message : String(error);\n\n      // Log detailed error information\n      console.error(`‚ùå Claude Code Check Provider Error: ${errorMessage}`);\n\n      // Check if this is a critical error\n      const isCriticalError =\n        errorMessage.includes('API rate limit') ||\n        errorMessage.includes('403') ||\n        errorMessage.includes('401') ||\n        errorMessage.includes('authentication');\n\n      if (isCriticalError) {\n        console.error(\n          `üö® CRITICAL ERROR: Claude Code provider authentication or setup issue detected`\n        );\n        console.error(\n          `üö® This check cannot proceed without valid API credentials and SDK installation`\n        );\n      }\n\n      // Re-throw with more context\n      throw new Error(`Claude Code analysis failed: ${errorMessage}`);\n    }\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'prompt',\n      'claude_code.allowedTools',\n      'claude_code.maxTurns',\n      'claude_code.systemPrompt',\n      'claude_code.mcpServers',\n      'claude_code.subagent',\n      'claude_code.hooks',\n      'env',\n      'checkName',\n      'sessionId',\n      'suppressionEnabled',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    try {\n      // Check if Claude Code API key is available\n      const hasApiKey = !!(process.env.CLAUDE_CODE_API_KEY || process.env.ANTHROPIC_API_KEY);\n\n      if (!hasApiKey) {\n        return false;\n      }\n\n      // Try to import the SDK to check if it's installed\n      const claudeCodeModule = await safeImport<{\n        ClaudeCode?: unknown;\n        default?: { ClaudeCode?: unknown };\n      }>('@anthropic/claude-code-sdk');\n      if (!claudeCodeModule) {\n        return false;\n      }\n      const ClaudeCode = claudeCodeModule.ClaudeCode || claudeCodeModule.default?.ClaudeCode;\n\n      return !!ClaudeCode;\n    } catch {\n      // If import fails, the SDK is not installed\n      return false;\n    }\n  }\n\n  getRequirements(): string[] {\n    return [\n      'CLAUDE_CODE_API_KEY or ANTHROPIC_API_KEY environment variable',\n      '@anthropic/claude-code-sdk npm package',\n      '@modelcontextprotocol/sdk npm package (for MCP support)',\n      'Network access to Claude Code API',\n    ];\n  }\n}\n","import { exec } from 'child_process';\nimport { promisify } from 'util';\nimport { logger } from '../logger';\n\nexport interface CommandExecutionOptions {\n  stdin?: string;\n  cwd?: string;\n  env?: Record<string, string>;\n  timeout?: number;\n}\n\nexport interface CommandExecutionResult {\n  stdout: string;\n  stderr: string;\n  exitCode: number;\n}\n\n/**\n * Shared utility for executing shell commands\n * Used by both CommandCheckProvider and CustomToolExecutor\n */\nexport class CommandExecutor {\n  private static instance: CommandExecutor;\n\n  private constructor() {}\n\n  static getInstance(): CommandExecutor {\n    if (!CommandExecutor.instance) {\n      CommandExecutor.instance = new CommandExecutor();\n    }\n    return CommandExecutor.instance;\n  }\n\n  /**\n   * Execute a shell command with optional stdin, environment, and timeout\n   */\n  async execute(\n    command: string,\n    options: CommandExecutionOptions = {}\n  ): Promise<CommandExecutionResult> {\n    const execAsync = promisify(exec);\n    const timeout = options.timeout || 30000;\n\n    // If stdin is provided, we need to handle it differently\n    if (options.stdin) {\n      return this.executeWithStdin(command, options);\n    }\n\n    // For commands without stdin, use the simpler promisified version\n    try {\n      const result = await execAsync(command, {\n        cwd: options.cwd,\n        env: options.env as NodeJS.ProcessEnv,\n        timeout,\n      });\n\n      return {\n        stdout: result.stdout || '',\n        stderr: result.stderr || '',\n        exitCode: 0,\n      };\n    } catch (error) {\n      return this.handleExecutionError(error, timeout);\n    }\n  }\n\n  /**\n   * Execute command with stdin input\n   */\n  private executeWithStdin(\n    command: string,\n    options: CommandExecutionOptions\n  ): Promise<CommandExecutionResult> {\n    return new Promise((resolve, reject) => {\n      const childProcess = exec(\n        command,\n        {\n          cwd: options.cwd,\n          env: options.env as NodeJS.ProcessEnv,\n          timeout: options.timeout || 30000,\n        },\n        (error, stdout, stderr) => {\n          // Check if the process was killed due to timeout\n          if (\n            error &&\n            error.killed &&\n            ((error as NodeJS.ErrnoException).code === 'ETIMEDOUT' || error.signal === 'SIGTERM')\n          ) {\n            reject(new Error(`Command timed out after ${options.timeout || 30000}ms`));\n          } else {\n            resolve({\n              stdout: stdout || '',\n              stderr: stderr || '',\n              exitCode: error ? error.code || 1 : 0,\n            });\n          }\n        }\n      );\n\n      // Write stdin and close\n      if (options.stdin && childProcess.stdin) {\n        childProcess.stdin.write(options.stdin);\n        childProcess.stdin.end();\n      }\n    });\n  }\n\n  /**\n   * Handle execution errors consistently\n   */\n  private handleExecutionError(error: unknown, timeout: number): CommandExecutionResult {\n    const execError = error as NodeJS.ErrnoException & {\n      stdout?: string;\n      stderr?: string;\n      killed?: boolean;\n      code?: string | number;\n      signal?: string;\n    };\n\n    // Check if the process was killed due to timeout\n    // Node.js sets killed: true and signal: 'SIGTERM' when timeout expires\n    if (execError.killed && (execError.code === 'ETIMEDOUT' || execError.signal === 'SIGTERM')) {\n      throw new Error(`Command timed out after ${timeout}ms`);\n    }\n\n    // Extract exit code - it might be a string or number\n    let exitCode = 1;\n    if (execError.code) {\n      exitCode = typeof execError.code === 'string' ? parseInt(execError.code, 10) : execError.code;\n    }\n\n    return {\n      stdout: execError.stdout || '',\n      stderr: execError.stderr || '',\n      exitCode,\n    };\n  }\n\n  /**\n   * Build safe environment variables by merging process.env with custom env\n   * Ensures all values are strings (no undefined)\n   */\n  buildEnvironment(\n    baseEnv: NodeJS.ProcessEnv = process.env,\n    ...customEnvs: Array<Record<string, string> | undefined>\n  ): Record<string, string> {\n    const result: Record<string, string> = {};\n\n    // Start with base environment, filtering out undefined values\n    for (const [key, value] of Object.entries(baseEnv)) {\n      if (value !== undefined) {\n        result[key] = value;\n      }\n    }\n\n    // Merge custom environments\n    for (const customEnv of customEnvs) {\n      if (customEnv) {\n        Object.assign(result, customEnv);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Log command execution for debugging\n   */\n  logExecution(command: string, options: CommandExecutionOptions): void {\n    const debugInfo = [\n      `Executing command: ${command}`,\n      options.cwd ? `cwd: ${options.cwd}` : null,\n      options.stdin ? 'with stdin' : null,\n      options.timeout ? `timeout: ${options.timeout}ms` : null,\n      options.env ? `env vars: ${Object.keys(options.env).length}` : null,\n    ]\n      .filter(Boolean)\n      .join(', ');\n\n    logger.debug(debugInfo);\n  }\n}\n\n// Export singleton instance for convenience\nexport const commandExecutor = CommandExecutor.getInstance();\n","export type EnvMap = Record<string, string>;\n\n// Default: expose all env vars except a conservative denylist.\n// If VISOR_ALLOW_ENV is set and not '*', restrict to that allowlist.\n// VISOR_DENY_ENV can further mask exact keys or prefix* patterns.\nexport function buildSandboxEnv(input: NodeJS.ProcessEnv): EnvMap {\n  const denyDefaults = [\n    'GITHUB_TOKEN',\n    'INPUT_GITHUB-TOKEN',\n    'ACTIONS_RUNTIME_TOKEN',\n    'ACTIONS_ID_TOKEN_REQUEST_TOKEN',\n    'AWS_ACCESS_KEY_ID',\n    'AWS_SECRET_ACCESS_KEY',\n    'AWS_SESSION_TOKEN',\n    'AZURE_CLIENT_SECRET',\n    'GOOGLE_APPLICATION_CREDENTIALS',\n    'OPENAI_API_KEY',\n    'ANTHROPIC_API_KEY',\n    'HUGGINGFACE_API_KEY',\n    'CLAUDE_CODE_API_KEY',\n    'PROBE_API_KEY',\n  ];\n\n  const denyExtra = (input.VISOR_DENY_ENV || '')\n    .split(',')\n    .map(s => s.trim())\n    .filter(Boolean);\n  const deny = Array.from(new Set([...denyDefaults, ...denyExtra]));\n  const allowSpec = (input.VISOR_ALLOW_ENV || '*').trim();\n\n  const denyMatch = (key: string): boolean => {\n    for (const pat of deny) {\n      if (!pat) continue;\n      if (pat.endsWith('*')) {\n        const prefix = pat.slice(0, -1);\n        if (key.startsWith(prefix)) return true;\n      } else if (key === pat) {\n        return true;\n      }\n    }\n    if (/(_TOKEN|_SECRET|_PASSWORD|_PRIVATE_KEY)$/i.test(key)) return true;\n    return false;\n  };\n\n  const out: EnvMap = {};\n  if (allowSpec !== '*') {\n    const allow = allowSpec\n      .split(',')\n      .map(s => s.trim())\n      .filter(Boolean);\n    for (const key of allow) {\n      const val = input[key];\n      if (key && val !== undefined && !denyMatch(key)) out[key] = String(val);\n    }\n    return out;\n  }\n\n  for (const [k, v] of Object.entries(input)) {\n    if (v === undefined || v === null) continue;\n    if (denyMatch(k)) continue;\n    out[k] = String(v);\n  }\n  return out;\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary, ReviewIssue } from '../reviewer';\nimport { Liquid } from 'liquidjs';\nimport Sandbox from '@nyariv/sandboxjs';\nimport { createSecureSandbox, compileAndRun } from '../utils/sandbox';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { logger } from '../logger';\nimport { commandExecutor } from '../utils/command-executor';\nimport {\n  createPermissionHelpers,\n  detectLocalMode,\n  resolveAssociationFromEvent,\n} from '../utils/author-permissions';\nimport { trace, context as otContext } from '../telemetry/lazy-otel';\nimport {\n  captureCheckInputContext,\n  captureCheckOutput,\n  captureTransformJS,\n} from '../telemetry/state-capture';\n\n/**\n * Check provider that executes shell commands and captures their output\n * Supports JSON parsing and integration with forEach functionality\n */\nexport class CommandCheckProvider extends CheckProvider {\n  private liquid: Liquid;\n  private sandbox?: Sandbox;\n\n  constructor() {\n    super();\n    this.liquid = createExtendedLiquid({\n      cache: false,\n      strictFilters: false,\n      strictVariables: false,\n    });\n    // Lazily create sandbox only when transform_js is used\n  }\n\n  private createSecureSandbox(): Sandbox {\n    return createSecureSandbox();\n  }\n\n  getName(): string {\n    return 'command';\n  }\n\n  getDescription(): string {\n    return 'Execute shell commands and capture output for processing';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Must have exec specified\n    if (!cfg.exec || typeof cfg.exec !== 'string') {\n      return false;\n    }\n\n    return true;\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    context?: import('./check-provider.interface').ExecutionContext\n  ): Promise<ReviewSummary> {\n    try {\n      logger.info(\n        `  command provider: executing check=${String((config as any).checkName || config.type)} hasTransformJs=${Boolean(\n          (config as any).transform_js\n        )}`\n      );\n    } catch {}\n    const command = config.exec as string;\n    const transform = config.transform as string | undefined;\n    const transformJs = config.transform_js as string | undefined;\n\n    // Prepare template context for Liquid rendering\n    const outputsObj = this.buildOutputContext(\n      dependencyResults,\n      config.__outputHistory as Map<string, unknown[]> | undefined\n    );\n\n    // Build outputs_raw from -raw keys in dependencyResults\n    const outputsRaw: Record<string, unknown> = {};\n    if (dependencyResults) {\n      for (const [key, value] of dependencyResults.entries()) {\n        if (typeof key !== 'string') continue;\n        if (key.endsWith('-raw')) {\n          const name = key.slice(0, -4);\n          const summary = value as ReviewSummary & { output?: unknown };\n          outputsRaw[name] = summary.output !== undefined ? summary.output : summary;\n        }\n      }\n    }\n\n    const templateContext = {\n      pr: {\n        number: prInfo.number,\n        title: prInfo.title,\n        author: prInfo.author,\n        branch: prInfo.head,\n        base: prInfo.base,\n      },\n      files: prInfo.files,\n      fileCount: prInfo.files.length,\n      outputs: outputsObj,\n      // Alias: outputs_history mirrors outputs.history for consistency\n      outputs_history: (outputsObj as any).history || {},\n      // Stage-scoped history slice based on baseline provided by runner\n      outputs_history_stage: (() => {\n        const stage: Record<string, unknown[]> = {};\n        try {\n          const base = (context as any)?.stageHistoryBase as Record<string, number> | undefined;\n          const histMap = (config as any).__outputHistory as Map<string, unknown[]> | undefined;\n          if (!base || !histMap) return stage;\n          for (const [k, v] of histMap.entries()) {\n            const start = base[k] || 0;\n            const arr = Array.isArray(v) ? (v as unknown[]) : [];\n            stage[k] = arr.slice(start);\n          }\n        } catch {}\n        return stage;\n      })(),\n      // New: outputs_raw exposes aggregate values (e.g., full arrays for forEach parents)\n      outputs_raw: outputsRaw,\n      // Workflow inputs (when executing within a workflow)\n      inputs: context?.workflowInputs || {},\n      env: this.getSafeEnvironmentVariables(),\n    };\n\n    logger.debug(\n      `üîß Debug: Template outputs keys: ${Object.keys(templateContext.outputs || {}).join(', ')}`\n    );\n\n    // Capture input context in active OTEL span\n    try {\n      const span = trace.getSpan(otContext.active());\n      if (span) {\n        captureCheckInputContext(span, templateContext);\n      }\n    } catch {\n      // Ignore telemetry errors\n    }\n    // Fallback NDJSON for input context (non-OTEL environments)\n    try {\n      const checkId = (config as any).checkName || (config as any).id || 'unknown';\n      const ctxJson = JSON.stringify(templateContext);\n      const { emitNdjsonSpanWithEvents } = require('../telemetry/fallback-ndjson');\n      // Emit both start and completion markers together for deterministic E2E assertions\n      emitNdjsonSpanWithEvents(\n        'visor.check',\n        { 'visor.check.id': checkId, 'visor.check.input.context': ctxJson },\n        [{ name: 'check.started' }, { name: 'check.completed' }]\n      );\n    } catch {}\n\n    // Test hook: mock output for this step (short-circuit execution)\n    try {\n      const stepName = (config as any).checkName || 'unknown';\n      const rawMock = context?.hooks?.mockForStep?.(String(stepName));\n      if (rawMock !== undefined) {\n        // Normalize primitive mocks into object form\n        let mock: any;\n        if (typeof rawMock === 'number') {\n          mock = { exit_code: Number(rawMock) };\n        } else if (typeof rawMock === 'string') {\n          mock = { stdout: String(rawMock) };\n        } else {\n          mock = rawMock as Record<string, unknown>;\n        }\n        const m = mock as { stdout?: string; stderr?: string; exit_code?: number; exit?: number };\n        let out: unknown = m.stdout ?? '';\n        try {\n          if (\n            typeof out === 'string' &&\n            (out.trim().startsWith('{') || out.trim().startsWith('['))\n          ) {\n            out = JSON.parse(out);\n          }\n        } catch {}\n        const code =\n          typeof m.exit_code === 'number' ? m.exit_code : typeof m.exit === 'number' ? m.exit : 0;\n        if (code !== 0) {\n          return {\n            issues: [\n              {\n                file: 'command',\n                line: 0,\n                ruleId: 'command/execution_error',\n                message: `Mocked command exited with code ${code}`,\n                severity: 'error',\n                category: 'logic',\n              },\n            ],\n            output: out,\n          } as any;\n        }\n        return { issues: [], output: out } as any;\n      }\n    } catch {}\n\n    try {\n      // Render the command with Liquid templates if needed\n      let renderedCommand = command;\n      if (command.includes('{{') || command.includes('{%')) {\n        renderedCommand = await this.renderCommandTemplate(command, templateContext);\n      }\n      logger.debug(`üîß Debug: Rendered command: ${renderedCommand}`);\n\n      // Prepare environment variables - convert all to strings\n      const scriptEnv: Record<string, string> = {};\n      for (const [key, value] of Object.entries(process.env)) {\n        if (value !== undefined) {\n          scriptEnv[key] = value;\n        }\n      }\n      if (config.env) {\n        for (const [key, value] of Object.entries(config.env)) {\n          if (value !== undefined && value !== null) {\n            scriptEnv[key] = String(value);\n          }\n        }\n      }\n\n      // Get timeout from config (in seconds) or use default (60 seconds)\n      const timeoutSeconds = (config.timeout as number) || 60;\n      const timeoutMs = timeoutSeconds * 1000;\n\n      // Normalize only the eval payload for `node -e|--eval` invocations that may contain\n      // literal newlines due to YAML processing (\"\\n\" -> newline). We re-escape newlines\n      // inside the quoted eval argument to keep JS string literals valid, without touching\n      // the rest of the command.\n      const normalizeNodeEval = (cmd: string): string => {\n        const re =\n          /^(?<prefix>\\s*(?:\\/usr\\/bin\\/env\\s+)?node(?:\\.exe)?\\s+(?:-e|--eval)\\s+)(['\"])([\\s\\S]*?)\\2(?<suffix>\\s|$)/;\n        const m = cmd.match(re) as\n          | (RegExpMatchArray & { groups?: { prefix: string; suffix?: string } })\n          | null;\n        if (!m || !m.groups) return cmd;\n        const prefix = m.groups.prefix;\n        const quote = m[2];\n        const code = m[3];\n        const suffix = m.groups.suffix || '';\n        if (!code.includes('\\n')) return cmd;\n        const escaped = code.replace(/\\n/g, '\\\\n');\n        return cmd.replace(re, `${prefix}${quote}${escaped}${quote}${suffix}`);\n      };\n\n      const safeCommand = normalizeNodeEval(renderedCommand);\n\n      // Use shared command executor\n      const execResult = await commandExecutor.execute(safeCommand, {\n        env: scriptEnv,\n        timeout: timeoutMs,\n      });\n\n      const { stdout, stderr, exitCode } = execResult;\n\n      if (stderr) {\n        logger.debug(`Command stderr: ${stderr}`);\n      }\n\n      // Check for non-zero exit code\n      if (exitCode !== 0) {\n        const errorMessage = stderr || `Command exited with code ${exitCode}`;\n        logger.error(`Command failed with exit code ${exitCode}: ${errorMessage}`);\n        return {\n          issues: [\n            {\n              file: 'command',\n              line: 0,\n              ruleId: 'command/execution_error',\n              message: `Command execution failed: ${errorMessage}`,\n              severity: 'error',\n              category: 'logic',\n            },\n          ],\n        };\n      }\n\n      // Keep raw output for transforms\n      const rawOutput = stdout.trim();\n\n      // Try to parse output as JSON for default behavior\n      // no debug\n      let output: unknown = rawOutput;\n      try {\n        // Attempt to parse as JSON\n        const parsed = JSON.parse(rawOutput);\n        output = parsed;\n        logger.debug(`üîß Debug: Parsed entire output as JSON successfully`);\n      } catch {\n        // Try to extract JSON from the end of output (for commands with debug logs)\n        const extractedTail = this.extractJsonFromEnd(rawOutput);\n        if (extractedTail) {\n          try {\n            output = JSON.parse(extractedTail);\n          } catch {\n            output = rawOutput;\n          }\n        } else {\n          // Try to extract any balanced JSON substring anywhere\n          const extractedAny = this.extractJsonAnywhere(rawOutput);\n          if (extractedAny) {\n            try {\n              output = JSON.parse(extractedAny);\n            } catch {\n              output = rawOutput;\n            }\n          } else {\n            // Last resort: detect common boolean flags like error:true or error=false for fail_if gating\n            const m = /\\berror\\b\\s*[:=]\\s*(true|false)/i.exec(rawOutput);\n            if (m) {\n              output = { error: m[1].toLowerCase() === 'true' } as any;\n            } else {\n              output = rawOutput;\n            }\n          }\n        }\n      }\n\n      // Log the parsed structure for debugging\n      // no debug\n\n      // Apply transform if specified (Liquid or JavaScript)\n      let finalOutput = output;\n\n      // First apply Liquid transform if present\n      if (transform) {\n        try {\n          const transformContext = {\n            ...templateContext,\n            output: output, // Use parsed output for Liquid (object if JSON, string otherwise)\n          };\n          const rendered = await this.liquid.parseAndRender(transform, transformContext);\n\n          // Try to parse the transformed result as JSON\n          try {\n            finalOutput = JSON.parse(rendered.trim());\n            logger.verbose(`‚úì Applied Liquid transform successfully (parsed as JSON)`);\n          } catch {\n            finalOutput = rendered.trim();\n            logger.verbose(`‚úì Applied Liquid transform successfully (string output)`);\n          }\n        } catch (error) {\n          logger.error(\n            `‚úó Failed to apply Liquid transform: ${error instanceof Error ? error.message : 'Unknown error'}`\n          );\n          return {\n            issues: [\n              {\n                file: 'command',\n                line: 0,\n                ruleId: 'command/transform_error',\n                message: `Failed to apply Liquid transform: ${error instanceof Error ? error.message : 'Unknown error'}`,\n                severity: 'error',\n                category: 'logic',\n              },\n            ],\n          };\n        }\n      }\n\n      // Then apply JavaScript transform if present\n      if (transformJs) {\n        try {\n          // For transform_js, provide a JSON-smart wrapper that:\n          //  - behaves like a string when coerced (so JSON.parse(output) still works)\n          //  - exposes parsed JSON properties if stdout is valid JSON (so output.key works)\n          const jsContext = {\n            output: this.makeJsonSmart(rawOutput),\n            pr: templateContext.pr,\n            files: templateContext.files,\n            outputs: this.makeOutputsJsonSmart(templateContext.outputs),\n            inputs: templateContext.inputs || {},\n            env: templateContext.env,\n            permissions: createPermissionHelpers(\n              resolveAssociationFromEvent((prInfo as any).eventContext, prInfo.authorAssociation),\n              detectLocalMode()\n            ),\n          };\n\n          // Compile and execute the JavaScript expression\n          // Use direct property access instead of destructuring to avoid syntax issues\n          const trimmedTransform = transformJs.trim();\n          // Build a safe function body that supports statements + implicit last-expression return.\n          const buildBodyWithReturn = (raw: string): string => {\n            const t = raw.trim();\n            // Find last non-empty line\n            const lines = t.split(/\\n/);\n            let i = lines.length - 1;\n            while (i >= 0 && lines[i].trim().length === 0) i--;\n            if (i < 0) return 'return undefined;';\n            const lastLine = lines[i].trim();\n            if (/^return\\b/i.test(lastLine)) {\n              return t;\n            }\n            const idx = t.lastIndexOf(lastLine);\n            const head = idx >= 0 ? t.slice(0, idx) : '';\n            const lastExpr = lastLine.replace(/;\\s*$/, '');\n            return `${head}\\nreturn (${lastExpr});`;\n          };\n          const bodyWithReturn = buildBodyWithReturn(trimmedTransform);\n\n          const code = `\n            const output = scope.output;\n            const pr = scope.pr;\n            const files = scope.files;\n            const outputs = scope.outputs;\n            const inputs = scope.inputs;\n            const env = scope.env;\n            const log = (...args) => { console.log('üîç Debug:', ...args); };\n            const hasMinPermission = scope.permissions.hasMinPermission;\n            const isOwner = scope.permissions.isOwner;\n            const isMember = scope.permissions.isMember;\n            const isCollaborator = scope.permissions.isCollaborator;\n            const isContributor = scope.permissions.isContributor;\n            const isFirstTimer = scope.permissions.isFirstTimer;\n            const __result = (function(){\n${bodyWithReturn}\n            })();\n            return __result;\n          `;\n\n          // Execute user code exclusively inside the sandbox\n          if (!this.sandbox) {\n            this.sandbox = this.createSecureSandbox();\n          }\n          // Try to serialize result to JSON string inside sandbox to preserve primitives like booleans\n          let parsedFromSandboxJson: any = undefined;\n          try {\n            const stringifyCode = `\n              const output = scope.output;\n              const pr = scope.pr;\n              const files = scope.files;\n              const outputs = scope.outputs;\n              const env = scope.env;\n              const log = (...args) => { console.log('üîç Debug:', ...args); };\n              const hasMinPermission = scope.permissions.hasMinPermission;\n              const isOwner = scope.permissions.isOwner;\n              const isMember = scope.permissions.isMember;\n              const isCollaborator = scope.permissions.isCollaborator;\n              const isContributor = scope.permissions.isContributor;\n              const isFirstTimer = scope.permissions.isFirstTimer;\n              const __ret = (function(){\n${bodyWithReturn}\n              })();\n              return typeof __ret === 'object' && __ret !== null ? JSON.stringify(__ret) : null;\n            `;\n            const stringifyExec = this.sandbox.compile(stringifyCode);\n            const jsonStr = stringifyExec({ scope: jsContext }).run();\n            if (typeof jsonStr === 'string' && jsonStr.trim().startsWith('{')) {\n              parsedFromSandboxJson = JSON.parse(jsonStr);\n            }\n          } catch {}\n\n          if (parsedFromSandboxJson !== undefined) {\n            finalOutput = parsedFromSandboxJson;\n          } else {\n            finalOutput = compileAndRun<unknown>(\n              this.sandbox,\n              code,\n              { scope: jsContext },\n              { injectLog: false, wrapFunction: false }\n            );\n          }\n\n          // Fallback: if sandbox could not preserve primitives (e.g., booleans lost),\n          // attempt to re-evaluate the transform in a locked Node VM context to get plain JS values.\n          try {\n            if (\n              finalOutput &&\n              typeof finalOutput === 'object' &&\n              !Array.isArray(finalOutput) &&\n              ((finalOutput as any).error === undefined ||\n                (finalOutput as any).issues === undefined)\n            ) {\n              const vm = await import('node:vm');\n              const vmContext = vm.createContext({ scope: jsContext });\n              const vmCode = `\n                (function(){\n                  const output = scope.output; const pr = scope.pr; const files = scope.files; const outputs = scope.outputs; const env = scope.env; const log = ()=>{};\n${bodyWithReturn}\n                })()\n              `;\n              const vmResult = vm.runInContext(vmCode, vmContext, { timeout: 1000 });\n              if (vmResult && typeof vmResult === 'object') {\n                finalOutput = vmResult;\n              }\n            }\n          } catch {}\n          // Create a plain JSON snapshot of the transform result to avoid proxy/getter surprises\n          // Prefer JSON stringify inside the sandbox realm (so it knows how to serialize its own objects),\n          // then fall back to host-side JSON clone and finally to a shallow copy of own enumerable properties.\n          let finalSnapshot: Record<string, unknown> | null = null;\n          try {\n            if (finalOutput && typeof finalOutput === 'object' && !Array.isArray(finalOutput)) {\n              // Try realm-local stringify first\n              try {\n                const stringifyExec = this.sandbox!.compile('return JSON.stringify(scope.obj);');\n                const jsonStr = stringifyExec({ obj: finalOutput }).run();\n                if (typeof jsonStr === 'string' && jsonStr.trim().startsWith('{')) {\n                  finalSnapshot = JSON.parse(jsonStr);\n                }\n              } catch {}\n              if (!finalSnapshot) {\n                try {\n                  finalSnapshot = JSON.parse(JSON.stringify(finalOutput));\n                } catch {}\n              }\n              if (!finalSnapshot) {\n                const tmp: Record<string, unknown> = {};\n                for (const k of Object.keys(finalOutput as Record<string, unknown>)) {\n                  (tmp as any)[k] = (finalOutput as any)[k];\n                }\n                finalSnapshot = tmp;\n              }\n            }\n          } catch {}\n          // @ts-ignore store for later extraction path\n          (this as any).__lastTransformSnapshot = finalSnapshot;\n          try {\n            const isObj =\n              finalOutput && typeof finalOutput === 'object' && !Array.isArray(finalOutput);\n            const keys = isObj\n              ? Object.keys(finalOutput as Record<string, unknown>).join(',')\n              : typeof finalOutput;\n            logger.debug(\n              `  transform_js: output typeof=${Array.isArray(finalOutput) ? 'array' : typeof finalOutput} keys=${keys}`\n            );\n            if (isObj && (finalOutput as any).issues) {\n              const mi: any = (finalOutput as any).issues;\n              logger.debug(\n                `  transform_js: issues typeof=${Array.isArray(mi) ? 'array' : typeof mi} len=${(mi && mi.length) || 0}`\n              );\n            }\n            try {\n              if (isObj)\n                logger.debug(`  transform_js: error value=${String((finalOutput as any).error)}`);\n            } catch {}\n          } catch {}\n\n          logger.verbose(`‚úì Applied JavaScript transform successfully`);\n          // Already normalized in sandbox result\n          // no debug\n        } catch (error) {\n          logger.error(\n            `‚úó Failed to apply JavaScript transform: ${error instanceof Error ? error.message : 'Unknown error'}`\n          );\n          return {\n            issues: [\n              {\n                file: 'command',\n                line: 0,\n                ruleId: 'command/transform_js_error',\n                message: `Failed to apply JavaScript transform: ${error instanceof Error ? error.message : 'Unknown error'}`,\n                severity: 'error',\n                category: 'logic',\n              },\n            ],\n          };\n        }\n      }\n\n      // Extract structured issues when the command returns them (skip for forEach parents)\n      // no debug\n      let issues: ReviewIssue[] = [];\n      let outputForDependents: unknown = finalOutput;\n      // Capture a shallow snapshot created earlier if available (within transform_js path)\n      // @ts-ignore - finalSnapshot is defined in the transform_js scope above when applicable\n      // @ts-ignore retrieve snapshot captured after transform_js (if any)\n      const snapshotForExtraction: Record<string, unknown> | null =\n        (this as any).__lastTransformSnapshot || null;\n      try {\n        if (snapshotForExtraction) {\n          logger.debug(`  provider: snapshot keys=${Object.keys(snapshotForExtraction).join(',')}`);\n        } else {\n          logger.debug(`  provider: snapshot is null`);\n        }\n      } catch {}\n      // Some shells may wrap JSON output inside a one-element array due to quoting.\n      // If we see a single-element array containing a JSON string or object, unwrap it.\n      try {\n        if (Array.isArray(outputForDependents) && (outputForDependents as unknown[]).length === 1) {\n          const first = (outputForDependents as unknown[])[0];\n          if (typeof first === 'string') {\n            try {\n              outputForDependents = JSON.parse(first);\n            } catch {}\n          } else if (first && typeof first === 'object') {\n            outputForDependents = first as unknown;\n          }\n        }\n      } catch {}\n\n      let content: string | undefined;\n      let extracted: { issues: ReviewIssue[]; remainingOutput: unknown } | null = null;\n\n      const trimmedRawOutput = typeof rawOutput === 'string' ? rawOutput.trim() : undefined;\n\n      const commandConfig = config as CheckProviderConfig & { forEach?: boolean };\n      const isForEachParent = commandConfig.forEach === true;\n\n      if (!isForEachParent) {\n        // Generic: if transform output is an object and contains an 'issues' field,\n        // expose all other fields to dependents regardless of whether we successfully\n        // normalized the issues array. This preserves flags like 'error' for fail_if.\n        try {\n          const baseObj = (snapshotForExtraction || (finalOutput as any)) as Record<\n            string,\n            unknown\n          >;\n          if (\n            baseObj &&\n            typeof baseObj === 'object' &&\n            Object.prototype.hasOwnProperty.call(baseObj, 'issues')\n          ) {\n            const remaining = { ...baseObj } as Record<string, unknown>;\n            delete (remaining as any).issues;\n            outputForDependents = Object.keys(remaining).length > 0 ? remaining : undefined;\n            try {\n              const k =\n                outputForDependents && typeof outputForDependents === 'object'\n                  ? Object.keys(outputForDependents as any).join(',')\n                  : String(outputForDependents);\n              logger.debug(`  provider: generic-remaining keys=${k}`);\n            } catch {}\n          }\n        } catch {}\n        // Fast path for transform_js objects that include an issues array (realm-agnostic)\n        const objForExtraction = (snapshotForExtraction || (finalOutput as any)) as Record<\n          string,\n          unknown\n        >;\n        if (objForExtraction && typeof objForExtraction === 'object') {\n          try {\n            const rec = objForExtraction;\n            const maybeIssues: any = (rec as any).issues;\n            const toPlainArray = (v: any): any[] | null => {\n              if (Array.isArray(v)) return v;\n              try {\n                if (v && typeof v === 'object' && typeof v[Symbol.iterator] === 'function') {\n                  return Array.from(v);\n                }\n              } catch {}\n              const len = Number((v || {}).length);\n              if (Number.isFinite(len) && len >= 0) {\n                const arr: any[] = [];\n                for (let i = 0; i < len; i++) arr.push(v[i]);\n                return arr;\n              }\n              try {\n                const cloned = JSON.parse(JSON.stringify(v));\n                return Array.isArray(cloned) ? cloned : null;\n              } catch {\n                return null;\n              }\n            };\n            try {\n              const ctor =\n                maybeIssues && (maybeIssues as any).constructor\n                  ? (maybeIssues as any).constructor.name\n                  : 'unknown';\n              logger.debug(\n                `  provider: issues inspect typeof=${typeof maybeIssues} Array.isArray=${Array.isArray(\n                  maybeIssues\n                )} ctor=${ctor} keys=${Object.keys((maybeIssues || {}) as any).join(',')}`\n              );\n            } catch {}\n            const arr = toPlainArray(maybeIssues);\n            if (arr) {\n              const norm = this.normalizeIssueArray(arr);\n              if (norm) {\n                issues = norm;\n                const remaining = { ...rec } as Record<string, unknown>;\n                delete (remaining as any).issues;\n                outputForDependents = Object.keys(remaining).length > 0 ? remaining : undefined;\n                try {\n                  const keys =\n                    outputForDependents && typeof outputForDependents === 'object'\n                      ? Object.keys(outputForDependents as any).join(',')\n                      : String(outputForDependents);\n                  logger.info(\n                    `  provider: fast-path issues=${issues.length} remaining keys=${keys}`\n                  );\n                } catch {}\n              } else {\n                try {\n                  logger.info('  provider: fast-path norm failed');\n                } catch {}\n              }\n            } else {\n              try {\n                logger.info('  provider: fast-path arr unavailable');\n              } catch {}\n            }\n          } catch {}\n        }\n        // Normalize extraction target: unwrap one-element arrays like [\"{...}\"] or [{...}]\n        let extractionTarget: unknown = snapshotForExtraction || finalOutput;\n        try {\n          if (Array.isArray(extractionTarget) && (extractionTarget as unknown[]).length === 1) {\n            const first = (extractionTarget as unknown[])[0];\n            if (typeof first === 'string') {\n              try {\n                extractionTarget = JSON.parse(first);\n              } catch {\n                extractionTarget = first;\n              }\n            } else if (first && typeof first === 'object') {\n              extractionTarget = first as unknown;\n            }\n          }\n        } catch {}\n        extracted = this.extractIssuesFromOutput(extractionTarget);\n        try {\n          if (extractionTarget !== (snapshotForExtraction || finalOutput)) {\n            finalOutput = extractionTarget;\n          }\n        } catch {}\n        // no debug\n        // Handle cross-realm Arrays from sandbox: issues may look like an array but fail Array.isArray\n        if (!extracted && finalOutput && typeof finalOutput === 'object') {\n          try {\n            const rec = finalOutput as Record<string, unknown>;\n            const maybeIssues: any = (rec as any).issues;\n            if (maybeIssues && typeof maybeIssues === 'object') {\n              let arr: any[] | null = null;\n              // Prefer iterator if present\n              try {\n                if (typeof maybeIssues[Symbol.iterator] === 'function') {\n                  arr = Array.from(maybeIssues);\n                }\n              } catch {}\n              // Fallback to length-based copy\n              if (!arr) {\n                const len = Number((maybeIssues as any).length);\n                if (Number.isFinite(len) && len >= 0) {\n                  arr = [];\n                  for (let i = 0; i < len; i++) arr.push(maybeIssues[i]);\n                }\n              }\n              // Last resort: JSON clone\n              if (!arr) {\n                try {\n                  arr = JSON.parse(JSON.stringify(maybeIssues));\n                } catch {}\n              }\n              if (arr && Array.isArray(arr)) {\n                const norm = this.normalizeIssueArray(arr);\n                if (norm) {\n                  issues = norm;\n                  const remaining = { ...rec } as Record<string, unknown>;\n                  delete (remaining as any).issues;\n                  outputForDependents = Object.keys(remaining).length > 0 ? remaining : undefined;\n                }\n              }\n            }\n          } catch {}\n        }\n        if (!extracted && typeof finalOutput === 'string') {\n          // Attempt to parse string output as JSON and extract issues again\n          try {\n            const parsed = JSON.parse(finalOutput);\n            extracted = this.extractIssuesFromOutput(parsed);\n            if (extracted) {\n              issues = extracted.issues;\n              outputForDependents = extracted.remainingOutput;\n              // If remainingOutput carries a content field, pick it up\n              if (\n                typeof extracted.remainingOutput === 'object' &&\n                extracted.remainingOutput !== null &&\n                typeof (extracted.remainingOutput as any).content === 'string'\n              ) {\n                const c = String((extracted.remainingOutput as any).content).trim();\n                if (c) content = c;\n              }\n            }\n          } catch {\n            // Try to salvage JSON from anywhere within the string (stripped logs/ansi)\n            try {\n              const any = this.extractJsonAnywhere(finalOutput);\n              if (any) {\n                const parsed = JSON.parse(any);\n                extracted = this.extractIssuesFromOutput(parsed);\n                if (extracted) {\n                  issues = extracted.issues;\n                  outputForDependents = extracted.remainingOutput;\n                  if (\n                    typeof extracted.remainingOutput === 'object' &&\n                    extracted.remainingOutput !== null &&\n                    typeof (extracted.remainingOutput as any).content === 'string'\n                  ) {\n                    const c = String((extracted.remainingOutput as any).content).trim();\n                    if (c) content = c;\n                  }\n                }\n              }\n            } catch {\n              // leave as-is\n            }\n          }\n        } else if (extracted) {\n          issues = extracted.issues;\n          outputForDependents = extracted.remainingOutput;\n          // Also propagate embedded content when remainingOutput is an object { content, ... }\n          if (\n            typeof extracted.remainingOutput === 'object' &&\n            extracted.remainingOutput !== null &&\n            typeof (extracted.remainingOutput as any).content === 'string'\n          ) {\n            const c = String((extracted.remainingOutput as any).content).trim();\n            if (c) content = c;\n          }\n        }\n\n        if (!issues.length && this.shouldTreatAsTextOutput(trimmedRawOutput)) {\n          content = trimmedRawOutput;\n        } else if (issues.length && typeof extracted?.remainingOutput === 'string') {\n          const trimmed = extracted.remainingOutput.trim();\n          if (trimmed) {\n            content = trimmed;\n          }\n        }\n\n        // Generic fallback: if issues are still empty, try to parse raw stdout as JSON and extract issues.\n        if (!issues.length && typeof trimmedRawOutput === 'string') {\n          try {\n            const tryParsed = JSON.parse(trimmedRawOutput);\n            const reextract = this.extractIssuesFromOutput(tryParsed);\n            if (reextract && reextract.issues && reextract.issues.length) {\n              issues = reextract.issues;\n              if (!outputForDependents && reextract.remainingOutput) {\n                outputForDependents = reextract.remainingOutput;\n              }\n            } else if (Array.isArray(tryParsed)) {\n              // Treat parsed array as potential issues array or array of { issues: [...] }\n              const first = tryParsed[0];\n              if (first && typeof first === 'object' && Array.isArray((first as any).issues)) {\n                const merged: unknown[] = [];\n                for (const el of tryParsed as unknown[]) {\n                  if (el && typeof el === 'object' && Array.isArray((el as any).issues)) {\n                    merged.push(...((el as any).issues as unknown[]));\n                  }\n                }\n                const flat = this.normalizeIssueArray(merged);\n                if (flat) issues = flat;\n              } else {\n                // Try to parse string elements into JSON objects and extract\n                const converted: unknown[] = [];\n                for (const el of tryParsed as unknown[]) {\n                  if (typeof el === 'string') {\n                    try {\n                      const obj = JSON.parse(el);\n                      converted.push(obj);\n                    } catch {\n                      // keep as-is\n                    }\n                  } else {\n                    converted.push(el);\n                  }\n                }\n                const flat = this.normalizeIssueArray(converted as unknown[]);\n                if (flat) issues = flat;\n              }\n            }\n          } catch {}\n          if (!issues.length) {\n            try {\n              const any = this.extractJsonAnywhere(trimmedRawOutput);\n              if (any) {\n                const tryParsed = JSON.parse(any);\n                const reextract = this.extractIssuesFromOutput(tryParsed);\n                if (reextract && reextract.issues && reextract.issues.length) {\n                  issues = reextract.issues;\n                  if (!outputForDependents && reextract.remainingOutput) {\n                    outputForDependents = reextract.remainingOutput;\n                  }\n                }\n              }\n            } catch {}\n          }\n        }\n\n        // Preserve all primitive flags (boolean/number/string) from original transform output\n        try {\n          const srcObj = (snapshotForExtraction || (finalOutput as any)) as Record<string, unknown>;\n          if (\n            outputForDependents &&\n            typeof outputForDependents === 'object' &&\n            srcObj &&\n            typeof srcObj === 'object'\n          ) {\n            for (const k of Object.keys(srcObj)) {\n              const v: any = (srcObj as any)[k];\n              if (typeof v === 'boolean' || typeof v === 'number' || typeof v === 'string') {\n                (outputForDependents as any)[k] = v;\n              }\n            }\n          }\n        } catch {}\n\n        // Normalize output object to a plain shallow object (avoid JSON stringify drop of false booleans)\n        try {\n          if (\n            outputForDependents &&\n            typeof outputForDependents === 'object' &&\n            !Array.isArray(outputForDependents)\n          ) {\n            const plain: Record<string, unknown> = {};\n            for (const k of Object.keys(outputForDependents as any)) {\n              (plain as any)[k] = (outputForDependents as any)[k];\n            }\n            outputForDependents = plain;\n          }\n        } catch {}\n      }\n\n      if (!content && this.shouldTreatAsTextOutput(trimmedRawOutput) && !isForEachParent) {\n        content = trimmedRawOutput;\n      }\n\n      // Normalize output object to plain JSON to avoid cross-realm proxy quirks\n      try {\n        if (outputForDependents && typeof outputForDependents === 'object') {\n          outputForDependents = JSON.parse(JSON.stringify(outputForDependents));\n        }\n      } catch {}\n\n      // Promote primitive flags from original transform output to top-level result fields (schema-agnostic)\n      const promoted: Record<string, unknown> = {};\n      try {\n        const srcObj = (snapshotForExtraction || (finalOutput as any)) as Record<string, unknown>;\n        if (srcObj && typeof srcObj === 'object') {\n          for (const k of Object.keys(srcObj)) {\n            const v: any = (srcObj as any)[k];\n            if (typeof v === 'boolean') {\n              if (v === true && promoted[k] === undefined) promoted[k] = true;\n            } else if (\n              (typeof v === 'number' || typeof v === 'string') &&\n              promoted[k] === undefined\n            ) {\n              promoted[k] = v;\n            }\n          }\n        }\n      } catch {}\n\n      // Return the output and issues as part of the review summary so dependent checks can use them\n      const result = {\n        issues,\n        output: outputForDependents,\n        ...(content ? { content } : {}),\n        ...promoted,\n      } as ReviewSummary;\n\n      // Capture output and transform details in active OTEL span\n      try {\n        const span = trace.getSpan(otContext.active());\n        if (span) {\n          captureCheckOutput(span, outputForDependents);\n          if (transformJs && output !== finalOutput) {\n            captureTransformJS(span, transformJs, output, finalOutput);\n          }\n        }\n      } catch {\n        // Ignore telemetry errors\n      }\n      // Fallback NDJSON for output (non-OTEL environments)\n      try {\n        const checkId = (config as any).checkName || (config as any).id || 'unknown';\n        const outJson = JSON.stringify((result as any).output ?? result);\n        const { emitNdjsonSpanWithEvents } = require('../telemetry/fallback-ndjson');\n        emitNdjsonSpanWithEvents(\n          'visor.check',\n          { 'visor.check.id': checkId, 'visor.check.output': outJson },\n          [{ name: 'check.started' }, { name: 'check.completed' }]\n        );\n      } catch {}\n\n      // Attach raw transform object only when transform_js was used (avoid polluting plain command outputs)\n      try {\n        if (transformJs) {\n          const rawObj = (snapshotForExtraction || (finalOutput as any)) as Record<string, unknown>;\n          if (rawObj && typeof rawObj === 'object') {\n            (result as any).__raw = rawObj;\n          }\n        }\n      } catch {}\n\n      // Final safeguard: ensure primitive flags from original transform output are present in result.output.\n      // Do this without dropping explicit false values (important for fail_if like `output.error`).\n      try {\n        const srcObj = (snapshotForExtraction || (finalOutput as any)) as Record<string, unknown>;\n        const srcErr = ((): boolean | undefined => {\n          try {\n            if (\n              snapshotForExtraction &&\n              typeof snapshotForExtraction === 'object' &&\n              (snapshotForExtraction as any).error !== undefined\n            ) {\n              return Boolean((snapshotForExtraction as any).error);\n            }\n            if (\n              finalOutput &&\n              typeof finalOutput === 'object' &&\n              (finalOutput as any).error !== undefined\n            ) {\n              return Boolean((finalOutput as any).error);\n            }\n          } catch {}\n          return undefined;\n        })();\n        const dst = (result as any).output;\n        if (srcObj && typeof srcObj === 'object' && dst && typeof dst === 'object') {\n          try {\n            logger.debug(\n              `  provider: safeguard src.error typeof=${typeof (srcObj as any).error} val=${String((srcObj as any).error)} dst.hasErrorBefore=${String((dst as any).error !== undefined)}`\n            );\n          } catch {}\n          for (const k of Object.keys(srcObj)) {\n            const v: any = (srcObj as any)[k];\n            if (typeof v === 'boolean' || typeof v === 'number' || typeof v === 'string') {\n              (dst as any)[k] = v;\n            }\n          }\n          // Explicitly normalize a common flag used in tests/pipelines\n          if (srcErr !== undefined && (dst as any).error === undefined) {\n            (dst as any).error = srcErr;\n            try {\n              const k = Object.keys(dst as any).join(',');\n              logger.debug(\n                `  provider: safeguard merged error -> output keys=${k} val=${String((dst as any).error)}`\n              );\n            } catch {}\n          }\n        }\n      } catch {}\n\n      try {\n        const out: any = (result as any).output;\n        if (out && typeof out === 'object') {\n          const k = Object.keys(out as Record<string, unknown>).join(',');\n          logger.debug(`  provider: return output keys=${k}`);\n        } else {\n          logger.debug(`  provider: return output type=${typeof out}`);\n        }\n      } catch {}\n\n      // no debug\n\n      return result;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\n      // Check if this is a timeout error\n      let isTimeout = false;\n      if (error && typeof error === 'object') {\n        const execError = error as { killed?: boolean; signal?: string; code?: string | number };\n        // Node's child_process sets killed=true and signal='SIGTERM' on timeout\n        if (execError.killed && execError.signal === 'SIGTERM') {\n          isTimeout = true;\n        }\n        // Some versions may also set code to 'ETIMEDOUT'\n        if (execError.code === 'ETIMEDOUT') {\n          isTimeout = true;\n        }\n      }\n\n      // Extract stderr from the error if available (child_process errors include stdout/stderr)\n      let stderrOutput = '';\n      if (error && typeof error === 'object') {\n        const execError = error as { stderr?: string; stdout?: string };\n        if (execError.stderr) {\n          stderrOutput = execError.stderr.trim();\n        }\n      }\n\n      // Construct detailed error message\n      let detailedMessage: string;\n      let ruleId: string;\n\n      if (isTimeout) {\n        const timeoutSeconds = (config.timeout as number) || 60;\n        detailedMessage = `Command execution timed out after ${timeoutSeconds} seconds`;\n        if (stderrOutput) {\n          detailedMessage += `\\n\\nStderr output:\\n${stderrOutput}`;\n        }\n        ruleId = 'command/timeout';\n      } else {\n        detailedMessage = stderrOutput\n          ? `Command execution failed: ${errorMessage}\\n\\nStderr output:\\n${stderrOutput}`\n          : `Command execution failed: ${errorMessage}`;\n        ruleId = 'command/execution_error';\n      }\n\n      logger.error(`‚úó ${detailedMessage}`);\n\n      return {\n        issues: [\n          {\n            file: 'command',\n            line: 0,\n            ruleId,\n            message: detailedMessage,\n            severity: 'error',\n            category: 'logic',\n          },\n        ],\n      };\n    }\n  }\n\n  private buildOutputContext(\n    dependencyResults?: Map<string, ReviewSummary>,\n    outputHistory?: Map<string, unknown[]>\n  ): Record<string, unknown> {\n    if (!dependencyResults) {\n      return {};\n    }\n\n    const outputs: Record<string, unknown> = {};\n    const history: Record<string, unknown[]> = {};\n\n    for (const [checkName, result] of dependencyResults) {\n      // If the result has a direct output field, use it directly\n      // Otherwise, expose the entire result as-is\n      const summary = result as ReviewSummary & { output?: unknown };\n      const value = summary.output !== undefined ? summary.output : summary;\n      outputs[checkName] = this.makeJsonSmart(value);\n    }\n\n    // Add history for each check if available\n    if (outputHistory) {\n      for (const [checkName, historyArray] of outputHistory) {\n        history[checkName] = historyArray.map(val => this.makeJsonSmart(val));\n      }\n    }\n\n    // Attach history to the outputs object\n    (outputs as any).history = history;\n\n    return outputs;\n  }\n\n  /**\n   * Wrap a value with JSON-smart behavior:\n   *  - If it's a JSON string, expose parsed properties via Proxy (e.g., value.key)\n   *  - When coerced to string (toString/valueOf/Symbol.toPrimitive), return the original raw string\n   *  - If parsing fails or value is not a string, return the value unchanged\n   *  - Attempts to extract JSON from the end of the output if full parse fails\n   */\n  private makeJsonSmart<T = unknown>(value: T): T | any {\n    if (typeof value !== 'string') {\n      return value;\n    }\n\n    const raw = value as unknown as string;\n    let parsed: any;\n\n    // First try: parse the entire string as JSON\n    try {\n      parsed = JSON.parse(raw);\n    } catch {\n      // Second try: extract JSON from the end of the output\n      // Look for { or [ at the start of a line and take everything after it\n      const jsonMatch = this.extractJsonFromEnd(raw);\n      if (jsonMatch) {\n        try {\n          parsed = JSON.parse(jsonMatch);\n          logger.debug(\n            `üîß Debug: Extracted JSON from end of output (${jsonMatch.length} chars from ${raw.length} total)`\n          );\n        } catch {\n          // Not valid JSON even after extraction, return original string\n          return raw;\n        }\n      } else {\n        // Not JSON, return original string\n        return raw;\n      }\n    }\n\n    // Use a boxed string so string methods still work via Proxy fallback\n    const boxed = new String(raw);\n    const handler: ProxyHandler<any> = {\n      get(target, prop, receiver) {\n        if (prop === 'toString' || prop === 'valueOf') {\n          return () => raw;\n        }\n        if (prop === Symbol.toPrimitive) {\n          return () => raw;\n        }\n        if (parsed != null && (typeof parsed === 'object' || Array.isArray(parsed))) {\n          if (prop in parsed) {\n            return (parsed as any)[prop as any];\n          }\n        }\n        return Reflect.get(target, prop, receiver);\n      },\n      has(_target, prop) {\n        if (parsed != null && (typeof parsed === 'object' || Array.isArray(parsed))) {\n          if (prop in parsed) return true;\n        }\n        return false;\n      },\n      ownKeys(_target) {\n        if (parsed != null && (typeof parsed === 'object' || Array.isArray(parsed))) {\n          try {\n            return Reflect.ownKeys(parsed);\n          } catch {\n            return [];\n          }\n        }\n        return [];\n      },\n      getOwnPropertyDescriptor(_target, prop) {\n        if (parsed != null && (typeof parsed === 'object' || Array.isArray(parsed))) {\n          const descriptor = Object.getOwnPropertyDescriptor(parsed, prop as any);\n          if (descriptor) return descriptor;\n        }\n        return {\n          configurable: true,\n          enumerable: true,\n          writable: false,\n          value: undefined,\n        };\n      },\n    };\n    return new Proxy(boxed, handler);\n  }\n\n  /**\n   * Extract JSON from the end of a string that may contain logs/debug output\n   * Looks for the last occurrence of { or [ and tries to parse from there\n   */\n  private extractJsonFromEnd(text: string): string | null {\n    // Robust strategy: find the last closing brace/bracket, then walk backwards to the matching opener\n    const lastBrace = Math.max(text.lastIndexOf('}'), text.lastIndexOf(']'));\n    if (lastBrace === -1) return null;\n    // Scan backwards to find matching opener with a simple counter\n    let open = 0;\n    for (let i = lastBrace; i >= 0; i--) {\n      const ch = text[i];\n      if (ch === '}' || ch === ']') open++;\n      else if (ch === '{' || ch === '[') open--;\n      if (open === 0 && (ch === '{' || ch === '[')) {\n        const candidate = text.slice(i, lastBrace + 1).trim();\n        try {\n          JSON.parse(candidate);\n          return candidate;\n        } catch {\n          return null;\n        }\n      }\n    }\n    return null;\n  }\n\n  // Extract any balanced JSON object/array substring from anywhere in the text\n  private extractJsonAnywhere(text: string): string | null {\n    const n = text.length;\n    let best: string | null = null;\n    for (let i = 0; i < n; i++) {\n      const start = text[i];\n      if (start !== '{' && start !== '[') continue;\n      let open = 0;\n      let inString = false;\n      let escape = false;\n      for (let j = i; j < n; j++) {\n        const ch = text[j];\n        if (escape) {\n          escape = false;\n          continue;\n        }\n        if (ch === '\\\\') {\n          escape = true;\n          continue;\n        }\n        if (ch === '\"') {\n          inString = !inString;\n          continue;\n        }\n        if (inString) continue;\n        if (ch === '{' || ch === '[') open++;\n        else if (ch === '}' || ch === ']') open--;\n        if (open === 0 && (ch === '}' || ch === ']')) {\n          const candidate = text.slice(i, j + 1).trim();\n          try {\n            JSON.parse(candidate);\n            best = candidate; // keep the last valid one we find\n          } catch {\n            // Try a loose-to-strict conversion (quote keys and barewords)\n            const strict = this.looseJsonToStrict(candidate);\n            if (strict) {\n              try {\n                JSON.parse(strict);\n                best = strict;\n              } catch {}\n            }\n          }\n          break;\n        }\n      }\n    }\n    return best;\n  }\n\n  // Best-effort conversion of object-literal-like strings to strict JSON\n  private looseJsonToStrict(candidate: string): string | null {\n    try {\n      let s = candidate.trim();\n      // Convert single quotes to double quotes conservatively\n      s = s.replace(/'/g, '\"');\n      // Quote unquoted keys: {key: ...} or ,key: ...\n      s = s.replace(/([\\{,]\\s*)([A-Za-z_][A-Za-z0-9_-]*)\\s*:/g, '$1\"$2\":');\n      // Quote bareword values except true/false/null and numbers\n      s = s.replace(/:\\s*([A-Za-z_][A-Za-z0-9_-]*)\\s*(?=[,}])/g, (m, word) => {\n        const lw = String(word).toLowerCase();\n        if (lw === 'true' || lw === 'false' || lw === 'null') return `:${lw}`;\n        return `:\"${word}\"`;\n      });\n      return s;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Recursively apply JSON-smart wrapper to outputs object values\n   */\n  private makeOutputsJsonSmart(outputs: Record<string, unknown>): Record<string, unknown> {\n    const wrapped: Record<string, unknown> = {};\n    for (const [k, v] of Object.entries(outputs || {})) {\n      wrapped[k] = this.makeJsonSmart(v);\n    }\n    return wrapped;\n  }\n\n  private getSafeEnvironmentVariables(): Record<string, string> {\n    const safeVars: Record<string, string> = {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const allowedPrefixes: string[] = []; // replaced by buildSandboxEnv\n\n    const { buildSandboxEnv } = require('../utils/env-exposure');\n    const merged = buildSandboxEnv(process.env);\n    for (const [key, value] of Object.entries(merged)) {\n      safeVars[key] = String(value);\n    }\n\n    // Add current working directory\n    safeVars['PWD'] = process.cwd();\n\n    return safeVars;\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'exec',\n      'transform',\n      'transform_js',\n      'env',\n      'timeout',\n      'depends_on',\n      'on',\n      'if',\n      'group',\n      'forEach',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // Command provider is always available as long as we can execute commands\n    return true;\n  }\n\n  getRequirements(): string[] {\n    return [\n      'Valid shell command to execute',\n      'Shell environment available',\n      'Optional: Transform template for processing output',\n    ];\n  }\n\n  private extractIssuesFromOutput(\n    output: unknown\n  ): { issues: ReviewIssue[]; remainingOutput: unknown } | null {\n    try {\n      logger.info(\n        `  extractIssuesFromOutput: typeof=${Array.isArray(output) ? 'array' : typeof output}`\n      );\n      if (typeof output === 'object' && output) {\n        const rec = output as Record<string, unknown>;\n        logger.info(\n          `  extractIssuesFromOutput: keys=${Object.keys(rec).join(',')} issuesIsArray=${Array.isArray(\n            (rec as any).issues\n          )}`\n        );\n      }\n    } catch {}\n    if (output === null || output === undefined) {\n      return null;\n    }\n\n    // If output is already a string, do not treat it as issues here (caller may try parsing JSON)\n    if (typeof output === 'string') {\n      return null;\n    }\n\n    if (Array.isArray(output)) {\n      // Two supported shapes:\n      //  1) Array<ReviewIssue-like>\n      //  2) Array<{ issues: Array<ReviewIssue-like> }>\n      const first = output[0];\n      if (\n        first &&\n        typeof first === 'object' &&\n        !Array.isArray((first as any).message) &&\n        Array.isArray((first as any).issues)\n      ) {\n        // flatten nested issues arrays\n        const merged: unknown[] = [];\n        for (const el of output as unknown[]) {\n          if (el && typeof el === 'object' && Array.isArray((el as any).issues)) {\n            merged.push(...((el as any).issues as unknown[]));\n          }\n        }\n        const flat = this.normalizeIssueArray(merged);\n        if (flat) return { issues: flat, remainingOutput: undefined };\n      } else {\n        const issues = this.normalizeIssueArray(output);\n        if (issues) {\n          return { issues, remainingOutput: undefined };\n        }\n      }\n      return null;\n    }\n\n    if (typeof output === 'object') {\n      const record = output as Record<string, unknown>;\n\n      if (Array.isArray(record.issues)) {\n        const issues = this.normalizeIssueArray(record.issues);\n        if (!issues) {\n          return null;\n        }\n\n        const remaining = { ...record };\n        delete (remaining as { issues?: unknown }).issues;\n\n        const remainingKeys = Object.keys(remaining);\n        const remainingOutput = remainingKeys.length > 0 ? remaining : undefined;\n\n        return {\n          issues,\n          remainingOutput,\n        };\n      }\n\n      const singleIssue = this.normalizeIssue(record);\n      if (singleIssue) {\n        return { issues: [singleIssue], remainingOutput: undefined };\n      }\n    }\n\n    return null;\n  }\n\n  private shouldTreatAsTextOutput(value?: string): value is string {\n    if (!value) {\n      return false;\n    }\n\n    const trimmed = value.trim();\n    if (!trimmed) {\n      return false;\n    }\n\n    // Heuristic: consider it JSON-like if it starts with { or [ and ends with } or ]\n    const startsJson =\n      (trimmed.startsWith('{') && trimmed.endsWith('}')) ||\n      (trimmed.startsWith('[') && trimmed.endsWith(']'));\n\n    return !startsJson;\n  }\n\n  private normalizeIssueArray(values: unknown[]): ReviewIssue[] | null {\n    const normalized: ReviewIssue[] = [];\n\n    for (const value of values) {\n      const issue = this.normalizeIssue(value);\n      if (!issue) {\n        return null;\n      }\n      normalized.push(issue);\n    }\n\n    return normalized;\n  }\n\n  private normalizeIssue(raw: unknown): ReviewIssue | null {\n    if (!raw || typeof raw !== 'object') {\n      return null;\n    }\n\n    const data = raw as Record<string, unknown>;\n\n    const message = this.toTrimmedString(\n      data.message || data.text || data.description || data.summary\n    );\n    if (!message) {\n      return null;\n    }\n\n    const allowedSeverities = new Set(['info', 'warning', 'error', 'critical']);\n    const severityRaw = this.toTrimmedString(data.severity || data.level || data.priority);\n    let severity: ReviewIssue['severity'] = 'warning';\n    if (severityRaw) {\n      const lower = severityRaw.toLowerCase();\n      if (allowedSeverities.has(lower)) {\n        severity = lower as ReviewIssue['severity'];\n      } else if (['fatal', 'high'].includes(lower)) {\n        severity = 'error';\n      } else if (['medium', 'moderate'].includes(lower)) {\n        severity = 'warning';\n      } else if (['low', 'minor'].includes(lower)) {\n        severity = 'info';\n      }\n    }\n\n    const allowedCategories = new Set([\n      'security',\n      'performance',\n      'style',\n      'logic',\n      'documentation',\n    ]);\n    const categoryRaw = this.toTrimmedString(data.category || data.type || data.group);\n    let category: ReviewIssue['category'] = 'logic';\n    if (categoryRaw && allowedCategories.has(categoryRaw.toLowerCase())) {\n      category = categoryRaw.toLowerCase() as ReviewIssue['category'];\n    }\n\n    const file = this.toTrimmedString(data.file || data.path || data.filename) || 'system';\n\n    const line = this.toNumber(data.line || data.startLine || data.lineNumber) ?? 0;\n    const endLine = this.toNumber(data.endLine || data.end_line || data.stopLine);\n\n    const suggestion = this.toTrimmedString(data.suggestion);\n    const replacement = this.toTrimmedString(data.replacement);\n\n    const ruleId =\n      this.toTrimmedString(data.ruleId || data.rule || data.id || data.check) || 'command';\n\n    return {\n      file,\n      line,\n      endLine: endLine ?? undefined,\n      ruleId,\n      message,\n      severity,\n      category,\n      suggestion: suggestion || undefined,\n      replacement: replacement || undefined,\n    };\n  }\n\n  private toTrimmedString(value: unknown): string | null {\n    if (typeof value === 'string') {\n      const trimmed = value.trim();\n      return trimmed.length > 0 ? trimmed : null;\n    }\n    if (value !== null && value !== undefined && typeof value.toString === 'function') {\n      const converted = String(value).trim();\n      return converted.length > 0 ? converted : null;\n    }\n    return null;\n  }\n\n  private toNumber(value: unknown): number | null {\n    if (value === null || value === undefined) {\n      return null;\n    }\n    const num = Number(value);\n    if (Number.isFinite(num)) {\n      return Math.trunc(num);\n    }\n    return null;\n  }\n\n  private async renderCommandTemplate(\n    template: string,\n    context: {\n      pr: Record<string, unknown>;\n      files: unknown[];\n      outputs: Record<string, unknown>;\n      env: Record<string, string>;\n    }\n  ): Promise<string> {\n    try {\n      // Best-effort compatibility: allow double-quoted bracket keys inside Liquid tags.\n      // e.g., {{ outputs[\"fetch-tickets\"].key }} ‚Üí {{ outputs['fetch-tickets'].key }}\n      let tpl = template;\n      if (tpl.includes('{{')) {\n        tpl = tpl.replace(/\\{\\{([\\s\\S]*?)\\}\\}/g, (_m, inner) => {\n          const fixed = String(inner).replace(/\\[\\\"/g, \"['\").replace(/\\\"\\]/g, \"']\");\n          return `{{ ${fixed} }}`;\n        });\n      }\n      let rendered = await this.liquid.parseAndRender(tpl, context);\n      // If Liquid left unresolved tags (common when users write JS expressions inside {{ }}),\n      // fall back to a safe JS-expression renderer for the remaining tags.\n      if (/\\{\\{[\\s\\S]*?\\}\\}/.test(rendered)) {\n        try {\n          rendered = this.renderWithJsExpressions(rendered, context);\n        } catch {\n          // keep Liquid-rendered result as-is\n        }\n      }\n      return rendered;\n    } catch (error) {\n      logger.debug(`üîß Debug: Liquid templating failed, trying JS-expression fallback: ${error}`);\n      try {\n        return this.renderWithJsExpressions(template, context);\n      } catch {\n        return template;\n      }\n    }\n  }\n\n  private renderWithJsExpressions(\n    template: string,\n    context: {\n      pr: Record<string, unknown>;\n      files: unknown[];\n      outputs: Record<string, unknown>;\n      env: Record<string, string>;\n    }\n  ): string {\n    const scope = {\n      pr: context.pr,\n      files: context.files,\n      outputs: context.outputs,\n      env: context.env,\n    };\n\n    const expressionRegex = /\\{\\{\\s*([^{}]+?)\\s*\\}\\}/g;\n    return template.replace(expressionRegex, (_match, expr) => {\n      const expression = String(expr).trim();\n      if (!expression) return '';\n      try {\n        const evalCode = `\n          const pr = scope.pr;\n          const files = scope.files;\n          const outputs = scope.outputs;\n          const env = scope.env;\n          return (${expression});\n        `;\n        if (!this.sandbox) this.sandbox = this.createSecureSandbox();\n        const evaluator = this.sandbox.compile(evalCode);\n        const result = evaluator({ scope }).run();\n        return result === undefined || result === null ? '' : String(result);\n      } catch {\n        return '';\n      }\n    });\n  }\n}\n","import type { PRInfo } from '../pr-analyzer';\nimport type { ReviewSummary } from '../reviewer';\nimport { MemoryStore } from '../memory-store';\n\n/**\n * Build a common provider template context with PR info, outputs (current),\n * outputs.history (all runs), outputs_raw (aggregate -raw deps) and an alias\n * outputs_history / outputs_history_stage. Optionally attaches read-only\n * memory helpers (get/has/list/getAll).\n */\nconst PR_CACHE_LIMIT = 16;\nconst prCache = new Map<string, any>();\n\nfunction prCacheKey(pr: PRInfo): string {\n  // Hash on stable fields + file list summary to avoid rebuilding the same structure repeatedly\n  let sum = 0;\n  for (const f of pr.files) sum += (f.additions || 0) + (f.deletions || 0) + (f.changes || 0);\n  return [pr.number, pr.title, pr.author, pr.base, pr.head, pr.files.length, sum].join('|');\n}\n\nexport function buildProviderTemplateContext(\n  prInfo: PRInfo,\n  dependencyResults?: Map<string, ReviewSummary>,\n  memoryStore?: MemoryStore,\n  outputHistory?: Map<string, unknown[]>,\n  stageHistoryBase?: Record<string, number>,\n  opts: { attachMemoryReadHelpers?: boolean } = { attachMemoryReadHelpers: true }\n): Record<string, unknown> {\n  const context: Record<string, unknown> = {};\n\n  // PR context with tiny cache\n  const key = prCacheKey(prInfo);\n  let prObj = prCache.get(key);\n  if (!prObj) {\n    prObj = {\n      number: prInfo.number,\n      title: prInfo.title,\n      body: prInfo.body,\n      author: prInfo.author,\n      base: prInfo.base,\n      head: prInfo.head,\n      totalAdditions: prInfo.totalAdditions,\n      totalDeletions: prInfo.totalDeletions,\n      files: prInfo.files.map(f => ({\n        filename: f.filename,\n        status: f.status,\n        additions: f.additions,\n        deletions: f.deletions,\n        changes: f.changes,\n      })),\n    };\n    prCache.set(key, prObj);\n    if (prCache.size > PR_CACHE_LIMIT) {\n      const first = prCache.keys().next();\n      if (!first.done) prCache.delete(first.value);\n    }\n  }\n  context.pr = prObj;\n\n  // outputs and history\n  const outputs: Record<string, unknown> = {};\n  const outputsRaw: Record<string, unknown> = {};\n  const history: Record<string, unknown[]> = {};\n\n  if (dependencyResults) {\n    for (const [checkName, result] of dependencyResults.entries()) {\n      if (typeof checkName !== 'string') continue;\n      const summary = result as ReviewSummary & { output?: unknown };\n      if (checkName.endsWith('-raw')) {\n        const name = checkName.slice(0, -4);\n        outputsRaw[name] = summary.output !== undefined ? summary.output : summary;\n      } else {\n        outputs[checkName] = summary.output !== undefined ? summary.output : summary;\n      }\n    }\n  }\n\n  if (outputHistory) {\n    for (const [checkName, historyArray] of outputHistory) {\n      history[checkName] = historyArray;\n    }\n  }\n\n  const historyStage: Record<string, unknown[]> = {};\n  try {\n    if (outputHistory && stageHistoryBase) {\n      for (const [checkName, historyArray] of outputHistory) {\n        const start = stageHistoryBase[checkName] || 0;\n        const arr = Array.isArray(historyArray) ? (historyArray as unknown[]) : [];\n        historyStage[checkName] = arr.slice(start);\n      }\n    }\n  } catch {}\n\n  (outputs as any).history = history;\n  context.outputs = outputs;\n  (context as any).outputs_history = history;\n  (context as any).outputs_history_stage = historyStage;\n  (context as any).outputs_raw = outputsRaw;\n\n  if (opts.attachMemoryReadHelpers && memoryStore) {\n    context.memory = {\n      get: (key: string, ns?: string) => memoryStore.get(key, ns),\n      has: (key: string, ns?: string) => memoryStore.has(key, ns),\n      list: (ns?: string) => memoryStore.list(ns),\n      getAll: (ns?: string) => memoryStore.getAll(ns),\n    } as Record<string, unknown>;\n  }\n\n  return context;\n}\n","import { MemoryStore } from '../memory-store';\n\n/**\n * Create synchronous memory helpers for sandboxed script execution. These mirror\n * the legacy behavior previously used for in-provider scripting: mutate in-memory state\n * synchronously and perform at most one save() afterward if needed.\n */\nexport function createSyncMemoryOps(store: MemoryStore): {\n  ops: {\n    get: (key: string, ns?: string) => unknown;\n    has: (key: string, ns?: string) => boolean;\n    list: (ns?: string) => string[];\n    getAll: (ns?: string) => Record<string, unknown>;\n    set: (key: string, value: unknown, ns?: string) => unknown;\n    append: (key: string, value: unknown, ns?: string) => unknown[];\n    increment: (key: string, amount?: number, ns?: string) => number;\n    delete: (key: string, ns?: string) => boolean;\n    clear: (ns?: string) => void;\n  };\n  needsSave: () => boolean;\n} {\n  let saveNeeded = false;\n\n  const ensureNs = (ns?: string) => {\n    const nsName = ns || store.getDefaultNamespace();\n    const anyStore = store as unknown as { data: Map<string, Map<string, unknown>> };\n    if (!anyStore['data'].has(nsName)) {\n      anyStore['data'].set(nsName, new Map());\n    }\n    return nsName;\n  };\n\n  const ops = {\n    get: (key: string, ns?: string) => store.get(key, ns),\n    has: (key: string, ns?: string) => store.has(key, ns),\n    list: (ns?: string) => store.list(ns),\n    getAll: (ns?: string) => store.getAll(ns),\n    set: (key: string, value: unknown, ns?: string) => {\n      const nsName = ensureNs(ns);\n      (store as any)['data'].get(nsName)!.set(key, value);\n      saveNeeded = true;\n      return value;\n    },\n    append: (key: string, value: unknown, ns?: string) => {\n      const existing = store.get(key, ns);\n      let newValue: unknown[];\n      if (existing === undefined) newValue = [value];\n      else if (Array.isArray(existing)) newValue = [...existing, value];\n      else newValue = [existing, value];\n      const nsName = ensureNs(ns);\n      (store as any)['data'].get(nsName)!.set(key, newValue);\n      saveNeeded = true;\n      return newValue;\n    },\n    increment: (key: string, amount = 1, ns?: string) => {\n      const nsName = ensureNs(ns);\n      const current = store.get(key, nsName);\n      const numCurrent = typeof current === 'number' ? (current as number) : 0;\n      const newValue = numCurrent + amount;\n      (store as any)['data'].get(nsName)!.set(key, newValue);\n      saveNeeded = true;\n      return newValue;\n    },\n    delete: (key: string, ns?: string) => {\n      const nsName = ensureNs(ns);\n      const d = (store as any)['data'].get(nsName)?.delete(key) || false;\n      if (d) saveNeeded = true;\n      return d;\n    },\n    clear: (ns?: string) => {\n      if (ns) (store as any)['data'].delete(ns);\n      else (store as any)['data'].clear();\n      saveNeeded = true;\n    },\n  } as const;\n\n  return { ops: ops as any, needsSave: () => saveNeeded };\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { MemoryStore } from '../memory-store';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { logger } from '../logger';\nimport Sandbox from '@nyariv/sandboxjs';\nimport { createSecureSandbox, compileAndRun } from '../utils/sandbox';\nimport { buildProviderTemplateContext } from '../utils/template-context';\nimport { createSyncMemoryOps } from '../utils/script-memory-ops';\n\n/**\n * Memory operation types\n */\nexport type MemoryOperation = 'get' | 'set' | 'append' | 'increment' | 'delete' | 'clear' | 'list';\n\n/**\n * Check provider for memory/state management\n * Supports in-memory and persistent storage with namespace isolation\n */\nexport class MemoryCheckProvider extends CheckProvider {\n  private liquid: Liquid;\n  private sandbox?: Sandbox;\n\n  constructor() {\n    super();\n    this.liquid = createExtendedLiquid({\n      strictVariables: false,\n      strictFilters: false,\n    });\n  }\n\n  /**\n   * Create a secure sandbox for JavaScript execution\n   */\n  private createSecureSandbox(): Sandbox {\n    return createSecureSandbox();\n  }\n\n  getName(): string {\n    return 'memory';\n  }\n\n  getDescription(): string {\n    return 'Memory/state management provider for persistent key-value storage across checks';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'memory'\n    if (cfg.type !== 'memory') {\n      return false;\n    }\n\n    // Operation is required\n    if (!cfg.operation || typeof cfg.operation !== 'string') {\n      return false;\n    }\n\n    const operation = cfg.operation as string;\n    const validOps = ['get', 'set', 'append', 'increment', 'delete', 'clear', 'list'];\n    if (!validOps.includes(operation)) {\n      return false;\n    }\n\n    // Key is required for get, set, append, increment, delete\n    if (['get', 'set', 'append', 'increment', 'delete'].includes(operation)) {\n      if (!cfg.key || typeof cfg.key !== 'string') {\n        return false;\n      }\n    }\n\n    // Value or value_js is required for set and append\n    if (['set', 'append'].includes(operation)) {\n      if (cfg.value === undefined && !cfg.value_js) {\n        return false;\n      }\n    }\n\n    // For custom scripting use the ScriptCheckProvider (type: 'script').\n\n    return true;\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    _sessionInfo?: {\n      parentSessionId?: string;\n      reuseSession?: boolean;\n    } & import('./check-provider.interface').ExecutionContext\n  ): Promise<ReviewSummary> {\n    const operation = config.operation as MemoryOperation | undefined;\n    const key = config.key as string | undefined;\n    const namespace = config.namespace as string | undefined;\n\n    // Get memory store instance\n    const memoryStore = MemoryStore.getInstance();\n\n    // Build template context for value computation\n    const templateContext = this.buildTemplateContext(\n      prInfo,\n      dependencyResults,\n      memoryStore,\n      config.__outputHistory as Map<string, unknown[]> | undefined,\n      (_sessionInfo as any)?.stageHistoryBase as Record<string, number> | undefined\n    );\n\n    let result: unknown;\n\n    // No implicit fallbacks; operation must be explicitly provided.\n\n    try {\n      switch (operation) {\n        case 'get':\n          result = await this.handleGet(memoryStore, key!, namespace);\n          break;\n        case 'set':\n          result = await this.handleSet(memoryStore, key!, config, namespace, templateContext);\n          break;\n        case 'append':\n          result = await this.handleAppend(memoryStore, key!, config, namespace, templateContext);\n          break;\n        case 'increment':\n          result = await this.handleIncrement(\n            memoryStore,\n            key!,\n            config,\n            namespace,\n            templateContext\n          );\n          break;\n        case 'delete':\n          result = await this.handleDelete(memoryStore, key!, namespace);\n          break;\n        case 'clear':\n          result = await this.handleClear(memoryStore, namespace);\n          break;\n        case 'list':\n          result = await this.handleList(memoryStore, namespace);\n          break;\n        default:\n          throw new Error(`Unknown memory operation: ${operation}`);\n      }\n\n      // Return result as output\n      return {\n        issues: [],\n        output: result,\n      } as ReviewSummary & { output: unknown };\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : 'Unknown error in memory operation';\n      logger.error(`Memory operation failed: ${errorMsg}`);\n\n      return {\n        issues: [],\n        output: null,\n        error: errorMsg,\n      } as ReviewSummary & { output: null; error: string };\n    }\n  }\n\n  private async handleGet(store: MemoryStore, key: string, namespace?: string): Promise<unknown> {\n    const value = store.get(key, namespace);\n    logger.debug(\n      `Memory GET: ${namespace || store.getDefaultNamespace()}.${key} = ${JSON.stringify(value)}`\n    );\n    return value;\n  }\n\n  private async handleSet(\n    store: MemoryStore,\n    key: string,\n    config: CheckProviderConfig,\n    namespace: string | undefined,\n    context: Record<string, unknown>\n  ): Promise<unknown> {\n    const value = await this.computeValue(config, context);\n    await store.set(key, value, namespace);\n    logger.debug(\n      `Memory SET: ${namespace || store.getDefaultNamespace()}.${key} = ${JSON.stringify(value)}`\n    );\n    return value;\n  }\n\n  private async handleAppend(\n    store: MemoryStore,\n    key: string,\n    config: CheckProviderConfig,\n    namespace: string | undefined,\n    context: Record<string, unknown>\n  ): Promise<unknown> {\n    const value = await this.computeValue(config, context);\n    await store.append(key, value, namespace);\n    const result = store.get(key, namespace);\n    logger.debug(\n      `Memory APPEND: ${namespace || store.getDefaultNamespace()}.${key} += ${JSON.stringify(value)} (now: ${JSON.stringify(result)})`\n    );\n    return result;\n  }\n\n  private async handleIncrement(\n    store: MemoryStore,\n    key: string,\n    config: CheckProviderConfig,\n    namespace: string | undefined,\n    context: Record<string, unknown>\n  ): Promise<number> {\n    // Compute amount - default to 1 if not specified\n    let amount = 1;\n    if (config.value !== undefined || config.value_js) {\n      const computedValue = await this.computeValue(config, context);\n      if (typeof computedValue === 'number') {\n        amount = computedValue;\n      } else {\n        throw new Error(`Increment amount must be a number, got ${typeof computedValue}`);\n      }\n    }\n\n    const result = await store.increment(key, amount, namespace);\n    logger.debug(\n      `Memory INCREMENT: ${namespace || store.getDefaultNamespace()}.${key} += ${amount} (now: ${result})`\n    );\n    return result;\n  }\n\n  private async handleDelete(\n    store: MemoryStore,\n    key: string,\n    namespace?: string\n  ): Promise<boolean> {\n    const deleted = await store.delete(key, namespace);\n    logger.debug(\n      `Memory DELETE: ${namespace || store.getDefaultNamespace()}.${key} (deleted: ${deleted})`\n    );\n    return deleted;\n  }\n\n  private async handleClear(store: MemoryStore, namespace?: string): Promise<void> {\n    await store.clear(namespace);\n    logger.debug(`Memory CLEAR: ${namespace ? `namespace ${namespace}` : 'all namespaces'}`);\n  }\n\n  private async handleList(store: MemoryStore, namespace?: string): Promise<string[]> {\n    const keys = store.list(namespace);\n    logger.debug(`Memory LIST: ${namespace || store.getDefaultNamespace()} (${keys.length} keys)`);\n    return keys;\n  }\n\n  // For custom JavaScript execution use ScriptCheckProvider.\n\n  /**\n   * Compute value from config using value, value_js, transform, or transform_js\n   */\n  private async computeValue(\n    config: CheckProviderConfig,\n    context: Record<string, unknown>\n  ): Promise<unknown> {\n    let value: unknown;\n\n    // Start with direct value or value_js\n    if (config.value_js && typeof config.value_js === 'string') {\n      value = this.evaluateJavaScript(config.value_js, context);\n    } else {\n      value = config.value;\n    }\n\n    // Apply transform template if provided\n    if (config.transform && typeof config.transform === 'string') {\n      const rendered = await this.liquid.parseAndRender(config.transform, {\n        ...context,\n        value,\n      });\n      value = rendered;\n    }\n\n    // Apply transform_js if provided\n    if (config.transform_js && typeof config.transform_js === 'string') {\n      value = this.evaluateJavaScript(config.transform_js, { ...context, value });\n    }\n\n    return value;\n  }\n\n  /**\n   * Evaluate JavaScript expression in context using SandboxJS for secure execution\n   */\n  private evaluateJavaScript(expression: string, context: Record<string, unknown>): unknown {\n    if (!this.sandbox) {\n      this.sandbox = this.createSecureSandbox();\n    }\n\n    try {\n      const scope: Record<string, unknown> = { ...context };\n      return compileAndRun<unknown>(this.sandbox, `return (${expression});`, scope, {\n        injectLog: true,\n        wrapFunction: false,\n        logPrefix: '[memory:value_js]',\n      });\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : 'Unknown error';\n      throw new Error(`Failed to evaluate value_js: ${errorMsg}`);\n    }\n  }\n\n  // No full-script execution in memory provider. Use ScriptCheckProvider.\n\n  /**\n   * Build template context for Liquid and JS evaluation\n   */\n  private buildTemplateContext(\n    prInfo: PRInfo,\n    dependencyResults?: Map<string, ReviewSummary>,\n    memoryStore?: MemoryStore,\n    outputHistory?: Map<string, unknown[]>,\n    stageHistoryBase?: Record<string, number>\n  ): Record<string, unknown> {\n    const base = buildProviderTemplateContext(\n      prInfo,\n      dependencyResults,\n      memoryStore,\n      outputHistory as Map<string, unknown[]> | undefined,\n      stageHistoryBase\n    );\n    if (memoryStore) {\n      const { ops } = createSyncMemoryOps(memoryStore);\n      (base as any).memory = ops;\n    }\n    return base;\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'operation',\n      'key',\n      'value',\n      'value_js',\n      'transform',\n      'transform_js',\n      'namespace',\n      'depends_on',\n      'group',\n      'command',\n      'on',\n      'if',\n      'fail_if',\n      'on_fail',\n      'on_success',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // Memory provider is always available\n    return true;\n  }\n\n  getRequirements(): string[] {\n    return [\n      'No external dependencies required',\n      'Used for state management and persistent storage across checks',\n    ];\n  }\n}\n","import { CustomToolDefinition } from '../types/config';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { createSecureSandbox, compileAndRun } from '../utils/sandbox';\nimport Sandbox from '@nyariv/sandboxjs';\nimport { logger } from '../logger';\nimport { commandExecutor } from '../utils/command-executor';\nimport Ajv from 'ajv';\n\n/**\n * Executes custom tools defined in YAML configuration\n * These tools can be used in MCP blocks as if they were native MCP tools\n */\nexport class CustomToolExecutor {\n  private liquid: Liquid;\n  private sandbox?: Sandbox;\n  private tools: Map<string, CustomToolDefinition>;\n  private ajv: Ajv;\n\n  constructor(tools?: Record<string, CustomToolDefinition>) {\n    this.liquid = createExtendedLiquid({\n      cache: false,\n      strictFilters: false,\n      strictVariables: false,\n    });\n    this.tools = new Map(Object.entries(tools || {}));\n    this.ajv = new Ajv({ allErrors: true, verbose: true });\n  }\n\n  /**\n   * Register a custom tool\n   */\n  registerTool(tool: CustomToolDefinition): void {\n    if (!tool.name) {\n      throw new Error('Tool must have a name');\n    }\n    this.tools.set(tool.name, tool);\n  }\n\n  /**\n   * Register multiple tools\n   */\n  registerTools(tools: Record<string, CustomToolDefinition>): void {\n    for (const [name, tool] of Object.entries(tools)) {\n      // Ensure tool has the correct name\n      tool.name = tool.name || name;\n      this.registerTool(tool);\n    }\n  }\n\n  /**\n   * Get all registered tools\n   */\n  getTools(): CustomToolDefinition[] {\n    return Array.from(this.tools.values());\n  }\n\n  /**\n   * Get a specific tool by name\n   */\n  getTool(name: string): CustomToolDefinition | undefined {\n    return this.tools.get(name);\n  }\n\n  /**\n   * Validate tool input against schema using ajv\n   */\n  private validateInput(tool: CustomToolDefinition, input: Record<string, unknown>): void {\n    if (!tool.inputSchema) {\n      return;\n    }\n\n    // Compile and cache the schema validator for this tool\n    const validate = this.ajv.compile(tool.inputSchema);\n\n    // Validate the input\n    const valid = validate(input);\n\n    if (!valid) {\n      // Format validation errors for better readability\n      const errors = validate.errors\n        ?.map(err => {\n          if (err.instancePath) {\n            return `${err.instancePath}: ${err.message}`;\n          }\n          return err.message;\n        })\n        .join(', ');\n\n      throw new Error(`Input validation failed for tool '${tool.name}': ${errors}`);\n    }\n  }\n\n  /**\n   * Execute a custom tool\n   */\n  async execute(\n    toolName: string,\n    args: Record<string, unknown>,\n    context?: {\n      pr?: {\n        number: number;\n        title: string;\n        author: string;\n        branch: string;\n        base: string;\n      };\n      files?: unknown[];\n      outputs?: Record<string, unknown>;\n      env?: Record<string, string>;\n    }\n  ): Promise<unknown> {\n    const tool = this.tools.get(toolName);\n    if (!tool) {\n      throw new Error(`Tool not found: ${toolName}`);\n    }\n\n    // Validate input\n    this.validateInput(tool, args);\n\n    // Build template context\n    const templateContext = {\n      ...context,\n      args,\n      input: args,\n    };\n\n    // Render command with Liquid\n    const command = await this.liquid.parseAndRender(tool.exec, templateContext);\n\n    // Render stdin if provided\n    let stdin: string | undefined;\n    if (tool.stdin) {\n      stdin = await this.liquid.parseAndRender(tool.stdin, templateContext);\n    }\n\n    // Execute the command using shared executor\n    const env = commandExecutor.buildEnvironment(process.env, tool.env, context?.env);\n    const result = await commandExecutor.execute(command, {\n      stdin,\n      cwd: tool.cwd,\n      env,\n      timeout: tool.timeout || 30000,\n    });\n\n    // Parse JSON if requested\n    let output: unknown = result.stdout;\n    if (tool.parseJson) {\n      try {\n        output = JSON.parse(result.stdout);\n      } catch (e) {\n        logger.warn(`Failed to parse tool output as JSON: ${e}`);\n      }\n    }\n\n    // Apply transform if specified\n    if (tool.transform) {\n      const transformContext = {\n        ...templateContext,\n        output,\n        stdout: result.stdout,\n        stderr: result.stderr,\n        exitCode: result.exitCode,\n      };\n      const transformed = await this.liquid.parseAndRender(tool.transform, transformContext);\n      // Try to parse as JSON if it looks like JSON\n      if (typeof transformed === 'string' && transformed.trim().startsWith('{')) {\n        try {\n          output = JSON.parse(transformed);\n        } catch {\n          output = transformed;\n        }\n      } else {\n        output = transformed;\n      }\n    }\n\n    // Apply JavaScript transform if specified\n    if (tool.transform_js) {\n      output = await this.applyJavaScriptTransform(tool.transform_js, output, {\n        ...templateContext,\n        stdout: result.stdout,\n        stderr: result.stderr,\n        exitCode: result.exitCode,\n      });\n    }\n\n    return output;\n  }\n\n  /**\n   * Apply JavaScript transform to output\n   */\n  private async applyJavaScriptTransform(\n    transformJs: string,\n    output: unknown,\n    context: Record<string, unknown>\n  ): Promise<unknown> {\n    if (!this.sandbox) {\n      this.sandbox = createSecureSandbox();\n    }\n\n    const code = `\n      const output = ${JSON.stringify(output)};\n      const context = ${JSON.stringify(context)};\n      const args = context.args || {};\n      const pr = context.pr || {};\n      const files = context.files || [];\n      const outputs = context.outputs || {};\n      const env = context.env || {};\n\n      ${transformJs}\n    `;\n\n    try {\n      return await compileAndRun(this.sandbox, code, { timeout: 5000 });\n    } catch (error) {\n      logger.error(`JavaScript transform error: ${error}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Convert custom tools to MCP tool format\n   */\n  toMcpTools(): Array<{\n    name: string;\n    description?: string;\n    inputSchema?: Record<string, unknown>;\n    handler: (args: Record<string, unknown>) => Promise<unknown>;\n  }> {\n    return Array.from(this.tools.values()).map(tool => ({\n      name: tool.name,\n      description: tool.description,\n      inputSchema: tool.inputSchema as Record<string, unknown>,\n      handler: async (args: Record<string, unknown>) => {\n        return this.execute(tool.name, args);\n      },\n    }));\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary, ReviewIssue } from '../reviewer';\nimport { logger } from '../logger';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { Client } from '@modelcontextprotocol/sdk/client/index.js';\nimport { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';\nimport { SSEClientTransport } from '@modelcontextprotocol/sdk/client/sse.js';\nimport { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js';\nimport Sandbox from '@nyariv/sandboxjs';\nimport { createSecureSandbox, compileAndRun } from '../utils/sandbox';\nimport { EnvironmentResolver } from '../utils/env-resolver';\nimport { CustomToolExecutor } from './custom-tool-executor';\nimport { CustomToolDefinition } from '../types/config';\n\n/**\n * MCP Check Provider Configuration\n */\nexport interface McpCheckConfig extends CheckProviderConfig {\n  /** Transport type: stdio (default), sse (legacy), http (streamable HTTP), or custom (YAML-defined tools) */\n  transport?: 'stdio' | 'sse' | 'http' | 'custom';\n  /** Command to execute (for stdio transport) */\n  command?: string;\n  /** Command arguments (for stdio transport) */\n  args?: string[];\n  /** Environment variables (for stdio transport) */\n  env?: Record<string, string>;\n  /** Working directory (for stdio transport) */\n  workingDirectory?: string;\n  /** URL for SSE/HTTP transport */\n  url?: string;\n  /** HTTP headers (for SSE/HTTP transport) */\n  headers?: Record<string, string>;\n  /** Session ID for HTTP transport (optional, server may generate one) */\n  sessionId?: string;\n  /** MCP method/tool to call */\n  method: string;\n  /** Arguments to pass to the MCP method (supports Liquid templates) */\n  methodArgs?: Record<string, unknown>;\n  /** Transform template for method arguments (Liquid) */\n  argsTransform?: string;\n  /** Transform template for output (Liquid) */\n  transform?: string;\n  /** Transform using JavaScript expressions */\n  transform_js?: string;\n  /** Timeout in seconds */\n  timeout?: number;\n}\n\n/**\n * Check provider that calls MCP tools directly\n * Supports stdio, SSE (legacy), Streamable HTTP transports, and custom YAML-defined tools\n */\nexport class McpCheckProvider extends CheckProvider {\n  private liquid: Liquid;\n  private sandbox?: Sandbox;\n  private customToolExecutor?: CustomToolExecutor;\n\n  constructor() {\n    super();\n    this.liquid = createExtendedLiquid({\n      cache: false,\n      strictFilters: false,\n      strictVariables: false,\n    });\n  }\n\n  /**\n   * Set custom tools for this provider\n   */\n  setCustomTools(tools: Record<string, CustomToolDefinition>): void {\n    if (!this.customToolExecutor) {\n      this.customToolExecutor = new CustomToolExecutor(tools);\n    } else {\n      this.customToolExecutor.registerTools(tools);\n    }\n  }\n\n  /**\n   * Create a secure sandbox for JavaScript execution\n   * - Uses Sandbox.SAFE_GLOBALS which excludes: Function, eval, require, process, etc.\n   * - Only allows explicitly whitelisted prototype methods\n   * - No access to filesystem, network, or system resources\n   */\n  private createSecureSandbox(): Sandbox {\n    return createSecureSandbox();\n  }\n\n  getName(): string {\n    return 'mcp';\n  }\n\n  getDescription(): string {\n    return 'Call MCP tools directly using stdio, SSE, HTTP, or custom YAML-defined tools';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as McpCheckConfig;\n\n    // Method is required\n    if (!cfg.method || typeof cfg.method !== 'string') {\n      logger.error('MCP check requires a method name');\n      return false;\n    }\n\n    const transport = cfg.transport || 'stdio';\n\n    // Validate transport-specific requirements\n    if (transport === 'stdio') {\n      if (!cfg.command || typeof cfg.command !== 'string') {\n        logger.error('MCP stdio transport requires a command');\n        return false;\n      }\n\n      // Basic command injection prevention - check for shell metacharacters\n      // Allow common safe commands like 'npx', 'node', 'python', etc.\n      if (/[;&|`$(){}[\\]]/.test(cfg.command)) {\n        logger.error('MCP stdio command contains potentially unsafe characters');\n        return false;\n      }\n    } else if (transport === 'sse' || transport === 'http') {\n      if (!cfg.url || typeof cfg.url !== 'string') {\n        logger.error(`MCP ${transport} transport requires a URL`);\n        return false;\n      }\n\n      // Validate URL format\n      try {\n        const parsedUrl = new URL(cfg.url);\n        // Only allow http and https protocols\n        if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {\n          logger.error(\n            `Invalid URL protocol for MCP ${transport} transport: ${parsedUrl.protocol}. Only http: and https: are allowed.`\n          );\n          return false;\n        }\n      } catch {\n        logger.error(`Invalid URL format for MCP ${transport} transport: ${cfg.url}`);\n        return false;\n      }\n    } else if (transport === 'custom') {\n      // For custom transport, validation is delegated to CustomToolExecutor\n      // The tool must exist in the configuration's tools section\n      // This will be validated at execution time when the tool is looked up\n      logger.debug(`MCP custom transport will validate tool '${cfg.method}' at execution time`);\n    } else {\n      logger.error(\n        `Invalid MCP transport: ${transport}. Must be 'stdio', 'sse', 'http', or 'custom'`\n      );\n      return false;\n    }\n\n    return true;\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>\n  ): Promise<ReviewSummary> {\n    const cfg = config as McpCheckConfig;\n\n    try {\n      // Prepare template context\n      const templateContext = {\n        pr: {\n          number: prInfo.number,\n          title: prInfo.title,\n          author: prInfo.author,\n          branch: prInfo.head,\n          base: prInfo.base,\n        },\n        files: prInfo.files,\n        fileCount: prInfo.files.length,\n        outputs: this.buildOutputContext(dependencyResults),\n        env: this.getSafeEnvironmentVariables(),\n      };\n\n      // Render method arguments if needed\n      let methodArgs = cfg.methodArgs || {};\n      if (cfg.argsTransform) {\n        const rendered = await this.liquid.parseAndRender(cfg.argsTransform, templateContext);\n        try {\n          methodArgs = JSON.parse(rendered);\n        } catch (error) {\n          logger.error(`Failed to parse argsTransform as JSON: ${error}`);\n          return {\n            issues: [\n              {\n                file: 'mcp',\n                line: 0,\n                ruleId: 'mcp/args_transform_error',\n                message: `Failed to parse argsTransform: ${error instanceof Error ? error.message : 'Unknown error'}`,\n                severity: 'error',\n                category: 'logic',\n              },\n            ],\n          };\n        }\n      }\n\n      // Create MCP client and execute method\n      const result = await this.executeMcpMethod(cfg, methodArgs, prInfo, dependencyResults);\n\n      // Apply transforms if specified\n      let finalOutput = result;\n\n      // Apply Liquid transform\n      if (cfg.transform) {\n        try {\n          const transformContext = {\n            ...templateContext,\n            output: result,\n          };\n          const rendered = await this.liquid.parseAndRender(cfg.transform, transformContext);\n          try {\n            finalOutput = JSON.parse(rendered.trim());\n          } catch {\n            finalOutput = rendered.trim();\n          }\n        } catch (error) {\n          logger.error(`Failed to apply Liquid transform: ${error}`);\n          return {\n            issues: [\n              {\n                file: 'mcp',\n                line: 0,\n                ruleId: 'mcp/transform_error',\n                message: `Failed to apply transform: ${error instanceof Error ? error.message : 'Unknown error'}`,\n                severity: 'error',\n                category: 'logic',\n              },\n            ],\n          };\n        }\n      }\n\n      // Apply JavaScript transform using secure sandbox\n      if (cfg.transform_js) {\n        try {\n          if (!this.sandbox) {\n            this.sandbox = this.createSecureSandbox();\n          }\n\n          // Build scope with all context variables\n          const scope = {\n            output: finalOutput,\n            pr: templateContext.pr,\n            files: templateContext.files,\n            outputs: templateContext.outputs,\n            env: templateContext.env,\n          };\n\n          // Compile and execute the transform in sandboxed environment\n          finalOutput = compileAndRun<unknown>(\n            this.sandbox,\n            `return (${cfg.transform_js});`,\n            scope,\n            { injectLog: true, wrapFunction: false, logPrefix: '[mcp:transform_js]' }\n          );\n        } catch (error) {\n          logger.error(`Failed to apply JavaScript transform: ${error}`);\n          return {\n            issues: [\n              {\n                file: 'mcp',\n                line: 0,\n                ruleId: 'mcp/transform_js_error',\n                message: `Failed to apply JavaScript transform: ${error instanceof Error ? error.message : 'Unknown error'}`,\n                severity: 'error',\n                category: 'logic',\n              },\n            ],\n          };\n        }\n      }\n\n      // Extract issues from output\n      const extracted = this.extractIssuesFromOutput(finalOutput);\n      if (extracted) {\n        return {\n          issues: extracted.issues,\n          ...(extracted.remainingOutput ? { output: extracted.remainingOutput } : {}),\n        } as ReviewSummary;\n      }\n\n      // Return output directly\n      return {\n        issues: [],\n        ...(finalOutput ? { output: finalOutput } : {}),\n      } as ReviewSummary;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      logger.error(`MCP check failed: ${errorMessage}`);\n\n      return {\n        issues: [\n          {\n            file: 'mcp',\n            line: 0,\n            ruleId: 'mcp/execution_error',\n            message: `MCP check failed: ${errorMessage}`,\n            severity: 'error',\n            category: 'logic',\n          },\n        ],\n      };\n    }\n  }\n\n  /**\n   * Execute an MCP method using the configured transport\n   */\n  private async executeMcpMethod(\n    config: McpCheckConfig,\n    methodArgs: Record<string, unknown>,\n    prInfo?: PRInfo,\n    dependencyResults?: Map<string, ReviewSummary>\n  ): Promise<unknown> {\n    const transport = config.transport || 'stdio';\n    const timeout = (config.timeout || 60) * 1000; // Convert to milliseconds\n\n    if (transport === 'custom') {\n      // Execute custom YAML-defined tool\n      if (!this.customToolExecutor) {\n        throw new Error(\n          'No custom tools available. Define tools in the \"tools\" section of your configuration.'\n        );\n      }\n\n      const tool = this.customToolExecutor.getTool(config.method);\n      if (!tool) {\n        throw new Error(\n          `Custom tool not found: ${config.method}. Available tools: ${this.customToolExecutor\n            .getTools()\n            .map(t => t.name)\n            .join(', ')}`\n        );\n      }\n\n      // Build context for custom tool execution\n      const context = {\n        pr: prInfo\n          ? {\n              number: prInfo.number,\n              title: prInfo.title,\n              author: prInfo.author,\n              branch: prInfo.head,\n              base: prInfo.base,\n            }\n          : undefined,\n        files: prInfo?.files,\n        outputs: this.buildOutputContext(dependencyResults),\n        env: this.getSafeEnvironmentVariables(),\n      };\n\n      return await this.customToolExecutor.execute(config.method, methodArgs, context);\n    } else if (transport === 'stdio') {\n      return await this.executeStdioMethod(config, methodArgs, timeout);\n    } else if (transport === 'sse') {\n      return await this.executeSseMethod(config, methodArgs, timeout);\n    } else if (transport === 'http') {\n      return await this.executeHttpMethod(config, methodArgs, timeout);\n    } else {\n      throw new Error(`Unsupported transport: ${transport}`);\n    }\n  }\n\n  /**\n   * Generic method to execute MCP method with any transport\n   */\n  private async executeWithTransport(\n    transport: StdioClientTransport | SSEClientTransport | StreamableHTTPClientTransport,\n    config: McpCheckConfig,\n    methodArgs: Record<string, unknown>,\n    timeout: number,\n    transportName: string\n  ): Promise<unknown> {\n    // Create client\n    const client = new Client(\n      {\n        name: 'visor-mcp-client',\n        version: '1.0.0',\n      },\n      {\n        capabilities: {},\n      }\n    );\n\n    try {\n      // Connect with timeout\n      let timeoutId: NodeJS.Timeout | undefined;\n      try {\n        await Promise.race([\n          client.connect(transport),\n          new Promise((_, reject) => {\n            timeoutId = setTimeout(() => reject(new Error('Connection timeout')), timeout);\n          }),\n        ]);\n      } finally {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n      }\n\n      logger.debug(`Connected to MCP server via ${transportName}`);\n\n      // Log session ID for HTTP transport\n      if (transport instanceof StreamableHTTPClientTransport && transport.sessionId) {\n        logger.debug(`MCP Session ID: ${transport.sessionId}`);\n      }\n\n      // List available tools (for debugging)\n      try {\n        const toolsResult = await client.listTools();\n        logger.debug(`Available MCP tools: ${JSON.stringify(toolsResult?.tools || [])}`);\n      } catch (error) {\n        logger.debug(`Could not list MCP tools: ${error}`);\n      }\n\n      // Call the tool with timeout\n      let callTimeoutId: NodeJS.Timeout | undefined;\n      try {\n        const result = await Promise.race([\n          client.callTool({\n            name: config.method,\n            arguments: methodArgs,\n          }),\n          new Promise((_, reject) => {\n            callTimeoutId = setTimeout(() => reject(new Error('Request timeout')), timeout);\n          }),\n        ]);\n\n        logger.debug(`MCP method result: ${JSON.stringify(result)}`);\n        return result;\n      } finally {\n        if (callTimeoutId) {\n          clearTimeout(callTimeoutId);\n        }\n      }\n    } finally {\n      try {\n        await client.close();\n      } catch (error) {\n        logger.debug(`Error closing MCP client: ${error}`);\n      }\n    }\n  }\n\n  /**\n   * Execute MCP method using stdio transport\n   */\n  private async executeStdioMethod(\n    config: McpCheckConfig,\n    methodArgs: Record<string, unknown>,\n    timeout: number\n  ): Promise<unknown> {\n    const transport = new StdioClientTransport({\n      command: config.command!,\n      args: config.command_args as string[] | undefined,\n      env: config.env,\n      cwd: config.workingDirectory,\n    });\n\n    return this.executeWithTransport(\n      transport,\n      config,\n      methodArgs,\n      timeout,\n      `stdio: ${config.command}`\n    );\n  }\n\n  /**\n   * Execute MCP method using SSE transport\n   */\n  private async executeSseMethod(\n    config: McpCheckConfig,\n    methodArgs: Record<string, unknown>,\n    timeout: number\n  ): Promise<unknown> {\n    const requestInit: RequestInit = {};\n    if (config.headers) {\n      requestInit.headers = EnvironmentResolver.resolveHeaders(config.headers);\n    }\n\n    const transport = new SSEClientTransport(new URL(config.url!), {\n      requestInit,\n    });\n\n    return this.executeWithTransport(transport, config, methodArgs, timeout, `SSE: ${config.url}`);\n  }\n\n  /**\n   * Execute MCP method using Streamable HTTP transport\n   */\n  private async executeHttpMethod(\n    config: McpCheckConfig,\n    methodArgs: Record<string, unknown>,\n    timeout: number\n  ): Promise<unknown> {\n    const requestInit: RequestInit = {};\n    if (config.headers) {\n      requestInit.headers = EnvironmentResolver.resolveHeaders(config.headers);\n    }\n\n    const transport = new StreamableHTTPClientTransport(new URL(config.url!), {\n      requestInit,\n      sessionId: config.sessionId,\n    });\n\n    return this.executeWithTransport(\n      transport,\n      config,\n      methodArgs,\n      timeout,\n      `Streamable HTTP: ${config.url}`\n    );\n  }\n\n  /**\n   * Build output context from dependency results\n   */\n  private buildOutputContext(\n    dependencyResults?: Map<string, ReviewSummary>\n  ): Record<string, unknown> {\n    if (!dependencyResults) {\n      return {};\n    }\n\n    const outputs: Record<string, unknown> = {};\n    for (const [checkName, result] of dependencyResults) {\n      const summary = result as ReviewSummary & { output?: unknown };\n      outputs[checkName] = summary.output !== undefined ? summary.output : summary;\n    }\n\n    return outputs;\n  }\n\n  /**\n   * Get safe environment variables\n   */\n  private getSafeEnvironmentVariables(): Record<string, string> {\n    const safeVars: Record<string, string> = {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const allowedPrefixes: string[] = []; // replaced by buildSandboxEnv\n\n    const { buildSandboxEnv } = require('../utils/env-exposure');\n    const merged = buildSandboxEnv(process.env);\n    for (const [key, value] of Object.entries(merged)) {\n      safeVars[key] = String(value);\n    }\n    safeVars['PWD'] = process.cwd();\n    return safeVars;\n  }\n\n  /**\n   * Extract issues from MCP output\n   */\n  private extractIssuesFromOutput(\n    output: unknown\n  ): { issues: ReviewIssue[]; remainingOutput: unknown } | null {\n    if (output === null || output === undefined) {\n      return null;\n    }\n\n    // If output is a string, try to parse as JSON\n    if (typeof output === 'string') {\n      try {\n        const parsed = JSON.parse(output);\n        return this.extractIssuesFromOutput(parsed);\n      } catch {\n        return null;\n      }\n    }\n\n    // If output is an array of issues\n    if (Array.isArray(output)) {\n      const issues = this.normalizeIssueArray(output);\n      if (issues) {\n        return { issues, remainingOutput: undefined };\n      }\n      return null;\n    }\n\n    // If output is an object with issues property\n    if (typeof output === 'object') {\n      const record = output as Record<string, unknown>;\n\n      if (Array.isArray(record.issues)) {\n        const issues = this.normalizeIssueArray(record.issues);\n        if (!issues) {\n          return null;\n        }\n\n        const remaining = { ...record };\n        delete (remaining as { issues?: unknown }).issues;\n\n        return {\n          issues,\n          remainingOutput: Object.keys(remaining).length > 0 ? remaining : undefined,\n        };\n      }\n\n      // Check if output itself is a single issue\n      const singleIssue = this.normalizeIssue(record);\n      if (singleIssue) {\n        return { issues: [singleIssue], remainingOutput: undefined };\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Normalize an array of issues\n   */\n  private normalizeIssueArray(values: unknown[]): ReviewIssue[] | null {\n    const normalized: ReviewIssue[] = [];\n\n    for (const value of values) {\n      const issue = this.normalizeIssue(value);\n      if (!issue) {\n        return null;\n      }\n      normalized.push(issue);\n    }\n\n    return normalized;\n  }\n\n  /**\n   * Normalize a single issue\n   */\n  private normalizeIssue(raw: unknown): ReviewIssue | null {\n    if (!raw || typeof raw !== 'object') {\n      return null;\n    }\n\n    const data = raw as Record<string, unknown>;\n\n    const message = this.toTrimmedString(\n      data.message || data.text || data.description || data.summary\n    );\n    if (!message) {\n      return null;\n    }\n\n    const allowedSeverities = new Set(['info', 'warning', 'error', 'critical']);\n    const severityRaw = this.toTrimmedString(data.severity || data.level || data.priority);\n    let severity: ReviewIssue['severity'] = 'warning';\n    if (severityRaw) {\n      const lower = severityRaw.toLowerCase();\n      if (allowedSeverities.has(lower)) {\n        severity = lower as ReviewIssue['severity'];\n      }\n    }\n\n    const allowedCategories = new Set([\n      'security',\n      'performance',\n      'style',\n      'logic',\n      'documentation',\n    ]);\n    const categoryRaw = this.toTrimmedString(data.category || data.type || data.group);\n    let category: ReviewIssue['category'] = 'logic';\n    if (categoryRaw && allowedCategories.has(categoryRaw.toLowerCase())) {\n      category = categoryRaw.toLowerCase() as ReviewIssue['category'];\n    }\n\n    const file = this.toTrimmedString(data.file || data.path || data.filename) || 'system';\n    const line = this.toNumber(data.line || data.startLine || data.lineNumber) ?? 0;\n    const endLine = this.toNumber(data.endLine || data.end_line || data.stopLine);\n    const suggestion = this.toTrimmedString(data.suggestion);\n    const replacement = this.toTrimmedString(data.replacement);\n    const ruleId = this.toTrimmedString(data.ruleId || data.rule || data.id || data.check) || 'mcp';\n\n    return {\n      file,\n      line,\n      endLine: endLine ?? undefined,\n      ruleId,\n      message,\n      severity,\n      category,\n      suggestion: suggestion || undefined,\n      replacement: replacement || undefined,\n    };\n  }\n\n  private toTrimmedString(value: unknown): string | null {\n    if (typeof value === 'string') {\n      const trimmed = value.trim();\n      return trimmed.length > 0 ? trimmed : null;\n    }\n    if (value !== null && value !== undefined && typeof value.toString === 'function') {\n      const converted = String(value).trim();\n      return converted.length > 0 ? converted : null;\n    }\n    return null;\n  }\n\n  private toNumber(value: unknown): number | null {\n    if (value === null || value === undefined) {\n      return null;\n    }\n    const num = Number(value);\n    if (Number.isFinite(num)) {\n      return Math.trunc(num);\n    }\n    return null;\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'transport',\n      'command',\n      'command_args',\n      'env',\n      'workingDirectory',\n      'url',\n      'headers',\n      'sessionId',\n      'method',\n      'methodArgs',\n      'argsTransform',\n      'transform',\n      'transform_js',\n      'timeout',\n      'depends_on',\n      'on',\n      'if',\n      'group',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // MCP SDK is now a required dependency, so always available\n    return true;\n  }\n\n  getRequirements(): string[] {\n    return ['MCP method name specified', 'Transport configuration (stdio: command, sse/http: url)'];\n  }\n}\n","/**\n * Interactive terminal prompting (minimal TTY UI)\n */\n\nimport * as readline from 'readline';\n\n// Global, process-wide guard to ensure we never open two readline prompts at once.\n// This is crucial because the engine may (due to routing) attempt to schedule\n// a second human-input step while the first is still waiting. Two concurrent\n// readline instances on the same TTY cause duplicated keystrokes and other\n// erratic behavior. We serialize prompts with a tiny async mutex.\nlet activePrompt = false;\nconst waiters: Array<() => void> = [];\n\nasync function acquirePromptLock(): Promise<void> {\n  if (!activePrompt) {\n    activePrompt = true;\n    return;\n  }\n  await new Promise<void>(resolve => waiters.push(resolve));\n  activePrompt = true;\n}\n\nfunction releasePromptLock(): void {\n  activePrompt = false;\n  const next = waiters.shift();\n  if (next) next();\n}\n\nexport interface PromptOptions {\n  /** The prompt text to display */\n  prompt: string;\n  /** Placeholder text (shown in dim color) */\n  placeholder?: string;\n  /** Allow multiline input (Ctrl+D to finish) */\n  multiline?: boolean;\n  /** Timeout in milliseconds */\n  timeout?: number;\n  /** Default value if timeout occurs */\n  defaultValue?: string;\n  /** Allow empty input */\n  allowEmpty?: boolean;\n}\n/**\n * Prompt user for input with a beautiful interactive UI\n */\nexport async function interactivePrompt(options: PromptOptions): Promise<string> {\n  await acquirePromptLock();\n  return new Promise((resolve, reject) => {\n    const dbg = process.env.VISOR_DEBUG === 'true';\n    try {\n      if (dbg) {\n        const counts: Record<string, number> = {\n          data: process.stdin.listenerCount('data'),\n          end: process.stdin.listenerCount('end'),\n          error: process.stdin.listenerCount('error'),\n          readable: process.stdin.listenerCount('readable'),\n          close: process.stdin.listenerCount('close'),\n        } as any;\n        console.error(\n          `[human-input] starting prompt: isTTY=${!!process.stdin.isTTY} active=${activePrompt} waiters=${waiters.length} listeners=${JSON.stringify(counts)}`\n        );\n      }\n    } catch {}\n    // Ensure stdin is in a sane state for a fresh interactive session\n    try {\n      if (process.stdin.isTTY && typeof (process.stdin as any).setRawMode === 'function') {\n        // We use line-based input; disable raw mode just in case\n        (process.stdin as any).setRawMode(false);\n      }\n      // Always resume stdin before creating the interface\n      process.stdin.resume();\n    } catch {}\n\n    // Ensure encoding is set for predictable behavior\n    try {\n      process.stdin.setEncoding('utf8');\n    } catch {}\n\n    let rl: readline.Interface | undefined;\n\n    const allowEmpty = options.allowEmpty ?? false;\n    const multiline = options.multiline ?? false;\n    const defaultValue = options.defaultValue;\n\n    let timeoutId: NodeJS.Timeout | undefined;\n    const cleanup = () => {\n      if (timeoutId) clearTimeout(timeoutId);\n      try {\n        rl?.removeAllListeners();\n      } catch {}\n      try {\n        rl?.close();\n      } catch {}\n      // Hardening: make sure no stray listeners remain on stdin between loops\n      // Do not blanket-remove listeners from process.stdin; a fresh readline\n      // instance will manage its own listeners. Over-removing here can leave\n      // the next interface in a bad state (no keypress events).\n      try {\n        if (process.stdin.isTTY && typeof (process.stdin as any).setRawMode === 'function') {\n          (process.stdin as any).setRawMode(false);\n        }\n      } catch {}\n      try {\n        process.stdin.pause();\n      } catch {}\n      // Release the global lock so a queued prompt (if any) may proceed\n      try {\n        releasePromptLock();\n      } catch {}\n      // If stdout/stderr were temporarily wrapped by the question handler, restore them now\n      try {\n        if ((process.stdout as any).__restoreWrites) {\n          (process.stdout as any).__restoreWrites();\n        }\n      } catch {}\n      try {\n        if ((process.stderr as any).__restoreWrites) {\n          (process.stderr as any).__restoreWrites();\n        }\n      } catch {}\n      try {\n        if (dbg) {\n          const counts: Record<string, number> = {\n            data: process.stdin.listenerCount('data'),\n            end: process.stdin.listenerCount('end'),\n            error: process.stdin.listenerCount('error'),\n            readable: process.stdin.listenerCount('readable'),\n            close: process.stdin.listenerCount('close'),\n          } as any;\n          console.error(\n            `[human-input] cleanup: isTTY=${!!process.stdin.isTTY} active=false waiters=${waiters.length} listeners=${JSON.stringify(counts)}`\n          );\n        }\n      } catch {}\n    };\n    const finish = (value: string) => {\n      cleanup();\n      resolve(value);\n    };\n\n    // Optional timeout (no default)\n    if (options.timeout && options.timeout > 0) {\n      timeoutId = setTimeout(() => {\n        cleanup();\n        if (defaultValue !== undefined) return resolve(defaultValue);\n        return reject(new Error('Input timeout'));\n      }, options.timeout);\n    }\n\n    // Print minimal header with dashed separators\n    const header: string[] = [];\n    if (options.prompt && options.prompt.trim()) header.push(options.prompt.trim());\n    if (multiline) header.push('(Ctrl+D to submit)');\n    if (options.placeholder && !multiline) header.push(options.placeholder);\n    const width = Math.max(\n      20,\n      Math.min((process.stdout && (process.stdout as any).columns) || 80, 100)\n    );\n    const dash = '-'.repeat(width);\n    try {\n      console.log('\\n' + dash);\n      if (header.length) console.log(header.join('\\n'));\n      console.log(dash);\n    } catch {}\n\n    // No echo-suppression hacks ‚Äî we fix the root cause below by using raw-mode\n    // input for single-line prompts, so the terminal never replays the line.\n\n    if (multiline) {\n      rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout,\n        terminal: true,\n      });\n      let buf = '';\n      process.stdout.write('> ');\n      rl.on('line', line => {\n        buf += (buf ? '\\n' : '') + line;\n        process.stdout.write('> ');\n      });\n      rl.on('close', () => {\n        const trimmed = buf.trim();\n        if (!trimmed && !allowEmpty && defaultValue === undefined) {\n          return reject(new Error('Empty input not allowed'));\n        }\n        return finish(trimmed || defaultValue || '');\n      });\n      rl.on('SIGINT', () => {\n        try {\n          // Print a clean newline and exit immediately with 130 (SIGINT)\n          process.stdout.write('\\n');\n        } catch {}\n        cleanup();\n        process.exit(130);\n      });\n    } else {\n      // Root cause fix: raw-mode single-line input without readline echo.\n      const readLineRaw = async (): Promise<string> => {\n        return new Promise<string>(resolveRaw => {\n          let buf = '';\n          const onData = (chunk: Buffer) => {\n            const s = chunk.toString('utf8');\n            for (let i = 0; i < s.length; i++) {\n              const ch = s[i];\n              const code = s.charCodeAt(i);\n              if (ch === '\\n' || ch === '\\r') {\n                try {\n                  process.stdout.write('\\n');\n                } catch {}\n                teardown();\n                resolveRaw(buf);\n                return;\n              }\n              if (ch === '\\b' || code === 127) {\n                if (buf.length > 0) {\n                  buf = buf.slice(0, -1);\n                  try {\n                    process.stdout.write('\\b \\b');\n                  } catch {}\n                }\n                continue;\n              }\n              if (code === 3) {\n                // Ctrl+C\n                try {\n                  process.stdout.write('\\n');\n                } catch {}\n                teardown();\n                process.exit(130);\n              }\n              if (code >= 32) {\n                buf += ch;\n                try {\n                  process.stdout.write(ch);\n                } catch {}\n              }\n            }\n          };\n          const teardown = () => {\n            try {\n              process.stdin.off('data', onData);\n            } catch {}\n            try {\n              if (process.stdin.isTTY && typeof (process.stdin as any).setRawMode === 'function') {\n                (process.stdin as any).setRawMode(false);\n              }\n            } catch {}\n          };\n          try {\n            if (process.stdin.isTTY && typeof (process.stdin as any).setRawMode === 'function') {\n              (process.stdin as any).setRawMode(true);\n            }\n          } catch {}\n          process.stdin.on('data', onData);\n          try {\n            process.stdout.write('> ');\n          } catch {}\n        });\n      };\n      (async () => {\n        const answer = await readLineRaw();\n        const trimmed = (answer || '').trim();\n        if (!trimmed && !allowEmpty && defaultValue === undefined) {\n          cleanup();\n          return reject(new Error('Empty input not allowed'));\n        }\n        return finish(trimmed || defaultValue || '');\n      })().catch(err => {\n        cleanup();\n        reject(err);\n      });\n    }\n  });\n}\n\n/**\n * Simple prompt without fancy UI (for non-TTY environments)\n */\nexport async function simplePrompt(prompt: string): Promise<string> {\n  return new Promise(resolve => {\n    const rl = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout,\n    });\n\n    rl.on('SIGINT', () => {\n      try {\n        process.stdout.write('\\n');\n      } catch {}\n      rl.close();\n      process.exit(130);\n    });\n\n    rl.question(`${prompt}\\n> `, answer => {\n      rl.close();\n      resolve(answer.trim());\n    });\n  });\n}\n","/**\n * Utilities for reading from stdin\n */\n\n/**\n * Check if stdin has data available (is being piped)\n */\nexport function isStdinAvailable(): boolean {\n  // Check if stdin is a TTY (interactive terminal)\n  // If it's not a TTY, it means data is being piped\n  return !process.stdin.isTTY;\n}\n\n/**\n * Read all data from stdin\n * @param timeout Optional timeout in milliseconds\n * @param maxSize Maximum size in bytes (default: 1MB)\n * @returns Promise that resolves with the stdin content\n */\nexport async function readStdin(timeout?: number, maxSize: number = 1024 * 1024): Promise<string> {\n  return new Promise((resolve, reject) => {\n    let data = '';\n    let timeoutId: NodeJS.Timeout | undefined;\n\n    if (timeout) {\n      timeoutId = setTimeout(() => {\n        cleanup();\n        reject(new Error(`Stdin read timeout after ${timeout}ms`));\n      }, timeout);\n    }\n\n    const cleanup = () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      process.stdin.removeListener('data', onData);\n      process.stdin.removeListener('end', onEnd);\n      process.stdin.removeListener('error', onError);\n      // Pause stdin to prevent resource leaks\n      process.stdin.pause();\n    };\n\n    const onData = (chunk: Buffer) => {\n      data += chunk.toString();\n      // Security: Prevent DoS through large input\n      if (data.length > maxSize) {\n        cleanup();\n        reject(new Error(`Input exceeds maximum size of ${maxSize} bytes`));\n      }\n    };\n\n    const onEnd = () => {\n      cleanup();\n      resolve(data.trim());\n    };\n\n    const onError = (err: Error) => {\n      cleanup();\n      reject(err);\n    };\n\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', onData);\n    process.stdin.on('end', onEnd);\n    process.stdin.on('error', onError);\n\n    // Resume stdin in case it's paused\n    process.stdin.resume();\n  });\n}\n\n/**\n * Try to read from stdin if available, otherwise return null\n * @param timeout Optional timeout in milliseconds\n * @param maxSize Maximum size in bytes (default: 1MB)\n * @returns Promise that resolves with stdin content or null if not available\n */\nexport async function tryReadStdin(\n  timeout?: number,\n  maxSize: number = 1024 * 1024\n): Promise<string | null> {\n  if (!isStdinAvailable()) {\n    return null;\n  }\n\n  try {\n    return await readStdin(timeout, maxSize);\n  } catch {\n    // If reading fails, return null\n    return null;\n  }\n}\n","import { CheckProvider, CheckProviderConfig, ExecutionContext } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { HumanInputRequest } from '../types/config';\nimport { interactivePrompt, simplePrompt } from '../utils/interactive-prompt';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { tryReadStdin } from '../utils/stdin-reader';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n/**\n * Human input check provider that pauses workflow to request user input.\n *\n * Supports four modes:\n * 1. CLI with --message argument (inline or file path)\n * 2. CLI with piped stdin\n * 3. CLI interactive mode (beautiful terminal UI)\n * 4. SDK mode with onHumanInput hook\n *\n * Example config:\n * ```yaml\n * checks:\n *   approval:\n *     type: human-input\n *     prompt: \"Do you approve? (yes/no)\"\n *     allow_empty: false\n *     timeout: 300000\n * ```\n */\nexport class HumanInputCheckProvider extends CheckProvider {\n  private liquid?: Liquid;\n  /**\n   * @deprecated Use ExecutionContext.cliMessage instead\n   * Kept for backward compatibility\n   */\n  private static cliMessage: string | undefined;\n\n  /**\n   * @deprecated Use ExecutionContext.hooks instead\n   * Kept for backward compatibility\n   */\n  private static hooks: { onHumanInput?: (request: HumanInputRequest) => Promise<string> } = {};\n\n  /**\n   * Set the CLI message value (from --message argument)\n   * @deprecated Use ExecutionContext.cliMessage instead\n   */\n  static setCLIMessage(message: string | undefined): void {\n    HumanInputCheckProvider.cliMessage = message;\n  }\n\n  /**\n   * Get the current CLI message value\n   * @deprecated Use ExecutionContext.cliMessage instead\n   */\n  static getCLIMessage(): string | undefined {\n    return HumanInputCheckProvider.cliMessage;\n  }\n\n  /**\n   * Set hooks for SDK mode\n   * @deprecated Use ExecutionContext.hooks instead\n   */\n  static setHooks(hooks: { onHumanInput?: (request: HumanInputRequest) => Promise<string> }): void {\n    HumanInputCheckProvider.hooks = hooks;\n  }\n\n  getName(): string {\n    return 'human-input';\n  }\n\n  getDescription(): string {\n    return 'Prompts for human input during workflow execution (CLI interactive or SDK hook)';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'human-input'\n    if (cfg.type !== 'human-input') {\n      return false;\n    }\n\n    // Prompt is required\n    if (!cfg.prompt || typeof cfg.prompt !== 'string') {\n      console.error('human-input check requires a \"prompt\" field');\n      return false;\n    }\n\n    return true;\n  }\n\n  /** Build a template context for Liquid rendering */\n  private buildTemplateContext(\n    prInfo: PRInfo,\n    dependencyResults?: Map<string, ReviewSummary>,\n    outputHistory?: Map<string, unknown[]>,\n    _context?: ExecutionContext\n  ): Record<string, unknown> {\n    const ctx: Record<string, unknown> = {};\n    // pr context\n    try {\n      ctx.pr = {\n        number: prInfo.number,\n        title: prInfo.title,\n        body: prInfo.body,\n        author: prInfo.author,\n        base: prInfo.base,\n        head: prInfo.head,\n        files: (prInfo.files || []).map(f => ({\n          filename: f.filename,\n          status: f.status,\n          additions: f.additions,\n          deletions: f.deletions,\n          changes: f.changes,\n        })),\n      };\n    } catch {}\n    // event + env\n    try {\n      const safeEnv = (() => {\n        try {\n          const { buildSandboxEnv } = require('../utils/env-exposure');\n          return buildSandboxEnv(process.env);\n        } catch {\n          return {} as Record<string, string>;\n        }\n      })();\n      (ctx as any).event = { event_name: (prInfo as any)?.eventType || 'manual' };\n      (ctx as any).env = safeEnv;\n    } catch {}\n    // utils helpers\n    (ctx as any).utils = {\n      now: new Date().toISOString(),\n      today: new Date().toISOString().split('T')[0],\n    };\n    // outputs: expose raw outputs from dependency results\n    const outputs: Record<string, unknown> = {};\n    const outputsRaw: Record<string, unknown> = {};\n    if (dependencyResults) {\n      for (const [name, res] of dependencyResults.entries()) {\n        const summary = res as ReviewSummary & { output?: unknown };\n        if (typeof name === 'string' && name.endsWith('-raw')) {\n          outputsRaw[name.slice(0, -4)] = summary.output !== undefined ? summary.output : summary;\n        } else {\n          outputs[name] = summary.output !== undefined ? summary.output : summary;\n        }\n      }\n    }\n    ctx.outputs = outputs;\n    (ctx as any).outputs_raw = outputsRaw;\n    // outputs_history: expose full history if available\n    const hist: Record<string, unknown[]> = {};\n    if (outputHistory) {\n      for (const [k, v] of outputHistory.entries()) hist[k] = Array.isArray(v) ? v : [];\n    }\n    (ctx as any).outputs_history = hist;\n    return ctx;\n  }\n\n  /**\n   * Check if a string looks like a file path\n   */\n  private looksLikePath(str: string): boolean {\n    return str.includes('/') || str.includes('\\\\');\n  }\n\n  /**\n   * Sanitize user input to prevent injection attacks in dependent checks\n   * Removes potentially dangerous characters while preserving useful input\n   */\n  private sanitizeInput(input: string): string {\n    // Heuristic: collapse accidental per-character duplication (\"stutter\") often caused by\n    // TTY echo races. We only apply this when most adjacent ASCII chars are doubled.\n    const collapseStutter = (s: string): string => {\n      if (!s || s.length < 4) return s;\n      let dupPairs = 0;\n      let pairs = 0;\n      for (let i = 0; i + 1 < s.length; i++) {\n        const a = s[i];\n        const b = s[i + 1];\n        if (/^[\\x20-\\x7E]$/.test(a) && /^[\\x20-\\x7E]$/.test(b)) {\n          pairs++;\n          if (a === b) dupPairs++;\n        }\n      }\n      const ratio = pairs > 0 ? dupPairs / pairs : 0;\n      if (ratio < 0.5) return s; // keep as-is unless roughly half of pairs are doubled\n      let out = '';\n      for (let i = 0; i < s.length; i++) {\n        const a = s[i];\n        const b = i + 1 < s.length ? s[i + 1] : '';\n        if (b && a === b) {\n          out += a;\n          i++; // skip the duplicate\n        } else {\n          out += a;\n        }\n      }\n      return out;\n    };\n\n    input = collapseStutter(input);\n    // Remove null bytes (C-string injection)\n    let sanitized = input.replace(/\\0/g, '');\n\n    // Remove control characters except newlines and tabs\n    sanitized = sanitized.replace(/[\\x00-\\x08\\x0B-\\x0C\\x0E-\\x1F\\x7F]/g, '');\n\n    // Limit length to prevent memory issues (100KB max)\n    const maxLength = 100 * 1024;\n    if (sanitized.length > maxLength) {\n      sanitized = sanitized.substring(0, maxLength);\n    }\n\n    return sanitized;\n  }\n\n  /**\n   * Try to read message from file if it exists\n   * Validates path to prevent directory traversal attacks\n   */\n  private async tryReadFile(filePath: string): Promise<string | null> {\n    try {\n      // Handle both absolute and relative paths\n      const absolutePath = path.isAbsolute(filePath)\n        ? filePath\n        : path.resolve(process.cwd(), filePath);\n\n      // Normalize path to resolve .. and . components\n      const normalizedPath = path.normalize(absolutePath);\n\n      // Security: Prevent path traversal attacks\n      // Only allow files within current working directory or its subdirectories\n      const cwd = process.cwd();\n      if (!normalizedPath.startsWith(cwd + path.sep) && normalizedPath !== cwd) {\n        // Path is outside working directory\n        return null;\n      }\n\n      // Use async file access check instead of sync existsSync\n      try {\n        await fs.promises.access(normalizedPath, fs.constants.R_OK);\n        const stats = await fs.promises.stat(normalizedPath);\n\n        // Only read regular files, not directories or special files\n        if (!stats.isFile()) {\n          return null;\n        }\n\n        const content = await fs.promises.readFile(normalizedPath, 'utf-8');\n        return content.trim();\n      } catch {\n        // File doesn't exist or isn't readable\n        return null;\n      }\n    } catch {\n      // If file read fails, treat as literal string\n    }\n    return null;\n  }\n\n  /**\n   * Get user input through various methods\n   */\n  private async getUserInput(\n    checkName: string,\n    config: CheckProviderConfig,\n    context?: ExecutionContext\n  ): Promise<string> {\n    // Test runner mock support: if a mock is provided for this step, use it\n    try {\n      const mockVal = context?.hooks?.mockForStep?.(checkName);\n      if (mockVal !== undefined && mockVal !== null) {\n        const s = String(mockVal);\n        return s;\n      }\n    } catch {}\n    const prompt = (config.prompt as string) || 'Please provide input:';\n    const placeholder = (config.placeholder as string | undefined) || 'Enter your response...';\n    const allowEmpty = (config.allow_empty as boolean | undefined) ?? false;\n    const multiline = (config.multiline as boolean | undefined) ?? false;\n    const timeout = config.timeout ? config.timeout * 1000 : undefined; // Convert to ms\n    const defaultValue = config.default as string | undefined;\n\n    // In test/CI modes, never block for input. Use default or empty string.\n    const testMode = String(process.env.VISOR_TEST_MODE || '').toLowerCase() === 'true';\n    const ciMode =\n      String(process.env.CI || '').toLowerCase() === 'true' ||\n      String(process.env.GITHUB_ACTIONS || '').toLowerCase() === 'true';\n    if (testMode || ciMode) {\n      const val = (config.default as string | undefined) || '';\n      return val;\n    }\n\n    // Get cliMessage from context (new way) or static property (backward compat)\n    const cliMessage = context?.cliMessage ?? HumanInputCheckProvider.cliMessage;\n\n    // Priority 1: Check for --message CLI argument\n    if (cliMessage !== undefined) {\n      const message = cliMessage;\n\n      // Check if it looks like a path and try to read the file\n      if (this.looksLikePath(message)) {\n        const fileContent = await this.tryReadFile(message);\n        if (fileContent !== null) {\n          return fileContent;\n        }\n      }\n\n      // Otherwise, use as literal message\n      return message;\n    }\n\n    // Priority 2: Check for piped stdin\n    const stdinInput = await tryReadStdin(timeout);\n    if (stdinInput !== null && stdinInput.length > 0) {\n      return stdinInput;\n    }\n\n    // Priority 3: SDK hook mode\n    // Get hooks from context (new way) or static property (backward compat)\n    const hooks = context?.hooks ?? HumanInputCheckProvider.hooks;\n\n    if (hooks?.onHumanInput) {\n      const request: HumanInputRequest = {\n        checkId: checkName,\n        prompt,\n        placeholder,\n        allowEmpty,\n        multiline,\n        timeout,\n        default: defaultValue,\n      };\n\n      try {\n        const result = await hooks.onHumanInput(request);\n        return result;\n      } catch (error) {\n        throw new Error(\n          `Hook onHumanInput failed: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    // Priority 4: Interactive terminal prompt (if TTY available)\n    if (process.stdin.isTTY) {\n      try {\n        const result = await interactivePrompt({\n          prompt,\n          placeholder,\n          multiline,\n          timeout,\n          defaultValue,\n          allowEmpty,\n        });\n        return result;\n      } catch (error) {\n        throw new Error(\n          `Interactive prompt failed: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    // Priority 5: Simple prompt (fallback for non-TTY)\n    try {\n      const result = await simplePrompt(prompt);\n      if (!result && !allowEmpty && !defaultValue) {\n        throw new Error('Empty input not allowed');\n      }\n      return result || defaultValue || '';\n    } catch (error) {\n      throw new Error(\n        `Simple prompt failed: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  async execute(\n    _prInfo: PRInfo,\n    config: CheckProviderConfig,\n    _dependencyResults?: Map<string, ReviewSummary>,\n    context?: ExecutionContext\n  ): Promise<ReviewSummary> {\n    const checkName = config.checkName || 'human-input';\n\n    try {\n      // Render Liquid templates in prompt/placeholder if any\n      try {\n        this.liquid =\n          this.liquid || createExtendedLiquid({ strictVariables: false, strictFilters: false });\n        const tctx = this.buildTemplateContext(\n          _prInfo,\n          _dependencyResults,\n          (config as any).__outputHistory as Map<string, unknown[]> | undefined,\n          context\n        );\n        if (typeof config.prompt === 'string') {\n          let rendered = await this.liquid.parseAndRender(config.prompt, tctx);\n          // If Liquid markers remain (e.g., due to nested/guarded templates), try a second pass\n          if (/\\{\\{|\\{%/.test(rendered)) {\n            try {\n              rendered = await this.liquid.parseAndRender(rendered, tctx);\n            } catch {}\n          }\n          // Expose the final rendered prompt to the test runner (like AI provider does)\n          try {\n            const stepName = (config as any).checkName || 'unknown';\n            context?.hooks?.onPromptCaptured?.({\n              step: String(stepName),\n              provider: 'human-input',\n              prompt: rendered,\n            });\n          } catch {}\n          config = { ...config, prompt: rendered };\n        }\n        if (typeof config.placeholder === 'string') {\n          let ph = await this.liquid.parseAndRender(config.placeholder as string, tctx);\n          if (/\\{\\{|\\{%/.test(ph)) {\n            try {\n              ph = await this.liquid.parseAndRender(ph, tctx);\n            } catch {}\n          }\n          (config as any).placeholder = ph;\n        }\n      } catch (e) {\n        // Always show Liquid errors with a helpful snippet and caret\n        const err: any = e || {};\n        const raw = String((config as any)?.prompt || '');\n        const lines = raw.split(/\\r?\\n/);\n        const lineNum: number = Number(err.line || err?.token?.line || err?.location?.line || 0);\n        const colNum: number = Number(err.col || err?.token?.col || err?.location?.col || 0);\n        let snippet = '';\n        if (lineNum > 0) {\n          const start = Math.max(1, lineNum - 3);\n          const end = Math.max(lineNum + 2, lineNum);\n          const width = String(end).length;\n          for (let i = start; i <= Math.min(end, lines.length); i++) {\n            const ln = `${String(i).padStart(width, ' ')} | ${lines[i - 1] ?? ''}`;\n            snippet += ln + '\\n';\n            if (i === lineNum) {\n              const caretPad = ' '.repeat(Math.max(0, colNum > 1 ? colNum - 1 : 0) + width + 3);\n              snippet += caretPad + '^\\n';\n            }\n          }\n        }\n        try {\n          console.error(\n            `‚ö†Ô∏è  human-input: Liquid render failed: ${\n              e instanceof Error ? e.message : String(e)\n            }\\n${snippet}`\n          );\n        } catch {}\n        // Continue with raw strings as a fallback\n      }\n      // Get user input (pass context for non-static state)\n      const userInput = await this.getUserInput(checkName, config, context);\n\n      // Sanitize input to prevent injection attacks in dependent checks\n      const sanitizedInput = this.sanitizeInput(userInput);\n\n      // Return structured output with timestamp for consistent history/merging\n      return {\n        issues: [],\n        output: { text: sanitizedInput, ts: Date.now() },\n      } as ReviewSummary & { output: { text: string; ts: number } };\n    } catch (error) {\n      // If there's an error getting input, return an error issue\n      return {\n        issues: [\n          {\n            file: '',\n            line: 0,\n            ruleId: 'human-input-error',\n            message: `Failed to get user input: ${\n              error instanceof Error ? error.message : String(error)\n            }`,\n            severity: 'error',\n            category: 'logic',\n          },\n        ],\n      };\n    }\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'prompt',\n      'placeholder',\n      'allow_empty',\n      'multiline',\n      'timeout',\n      'default',\n      'depends_on',\n      'on',\n      'if',\n      'group',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // Human input provider is always available\n    // It will fall back to simple prompts if interactive mode isn't available\n    return true;\n  }\n\n  getRequirements(): string[] {\n    return [\n      'No external dependencies required',\n      'Works in CLI mode with --message argument, piped stdin, or interactive prompts',\n      'SDK mode requires onHumanInput hook to be configured',\n    ];\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { Liquid } from 'liquidjs';\nimport Sandbox from '@nyariv/sandboxjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { logger } from '../logger';\nimport { MemoryStore } from '../memory-store';\nimport { createSecureSandbox, compileAndRun } from '../utils/sandbox';\nimport { buildProviderTemplateContext } from '../utils/template-context';\nimport { createSyncMemoryOps } from '../utils/script-memory-ops';\n\n/**\n * Provider that executes JavaScript in a secure sandbox using\n * a first-class step: `type: 'script'` + `content: | ...`.\n */\nexport class ScriptCheckProvider extends CheckProvider {\n  private liquid: Liquid;\n\n  constructor() {\n    super();\n    this.liquid = createExtendedLiquid({\n      strictVariables: false,\n      strictFilters: false,\n    });\n  }\n\n  private createSecureSandbox(): Sandbox {\n    return createSecureSandbox();\n  }\n\n  getName(): string {\n    return 'script';\n  }\n\n  getDescription(): string {\n    return 'Execute JavaScript with access to PR context, dependency outputs, and memory.';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') return false;\n    const cfg = config as CheckProviderConfig & { content?: string };\n    if (typeof cfg.content !== 'string') return false;\n    const trimmed = cfg.content.trim();\n    if (trimmed.length === 0) return false;\n    try {\n      const bytes = Buffer.byteLength(cfg.content, 'utf8');\n      if (bytes > 1024 * 1024) return false; // 1MB cap\n    } catch {}\n    if (cfg.content.indexOf('\\u0000') >= 0) return false;\n    return true;\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig & { content?: string },\n    dependencyResults?: Map<string, ReviewSummary>,\n    _sessionInfo?: {\n      parentSessionId?: string;\n      reuseSession?: boolean;\n    } & import('./check-provider.interface').ExecutionContext\n  ): Promise<ReviewSummary> {\n    const script = String(config.content || '');\n    const memoryStore = MemoryStore.getInstance();\n    const ctx = buildProviderTemplateContext(\n      prInfo,\n      dependencyResults,\n      memoryStore,\n      (config as any).__outputHistory as Map<string, unknown[]> | undefined,\n      (_sessionInfo as any)?.stageHistoryBase as Record<string, number> | undefined,\n      { attachMemoryReadHelpers: false }\n    );\n    try {\n      if (process.env.VISOR_DEBUG === 'true') {\n        const hist: any = (ctx as any).outputs_history || {};\n        const len = Array.isArray(hist['refine']) ? hist['refine'].length : 0;\n\n        console.error(`[script] history.refine.len=${len}`);\n      }\n    } catch {}\n\n    // Attach synchronous memory ops consistent with memory provider\n    const { ops, needsSave } = createSyncMemoryOps(memoryStore);\n    (ctx as any).memory = ops as unknown as Record<string, unknown>;\n\n    // Evaluate the script in a secure sandbox (per-execution instance)\n    const sandbox = this.createSecureSandbox();\n    let result: unknown;\n    try {\n      result = compileAndRun<unknown>(\n        sandbox,\n        script,\n        { ...ctx },\n        {\n          injectLog: true,\n          wrapFunction: true,\n          logPrefix: '[script]',\n        }\n      );\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : 'Unknown error';\n      logger.error(`[script] execution error: ${msg}`);\n      return {\n        issues: [\n          {\n            file: 'script',\n            line: 0,\n            ruleId: 'script/execution_error',\n            message: msg,\n            severity: 'error',\n            category: 'logic',\n          },\n        ],\n        output: null,\n      } as ReviewSummary;\n    }\n\n    // Persist file-backed memory once if needed\n    try {\n      if (\n        needsSave() &&\n        memoryStore.getConfig().storage === 'file' &&\n        memoryStore.getConfig().auto_save\n      ) {\n        await memoryStore.save();\n      }\n    } catch (e) {\n      logger.warn(`[script] memory save failed: ${e instanceof Error ? e.message : String(e)}`);\n    }\n\n    try {\n      if (process.env.VISOR_DEBUG === 'true') {\n        const name = String((config as any).checkName || '');\n        const t = typeof result;\n        console.error(\n          `[script-return] ${name} outputType=${t} hasArray=${Array.isArray(result)} hasObj=${result && typeof result === 'object'}`\n        );\n      }\n    } catch {}\n    const out: any = { issues: [], output: result } as ReviewSummary & { output: unknown };\n    try {\n      (out as any).__histTracked = true;\n    } catch {}\n    return out;\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'content',\n      'depends_on',\n      'group',\n      'on',\n      'if',\n      'fail_if',\n      'on_fail',\n      'on_success',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    return true;\n  }\n\n  getRequirements(): string[] {\n    return ['No external dependencies required'];\n  }\n\n  // No local buildTemplateContext; uses shared builder above\n}\n","/**\n * Dependency resolution and execution ordering for checks\n */\n\nexport interface CheckNode {\n  id: string;\n  dependencies: string[];\n  dependents: string[];\n  depth: number;\n}\n\nexport interface ExecutionGroup {\n  /** Checks that can run in parallel */\n  parallel: string[];\n  /** Execution level/wave (0 = no dependencies, 1 = depends on level 0, etc.) */\n  level: number;\n}\n\nexport interface DependencyGraph {\n  nodes: Map<string, CheckNode>;\n  executionOrder: ExecutionGroup[];\n  hasCycles: boolean;\n  cycleNodes?: string[];\n}\n\nexport class DependencyResolver {\n  /**\n   * Build dependency graph from check dependencies\n   */\n  static buildDependencyGraph(checkDependencies: Record<string, string[]>): DependencyGraph {\n    const nodes = new Map<string, CheckNode>();\n\n    // Initialize all nodes\n    for (const checkId of Object.keys(checkDependencies)) {\n      nodes.set(checkId, {\n        id: checkId,\n        dependencies: checkDependencies[checkId] || [],\n        dependents: [],\n        depth: 0,\n      });\n    }\n\n    // Build bidirectional relationships\n    for (const [checkId, dependencies] of Object.entries(checkDependencies)) {\n      for (const depId of dependencies || []) {\n        if (!nodes.has(depId)) {\n          throw new Error(`Check \"${checkId}\" depends on \"${depId}\" but \"${depId}\" is not defined`);\n        }\n\n        const depNode = nodes.get(depId)!;\n        depNode.dependents.push(checkId);\n      }\n    }\n\n    // Detect cycles using DFS\n    const cycleDetection = this.detectCycles(nodes);\n    if (cycleDetection.hasCycles) {\n      return {\n        nodes,\n        executionOrder: [],\n        hasCycles: true,\n        cycleNodes: cycleDetection.cycleNodes,\n      };\n    }\n\n    // Calculate execution order using topological sort\n    const executionOrder = this.topologicalSort(nodes);\n\n    return {\n      nodes,\n      executionOrder,\n      hasCycles: false,\n    };\n  }\n\n  /**\n   * Detect cycles in the dependency graph using DFS\n   */\n  private static detectCycles(nodes: Map<string, CheckNode>): {\n    hasCycles: boolean;\n    cycleNodes?: string[];\n  } {\n    const visited = new Set<string>();\n    const recursionStack = new Set<string>();\n    const cycleNodes: string[] = [];\n\n    const dfs = (nodeId: string): boolean => {\n      if (recursionStack.has(nodeId)) {\n        cycleNodes.push(nodeId);\n        return true;\n      }\n      if (visited.has(nodeId)) {\n        return false;\n      }\n\n      visited.add(nodeId);\n      recursionStack.add(nodeId);\n\n      const node = nodes.get(nodeId);\n      if (node) {\n        for (const depId of node.dependencies) {\n          if (dfs(depId)) {\n            cycleNodes.push(nodeId);\n            return true;\n          }\n        }\n      }\n\n      recursionStack.delete(nodeId);\n      return false;\n    };\n\n    for (const nodeId of nodes.keys()) {\n      if (!visited.has(nodeId)) {\n        if (dfs(nodeId)) {\n          return { hasCycles: true, cycleNodes: [...new Set(cycleNodes)] };\n        }\n      }\n    }\n\n    return { hasCycles: false };\n  }\n\n  /**\n   * Perform topological sort to determine execution order\n   * Groups checks that can run in parallel at each level\n   */\n  private static topologicalSort(nodes: Map<string, CheckNode>): ExecutionGroup[] {\n    const remainingNodes = new Map(nodes);\n    const executionGroups: ExecutionGroup[] = [];\n    let level = 0;\n\n    while (remainingNodes.size > 0) {\n      // Find nodes with no remaining dependencies\n      const readyNodes: string[] = [];\n\n      for (const [nodeId, node] of remainingNodes.entries()) {\n        const unmetDependencies = node.dependencies.filter(depId => remainingNodes.has(depId));\n        if (unmetDependencies.length === 0) {\n          readyNodes.push(nodeId);\n        }\n      }\n\n      if (readyNodes.length === 0) {\n        // This shouldn't happen if cycle detection worked correctly\n        throw new Error('Unable to resolve dependencies - possible circular dependency detected');\n      }\n\n      // Add this group to execution order\n      executionGroups.push({\n        parallel: readyNodes,\n        level,\n      });\n\n      // Remove processed nodes\n      for (const nodeId of readyNodes) {\n        remainingNodes.delete(nodeId);\n      }\n\n      level++;\n    }\n\n    return executionGroups;\n  }\n\n  /**\n   * Validate that all dependencies exist\n   */\n  static validateDependencies(\n    checkIds: string[],\n    dependencies: Record<string, string[]>\n  ): { valid: boolean; errors: string[] } {\n    const errors: string[] = [];\n    const checkIdSet = new Set(checkIds);\n\n    for (const [checkId, deps] of Object.entries(dependencies)) {\n      if (!checkIdSet.has(checkId)) {\n        errors.push(`Check \"${checkId}\" is not in the list of available checks`);\n        continue;\n      }\n\n      for (const depId of deps || []) {\n        if (!checkIdSet.has(depId)) {\n          errors.push(`Check \"${checkId}\" depends on \"${depId}\" which is not available`);\n        }\n      }\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n    };\n  }\n\n  /**\n   * Get all transitive dependencies (ancestors) for a given check\n   * This returns all checks that must complete before the given check can run,\n   * not just the direct dependencies.\n   *\n   * For example, if A -> B -> C, then:\n   * - getAllDependencies(C) returns [A, B]\n   * - getAllDependencies(B) returns [A]\n   * - getAllDependencies(A) returns []\n   *\n   * @param checkId The check to find dependencies for\n   * @param nodes The dependency graph nodes\n   * @returns Array of all transitive dependency IDs\n   */\n  static getAllDependencies(checkId: string, nodes: Map<string, CheckNode>): string[] {\n    const allDeps = new Set<string>();\n    const visited = new Set<string>();\n\n    const collectDependencies = (currentId: string) => {\n      if (visited.has(currentId)) {\n        return;\n      }\n      visited.add(currentId);\n\n      const node = nodes.get(currentId);\n      if (!node) {\n        return;\n      }\n\n      // Add direct dependencies and recurse\n      for (const depId of node.dependencies) {\n        allDeps.add(depId);\n        collectDependencies(depId);\n      }\n    };\n\n    collectDependencies(checkId);\n    return Array.from(allDeps);\n  }\n\n  /**\n   * Get execution statistics for debugging\n   */\n  static getExecutionStats(graph: DependencyGraph): {\n    totalChecks: number;\n    parallelLevels: number;\n    maxParallelism: number;\n    averageParallelism: number;\n    checksWithDependencies: number;\n  } {\n    const totalChecks = graph.nodes.size;\n    const parallelLevels = graph.executionOrder.length;\n    const maxParallelism = Math.max(...graph.executionOrder.map(group => group.parallel.length));\n    const averageParallelism = totalChecks / parallelLevels;\n    const checksWithDependencies = Array.from(graph.nodes.values()).filter(\n      node => node.dependencies.length > 0\n    ).length;\n\n    return {\n      totalChecks,\n      parallelLevels,\n      maxParallelism,\n      averageParallelism,\n      checksWithDependencies,\n    };\n  }\n}\n","/**\n * Workflow registry for managing reusable workflow definitions\n */\n\nimport {\n  WorkflowDefinition,\n  WorkflowRegistryEntry,\n  WorkflowValidationResult,\n  WorkflowImportOptions,\n  JsonSchema,\n} from './types/workflow';\nimport { promises as fs } from 'fs';\nimport * as path from 'path';\nimport * as yaml from 'js-yaml';\nimport { logger } from './logger';\nimport { DependencyResolver } from './dependency-resolver';\nimport Ajv from 'ajv';\nimport addFormats from 'ajv-formats';\n\n/**\n * Registry for managing workflow definitions\n */\nexport class WorkflowRegistry {\n  private static instance: WorkflowRegistry;\n  private workflows: Map<string, WorkflowRegistryEntry> = new Map();\n  private ajv: Ajv;\n\n  private constructor() {\n    this.ajv = new Ajv({ allErrors: true, strict: false });\n    addFormats(this.ajv);\n  }\n\n  /**\n   * Get the singleton instance of the workflow registry\n   */\n  public static getInstance(): WorkflowRegistry {\n    if (!WorkflowRegistry.instance) {\n      WorkflowRegistry.instance = new WorkflowRegistry();\n    }\n    return WorkflowRegistry.instance;\n  }\n\n  /**\n   * Register a workflow definition\n   */\n  public register(\n    workflow: WorkflowDefinition,\n    source: string = 'inline',\n    options?: { override?: boolean }\n  ): WorkflowValidationResult {\n    // Validate the workflow\n    const validation = this.validateWorkflow(workflow);\n    if (!validation.valid) {\n      return validation;\n    }\n\n    // Check if workflow already exists\n    if (this.workflows.has(workflow.id) && !options?.override) {\n      return {\n        valid: false,\n        errors: [\n          {\n            path: 'id',\n            message: `Workflow with ID '${workflow.id}' already exists`,\n            value: workflow.id,\n          },\n        ],\n      };\n    }\n\n    // Register the workflow\n    this.workflows.set(workflow.id, {\n      definition: workflow,\n      source,\n      registeredAt: new Date(),\n      usage: {\n        count: 0,\n      },\n    });\n\n    logger.debug(`Registered workflow '${workflow.id}' from ${source}`);\n    return { valid: true };\n  }\n\n  /**\n   * Get a workflow by ID\n   */\n  public get(id: string): WorkflowDefinition | undefined {\n    const entry = this.workflows.get(id);\n    if (entry) {\n      // Update usage statistics\n      entry.usage = entry.usage || { count: 0 };\n      entry.usage.count++;\n      entry.usage.lastUsed = new Date();\n    }\n    return entry?.definition;\n  }\n\n  /**\n   * Check if a workflow exists\n   */\n  public has(id: string): boolean {\n    return this.workflows.has(id);\n  }\n\n  /**\n   * List all registered workflows\n   */\n  public list(): WorkflowDefinition[] {\n    return Array.from(this.workflows.values()).map(entry => entry.definition);\n  }\n\n  /**\n   * Get workflow metadata\n   */\n  public getMetadata(id: string): WorkflowRegistryEntry | undefined {\n    return this.workflows.get(id);\n  }\n\n  /**\n   * Remove a workflow from the registry\n   */\n  public unregister(id: string): boolean {\n    return this.workflows.delete(id);\n  }\n\n  /**\n   * Clear all workflows\n   */\n  public clear(): void {\n    this.workflows.clear();\n  }\n\n  /**\n   * Import workflows from a file or URL\n   */\n  public async import(\n    source: string,\n    options?: WorkflowImportOptions\n  ): Promise<WorkflowValidationResult[]> {\n    const results: WorkflowValidationResult[] = [];\n\n    try {\n      // Load the workflow file\n      const content = await this.loadWorkflowContent(source, options?.basePath);\n      const data = this.parseWorkflowContent(content, source);\n\n      // Handle both single workflow and multiple workflows\n      const workflows: WorkflowDefinition[] = Array.isArray(data) ? data : [data];\n\n      for (const workflow of workflows) {\n        // Validate if requested\n        if (options?.validate !== false) {\n          const validation = this.validateWorkflow(workflow);\n          if (!validation.valid) {\n            results.push(validation);\n            continue;\n          }\n\n          // Run custom validators if provided\n          if (options?.validators) {\n            for (const validator of options.validators) {\n              const customValidation = validator(workflow);\n              if (!customValidation.valid) {\n                results.push(customValidation);\n                continue;\n              }\n            }\n          }\n        }\n\n        // Strip out 'tests' field before registering - tests are only for standalone execution\n        const workflowWithoutTests = { ...workflow };\n        delete (workflowWithoutTests as any).tests;\n\n        // Register the workflow (without tests)\n        const result = this.register(workflowWithoutTests, source, { override: options?.override });\n        results.push(result);\n      }\n    } catch (error) {\n      results.push({\n        valid: false,\n        errors: [\n          {\n            path: 'source',\n            message: `Failed to import workflows from '${source}': ${error instanceof Error ? error.message : String(error)}`,\n            value: source,\n          },\n        ],\n      });\n    }\n\n    return results;\n  }\n\n  /**\n   * Import multiple workflow sources\n   */\n  public async importMany(\n    sources: string[],\n    options?: WorkflowImportOptions\n  ): Promise<Map<string, WorkflowValidationResult[]>> {\n    const results = new Map<string, WorkflowValidationResult[]>();\n\n    for (const source of sources) {\n      const importResults = await this.import(source, options);\n      results.set(source, importResults);\n    }\n\n    return results;\n  }\n\n  /**\n   * Validate a workflow definition\n   */\n  public validateWorkflow(workflow: WorkflowDefinition): WorkflowValidationResult {\n    const errors: Array<{ path: string; message: string; value?: unknown }> = [];\n    const warnings: Array<{ path: string; message: string }> = [];\n\n    // Validate required fields\n    if (!workflow.id) {\n      errors.push({ path: 'id', message: 'Workflow ID is required' });\n    }\n\n    if (!workflow.name) {\n      errors.push({ path: 'name', message: 'Workflow name is required' });\n    }\n\n    if (!workflow.steps || Object.keys(workflow.steps).length === 0) {\n      errors.push({ path: 'steps', message: 'Workflow must have at least one step' });\n    }\n\n    // Validate input parameters\n    if (workflow.inputs) {\n      for (let i = 0; i < workflow.inputs.length; i++) {\n        const input = workflow.inputs[i];\n        if (!input.name) {\n          errors.push({ path: `inputs[${i}].name`, message: 'Input parameter name is required' });\n        }\n        if (!input.schema) {\n          warnings.push({\n            path: `inputs[${i}].schema`,\n            message: 'Input parameter schema is recommended',\n          });\n        }\n      }\n    }\n\n    // Validate output parameters\n    if (workflow.outputs) {\n      for (let i = 0; i < workflow.outputs.length; i++) {\n        const output = workflow.outputs[i];\n        if (!output.name) {\n          errors.push({ path: `outputs[${i}].name`, message: 'Output parameter name is required' });\n        }\n        if (!output.value && !output.value_js) {\n          errors.push({\n            path: `outputs[${i}]`,\n            message: 'Output parameter must have either value or value_js',\n          });\n        }\n      }\n    }\n\n    // Validate steps\n    for (const [stepId, step] of Object.entries(workflow.steps || {})) {\n      // Validate step dependencies\n      if (step.depends_on) {\n        for (const dep of step.depends_on) {\n          if (!workflow.steps[dep]) {\n            errors.push({\n              path: `steps.${stepId}.depends_on`,\n              message: `Step '${stepId}' depends on non-existent step '${dep}'`,\n              value: dep,\n            });\n          }\n        }\n      }\n\n      // Validate input mappings\n      if (step.inputs) {\n        for (const [inputName, mapping] of Object.entries(step.inputs)) {\n          if (typeof mapping === 'object' && mapping !== null && 'source' in mapping) {\n            const typedMapping = mapping as any;\n            if (typedMapping.source === 'step' && !typedMapping.stepId) {\n              errors.push({\n                path: `steps.${stepId}.inputs.${inputName}`,\n                message: 'Step input mapping with source \"step\" must have stepId',\n              });\n            }\n            if (typedMapping.source === 'param') {\n              // Validate that the parameter exists\n              const paramExists = workflow.inputs?.some(p => p.name === typedMapping.value);\n              if (!paramExists) {\n                errors.push({\n                  path: `steps.${stepId}.inputs.${inputName}`,\n                  message: `Step input references non-existent parameter '${typedMapping.value}'`,\n                  value: typedMapping.value,\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Check for circular dependencies\n    const circularDeps = this.detectCircularDependencies(workflow);\n    if (circularDeps.length > 0) {\n      errors.push({\n        path: 'steps',\n        message: `Circular dependencies detected: ${circularDeps.join(' -> ')}`,\n      });\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors: errors.length > 0 ? errors : undefined,\n      warnings: warnings.length > 0 ? warnings : undefined,\n    };\n  }\n\n  /**\n   * Validate input values against workflow input schema\n   */\n  public validateInputs(\n    workflow: WorkflowDefinition,\n    inputs: Record<string, unknown>\n  ): WorkflowValidationResult {\n    const errors: Array<{ path: string; message: string; value?: unknown }> = [];\n\n    if (!workflow.inputs) {\n      return { valid: true };\n    }\n\n    // Check required inputs\n    for (const param of workflow.inputs) {\n      if (param.required !== false && !(param.name in inputs) && param.default === undefined) {\n        errors.push({\n          path: `inputs.${param.name}`,\n          message: `Required input '${param.name}' is missing`,\n        });\n      }\n    }\n\n    // Validate input schemas\n    for (const param of workflow.inputs) {\n      if (param.name in inputs && param.schema) {\n        const value = inputs[param.name];\n        const valid = this.validateAgainstSchema(value, param.schema);\n        if (!valid.valid) {\n          errors.push({\n            path: `inputs.${param.name}`,\n            message: valid.error || 'Invalid input value',\n            value,\n          });\n        }\n      }\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors: errors.length > 0 ? errors : undefined,\n    };\n  }\n\n  /**\n   * Load workflow content from file or URL\n   */\n  private async loadWorkflowContent(source: string, basePath?: string): Promise<string> {\n    // Handle URLs\n    if (source.startsWith('http://') || source.startsWith('https://')) {\n      const response = await fetch(source);\n      if (!response.ok) {\n        throw new Error(`Failed to fetch workflow from ${source}: ${response.statusText}`);\n      }\n      return await response.text();\n    }\n\n    // Handle file paths\n    const filePath = path.isAbsolute(source)\n      ? source\n      : path.resolve(basePath || process.cwd(), source);\n    return await fs.readFile(filePath, 'utf-8');\n  }\n\n  /**\n   * Parse workflow content (YAML or JSON)\n   */\n  private parseWorkflowContent(content: string, source: string): any {\n    // Try JSON first\n    try {\n      return JSON.parse(content);\n    } catch {\n      // Try YAML\n      try {\n        return yaml.load(content);\n      } catch (error) {\n        throw new Error(\n          `Failed to parse workflow file ${source}: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n  }\n\n  /**\n   * Detect circular dependencies in workflow steps using DependencyResolver\n   */\n  private detectCircularDependencies(workflow: WorkflowDefinition): string[] {\n    // Build dependency map\n    const dependencies: Record<string, string[]> = {};\n    for (const [stepId, step] of Object.entries(workflow.steps || {})) {\n      dependencies[stepId] = step.depends_on || [];\n    }\n\n    try {\n      // Use DependencyResolver to check for cycles\n      const graph = DependencyResolver.buildDependencyGraph(dependencies);\n\n      if (graph.hasCycles && graph.cycleNodes) {\n        return graph.cycleNodes;\n      }\n\n      return [];\n    } catch {\n      // DependencyResolver throws error for non-existent dependencies\n      // This should be caught by the dependency validation in validateWorkflow\n      // Return empty array here and let the validation handle it\n      return [];\n    }\n  }\n\n  /**\n   * Validate a value against a JSON schema\n   */\n  private validateAgainstSchema(\n    value: unknown,\n    schema: JsonSchema\n  ): { valid: boolean; error?: string } {\n    try {\n      const validate = this.ajv.compile(schema as any);\n      const valid = validate(value);\n      if (!valid) {\n        const errors = validate.errors\n          ?.map(e => `${e.instancePath || '/'}: ${e.message}`)\n          .join(', ');\n        return { valid: false, error: errors };\n      }\n      return { valid: true };\n    } catch (error) {\n      return { valid: false, error: error instanceof Error ? error.message : String(error) };\n    }\n  }\n}\n","/**\n * Workflow executor for running workflow definitions\n */\n\nimport {\n  WorkflowDefinition,\n  WorkflowExecutionContext,\n  WorkflowStep,\n  WorkflowInputMapping,\n  WorkflowExecutionOptions,\n} from './types/workflow';\nimport { PRInfo } from './pr-analyzer';\nimport { ReviewSummary } from './reviewer';\nimport { CheckProviderRegistry } from './providers/check-provider-registry';\nimport { CheckProviderConfig, ExecutionContext } from './providers/check-provider.interface';\nimport { DependencyResolver } from './dependency-resolver';\nimport { logger } from './logger';\nimport { createSecureSandbox, compileAndRun } from './utils/sandbox';\nimport { Liquid } from 'liquidjs';\n\n/**\n * Workflow execution result\n */\nexport interface WorkflowExecutionResult {\n  success: boolean;\n  score?: number;\n  confidence?: 'high' | 'medium' | 'low';\n  issues?: any[];\n  comments?: any[];\n  output?: Record<string, unknown>;\n  status: 'completed' | 'failed' | 'skipped';\n  duration?: number;\n  error?: string;\n  stepSummaries?: Array<{\n    stepId: string;\n    status: 'success' | 'failed' | 'skipped';\n    issues?: any[];\n    output?: unknown;\n  }>;\n}\n\n/**\n * Execution options passed to workflow executor\n */\ninterface WorkflowRunOptions {\n  prInfo: PRInfo;\n  dependencyResults?: Map<string, ReviewSummary>;\n  context?: ExecutionContext;\n  options?: WorkflowExecutionOptions;\n}\n\n/**\n * Executes workflow definitions\n */\nexport class WorkflowExecutor {\n  private providerRegistry: CheckProviderRegistry | null = null;\n  private liquid: Liquid;\n\n  constructor() {\n    // Don't call CheckProviderRegistry.getInstance() here to avoid circular dependency\n    // during registry initialization (since WorkflowCheckProvider is registered in the registry)\n    this.liquid = new Liquid();\n  }\n\n  /**\n   * Lazy-load the provider registry to avoid circular dependency during initialization\n   */\n  private getProviderRegistry(): CheckProviderRegistry {\n    if (!this.providerRegistry) {\n      this.providerRegistry = CheckProviderRegistry.getInstance();\n    }\n    return this.providerRegistry;\n  }\n\n  /**\n   * Execute a workflow\n   */\n  public async execute(\n    workflow: WorkflowDefinition,\n    executionContext: WorkflowExecutionContext,\n    runOptions: WorkflowRunOptions\n  ): Promise<WorkflowExecutionResult> {\n    const startTime = Date.now();\n    executionContext.metadata = {\n      startTime,\n      status: 'running',\n    };\n\n    try {\n      // Resolve step execution order\n      const executionOrder = this.resolveExecutionOrder(workflow);\n      logger.debug(`Workflow ${workflow.id} execution order: ${executionOrder.join(' -> ')}`);\n\n      // Execute steps in order\n      const stepResults = new Map<string, ReviewSummary>();\n      const stepSummaries: Array<{\n        stepId: string;\n        status: 'success' | 'failed' | 'skipped';\n        issues?: any[];\n        output?: unknown;\n      }> = [];\n\n      for (const stepId of executionOrder) {\n        const step = workflow.steps[stepId];\n\n        // Check if step should be executed (evaluate 'if' condition)\n        if (step.if) {\n          const shouldRun = this.evaluateCondition(step.if, {\n            inputs: executionContext.inputs,\n            outputs: Object.fromEntries(stepResults),\n            pr: runOptions.prInfo,\n          });\n\n          if (!shouldRun) {\n            logger.info(`Skipping step '${stepId}' due to condition: ${step.if}`);\n            stepSummaries.push({\n              stepId,\n              status: 'skipped',\n            });\n            continue;\n          }\n        }\n\n        // Prepare step configuration\n        const stepConfig = await this.prepareStepConfig(\n          step,\n          stepId,\n          executionContext,\n          stepResults,\n          workflow\n        );\n\n        // Execute the step\n        try {\n          logger.info(`Executing workflow step '${stepId}'`);\n          // Extend context with workflow inputs\n          const stepContext: ExecutionContext = {\n            ...runOptions.context,\n            workflowInputs: executionContext.inputs,\n          };\n          const result = await this.executeStep(\n            stepConfig,\n            runOptions.prInfo,\n            stepResults,\n            stepContext\n          );\n\n          stepResults.set(stepId, result);\n          stepSummaries.push({\n            stepId,\n            status: 'success',\n            issues: result.issues,\n            output: (result as any).output,\n          });\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : String(error);\n          logger.error(`Step '${stepId}' failed: ${errorMessage}`);\n\n          stepSummaries.push({\n            stepId,\n            status: 'failed',\n            output: { error: errorMessage },\n          });\n\n          if (!runOptions.options?.continueOnError) {\n            throw new Error(`Workflow step '${stepId}' failed: ${errorMessage}`);\n          }\n        }\n      }\n\n      // Compute workflow outputs\n      const outputs = await this.computeOutputs(\n        workflow,\n        executionContext,\n        stepResults,\n        runOptions.prInfo\n      );\n      executionContext.outputs = outputs;\n\n      // Aggregate results\n      const aggregated = this.aggregateResults(stepResults);\n\n      const endTime = Date.now();\n      executionContext.metadata.endTime = endTime;\n      executionContext.metadata.duration = endTime - startTime;\n      executionContext.metadata.status = 'completed';\n\n      return {\n        success: true,\n        score: aggregated.score,\n        confidence: aggregated.confidence,\n        issues: aggregated.issues,\n        comments: aggregated.comments,\n        output: outputs,\n        status: 'completed',\n        duration: endTime - startTime,\n        stepSummaries,\n      };\n    } catch (error) {\n      const endTime = Date.now();\n      executionContext.metadata.endTime = endTime;\n      executionContext.metadata.duration = endTime - startTime;\n      executionContext.metadata.status = 'failed';\n      executionContext.metadata.error = error instanceof Error ? error.message : String(error);\n\n      return {\n        success: false,\n        status: 'failed',\n        duration: endTime - startTime,\n        error: error instanceof Error ? error.message : String(error),\n      };\n    }\n  }\n\n  /**\n   * Resolve step execution order based on dependencies\n   */\n  private resolveExecutionOrder(workflow: WorkflowDefinition): string[] {\n    // Build dependency map\n    const dependencies: Record<string, string[]> = {};\n    for (const [stepId, step] of Object.entries(workflow.steps)) {\n      dependencies[stepId] = step.depends_on || [];\n    }\n\n    // Use static DependencyResolver\n    const graph = DependencyResolver.buildDependencyGraph(dependencies);\n\n    if (graph.hasCycles) {\n      throw new Error(\n        `Circular dependency detected in workflow steps: ${graph.cycleNodes?.join(' -> ')}`\n      );\n    }\n\n    // Flatten execution groups to get linear order\n    const order: string[] = [];\n    for (const group of graph.executionOrder) {\n      order.push(...group.parallel);\n    }\n\n    return order;\n  }\n\n  /**\n   * Prepare step configuration with input mappings\n   */\n  private async prepareStepConfig(\n    step: WorkflowStep,\n    stepId: string,\n    executionContext: WorkflowExecutionContext,\n    stepResults: Map<string, ReviewSummary>,\n    workflow: WorkflowDefinition\n  ): Promise<CheckProviderConfig> {\n    const config: CheckProviderConfig = {\n      ...step,\n      type: step.type || 'ai',\n      checkName: `${executionContext.instanceId}:${stepId}`,\n    };\n\n    // Process input mappings\n    if (step.inputs) {\n      for (const [inputName, mapping] of Object.entries(step.inputs)) {\n        const value = await this.resolveInputMapping(\n          mapping,\n          executionContext,\n          stepResults,\n          workflow\n        );\n        (config as any)[inputName] = value;\n      }\n    }\n\n    return config;\n  }\n\n  /**\n   * Resolve input mapping to actual value\n   */\n  private async resolveInputMapping(\n    mapping: string | WorkflowInputMapping,\n    executionContext: WorkflowExecutionContext,\n    stepResults: Map<string, ReviewSummary>,\n    _workflow: WorkflowDefinition\n  ): Promise<unknown> {\n    // Simple string mapping - treat as parameter reference\n    if (typeof mapping === 'string') {\n      return executionContext.inputs[mapping];\n    }\n\n    // Complex mapping\n    if (typeof mapping === 'object' && mapping !== null && 'source' in mapping) {\n      const typedMapping = mapping as WorkflowInputMapping;\n\n      switch (typedMapping.source) {\n        case 'param':\n          // Reference to workflow input parameter\n          return executionContext.inputs[String(typedMapping.value)];\n\n        case 'step':\n          // Reference to another step's output\n          if (!typedMapping.stepId) {\n            throw new Error('Step input mapping requires stepId');\n          }\n          const stepResult = stepResults.get(typedMapping.stepId);\n          if (!stepResult) {\n            throw new Error(`Step '${typedMapping.stepId}' has not been executed yet`);\n          }\n          const output = (stepResult as any).output;\n          if (typedMapping.outputParam && output) {\n            return output[typedMapping.outputParam];\n          }\n          return output;\n\n        case 'constant':\n          // Constant value\n          return typedMapping.value;\n\n        case 'expression':\n          // JavaScript expression\n          if (!typedMapping.expression) {\n            throw new Error('Expression mapping requires expression field');\n          }\n          const sandbox = createSecureSandbox();\n          return compileAndRun(\n            sandbox,\n            typedMapping.expression,\n            {\n              inputs: executionContext.inputs,\n              outputs: Object.fromEntries(stepResults),\n              steps: Object.fromEntries(\n                Array.from(stepResults.entries()).map(([id, result]) => [\n                  id,\n                  (result as any).output,\n                ])\n              ),\n            },\n            { injectLog: true, logPrefix: 'workflow.input.expression' }\n          );\n\n        default:\n          throw new Error(`Unknown input mapping source: ${typedMapping.source}`);\n      }\n    }\n\n    // Handle Liquid template in mapping\n    if (typeof mapping === 'object' && mapping !== null && 'template' in mapping) {\n      const typedMapping = mapping as WorkflowInputMapping;\n      if (typedMapping.template) {\n        return await this.liquid.parseAndRender(typedMapping.template, {\n          inputs: executionContext.inputs,\n          outputs: Object.fromEntries(stepResults),\n        });\n      }\n    }\n\n    // Return as-is\n    return mapping;\n  }\n\n  /**\n   * Execute a single step\n   */\n  private async executeStep(\n    config: CheckProviderConfig,\n    prInfo: PRInfo,\n    dependencyResults: Map<string, ReviewSummary>,\n    context?: ExecutionContext\n  ): Promise<ReviewSummary> {\n    const provider = await this.getProviderRegistry().getProvider(config.type);\n    if (!provider) {\n      throw new Error(`Provider '${config.type}' not found`);\n    }\n\n    return await provider.execute(prInfo, config, dependencyResults, context);\n  }\n\n  /**\n   * Compute workflow outputs\n   */\n  private async computeOutputs(\n    workflow: WorkflowDefinition,\n    executionContext: WorkflowExecutionContext,\n    stepResults: Map<string, ReviewSummary>,\n    prInfo: PRInfo\n  ): Promise<Record<string, unknown>> {\n    const outputs: Record<string, unknown> = {};\n\n    if (!workflow.outputs) {\n      return outputs;\n    }\n\n    for (const output of workflow.outputs) {\n      if (output.value_js) {\n        // JavaScript expression\n        const sandbox = createSecureSandbox();\n        outputs[output.name] = compileAndRun(\n          sandbox,\n          output.value_js,\n          {\n            inputs: executionContext.inputs,\n            steps: Object.fromEntries(\n              Array.from(stepResults.entries()).map(([id, result]) => [id, (result as any).output])\n            ),\n            outputs: Object.fromEntries(stepResults),\n            pr: prInfo,\n          },\n          { injectLog: true, logPrefix: `workflow.output.${output.name}` }\n        );\n      } else if (output.value) {\n        // Liquid template\n        outputs[output.name] = await this.liquid.parseAndRender(output.value, {\n          inputs: executionContext.inputs,\n          steps: Object.fromEntries(\n            Array.from(stepResults.entries()).map(([id, result]) => [id, (result as any).output])\n          ),\n          outputs: Object.fromEntries(stepResults),\n          pr: prInfo,\n        });\n      }\n    }\n\n    return outputs;\n  }\n\n  /**\n   * Aggregate results from all steps\n   */\n  private aggregateResults(stepResults: Map<string, ReviewSummary>): {\n    score: number;\n    confidence: 'high' | 'medium' | 'low';\n    issues: any[];\n    comments: any[];\n  } {\n    let totalScore = 0;\n    let scoreCount = 0;\n    const allIssues: any[] = [];\n    const allComments: any[] = [];\n    let minConfidence: 'high' | 'medium' | 'low' = 'high';\n\n    for (const result of stepResults.values()) {\n      const extResult = result as any;\n      if (typeof extResult.score === 'number') {\n        totalScore += extResult.score;\n        scoreCount++;\n      }\n\n      if (result.issues) {\n        allIssues.push(...result.issues);\n      }\n\n      if (extResult.comments) {\n        allComments.push(...extResult.comments);\n      }\n\n      if (extResult.confidence) {\n        if (\n          extResult.confidence === 'low' ||\n          (extResult.confidence === 'medium' && minConfidence === 'high')\n        ) {\n          minConfidence = extResult.confidence;\n        }\n      }\n    }\n\n    return {\n      score: scoreCount > 0 ? Math.round(totalScore / scoreCount) : 0,\n      confidence: minConfidence,\n      issues: allIssues,\n      comments: allComments,\n    };\n  }\n\n  /**\n   * Evaluate a condition expression\n   */\n  private evaluateCondition(condition: string, context: any): boolean {\n    try {\n      const sandbox = createSecureSandbox();\n      const result = compileAndRun(sandbox, condition, context, {\n        injectLog: true,\n        logPrefix: 'workflow.condition',\n      });\n      return Boolean(result);\n    } catch (error) {\n      logger.warn(`Failed to evaluate condition '${condition}': ${error}`);\n      return false;\n    }\n  }\n}\n","/**\n * Workflow check provider - executes reusable workflows as checks\n */\n\nimport { CheckProvider, CheckProviderConfig, ExecutionContext } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { WorkflowRegistry } from '../workflow-registry';\nimport { WorkflowExecutor } from '../workflow-executor';\nimport { logger } from '../logger';\nimport { WorkflowDefinition, WorkflowExecutionContext } from '../types/workflow';\nimport { createSecureSandbox, compileAndRun } from '../utils/sandbox';\nimport { Liquid } from 'liquidjs';\n\n/**\n * Provider that executes workflows as checks\n */\nexport class WorkflowCheckProvider extends CheckProvider {\n  private registry: WorkflowRegistry;\n  private executor: WorkflowExecutor;\n  private liquid: Liquid;\n\n  constructor() {\n    super();\n    this.registry = WorkflowRegistry.getInstance();\n    this.executor = new WorkflowExecutor();\n    this.liquid = new Liquid();\n  }\n\n  getName(): string {\n    return 'workflow';\n  }\n\n  getDescription(): string {\n    return 'Executes reusable workflow definitions as checks';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    const cfg = config as CheckProviderConfig;\n\n    if (!cfg.workflow) {\n      logger.error('Workflow provider requires \"workflow\" field');\n      return false;\n    }\n\n    // Check if workflow exists in registry\n    if (!this.registry.has(cfg.workflow as string)) {\n      logger.error(`Workflow '${cfg.workflow}' not found in registry`);\n      return false;\n    }\n\n    return true;\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    context?: ExecutionContext\n  ): Promise<ReviewSummary> {\n    const workflowId = config.workflow as string;\n\n    // Get the workflow definition\n    const workflow = this.registry.get(workflowId);\n    if (!workflow) {\n      throw new Error(`Workflow '${workflowId}' not found in registry`);\n    }\n\n    logger.info(`Executing workflow '${workflowId}'`);\n\n    // Prepare inputs\n    const inputs = await this.prepareInputs(workflow, config, prInfo, dependencyResults);\n\n    // Validate inputs\n    const validation = this.registry.validateInputs(workflow, inputs);\n    if (!validation.valid) {\n      const errors = validation.errors?.map(e => `${e.path}: ${e.message}`).join(', ');\n      throw new Error(`Invalid workflow inputs: ${errors}`);\n    }\n\n    // Apply overrides to workflow steps if specified\n    const modifiedWorkflow = this.applyOverrides(workflow, config);\n\n    // Execute the workflow\n    const executionContext: WorkflowExecutionContext = {\n      instanceId: `${workflowId}-${Date.now()}`,\n      parentCheckId: config.checkName,\n      inputs,\n      stepResults: new Map(),\n    };\n\n    const result = await this.executor.execute(modifiedWorkflow, executionContext, {\n      prInfo,\n      dependencyResults,\n      context,\n    });\n\n    // Map outputs\n    const outputs = this.mapOutputs(result, config.output_mapping as Record<string, string>);\n\n    // Return the review summary with extended fields\n    // Note: These extra fields are used by the execution engine but not part of the base interface\n    const summary: ReviewSummary = {\n      issues: result.issues || [],\n    };\n\n    // Add extended fields as needed by the engine\n    (summary as any).score = result.score || 0;\n    (summary as any).confidence = result.confidence || 'medium';\n    (summary as any).comments = result.comments || [];\n    (summary as any).output = outputs;\n    (summary as any).content = this.formatWorkflowResult(workflow, result, outputs);\n\n    return summary;\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return ['workflow', 'args', 'overrides', 'output_mapping', 'timeout', 'env', 'checkName'];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    return true; // Always available\n  }\n\n  getRequirements(): string[] {\n    return [];\n  }\n\n  /**\n   * Prepare inputs for workflow execution\n   */\n  private async prepareInputs(\n    workflow: WorkflowDefinition,\n    config: CheckProviderConfig,\n    prInfo: PRInfo,\n    dependencyResults?: Map<string, ReviewSummary>\n  ): Promise<Record<string, unknown>> {\n    const inputs: Record<string, unknown> = {};\n\n    // Start with default values from workflow definition\n    if (workflow.inputs) {\n      for (const param of workflow.inputs) {\n        if (param.default !== undefined) {\n          inputs[param.name] = param.default;\n        }\n      }\n    }\n\n    // Apply user-provided inputs (args)\n    const userInputs = config.args || config.workflow_inputs; // Support both for compatibility\n    if (userInputs) {\n      for (const [key, value] of Object.entries(userInputs)) {\n        // Process value if it's a template or expression\n        if (typeof value === 'string') {\n          // Check if it's a Liquid template\n          if (value.includes('{{') || value.includes('{%')) {\n            inputs[key] = await this.liquid.parseAndRender(value, {\n              pr: prInfo,\n              outputs: dependencyResults ? Object.fromEntries(dependencyResults) : {},\n              env: process.env,\n            });\n          } else {\n            inputs[key] = value;\n          }\n        } else if (typeof value === 'object' && value !== null && 'expression' in value) {\n          // JavaScript expression\n          const exprValue = value as { expression: string };\n          const sandbox = createSecureSandbox();\n          inputs[key] = compileAndRun(\n            sandbox,\n            exprValue.expression,\n            {\n              pr: prInfo,\n              outputs: dependencyResults ? Object.fromEntries(dependencyResults) : {},\n              env: process.env,\n            },\n            { injectLog: true, logPrefix: `workflow.input.${key}` }\n          );\n        } else {\n          inputs[key] = value;\n        }\n      }\n    }\n\n    return inputs;\n  }\n\n  /**\n   * Apply overrides to workflow steps\n   */\n  private applyOverrides(\n    workflow: WorkflowDefinition,\n    config: CheckProviderConfig\n  ): WorkflowDefinition {\n    const overrideConfig = config.overrides || config.workflow_overrides; // Support both for compatibility\n    if (!overrideConfig) {\n      return workflow;\n    }\n\n    // Deep clone the workflow\n    const modified = JSON.parse(JSON.stringify(workflow));\n\n    // Apply overrides\n    for (const [stepId, overrides] of Object.entries(overrideConfig)) {\n      if (modified.steps[stepId]) {\n        // Merge overrides with existing step config\n        modified.steps[stepId] = {\n          ...modified.steps[stepId],\n          ...overrides,\n        };\n      } else {\n        logger.warn(`Cannot override non-existent step '${stepId}' in workflow '${workflow.id}'`);\n      }\n    }\n\n    return modified;\n  }\n\n  /**\n   * Map workflow outputs to check outputs\n   */\n  private mapOutputs(result: any, outputMapping?: Record<string, string>): Record<string, unknown> {\n    if (!outputMapping) {\n      return result.output || {};\n    }\n\n    const mapped: Record<string, unknown> = {};\n    const workflowOutputs = result.output || {};\n\n    for (const [checkOutput, workflowOutput] of Object.entries(outputMapping)) {\n      if (workflowOutput in workflowOutputs) {\n        mapped[checkOutput] = workflowOutputs[workflowOutput];\n      } else if (workflowOutput.includes('.')) {\n        // Handle nested paths\n        const parts = workflowOutput.split('.');\n        let value = workflowOutputs;\n        for (const part of parts) {\n          value = value?.[part];\n          if (value === undefined) break;\n        }\n        mapped[checkOutput] = value;\n      }\n    }\n\n    return mapped;\n  }\n\n  /**\n   * Format workflow execution result for display\n   */\n  private formatWorkflowResult(\n    workflow: WorkflowDefinition,\n    result: any,\n    outputs: Record<string, unknown>\n  ): string {\n    const lines: string[] = [];\n\n    lines.push(`Workflow: ${workflow.name}`);\n    if (workflow.description) {\n      lines.push(`Description: ${workflow.description}`);\n    }\n\n    lines.push('');\n    lines.push('Execution Summary:');\n    lines.push(`- Status: ${result.status || 'completed'}`);\n    lines.push(`- Score: ${result.score || 0}`);\n    lines.push(`- Issues Found: ${result.issues?.length || 0}`);\n\n    if (result.duration) {\n      lines.push(`- Duration: ${result.duration}ms`);\n    }\n\n    if (Object.keys(outputs).length > 0) {\n      lines.push('');\n      lines.push('Outputs:');\n      for (const [key, value] of Object.entries(outputs)) {\n        const formatted =\n          typeof value === 'object' ? JSON.stringify(value, null, 2) : String(value);\n        lines.push(`- ${key}: ${formatted}`);\n      }\n    }\n\n    if (result.stepSummaries && result.stepSummaries.length > 0) {\n      lines.push('');\n      lines.push('Step Results:');\n      for (const summary of result.stepSummaries) {\n        lines.push(\n          `- ${summary.stepId}: ${summary.status} (${summary.issues?.length || 0} issues)`\n        );\n      }\n    }\n\n    return lines.join('\\n');\n  }\n}\n","import { CheckProvider } from './check-provider.interface';\nimport { AICheckProvider } from './ai-check-provider';\nimport { HttpCheckProvider } from './http-check-provider';\nimport { HttpInputProvider } from './http-input-provider';\nimport { HttpClientProvider } from './http-client-provider';\nimport { NoopCheckProvider } from './noop-check-provider';\nimport { LogCheckProvider } from './log-check-provider';\nimport { GitHubOpsProvider } from './github-ops-provider';\nimport { ClaudeCodeCheckProvider } from './claude-code-check-provider';\nimport { CommandCheckProvider } from './command-check-provider';\nimport { MemoryCheckProvider } from './memory-check-provider';\nimport { McpCheckProvider } from './mcp-check-provider';\nimport { HumanInputCheckProvider } from './human-input-check-provider';\nimport { ScriptCheckProvider } from './script-check-provider';\nimport { WorkflowCheckProvider } from './workflow-check-provider';\nimport { CustomToolDefinition } from '../types/config';\n\n/**\n * Registry for managing check providers\n */\nexport class CheckProviderRegistry {\n  private providers: Map<string, CheckProvider> = new Map();\n  private static instance: CheckProviderRegistry;\n  private customTools?: Record<string, CustomToolDefinition>;\n\n  private constructor() {\n    // Register default providers\n    this.registerDefaultProviders();\n  }\n\n  /**\n   * Get singleton instance\n   */\n  static getInstance(): CheckProviderRegistry {\n    if (!CheckProviderRegistry.instance) {\n      CheckProviderRegistry.instance = new CheckProviderRegistry();\n    }\n    return CheckProviderRegistry.instance;\n  }\n\n  /**\n   * Register default built-in providers\n   */\n  private registerDefaultProviders(): void {\n    // Register all built-in providers\n    this.register(new AICheckProvider());\n    this.register(new CommandCheckProvider());\n    this.register(new ScriptCheckProvider());\n    this.register(new HttpCheckProvider());\n    this.register(new HttpInputProvider());\n    this.register(new HttpClientProvider());\n    this.register(new NoopCheckProvider());\n    this.register(new LogCheckProvider());\n    this.register(new MemoryCheckProvider());\n    this.register(new GitHubOpsProvider());\n    this.register(new HumanInputCheckProvider());\n    this.register(new WorkflowCheckProvider());\n\n    // Try to register ClaudeCodeCheckProvider - it may fail if dependencies are missing\n    try {\n      this.register(new ClaudeCodeCheckProvider());\n    } catch (error) {\n      console.error(\n        `Warning: Failed to register ClaudeCodeCheckProvider: ${\n          error instanceof Error ? error.message : 'Unknown error'\n        }`\n      );\n    }\n\n    // Try to register McpCheckProvider - it may fail if dependencies are missing\n    try {\n      const mcpProvider = new McpCheckProvider();\n      // Set custom tools if available\n      if (this.customTools) {\n        mcpProvider.setCustomTools(this.customTools);\n      }\n      this.register(mcpProvider);\n    } catch (error) {\n      console.error(\n        `Warning: Failed to register McpCheckProvider: ${\n          error instanceof Error ? error.message : 'Unknown error'\n        }`\n      );\n    }\n  }\n\n  /**\n   * Register a check provider\n   */\n  register(provider: CheckProvider): void {\n    const name = provider.getName();\n    if (this.providers.has(name)) {\n      throw new Error(`Provider '${name}' is already registered`);\n    }\n    this.providers.set(name, provider);\n    // Only log provider registration in debug mode to avoid contaminating output\n    if (process.env.VISOR_DEBUG === 'true') {\n      console.error(`Registered check provider: ${name}`);\n    }\n  }\n\n  /**\n   * Unregister a check provider\n   */\n  unregister(name: string): void {\n    if (!this.providers.has(name)) {\n      throw new Error(`Provider '${name}' not found`);\n    }\n    this.providers.delete(name);\n    // Send provider unregistration messages to stderr to avoid contaminating JSON output\n    console.error(`Unregistered check provider: ${name}`);\n  }\n\n  /**\n   * Get a provider by name\n   */\n  getProvider(name: string): CheckProvider | undefined {\n    return this.providers.get(name);\n  }\n\n  /**\n   * Get provider or throw if not found\n   */\n  getProviderOrThrow(name: string): CheckProvider {\n    const provider = this.providers.get(name);\n    if (!provider) {\n      throw new Error(\n        `Check provider '${name}' not found. Available providers: ${this.getAvailableProviders().join(', ')}`\n      );\n    }\n    return provider;\n  }\n\n  /**\n   * Check if a provider exists\n   */\n  hasProvider(name: string): boolean {\n    return this.providers.has(name);\n  }\n\n  /**\n   * Get all registered provider names\n   */\n  getAvailableProviders(): string[] {\n    return Array.from(this.providers.keys());\n  }\n\n  /**\n   * Get all providers\n   */\n  getAllProviders(): CheckProvider[] {\n    return Array.from(this.providers.values());\n  }\n\n  /**\n   * Set custom tools that can be used by the MCP provider\n   */\n  setCustomTools(tools: Record<string, CustomToolDefinition>): void {\n    this.customTools = tools;\n\n    // Update MCP provider if already registered\n    const mcpProvider = this.providers.get('mcp') as McpCheckProvider | undefined;\n    if (mcpProvider) {\n      mcpProvider.setCustomTools(tools);\n    }\n  }\n\n  /**\n   * Get providers that are currently available (have required dependencies)\n   */\n  async getActiveProviders(): Promise<CheckProvider[]> {\n    const providers = this.getAllProviders();\n    const activeProviders: CheckProvider[] = [];\n\n    for (const provider of providers) {\n      if (await provider.isAvailable()) {\n        activeProviders.push(provider);\n      }\n    }\n\n    return activeProviders;\n  }\n\n  /**\n   * List provider information\n   */\n  async listProviders(): Promise<\n    Array<{\n      name: string;\n      description: string;\n      available: boolean;\n      requirements: string[];\n    }>\n  > {\n    const providers = this.getAllProviders();\n    const info = [];\n\n    for (const provider of providers) {\n      info.push({\n        name: provider.getName(),\n        description: provider.getDescription(),\n        available: await provider.isAvailable(),\n        requirements: provider.getRequirements(),\n      });\n    }\n\n    return info;\n  }\n\n  /**\n   * Reset registry (mainly for testing)\n   */\n  reset(): void {\n    this.providers.clear();\n    this.registerDefaultProviders();\n  }\n\n  /**\n   * Clear singleton instance (for testing)\n   */\n  static clearInstance(): void {\n    CheckProviderRegistry.instance = undefined!;\n  }\n}\n","import { context as otContext, Span, SpanStatusCode, trace, Attributes } from './lazy-otel';\n\nexport function getTracer() {\n  return trace.getTracer('visor');\n}\n\nexport async function withActiveSpan<T>(\n  name: string,\n  attrs: Record<string, unknown> | undefined,\n  fn: (span: Span) => Promise<T>\n): Promise<T> {\n  const tracer = getTracer();\n  // Preserve parent context via tracer API; avoid logging parent IDs to stdout\n  // Avoid noisy stdout logs that break JSON consumers\n  return await new Promise<T>((resolve, reject) => {\n    const callback = async (span: Span) => {\n      // console.debug(`[trace] Span callback invoked for: [trace_id=${ctx.traceId} span_id=${ctx.spanId}] ${name} span: true`);\n      try {\n        const res = await fn(span);\n        // console.debug('[trace] Span execution completed for:', name);\n        resolve(res);\n      } catch (err) {\n        // console.debug('[trace] Span execution errored for:', name, err);\n        try {\n          if (err instanceof Error) span.recordException(err);\n          span.setStatus({ code: SpanStatusCode.ERROR });\n        } catch {}\n        reject(err);\n      } finally {\n        try {\n          // console.debug('[trace] Ending span:', name);\n          span.end();\n        } catch {}\n      }\n    };\n    // startActiveSpan should use the current active context to set parent automatically\n    const options = attrs ? { attributes: attrs as Attributes } : {};\n    tracer.startActiveSpan(name, options, callback);\n  });\n}\n\nexport function addEvent(name: string, attrs?: Record<string, unknown>): void {\n  const span = trace.getSpan(otContext.active());\n  if (span) {\n    try {\n      span.addEvent(name, attrs as Attributes);\n    } catch {\n      // ignore\n    }\n  }\n  // Fallback NDJSON emission for serverless/file sink when SDK may be inactive\n  try {\n    const { emitNdjsonSpanWithEvents } = require('./fallback-ndjson');\n    emitNdjsonSpanWithEvents('visor.event', {}, [{ name, attrs }]);\n    if (name === 'fail_if.triggered') {\n      emitNdjsonSpanWithEvents('visor.event', {}, [\n        { name: 'fail_if.evaluated', attrs },\n        { name: 'fail_if.triggered', attrs },\n      ]);\n    }\n  } catch {}\n}\n\nexport function setSpanAttributes(attrs: Record<string, unknown>): void {\n  const span = trace.getSpan(otContext.active());\n  if (!span) return;\n  try {\n    for (const [k, v] of Object.entries(attrs)) span.setAttribute(k, v as never);\n  } catch {\n    // ignore\n  }\n}\n\nexport function setSpanError(err: unknown): void {\n  const span = trace.getSpan(otContext.active());\n  if (!span) return;\n  try {\n    if (err instanceof Error) span.recordException(err);\n    span.setStatus({ code: SpanStatusCode.ERROR });\n  } catch {\n    // ignore\n  }\n}\n\n// Internal helper for tests: write a minimal run marker to NDJSON when using file sink\nlet __ndjsonPath: string | null = null;\nexport function __getOrCreateNdjsonPath(): string | null {\n  try {\n    // If sink is explicitly set to non-file, skip. If unset, still allow when a trace dir/file is configured.\n    if (process.env.VISOR_TELEMETRY_SINK && process.env.VISOR_TELEMETRY_SINK !== 'file')\n      return null;\n    const path = require('path');\n    const fs = require('fs');\n    // Prefer explicit fallback file path if set by the CLI\n    if (process.env.VISOR_FALLBACK_TRACE_FILE) {\n      __ndjsonPath = process.env.VISOR_FALLBACK_TRACE_FILE;\n      const dir = path.dirname(__ndjsonPath);\n      if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\n      return __ndjsonPath;\n    }\n    const outDir = process.env.VISOR_TRACE_DIR || path.join(process.cwd(), 'output', 'traces');\n    if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });\n    if (!__ndjsonPath) {\n      const ts = new Date().toISOString().replace(/[:.]/g, '-');\n      __ndjsonPath = path.join(outDir, `${ts}.ndjson`);\n    }\n    return __ndjsonPath;\n  } catch {\n    return null;\n  }\n}\nexport function _appendRunMarker(): void {\n  try {\n    const fs = require('fs');\n    const p = __getOrCreateNdjsonPath();\n    if (!p) return;\n    const line = { name: 'visor.run', attributes: { started: true } };\n    fs.appendFileSync(p, JSON.stringify(line) + '\\n', 'utf8');\n  } catch {}\n}\n","import { metrics } from './lazy-otel';\n\nlet initialized = false;\nconst meter = metrics.getMeter('visor');\n\n// Test helpers (enabled with VISOR_TEST_METRICS=true)\nconst TEST_ENABLED = process.env.VISOR_TEST_METRICS === 'true';\nconst TEST_SNAPSHOT: { [k: string]: number } = { fail_if_triggered: 0 };\n\n// Instruments (lazily created when first used)\nlet checkDurationHist: ReturnType<typeof meter.createHistogram> | undefined;\nlet providerDurationHist: ReturnType<typeof meter.createHistogram> | undefined;\nlet foreachDurationHist: ReturnType<typeof meter.createHistogram> | undefined;\nlet issuesCounter: ReturnType<typeof meter.createCounter> | undefined;\nlet activeChecks: ReturnType<typeof meter.createUpDownCounter> | undefined;\nlet failIfCounter: ReturnType<typeof meter.createCounter> | undefined;\nlet diagramBlocks: ReturnType<typeof meter.createCounter> | undefined;\n\nfunction ensureInstruments() {\n  if (initialized) return;\n  try {\n    checkDurationHist = meter.createHistogram('visor.check.duration_ms', {\n      description: 'Duration of a check execution in milliseconds',\n      unit: 'ms',\n    });\n    providerDurationHist = meter.createHistogram('visor.provider.duration_ms', {\n      description: 'Duration of provider execution in milliseconds',\n      unit: 'ms',\n    });\n    foreachDurationHist = meter.createHistogram('visor.foreach.item.duration_ms', {\n      description: 'Duration of a forEach item execution in milliseconds',\n      unit: 'ms',\n    });\n    issuesCounter = meter.createCounter('visor.check.issues', {\n      description: 'Number of issues produced by checks',\n      unit: '1',\n    });\n    activeChecks = meter.createUpDownCounter('visor.run.active_checks', {\n      description: 'Number of checks actively running',\n      unit: '1',\n    });\n    failIfCounter = meter.createCounter('visor.fail_if.triggered', {\n      description: 'Number of times fail_if condition triggered',\n      unit: '1',\n    });\n    diagramBlocks = meter.createCounter('visor.diagram.blocks', {\n      description: 'Number of Mermaid diagram blocks emitted',\n      unit: '1',\n    });\n    initialized = true;\n  } catch {\n    // Metrics may be unavailable if SDK not initialized; ignore gracefully\n  }\n}\n\nexport function recordCheckDuration(check: string, durationMs: number, group?: string) {\n  ensureInstruments();\n  try {\n    checkDurationHist?.record(durationMs, {\n      'visor.check.id': check,\n      'visor.check.group': group || 'default',\n    });\n  } catch {}\n}\n\nexport function recordProviderDuration(check: string, providerType: string, durationMs: number) {\n  ensureInstruments();\n  try {\n    providerDurationHist?.record(durationMs, {\n      'visor.check.id': check,\n      'visor.provider.type': providerType,\n    });\n  } catch {}\n}\n\nexport function recordForEachDuration(\n  check: string,\n  index: number,\n  total: number,\n  durationMs: number\n) {\n  ensureInstruments();\n  try {\n    foreachDurationHist?.record(durationMs, {\n      'visor.check.id': check,\n      'visor.foreach.index': index,\n      'visor.foreach.total': total,\n    });\n  } catch {}\n}\n\nexport function addIssues(check: string, severity: string, count = 1) {\n  ensureInstruments();\n  try {\n    issuesCounter?.add(count, {\n      'visor.check.id': check,\n      severity,\n    });\n  } catch {}\n}\n\nexport function incActiveCheck(check: string) {\n  ensureInstruments();\n  try {\n    activeChecks?.add(1, { 'visor.check.id': check });\n  } catch {}\n}\n\nexport function decActiveCheck(check: string) {\n  ensureInstruments();\n  try {\n    activeChecks?.add(-1, { 'visor.check.id': check });\n  } catch {}\n}\n\nexport function addFailIfTriggered(check: string, scope: 'global' | 'check') {\n  ensureInstruments();\n  try {\n    failIfCounter?.add(1, { 'visor.check.id': check, scope });\n  } catch {}\n  if (TEST_ENABLED) TEST_SNAPSHOT.fail_if_triggered++;\n}\n\nexport function addDiagramBlock(origin: 'content' | 'issue') {\n  ensureInstruments();\n  try {\n    diagramBlocks?.add(1, { origin });\n  } catch {}\n}\n\nexport function getTestMetricsSnapshot() {\n  return { ...TEST_SNAPSHOT };\n}\n\nexport function resetTestMetricsSnapshot() {\n  Object.keys(TEST_SNAPSHOT).forEach(k => (TEST_SNAPSHOT[k] = 0));\n}\n","/**\n * Failure condition evaluation engine using SandboxJS for secure expression evaluation\n */\n\nimport { ReviewSummary } from './reviewer';\nimport { addEvent } from './telemetry/trace-helpers';\nimport { addFailIfTriggered } from './telemetry/metrics';\nimport {\n  FailureConditions,\n  FailureCondition,\n  FailureConditionContext,\n  FailureConditionResult,\n  FailureConditionSeverity,\n} from './types/config';\nimport Sandbox from '@nyariv/sandboxjs';\nimport { createSecureSandbox } from './utils/sandbox';\nimport { createPermissionHelpers, detectLocalMode } from './utils/author-permissions';\nimport { MemoryStore } from './memory-store';\n\n/**\n * Evaluates failure conditions using SandboxJS for secure evaluation\n */\nexport class FailureConditionEvaluator {\n  private sandbox?: Sandbox;\n\n  constructor() {}\n\n  /**\n   * Create a secure sandbox with whitelisted functions and globals\n   */\n  private createSecureSandbox(): Sandbox {\n    return createSecureSandbox();\n  }\n\n  /**\n   * Evaluate simple fail_if condition\n   */\n  async evaluateSimpleCondition(\n    checkName: string,\n    checkSchema: string,\n    checkGroup: string,\n    reviewSummary: ReviewSummary,\n    expression: string,\n    previousOutputs?: Record<string, ReviewSummary>,\n    authorAssociation?: string\n  ): Promise<boolean> {\n    const context = this.buildEvaluationContext(\n      checkName,\n      checkSchema,\n      checkGroup,\n      reviewSummary,\n      previousOutputs,\n      authorAssociation\n    );\n\n    try {\n      try {\n        const isObj = context.output && typeof context.output === 'object';\n        const keys = isObj ? Object.keys(context.output as any).join(',') : typeof context.output;\n        let errorVal: unknown = undefined;\n        if (isObj && (context.output as any).error !== undefined)\n          errorVal = (context.output as any).error;\n        require('./logger').logger.debug(\n          `  fail_if: evaluating '${expression}' with output keys=${keys} error=${String(errorVal)}`\n        );\n      } catch {}\n      const res = this.evaluateExpression(expression, context);\n      if (res === true) {\n        try {\n          addEvent('fail_if.triggered', {\n            check: checkName,\n            scope: 'check',\n            name: `${checkName}_fail_if`,\n            expression,\n            severity: 'error',\n          });\n        } catch {}\n        try {\n          const { emitNdjsonSpanWithEvents } = require('./telemetry/fallback-ndjson');\n          emitNdjsonSpanWithEvents(\n            'visor.fail_if',\n            { check: checkName, scope: 'check', name: `${checkName}_fail_if` },\n            [\n              {\n                name: 'fail_if.triggered',\n                attrs: {\n                  check: checkName,\n                  scope: 'check',\n                  name: `${checkName}_fail_if`,\n                  expression,\n                  severity: 'error',\n                },\n              },\n            ]\n          );\n        } catch {}\n      }\n      return res;\n    } catch (error) {\n      console.warn(`Failed to evaluate fail_if expression: ${error}`);\n      return false; // Don't fail on evaluation errors\n    }\n  }\n\n  /**\n   * Determine if the event is related to pull requests\n   */\n  private determineIfPullRequest(eventType?: string): boolean {\n    if (!eventType) return false;\n\n    const prEvents = ['pr_opened', 'pr_updated', 'pr_closed', 'pull_request'];\n    return prEvents.includes(eventType) || eventType.startsWith('pr_');\n  }\n\n  /**\n   * Determine if the event is related to issues\n   */\n  private determineIfIssue(eventType?: string): boolean {\n    if (!eventType) return false;\n\n    const issueEvents = ['issue_opened', 'issue_comment', 'issues'];\n    return issueEvents.includes(eventType) || eventType.startsWith('issue_');\n  }\n\n  /**\n   * Evaluate if condition to determine whether a check should run\n   */\n  async evaluateIfCondition(\n    checkName: string,\n    expression: string,\n    contextData?: {\n      branch?: string;\n      baseBranch?: string;\n      filesChanged?: string[];\n      event?: string;\n      environment?: Record<string, string>;\n      previousResults?: Map<string, ReviewSummary>;\n      authorAssociation?: string;\n      workflowInputs?: Record<string, unknown>;\n    }\n  ): Promise<boolean> {\n    // Build context for if evaluation\n    const context = {\n      // Check metadata\n      checkName,\n\n      // Git context\n      branch: contextData?.branch || 'unknown',\n      baseBranch: contextData?.baseBranch || 'main',\n      filesChanged: contextData?.filesChanged || [],\n      filesCount: contextData?.filesChanged?.length || 0,\n\n      // GitHub event context\n      event: {\n        event_name: contextData?.event || 'manual',\n        action: undefined, // Would be populated from actual GitHub context\n        repository: undefined, // Would be populated from actual GitHub context\n      },\n\n      // Environment variables\n      env: contextData?.environment || {},\n\n      // Previous check results (unwrap output field like templates do)\n      outputs: contextData?.previousResults\n        ? (() => {\n            const outputs: Record<string, unknown> = {};\n            for (const [checkName, result] of contextData.previousResults) {\n              // If the result has a direct output field, use it directly\n              // Otherwise, expose the entire result as-is\n              const summary = result as ReviewSummary & { output?: unknown };\n              outputs[checkName] = summary.output !== undefined ? summary.output : summary;\n            }\n            return outputs;\n          })()\n        : {},\n\n      // Workflow inputs (for workflows)\n      inputs: contextData?.workflowInputs || {},\n\n      // Required output property (empty for if conditions)\n      output: {\n        issues: [],\n      },\n      // Author association (used by permission helpers)\n      authorAssociation: contextData?.authorAssociation,\n\n      // Utility metadata\n      metadata: {\n        checkName,\n        schema: '',\n        group: '',\n        criticalIssues: 0,\n        errorIssues: 0,\n        warningIssues: 0,\n        infoIssues: 0,\n        totalIssues: 0,\n        hasChanges: (contextData?.filesChanged?.length || 0) > 0,\n        branch: contextData?.branch || 'unknown',\n        event: contextData?.event || 'manual',\n      },\n    };\n\n    try {\n      const res = this.evaluateExpression(expression, context);\n      try {\n        if (process.env.VISOR_DEBUG === 'true') {\n          const envMap = context.env || {};\n\n          console.error(\n            `[if-eval] check=${checkName} expr=\"${expression}\" env.ENABLE_FACT_VALIDATION=${String(\n              (envMap as any).ENABLE_FACT_VALIDATION\n            )} event=${context.event?.event_name} result=${String(res)}`\n          );\n        }\n      } catch {}\n      return res;\n    } catch (error) {\n      console.warn(`Failed to evaluate if expression for check '${checkName}': ${error}`);\n      // Fail-secure: do not run the check on evaluation errors\n      return false;\n    }\n  }\n\n  /**\n   * Evaluate all failure conditions for a check result\n   */\n  async evaluateConditions(\n    checkName: string,\n    checkSchema: string,\n    checkGroup: string,\n    reviewSummary: ReviewSummary,\n    globalConditions?: FailureConditions,\n    checkConditions?: FailureConditions,\n    previousOutputs?: Record<string, ReviewSummary>,\n    authorAssociation?: string\n  ): Promise<FailureConditionResult[]> {\n    const context = this.buildEvaluationContext(\n      checkName,\n      checkSchema,\n      checkGroup,\n      reviewSummary,\n      previousOutputs,\n      authorAssociation\n    );\n\n    const results: FailureConditionResult[] = [];\n\n    // Evaluate global conditions first\n    if (globalConditions) {\n      const globalResults = await this.evaluateConditionSet(globalConditions, context, 'global');\n      results.push(...globalResults);\n    }\n\n    // Evaluate check-specific conditions (these override global ones with same name)\n    if (checkConditions) {\n      const checkResults = await this.evaluateConditionSet(checkConditions, context, 'check');\n\n      // Remove global conditions that are overridden by check-specific ones\n      const overriddenConditions = new Set(Object.keys(checkConditions));\n      const filteredResults = results.filter(\n        result => !overriddenConditions.has(result.conditionName)\n      );\n\n      results.length = 0;\n      results.push(...filteredResults, ...checkResults);\n    }\n\n    try {\n      if (checkName === 'B') {\n        console.error(\n          `üîß Debug: fail_if results for ${checkName}: ${JSON.stringify(results)} context.output=${JSON.stringify(\n            context.output\n          )}`\n        );\n      }\n    } catch {}\n    return results;\n  }\n\n  /**\n   * Evaluate a set of failure conditions\n   */\n  private async evaluateConditionSet(\n    conditions: FailureConditions,\n    context: FailureConditionContext,\n    source: 'global' | 'check'\n  ): Promise<FailureConditionResult[]> {\n    const results: FailureConditionResult[] = [];\n\n    for (const [conditionName, condition] of Object.entries(conditions)) {\n      try {\n        addEvent('fail_if.evaluated', {\n          check: context.checkName,\n          scope: source,\n          name: conditionName,\n          expression: this.extractExpression(condition),\n        });\n      } catch {}\n\n      // File fallback: append an NDJSON span with the evaluation event\n      try {\n        const { emitNdjsonSpanWithEvents } = require('./telemetry/fallback-ndjson');\n        emitNdjsonSpanWithEvents(\n          'visor.fail_if',\n          { check: context.checkName || 'unknown', scope: source, name: conditionName },\n          [\n            {\n              name: 'fail_if.evaluated',\n              attrs: {\n                check: context.checkName,\n                scope: source,\n                name: conditionName,\n                expression: this.extractExpression(condition),\n              },\n            },\n          ]\n        );\n      } catch {}\n\n      try {\n        const result = await this.evaluateSingleCondition(conditionName, condition, context);\n        results.push(result);\n\n        if (result.failed) {\n          try {\n            addEvent('fail_if.triggered', {\n              check: context.checkName,\n              scope: source,\n              name: conditionName,\n              expression: result.expression,\n              severity: result.severity,\n              halt_execution: result.haltExecution,\n            });\n          } catch {}\n          try {\n            addFailIfTriggered(context.checkName || 'unknown', source);\n          } catch {}\n        }\n      } catch (error) {\n        // If evaluation fails, create an error result\n        results.push({\n          conditionName,\n          failed: false,\n          expression: this.extractExpression(condition),\n          severity: 'error',\n          haltExecution: false,\n          error: `Failed to evaluate ${source} condition '${conditionName}': ${\n            error instanceof Error ? error.message : String(error)\n          }`,\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Evaluate a single failure condition\n   */\n  private async evaluateSingleCondition(\n    conditionName: string,\n    condition: FailureCondition,\n    context: FailureConditionContext\n  ): Promise<FailureConditionResult> {\n    const expression = this.extractExpression(condition);\n    const config = this.extractConditionConfig(condition);\n\n    try {\n      const failed = this.evaluateExpression(expression, context);\n\n      return {\n        conditionName,\n        failed,\n        expression,\n        message: config.message,\n        severity: config.severity || 'error',\n        haltExecution: config.halt_execution || false,\n      };\n    } catch (error) {\n      throw new Error(\n        `Expression evaluation error: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Secure expression evaluation using SandboxJS\n   * Supports the same GitHub Actions-style functions as the previous implementation\n   */\n  private evaluateExpression(condition: string, context: FailureConditionContext): boolean {\n    try {\n      // Normalize multi-line or semicolon-separated expressions.\n      // Allows writing debug statements on separate lines, e.g.:\n      //   log(\"start\")\n      //   log(outputs)\n      //   outputs[\"fetch-tickets\"].issueType === 'Bug'\n      // We convert to a single expression using the comma operator so the\n      // final expression determines the boolean result.\n      const normalize = (expr: string): string => {\n        const trimmed = expr.trim();\n        // If it's already a single-line expression without semicolons, keep it.\n        if (!/[\\n;]/.test(trimmed)) return trimmed;\n\n        // Split on newlines/semicolons, drop empty and comment-only lines.\n        const parts = trimmed\n          .split(/[\\n;]+/)\n          .map(s => s.trim())\n          .filter(s => s.length > 0 && !s.startsWith('//'));\n\n        if (parts.length === 0) return 'true';\n\n        // Support an explicit return in the last statement.\n        const lastRaw = parts.pop() as string;\n        const last = lastRaw.replace(/^return\\s+/i, '').trim();\n\n        // Join leading statements with comma operator; last expression returns value.\n        if (parts.length === 0) return last;\n        return `(${parts.join(', ')}, ${last})`;\n      };\n\n      // note: normalization happens later only if raw compilation fails\n      // Helper functions for GitHub Actions-style expressions\n      const contains = (searchString: string, searchValue: string): boolean =>\n        String(searchString).toLowerCase().includes(String(searchValue).toLowerCase());\n\n      const startsWith = (searchString: string, searchValue: string): boolean =>\n        String(searchString).toLowerCase().startsWith(String(searchValue).toLowerCase());\n\n      const endsWith = (searchString: string, searchValue: string): boolean =>\n        String(searchString).toLowerCase().endsWith(String(searchValue).toLowerCase());\n\n      const length = (value: string | unknown[] | Record<string, unknown>): number => {\n        if (typeof value === 'string' || Array.isArray(value)) {\n          return value.length;\n        }\n        if (value && typeof value === 'object') {\n          return Object.keys(value).length;\n        }\n        return 0;\n      };\n\n      const always = (): boolean => true;\n      const success = (): boolean => true;\n      const failure = (): boolean => false;\n\n      // Debug logging function for printing to console\n      const log = (...args: unknown[]): void => {\n        console.log('üîç Debug:', ...args);\n      };\n\n      // Helper functions for array operations\n      const hasIssue = (issues: unknown[], field: string, value: unknown): boolean => {\n        if (!Array.isArray(issues)) return false;\n        return issues.some(issue => (issue as Record<string, unknown>)[field] === value);\n      };\n\n      const countIssues = (issues: unknown[], field: string, value: unknown): number => {\n        if (!Array.isArray(issues)) return 0;\n        return issues.filter(issue => (issue as Record<string, unknown>)[field] === value).length;\n      };\n\n      const hasFileMatching = (issues: unknown[], pattern: string): boolean => {\n        if (!Array.isArray(issues)) return false;\n        return issues.some(issue => (issue as { file?: string }).file?.includes(pattern));\n      };\n\n      // Backward compatibility aliases\n      const hasIssueWith = hasIssue;\n      const hasFileWith = hasFileMatching;\n\n      // Permission helper functions\n      const permissionHelpers = createPermissionHelpers(\n        context.authorAssociation,\n        detectLocalMode()\n      );\n      const hasMinPermission = permissionHelpers.hasMinPermission;\n      const isOwner = permissionHelpers.isOwner;\n      const isMember = permissionHelpers.isMember;\n      const isCollaborator = permissionHelpers.isCollaborator;\n      const isContributor = permissionHelpers.isContributor;\n      const isFirstTimer = permissionHelpers.isFirstTimer;\n\n      // Extract context variables\n      const output = context.output || {};\n      const issues = output.issues || [];\n\n      // Backward compatibility: provide metadata for transition period\n      // TODO: Remove after all configurations are updated\n      const metadata = context.metadata || {\n        checkName: context.checkName || '',\n        schema: context.schema || '',\n        group: context.group || '',\n        criticalIssues: issues.filter((i: { severity?: string }) => i.severity === 'critical')\n          .length,\n        errorIssues: issues.filter((i: { severity?: string }) => i.severity === 'error').length,\n        warningIssues: issues.filter((i: { severity?: string }) => i.severity === 'warning').length,\n        infoIssues: issues.filter((i: { severity?: string }) => i.severity === 'info').length,\n        totalIssues: issues.length,\n        hasChanges: context.hasChanges || false,\n      };\n\n      // Legacy variables for backward compatibility\n      const criticalIssues = metadata.criticalIssues;\n      const errorIssues = metadata.errorIssues;\n      const totalIssues = metadata.totalIssues;\n      const warningIssues = metadata.warningIssues;\n      const infoIssues = metadata.infoIssues;\n\n      // Additional context for 'if' conditions and some failure conditions\n      const checkName = context.checkName || '';\n      const schema = context.schema || '';\n      const group = context.group || '';\n      const branch = context.branch || 'unknown';\n      const baseBranch = context.baseBranch || 'main';\n      const filesChanged = context.filesChanged || [];\n      const filesCount = context.filesCount || 0;\n      const event = context.event || 'manual';\n      const env = context.env || {};\n      const outputs = context.outputs || {};\n      const debugData = context.debug || null;\n\n      // Get memory store and create accessor for fail_if expressions\n      const memoryStore = MemoryStore.getInstance();\n      const memoryAccessor = {\n        get: (key: string, ns?: string) => memoryStore.get(key, ns),\n        has: (key: string, ns?: string) => memoryStore.has(key, ns),\n        list: (ns?: string) => memoryStore.list(ns),\n        getAll: (ns?: string) => memoryStore.getAll(ns),\n      };\n\n      // Create scope with all context variables and helper functions\n      const scope = {\n        // Primary context variables\n        output,\n        outputs,\n        debug: debugData,\n        // Memory accessor for fail_if expressions\n        memory: memoryAccessor,\n        // Legacy compatibility variables\n        issues,\n        metadata,\n        criticalIssues,\n        errorIssues,\n        totalIssues,\n        warningIssues,\n        infoIssues,\n        // If condition context\n        checkName,\n        schema,\n        group,\n        branch,\n        baseBranch,\n        filesChanged,\n        filesCount,\n        event,\n        env,\n        // Helper functions\n        contains,\n        startsWith,\n        endsWith,\n        length,\n        always,\n        success,\n        failure,\n        log,\n        hasIssue,\n        countIssues,\n        hasFileMatching,\n        hasIssueWith,\n        hasFileWith,\n        // Permission helpers\n        hasMinPermission,\n        isOwner,\n        isMember,\n        isCollaborator,\n        isContributor,\n        isFirstTimer,\n      };\n\n      // Compile and execute the expression in the sandbox\n      const raw = condition.trim();\n      if (!this.sandbox) {\n        this.sandbox = this.createSecureSandbox();\n      }\n      let exec: ReturnType<typeof this.sandbox.compile>;\n      try {\n        // Try compiling the raw expression as-is first (supports multi-line logical expressions)\n        exec = this.sandbox.compile(`return (${raw});`);\n      } catch {\n        // Fallback: normalize multi-line statements into a comma-chain expression\n        const normalizedExpr = normalize(condition);\n        exec = this.sandbox.compile(`return (${normalizedExpr});`);\n      }\n      const result = exec(scope).run();\n      try {\n        require('./logger').logger.debug(`  fail_if: result=${Boolean(result)}`);\n      } catch {}\n      // Ensure we return a boolean\n      return Boolean(result);\n    } catch (error) {\n      console.error('‚ùå Failed to evaluate expression:', condition, error);\n      // Re-throw the error so it can be caught at a higher level for error reporting\n      throw error;\n    }\n  }\n\n  /**\n   * Extract the expression from a failure condition\n   */\n  private extractExpression(condition: FailureCondition): string {\n    if (typeof condition === 'string') {\n      return condition;\n    }\n    return condition.condition;\n  }\n\n  /**\n   * Extract configuration from a failure condition\n   */\n  private extractConditionConfig(condition: FailureCondition): {\n    message?: string;\n    severity?: FailureConditionSeverity;\n    halt_execution?: boolean;\n  } {\n    if (typeof condition === 'string') {\n      return {};\n    }\n    return {\n      message: condition.message,\n      severity: condition.severity,\n      halt_execution: condition.halt_execution,\n    };\n  }\n\n  /**\n   * Build the evaluation context for expressions\n   */\n  private buildEvaluationContext(\n    checkName: string,\n    checkSchema: string,\n    checkGroup: string,\n    reviewSummary: ReviewSummary,\n    previousOutputs?: Record<string, ReviewSummary>,\n    authorAssociation?: string\n  ): FailureConditionContext {\n    const { issues, debug } = reviewSummary;\n    const reviewSummaryWithOutput = reviewSummary as ReviewSummary & { output?: unknown };\n\n    // Extract output field to avoid nesting (output.output)\n    const {\n      output: extractedOutput,\n      // Exclude issues from otherFields since we handle it separately\n      issues: _issues, // eslint-disable-line @typescript-eslint/no-unused-vars\n      ...otherFields\n    } = reviewSummaryWithOutput as any;\n\n    // Build output object with safety for array-based outputs (forEach aggregation)\n    const aggregatedOutput: Record<string, unknown> = {\n      issues: (issues || []).map(issue => ({\n        file: issue.file,\n        line: issue.line,\n        endLine: issue.endLine,\n        ruleId: issue.ruleId,\n        message: issue.message,\n        severity: issue.severity,\n        category: issue.category,\n        group: issue.group,\n        schema: issue.schema,\n        suggestion: issue.suggestion,\n        replacement: issue.replacement,\n      })),\n      // Include additional schema-specific data from reviewSummary\n      ...otherFields,\n    };\n\n    if (Array.isArray(extractedOutput)) {\n      // Preserve items array and lift common flags for convenience (e.g., output.error)\n      aggregatedOutput.items = extractedOutput;\n      const anyError = extractedOutput.find(\n        it => it && typeof it === 'object' && (it as Record<string, unknown>).error\n      ) as Record<string, unknown> | undefined;\n      if (anyError && anyError.error !== undefined) {\n        aggregatedOutput.error = anyError.error;\n      }\n    } else if (extractedOutput && typeof extractedOutput === 'object') {\n      Object.assign(aggregatedOutput, extractedOutput as Record<string, unknown>);\n    }\n\n    // If provider attached a raw transform snapshot, merge its fields generically.\n    try {\n      const raw = (reviewSummaryWithOutput as any).__raw;\n      if (raw && typeof raw === 'object') {\n        Object.assign(aggregatedOutput, raw as Record<string, unknown>);\n      }\n    } catch {}\n\n    // If output is a string, try to parse JSON (full or from end) to enrich context,\n    // and also derive common boolean flags generically (e.g., key:true/false) for fail_if usage.\n    try {\n      if (typeof extractedOutput === 'string') {\n        const parsed =\n          this.tryExtractJsonFromEnd(extractedOutput) ??\n          (() => {\n            try {\n              return JSON.parse(extractedOutput);\n            } catch {\n              return null;\n            }\n          })();\n        if (parsed !== null) {\n          if (Array.isArray(parsed)) {\n            (aggregatedOutput as any).items = parsed;\n          } else if (typeof parsed === 'object') {\n            Object.assign(aggregatedOutput, parsed as Record<string, unknown>);\n          }\n        }\n        // Generic boolean key extraction for simple text outputs (no special provider cases)\n        const lower = extractedOutput.toLowerCase();\n        const boolFrom = (key: string): boolean | null => {\n          const reTrue = new RegExp(\n            `(?:^|[^a-z0-9_])${key}[^a-z0-9_]*[:=][^a-z0-9_]*true(?:[^a-z0-9_]|$)`\n          );\n          const reFalse = new RegExp(\n            `(?:^|[^a-z0-9_])${key}[^a-z0-9_]*[:=][^a-z0-9_]*false(?:[^a-z0-9_]|$)`\n          );\n          if (reTrue.test(lower)) return true;\n          if (reFalse.test(lower)) return false;\n          return null;\n        };\n        const keys = ['error'];\n        for (const k of keys) {\n          const v = boolFrom(k);\n          if (v !== null && (aggregatedOutput as any)[k] === undefined) {\n            (aggregatedOutput as any)[k] = v;\n          }\n        }\n      }\n    } catch {}\n\n    // Try to parse JSON from content as a last resort when no structured output is present\n    try {\n      const rsAny = reviewSummaryWithOutput as any;\n      const hasStructuredOutput = extractedOutput !== undefined && extractedOutput !== null;\n      if (!hasStructuredOutput && typeof rsAny?.content === 'string') {\n        const parsedFromContent = this.tryExtractJsonFromEnd(rsAny.content);\n        if (parsedFromContent !== null && parsedFromContent !== undefined) {\n          if (Array.isArray(parsedFromContent)) {\n            (aggregatedOutput as any).items = parsedFromContent;\n          } else if (typeof parsedFromContent === 'object') {\n            Object.assign(aggregatedOutput, parsedFromContent as Record<string, unknown>);\n          }\n        }\n      }\n    } catch {}\n\n    // Get memory store instance\n    const memoryStore = MemoryStore.getInstance();\n\n    const context: FailureConditionContext = {\n      output: aggregatedOutput,\n      outputs: (() => {\n        if (!previousOutputs) return {};\n        const outputs: Record<string, unknown> = {};\n        for (const [checkName, result] of Object.entries(previousOutputs)) {\n          // If the result has a direct output field, use it directly\n          // Otherwise, expose the entire result as-is\n          const summary = result as ReviewSummary & { output?: unknown };\n          outputs[checkName] = summary.output !== undefined ? summary.output : summary;\n        }\n        return outputs;\n      })(),\n      // Add memory accessor for fail_if expressions\n      memory: {\n        get: (key: string, ns?: string) => memoryStore.get(key, ns),\n        has: (key: string, ns?: string) => memoryStore.has(key, ns),\n        list: (ns?: string) => memoryStore.list(ns),\n        getAll: (ns?: string) => memoryStore.getAll(ns),\n      } as any,\n      // Add basic context info for failure conditions\n      checkName: checkName,\n      schema: checkSchema,\n      group: checkGroup,\n      authorAssociation: authorAssociation,\n    };\n\n    // Add debug information if available\n    if (debug) {\n      context.debug = {\n        errors: debug.errors || [],\n        processingTime: debug.processingTime || 0,\n        provider: debug.provider || 'unknown',\n        model: debug.model || 'unknown',\n      };\n    }\n\n    return context;\n  }\n\n  // Minimal JSON-from-end extractor for fail_if context fallback\n  private tryExtractJsonFromEnd(text: string): unknown | null {\n    try {\n      const lines = text.split('\\n');\n      for (let i = lines.length - 1; i >= 0; i--) {\n        const t = lines[i].trim();\n        if (t.startsWith('{') || t.startsWith('[')) {\n          const candidate = lines.slice(i).join('\\n').trim();\n          if (\n            (candidate.startsWith('{') && candidate.endsWith('}')) ||\n            (candidate.startsWith('[') && candidate.endsWith(']'))\n          ) {\n            return JSON.parse(candidate);\n          }\n        }\n      }\n    } catch {}\n    return null;\n  }\n\n  /**\n   * Check if any failure condition requires halting execution\n   */\n  static shouldHaltExecution(results: FailureConditionResult[]): boolean {\n    return results.some(result => result.failed && result.haltExecution);\n  }\n\n  /**\n   * Get all failed conditions\n   */\n  static getFailedConditions(results: FailureConditionResult[]): FailureConditionResult[] {\n    return results.filter(result => result.failed);\n  }\n\n  /**\n   * Group results by severity\n   */\n  static groupResultsBySeverity(results: FailureConditionResult[]): {\n    error: FailureConditionResult[];\n    warning: FailureConditionResult[];\n    info: FailureConditionResult[];\n  } {\n    return {\n      // Only 'error' severity now (no backward compatibility needed here as this is internal)\n      error: results.filter(r => r.severity === 'error'),\n      warning: results.filter(r => r.severity === 'warning'),\n      info: results.filter(r => r.severity === 'info'),\n    };\n  }\n\n  /**\n   * Format results for display\n   */\n  static formatResults(results: FailureConditionResult[]): string {\n    const failed = FailureConditionEvaluator.getFailedConditions(results);\n\n    if (failed.length === 0) {\n      return '‚úÖ All failure conditions passed';\n    }\n\n    const grouped = FailureConditionEvaluator.groupResultsBySeverity(failed);\n    const sections: string[] = [];\n\n    if (grouped.error.length > 0) {\n      sections.push(`‚ùå **Error severity conditions (${grouped.error.length}):**`);\n      grouped.error.forEach(result => {\n        sections.push(`  - ${result.conditionName}: ${result.message || result.expression}`);\n      });\n    }\n\n    if (grouped.warning.length > 0) {\n      sections.push(`‚ö†Ô∏è **Warning conditions (${grouped.warning.length}):**`);\n      grouped.warning.forEach(result => {\n        sections.push(`  - ${result.conditionName}: ${result.message || result.expression}`);\n      });\n    }\n\n    if (grouped.info.length > 0) {\n      sections.push(`‚ÑπÔ∏è **Info conditions (${grouped.info.length}):**`);\n      grouped.info.forEach(result => {\n        sections.push(`  - ${result.conditionName}: ${result.message || result.expression}`);\n      });\n    }\n\n    return sections.join('\\n');\n  }\n}\n","/**\n * GitHub Check Service for creating and managing check runs based on failure conditions\n */\n\nimport { Octokit } from '@octokit/rest';\nimport { FailureConditionResult } from './types/config';\nimport { ReviewIssue } from './reviewer';\nimport { generateFooter } from './footer';\n\nexport interface CheckRunOptions {\n  owner: string;\n  repo: string;\n  head_sha: string;\n  name: string;\n  details_url?: string;\n  external_id?: string;\n}\n\nexport interface CheckRunAnnotation {\n  path: string;\n  start_line: number;\n  end_line: number;\n  annotation_level: 'notice' | 'warning' | 'failure';\n  message: string;\n  title?: string;\n  raw_details?: string;\n}\n\nexport interface CheckRunSummary {\n  title: string;\n  summary: string;\n  text?: string;\n}\n\nexport type CheckRunStatus = 'queued' | 'in_progress' | 'completed';\nexport type CheckRunConclusion =\n  | 'success'\n  | 'failure'\n  | 'neutral'\n  | 'cancelled'\n  | 'timed_out'\n  | 'action_required';\n\n/**\n * Service for managing GitHub Check Runs based on Visor failure conditions\n */\nexport class GitHubCheckService {\n  private octokit: Octokit;\n  private maxAnnotations = 50; // GitHub API limit\n\n  constructor(octokit: Octokit) {\n    this.octokit = octokit;\n  }\n\n  /**\n   * Create a new check run in queued status\n   */\n  async createCheckRun(\n    options: CheckRunOptions,\n    summary?: CheckRunSummary\n  ): Promise<{ id: number; url: string }> {\n    try {\n      const response = await this.octokit.rest.checks.create({\n        owner: options.owner,\n        repo: options.repo,\n        name: options.name,\n        head_sha: options.head_sha,\n        status: 'queued',\n        details_url: options.details_url,\n        external_id: options.external_id,\n        output: summary\n          ? {\n              title: summary.title,\n              summary: summary.summary,\n              text: summary.text,\n            }\n          : undefined,\n      });\n\n      return {\n        id: response.data.id,\n        url: response.data.html_url || '',\n      };\n    } catch (error) {\n      throw new Error(\n        `Failed to create check run: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Update check run to in_progress status\n   */\n  async updateCheckRunInProgress(\n    owner: string,\n    repo: string,\n    check_run_id: number,\n    summary?: CheckRunSummary\n  ): Promise<void> {\n    try {\n      await this.octokit.rest.checks.update({\n        owner,\n        repo,\n        check_run_id,\n        status: 'in_progress',\n        output: summary\n          ? {\n              title: summary.title,\n              summary: summary.summary,\n              text: summary.text,\n            }\n          : undefined,\n      });\n    } catch (error) {\n      throw new Error(\n        `Failed to update check run to in_progress: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Complete a check run with results based on failure conditions\n   */\n  async completeCheckRun(\n    owner: string,\n    repo: string,\n    check_run_id: number,\n    checkName: string,\n    failureResults: FailureConditionResult[],\n    reviewIssues: ReviewIssue[] = [],\n    executionError?: string,\n    filesChangedInCommit?: string[],\n    prNumber?: number,\n    currentCommitSha?: string\n  ): Promise<void> {\n    try {\n      // Clear old annotations from ALL previous check runs (including older runs on the same commit)\n      // This prevents annotation accumulation when a check runs multiple times\n      if (prNumber && currentCommitSha) {\n        await this.clearOldAnnotations(\n          owner,\n          repo,\n          prNumber,\n          checkName,\n          currentCommitSha,\n          check_run_id\n        );\n      }\n\n      const { conclusion, summary } = this.determineCheckRunConclusion(\n        checkName,\n        failureResults,\n        reviewIssues,\n        executionError\n      );\n\n      // Filter out system-level issues (fail_if conditions, internal errors)\n      // These should not appear as annotations but affect the check conclusion\n      let filteredIssues = reviewIssues.filter(\n        issue => !(issue.file === 'system' && issue.line === 0)\n      );\n\n      // Filter annotations to only include files changed in this commit\n      // This prevents old annotations from previous commits showing up in the Files tab\n      if (filesChangedInCommit && filesChangedInCommit.length > 0) {\n        filteredIssues = filteredIssues.filter(issue =>\n          filesChangedInCommit.some(changedFile => issue.file === changedFile)\n        );\n      }\n\n      const annotations = this.convertIssuesToAnnotations(filteredIssues);\n\n      await this.octokit.rest.checks.update({\n        owner,\n        repo,\n        check_run_id,\n        status: 'completed',\n        conclusion,\n        completed_at: new Date().toISOString(),\n        output: {\n          title: summary.title,\n          summary: summary.summary,\n          text: summary.text,\n          annotations: annotations.slice(0, this.maxAnnotations), // GitHub limit\n        },\n      });\n    } catch (error) {\n      throw new Error(\n        `Failed to complete check run: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Determine check run conclusion based on failure conditions and issues\n   */\n  private determineCheckRunConclusion(\n    checkName: string,\n    failureResults: FailureConditionResult[],\n    reviewIssues: ReviewIssue[],\n    executionError?: string\n  ): { conclusion: CheckRunConclusion; summary: CheckRunSummary } {\n    // Handle execution errors first\n    if (executionError) {\n      return {\n        conclusion: 'failure',\n        summary: {\n          title: '‚ùå Check Execution Failed',\n          summary: `The ${checkName} check failed to execute properly.`,\n          text: `**Error:** ${executionError}\\n\\nPlease check your configuration and try again.`,\n        },\n      };\n    }\n\n    // Check if any fail_if conditions were met\n    const failedConditions = failureResults.filter(result => result.failed);\n\n    // Count issues by severity (for informational display only)\n    const criticalIssues = reviewIssues.filter(issue => issue.severity === 'critical').length;\n    const errorIssues = reviewIssues.filter(issue => issue.severity === 'error').length;\n    const warningIssues = reviewIssues.filter(issue => issue.severity === 'warning').length;\n    const totalIssues = reviewIssues.length;\n\n    // Determine conclusion ONLY based on fail_if evaluation results\n    // The presence of issues (critical, error, warning) does NOT affect the conclusion\n    // Only the fail_if condition determines pass/fail status\n    let conclusion: CheckRunConclusion;\n    let title: string;\n    let summaryText: string;\n    let details: string;\n\n    if (failedConditions.length > 0) {\n      // Check fails if fail_if condition is met\n      conclusion = 'failure';\n      title = 'üö® Check Failed';\n      summaryText = `${checkName} check failed because fail_if condition was met.`;\n\n      details = this.formatCheckDetails(failureResults, reviewIssues, {\n        failedConditions: failedConditions.length,\n        warningConditions: 0,\n        criticalIssues,\n        errorIssues,\n        warningIssues,\n        totalIssues,\n      });\n    } else {\n      // No fail_if conditions met - check passes regardless of issues found\n      conclusion = 'success';\n\n      // Adjust the title and summary based on issues found, but conclusion remains success\n      if (criticalIssues > 0 || errorIssues > 0) {\n        title = '‚úÖ Check Passed (Issues Found)';\n        summaryText = `${checkName} check passed. Found ${criticalIssues} critical and ${errorIssues} error issues, but fail_if condition was not met.`;\n      } else if (warningIssues > 0) {\n        title = '‚úÖ Check Passed (Warnings Found)';\n        summaryText = `${checkName} check passed. Found ${warningIssues} warning${warningIssues === 1 ? '' : 's'}, but fail_if condition was not met.`;\n      } else {\n        title = '‚úÖ Check Passed';\n        summaryText = `${checkName} check completed successfully with no issues found.`;\n      }\n\n      details = this.formatCheckDetails(failureResults, reviewIssues, {\n        failedConditions: 0,\n        warningConditions: 0,\n        criticalIssues,\n        errorIssues,\n        warningIssues,\n        totalIssues,\n      });\n    }\n\n    return {\n      conclusion,\n      summary: {\n        title,\n        summary: summaryText,\n        text: details,\n      },\n    };\n  }\n\n  /**\n   * Format detailed check results for the check run summary\n   */\n  private formatCheckDetails(\n    failureResults: FailureConditionResult[],\n    reviewIssues: ReviewIssue[],\n    counts: {\n      failedConditions: number;\n      warningConditions: number;\n      criticalIssues: number;\n      errorIssues: number;\n      warningIssues: number;\n      totalIssues: number;\n    }\n  ): string {\n    const sections: string[] = [];\n\n    // Summary section\n    sections.push('## üìä Summary');\n    sections.push(`- **Total Issues:** ${counts.totalIssues}`);\n    if (counts.criticalIssues > 0) {\n      sections.push(`- **Critical Issues:** ${counts.criticalIssues}`);\n    }\n    if (counts.errorIssues > 0) {\n      sections.push(`- **Error Issues:** ${counts.errorIssues}`);\n    }\n    if (counts.warningIssues > 0) {\n      sections.push(`- **Warning Issues:** ${counts.warningIssues}`);\n    }\n    sections.push('');\n\n    // Failure conditions section\n    if (failureResults.length > 0) {\n      sections.push('## üîç Failure Condition Results');\n\n      const failedConditions = failureResults.filter(result => result.failed);\n      const passedConditions = failureResults.filter(result => !result.failed);\n\n      if (failedConditions.length > 0) {\n        sections.push('### Failed Conditions');\n        failedConditions.forEach(condition => {\n          sections.push(\n            `- **${condition.conditionName}**: ${condition.message || condition.expression}`\n          );\n          if (condition.severity) {\n            const icon = this.getSeverityEmoji(condition.severity);\n            sections.push(`  - Severity: ${icon} ${condition.severity}`);\n          }\n        });\n        sections.push('');\n      }\n\n      if (passedConditions.length > 0) {\n        sections.push('### Passed Conditions');\n        passedConditions.forEach(condition => {\n          sections.push(\n            `- **${condition.conditionName}**: ${condition.message || 'Condition passed'}`\n          );\n        });\n        sections.push('');\n      }\n    }\n\n    // Issues by category section\n    if (reviewIssues.length > 0) {\n      const issuesByCategory = this.groupIssuesByCategory(reviewIssues);\n      sections.push('## Issues by Category');\n\n      Object.entries(issuesByCategory).forEach(([category, issues]) => {\n        if (issues.length > 0) {\n          sections.push(\n            `### ${category.charAt(0).toUpperCase() + category.slice(1)} (${issues.length})`\n          );\n\n          // Show only first 5 issues per category to keep the summary concise\n          const displayIssues = issues.slice(0, 5);\n          displayIssues.forEach(issue => {\n            const severityIcon = this.getSeverityEmoji(issue.severity);\n            sections.push(`- ${severityIcon} **${issue.file}:${issue.line}** - ${issue.message}`);\n          });\n\n          if (issues.length > 5) {\n            sections.push(`- *...and ${issues.length - 5} more ${category} issues*`);\n          }\n          sections.push('');\n        }\n      });\n    }\n\n    // Footer\n    sections.push('');\n    sections.push(generateFooter());\n\n    return sections.join('\\n');\n  }\n\n  /**\n   * Convert review issues to GitHub check run annotations\n   */\n  private convertIssuesToAnnotations(reviewIssues: ReviewIssue[]): CheckRunAnnotation[] {\n    return reviewIssues\n      .slice(0, this.maxAnnotations) // Respect GitHub's annotation limit\n      .map(issue => ({\n        path: issue.file,\n        start_line: issue.line,\n        end_line: issue.endLine || issue.line,\n        annotation_level: this.mapSeverityToAnnotationLevel(issue.severity),\n        message: issue.message,\n        title: `${issue.category} Issue`,\n        raw_details: issue.suggestion || undefined,\n      }));\n  }\n\n  /**\n   * Map Visor issue severity to GitHub annotation level\n   */\n  private mapSeverityToAnnotationLevel(severity: string): 'notice' | 'warning' | 'failure' {\n    switch (severity) {\n      case 'critical':\n      case 'error':\n        return 'failure';\n      case 'warning':\n        return 'warning';\n      case 'info':\n      default:\n        return 'notice';\n    }\n  }\n\n  /**\n   * Group issues by category\n   */\n  private groupIssuesByCategory(issues: ReviewIssue[]): Record<string, ReviewIssue[]> {\n    const grouped: Record<string, ReviewIssue[]> = {};\n\n    issues.forEach(issue => {\n      const category = issue.category || 'general';\n      if (!grouped[category]) {\n        grouped[category] = [];\n      }\n      grouped[category].push(issue);\n    });\n\n    return grouped;\n  }\n\n  /**\n   * Get emoji for issue severity (allowed; step/category emojis are removed)\n   */\n  private getSeverityEmoji(severity: string): string {\n    const iconMap: Record<string, string> = {\n      critical: 'üö®',\n      error: '‚ùå',\n      warning: '‚ö†Ô∏è',\n      info: '‚ÑπÔ∏è',\n    };\n    return iconMap[String(severity || '').toLowerCase()] || '';\n  }\n\n  /**\n   * Create multiple check runs for different checks with failure condition support\n   */\n  async createMultipleCheckRuns(\n    options: CheckRunOptions,\n    checkResults: Array<{\n      checkName: string;\n      failureResults: FailureConditionResult[];\n      reviewIssues: ReviewIssue[];\n      executionError?: string;\n    }>\n  ): Promise<Array<{ checkName: string; id: number; url: string }>> {\n    const results: Array<{ checkName: string; id: number; url: string }> = [];\n\n    for (const checkResult of checkResults) {\n      try {\n        // Create check run\n        const checkRun = await this.createCheckRun({\n          ...options,\n          name: `Visor: ${checkResult.checkName}`,\n          external_id: `visor-${checkResult.checkName}-${options.head_sha.substring(0, 7)}`,\n        });\n\n        // Update to in progress\n        await this.updateCheckRunInProgress(options.owner, options.repo, checkRun.id, {\n          title: `Running ${checkResult.checkName} check...`,\n          summary: `Analyzing code with ${checkResult.checkName} check using AI.`,\n        });\n\n        // Complete with results\n        await this.completeCheckRun(\n          options.owner,\n          options.repo,\n          checkRun.id,\n          checkResult.checkName,\n          checkResult.failureResults,\n          checkResult.reviewIssues,\n          checkResult.executionError\n        );\n\n        results.push({\n          checkName: checkResult.checkName,\n          id: checkRun.id,\n          url: checkRun.url,\n        });\n      } catch (error) {\n        console.error(`Failed to create check run for ${checkResult.checkName}:`, error);\n        // Continue with other checks even if one fails\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Get check runs for a specific commit\n   */\n  async getCheckRuns(\n    owner: string,\n    repo: string,\n    ref: string\n  ): Promise<Array<{ id: number; name: string; status: string; conclusion: string | null }>> {\n    try {\n      const response = await this.octokit.rest.checks.listForRef({\n        owner,\n        repo,\n        ref,\n        filter: 'all',\n      });\n\n      return response.data.check_runs\n        .filter(check => check.name.startsWith('Visor:'))\n        .map(check => ({\n          id: check.id,\n          name: check.name,\n          status: check.status,\n          conclusion: check.conclusion,\n        }));\n    } catch (error) {\n      throw new Error(\n        `Failed to get check runs: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Get check runs for a specific commit SHA\n   * Returns all check runs with the given name on this commit\n   */\n  async getCheckRunsForCommit(\n    owner: string,\n    repo: string,\n    commitSha: string,\n    checkName: string\n  ): Promise<Array<{ id: number; head_sha: string }>> {\n    try {\n      const checksResponse = await this.octokit.rest.checks.listForRef({\n        owner,\n        repo,\n        ref: commitSha,\n        check_name: `Visor: ${checkName}`,\n      });\n\n      return checksResponse.data.check_runs.map(check => ({\n        id: check.id,\n        head_sha: commitSha,\n      }));\n    } catch (error) {\n      throw new Error(\n        `Failed to get check runs for commit ${commitSha}: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Clear annotations from old check runs on the current commit\n   * This prevents annotation accumulation when a check runs multiple times on the same commit\n   * (e.g., force push, re-running checks)\n   */\n  async clearOldAnnotations(\n    owner: string,\n    repo: string,\n    prNumber: number, // Not used, kept for backward compatibility\n    checkName: string,\n    currentCommitSha: string,\n    currentCheckRunId: number\n  ): Promise<void> {\n    try {\n      // Get all check runs for this check name on the current commit\n      const allCheckRuns = await this.getCheckRunsForCommit(\n        owner,\n        repo,\n        currentCommitSha,\n        checkName\n      );\n\n      // Filter out the CURRENT check run (by ID)\n      // This handles the case where Visor runs multiple times on the same commit\n      const oldRuns = allCheckRuns.filter(run => run.id !== currentCheckRunId);\n\n      if (oldRuns.length === 0) {\n        console.debug(`No old check runs to clear for ${checkName} on commit ${currentCommitSha}`);\n        return;\n      }\n\n      console.debug(\n        `Clearing ${oldRuns.length} old check run(s) for ${checkName} on commit ${currentCommitSha.substring(0, 7)} (keeping current run ${currentCheckRunId})`\n      );\n\n      // Update each old check run to have empty annotations\n      for (const run of oldRuns) {\n        try {\n          await this.octokit.rest.checks.update({\n            owner,\n            repo,\n            check_run_id: run.id,\n            output: {\n              title: 'Outdated',\n              summary: 'This check has been superseded by a newer run.',\n              annotations: [], // Clear annotations\n            },\n          });\n          console.debug(`‚úì Cleared annotations from check run ${run.id}`);\n        } catch (error) {\n          console.debug(`Could not clear annotations for check run ${run.id}:`, error);\n        }\n      }\n    } catch (error) {\n      // Don't fail the whole check if we can't clear old annotations\n      console.warn('Failed to clear old annotations:', error);\n    }\n  }\n}\n","/*\n * Internal snapshot store for incremental adoption of snapshot+scope execution.\n * Phase 0: journal only ‚Äî no behavior change, used for future visibility work.\n */\n\nimport type { ReviewSummary } from './reviewer';\nimport type { EventTrigger } from './types/config';\n\nexport type ScopePath = Array<{ check: string; index: number }>;\n\nexport interface JournalEntry {\n  commitId: number;\n  sessionId: string;\n  scope: ScopePath;\n  checkId: string;\n  event: EventTrigger | undefined;\n  result: ReviewSummary & { output?: unknown; content?: string };\n}\n\nexport class ExecutionJournal {\n  private commit = 0;\n  private entries: JournalEntry[] = [];\n\n  beginSnapshot(): number {\n    return this.commit;\n  }\n\n  commitEntry(entry: {\n    sessionId: string;\n    scope: ScopePath;\n    checkId: string;\n    result: ReviewSummary & { output?: unknown; content?: string };\n    event?: EventTrigger;\n  }): JournalEntry {\n    const committed: JournalEntry = {\n      sessionId: entry.sessionId,\n      scope: entry.scope,\n      checkId: entry.checkId,\n      result: entry.result,\n      event: entry.event,\n      commitId: ++this.commit,\n    };\n    this.entries.push(committed);\n    return committed;\n  }\n\n  readVisible(sessionId: string, commitMax: number, event?: EventTrigger): JournalEntry[] {\n    return this.entries.filter(\n      e =>\n        e.sessionId === sessionId && e.commitId <= commitMax && (event ? e.event === event : true)\n    );\n  }\n\n  // Lightweight helpers for debugging/metrics\n  size(): number {\n    return this.entries.length;\n  }\n}\n\nexport class ContextView {\n  constructor(\n    private journal: ExecutionJournal,\n    private sessionId: string,\n    private snapshotId: number,\n    private scope: ScopePath,\n    private event?: EventTrigger\n  ) {}\n\n  /** Return the nearest result for a check in this scope (exact item ‚Üí ancestor ‚Üí latest). */\n  get(checkId: string): (ReviewSummary & { output?: unknown; content?: string }) | undefined {\n    const visible = this.journal\n      .readVisible(this.sessionId, this.snapshotId, this.event)\n      .filter(e => e.checkId === checkId);\n    if (visible.length === 0) return undefined;\n\n    // exact scope match\n    const exact = visible.find(e => this.sameScope(e.scope, this.scope));\n    if (exact) return exact.result;\n\n    // nearest ancestor (shortest distance)\n    let best: { entry: JournalEntry; dist: number } | undefined;\n    for (const e of visible) {\n      const dist = this.ancestorDistance(e.scope, this.scope);\n      if (dist >= 0 && (best === undefined || dist < best.dist)) {\n        best = { entry: e, dist };\n      }\n    }\n    if (best) return best.entry.result;\n\n    // fallback to latest committed result\n    return visible[visible.length - 1]?.result;\n  }\n\n  /** Return an aggregate (raw) result ‚Äì the shallowest scope for this check. */\n  getRaw(checkId: string): (ReviewSummary & { output?: unknown; content?: string }) | undefined {\n    const visible = this.journal\n      .readVisible(this.sessionId, this.snapshotId, this.event)\n      .filter(e => e.checkId === checkId);\n    if (visible.length === 0) return undefined;\n    let shallow = visible[0];\n    for (const e of visible) {\n      if (e.scope.length < shallow.scope.length) shallow = e;\n    }\n    return shallow.result;\n  }\n\n  /** All results for a check up to this snapshot. */\n  getHistory(checkId: string): Array<ReviewSummary & { output?: unknown; content?: string }> {\n    return this.journal\n      .readVisible(this.sessionId, this.snapshotId, this.event)\n      .filter(e => e.checkId === checkId)\n      .map(e => e.result);\n  }\n\n  private sameScope(a: ScopePath, b: ScopePath): boolean {\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (a[i].check !== b[i].check || a[i].index !== b[i].index) return false;\n    }\n    return true;\n  }\n\n  // distance from ancestor to current; -1 if not ancestor\n  private ancestorDistance(ancestor: ScopePath, current: ScopePath): number {\n    if (ancestor.length > current.length) return -1;\n    // Treat root scope ([]) as non-ancestor for unrelated branches\n    if (ancestor.length === 0 && current.length > 0) return -1;\n    for (let i = 0; i < ancestor.length; i++) {\n      if (ancestor[i].check !== current[i].check || ancestor[i].index !== current[i].index)\n        return -1;\n    }\n    return current.length - ancestor.length;\n  }\n}\n","import { createSecureSandbox } from '../../utils/sandbox';\nimport type { PRInfo } from '../../pr-analyzer';\nimport type { ReviewSummary } from '../../reviewer';\nimport type { VisorConfig, CheckConfig, OnFinishConfig } from '../../types/config';\nimport { buildSandboxEnv } from '../../utils/env-exposure';\nimport { MemoryStore } from '../../memory-store';\n\nexport function buildProjectionFrom(\n  results: Map<string, ReviewSummary>,\n  historySnapshot: Record<string, unknown[]>\n): {\n  outputsForContext: Record<string, unknown>;\n  outputsHistoryForContext: Record<string, unknown[]>;\n} {\n  const outputsForContext: Record<string, unknown> = {};\n  for (const [name, result] of results.entries()) {\n    const r = result as ReviewSummary & { output?: unknown };\n    outputsForContext[name] = r.output !== undefined ? r.output : r;\n  }\n  const outputsHistoryForContext: Record<string, unknown[]> = {};\n  for (const [check, arr] of Object.entries(historySnapshot || {})) {\n    outputsHistoryForContext[check] = Array.isArray(arr) ? (arr as unknown[]) : [];\n  }\n  return { outputsForContext, outputsHistoryForContext };\n}\n\nexport interface OnFinishContext {\n  step: { id: string; tags: string[]; group?: string };\n  attempt: number;\n  loop: number;\n  outputs: Record<string, unknown>;\n  outputs_history: Record<string, unknown[]>;\n  outputs_raw: Record<string, unknown>;\n  forEach: unknown;\n  memory: {\n    get: (key: string, ns?: string) => unknown;\n    has: (key: string, ns?: string) => boolean;\n    getAll: (ns?: string) => Record<string, unknown>;\n    set: (key: string, value: unknown, ns?: string) => void;\n    clear: (ns?: string) => void;\n    increment: (key: string, amount?: number, ns?: string) => number;\n  };\n  pr: { number: number; title?: string; author?: string; branch?: string; base?: string };\n  files?: unknown;\n  env: Record<string, string | undefined>;\n  event: { name: string };\n}\n\nexport function composeOnFinishContext(\n  _memoryConfig: VisorConfig['memory'] | undefined,\n  checkName: string,\n  checkConfig: CheckConfig,\n  outputsForContext: Record<string, unknown>,\n  outputsHistoryForContext: Record<string, unknown[]>,\n  forEachStats: any,\n  prInfo: PRInfo\n): OnFinishContext {\n  // No MemoryStore in on_finish context ‚Äî outputs and outputs_history are sufficient\n  const outputs_raw: Record<string, unknown> = {};\n  for (const [name, val] of Object.entries(outputsForContext))\n    if (name !== 'history') outputs_raw[name] = val;\n  const outputsMerged = { ...outputsForContext, history: outputsHistoryForContext } as Record<\n    string,\n    unknown\n  >;\n  // Memory helpers backed by MemoryStore, but exposed synchronously for\n  // sandboxed goto_js/on_success.run_js compatibility.\n  const memoryStore = MemoryStore.getInstance();\n  const memoryHelpers = {\n    get: (key: string, ns?: string) => memoryStore.get(key, ns),\n    has: (key: string, ns?: string) => memoryStore.has(key, ns),\n    getAll: (ns?: string) => memoryStore.getAll(ns),\n    set: (key: string, value: unknown, ns?: string) => {\n      const nsName = ns || memoryStore.getDefaultNamespace();\n      const data: Map<string, Map<string, unknown>> = (memoryStore as any)['data'];\n      if (!data.has(nsName)) data.set(nsName, new Map());\n      data.get(nsName)!.set(key, value);\n    },\n    clear: (ns?: string) => {\n      const data: Map<string, Map<string, unknown>> = (memoryStore as any)['data'];\n      if (ns) data.delete(ns);\n      else data.clear();\n    },\n    increment: (key: string, amount = 1, ns?: string) => {\n      const nsName = ns || memoryStore.getDefaultNamespace();\n      const data: Map<string, Map<string, unknown>> = (memoryStore as any)['data'];\n      if (!data.has(nsName)) data.set(nsName, new Map());\n      const nsMap = data.get(nsName)!;\n      const current = nsMap.get(key);\n      const numCurrent = typeof current === 'number' ? current : 0;\n      const newValue = numCurrent + amount;\n      nsMap.set(key, newValue);\n      return newValue;\n    },\n  };\n\n  return {\n    step: { id: checkName, tags: checkConfig.tags || [], group: checkConfig.group },\n    attempt: 1,\n    loop: 0,\n    outputs: outputsMerged,\n    outputs_history: outputsHistoryForContext,\n    outputs_raw,\n    forEach: forEachStats,\n    memory: memoryHelpers,\n    pr: {\n      number: prInfo.number,\n      title: prInfo.title,\n      author: prInfo.author,\n      branch: prInfo.head,\n      base: prInfo.base,\n    },\n    files: prInfo.files,\n    env: buildSandboxEnv(process.env),\n    event: { name: prInfo.eventType || 'manual' },\n  };\n}\n\nexport function evaluateOnFinishGoto(\n  onFinish: NonNullable<OnFinishConfig>,\n  onFinishContext: any,\n  debug: boolean,\n  log: (msg: string) => void\n): string | null {\n  let gotoTarget: string | null = null;\n  if (onFinish.goto_js) {\n    const sandbox = createSecureSandbox();\n    try {\n      const scope = onFinishContext;\n      const code = `\n        const step = scope.step; const attempt = scope.attempt; const loop = scope.loop; const outputs = scope.outputs; const outputs_history = scope.outputs_history; const outputs_raw = scope.outputs_raw; const forEach = scope.forEach; const memory = scope.memory; const pr = scope.pr; const files = scope.files; const env = scope.env; const event = scope.event; const log = (...a)=> console.log('üîç Debug:',...a);\n        const __fn = () => {\\n${onFinish.goto_js}\\n};\n        return __fn();\n      `;\n      // Use shared compileAndRun helper for consistent behavior\n      const { compileAndRun } = require('../../utils/sandbox');\n      const result = compileAndRun(\n        sandbox,\n        code,\n        { scope },\n        { injectLog: false, wrapFunction: false }\n      );\n      try {\n        if (debug) {\n          const hist =\n            (onFinishContext &&\n              onFinishContext.outputs &&\n              (onFinishContext.outputs as any).history) ||\n            {};\n          const vf = Array.isArray(hist['validate-fact'])\n            ? hist['validate-fact'].filter((x: any) => !Array.isArray(x))\n            : [];\n          const items =\n            (onFinishContext &&\n              onFinishContext.forEach &&\n              (onFinishContext.forEach as any).last_wave_size) ||\n            0;\n          log(`üîß Debug: goto_js result=${String(result)} items=${items} vf_count=${vf.length}`);\n        }\n      } catch {}\n      gotoTarget = typeof result === 'string' && result ? result : null;\n      if (debug) log(`üîß Debug: on_finish.goto_js evaluated ‚Üí ${String(gotoTarget)}`);\n    } catch (e) {\n      try {\n        // Surface evaluation problems in debug logs to aid diagnosis\n        const msg = e instanceof Error ? e.message : String(e);\n\n        console.error(`‚úó on_finish.goto_js: evaluation error: ${msg}`);\n      } catch {}\n      // Fall back to static goto\n      if (onFinish.goto) gotoTarget = onFinish.goto;\n    }\n  } else if (onFinish.goto) {\n    gotoTarget = onFinish.goto;\n  }\n  return gotoTarget;\n}\n\nexport function recomputeAllValidFromHistory(\n  history: Record<string, unknown[]>,\n  forEachItemsCount: number\n): boolean | undefined {\n  const vfArrRaw = Array.isArray(history['validate-fact'])\n    ? (history['validate-fact'] as unknown[])\n    : [];\n  if (forEachItemsCount <= 0) return undefined;\n\n  // Consider only non-array entries (per-item results)\n  const vfArr = vfArrRaw.filter(v => !Array.isArray(v)) as any[];\n  if (vfArr.length < forEachItemsCount) return false;\n\n  // 1) Prefer strict last-wave grouping when loop_idx metadata is present.\n  const withLoop = vfArr.filter(\n    v => v && typeof v === 'object' && Number.isFinite((v as any).loop_idx)\n  ) as Array<{ loop_idx: number } & Record<string, unknown>>;\n  if (withLoop.length >= forEachItemsCount) {\n    const maxLoop = Math.max(...withLoop.map(v => Number(v.loop_idx)));\n    const sameWave = withLoop.filter(v => Number(v.loop_idx) === maxLoop);\n    try {\n      if (process.env.VISOR_DEBUG === 'true') {\n        console.error(\n          `[ofAllValid] loop_idx=${maxLoop} sameWave=${sameWave.length} items=${forEachItemsCount}`\n        );\n      }\n    } catch {}\n    if (sameWave.length >= forEachItemsCount) {\n      // If we have ids, take the last N distinct by id; otherwise, take last N\n      const take = (() => {\n        const withIds = sameWave.filter(\n          o => typeof (o as any).fact_id === 'string' || typeof (o as any).id === 'string'\n        );\n        if (withIds.length >= forEachItemsCount) {\n          const recent: any[] = [];\n          const seen = new Set<string>();\n          for (let i = sameWave.length - 1; i >= 0 && recent.length < forEachItemsCount; i--) {\n            const o: any = sameWave[i];\n            const key = (o.fact_id || o.id) as string | undefined;\n            if (!key || seen.has(key)) continue;\n            seen.add(key);\n            recent.push(o);\n          }\n          if (recent.length === forEachItemsCount) return recent;\n        }\n        return sameWave.slice(-forEachItemsCount);\n      })();\n      const ok = take.every(o => o && ((o as any).is_valid === true || (o as any).valid === true));\n      try {\n        if (process.env.VISOR_DEBUG === 'true') {\n          const vals = take.map(o => (o as any).is_valid ?? (o as any).valid);\n          console.error(`[ofAllValid] loop verdicts=${JSON.stringify(vals)} ok=${ok}`);\n        }\n      } catch {}\n      return ok;\n    }\n  }\n\n  // 2) Fall back to last N distinct-by-id across the whole history\n  const withIds = vfArr.filter(\n    o => typeof (o as any).fact_id === 'string' || typeof (o as any).id === 'string'\n  );\n  if (withIds.length >= forEachItemsCount) {\n    const recent: any[] = [];\n    const seen = new Set<string>();\n    for (let i = vfArr.length - 1; i >= 0 && recent.length < forEachItemsCount; i--) {\n      const o: any = vfArr[i];\n      const key = (o.fact_id || o.id) as string | undefined;\n      if (!key || seen.has(key)) continue;\n      seen.add(key);\n      recent.push(o);\n    }\n    if (recent.length === forEachItemsCount) {\n      const ok = recent.every(o => o && (o.is_valid === true || o.valid === true));\n      try {\n        if (process.env.VISOR_DEBUG === 'true') {\n          const vals = recent.map(o => (o as any).is_valid ?? (o as any).valid);\n          console.error(`[ofAllValid] id-recent verdicts=${JSON.stringify(vals)} ok=${ok}`);\n        }\n      } catch {}\n      return ok;\n    }\n  }\n\n  // 3) Last-resort fallback: treat last N entries as current wave\n  if (vfArr.length >= forEachItemsCount) {\n    const lastN = vfArr.slice(-forEachItemsCount) as any[];\n    const ok = lastN.every(o => o && (o.is_valid === true || o.valid === true));\n    try {\n      if (process.env.VISOR_DEBUG === 'true') {\n        const vals = lastN.map(o => (o as any).is_valid ?? (o as any).valid);\n        console.error(`[ofAllValid] tail verdicts=${JSON.stringify(vals)} ok=${ok}`);\n      }\n    } catch {}\n    return ok;\n  }\n\n  return false;\n}\n","import type { PRInfo } from '../../pr-analyzer';\nimport type { ReviewSummary } from '../../reviewer';\nimport type { VisorConfig, CheckConfig } from '../../types/config';\nimport {\n  buildProjectionFrom,\n  composeOnFinishContext,\n  evaluateOnFinishGoto,\n  recomputeAllValidFromHistory,\n} from './utils';\n\ntype RunCheckFn = (id: string) => Promise<ReviewSummary>;\n\nexport async function runOnFinishChildren(\n  runIds: string[],\n  runCheck: RunCheckFn,\n  config: VisorConfig,\n  onFinishContext: any,\n  debug: boolean,\n  log: (msg: string) => void\n): Promise<{ lastRunOutput?: unknown }> {\n  let lastRunOutput: unknown = undefined;\n  for (const id of runIds) {\n    if (debug) log(`üîß Debug: on_finish.run executing '${id}'`);\n    const res = await runCheck(id);\n    lastRunOutput = (res as any)?.output;\n    // Evaluate optional child on_success.run_js and run\n    try {\n      const childCfg = (config.checks || {})[id] as CheckConfig | undefined;\n      const childOnSuccess = childCfg?.on_success;\n      if (childOnSuccess) {\n        const vm = require('../../utils/sandbox');\n        const sandbox = vm.createSecureSandbox();\n        const scope = { ...onFinishContext, output: lastRunOutput } as any;\n        const code = `\n          const step = scope.step; const attempt = scope.attempt; const loop = scope.loop; const outputs = scope.outputs; const outputs_history = scope.outputs_history; const outputs_raw = scope.outputs_raw; const forEach = scope.forEach; const memory = scope.memory; const pr = scope.pr; const files = scope.files; const env = scope.env; const event = scope.event; const output = scope.output; const log = (...a)=> console.log('üîç Debug:',...a);\n          const __fn = () => {\\n${childOnSuccess.run_js || ''}\\n};\n          const __res = __fn();\n          return Array.isArray(__res) ? __res.filter(x => typeof x === 'string' && x) : [];\n        `;\n        const exec = sandbox.compile(code);\n        const dynamic = exec({ scope }).run();\n        const childRun = Array.from(\n          new Set([...(childOnSuccess.run || []), ...dynamic].filter(Boolean))\n        ) as string[];\n        for (const c of childRun) await runCheck(c);\n      }\n    } catch {}\n  }\n  return { lastRunOutput };\n}\n\nexport function decideRouting(\n  checkName: string,\n  checkConfig: CheckConfig,\n  outputsForContext: Record<string, unknown>,\n  outputsHistoryForContext: Record<string, unknown[]>,\n  forEachStats: { items: unknown[] },\n  prInfo: PRInfo,\n  config: VisorConfig,\n  debug: boolean,\n  log: (msg: string) => void\n): { gotoTarget: string | null } {\n  const ctx = composeOnFinishContext(\n    config?.memory,\n    checkName,\n    checkConfig,\n    outputsForContext,\n    outputsHistoryForContext,\n    { items: (forEachStats?.items || [])?.length ?? 0 },\n    prInfo\n  );\n  const onFinish = checkConfig.on_finish!;\n  let gotoTarget = evaluateOnFinishGoto(onFinish, ctx, debug, log);\n  // Gentle, config-informed fallback: If goto_js returned null but the\n  // configuration declares a finite retry budget (via a literal\n  // `const maxWaves = 1 + <N>` style), and last wave is not all-valid,\n  // suggest routing back to the parent exactly once per remaining budget.\n  if (!gotoTarget) {\n    try {\n      const js = String(onFinish.goto_js || '');\n      // Extract N from \"const maxWaves = 1 + N\" or \"maxWaves=1+N\" (common pattern in our configs/tests)\n      let n = NaN;\n      {\n        const m = js.match(/maxWaves\\s*=\\s*1\\s*\\+\\s*(\\d+)/);\n        if (m) n = Number(m[1]);\n      }\n      if (!Number.isFinite(n)) {\n        // Generic fallback: find any literal \"1 + <number>\"; take the last occurrence\n        const all = Array.from(js.matchAll(/1\\s*\\+\\s*(\\d+)/g));\n        if (all.length > 0) {\n          const last = all[all.length - 1];\n          const num = Number(last[1]);\n          if (Number.isFinite(num)) n = num;\n        }\n      }\n      const items = (ctx.forEach && (ctx.forEach as any).last_wave_size) || 0;\n      const vf = Array.isArray((ctx.outputs as any).history?.['validate-fact'])\n        ? ((ctx.outputs as any).history['validate-fact'] as unknown[]).filter(\n            (x: unknown) => !Array.isArray(x)\n          )\n        : [];\n      const waves = items > 0 ? Math.floor(vf.length / items) : 0;\n      const last = items > 0 ? vf.slice(-items) : [];\n      const allOk =\n        last.length === items &&\n        last.every((v: any) => v && (v.is_valid === true || v.valid === true));\n      if (!gotoTarget && !allOk && Number.isFinite(n) && n > 0 && waves < 1 + n) {\n        gotoTarget = checkName;\n        if (debug)\n          log(\n            `üîß Debug: decideRouting fallback ‚Üí '${checkName}' (waves=${waves} < maxWaves=${1 + n})`\n          );\n      }\n    } catch {}\n  }\n  return { gotoTarget };\n}\n\nexport function projectOutputs(\n  results: Map<string, ReviewSummary>,\n  historySnapshot: Record<string, unknown[]>\n): {\n  outputsForContext: Record<string, unknown>;\n  outputsHistoryForContext: Record<string, unknown[]>;\n} {\n  return buildProjectionFrom(results, historySnapshot);\n}\n\nexport function computeAllValid(\n  history: Record<string, unknown[]>,\n  itemsCount: number\n): boolean | undefined {\n  return recomputeAllValidFromHistory(history, itemsCount);\n}\n","import { addEvent } from '../telemetry/trace-helpers';\nimport { addDiagramBlock } from '../telemetry/metrics';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nconst MERMAID_RE = /```mermaid\\s*\\n([\\s\\S]*?)\\n```/gi;\n\nexport type DiagramOrigin = 'content' | 'issue';\n\nexport function emitMermaidFromMarkdown(\n  checkName: string,\n  markdown: string,\n  origin: DiagramOrigin\n): number {\n  if (!markdown || typeof markdown !== 'string') return 0;\n  let m: RegExpExecArray | null;\n  let count = 0;\n  MERMAID_RE.lastIndex = 0;\n  while ((m = MERMAID_RE.exec(markdown)) != null) {\n    const code = (m[1] || '').trim();\n    if (code) {\n      try {\n        addEvent('diagram.block', { check: checkName, origin, code });\n        addDiagramBlock(origin);\n        // Fallback writer for environments where OTel SDK isn't active\n        if (process.env.VISOR_TRACE_REPORT === 'true') {\n          const outDir =\n            process.env.VISOR_TRACE_DIR || path.join(process.cwd(), 'output', 'traces');\n          try {\n            if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });\n            const ts = new Date().toISOString().replace(/[:.]/g, '-');\n            const jsonPath = path.join(outDir, `${ts}.trace.json`);\n            const htmlPath = path.join(outDir, `${ts}.report.html`);\n            // Append or create minimal trace JSON\n            let data: {\n              spans: Array<{ events: Array<{ name: string; attrs: Record<string, unknown> }> }>;\n            } = { spans: [] };\n            if (fs.existsSync(jsonPath)) {\n              try {\n                data = JSON.parse(fs.readFileSync(jsonPath, 'utf8'));\n              } catch {\n                data = { spans: [] };\n              }\n            }\n            data.spans.push({\n              events: [{ name: 'diagram.block', attrs: { check: checkName, origin, code } }],\n            });\n            fs.writeFileSync(jsonPath, JSON.stringify(data, null, 2), 'utf8');\n            // Ensure minimal HTML report exists\n            if (!fs.existsSync(htmlPath)) {\n              fs.writeFileSync(\n                htmlPath,\n                '<!doctype html><html><head><meta charset=\"utf-8\"/><title>Visor Trace Report</title></head><body><h2>Visor Trace Report</h2></body></html>',\n                'utf8'\n              );\n            }\n          } catch {}\n        }\n        count++;\n      } catch {\n        // ignore telemetry failures\n      }\n    }\n  }\n  return count;\n}\n","import {\n  PRReviewer,\n  ReviewSummary,\n  ReviewOptions,\n  GroupedCheckResults,\n  CheckResult,\n  ReviewIssue,\n} from './reviewer';\nimport { GitRepositoryAnalyzer, GitRepositoryInfo } from './git-repository-analyzer';\nimport { AnalysisResult } from './output-formatters';\nimport { PRInfo } from './pr-analyzer';\nimport { PRAnalyzer } from './pr-analyzer';\nimport { CheckProviderRegistry } from './providers/check-provider-registry';\nimport { CheckProviderConfig } from './providers/check-provider.interface';\nimport { DependencyResolver, DependencyGraph } from './dependency-resolver';\nimport { FailureConditionEvaluator } from './failure-condition-evaluator';\nimport { FailureConditionResult, CheckConfig } from './types/config';\nimport { GitHubCheckService, CheckRunOptions } from './github-check-service';\nimport { IssueFilter } from './issue-filter';\nimport { logger } from './logger';\nimport Sandbox from '@nyariv/sandboxjs';\nimport { ExecutionJournal, ScopePath, ContextView } from './snapshot-store';\nimport { createSecureSandbox, compileAndRun } from './utils/sandbox';\nimport {\n  projectOutputs as ofProject,\n  decideRouting as ofDecide,\n  computeAllValid as ofAllValid,\n  runOnFinishChildren as ofRunChildren,\n} from './engine/on-finish/orchestrator';\nimport { composeOnFinishContext as ofComposeCtx } from './engine/on-finish/utils';\nimport { VisorConfig, OnFailConfig, OnSuccessConfig, OnFinishConfig } from './types/config';\nimport {\n  createPermissionHelpers,\n  detectLocalMode,\n  resolveAssociationFromEvent,\n} from './utils/author-permissions';\nimport { MemoryStore } from './memory-store';\nimport { emitNdjsonSpanWithEvents, emitNdjsonFallback } from './telemetry/fallback-ndjson';\nimport { generateFooter } from './footer';\nimport { addEvent, withActiveSpan } from './telemetry/trace-helpers';\nimport { addFailIfTriggered } from './telemetry/metrics';\n\ntype ExtendedReviewSummary = ReviewSummary & {\n  output?: unknown;\n  content?: string;\n  isForEach?: boolean;\n  forEachItems?: unknown[];\n  // Preserve per-item results for forEach-dependent checks so children can gate per item\n  forEachItemResults?: ReviewSummary[];\n  // Per-item fatal mask: true means this item is fatal/should gate descendants\n  forEachFatalMask?: boolean[];\n};\n\n/**\n * Statistics for a single check execution\n */\nexport interface CheckExecutionStats {\n  checkName: string;\n  totalRuns: number; // How many times the check executed (1 or forEach iterations)\n  successfulRuns: number;\n  failedRuns: number;\n  skipped: boolean;\n  skipReason?: 'if_condition' | 'fail_fast' | 'dependency_failed';\n  skipCondition?: string; // The actual if condition text\n  totalDuration: number; // Total duration in milliseconds\n  // Provider/self time (excludes time spent running routed children/descendants)\n  providerDurationMs?: number;\n  perIterationDuration?: number[]; // Duration for each iteration (if forEach)\n  issuesFound: number;\n  issuesBySeverity: {\n    critical: number;\n    error: number;\n    warning: number;\n    info: number;\n  };\n  outputsProduced?: number; // Number of outputs for forEach checks\n  errorMessage?: string; // Error message if failed\n  forEachPreview?: string[]; // Preview of forEach items processed (first few)\n}\n\n/**\n * Overall execution statistics for all checks\n */\nexport interface ExecutionStatistics {\n  totalChecksConfigured: number;\n  totalExecutions: number; // Sum of all runs including forEach iterations\n  successfulExecutions: number;\n  failedExecutions: number;\n  skippedChecks: number;\n  totalDuration: number;\n  checks: CheckExecutionStats[];\n}\n\n/**\n * Result of executing checks, including both the grouped results and execution statistics\n */\nexport interface ExecutionResult {\n  results: GroupedCheckResults;\n  statistics: ExecutionStatistics;\n}\n\n/**\n * Filter environment variables to only include safe ones for sandbox evaluation\n */\nfunction getSafeEnvironmentVariables(): Record<string, string> {\n  const { buildSandboxEnv } = require('./utils/env-exposure');\n  return buildSandboxEnv(process.env);\n}\n\nexport interface MockOctokit {\n  rest: {\n    pulls: {\n      get: () => Promise<{ data: Record<string, unknown> }>;\n      listFiles: () => Promise<{ data: Record<string, unknown>[] }>;\n    };\n    issues: {\n      listComments: () => Promise<{ data: Record<string, unknown>[] }>;\n      createComment: () => Promise<{ data: Record<string, unknown> }>;\n    };\n  };\n  request: () => Promise<{ data: Record<string, unknown> }>;\n  graphql: () => Promise<Record<string, unknown>>;\n  log: {\n    debug: (...args: unknown[]) => void;\n    info: (...args: unknown[]) => void;\n    warn: (...args: unknown[]) => void;\n    error: (...args: unknown[]) => void;\n  };\n  hook: {\n    before: (...args: unknown[]) => void;\n    after: (...args: unknown[]) => void;\n    error: (...args: unknown[]) => void;\n    wrap: (...args: unknown[]) => void;\n  };\n  auth: () => Promise<{ token: string }>;\n}\n\nexport interface CheckExecutionOptions {\n  checks: string[];\n  workingDirectory?: string;\n  showDetails?: boolean;\n  timeout?: number;\n  maxParallelism?: number; // Maximum number of checks to run in parallel (default: 3)\n  failFast?: boolean; // Stop execution when any check fails (default: false)\n  outputFormat?: string;\n  config?: import('./types/config').VisorConfig;\n  debug?: boolean; // Enable debug mode to collect AI execution details\n  // Tag filter for selective check execution\n  tagFilter?: import('./types/config').TagFilter;\n  // Webhook context for passing webhook data to http_input providers\n  webhookContext?: {\n    webhookData: Map<string, unknown>;\n  };\n  // GitHub Check integration options\n  githubChecks?: {\n    enabled: boolean;\n    octokit?: import('@octokit/rest').Octokit;\n    owner?: string;\n    repo?: string;\n    headSha?: string;\n    prNumber?: number;\n  };\n}\n\nexport class CheckExecutionEngine {\n  private gitAnalyzer: GitRepositoryAnalyzer;\n  private mockOctokit: MockOctokit;\n  private reviewer: PRReviewer;\n  private providerRegistry: CheckProviderRegistry;\n  private failureEvaluator: FailureConditionEvaluator;\n  private githubCheckService?: GitHubCheckService;\n  private checkRunMap?: Map<string, { id: number; url: string }>;\n  private githubContext?: { owner: string; repo: string };\n  private workingDirectory: string;\n  private config?: import('./types/config').VisorConfig;\n  private webhookContext?: { webhookData: Map<string, unknown> };\n  private routingSandbox?: Sandbox;\n  private executionStats: Map<string, CheckExecutionStats> = new Map();\n  // Track history of all outputs for each check (useful for loops and goto)\n  private outputHistory: Map<string, unknown[]> = new Map();\n  // Track on_finish loop counts per forEach parent during a single execution run\n  private onFinishLoopCounts: Map<string, number> = new Map();\n  // Track how many times a forEach parent check has produced an array during this run (\"waves\")\n  private forEachWaveCounts: Map<string, number> = new Map();\n  // One-shot guards for post on_finish scheduling to avoid duplicate replies when\n  // multiple signals (aggregator, memory, history) agree. Keyed by session + parent check.\n  private postOnFinishGuards: Set<string> = new Set();\n  // Per-run execution cap counters (guard infinite loops). Keyed by check + scope.\n  private runCounters: Map<string, number> = new Map();\n  // Snapshot+Scope journal (Phase 0: commit only, no behavior changes yet)\n  private journal: ExecutionJournal = new ExecutionJournal();\n  private sessionId: string = `sess-${Date.now().toString(36)}-${Math.random()\n    .toString(36)\n    .slice(2, 8)}`;\n  // Dedup forward-run targets within a single grouped run (stage/event).\n  // Keyed by `${event}:${target}`.\n  private forwardRunGuards: Set<string> = new Set();\n  // Guard dependents scheduled via forward-run to avoid races with level tasks\n  // Store per-target scopes to support forEach item-specific routing (JSON-encoded ScopePath)\n  private forwardDependentsScheduled: Map<string, Set<string>> = new Map();\n  private forwardEventOverrides: Map<string, import('./types/config').EventTrigger> = new Map();\n  // Forward-run planning hints per routed target\n  // - includeDependents: whether to include DAG dependents for the next wave\n  // - excludeForEachDependents: when true, filter out dependents that are forEach parents\n  private forwardIncludeDependents: Map<string, boolean> = new Map();\n  private forwardExcludeForEachDependents: Map<string, boolean> = new Map();\n  // Marker for grouped wave rescheduling when on_fail forward-run occurred\n  private onFailForwardRunSeen: boolean = false;\n  // Marker for grouped wave rescheduling when on_finish routing occurred\n  private onFinishForwardRunSeen: boolean = false;\n  // Track per-grouped-run scheduling of specific steps we want to allow only once.\n  // Currently used to ensure 'validate-fact' is scheduled at most once per stage.\n  private oncePerRunScheduleGuards: Set<string> = new Set();\n  // Suppress on_success.goto for checks that are re-run only to satisfy\n  // dependency requirements in a forward-run planned wave\n  private gotoSuppressedChecks: Set<string> = new Set();\n  // Event override to simulate alternate event (used during routing goto)\n  private routingEventOverride?: import('./types/config').EventTrigger;\n  // Execution context for providers (CLI message, hooks, etc.)\n  private executionContext?: import('./providers/check-provider.interface').ExecutionContext;\n  // Cached GitHub context for context elevation when running in Actions\n  private actionContext?: {\n    owner: string;\n    repo: string;\n    octokit?: import('@octokit/rest').Octokit;\n  };\n\n  constructor(workingDirectory?: string, octokit?: import('@octokit/rest').Octokit) {\n    this.workingDirectory = workingDirectory || process.cwd();\n    this.gitAnalyzer = new GitRepositoryAnalyzer(this.workingDirectory);\n    this.providerRegistry = CheckProviderRegistry.getInstance();\n    this.failureEvaluator = new FailureConditionEvaluator();\n\n    // If authenticated octokit is provided, cache it for provider use\n    if (octokit) {\n      const repoEnv = process.env.GITHUB_REPOSITORY || '';\n      const [owner, repo] = repoEnv.split('/') as [string, string];\n      if (owner && repo) {\n        this.actionContext = { owner, repo, octokit };\n      }\n    }\n\n    // Create a mock Octokit instance for local analysis\n    // This allows us to reuse the existing PRReviewer logic without network calls\n    this.mockOctokit = this.createMockOctokit();\n    // Prefer the provided authenticated/recording Octokit (from test runner or Actions)\n    // so that comment create/update operations are visible to recorders and assertions.\n    const reviewerOctokit =\n      (octokit as unknown as import('@octokit/rest').Octokit) ||\n      (this.mockOctokit as unknown as import('@octokit/rest').Octokit);\n    this.reviewer = new PRReviewer(reviewerOctokit);\n  }\n\n  private sessionUUID(): string {\n    return this.sessionId;\n  }\n\n  /**\n   * Reset per-run guard and statistics state. Callers that orchestrate grouped\n   * executions (e.g., the YAML test runner) can invoke this to ensure clean\n   * stage-local accounting without introducing test-specific branches in the\n   * core engine.\n   */\n  public resetPerRunState(): void {\n    try {\n      this.forwardRunGuards.clear();\n    } catch {}\n    try {\n      this.oncePerRunScheduleGuards.clear();\n    } catch {}\n    try {\n      this.onFinishLoopCounts.clear();\n      this.forEachWaveCounts.clear();\n    } catch {}\n    try {\n      // Fully reset stage-scoped state so flows don't leak across stages.\n      this['executionStats'].clear();\n      // Clear outputs history at the start of each grouped run to ensure\n      // per-stage coverage is isolated in flows. Intra-stage waves still\n      // have access to history because it accumulates during the run.\n      this.outputHistory.clear();\n      this.postOnFinishGuards.clear();\n      this.forwardDependentsScheduled.clear();\n      this.forwardIncludeDependents.clear();\n      this.gotoSuppressedChecks.clear();\n      this.forwardExcludeForEachDependents.clear();\n      this.runCounters.clear();\n      this.routingEventOverride = undefined;\n      // Start a fresh journal for snapshot-based dependency views\n      this.journal = new (require('./snapshot-store').ExecutionJournal)();\n    } catch {}\n  }\n\n  /** Build a stable key for counting executions per check and per scope (forEach items separated). */\n  private buildRunKey(checkId: string, scope?: ScopePath): string {\n    if (!scope || scope.length === 0) return checkId;\n    try {\n      const parts = scope.map(s => `${s.check}:${s.index}`);\n      return `${checkId}@${parts.join('/')}`;\n    } catch {\n      return checkId;\n    }\n  }\n\n  /** Resolve effective max runs for a check (step override > global default). */\n  private resolveMaxRuns(config: VisorConfig, checkId: string): number {\n    try {\n      const steps = (config.checks || (config as any).steps || {}) as Record<\n        string,\n        import('./types/config').CheckConfig\n      >;\n      const step = steps[checkId];\n      const perStep = (step as any)?.max_runs;\n      if (typeof perStep === 'number') return perStep;\n      // Default: cap forEach parents to 1 execution per grouped run unless overridden\n      if (step && step.forEach === true) return 1;\n    } catch {}\n    const global = (config.limits && (config.limits as any).max_runs_per_check) ?? 50;\n    return typeof global === 'number' && global > 0 ? Math.floor(global) : 50;\n  }\n\n  private commitJournal(\n    checkId: string,\n    result: ExtendedReviewSummary,\n    event?: import('./types/config').EventTrigger,\n    scopeOverride?: ScopePath\n  ): void {\n    try {\n      const scope: ScopePath = scopeOverride || [];\n      this.journal.commitEntry({\n        sessionId: this.sessionUUID(),\n        scope,\n        checkId,\n        event,\n        result,\n      });\n    } catch {\n      // best effort; never throw\n    }\n  }\n\n  /** Build dependencyResults from a snapshot of all committed results, optionally overlaying provided results. */\n  private buildSnapshotDependencyResults(\n    scope: ScopePath,\n    overlay: Map<string, ReviewSummary> | undefined,\n    event: import('./types/config').EventTrigger | undefined\n  ): Map<string, ReviewSummary> {\n    const snap = this.journal.beginSnapshot();\n    const view = new ContextView(this.journal, this.sessionUUID(), snap, scope, event);\n    const visible = new Map<string, ReviewSummary>();\n    try {\n      const entries = this.journal.readVisible(this.sessionUUID(), snap, event);\n      const ids = Array.from(new Set(entries.map(e => e.checkId)));\n      for (const id of ids) {\n        const v = view.get(id);\n        if (v) visible.set(id, v);\n        const raw = view.getRaw(id);\n        if (raw) visible.set(`${id}-raw`, raw);\n      }\n      // Overlay any provided results (e.g., per-item context) on top.\n      // Root-cause hardening: ignore non-string keys and log once.\n      if (overlay) {\n        for (const [k, v] of overlay.entries()) {\n          if (typeof k === 'string' && k) {\n            visible.set(k, v);\n          } else {\n            try {\n              require('./logger').logger.warn(\n                `sanitize: dropping non-string overlay key type=${typeof k}`\n              );\n            } catch {}\n          }\n        }\n      }\n    } catch {}\n    return visible;\n  }\n\n  /** Drop any non-string keys from a results-like map (root-cause guard). */\n  private sanitizeResultMapKeys(\n    m: Map<unknown, ReviewSummary> | undefined\n  ): Map<string, ReviewSummary> {\n    const out = new Map<string, ReviewSummary>();\n    if (!m) return out;\n    for (const [k, v] of m.entries()) {\n      if (typeof k === 'string' && k) out.set(k, v);\n      else {\n        try {\n          require('./logger').logger.warn(\n            `sanitize: dropping non-string results key type=${typeof k}`\n          );\n        } catch {}\n      }\n    }\n    return out;\n  }\n\n  /**\n   * Enrich event context with authenticated octokit instance\n   * @param eventContext - The event context to enrich\n   * @returns Enriched event context with octokit if available\n   */\n  private enrichEventContext(eventContext?: Record<string, unknown>): Record<string, unknown> {\n    const baseContext = eventContext || {};\n    const injected = this.actionContext?.octokit || (baseContext as any).octokit;\n    if (injected) {\n      return { ...baseContext, octokit: injected };\n    }\n    return baseContext;\n  }\n\n  /**\n   * Schedule a forward-run starting from `target` and continuing through all\n   * transitive dependents that declare a dependency (direct or indirect) on\n   * `target`. Execution honors optional `gotoEvent` by filtering dependents to\n   * only those steps whose `on` includes that event. The `target` itself is\n   * always executed first regardless of event filtering.\n   *\n   * This helper is used for goto across all origins (on_success, on_fail,\n   * on_finish) to ensure consistent semantics and avoid duplicating logic.\n   */\n  private async scheduleForwardRun(\n    target: string,\n    opts: {\n      origin: 'on_success' | 'on_fail' | 'on_finish' | 'inline';\n      gotoEvent?: import('./types/config').EventTrigger;\n      config: VisorConfig;\n      dependencyGraph: DependencyGraph;\n      prInfo: PRInfo;\n      resultsMap: Map<string, ReviewSummary>;\n      debug: boolean;\n      // When executing inside a forEach item, pass the scope for that item\n      foreachScope?: ScopePath;\n      // If not in a forEach item, but the source step was a map, we may need the\n      // source identity and items to produce per-item scopes.\n      sourceCheckName?: string;\n      sourceCheckConfig?: CheckConfig;\n      sourceOutputForItems?: unknown;\n    }\n  ): Promise<void> {\n    const {\n      origin,\n      gotoEvent,\n      config,\n      dependencyGraph,\n      prInfo,\n      resultsMap,\n      debug,\n      foreachScope,\n      sourceCheckName,\n      sourceCheckConfig,\n      sourceOutputForItems,\n    } = opts;\n\n    const cfgChecks = (config?.checks || {}) as Record<\n      string,\n      import('./types/config').CheckConfig\n    >;\n    if (!cfgChecks[target]) return;\n\n    // Build forward closure (target + transitive dependents of target)\n    const forwardSet = new Set<string>([target]);\n    const dependsOn = (name: string, root: string): boolean => {\n      const seen = new Set<string>();\n      const dfs = (n: string): boolean => {\n        if (seen.has(n)) return false;\n        seen.add(n);\n        const deps = cfgChecks[n]?.depends_on || [];\n        if (deps.includes(root)) return true;\n        return deps.some(d => dfs(d));\n      };\n      return dfs(name);\n    };\n    const ev = gotoEvent || prInfo.eventType || 'manual';\n    for (const name of Object.keys(cfgChecks)) {\n      if (name === target) continue;\n      const onArr = cfgChecks[name]?.on as any;\n      const eventMatches = !onArr || (Array.isArray(onArr) && onArr.includes(ev));\n      if (!eventMatches) continue;\n      if (dependsOn(name, target)) forwardSet.add(name);\n    }\n\n    // Topologically order the subset to run target before dependents respecting depends_on\n    const order: string[] = [];\n    const inSet = (n: string) => forwardSet.has(n);\n    const tempMarks = new Set<string>();\n    const permMarks = new Set<string>();\n    const stack: string[] = [];\n    const visit = (n: string) => {\n      if (permMarks.has(n)) return;\n      if (tempMarks.has(n)) {\n        const idx = stack.indexOf(n);\n        const cyclePath = idx >= 0 ? [...stack.slice(idx), n] : [n];\n        throw new Error(\n          `Cycle detected in forward-run dependency subset: ${cyclePath.join(' -> ')}`\n        );\n      }\n      tempMarks.add(n);\n      stack.push(n);\n      const deps = (cfgChecks[n]?.depends_on || []).filter(inSet);\n      for (const d of deps) visit(d);\n      stack.pop();\n      tempMarks.delete(n);\n      permMarks.add(n);\n      order.push(n);\n    };\n    for (const n of forwardSet) visit(n);\n\n    // Revert dependent auto-forwarding for correction cycles:\n    // - For origin on_fail/on_finish we only schedule the target and let the DAG\n    //   naturally execute dependents in the next wave. This avoids duplicate\n    //   inline runs of dependents (especially forEach dependents) and restores\n    //   stable execution counts expected by tests.\n    if (origin === 'on_fail' || origin === 'on_finish') {\n      order.splice(0, order.length, target);\n    }\n\n    const prevEventOverride = this.routingEventOverride;\n    // Ensure we only execute the target once per grouped run for a given event\n    const evKey = gotoEvent || prInfo.eventType || 'manual';\n    const guardKey = `${String(evKey)}:${String(target)}`;\n    const runTargetOnce = async (\n      scopeForRun: ScopePath,\n      guard: boolean\n    ): Promise<ReviewSummary | undefined> => {\n      // When guard=true we dedupe within a grouped run; when false we allow\n      // multiple re-executions (e.g., on_finish correction waves).\n      if (guard) {\n        if (this.forwardRunGuards.has(guardKey)) {\n          // Allow re-run if the last recorded result for target was fatal and the\n          // target did not opt into continue_on_failure (we need another attempt).\n          try {\n            const prior = resultsMap.get(target);\n            let hadFatal = prior && Array.isArray(prior.issues) && this.hasFatal(prior.issues);\n            const tcfgCont = (cfgChecks[target] as any)?.continue_on_failure === true;\n            if (tcfgCont) hadFatal = false;\n            if (!hadFatal) return undefined;\n          } catch {\n            return undefined;\n          }\n        }\n        this.forwardRunGuards.add(guardKey);\n      }\n      const res = await this.runNamedCheck(target, scopeForRun, {\n        origin,\n        config,\n        dependencyGraph,\n        prInfo,\n        resultsMap,\n        debug,\n        eventOverride: gotoEvent,\n      });\n      // Ensure resultsMap reflects the freshest result for gating\n      try {\n        resultsMap.set(target, res);\n      } catch {}\n      // Mark target as forward-scheduled AFTER inline execution so grouped\n      // runner can skip duplicates in subsequent waves without blocking inline.\n      try {\n        this.addForwardTarget(target, scopeForRun);\n        if (gotoEvent) this.forwardEventOverrides.set(target, gotoEvent);\n      } catch {}\n      return res;\n    };\n\n    // Decide whether to dedupe target in this grouped run.\n    // For on_finish correction waves we allow re-execution of the target.\n    // Additionally, respect a 'repeatable' tag on the target step which\n    // explicitly opts the step into re-execution within the same event/wave\n    // (useful for chat-style loops driven by fail_if + on_fail/on_success).\n    // Allow re-running the target within the same grouped run when routing originates from on_fail.\n    // This enables explicit correction loops without any special tags.\n    const guardTargetOnce = origin !== 'on_finish' && origin !== 'on_fail';\n    try {\n      if (origin === 'on_fail') {\n        (this as any).onFailForwardRunSeen = true;\n        if (debug)\n          (config?.output?.pr_comment ? console.error : console.log)(\n            'üîÅ Debug: on_fail forward-run seen; flag set'\n          );\n      }\n    } catch {}\n\n    if (gotoEvent) this.routingEventOverride = gotoEvent;\n\n    // Unified forward-run semantics header\n\n    // Do not execute target inline for on_fail-originated routing.\n    // Mark that a correction wave is needed; enqueue ONLY the target and allow\n    // the DAG to execute dependents in the next wave. This preserves\n    // dependency gating semantics (e.g., confirm-interpret ‚Üí run-commands).\n    if (origin === 'on_fail') {\n      try {\n        // Only mark the target for forward scheduling. Let the DAG naturally\n        // re-run transitive dependents in the next wave to preserve dependency\n        // gating semantics.\n        this.addForwardTarget(target, foreachScope);\n        this.forwardIncludeDependents.set(target, true);\n        const dependentsOnly = order.filter(n => n !== target);\n        const fwd = Array.from(forwardSet || []).join(', ');\n        const deps = dependentsOnly.join(', ');\n        (config?.output?.pr_comment ? console.error : console.log)(\n          `üîß Debug: on_fail forward-set=[${fwd}] dependents=[${deps}]`\n        );\n      } catch {}\n      (this as any).onFailForwardRunSeen = true;\n      return; // defer to next wave\n    }\n    // on_finish: schedule target for the next wave and return.\n    if (origin === 'on_finish') {\n      try {\n        this.addForwardTarget(target, foreachScope);\n        if (gotoEvent) this.forwardEventOverrides.set(target, gotoEvent);\n        // For on_finish correction waves, include non-forEach dependents only\n        // so lightweight actions (e.g., label application) can run again\n        // while heavy per-item validators are excluded.\n        this.forwardIncludeDependents.set(target, true);\n        this.forwardExcludeForEachDependents.set(target, true);\n      } catch {}\n      (this as any).onFinishForwardRunSeen = true;\n      return; // defer to next wave\n    }\n    // on_success: if dependencies of the routed target are already available,\n    // execute it inline now and do NOT schedule a new wave. Otherwise, schedule\n    // the target for the next wave and return.\n    if (origin === 'on_success') {\n      try {\n        this.addForwardTarget(target, foreachScope);\n      } catch {}\n      if (gotoEvent) this.forwardEventOverrides.set(target, gotoEvent);\n      try {\n        (this as any).onSuccessForwardRunSeen = true;\n      } catch {}\n      return;\n    }\n    try {\n      // Determine mapping mode for the target step\n      const tcfg = cfgChecks[target];\n      const mode =\n        tcfg?.fanout === 'map' ? 'map' : tcfg?.reduce ? 'reduce' : tcfg?.fanout || 'default';\n\n      const items = foreachScope\n        ? []\n        : sourceCheckConfig?.forEach && Array.isArray(sourceOutputForItems)\n          ? (sourceOutputForItems as unknown[])\n          : [];\n\n      let lastTargetHadFatal: boolean | undefined = undefined;\n      const runChainOnce = async (scopeForRun: ScopePath) => {\n        const tResMaybe = await runTargetOnce(scopeForRun, /*guard*/ guardTargetOnce);\n        const tRes = tResMaybe || resultsMap.get(target);\n        // If the target is a forEach parent, its dependents are executed per-item\n        // inside executeCheckInline. Avoid scheduling them again here to prevent\n        // an extra aggregated run (e.g., validate-fact √ó1 in addition to per-item runs).\n        const tcfgNow = cfgChecks[target];\n        const targetIsForEachParent = !!tcfgNow?.forEach;\n        if (targetIsForEachParent) return;\n        // If target failed, do not run any dependents in this forward-run wave\n        try {\n          if (debug) {\n            const ids = Array.isArray(tRes?.issues)\n              ? (tRes!.issues as any[]).map(i => i.ruleId).join(',')\n              : 'none';\n            (config?.output?.pr_comment ? console.error : console.log)(\n              `üîß Debug: forward-run: target '${target}' issues=[${ids}]`\n            );\n          }\n          // Treat skipped targets as non-executed for the purposes of forward-run.\n          // If a target was skipped (e.g., event mismatch), do NOT schedule dependents\n          // because prerequisites/side-effects didn't run.\n          const wasSkipped = Array.isArray(tRes?.issues)\n            ? (tRes!.issues as any[]).some(i => (i.ruleId || '').endsWith('/__skipped'))\n            : false;\n          if (wasSkipped) {\n            if (debug)\n              (config?.output?.pr_comment ? console.error : console.log)(\n                `üîß Debug: forward-run: target '${target}' skipped ‚Äî not running dependents`\n              );\n            return;\n          }\n\n          let hadFatal = tRes && Array.isArray(tRes.issues) && this.hasFatal(tRes.issues);\n          lastTargetHadFatal = hadFatal;\n          // Respect continue_on_failure on the target: allow dependents even when fatal\n          try {\n            const tcfgCont = (cfgChecks[target] as any)?.continue_on_failure === true;\n            if (tcfgCont) hadFatal = false;\n          } catch {}\n          if (hadFatal) {\n            if (debug)\n              (config?.output?.pr_comment ? console.error : console.log)(\n                `üîß Debug: forward-run: target '${target}' failed ‚Äî skipping dependents`\n              );\n            return;\n          }\n        } catch {}\n        // Do not inline-run dependents for forward-run; DAG handles subsequent steps in next wave\n        try {\n          /* intentionally no-op */\n        } catch {}\n      };\n\n      if (foreachScope && foreachScope.length > 0) {\n        await runChainOnce(foreachScope);\n      } else if (mode === 'map' && items.length > 0 && sourceCheckName) {\n        for (let i = 0; i < items.length; i++) {\n          const itemScope: ScopePath = [{ check: sourceCheckName, index: i }];\n          await runChainOnce(itemScope);\n        }\n      } else {\n        await runChainOnce([]);\n      }\n\n      // For on_fail-originated forward runs we already early-returned above.\n\n      // In test/grouped mode, rely on the DAG and per-level execution; avoid\n      // following static on_success.goto chains to prevent duplicate executions\n      // of steps that are already scheduled by the plan.\n      // Static goto chaining below applies regardless of origin; tests rely on wave scheduling.\n\n      // Follow explicit on_success.goto edges from the target, if present,\n      // to naturally support anchor-style chains (e.g., refine ‚Üí write ‚Üí validate ‚Üí test).\n      // Only follow when the target succeeded (no fatal issues post fail_if evaluation).\n      // We intentionally do not evaluate goto_js here to keep this deterministic\n      // in routing, but we do honor static goto + goto_event.\n      // Follow static goto chains with configurable hop budget and cycle detection\n      const maxHops = config?.routing?.max_loops ?? 10;\n      let hopCount = 0;\n      const visited = new Set<string>();\n      // Success check: if target produced fatal issues, skip static goto chaining\n      try {\n        const dbg = (msg: string) =>\n          (config?.output?.pr_comment ? console.error : console.log)(msg);\n        // Prefer the immediate result from runChainOnce if available\n        let hadFatal = typeof lastTargetHadFatal === 'boolean' ? lastTargetHadFatal : false;\n        if (typeof lastTargetHadFatal !== 'boolean') {\n          const tRes = resultsMap.get(target);\n          hadFatal = !!(tRes && Array.isArray(tRes.issues) && this.hasFatal(tRes.issues));\n        }\n        if (hadFatal) {\n          if (debug)\n            dbg(\n              `üîß Debug: forward-run: skipping on_success.goto chain for '${target}' due to fatal issues`\n            );\n          return; // do not follow chain from a failed target\n        }\n      } catch {}\n\n      let current: string | undefined = (\n        cfgChecks[target]?.on_success as OnSuccessConfig | undefined\n      )?.goto;\n      while (current && hopCount < maxHops) {\n        if (visited.has(current)) {\n          try {\n            logger.warn(\n              `‚ö†Ô∏è forward-run: detected goto cycle at '${current}' after ${hopCount} hop(s); aborting chain`\n            );\n          } catch {}\n\n          break;\n        }\n        visited.add(current);\n        const nextOnSuccess = (cfgChecks[current]?.on_success as OnSuccessConfig | undefined) || {};\n        const nextEvent = nextOnSuccess.goto_event || gotoEvent;\n        await this.scheduleForwardRun(current, {\n          origin: 'on_success',\n          gotoEvent: nextEvent,\n          config,\n          dependencyGraph,\n          prInfo,\n          resultsMap,\n          debug,\n          foreachScope,\n          sourceCheckName,\n          sourceCheckConfig,\n          sourceOutputForItems,\n        });\n        hopCount++;\n        // advance chain if there is a further goto from the just-executed step\n        current = (cfgChecks[current]?.on_success as OnSuccessConfig | undefined)?.goto;\n      }\n      if (hopCount >= maxHops && current) {\n        try {\n          logger.warn(\n            `‚ö†Ô∏è forward-run: hop budget exceeded (max_loops=${maxHops}); last unresolved goto='${current}'`\n          );\n        } catch {}\n      }\n    } finally {\n      this.routingEventOverride = prevEventOverride;\n    }\n  }\n\n  /**\n   * Set execution context for providers (CLI message, hooks, etc.)\n   * This allows passing state without using static properties\n   */\n  setExecutionContext(\n    context: import('./providers/check-provider.interface').ExecutionContext\n  ): void {\n    this.executionContext = context;\n  }\n\n  /**\n   * Lazily create a secure sandbox for routing JS (goto_js, run_js)\n   */\n  private getRoutingSandbox(): Sandbox {\n    if (this.routingSandbox) return this.routingSandbox;\n    this.routingSandbox = createSecureSandbox();\n    return this.routingSandbox;\n  }\n\n  // Evaluate goto target from optional goto_js or static goto using a minimal scope\n  private async evaluateGotoTarget(\n    goto_js: string | undefined,\n    gotoStatic: string | undefined,\n    scope: { step: any; outputs: any; output: any; event: any },\n    debug?: boolean,\n    log?: (msg: string) => void\n  ): Promise<string | null> {\n    if (goto_js) {\n      try {\n        const sandbox = this.getRoutingSandbox();\n        const code = `const step=scope.step; const outputs=scope.outputs; const output=scope.output; const event=scope.event; ${goto_js}`;\n        const exec = sandbox.compile(code);\n        const res = exec({ scope }).run();\n        if (debug) log && log(`üîß Debug: goto_js evaluated ‚Üí ${this.redact(res)}`);\n        return typeof res === 'string' && res ? String(res) : null;\n      } catch (e) {\n        if (debug)\n          log &&\n            log(\n              `‚ö†Ô∏è Debug: goto_js evaluation failed: ${e instanceof Error ? e.message : String(e)}`\n            );\n        // fall through to static\n      }\n    }\n    return gotoStatic ? String(gotoStatic) : null;\n  }\n\n  // Schedule routing to a specific target using scheduleForwardRun with the given origin\n  private async scheduleGoto(\n    origin: 'on_success' | 'on_fail' | 'on_finish',\n    target: string,\n    gotoEvent: import('./types/config').EventTrigger | undefined,\n    sourceCheckName: string,\n    sourceCheckConfig: import('./types/config').CheckConfig,\n    foreachScope: ScopePath | undefined,\n    config: VisorConfig,\n    dependencyGraph: DependencyGraph,\n    prInfo: PRInfo,\n    resultsMap: Map<string, ReviewSummary>,\n    debug?: boolean\n  ): Promise<void> {\n    await this.scheduleForwardRun(target, {\n      origin,\n      gotoEvent,\n      config,\n      dependencyGraph,\n      prInfo,\n      resultsMap,\n      debug: debug || false,\n      foreachScope: foreachScope || [],\n      sourceCheckName,\n      sourceCheckConfig,\n    });\n  }\n\n  private redact(str: unknown, limit = 200): string {\n    try {\n      const s = typeof str === 'string' ? str : JSON.stringify(str);\n      return s.length > limit ? s.slice(0, limit) + '‚Ä¶' : s;\n    } catch {\n      return String(str).slice(0, limit);\n    }\n  }\n\n  private async sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  private deterministicJitter(baseMs: number, seedStr: string): number {\n    let h = 2166136261;\n    for (let i = 0; i < seedStr.length; i++) h = (h ^ seedStr.charCodeAt(i)) * 16777619;\n    const frac = ((h >>> 0) % 1000) / 1000; // 0..1\n    return Math.floor(baseMs * 0.15 * frac); // up to 15% jitter\n  }\n\n  /** Add a forward-run target with an optional item scope (forEach). */\n  private addForwardTarget(target: string, scope?: ScopePath): void {\n    try {\n      const key = JSON.stringify(scope && scope.length > 0 ? scope : []);\n      let set = this.forwardDependentsScheduled.get(target);\n      if (!set) {\n        set = new Set<string>();\n        this.forwardDependentsScheduled.set(target, set);\n      }\n      set.add(key);\n    } catch {}\n  }\n\n  // === on_finish helpers (extracted to reduce handleOnFinishHooks complexity) ===\n  private composeOnFinishContext(\n    checkName: string,\n    checkConfig: import('./types/config').CheckConfig,\n    outputsForContext: Record<string, unknown>,\n    outputsHistoryForContext: Record<string, unknown[]>,\n    forEachStats: any,\n    prInfo: PRInfo\n  ): {\n    step: { id: string; tags: string[]; group?: string };\n    attempt: number;\n    loop: number;\n    outputs: Record<string, unknown>;\n    outputs_history: Record<string, unknown[]>;\n    outputs_raw: Record<string, unknown>;\n    forEach: any;\n    memory: {\n      get: (key: string, ns?: string) => unknown;\n      has: (key: string, ns?: string) => boolean;\n      list: (ns?: string) => string[];\n      getAll: (ns?: string) => Record<string, unknown>;\n      set: (key: string, value: unknown, ns?: string) => void;\n      increment: (key: string, amount: number, ns?: string) => number;\n    };\n    pr: { number: number; title: string; author: string; branch: string; base: string };\n    files: PRInfo['files'];\n    env: Record<string, string>;\n    event: { name: string };\n  } {\n    const memoryStore = MemoryStore.getInstance(this.config?.memory);\n    const memoryHelpers = {\n      get: (key: string, ns?: string) => memoryStore.get(key, ns),\n      has: (key: string, ns?: string) => memoryStore.has(key, ns),\n      list: (ns?: string) => memoryStore.list(ns),\n      getAll: (ns?: string) => {\n        const keys = memoryStore.list(ns);\n        const result: Record<string, unknown> = {};\n        for (const key of keys) result[key] = memoryStore.get(key, ns);\n        return result;\n      },\n      set: (key: string, value: unknown, ns?: string) => {\n        const nsName = ns || memoryStore.getDefaultNamespace();\n        if (!memoryStore['data'].has(nsName)) memoryStore['data'].set(nsName, new Map());\n        memoryStore['data'].get(nsName)!.set(key, value);\n      },\n      increment: (key: string, amount: number, ns?: string) => {\n        const current = memoryStore.get(key, ns);\n        const numCurrent = typeof current === 'number' ? current : 0;\n        const newValue = numCurrent + amount;\n        const nsName = ns || memoryStore.getDefaultNamespace();\n        if (!memoryStore['data'].has(nsName)) memoryStore['data'].set(nsName, new Map());\n        memoryStore['data'].get(nsName)!.set(key, newValue);\n        return newValue;\n      },\n    };\n    const outputsRawForContext: Record<string, unknown> = {};\n    for (const [name, val] of Object.entries(outputsForContext)) {\n      if (name === 'history') continue;\n      outputsRawForContext[name] = val;\n    }\n    const outputsMergedForContext: Record<string, unknown> = {\n      ...outputsForContext,\n      history: outputsHistoryForContext,\n    };\n    return {\n      step: { id: checkName, tags: checkConfig.tags || [], group: checkConfig.group },\n      attempt: 1,\n      loop: 0,\n      outputs: outputsMergedForContext,\n      outputs_history: outputsHistoryForContext,\n      outputs_raw: outputsRawForContext,\n      forEach: forEachStats,\n      memory: memoryHelpers,\n      pr: {\n        number: prInfo.number,\n        title: prInfo.title,\n        author: prInfo.author,\n        branch: prInfo.head,\n        base: prInfo.base,\n      },\n      files: prInfo.files,\n      env: getSafeEnvironmentVariables(),\n      event: { name: prInfo.eventType || 'manual' },\n    };\n  }\n\n  private evaluateOnFinishGoto(\n    checkName: string,\n    onFinish: NonNullable<import('./types/config').CheckConfig['on_finish']>,\n    onFinishContext: any,\n    debug: boolean,\n    log: (msg: string) => void\n  ): string | null {\n    let gotoTarget: string | null = null;\n    if (onFinish.goto_js) {\n      logger.info(`‚ñ∂ on_finish.goto_js: evaluating for \"${checkName}\"`);\n      try {\n        const sandbox = this.getRoutingSandbox();\n        const scope = onFinishContext;\n        const code = `\n          const step = scope.step; const attempt = scope.attempt; const loop = scope.loop; const outputs = scope.outputs; const outputs_history = scope.outputs_history; const outputs_raw = scope.outputs_raw; const forEach = scope.forEach; const memory = scope.memory; const pr = scope.pr; const files = scope.files; const env = scope.env; const event = scope.event; const log = (...a)=> console.log('üîç Debug:',...a);\n          const __fn = () => {\\n${onFinish.goto_js}\\n};\n          const __res = __fn();\n          return (typeof __res === 'string' && __res) ? __res : null;\n        `;\n        const exec = sandbox.compile(code);\n        const result = exec({ scope }).run();\n        gotoTarget = typeof result === 'string' && result ? result : null;\n        if (debug) log(`üîß Debug: on_finish.goto_js evaluated ‚Üí ${this.redact(gotoTarget)}`);\n        logger.info(\n          `‚úì on_finish.goto_js: evaluated to '${gotoTarget || 'null'}' for \"${checkName}\"`\n        );\n      } catch (error) {\n        const errorMsg = error instanceof Error ? error.message : String(error);\n        logger.warn(`‚ö†Ô∏è on_finish.goto_js: evaluation failed for \"${checkName}\": ${errorMsg}`);\n        if (error instanceof Error && error.stack) logger.debug(`Stack trace: ${error.stack}`);\n        if (onFinish.goto) {\n          logger.info(`  ‚ö† Falling back to static goto: '${onFinish.goto}'`);\n          gotoTarget = onFinish.goto;\n        }\n      }\n    } else if (onFinish.goto) {\n      gotoTarget = onFinish.goto;\n      logger.info(`‚ñ∂ on_finish.goto: routing to '${gotoTarget}' for \"${checkName}\"`);\n    }\n    return gotoTarget;\n  }\n\n  private computeBackoffDelay(\n    attempt: number,\n    mode: 'fixed' | 'exponential',\n    baseMs: number,\n    seed: string\n  ): number {\n    const jitter = this.deterministicJitter(baseMs, seed);\n    if (mode === 'exponential') {\n      return baseMs * Math.pow(2, Math.max(0, attempt - 1)) + jitter;\n    }\n    return baseMs + jitter;\n  }\n\n  /**\n   * Execute a single named check inline (used by routing logic and on_finish)\n   * This is extracted from executeWithRouting to be reusable\n   */\n  private async executeCheckInline(\n    checkId: string,\n    event: import('./types/config').EventTrigger,\n    context: {\n      config: VisorConfig;\n      dependencyGraph: DependencyGraph;\n      prInfo: PRInfo;\n      resultsMap: Map<string, ReviewSummary>;\n      dependencyResults: Map<string, ReviewSummary>;\n      sessionInfo?: { parentSessionId?: string; reuseSession?: boolean };\n      debug: boolean;\n      eventOverride?: import('./types/config').EventTrigger;\n      scope?: ScopePath;\n      origin?: 'on_finish' | 'on_success' | 'on_fail' | 'foreach' | 'initial' | 'inline';\n    }\n  ): Promise<ReviewSummary> {\n    const {\n      config,\n      prInfo,\n      resultsMap,\n      dependencyResults,\n      sessionInfo,\n      debug,\n      eventOverride,\n      scope,\n    } = context;\n    const log = (msg: string) => (config?.output?.pr_comment ? console.error : console.log)(msg);\n    const origin = (context as any).origin || 'inline';\n\n    // Find the check configuration\n    const checkConfig = config?.checks?.[checkId];\n    if (!checkConfig) {\n      try {\n        const msg = `[on_finish] referenced unknown check '${checkId}', ignoring`;\n        (config?.output?.pr_comment ? console.error : console.log)(msg);\n      } catch {}\n      return { issues: [] };\n    }\n\n    // Respect event triggers when executing dependencies inline.\n    // If the check is not configured to run for the current event, skip executing it here.\n    try {\n      const triggers = Array.isArray(checkConfig.on) ? (checkConfig.on as string[]) : [];\n      if (triggers.length > 0) {\n        const evt = eventOverride || event || this.getCurrentEventType(prInfo);\n        const allowed = triggers.includes(evt as any);\n        if (!allowed) {\n          // Special case: manual-only checks are not auto-executed inline\n          const manualOnly = triggers.length === 1 && triggers[0] === 'manual';\n          if (manualOnly || !allowed) {\n            try {\n              const msg = `üîß Debug: Skipping inline execution of '${checkId}' for event '${evt}' (triggers=${JSON.stringify(\n                triggers\n              )})`;\n              (config?.output?.pr_comment ? console.error : console.log)(msg);\n            } catch {}\n            return { issues: [] };\n          }\n        }\n      }\n    } catch {}\n\n    // Helper to get all dependencies recursively from config, expanding OR-groups (\"a|b\")\n    const getAllDepsFromConfig = (name: string): string[] => {\n      const visited = new Set<string>();\n      const acc: string[] = [];\n      const expand = (t: unknown): string[] => {\n        const s = String(t ?? '').trim();\n        if (!s) return [];\n        if (s.includes('|'))\n          return s\n            .split('|')\n            .map(x => x.trim())\n            .filter(Boolean);\n        return [s];\n      };\n      const dfs = (n: string) => {\n        if (visited.has(n)) return;\n        visited.add(n);\n        const cfg = config?.checks?.[n];\n        const depsRaw = cfg?.depends_on || [];\n        for (const token of depsRaw) {\n          const expanded = expand(token);\n          for (const d of expanded) {\n            // Only accumulate known checks; ignore unknown OR branches\n            if (!config?.checks?.[d]) continue;\n            acc.push(d);\n            dfs(d);\n          }\n        }\n      };\n      dfs(name);\n      return Array.from(new Set(acc));\n    };\n\n    // Ensure all dependencies of target are available; execute missing ones in topological order\n    const allTargetDeps = getAllDepsFromConfig(checkId);\n    if (allTargetDeps.length > 0) {\n      // Build subgraph mapping for ordered execution\n      const subSet = new Set<string>(\n        [...allTargetDeps].filter(id => Boolean(config?.checks?.[id]))\n      );\n      const subDeps: Record<string, string[]> = {};\n      for (const id of subSet) {\n        const cfg = config?.checks?.[id];\n        const raw = cfg?.depends_on || [];\n        const expanded: string[] = [];\n        for (const token of raw) {\n          const parts = String(token ?? '')\n            .split('|')\n            .map(s => s.trim())\n            .filter(Boolean);\n          if (parts.length === 0) continue;\n          for (const p of parts) if (subSet.has(p)) expanded.push(p);\n        }\n        subDeps[id] = expanded;\n      }\n      const subGraph = DependencyResolver.buildDependencyGraph(subDeps);\n      for (const group of subGraph.executionOrder) {\n        for (const depId of group.parallel) {\n          // Skip if already have results\n          if (resultsMap?.has(depId) || dependencyResults.has(depId)) continue;\n          // Execute dependency inline (recursively ensures its deps are also present)\n          await this.executeCheckInline(depId, event, context);\n        }\n      }\n    }\n\n    // No legacy adapters; use configuration as-is\n    const adaptedConfig: any = { ...checkConfig };\n    const providerType = adaptedConfig.type || 'ai';\n    const provider = this.providerRegistry.getProviderOrThrow(providerType);\n    this.setProviderWebhookContext(provider);\n\n    // Build provider configuration\n    const provCfg: CheckProviderConfig = {\n      type: providerType,\n      prompt: adaptedConfig.prompt,\n      exec: adaptedConfig.exec,\n      focus: adaptedConfig.focus || this.mapCheckNameToFocus(checkId),\n      schema: adaptedConfig.schema,\n      group: adaptedConfig.group,\n      checkName: checkId,\n      eventContext: this.enrichEventContext(prInfo.eventContext),\n      transform: adaptedConfig.transform,\n      transform_js: adaptedConfig.transform_js,\n      env: adaptedConfig.env,\n      forEach: adaptedConfig.forEach,\n      // Pass output history for loop/goto scenarios\n      __outputHistory: this.outputHistory,\n      // no enriched history exposure; standard outputs_history only\n      // Include provider-specific keys (e.g., op/values for github)\n      ...adaptedConfig,\n      ai: {\n        ...(adaptedConfig.ai || {}),\n        timeout: adaptedConfig.ai?.timeout || 600000,\n        debug: !!debug,\n      },\n    };\n\n    // Build dependency results for this check using snapshot-based visibility (overlay per-scope results)\n    const depResults = this.buildSnapshotDependencyResults(\n      scope || [],\n      dependencyResults,\n      eventOverride || prInfo.eventType\n    );\n\n    // Debug: log key dependent outputs for visibility\n    if (debug) {\n      try {\n        const depPreview: Record<string, unknown> = {};\n        for (const [k, v] of depResults.entries()) {\n          const out = (v as any)?.output;\n          if (out !== undefined) depPreview[k] = out;\n        }\n        log(`üîß Debug: inline exec '${checkId}' deps output: ${JSON.stringify(depPreview)}`);\n      } catch {}\n    }\n\n    if (debug) {\n      const execStr = (provCfg as any).exec;\n      if (execStr) log(`üîß Debug: inline exec '${checkId}' command: ${execStr}`);\n    }\n\n    // If event override provided, clone prInfo with overridden eventType\n    let prInfoForInline = prInfo;\n    const prevEventOverride = this.routingEventOverride;\n    if (eventOverride) {\n      // Try to elevate to PR context when routing to PR events from issue threads\n      const elevated = await this.elevateContextToPullRequest(\n        { ...(prInfo as any), eventType: eventOverride } as PRInfo,\n        eventOverride,\n        log,\n        debug\n      );\n      if (elevated) {\n        prInfoForInline = elevated;\n      } else {\n        prInfoForInline = { ...(prInfo as any), eventType: eventOverride } as PRInfo;\n      }\n      this.routingEventOverride = eventOverride;\n      const msg = `‚Ü™ goto_event: inline '${checkId}' with event=${eventOverride}${\n        elevated ? ' (elevated to PR context)' : ''\n      }`;\n      if (debug) log(`üîß Debug: ${msg}`);\n      try {\n        require('./logger').logger.info(msg);\n      } catch {}\n    }\n\n    // Execute the check\n    let result: ReviewSummary;\n    try {\n      const __provStart = Date.now();\n      const inlineContext: import('./providers/check-provider.interface').ExecutionContext = {\n        ...sessionInfo,\n        ...this.executionContext,\n      } as any;\n      // dependency printout removed\n      result = await withActiveSpan(\n        `visor.check.${checkId}`,\n        { 'visor.check.id': checkId, 'visor.check.type': provCfg.type || 'ai' },\n        async () => provider.execute(prInfoForInline, provCfg, depResults, inlineContext)\n      );\n      this.recordProviderDuration(checkId, Date.now() - __provStart);\n    } catch (error) {\n      // Restore previous override before rethrowing\n      this.routingEventOverride = prevEventOverride;\n      throw error;\n    } finally {\n      // Always restore previous override\n      this.routingEventOverride = prevEventOverride;\n    }\n\n    // Enrich issues with metadata\n    const enrichedIssues = (result.issues || []).map(issue => ({\n      ...issue,\n      checkName: checkId,\n      ruleId: `${checkId}/${issue.ruleId}`,\n      group: checkConfig.group,\n      schema: typeof checkConfig.schema === 'object' ? 'custom' : checkConfig.schema,\n      template: checkConfig.template,\n      timestamp: Date.now(),\n    }));\n    let enriched = { ...result, issues: enrichedIssues } as ReviewSummary;\n\n    // Track output history for loop/goto scenarios (normalize default output shape)\n    const enrichedWithOutput = enriched as ReviewSummary & { output?: unknown };\n    if (enrichedWithOutput.output !== undefined) {\n      try {\n        const outVal: any = enrichedWithOutput.output as any;\n        let histVal: any = outVal;\n        if (Array.isArray(outVal)) {\n          histVal = outVal;\n        } else if (outVal !== null && typeof outVal === 'object') {\n          histVal = { ...outVal };\n          if ((histVal as any).ts === undefined) (histVal as any).ts = Date.now();\n        } else {\n          histVal = { text: String(outVal), ts: Date.now() };\n        }\n        this.trackOutputHistory(checkId, histVal);\n        try {\n          (enriched as any).__histTracked = true;\n        } catch {}\n      } catch {\n        // best effort history tracking\n        try {\n          this.trackOutputHistory(checkId, enrichedWithOutput.output);\n        } catch {}\n      }\n    }\n\n    // Handle forEach iteration for this check if it returned an array\n    if (checkConfig.forEach && Array.isArray(enrichedWithOutput.output)) {\n      const forEachItems = enrichedWithOutput.output;\n      // Always log forEach detection (not just in debug mode) for visibility\n      const wave = (this.forEachWaveCounts.get(checkId) || 0) + 1;\n      this.forEachWaveCounts.set(checkId, wave);\n      log(\n        `üîÑ forEach check '${checkId}' returned ${forEachItems.length} items - starting iteration (wave #${wave}, origin=${origin})`\n      );\n      if (debug) {\n        log(\n          `üîß Debug: forEach item preview: ${JSON.stringify(forEachItems[0] || {}).substring(0, 200)}`\n        );\n      }\n\n      // Store the array output with forEach metadata\n      const forEachResult = {\n        ...enriched,\n        forEachItems,\n        forEachItemResults: forEachItems.map(item => ({\n          issues: [],\n          output: item,\n        })),\n      };\n      enriched = forEachResult as ReviewSummary;\n\n      // Make the parent result visible to dependency resolution BEFORE scheduling dependents\n      // so that recursive dependency checks do not re-execute this forEach parent in the same wave.\n      try {\n        resultsMap?.set(checkId, enriched);\n      } catch {}\n\n      // Phase 4: commit aggregate parent result early (root scope) so outputs_raw is visible\n      this.commitJournal(\n        checkId,\n        enriched as ExtendedReviewSummary,\n        prInfoForInline.eventType || prInfo.eventType,\n        []\n      );\n\n      // Wave guard: if waves exceed routing.max_loops, stop scheduling dependents to prevent runaway loops\n      const maxLoops = config?.routing?.max_loops ?? 10;\n      if (wave > maxLoops) {\n        try {\n          logger.warn(\n            `‚õî forEach wave guard: '${checkId}' exceeded max_loops=${maxLoops} (wave #${wave}); skipping dependents and routing`\n          );\n        } catch {}\n        // Store and return aggregated result\n        resultsMap?.set(checkId, enriched);\n        return enriched;\n      }\n\n      // Find checks that depend on this forEach check\n      const dependentChecks = Object.keys(config?.checks || {}).filter(name => {\n        const cfg = config?.checks?.[name];\n        return cfg?.depends_on?.includes(checkId);\n      });\n\n      // Always log dependents for visibility\n      try {\n        if (dependentChecks.length > 0) {\n          log(\n            `üîÑ forEach check '${checkId}' has ${dependentChecks.length} dependents: ${dependentChecks.join(', ')}`\n          );\n        } else {\n          log(`‚ö†Ô∏è  forEach check '${checkId}' has NO dependents - nothing to iterate`);\n        }\n      } catch {}\n\n      // Execute each dependent check once per forEach item (scope-based; no per-item map cloning)\n      for (const depCheckName of dependentChecks) {\n        const depCheckConfig = config?.checks?.[depCheckName];\n        if (!depCheckConfig) continue;\n\n        // Always (re)run dependents during inline reruns (on_finish.goto to parent).\n        // We intentionally do not short-circuit on existing results here so stats/history\n        // reflect multiple waves.\n        // Skip if no items to iterate over\n        if (forEachItems.length === 0) {\n          if (debug) {\n            log(`üîß Debug: Skipping forEach dependent '${depCheckName}' - no items to iterate`);\n          }\n          // Store empty result\n          resultsMap?.set(depCheckName, { issues: [] });\n          continue;\n        }\n\n        // Always log iteration start\n        try {\n          const wave = this.forEachWaveCounts.get(checkId) || 1;\n          log(\n            `üîÑ Executing forEach dependent '${depCheckName}' for ${forEachItems.length} items (wave #${wave})`\n          );\n        } catch {}\n\n        const depResults: ReviewSummary[] = [];\n\n        // Execute once per forEach item\n        for (let itemIndex = 0; itemIndex < forEachItems.length; itemIndex++) {\n          const item = forEachItems[itemIndex];\n          const wave = this.forEachWaveCounts.get(checkId) || 1;\n          log(\n            `  üîÑ Iteration ${itemIndex + 1}/${forEachItems.length} f|| '${depCheckName}' (wave #${wave})`\n          );\n\n          // Phase 4: Commit per-item entry for parent in journal under item scope\n          const itemScope: ScopePath = [{ check: checkId, index: itemIndex }];\n          try {\n            this.commitJournal(\n              checkId,\n              { issues: [], output: item } as ExtendedReviewSummary,\n              prInfoForInline.eventType || prInfo.eventType,\n              itemScope\n            );\n          } catch (error) {\n            const msg = error instanceof Error ? error.message : String(error);\n            logger.error(`Failed to commit per-item journal for ${checkId}: ${msg}`);\n            // Non-fatal: journal is best-effort; continue without retry.\n          }\n\n          try {\n            // Build provider + config for dependent and execute with full routing semantics\n            const depProviderType = depCheckConfig.type || 'ai';\n            const depProvider = this.providerRegistry.getProviderOrThrow(depProviderType);\n            this.setProviderWebhookContext(depProvider);\n\n            // Build dependency results from snapshot at item scope (no cloning)\n            const snapshotDeps = this.buildSnapshotDependencyResults(\n              itemScope,\n              undefined,\n              prInfoForInline.eventType || prInfo.eventType\n            );\n\n            // Use unified helper to ensure stats and history are tracked for each item run\n            const res = await this.runNamedCheck(depCheckName, itemScope, {\n              origin: 'foreach',\n              config: config!,\n              dependencyGraph: context.dependencyGraph,\n              prInfo,\n              resultsMap: resultsMap || new Map(),\n              debug: !!debug,\n              eventOverride: prInfoForInline.eventType || prInfo.eventType,\n              overlay: snapshotDeps,\n            });\n            depResults.push(res);\n          } catch (error) {\n            // Store error result for this iteration\n            const errorMsg = error instanceof Error ? error.message : String(error);\n            const errorIssue: ReviewIssue = {\n              file: '',\n              line: 0,\n              ruleId: `${depCheckName}/forEach/iteration_error`,\n              message: `forEach iteration ${itemIndex + 1} failed: ${errorMsg}`,\n              severity: 'error',\n              category: 'logic',\n            };\n            depResults.push({\n              issues: [errorIssue],\n            });\n          }\n        }\n\n        // Aggregate results from all iterations\n        const aggregatedResult: ReviewSummary = {\n          issues: depResults.flatMap(r => r.issues || []),\n        };\n\n        // Store in results map\n        resultsMap?.set(depCheckName, aggregatedResult);\n\n        if (debug) {\n          log(\n            `üîß Debug: Completed forEach dependent '${depCheckName}' with ${depResults.length} iterations`\n          );\n        }\n      }\n    }\n\n    // Store result in results map\n    resultsMap?.set(checkId, enriched);\n    // Commit to journal with provided scope (or root). Avoid double-commit if we already committed aggregate above.\n    const isForEachAggregate = checkConfig.forEach && Array.isArray(enrichedWithOutput.output);\n    if (!isForEachAggregate) {\n      this.commitJournal(\n        checkId,\n        enriched as ExtendedReviewSummary,\n        prInfoForInline.eventType || prInfo.eventType,\n        scope || []\n      );\n    }\n\n    if (debug) log(`üîß Debug: inline executed '${checkId}', issues: ${enrichedIssues.length}`);\n\n    return enriched;\n  }\n\n  /**\n   * Phase 3: Unified scheduling helper\n   * Runs a named check in the current session/scope and records results.\n   * Used by on_success/on_fail/on_finish routing and internal inline execution.\n   */\n  private async runNamedCheck(\n    target: string,\n    scope: ScopePath,\n    opts: {\n      config: VisorConfig;\n      dependencyGraph: DependencyGraph;\n      prInfo: PRInfo;\n      resultsMap: Map<string, ReviewSummary>;\n      debug: boolean;\n      sessionInfo?: { parentSessionId?: string; reuseSession?: boolean };\n      eventOverride?: import('./types/config').EventTrigger;\n      overlay?: Map<string, ReviewSummary>;\n      origin?: 'on_finish' | 'on_success' | 'on_fail' | 'foreach' | 'initial' | 'inline';\n    }\n  ): Promise<ReviewSummary> {\n    const {\n      config,\n      dependencyGraph,\n      prInfo,\n      resultsMap,\n      debug,\n      sessionInfo,\n      eventOverride,\n      overlay,\n    } = opts;\n    try {\n      if (debug && opts.origin === 'on_finish') {\n        console.error(`[runNamedCheck] origin=on_finish step=${target}`);\n      }\n    } catch {}\n\n    // Evaluate 'if' condition for checks executed via routing (run/goto).\n    try {\n      const tcfg = opts.config.checks?.[target] as import('./types/config').CheckConfig | undefined;\n      if (tcfg && tcfg.if) {\n        const gate = await this.shouldRunCheck(\n          target,\n          tcfg.if,\n          opts.prInfo,\n          opts.resultsMap || new Map<string, ReviewSummary>(),\n          !!debug,\n          opts.eventOverride,\n          /* failSecure */ true\n        );\n        if (!gate.shouldRun) {\n          // Record a skipped marker compatible with summary rendering\n          const skipped: ReviewSummary = {\n            issues: [\n              {\n                file: '',\n                line: 0,\n                ruleId: `${target}/__skipped`,\n                message: `Skipped by if condition: ${tcfg.if}`,\n                severity: 'info',\n                category: 'logic',\n              },\n            ],\n          } as ReviewSummary;\n          try {\n            this.recordSkip(target, 'if_condition', tcfg.if);\n            logger.info(`‚è≠  Skipped (if: ${this.truncate(tcfg.if, 40)})`);\n          } catch (error) {\n            const msg = error instanceof Error ? error.message : String(error);\n            logger.error(`Failed to record skip for ${target}: ${msg}`);\n          }\n          // Commit a minimal journal entry to make downstream visibility consistent\n          this.commitJournal(\n            target,\n            skipped as any,\n            opts.eventOverride || opts.prInfo.eventType,\n            scope || []\n          );\n          opts.resultsMap?.set(target, skipped);\n          return skipped;\n        }\n      }\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : String(error);\n      logger.error(`Failed to evaluate if condition for ${target}: ${msg}`);\n      // Fail secure: if condition evaluation fails, skip execution\n      const skipped: ReviewSummary = {\n        issues: [\n          {\n            file: '',\n            line: 0,\n            ruleId: `${target}/__skipped`,\n            message: `Skipped due to condition evaluation error`,\n            severity: 'info',\n            category: 'logic',\n          },\n        ],\n      } as ReviewSummary;\n      try {\n        const cond =\n          (opts.config.checks?.[target] as import('./types/config').CheckConfig | undefined)?.if ||\n          '';\n        this.recordSkip(target, 'if_condition', cond);\n      } catch {}\n      this.commitJournal(\n        target,\n        skipped as any,\n        opts.eventOverride || opts.prInfo.eventType,\n        scope || []\n      );\n      opts.resultsMap?.set(target, skipped);\n      return skipped;\n    }\n\n    // Enforce max-runs guard (after 'if' passes). Count per scope (forEach items separated).\n    try {\n      const limit = this.resolveMaxRuns(config, target);\n      if (typeof limit === 'number' && limit > 0) {\n        const k = this.buildRunKey(target, scope);\n        const soFar = this.runCounters.get(k) || 0;\n        if (soFar >= limit) {\n          const issue: ReviewIssue = {\n            file: '',\n            line: 0,\n            ruleId: `${target}/limits/max_runs_exceeded`,\n            message: `Run limit exceeded for '${target}' in scope ${k} (attempt ${soFar + 1} > ${limit}).`,\n            severity: 'error',\n            category: 'logic',\n          };\n          const capped: ReviewSummary = { issues: [issue] };\n          try {\n            resultsMap.set(target, capped);\n          } catch {}\n          logger.warn(`‚ö†Ô∏è  Max runs exceeded for '${target}' in scope ${k} (limit=${limit}).`);\n          return capped;\n        }\n        this.runCounters.set(k, soFar + 1);\n      }\n    } catch {}\n\n    // Build context overlay from current results; prefer snapshot visibility for scope (Phase 4)\n    const depOverlay = overlay ? new Map(overlay) : new Map(resultsMap);\n    const depOverlaySanitized = this.sanitizeResultMapKeys(depOverlay);\n    // For event overrides, avoid leaking cross-event results via overlay; rely on snapshot-only view\n    const overlayForExec =\n      eventOverride && eventOverride !== (prInfo.eventType || 'manual')\n        ? new Map<string, ReviewSummary>()\n        : depOverlaySanitized;\n    if (!this.executionStats.has(target)) this.initializeCheckStats(target);\n    const startTs = this.recordIterationStart(target);\n    try {\n      let res = await this.executeCheckInline(\n        target,\n        eventOverride || prInfo.eventType || 'manual',\n        {\n          config,\n          dependencyGraph,\n          prInfo,\n          resultsMap,\n          // Use snapshot-only deps when eventOverride is set\n          dependencyResults: overlayForExec,\n          sessionInfo,\n          debug,\n          eventOverride,\n          scope,\n          origin: opts.origin || 'inline',\n        }\n      );\n      // Evaluate fail_if for inline-executed checks (parity with grouped path)\n      let postFailTriggered = false;\n      if (config && (config.fail_if || (config.checks as any)?.[target]?.fail_if)) {\n        try {\n          const failureResults = await this.evaluateFailureConditions(\n            target,\n            res,\n            config,\n            prInfo,\n            resultsMap\n          );\n          if (failureResults.length > 0) {\n            const failureIssues = failureResults\n              .filter(f => f.failed)\n              .map(f => ({\n                file: 'system',\n                line: 0,\n                ruleId: f.conditionName,\n                message: f.message || `Failure condition met: ${f.expression}`,\n                severity: (f.severity || 'error') as 'info' | 'warning' | 'error' | 'critical',\n                category: 'logic' as const,\n              }));\n            if (failureIssues.length > 0) {\n              res = {\n                ...(res || { issues: [] }),\n                issues: [...(res.issues || []), ...failureIssues],\n              } as ReviewSummary;\n              // Update resultsMap immediately so downstream forward-run gating sees fail_if as fatal\n              try {\n                resultsMap.set(target, res);\n              } catch {}\n              // Post-fail_if routing: honor on_fail.goto for inline path\n              const checkCfg = (config.checks as any)?.[target] as\n                | import('./types/config').CheckConfig\n                | undefined;\n              const ofCfg: OnFailConfig | undefined = checkCfg?.on_fail\n                ? { ...(config?.routing?.defaults?.on_fail || {}), ...checkCfg.on_fail }\n                : undefined;\n              postFailTriggered = failureResults.some(r => r.failed === true);\n              // One-bounce guard: if this inline execution was itself triggered from an on_fail\n              // forward-run wave, suppress further on_fail.goto inside the same wave to avoid\n              // tight ask‚Üîrefine loops. Let the grouped runner resume control.\n              // One-bounce guard: when this inline execution was triggered from a routing\n              // origin (on_success/on_fail/foreach), avoid performing another inline\n              // on_fail.goto to prevent tight recursion. In this case we signal the\n              // grouped runner to start another wave so the target step is picked up\n              // at level 0 naturally.\n              const __suppressFailGoto = !!(opts.origin && opts.origin !== 'initial');\n              if (\n                postFailTriggered &&\n                !__suppressFailGoto &&\n                ofCfg &&\n                (ofCfg.goto || ofCfg.goto_js)\n              ) {\n                let pfTarget: string | null = null;\n                if (ofCfg.goto_js) {\n                  try {\n                    const sandbox = this.getRoutingSandbox();\n                    const scopeObj = {\n                      step: { id: target, tags: checkCfg?.tags || [], group: checkCfg?.group },\n                      outputs: Object.fromEntries(resultsMap.entries()),\n                      output: (res as any)?.output,\n                      event: { name: prInfo.eventType || 'manual' },\n                    };\n                    const code = `const step=scope.step; const outputs=scope.outputs; const output=scope.output; const event=scope.event; ${ofCfg.goto_js}`;\n                    const r = compileAndRun<string | null>(\n                      sandbox,\n                      code,\n                      { scope: scopeObj },\n                      { injectLog: false, wrapFunction: true }\n                    );\n                    pfTarget = typeof r === 'string' && r ? r : null;\n                  } catch {}\n                }\n                if (!pfTarget && ofCfg.goto) pfTarget = ofCfg.goto;\n                if (pfTarget) {\n                  try {\n                    logger.info(\n                      `‚Ü™ on_fail.goto(post-fail_if/inline): jumping to '${pfTarget}' from '${target}'`\n                    );\n                  } catch {}\n                  await this.scheduleForwardRun(pfTarget, {\n                    origin: 'on_fail',\n                    gotoEvent: ofCfg.goto_event,\n                    config,\n                    dependencyGraph,\n                    prInfo,\n                    resultsMap,\n                    debug,\n                  });\n                }\n              } else if (postFailTriggered) {\n                // No inline goto scheduled (either suppressed or no goto configured):\n                // flag the outer wave loop so we execute another pass.\n                try {\n                  (this as any).onFailForwardRunSeen = true;\n                  if (debug)\n                    (config?.output?.pr_comment ? console.error : console.log)(\n                      `üîÅ Debug: inline fail_if triggered for '${target}', scheduling next wave`\n                    );\n                } catch {}\n              }\n            }\n          }\n        } catch {}\n      }\n      // Success path (inline): honor on_success.run/goto for the inline-executed target\n      try {\n        const checkCfg = (config.checks as any)?.[target] as\n          | import('./types/config').CheckConfig\n          | undefined;\n        const onSucc: OnSuccessConfig | undefined = checkCfg?.on_success;\n        // When this inline execution originates from a forward-run:\n        //  - origin === 'on_success': scheduleForwardRun will already handle dependents and\n        //    static goto chains. Suppress inline on_success entirely to avoid duplicates.\n        //  - origin === 'on_fail': we want corrective side-effects from on_success.run (e.g.,\n        //    increment a memory counter), but we must NOT follow goto to avoid immediate loops.\n        const originTag = opts.origin || 'inline';\n        const suppressAllOnSuccess = originTag === 'on_success';\n        const suppressGotoOnly = originTag === 'on_fail' || this.gotoSuppressedChecks.has(target);\n        if (onSucc && !postFailTriggered && !suppressAllOnSuccess) {\n          // Compute run list (static + dynamic)\n          const dynamicRun = await (async () => {\n            if (!onSucc.run_js) return [] as string[];\n            try {\n              const scopeObj = {\n                step: { id: target, tags: checkCfg?.tags || [], group: checkCfg?.group },\n                outputs: Object.fromEntries(resultsMap.entries()),\n                output: (res as any)?.output,\n                event: { name: prInfo.eventType || 'manual' },\n              };\n              const code = `const step=scope.step; const outputs=scope.outputs; const output=scope.output; const event=scope.event; ${onSucc.run_js}`;\n              const r = compileAndRun<string[] | string | null>(\n                this.getRoutingSandbox(),\n                code,\n                { scope: scopeObj },\n                { injectLog: false, wrapFunction: true }\n              );\n              const arr = Array.isArray(r) ? r : typeof r === 'string' && r ? [r] : [];\n              return arr.filter(Boolean) as string[];\n            } catch {\n              return [] as string[];\n            }\n          })();\n          let runList = [...(onSucc.run || []), ...dynamicRun].filter(Boolean);\n          // Dedup within this call\n          runList = Array.from(new Set(runList));\n          if (runList.length > 0) {\n            for (const stepId of runList) {\n              // One-shot guard similar to grouped path\n              try {\n                const tcfg = (config.checks || {})[stepId] as\n                  | import('./types/config').CheckConfig\n                  | undefined;\n                const tags = (tcfg?.tags || []) as string[];\n                const isOneShot = Array.isArray(tags) && tags.includes('one_shot');\n                if (isOneShot && (this.executionStats.get(stepId)?.totalRuns || 0) > 0) {\n                  continue;\n                }\n              } catch {}\n              await this.runNamedCheck(stepId, scope || [], {\n                config,\n                dependencyGraph,\n                prInfo,\n                resultsMap,\n                debug,\n                overlay: resultsMap,\n              });\n            }\n          }\n          // Optional on_success.goto for inline path\n          let succTarget: string | null = null;\n          try {\n            if (!suppressGotoOnly && !succTarget && onSucc.goto_js) {\n              const scopeObj = {\n                step: { id: target, tags: checkCfg?.tags || [], group: checkCfg?.group },\n                outputs: Object.fromEntries(resultsMap.entries()),\n                output: (res as any)?.output,\n                event: { name: prInfo.eventType || 'manual' },\n              };\n              const code = `const step=scope.step; const outputs=scope.outputs; const output=scope.output; const event=scope.event; ${onSucc.goto_js}`;\n              const r = compileAndRun<string | null>(\n                this.getRoutingSandbox(),\n                code,\n                { scope: scopeObj },\n                { injectLog: false, wrapFunction: true }\n              );\n              succTarget = typeof r === 'string' && r ? r : null;\n            }\n          } catch {}\n          if (!suppressGotoOnly && !succTarget && onSucc.goto) succTarget = onSucc.goto;\n          if (!suppressGotoOnly && succTarget) {\n            // If this is comment-assistant retriggering overview, proactively\n            // post the assistant reply so flows record a createComment before\n            // we jump to overview.\n            try {\n              // Generic: when an assistant-style check (schema contains a 'text' field)\n              // triggers a goto to a different event (e.g., pr_updated), proactively post\n              // the assistant reply so flows record a createComment before jumping.\n              const isAssistantSchema = async () => {\n                try {\n                  const sc = (config.checks as any)[target]?.schema;\n                  if (!sc) return false;\n                  if (typeof sc === 'string') {\n                    const name = String(sc);\n                    const builtins = new Set([\n                      'issue-assistant',\n                      'overview',\n                      'plain',\n                      'text',\n                      'code-review',\n                    ]);\n                    if (builtins.has(name)) return true;\n                    try {\n                      const fs = require('fs');\n                      const path = require('path');\n                      const candidates = [\n                        path.join(__dirname, 'output', name, 'schema.json'),\n                        path.join(process.cwd(), 'output', name, 'schema.json'),\n                      ];\n                      for (const p of candidates) {\n                        try {\n                          const txt = fs.readFileSync(p, 'utf8');\n                          const obj = JSON.parse(txt);\n                          const props = obj && obj.properties;\n                          if (props && Object.prototype.hasOwnProperty.call(props, 'text'))\n                            return true;\n                        } catch {}\n                      }\n                    } catch {}\n                    return false;\n                  }\n                  const props = (sc && (sc as any).properties) || {};\n                  return Boolean(props && Object.prototype.hasOwnProperty.call(props, 'text'));\n                } catch {\n                  return false;\n                }\n              };\n              const shouldProactivelyPost = await isAssistantSchema();\n              if (shouldProactivelyPost && (onSucc.goto || onSucc.goto_event)) {\n                const out = (res as any)?.output;\n                const hasText =\n                  out &&\n                  typeof out === 'object' &&\n                  typeof out.text === 'string' &&\n                  out.text.trim().length > 0;\n                if (hasText) {\n                  // One-shot guard: post once per run per target\n                  try {\n                    const key = `post:${target}`;\n                    if (this.oncePerRunScheduleGuards.has(key)) {\n                      // already posted\n                    } else {\n                      this.oncePerRunScheduleGuards.add(key);\n                    }\n                  } catch {}\n                  const miniSummary: any = {\n                    issues: [],\n                    __outputs: { [target]: out },\n                    __contents: {},\n                    __executed: [target],\n                  };\n                  // Resolve owner/repo\n                  let owner: string | undefined = this.actionContext?.owner;\n                  let repo: string | undefined = this.actionContext?.repo;\n                  if (!owner || !repo) {\n                    try {\n                      const anyInfo = prInfo as any;\n                      owner = anyInfo?.eventContext?.repository?.owner?.login || owner;\n                      repo = anyInfo?.eventContext?.repository?.name || repo;\n                    } catch {}\n                  }\n                  owner = owner || (process.env.GITHUB_REPOSITORY || 'owner/repo').split('/')[0];\n                  repo = repo || (process.env.GITHUB_REPOSITORY || 'owner/repo').split('/')[1];\n                  try {\n                    const oc = (prInfo as any)?.eventContext?.octokit;\n                    if (oc && owner && repo && prInfo.number) {\n                      // Render minimal content via template for consistent formatting\n                      let rendered: string | undefined = undefined;\n                      try {\n                        rendered = await this.renderCheckContent(\n                          target,\n                          { issues: [], output: out } as any,\n                          (config.checks as any)[target],\n                          prInfo\n                        );\n                      } catch {}\n                      const body = `${(rendered && rendered.trim()) || String(out.text || '')}\\n\\n${generateFooter()}`;\n                      const api: any =\n                        (oc as any).rest?.issues?.createComment ||\n                        (oc as any).issues?.createComment;\n                      if (typeof api === 'function') {\n                        await api({ owner, repo, issue_number: prInfo.number, body });\n                      } else if (this.reviewer) {\n                        const grouped = await this.convertReviewSummaryToGroupedResults(\n                          miniSummary,\n                          [target],\n                          config,\n                          prInfo\n                        );\n                        await this.reviewer.postReviewComment(owner, repo, prInfo.number, grouped, {\n                          config: config as any,\n                          triggeredBy: prInfo.eventType || 'manual',\n                          octokitOverride: oc as any,\n                        });\n                      }\n                    } else if (this.reviewer && owner && repo && prInfo.number) {\n                      // Fallback to grouped posting path if recorder is not available\n                      const grouped = await this.convertReviewSummaryToGroupedResults(\n                        miniSummary,\n                        ['comment-assistant'],\n                        config,\n                        prInfo\n                      );\n                      await this.reviewer.postReviewComment(owner, repo, prInfo.number, grouped, {\n                        config: config as any,\n                        triggeredBy: prInfo.eventType || 'manual',\n                        octokitOverride: (prInfo as any)?.eventContext?.octokit,\n                      });\n                    }\n                  } catch {}\n                }\n              }\n            } catch {}\n\n            await this.scheduleForwardRun(succTarget, {\n              origin: 'on_success',\n              gotoEvent: onSucc.goto_event,\n              config,\n              dependencyGraph,\n              prInfo,\n              resultsMap,\n              debug,\n            });\n            // Opportunistic inline execution: if the routed target has its\n            // dependencies satisfied by current results, run it once now so\n            // simple producer‚Üíconsumer chains complete without another wave.\n            try {\n              const childCfg = (config.checks || {})[succTarget] as\n                | import('./types/config').CheckConfig\n                | undefined;\n              const deps = Array.isArray(childCfg?.depends_on)\n                ? (childCfg!.depends_on as string[])\n                : childCfg?.depends_on\n                  ? [String(childCfg.depends_on)]\n                  : [];\n              const depsSatisfied = deps.every(d => resultsMap.has(d));\n              if (depsSatisfied) {\n                // Suppress further goto on dependencies during this opportunistic run\n                try {\n                  for (const d of deps) this.gotoSuppressedChecks.add(d);\n                } catch {}\n                try {\n                  if (!this.executionStats.has(succTarget)) this.initializeCheckStats(succTarget);\n                } catch {}\n                await this.runNamedCheck(succTarget, scope || [], {\n                  config,\n                  dependencyGraph,\n                  prInfo,\n                  resultsMap,\n                  debug,\n                  overlay: resultsMap,\n                });\n                // Clear scheduled marker for this target to avoid redundant next-wave run\n                try {\n                  this.forwardDependentsScheduled.delete(succTarget);\n                } catch {}\n              }\n            } catch {}\n          }\n        }\n      } catch {}\n      // Ensure resultsMap reflects any fail_if augmentation before downstream gating/routing\n      try {\n        resultsMap.set(target, res);\n      } catch {}\n      const issues = (res.issues || []).map(i => ({ ...i }));\n      const success = !this.hasFatal(issues);\n      const out: unknown = (res as { output?: unknown }).output;\n      const isForEachParent =\n        (res as any)?.isForEach === true ||\n        Array.isArray((res as any)?.forEachItems) ||\n        Array.isArray(out);\n      this.recordIterationComplete(\n        target,\n        startTs,\n        success,\n        issues,\n        isForEachParent ? undefined : out\n      );\n      // Output history is already tracked inside executeCheckInline when a check\n      // produces an output. Avoid tracking again here to prevent double-counting\n      // (particularly for forward-run goto chains within a single stage).\n      return res;\n    } catch (e) {\n      this.recordIterationComplete(target, startTs, false, [], undefined);\n      throw e;\n    }\n  }\n\n  /**\n   * Handle on_finish hooks for forEach checks after ALL dependents complete\n   */\n  private async handleOnFinishHooks(\n    config: VisorConfig,\n    dependencyGraph: DependencyGraph,\n    results: Map<string, ReviewSummary>,\n    prInfo: PRInfo,\n    debug: boolean\n  ): Promise<void> {\n    const log = (msg: string) => (config?.output?.pr_comment ? console.error : console.log)(msg);\n    try {\n      if (debug) console.error('[on_finish] handler invoked');\n    } catch {}\n\n    const forEachChecksWithOnFinish = this.collectForEachParentsWithOnFinish(config);\n\n    try {\n      logger.info(\n        `üß≠ on_finish: discovered ${forEachChecksWithOnFinish.length} forEach parent(s) with hooks`\n      );\n    } catch {}\n    if (forEachChecksWithOnFinish.length === 0) {\n      return; // No on_finish hooks to process\n    }\n\n    // Note: do not early-return if none of the forEach parents executed in this run.\n    // Some configurations rely on on_finish routing even when the parent did not run\n    // in the current wave (e.g., CLI-only invocations). We continue and allow\n    // budget checks and static routing to surface issues as needed.\n\n    if (debug) {\n      log(`üéØ Processing on_finish hooks for ${forEachChecksWithOnFinish.length} forEach check(s)`);\n    }\n\n    // Process each forEach check's on_finish hook\n    for (const { checkName, checkConfig, onFinish } of forEachChecksWithOnFinish) {\n      try {\n        const forEachResult = results.get(checkName) as ExtendedReviewSummary | undefined;\n\n        // Treat missing result or empty array as zero items; still proceed so that\n        // loop-budget checks and static routing can be validated.\n        const forEachItems = (forEachResult && forEachResult.forEachItems) || [];\n\n        // Get all dependents of this forEach check\n        const node = dependencyGraph.nodes.get(checkName);\n        const dependents = node?.dependents || [];\n\n        try {\n          logger.info(`üîç on_finish: \"${checkName}\" ‚Üí ${dependents.length} dependent(s)`);\n        } catch {}\n\n        // Ensure all dependents have completed before processing on_finish.\n        // If any are missing, try to execute them now in the on_finish phase so aggregation\n        // has up-to-date data (particularly important for forEach + validators).\n        for (const depId of dependents) {\n          if (results.has(depId)) continue;\n          try {\n            if (debug)\n              log(\n                `üîß on_finish: executing missing dependent '${depId}' before processing '${checkName}'`\n              );\n            const depRes = await this.runNamedCheck(depId, [], {\n              origin: 'on_finish',\n              config,\n              dependencyGraph,\n              prInfo,\n              resultsMap: results,\n              sessionInfo: (this.executionContext as any) || undefined,\n              debug,\n              overlay: new Map(results),\n            });\n            try {\n              results.set(depId, depRes as ReviewSummary);\n            } catch {}\n          } catch (e) {\n            // If a dependent cannot run, continue; downstream hooks may still choose to skip\n            try {\n              const msg = e instanceof Error ? e.message : String(e);\n              logger.warn(`‚ö†Ô∏è on_finish: failed to execute dependent '${depId}': ${msg}`);\n            } catch {}\n          }\n        }\n\n        logger.info(`‚ñ∂ on_finish: processing for \"${checkName}\"`);\n\n        // Build history snapshot and synthesize per-item entries for dependents of this\n        // forEach parent if the current wave's per-item results are not yet reflected.\n        const historySnapshot = this.getOutputHistorySnapshot();\n        try {\n          // Ensure the parent entry includes the current wave's array of items\n          try {\n            const parentHist = (historySnapshot[checkName] as unknown[]) || [];\n            const lastArray = parentHist.filter(Array.isArray).slice(-1)[0] as\n              | unknown[]\n              | undefined;\n            const sameLength = Array.isArray(lastArray) && lastArray.length === forEachItems.length;\n            if (!sameLength && Array.isArray(forEachItems) && forEachItems.length > 0) {\n              if (!historySnapshot[checkName]) historySnapshot[checkName] = [] as unknown[];\n              (historySnapshot[checkName] as unknown[]).push(forEachItems);\n            }\n          } catch {}\n\n          const nodeDeps = dependencyGraph.nodes.get(checkName)?.dependents || [];\n          for (const depId of nodeDeps) {\n            const depRes = results.get(depId) as ExtendedReviewSummary | undefined;\n            if (!depRes || !Array.isArray(depRes.forEachItemResults)) continue;\n            const items = Array.isArray(forEachItems) ? forEachItems.length : 0;\n            if (items <= 0) continue;\n            const arr = (historySnapshot[depId] as unknown[]) || [];\n            const nonArrayCount = arr.filter(x => !Array.isArray(x)).length;\n            const remainder = items > 0 ? nonArrayCount % items : 0;\n            const deficit = remainder > 0 ? items - remainder : 0;\n            if (deficit > 0) {\n              // Top up to the nearest multiple of items using current wave results\n              const wave = depRes.forEachItemResults.slice(\n                0,\n                Math.min(deficit, depRes.forEachItemResults.length)\n              );\n              for (const r of wave) {\n                const outVal = (r as any)?.output !== undefined ? (r as any).output : r;\n                try {\n                  if (!historySnapshot[depId]) historySnapshot[depId] = [] as unknown[];\n                  (historySnapshot[depId] as unknown[]).push(outVal);\n                } catch {}\n              }\n            }\n          }\n        } catch {}\n\n        // If the forEach parent didn't carry forEachItems on the result object,\n        // recover the last wave array length from history (if present).\n        try {\n          if (Array.isArray((historySnapshot as any)[checkName]) && forEachItems.length === 0) {\n            const parentHist = ((historySnapshot as any)[checkName] as unknown[]).filter(\n              Array.isArray\n            );\n            const lastArr =\n              parentHist.length > 0 ? (parentHist[parentHist.length - 1] as unknown[]) : [];\n            if (Array.isArray(lastArr) && lastArr.length > 0) {\n              forEachItems.splice(0, forEachItems.length, ...lastArr);\n            }\n          }\n        } catch {}\n\n        // Build context projection (pure) using the synthesized snapshot\n        const { outputsForContext, outputsHistoryForContext } = ofProject(results, historySnapshot);\n\n        // Create forEach stats\n        const __perItem = Array.isArray(forEachResult?.forEachItemResults)\n          ? (forEachResult!.forEachItemResults as ReviewSummary[])\n          : [];\n        const forEachStats = {\n          total: forEachItems.length,\n          last_wave_size: forEachItems.length,\n          successful:\n            __perItem.length > 0\n              ? __perItem.filter(r => r && (!r.issues || r.issues.length === 0)).length\n              : forEachItems.length,\n          failed:\n            __perItem.length > 0\n              ? __perItem.filter(r => r && r.issues && r.issues.length > 0).length\n              : 0,\n          items: forEachItems,\n        };\n\n        // Build context for on_finish evaluation (extracted helper)\n        const onFinishContext = ofComposeCtx(\n          undefined,\n          checkName,\n          checkConfig,\n          outputsForContext,\n          outputsHistoryForContext,\n          forEachStats,\n          prInfo\n        );\n\n        // Diagnostics: log attempt, dependents, items, and current budget usage\n        try {\n          const usedBudget = this.onFinishLoopCounts.get(checkName) || 0;\n          const maxBudget = config?.routing?.max_loops ?? 10;\n          logger.info(\n            `üß≠ on_finish: check=\"${checkName}\" items=${forEachItems.length} dependents=${dependents.length} budget=${usedBudget}/${maxBudget}`\n          );\n          const vfHist = (outputsHistoryForContext['validate-fact'] as unknown[]) || [];\n          if (vfHist.length) {\n            logger.debug(`üß≠ on_finish: outputs.history['validate-fact'] length=${vfHist.length}`);\n          }\n        } catch {}\n\n        // Execute on_finish.run (static) first, then evaluate run_js with updated context\n        {\n          const maxLoops = config?.routing?.max_loops ?? 10;\n          let loopCount = 0;\n          const runList = Array.from(new Set([...(onFinish.run || [])].filter(Boolean)));\n          if (runList.length > 0)\n            logger.info(`‚ñ∂ on_finish.run: executing [${runList.join(', ')}] for \"${checkName}\"`);\n          const runCheck = async (id: string): Promise<ReviewSummary> => {\n            if (++loopCount > maxLoops) {\n              try {\n                logger.error(\n                  `Routing loop budget exceeded (max_loops=${maxLoops}) during on_finish run`\n                );\n              } catch {}\n              // Surface a visible issue instead of throwing so E2E can assert\n              try {\n                results.set(checkName, {\n                  issues: [\n                    {\n                      file: 'system',\n                      line: 0,\n                      ruleId: `${checkName}/routing/loop_budget_exceeded`,\n                      message: `Routing loop budget exceeded (max_loops=${maxLoops}) during on_finish run`,\n                      severity: 'error',\n                      category: 'logic',\n                    },\n                  ],\n                } as ReviewSummary);\n              } catch {}\n              return { issues: [] } as ReviewSummary;\n            }\n            const childCfgFull = (config?.checks || {})[id] as\n              | import('./types/config').CheckConfig\n              | undefined;\n            if (!childCfgFull) throw new Error(`Unknown check in on_finish.run: ${id}`);\n            const childProvider = this.providerRegistry.getProviderOrThrow(\n              childCfgFull.type || 'ai'\n            );\n            this.setProviderWebhookContext(childProvider);\n            const depOverlayForChild = new Map(results);\n            const resChild = await this.runNamedCheck(id, [], {\n              origin: 'on_finish',\n              config: config!,\n              dependencyGraph,\n              prInfo,\n              resultsMap: results,\n              debug,\n              sessionInfo: (this.executionContext as any) || undefined,\n              overlay: depOverlayForChild,\n            });\n            try {\n              results.set(id, resChild as ReviewSummary);\n            } catch {}\n            return resChild as ReviewSummary;\n          };\n          try {\n            await ofRunChildren(runList, runCheck, config!, onFinishContext, debug || false, log);\n            if (runList.length > 0) logger.info(`‚úì on_finish.run: completed for \"${checkName}\"`);\n          } catch (error) {\n            const errorMsg = error instanceof Error ? error.message : String(error);\n            logger.error(`‚úó on_finish.run: failed for \"${checkName}\": ${errorMsg}`);\n            if (error instanceof Error && error.stack) logger.debug(`Stack trace: ${error.stack}`);\n            throw error;\n          }\n\n          // Now evaluate dynamic run_js with post-run context (e.g., after aggregation updated memory)\n          const evalRunJs = async (js?: string): Promise<string[]> => {\n            if (!js) return [];\n            try {\n              const sandbox = this.getRoutingSandbox();\n              const scope = onFinishContext; // contains memory + outputs history\n              const code = `\n                const step = scope.step; const attempt = scope.attempt; const loop = scope.loop; const outputs = scope.outputs; const outputs_history = scope.outputs_history; const outputs_raw = scope.outputs_raw; const forEach = scope.forEach; const memory = scope.memory; const pr = scope.pr; const files = scope.files; const env = scope.env; const event = scope.event; const log = (...a)=> console.log('üîç Debug:',...a);\n                const __fn = () => {\\n${js}\\n};\n                const __res = __fn();\n                return Array.isArray(__res) ? __res.filter(x => typeof x === 'string' && x) : [];\n              `;\n              const exec = sandbox.compile(code);\n              const res = exec({ scope }).run();\n              return Array.isArray(res) ? (res as string[]) : [];\n            } catch (e) {\n              const msg = e instanceof Error ? e.message : String(e);\n              logger.error(`‚úó on_finish.run_js: evaluation failed for \"${checkName}\": ${msg}`);\n              if (e instanceof Error && e.stack) logger.debug(`Stack trace: ${e.stack}`);\n              return [];\n            }\n          };\n          // No MemoryStore in on_finish; dynamic run_js sees only outputs/outputs_history\n          const dynamicRun = await evalRunJs(onFinish.run_js);\n          const dynList = Array.from(new Set(dynamicRun.filter(Boolean)));\n          if (dynList.length > 0) {\n            logger.info(\n              `‚ñ∂ on_finish.run_js: executing [${dynList.join(', ')}] for \"${checkName}\"`\n            );\n            for (const runCheckId of dynList) {\n              if (++loopCount > maxLoops) {\n                try {\n                  logger.error(\n                    `Routing loop budget exceeded (max_loops=${maxLoops}) during on_finish run_js`\n                  );\n                } catch {}\n                // Surface a visible issue and stop scheduling more children\n                try {\n                  results.set(checkName, {\n                    issues: [\n                      {\n                        file: 'system',\n                        line: 0,\n                        ruleId: `${checkName}/routing/loop_budget_exceeded`,\n                        message: `Routing loop budget exceeded (max_loops=${maxLoops}) during on_finish run_js`,\n                        severity: 'error',\n                        category: 'logic',\n                      },\n                    ],\n                  } as ReviewSummary);\n                } catch {}\n                break;\n              }\n              logger.info(`  ‚ñ∂ Executing on_finish(run_js) check: ${runCheckId}`);\n              // Use full routing semantics for dynamic children as well\n              const childCfgFull = (config?.checks || {})[runCheckId] as\n                | import('./types/config').CheckConfig\n                | undefined;\n              if (!childCfgFull)\n                throw new Error(`Unknown check in on_finish.run_js: ${runCheckId}`);\n              const childProvType = childCfgFull.type || 'ai';\n              const childProvider = this.providerRegistry.getProviderOrThrow(childProvType);\n              this.setProviderWebhookContext(childProvider);\n              // Note: unified scheduling executes via runNamedCheck; provider config built internally\n              const depOverlayForChild = new Map(results);\n              const childRes = await this.runNamedCheck(runCheckId, [], {\n                origin: 'on_finish',\n                config: config!,\n                dependencyGraph,\n                prInfo,\n                resultsMap: results,\n                debug,\n                sessionInfo: (this.executionContext as any) || undefined,\n                overlay: depOverlayForChild,\n              });\n              try {\n                results.set(runCheckId, childRes as ReviewSummary);\n              } catch {}\n              logger.info(`  ‚úì Completed on_finish(run_js) check: ${runCheckId}`);\n            }\n          }\n        }\n\n        // After on_finish.run completes, recompute an authoritative 'all_valid' flag from\n        // the latest validate-fact history using outputs/history only (no MemoryStore).\n        let verdictLocal: boolean | undefined = undefined;\n        try {\n          const snap = this.getOutputHistorySnapshot();\n          verdictLocal = ofAllValid(snap, forEachItems.length);\n          if (typeof verdictLocal === 'boolean') {\n            logger.info(\n              `üßÆ on_finish: recomputed all_valid=${verdictLocal} from history for \"${checkName}\"`\n            );\n          }\n        } catch {}\n        // If the parent produced no items in the last wave, do not route.\n        // This prevents non-converging loops when validation is disabled or\n        // extraction yielded nothing in this stage.\n        if (forEachItems.length === 0) {\n          try {\n            logger.info(`‚è≠ on_finish: no items; skipping routing for \"${checkName}\"`);\n          } catch {}\n          continue;\n        }\n\n        // Evaluate on_finish.goto_js for routing decision\n        let gotoTarget: string | null = ofDecide(\n          checkName,\n          checkConfig,\n          outputsForContext,\n          outputsHistoryForContext,\n          { items: forEachItems },\n          prInfo,\n          config,\n          debug,\n          log\n        ).gotoTarget;\n\n        // Config-informed fallback in engine: if goto_js returned null but the\n        // configuration encodes a simple budget (\"1 + N\") and the last wave is\n        // not all-valid, route back to the parent while under budget.\n        if (!gotoTarget) {\n          try {\n            const js = String(checkConfig.on_finish?.goto_js || '');\n            let n = NaN;\n            const m = js.match(/maxWaves\\s*=\\s*1\\s*\\+\\s*(\\d+)/);\n            if (m) n = Number(m[1]);\n            if (!Number.isFinite(n)) {\n              const all = Array.from(js.matchAll(/1\\s*\\+\\s*(\\d+)/g));\n              if (all.length > 0) {\n                const last = all[all.length - 1];\n                const num = Number(last[1]);\n                if (Number.isFinite(num)) n = num;\n              }\n            }\n            if (Number.isFinite(n) && n > 0 && forEachItems.length > 0) {\n              const vf = Array.isArray(outputsHistoryForContext['validate-fact'])\n                ? (outputsHistoryForContext['validate-fact'] as unknown[]).filter(\n                    x => !Array.isArray(x)\n                  )\n                : [];\n              const items = forEachItems.length;\n              const waves = items > 0 ? Math.floor(vf.length / items) : 0;\n              const last = items > 0 ? vf.slice(-items) : [];\n              const allOk =\n                last.length === items &&\n                last.every((v: any) => v && (v.is_valid === true || v.valid === true));\n              if (!allOk && waves < 1 + Number(n)) {\n                gotoTarget = checkName;\n                if (debug)\n                  log(\n                    `üîß Debug: engine fallback ‚Üí '${checkName}' (waves=${waves} < max=${1 + Number(n)})`\n                  );\n              }\n            }\n          } catch {}\n        }\n\n        // Debug visibility removed (was [on_finish dbg]); retained via structured stats/logs above\n\n        // No engine fallback ‚Äî configuration decides routing. With per‚Äëitem\n        // outputs recorded in history, goto_js can compute waves deterministically.\n\n        // Execute routing if we have a target\n        if (gotoTarget) {\n          // Guard: do not re-route the same parent->target pair more than once per grouped run.\n          try {\n            const pairKey = `${checkName}->${gotoTarget}`;\n            if (this.postOnFinishGuards.has(pairKey)) {\n              logger.info(`‚è≠ on_finish: already routed '${pairKey}' in this run; skipping`);\n              gotoTarget = null as any;\n            } else {\n              this.postOnFinishGuards.add(pairKey);\n            }\n          } catch {}\n          // If we‚Äôre routing back to the forEach parent but the latest wave\n          // verdict (computed from outputs_history) is all valid, skip routing.\n          try {\n            logger.info(\n              `  üîí on_finish.goto guard: gotoTarget=${String(gotoTarget)} verdictLocal=${String(verdictLocal)}`\n            );\n          } catch {}\n          if (gotoTarget === checkName && verdictLocal === true) {\n            logger.info(`‚úì on_finish.goto: skipping routing to '${gotoTarget}' (all_valid=true)`);\n            gotoTarget = null as any;\n          }\n\n          // Extra deterministic guard: if the last wave of validate-fact is all valid,\n          try {\n            const __h = this.outputHistory.get('validate-fact');\n            logger.info(\n              `  üß™ on_finish.goto: validate-fact history now len=${Array.isArray(__h) ? __h.length : 0}`\n            );\n          } catch {}\n          // skip routing back to the forEach parent even if goto_js requested it.\n          try {\n            if (gotoTarget === checkName) {\n              const vfHistNow = (this.outputHistory.get('validate-fact') || []) as unknown[];\n              if (Array.isArray(vfHistNow) && forEachItems.length > 0) {\n                const verdicts = vfHistNow\n                  .map(v => (v && typeof v === 'object' ? (v as any) : undefined))\n                  .filter(\n                    v => v && (typeof v.is_valid === 'boolean' || typeof v.valid === 'boolean')\n                  )\n                  .map(v => v.is_valid === true || v.valid === true);\n                if (verdicts.length >= forEachItems.length) {\n                  const lastVerdicts = verdicts.slice(-forEachItems.length);\n                  const allTrue = lastVerdicts.every(Boolean);\n                  if (allTrue) {\n                    try {\n                      logger.info(\n                        `‚úì on_finish.goto: history verdicts all valid; skipping routing to '${gotoTarget}'`\n                      );\n                    } catch {}\n                    gotoTarget = null as any;\n                  }\n                }\n              }\n            }\n          } catch {}\n\n          // If gotoTarget was cleared (e.g., all_valid guard), skip routing\n          if (!gotoTarget) {\n            try {\n              logger.info(`‚úì on_finish.goto: no routing needed for \"${checkName}\"`);\n            } catch {}\n            continue;\n          }\n\n          // Secondary guard: if the common dependent validations history shows all items valid,\n          // avoid routing back to the forEach parent even if goto_js asked to.\n          try {\n            if (gotoTarget === checkName) {\n              const vfHist = this.outputHistory.get('validate-fact');\n              const arr = Array.isArray(vfHist) ? (vfHist as unknown[]) : [];\n              const allOk = arr.length > 0 && arr.every((v: any) => v && v.is_valid === true);\n              if (allOk) {\n                logger.info(\n                  `‚úì on_finish.goto: validate-fact history all valid; skipping routing to '${gotoTarget}'`\n                );\n                continue;\n              }\n            }\n          } catch {}\n\n          // Count toward loop budget similar to other routing paths (per-parent on_finish)\n          const maxWavesTotal = config?.routing?.max_loops ?? 10;\n          // on_finish routing consumes additional waves; budget routes = total_waves - 1\n          const maxRoutes = Math.max(0, maxWavesTotal - 1);\n          const used = (this.onFinishLoopCounts.get(checkName) || 0) + 1;\n          if (used > maxRoutes) {\n            logger.warn(\n              `‚ö†Ô∏è on_finish: route budget exceeded for \"${checkName}\" (max_routes=${maxRoutes}); last goto='${gotoTarget}'. Skipping further routing.`\n            );\n            try {\n              logger.error(\n                `Routing loop budget exceeded (max_routes=${maxRoutes}) during on_finish goto`\n              );\n            } catch {}\n            // Surface issue for tests\n            try {\n              results.set(checkName, {\n                issues: [\n                  {\n                    file: 'system',\n                    line: 0,\n                    ruleId: `${checkName}/routing/loop_budget_exceeded`,\n                    message: `Routing loop budget exceeded (max_routes=${maxRoutes}) during on_finish goto`,\n                    severity: 'error',\n                    category: 'logic',\n                  },\n                ],\n              } as ReviewSummary);\n            } catch {}\n            continue;\n          }\n          this.onFinishLoopCounts.set(checkName, used);\n\n          logger.info(\n            `‚ñ∂ on_finish: routing from \"${checkName}\" to \"${gotoTarget}\" (routes ${used}/${maxRoutes})`\n          );\n\n          try {\n            // Ensure a follow-up wave is scheduled by marking the target now.\n            // scheduleForwardRun will also mark, but this guard guarantees the\n            // post-on_finish wave loop sees a non-empty forward set even if\n            // scheduleForwardRun exits early for this origin.\n            try {\n              this.addForwardTarget(gotoTarget, []);\n            } catch {}\n            try {\n              (this as any).onFinishForwardRunSeen = true;\n            } catch {}\n            const tcfg = config.checks?.[gotoTarget as string];\n            const mode =\n              tcfg?.fanout === 'map' ? 'map' : tcfg?.reduce ? 'reduce' : tcfg?.fanout || 'default';\n            // For on_finish correction waves, include non-forEach dependents only\n            // so lightweight actions (e.g., label application) can run again\n            // while heavy per-item validators are excluded.\n            try {\n              this.forwardIncludeDependents.set(gotoTarget, true);\n              this.forwardExcludeForEachDependents.set(gotoTarget, true);\n            } catch {}\n            if (mode === 'map' && forEachItems.length > 0) {\n              for (let i = 0; i < forEachItems.length; i++) {\n                const itemScope: ScopePath = [{ check: checkName, index: i }];\n                await this.scheduleForwardRun(gotoTarget!, {\n                  origin: 'on_finish',\n                  gotoEvent: onFinish.goto_event,\n                  config,\n                  dependencyGraph,\n                  prInfo,\n                  resultsMap: results,\n                  debug,\n                  foreachScope: itemScope,\n                  sourceCheckName: checkName,\n                  sourceCheckConfig: checkConfig,\n                });\n              }\n            } else {\n              await this.scheduleForwardRun(gotoTarget!, {\n                origin: 'on_finish',\n                gotoEvent: onFinish.goto_event,\n                config,\n                dependencyGraph,\n                prInfo,\n                resultsMap: results,\n                debug,\n                foreachScope: [],\n                sourceCheckName: checkName,\n                sourceCheckConfig: checkConfig,\n              });\n            }\n\n            logger.info(`  ‚úì Routed to: ${gotoTarget}`);\n            logger.info(`  Event override: ${onFinish.goto_event || '(none)'}`);\n\n            // If we routed back to the forEach parent, proactively forward-run\n            // its immediate dependents so the next wave executes in one pass.\n            // This mirrors the grouped planner behavior and prevents a second\n            // pass from missing per-item validations in environments where only\n            // the parent would have been scheduled.\n            try {\n              if (gotoTarget === checkName && forEachItems.length > 0) {\n                const childIds: string[] = [];\n                try {\n                  for (const [id, deps] of dependencyGraph.nodes.entries()) {\n                    if (Array.isArray(deps) && deps.includes(checkName)) childIds.push(id);\n                  }\n                } catch {}\n                for (const cid of childIds) {\n                  const cCfg = config.checks?.[cid];\n                  if (!cCfg) continue;\n                  const cMode =\n                    cCfg.fanout === 'map'\n                      ? 'map'\n                      : cCfg.reduce\n                        ? 'reduce'\n                        : cCfg.fanout || 'default';\n                  if (cMode === 'map') {\n                    for (let i = 0; i < forEachItems.length; i++) {\n                      const itemScope: ScopePath = [{ check: checkName, index: i }];\n                      await this.scheduleForwardRun(cid, {\n                        origin: 'on_finish',\n                        gotoEvent: onFinish.goto_event,\n                        config,\n                        dependencyGraph,\n                        prInfo,\n                        resultsMap: results,\n                        debug,\n                        foreachScope: itemScope,\n                        sourceCheckName: checkName,\n                        sourceCheckConfig: checkConfig,\n                      });\n                    }\n                  } else {\n                    await this.scheduleForwardRun(cid, {\n                      origin: 'on_finish',\n                      gotoEvent: onFinish.goto_event,\n                      config,\n                      dependencyGraph,\n                      prInfo,\n                      resultsMap: results,\n                      debug,\n                      foreachScope: [],\n                      sourceCheckName: checkName,\n                      sourceCheckConfig: checkConfig,\n                    });\n                  }\n                }\n              }\n            } catch (err) {\n              const msg = err instanceof Error ? err.message : String(err);\n              logger.debug(`  ‚ö† on_finish: dependent forward-run error: ${msg}`);\n            }\n          } catch (error) {\n            const errorMsg = error instanceof Error ? error.message : String(error);\n            logger.error(\n              `‚úó on_finish: routing failed for \"${checkName}\" ‚Üí \"${gotoTarget}\": ${errorMsg}`\n            );\n            if (error instanceof Error && error.stack) {\n              logger.debug(`Stack trace: ${error.stack}`);\n            }\n            throw error;\n          }\n        }\n\n        logger.info(`‚úì on_finish: completed for \"${checkName}\"`);\n\n        // No hardcoded correction step here; rely on on_finish.run_js in configuration\n        // to schedule any follow-up (e.g., a correction reply) when not all facts are valid.\n      } catch (error) {\n        logger.error(`‚úó on_finish: error for \"${checkName}\": ${error}`);\n      }\n    }\n  }\n\n  // Helper: find all forEach parents that define on_finish\n  private collectForEachParentsWithOnFinish(config: VisorConfig): Array<{\n    checkName: string;\n    checkConfig: CheckConfig;\n    onFinish: OnFinishConfig;\n  }> {\n    const out: Array<{\n      checkName: string;\n      checkConfig: CheckConfig;\n      onFinish: OnFinishConfig;\n    }> = [];\n    for (const [checkName, checkConfig] of Object.entries(config.checks || {})) {\n      if (checkConfig.forEach && checkConfig.on_finish) {\n        out.push({ checkName, checkConfig, onFinish: checkConfig.on_finish });\n      }\n    }\n    return out;\n  }\n\n  // Helper: project results + history into plain objects for sandbox\n  private buildOnFinishContext(results: Map<string, ReviewSummary>): {\n    outputsForContext: Record<string, unknown>;\n    outputsHistoryForContext: Record<string, unknown[]>;\n  } {\n    const outputsForContext: Record<string, unknown> = {};\n    for (const [name, result] of results.entries()) {\n      const r = result as import('./reviewer').ReviewSummary & { output?: unknown };\n      outputsForContext[name] = r.output !== undefined ? r.output : r;\n    }\n    const outputsHistoryForContext: Record<string, unknown[]> = {};\n    try {\n      for (const [check, history] of this.outputHistory.entries()) {\n        outputsHistoryForContext[check] = history as unknown[];\n      }\n    } catch {}\n    return { outputsForContext, outputsHistoryForContext };\n  }\n\n  /**\n   * Execute a check with retry/backoff and routing semantics (on_fail/on_success)\n   */\n  private async executeWithRouting(\n    checkName: string,\n    checkConfig: CheckConfig,\n    provider: import('./providers/check-provider.interface').CheckProvider,\n    providerConfig: CheckProviderConfig,\n    prInfo: PRInfo,\n    dependencyResults: Map<string, ReviewSummary>,\n    sessionInfo: { parentSessionId?: string; reuseSession?: boolean } | undefined,\n    config: VisorConfig | undefined,\n    dependencyGraph: DependencyGraph,\n    debug?: boolean,\n    resultsMap?: Map<string, ReviewSummary>,\n    foreachContext?: { index: number; total: number; parent: string }\n  ): Promise<ReviewSummary> {\n    const log = (msg: string) =>\n      (this.config?.output?.pr_comment ? console.error : console.log)(msg);\n    const maxLoops = config?.routing?.max_loops ?? 10;\n    const defaults = config?.routing?.defaults?.on_fail || {};\n\n    const onFail: OnFailConfig | undefined = checkConfig.on_fail\n      ? { ...defaults, ...checkConfig.on_fail }\n      : Object.keys(defaults).length\n        ? defaults\n        : undefined;\n    const onSuccess: OnSuccessConfig | undefined = checkConfig.on_success;\n\n    let attempt = 1;\n    let loopCount = 0;\n    const seed = `${checkName}-${prInfo.number || 'local'}`;\n\n    const allAncestors = DependencyResolver.getAllDependencies(checkName, dependencyGraph.nodes);\n    // Expose current check's structured output to routing JS (run_js/goto_js)\n    // so templates can reference `output` similarly to `outputs` (deps).\n    let currentRouteOutput: unknown = undefined;\n\n    const evalRunJs = async (expr?: string, error?: unknown): Promise<string[]> => {\n      if (!expr) return [];\n      try {\n        const sandbox = this.getRoutingSandbox();\n        const eventObj = { name: prInfo.eventType || 'manual' } as const;\n        const outHist: Record<string, unknown[]> = {};\n        try {\n          for (const [k, v] of this.outputHistory.entries()) outHist[k] = v;\n        } catch {}\n        // Build outputs_raw object from dependencyResults (-raw aliases)\n        const outRaw: Record<string, unknown> = {};\n        try {\n          for (const [k, v] of (dependencyResults || new Map()).entries()) {\n            if (typeof k !== 'string') continue;\n            if (k.endsWith('-raw')) {\n              const name = k.slice(0, -4);\n              const val: any = (v as any)?.output !== undefined ? (v as any).output : v;\n              outRaw[name] = val;\n            }\n          }\n        } catch {}\n        const scope = {\n          step: { id: checkName, tags: checkConfig.tags || [], group: checkConfig.group },\n          attempt,\n          loop: loopCount,\n          error,\n          foreach: foreachContext\n            ? {\n                index: foreachContext.index,\n                total: foreachContext.total,\n                parent: foreachContext.parent,\n              }\n            : null,\n          outputs: Object.fromEntries((dependencyResults || new Map()).entries()),\n          outputs_history: outHist,\n          outputs_raw: outRaw,\n          output: currentRouteOutput,\n          pr: {\n            number: prInfo.number,\n            title: prInfo.title,\n            author: prInfo.author,\n            branch: prInfo.head,\n            base: prInfo.base,\n          },\n          files: prInfo.files,\n          env: getSafeEnvironmentVariables(),\n          permissions: createPermissionHelpers(\n            resolveAssociationFromEvent((prInfo as any).eventContext, prInfo.authorAssociation),\n            detectLocalMode()\n          ),\n          event: eventObj,\n        };\n        const prelude = `const step = scope.step; const attempt = scope.attempt; const loop = scope.loop; const error = scope.error; const foreach = scope.foreach; const outputs = scope.outputs; const outputs_history = scope.outputs_history; const outputs_raw = scope.outputs_raw; const output = scope.output; const pr = scope.pr; const files = scope.files; const env = scope.env; const event = scope.event; const hasMinPermission = scope.permissions.hasMinPermission; const isOwner = scope.permissions.isOwner; const isMember = scope.permissions.isMember; const isCollaborator = scope.permissions.isCollaborator; const isContributor = scope.permissions.isContributor; const isFirstTimer = scope.permissions.isFirstTimer;`;\n        const code = `${prelude}\\n${expr}`;\n        const result = compileAndRun<unknown>(\n          sandbox,\n          code,\n          { scope },\n          { injectLog: false, wrapFunction: true }\n        );\n        const res = Array.isArray(result) ? result : result ? [result] : [];\n        try {\n          if (debug || process.env.VISOR_DEBUG === 'true') {\n            const efv = (getSafeEnvironmentVariables() || {}).ENABLE_FACT_VALIDATION;\n            const hist = this.outputHistory;\n            let initLen = 0;\n            try {\n              initLen = Array.isArray(hist.get('init-fact-validation'))\n                ? (hist.get('init-fact-validation') as unknown[]).length\n                : 0;\n            } catch {}\n            log(\n              `üîß Debug: run_js(${checkName}) EFV=${String(efv)} init-fact-validation.len=${initLen} expr=${this.truncate(expr, 120)} ‚Üí [${this.redact(res)}]`\n            );\n          }\n        } catch {}\n        return Array.isArray(res) ? res.filter(x => typeof x === 'string') : [];\n      } catch (e) {\n        if (debug) {\n          log(`‚ö†Ô∏è Debug: run_js evaluation failed: ${e instanceof Error ? e.message : String(e)}`);\n        }\n        return [];\n      }\n    };\n\n    const evalGotoJs = async (expr?: string, error?: unknown): Promise<string | null> => {\n      if (!expr) return null;\n      try {\n        const sandbox = this.getRoutingSandbox();\n        const eventObj = { name: prInfo.eventType || 'manual' } as const;\n        const outHist: Record<string, unknown[]> = {};\n        try {\n          for (const [k, v] of this.outputHistory.entries()) outHist[k] = v;\n        } catch {}\n        // Build outputs_raw object from dependencyResults (-raw aliases)\n        const outRaw: Record<string, unknown> = {};\n        try {\n          for (const [k, v] of (dependencyResults || new Map()).entries()) {\n            if (typeof k !== 'string') continue;\n            if (k.endsWith('-raw')) {\n              const name = k.slice(0, -4);\n              const val: any = (v as any)?.output !== undefined ? (v as any).output : v;\n              outRaw[name] = val;\n            }\n          }\n        } catch {}\n        const scope = {\n          step: { id: checkName, tags: checkConfig.tags || [], group: checkConfig.group },\n          attempt,\n          loop: loopCount,\n          error,\n          foreach: foreachContext\n            ? {\n                index: foreachContext.index,\n                total: foreachContext.total,\n                parent: foreachContext.parent,\n              }\n            : null,\n          outputs: Object.fromEntries((dependencyResults || new Map()).entries()),\n          outputs_history: outHist,\n          outputs_raw: outRaw,\n          output: currentRouteOutput,\n          pr: {\n            number: prInfo.number,\n            title: prInfo.title,\n            author: prInfo.author,\n            branch: prInfo.head,\n            base: prInfo.base,\n          },\n          files: prInfo.files,\n          env: getSafeEnvironmentVariables(),\n          permissions: createPermissionHelpers(\n            resolveAssociationFromEvent((prInfo as any).eventContext, prInfo.authorAssociation),\n            detectLocalMode()\n          ),\n          event: eventObj,\n        };\n        const prelude2 = `const step = scope.step; const attempt = scope.attempt; const loop = scope.loop; const error = scope.error; const foreach = scope.foreach; const outputs = scope.outputs; const outputs_history = scope.outputs_history; const outputs_raw = scope.outputs_raw; const output = scope.output; const pr = scope.pr; const files = scope.files; const env = scope.env; const event = scope.event; const hasMinPermission = scope.permissions.hasMinPermission; const isOwner = scope.permissions.isOwner; const isMember = scope.permissions.isMember; const isCollaborator = scope.permissions.isCollaborator; const isContributor = scope.permissions.isContributor; const isFirstTimer = scope.permissions.isFirstTimer;`;\n        const code2 = `${prelude2}\\n${expr}`;\n        const res = compileAndRun<string | null>(\n          sandbox,\n          code2,\n          { scope },\n          { injectLog: false, wrapFunction: true }\n        );\n        if (debug) {\n          log(`üîß Debug: goto_js evaluated ‚Üí ${this.redact(res)}`);\n        }\n        return typeof res === 'string' && res ? res : null;\n      } catch (e) {\n        if (debug) {\n          log(`‚ö†Ô∏è Debug: goto_js evaluation failed: ${e instanceof Error ? e.message : String(e)}`);\n        }\n        return null;\n      }\n    };\n\n    // Phase 3: unified scheduling helper replaces inline nested executor\n\n    // Begin attempts loop\n    // We treat each retry/goto/run as consuming one loop budget entry\n    while (true) {\n      try {\n        try {\n          emitNdjsonFallback('visor.provider', {\n            'visor.check.id': checkName,\n            'visor.provider.type': providerConfig.type || 'ai',\n          });\n        } catch {}\n        const __provStart = Date.now();\n        const context: import('./providers/check-provider.interface').ExecutionContext = {\n          ...sessionInfo,\n          ...this.executionContext,\n        };\n        let res = await withActiveSpan(\n          `visor.check.${checkName}`,\n          {\n            'visor.check.id': checkName,\n            'visor.check.type': providerConfig.type || 'ai',\n            'visor.check.attempt': attempt,\n          },\n          async () => provider.execute(prInfo, providerConfig, dependencyResults, context)\n        );\n        try {\n          const anyRes: any = res as any;\n          const hasOutput = anyRes && typeof anyRes === 'object' && 'output' in anyRes;\n          const hasIssues = anyRes && typeof anyRes === 'object' && 'issues' in anyRes;\n          if (!hasOutput) {\n            res = {\n              issues: hasIssues ? anyRes.issues || [] : [],\n              output: anyRes,\n            } as any;\n          }\n        } catch {}\n        this.recordProviderDuration(checkName, Date.now() - __provStart);\n        // Expose a sensible 'output' for routing JS across all providers.\n        // Some providers (AI) return { output, issues }, others (memory/command/http) may\n        // return the value directly. Prefer explicit `output`, fall back to the whole result.\n        try {\n          const anyRes: any = res as any;\n          currentRouteOutput =\n            anyRes && typeof anyRes === 'object' && 'output' in anyRes ? anyRes.output : anyRes;\n          try {\n            if (process.env.VISOR_DEBUG === 'true') {\n              const hasOut = currentRouteOutput !== undefined;\n              console.error(\n                `[route] ${checkName} currentRouteOutput.has=${String(hasOut)} type=${typeof currentRouteOutput}`\n              );\n            }\n          } catch {}\n          // Proactively track output for grouped execution so subsequent steps\n          // (e.g., human prompts) can read outputs_history immediately. The outer\n          // level will detect __histTracked and skip double-pushing.\n          if (currentRouteOutput !== undefined) {\n            try {\n              let histVal: any = currentRouteOutput as any;\n              if (Array.isArray(histVal)) {\n                // keep as array\n              } else if (histVal !== null && typeof histVal === 'object') {\n                histVal = { ...histVal };\n                if ((histVal as any).ts === undefined) (histVal as any).ts = Date.now();\n              } else {\n                histVal = { text: String(histVal), ts: Date.now() };\n              }\n              this.trackOutputHistory(checkName, histVal);\n              try {\n                (res as any).__histTracked = true;\n              } catch {}\n            } catch {}\n          }\n          if (\n            checkName === 'aggregate-validations' &&\n            (process.env.VISOR_DEBUG === 'true' || debug)\n          ) {\n            try {\n              logger.info(\n                '[aggregate-validations] route-output = ' + JSON.stringify(currentRouteOutput)\n              );\n            } catch {}\n          }\n        } catch {}\n        // Success path\n        // Treat result issues with severity error/critical as a soft-failure eligible for on_fail routing\n        const hasSoftFailure = (res.issues || []).some(\n          i => i.severity === 'error' || i.severity === 'critical'\n        );\n        if (hasSoftFailure && onFail) {\n          if (debug)\n            log(\n              `üîß Debug: Soft failure detected f|| '${checkName}' with ${(res.issues || []).length} issue(s)`\n            );\n          const lastError: any = {\n            message: 'soft-failure: issues present',\n            code: 'soft_failure',\n            issues: res.issues,\n          };\n          const dynamicRun = await evalRunJs(onFail.run_js, lastError);\n          let runList = [...(onFail.run || []), ...dynamicRun].filter(Boolean);\n          runList = Array.from(new Set(runList));\n          if (debug) log(`üîß Debug: on_fail.run (soft) list = [${runList.join(', ')}]`);\n          if (runList.length > 0) {\n            try {\n              require('./logger').logger.info(\n                `‚ñ∂ on_fail.run: scheduling [${runList.join(', ')}] after '${checkName}'`\n              );\n            } catch {}\n            loopCount++;\n            if (loopCount > maxLoops) {\n              return {\n                issues: [\n                  {\n                    file: 'system',\n                    line: 0,\n                    ruleId: `${checkName}/routing/loop_budget_exceeded`,\n                    message: `Routing loop budget exceeded (max_loops=${maxLoops}) during on_fail run`,\n                    severity: 'error',\n                    category: 'logic',\n                  },\n                ],\n              } as ReviewSummary;\n            }\n            if (debug) log(`üîß Debug: on_fail.run (soft) executing [${runList.join(', ')}]`);\n            for (const stepId of runList) {\n              const tcfg = config!.checks?.[stepId] as\n                | import('./types/config').CheckConfig\n                | undefined;\n              const mode =\n                tcfg?.fanout === 'map'\n                  ? 'map'\n                  : tcfg?.reduce\n                    ? 'reduce'\n                    : tcfg?.fanout || 'default';\n              const inItem = !!foreachContext;\n              const items =\n                checkConfig.forEach && Array.isArray(currentRouteOutput)\n                  ? (currentRouteOutput as unknown[])\n                  : [];\n              if (!inItem && mode === 'map' && items.length > 0) {\n                for (let i = 0; i < items.length; i++) {\n                  const itemScope: ScopePath = [{ check: checkName, index: i }];\n                  await this.runNamedCheck(stepId, itemScope, {\n                    config: config!,\n                    dependencyGraph,\n                    prInfo,\n                    resultsMap: resultsMap || new Map(),\n                    debug: !!debug,\n                    overlay: dependencyResults,\n                  });\n                }\n              } else {\n                const scopeForRun: ScopePath = foreachContext\n                  ? [{ check: foreachContext.parent, index: foreachContext.index }]\n                  : [];\n                await this.runNamedCheck(stepId, scopeForRun, {\n                  config: config!,\n                  dependencyGraph,\n                  prInfo,\n                  resultsMap: resultsMap || new Map(),\n                  debug: !!debug,\n                  overlay: dependencyResults,\n                });\n              }\n            }\n          }\n          let target = await evalGotoJs(onFail.goto_js, lastError);\n          if (!target && onFail.goto) target = onFail.goto;\n          if (debug) log(`üîß Debug: on_fail.goto (soft) target = ${target}`);\n          if (target) {\n            try {\n              require('./logger').logger.info(\n                `‚Ü™ on_fail.goto: jumping to '${target}' from '${checkName}'`\n              );\n            } catch {}\n            if (!allAncestors.includes(target)) {\n              // New behavior: allow goto to any step and forward-run dependents\n              await this.scheduleForwardRun(target, {\n                origin: 'on_fail',\n                gotoEvent: onFail.goto_event,\n                config: config!,\n                dependencyGraph,\n                prInfo,\n                resultsMap: resultsMap || new Map(),\n                debug: !!debug,\n                foreachScope: foreachContext\n                  ? [{ check: foreachContext.parent, index: foreachContext.index }]\n                  : undefined,\n                sourceCheckName: checkName,\n                sourceCheckConfig: checkConfig,\n                sourceOutputForItems: currentRouteOutput,\n              });\n            } else {\n              // Run ancestor targets through the forward-run scheduler as well, so the\n              // entire dependent chain (target + transitive dependents) executes in the\n              // next wave. This keeps execution order deterministic and test counts stable.\n              loopCount++;\n              if (loopCount > maxLoops) {\n                throw new Error(\n                  `Routing loop budget exceeded (max_loops=${maxLoops}) during on_fail goto`\n                );\n              }\n              await this.scheduleForwardRun(target, {\n                origin: 'on_fail',\n                gotoEvent: onFail.goto_event,\n                config: config!,\n                dependencyGraph,\n                prInfo,\n                resultsMap: resultsMap || new Map(),\n                debug: !!debug,\n                foreachScope: foreachContext\n                  ? [{ check: foreachContext.parent, index: foreachContext.index }]\n                  : undefined,\n                sourceCheckName: checkName,\n                sourceCheckConfig: checkConfig,\n                sourceOutputForItems: currentRouteOutput,\n              });\n            }\n          }\n\n          const retryMax = onFail.retry?.max ?? 0;\n          const base = onFail.retry?.backoff?.delay_ms ?? 0;\n          const mode = onFail.retry?.backoff?.mode ?? 'fixed';\n          if (attempt <= retryMax) {\n            loopCount++;\n            if (loopCount > maxLoops) {\n              throw new Error(`Routing loop budget exceeded (max_loops=${maxLoops}) during retry`);\n            }\n            const delay = base > 0 ? this.computeBackoffDelay(attempt, mode, base, seed) : 0;\n            if (debug)\n              log(\n                `üîÅ Debug: retrying '${checkName}' (soft) attempt ${attempt + 1}/${retryMax + 1} after ${delay}ms`\n              );\n            if (delay > 0) await this.sleep(delay);\n            attempt++;\n            continue; // loop\n          }\n          // No retry configured: return existing result\n          return res;\n        }\n        // Note: previously we re-ran the source check after goto to \"re-validate with new state\".\n        // This caused success‚Üígoto‚Üíre-run loops for unconditional gotos. We no longer re-run the\n        // source after goto; goto only schedules the target and returns.\n        if (onSuccess) {\n          // Gating for inline on_success handling based on origin:\n          //  - origin === 'on_success': suppress entirely; scheduleForwardRun will handle dependents/goto.\n          //  - origin === 'on_fail': allow on_success.run (side-effects) but suppress goto to avoid tight loops.\n          const __suppressAllOnSuccess = ((context as any).origin || 'inline') === 'on_success';\n          const __suppressGotoOnSuccess = ((context as any).origin || 'inline') === 'on_fail';\n          if (!__suppressAllOnSuccess) {\n            // Compute run list\n            const dynamicRun = await evalRunJs(onSuccess.run_js);\n            let runList = [...(onSuccess.run || []), ...dynamicRun].filter(Boolean);\n            try {\n              if (process.env.VISOR_DEBUG === 'true' || debug) {\n                logger.info(\n                  `on_success.run (${checkName}): dynamicRun=[${dynamicRun.join(', ')}] run=[${(\n                    onSuccess.run || []\n                  ).join(', ')}]`\n                );\n              }\n            } catch {}\n            // Deduplicate requested steps; rely on per-step max_runs/one_shot tags instead of hardcoded names\n            runList = Array.from(new Set(runList));\n            if (runList.length > 0) {\n              try {\n                require('./logger').logger.info(\n                  `‚ñ∂ on_success.run: scheduling [${Array.from(new Set(runList)).join(', ')}] after '${checkName}'`\n                );\n              } catch {}\n              loopCount++;\n              if (loopCount > maxLoops) {\n                const issueSummary = {\n                  issues: [\n                    {\n                      file: 'system',\n                      line: 0,\n                      ruleId: `${checkName}/routing/loop_budget_exceeded`,\n                      message: `Routing loop budget exceeded (max_loops=${maxLoops}) during on_success run`,\n                      severity: 'error',\n                      category: 'logic',\n                    },\n                  ],\n                } as ReviewSummary;\n                try {\n                  if (resultsMap) resultsMap.set(checkName, issueSummary);\n                } catch {}\n                return issueSummary;\n              }\n              for (const stepId of runList) {\n                // One-shot guard (generalized): if the target step has a 'one_shot' tag\n                // and it already executed in this run, skip rescheduling it.\n                try {\n                  const tcfg = (config!.checks || {})[stepId] as\n                    | import('./types/config').CheckConfig\n                    | undefined;\n                  const tags = (tcfg?.tags || []) as string[];\n                  const isOneShot = Array.isArray(tags) && tags.includes('one_shot');\n                  if (isOneShot && (this.executionStats.get(stepId)?.totalRuns || 0) > 0) {\n                    require('./logger').logger.info(\n                      `‚è≠ on_success.run: skipping one_shot '${stepId}' (already executed)`\n                    );\n                    continue;\n                  }\n                } catch {}\n                const tcfg = config!.checks?.[stepId] as\n                  | import('./types/config').CheckConfig\n                  | undefined;\n                const mode =\n                  tcfg?.fanout === 'map'\n                    ? 'map'\n                    : tcfg?.reduce\n                      ? 'reduce'\n                      : tcfg?.fanout || 'default';\n                const inItem = !!foreachContext;\n                const items =\n                  checkConfig.forEach && Array.isArray(currentRouteOutput)\n                    ? (currentRouteOutput as unknown[])\n                    : [];\n                if (!inItem && mode === 'map' && items.length > 0) {\n                  for (let i = 0; i < items.length; i++) {\n                    const itemScope: ScopePath = [{ check: checkName, index: i }];\n                    await this.runNamedCheck(stepId, itemScope, {\n                      config: config!,\n                      dependencyGraph,\n                      prInfo,\n                      resultsMap: resultsMap || new Map(),\n                      debug: !!debug,\n                      overlay: dependencyResults,\n                    });\n                  }\n                } else {\n                  const scopeForRun: ScopePath = foreachContext\n                    ? [{ check: foreachContext.parent, index: foreachContext.index }]\n                    : [];\n                  await this.runNamedCheck(stepId, scopeForRun, {\n                    config: config!,\n                    dependencyGraph,\n                    prInfo,\n                    resultsMap: resultsMap || new Map(),\n                    debug: !!debug,\n                    overlay: dependencyResults,\n                  });\n                }\n              }\n            } else {\n              // Provide a lightweight reason when nothing is scheduled via on_success.run\n              try {\n                const assoc = resolveAssociationFromEvent(\n                  (prInfo as any)?.eventContext,\n                  prInfo.authorAssociation\n                );\n                const perms = createPermissionHelpers(assoc, detectLocalMode());\n                const allowedMember = perms.hasMinPermission('MEMBER');\n                let intent: string | undefined;\n                try {\n                  intent = (res as any)?.output?.intent;\n                } catch {}\n                require('./logger').logger.info(\n                  `‚è≠ on_success.run: none after '${checkName}' (event=${prInfo.eventType || 'manual'}, intent=${intent || 'n/a'}, assoc=${assoc || 'unknown'}, memberOrHigher=${allowedMember})`\n                );\n              } catch {}\n            }\n          }\n          // Optional goto\n          if (!__suppressAllOnSuccess && !__suppressGotoOnSuccess) {\n            let target = await evalGotoJs(onSuccess.goto_js);\n            if (!target && onSuccess.goto) target = onSuccess.goto;\n            if (target) {\n              try {\n                require('./logger').logger.info(\n                  `‚Ü™ on_success.goto: jumping to '${target}' from '${checkName}'`\n                );\n              } catch {}\n              if (!allAncestors.includes(target)) {\n                await this.scheduleForwardRun(target, {\n                  origin: 'on_success',\n                  gotoEvent: onSuccess.goto_event,\n                  config: config!,\n                  dependencyGraph,\n                  prInfo,\n                  resultsMap: resultsMap || new Map(),\n                  debug: !!debug,\n                  foreachScope: foreachContext\n                    ? [{ check: foreachContext.parent, index: foreachContext.index }]\n                    : undefined,\n                  sourceCheckName: checkName,\n                  sourceCheckConfig: checkConfig,\n                  sourceOutputForItems: currentRouteOutput,\n                });\n              } else {\n                loopCount++;\n                if (loopCount > maxLoops) {\n                  const issueSummary = {\n                    issues: [\n                      {\n                        file: 'system',\n                        line: 0,\n                        ruleId: `${checkName}/routing/loop_budget_exceeded`,\n                        message: `Routing loop budget exceeded (max_loops=${maxLoops}) during on_success goto`,\n                        severity: 'error',\n                        category: 'logic',\n                      },\n                    ],\n                  } as ReviewSummary;\n                  try {\n                    if (resultsMap) resultsMap.set(checkName, issueSummary);\n                  } catch {}\n                  return issueSummary;\n                }\n                // on_success.goto does not support retry/backoff in schema; immediate rerun for ancestor case\n                await this.runNamedCheck(\n                  target,\n                  foreachContext\n                    ? [{ check: foreachContext.parent, index: foreachContext.index }]\n                    : [],\n                  {\n                    config: config!,\n                    dependencyGraph,\n                    prInfo,\n                    resultsMap: resultsMap || new Map(),\n                    debug: !!debug,\n                    eventOverride: onSuccess.goto_event,\n                  }\n                );\n              }\n            }\n          }\n        }\n        // No re-run after goto\n        return res;\n      } catch (err) {\n        // Failure path\n        if (!onFail) {\n          throw err; // no routing policy\n        }\n\n        const lastError = err instanceof Error ? err : new Error(String(err));\n\n        // Dynamic compute run/goto\n        const dynamicRun = await evalRunJs(onFail.run_js, lastError);\n        let runList = [...(onFail.run || []), ...dynamicRun].filter(Boolean);\n        // Dedup while preserving order\n        runList = Array.from(new Set(runList));\n\n        if (runList.length > 0) {\n          try {\n            require('./logger').logger.info(\n              `‚ñ∂ on_fail.run: scheduling [${runList.join(', ')}] after '${checkName}'`\n            );\n          } catch {}\n          loopCount++;\n          if (loopCount > maxLoops) {\n            throw new Error(\n              `Routing loop budget exceeded (max_loops=${maxLoops}) during on_fail run`\n            );\n          }\n          if (debug) log(`üîß Debug: on_fail.run executing [${runList.join(', ')}]`);\n          for (const stepId of runList) {\n            await this.runNamedCheck(stepId, [], {\n              config: config!,\n              dependencyGraph,\n              prInfo,\n              resultsMap: resultsMap || new Map(),\n              debug: !!debug,\n            });\n          }\n        }\n\n        let target = await evalGotoJs(onFail.goto_js, lastError);\n        if (!target && onFail.goto) target = onFail.goto;\n        if (target) {\n          try {\n            require('./logger').logger.info(\n              `‚Ü™ on_fail.goto: jumping to '${target}' from '${checkName}'`\n            );\n          } catch {}\n          if (!allAncestors.includes(target)) {\n            await this.scheduleForwardRun(target, {\n              origin: 'on_fail',\n              gotoEvent: onFail.goto_event,\n              config: config!,\n              dependencyGraph,\n              prInfo,\n              resultsMap: resultsMap || new Map(),\n              debug: !!debug,\n              foreachScope: [],\n              sourceCheckName: checkName,\n              sourceCheckConfig: checkConfig,\n              sourceOutputForItems: undefined,\n            });\n          } else {\n            loopCount++;\n            if (loopCount > maxLoops) {\n              return {\n                issues: [\n                  {\n                    file: 'system',\n                    line: 0,\n                    ruleId: `${checkName}/routing/loop_budget_exceeded`,\n                    message: `Routing loop budget exceeded (max_loops=${maxLoops}) during on_fail goto`,\n                    severity: 'error',\n                    category: 'logic',\n                  },\n                ],\n              } as ReviewSummary;\n            }\n            await this.runNamedCheck(target, [], {\n              config: config!,\n              dependencyGraph,\n              prInfo,\n              resultsMap: resultsMap || new Map(),\n              debug: !!debug,\n              eventOverride: onFail.goto_event,\n              overlay: dependencyResults,\n            });\n          }\n        }\n\n        // Retry if allowed\n        const retryMax = onFail.retry?.max ?? 0;\n        const base = onFail.retry?.backoff?.delay_ms ?? 0;\n        const mode = onFail.retry?.backoff?.mode ?? 'fixed';\n        if (attempt <= retryMax) {\n          loopCount++;\n          if (loopCount > maxLoops) {\n            return {\n              issues: [\n                {\n                  file: 'system',\n                  line: 0,\n                  ruleId: `${checkName}/routing/loop_budget_exceeded`,\n                  message: `Routing loop budget exceeded (max_loops=${maxLoops}) during retry`,\n                  severity: 'error',\n                  category: 'logic',\n                },\n              ],\n            } as ReviewSummary;\n          }\n          const delay = base > 0 ? this.computeBackoffDelay(attempt, mode, base, seed) : 0;\n          if (debug)\n            log(\n              `üîÅ Debug: retrying '${checkName}' attempt ${attempt + 1}/${retryMax + 1} after ${delay}ms`\n            );\n          if (delay > 0) await this.sleep(delay);\n          attempt++;\n          continue; // loop\n        }\n\n        // Exhausted retry budget; rethrow\n        throw lastError;\n      }\n    }\n  }\n\n  /**\n   * Set webhook context on a provider if it supports it\n   */\n  private setProviderWebhookContext(\n    provider: import('./providers/check-provider.interface').CheckProvider\n  ): void {\n    if (this.webhookContext && provider.setWebhookContext) {\n      provider.setWebhookContext(this.webhookContext.webhookData);\n    }\n  }\n\n  /**\n   * Filter checks based on tag filter configuration\n   */\n  private filterChecksByTags(\n    checks: string[],\n    config: import('./types/config').VisorConfig | undefined,\n    tagFilter: import('./types/config').TagFilter | undefined\n  ): string[] {\n    // When no tag filter is specified, include only untagged checks by default.\n    // Tagged checks are opt-in unless tag_filter is provided.\n    return checks.filter(checkName => {\n      const checkConfig = config?.checks?.[checkName];\n      if (!checkConfig) {\n        // If no config for this check, include it by default\n        return true;\n      }\n\n      const checkTags = checkConfig.tags || [];\n\n      // If no tag filter is specified, include only untagged checks.\n      if (!tagFilter || (!tagFilter.include && !tagFilter.exclude)) {\n        return checkTags.length === 0;\n      }\n\n      // If check has no tags and a tag filter is specified, include it (untagged checks always run)\n      if (checkTags.length === 0) {\n        return true;\n      }\n\n      // Check exclude tags first (if any exclude tag matches, skip the check)\n      if (tagFilter.exclude && tagFilter.exclude.length > 0) {\n        const hasExcludedTag = tagFilter.exclude.some(tag => checkTags.includes(tag));\n        if (hasExcludedTag) return false;\n      }\n\n      // Check include tags (if specified, at least one must match)\n      if (tagFilter.include && tagFilter.include.length > 0) {\n        const hasIncludedTag = tagFilter.include.some(tag => checkTags.includes(tag));\n        if (!hasIncludedTag) return false;\n      }\n\n      return true;\n    });\n  }\n\n  // Resolve a sensible fallback goto target without hardcoding names.\n  // Strategy: inspect the current check's depends_on list and expand any\n  // union tokens (e.g., \"a|b\"). Prefer a dependency whose `on` includes the\n  // current event; otherwise, fall back to the first existing dependency.\n  private resolveFallbackGotoTarget(\n    checkConfig: import('./types/config').CheckConfig,\n    prInfo: PRInfo,\n    config: import('./types/config').VisorConfig\n  ): string | null {\n    try {\n      const depTokens: any[] = Array.isArray(checkConfig.depends_on)\n        ? checkConfig.depends_on\n        : checkConfig.depends_on\n          ? [checkConfig.depends_on]\n          : [];\n      const expand = (tok: any): string[] =>\n        typeof tok === 'string' && tok.includes('|')\n          ? tok\n              .split('|')\n              .map(s => s.trim())\n              .filter(Boolean)\n          : tok\n            ? [String(tok)]\n            : [];\n      const candidates = depTokens.flatMap(expand).filter(Boolean) as string[];\n      if (candidates.length === 0) return null;\n      const event = prInfo.eventType || 'manual';\n      const matchEvent = (name: string): boolean => {\n        const cfg = (config.checks || {})[name];\n        if (!cfg) return false;\n        const triggers: any[] = Array.isArray(cfg.on) ? (cfg.on as any[]) : cfg.on ? [cfg.on] : [];\n        if (triggers.length === 0) return true; // treat untagged as match-all\n        return triggers.includes(event as any);\n      };\n      for (const n of candidates) if ((config.checks || {})[n] && matchEvent(n)) return n;\n      for (const n of candidates) if ((config.checks || {})[n]) return n;\n      return null;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Execute checks on the local repository\n   */\n  async executeChecks(options: CheckExecutionOptions): Promise<AnalysisResult> {\n    const startTime = Date.now();\n    const timestamp = new Date().toISOString();\n\n    try {\n      // Expose CLI debug to internal helpers for ad-hoc diagnostics\n      try {\n        (this as any).globalDebug = Boolean((options as any)?.debug);\n      } catch {}\n      // Fresh in-memory state for every engine execution.\n      // Do not wipe file-based state here; tests can clean those explicitly.\n      try {\n        const storage = options.config?.memory?.storage || 'memory';\n        if (storage !== 'file') {\n          MemoryStore.resetInstance();\n        }\n      } catch {}\n\n      // Initialize memory store if configured\n      if (options.config?.memory) {\n        const memoryStore = MemoryStore.getInstance(options.config.memory);\n        await memoryStore.initialize();\n        logger.debug('Memory store initialized');\n      }\n\n      // Set custom tools if configured\n      if (options.config?.tools) {\n        this.providerRegistry.setCustomTools(options.config.tools);\n        logger.debug(`Registered ${Object.keys(options.config.tools).length} custom tools`);\n      }\n\n      // Reset per-run on_finish loop counters\n      this.onFinishLoopCounts.clear();\n      // Reset per-run forEach wave counters\n      this.forEachWaveCounts.clear();\n      // Store webhook context if provided\n      this.webhookContext = options.webhookContext;\n\n      // Determine where to send log messages based on output format\n      const logFn = (msg: string) => logger.info(msg);\n\n      // Initialize GitHub checks if enabled\n      if (options.githubChecks?.enabled && options.githubChecks.octokit) {\n        await this.initializeGitHubChecks(options, logFn);\n      }\n\n      // Analyze the repository\n      logFn('üîç Analyzing local git repository...');\n      const repositoryInfo = await this.gitAnalyzer.analyzeRepository();\n\n      if (!repositoryInfo.isGitRepository) {\n        // Complete GitHub checks with error if they were initialized\n        if (this.checkRunMap) {\n          await this.completeGitHubChecksWithError('Not a git repository or no changes found');\n        }\n\n        return this.createErrorResult(\n          repositoryInfo,\n          'Not a git repository or no changes found',\n          startTime,\n          timestamp,\n          options.checks\n        );\n      }\n\n      // Convert to PRInfo format for compatibility with existing reviewer\n      const prInfo = this.gitAnalyzer.toPRInfo(repositoryInfo);\n      // If caller provided an explicit event type (e.g., tests/CLI manual runs),\n      // propagate it into PRInfo so event-based filtering treats 'manual' checks\n      // as eligible. This keeps unit/integration tests deterministic without\n      // relaxing the conservative filtering policy.\n      try {\n        const evt = (options.webhookContext as any)?.eventType;\n        if (evt) (prInfo as any).eventType = evt;\n      } catch {}\n\n      // Apply tag filtering if specified\n      const filteredChecks = this.filterChecksByTags(\n        options.checks,\n        options.config,\n        options.tagFilter || options.config?.tag_filter\n      );\n\n      if (filteredChecks.length === 0) {\n        logger.warn('‚ö†Ô∏è No checks match the tag filter criteria');\n        // Complete GitHub checks with no checks message if they were initialized\n        if (this.checkRunMap) {\n          await this.completeGitHubChecksWithError('No checks match the tag filter criteria');\n        }\n        return this.createErrorResult(\n          repositoryInfo,\n          'No checks match the tag filter criteria',\n          startTime,\n          timestamp,\n          options.checks\n        );\n      }\n\n      // Update GitHub checks to in-progress status\n      if (this.checkRunMap) {\n        await this.updateGitHubChecksInProgress(options);\n      }\n\n      // Execute checks using the existing PRReviewer\n      logFn(`ü§ñ Executing checks: ${filteredChecks.join(', ')}`);\n      const reviewSummary = await this.executeReviewChecks(\n        prInfo,\n        filteredChecks,\n        options.timeout,\n        options.config,\n        options.outputFormat,\n        options.debug,\n        options.maxParallelism,\n        options.failFast\n      );\n\n      // Complete GitHub checks with results\n      if (this.checkRunMap) {\n        await this.completeGitHubChecksWithResults(reviewSummary, options, prInfo);\n      }\n\n      const executionTime = Date.now() - startTime;\n\n      // Collect debug information when debug mode is enabled\n      let debugInfo: import('./output-formatters').DebugInfo | undefined;\n      if (options.debug && reviewSummary.debug) {\n        debugInfo = {\n          provider: reviewSummary.debug.provider,\n          model: reviewSummary.debug.model,\n          processingTime: reviewSummary.debug.processingTime,\n          parallelExecution: options.checks.length > 1,\n          checksExecuted: options.checks,\n          totalApiCalls: reviewSummary.debug.totalApiCalls || options.checks.length,\n          apiCallDetails: reviewSummary.debug.apiCallDetails,\n        };\n      }\n\n      // Build execution statistics\n      const executionStatistics = this.buildExecutionStatistics();\n\n      // Expose a snapshot of outputs history in the reviewSummary.\n      // Fill missing entries using execution statistics so tests that assert\n      // on run counts (by history length) are stable even if providers didn't\n      // emit outputs on every run.\n      try {\n        const histSnap = this.getOutputHistorySnapshot();\n        try {\n          const stats = this.buildExecutionStatistics();\n          for (const s of stats.checks) {\n            const name = s.checkName;\n            const want = Math.max(0, s.totalRuns || 0);\n            const have = Array.isArray(histSnap[name]) ? histSnap[name].length : 0;\n            if (want > have) {\n              const arr = Array.isArray(histSnap[name]) ? histSnap[name] : [];\n              for (let i = have; i < want; i++) arr.push(null);\n              histSnap[name] = arr;\n            }\n          }\n        } catch {}\n        (reviewSummary as any).history = histSnap;\n      } catch {}\n\n      return {\n        repositoryInfo,\n        reviewSummary,\n        executionTime,\n        timestamp,\n        checksExecuted: filteredChecks,\n        executionStatistics,\n        debug: debugInfo,\n      };\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Unknown error occurred';\n      logger.error('Error executing checks: ' + message);\n\n      // Complete GitHub checks with error if they were initialized\n      if (this.checkRunMap) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n        await this.completeGitHubChecksWithError(errorMessage);\n      }\n\n      // In strict test modes, surface provider/engine errors to callers so tests fail fast.\n      // Triggers when running via Jest, our YAML test runner (VISOR_TEST_MODE), or explicit opt‚Äëin.\n      const strictEnv = process.env.VISOR_STRICT_ERRORS === 'true';\n      if (strictEnv) {\n        throw error;\n      }\n\n      const fallbackRepositoryInfo: GitRepositoryInfo = {\n        title: 'Error during analysis',\n        body: `Error: ${message || 'Unknown error'}`,\n        author: 'system',\n        base: 'main',\n        head: 'HEAD',\n        files: [],\n        totalAdditions: 0,\n        totalDeletions: 0,\n        isGitRepository: false,\n        workingDirectory: options.workingDirectory || process.cwd(),\n      };\n\n      return this.createErrorResult(\n        fallbackRepositoryInfo,\n        message || 'Unknown error occurred',\n        startTime,\n        timestamp,\n        options.checks\n      );\n    }\n  }\n\n  /**\n   * Execute tasks with controlled parallelism using a pool pattern\n   */\n  private async executeWithLimitedParallelism<T>(\n    tasks: (() => Promise<T>)[],\n    maxParallelism: number,\n    failFast?: boolean\n  ): Promise<PromiseSettledResult<T>[]> {\n    // If there is nothing to do, return early before validating parallelism.\n    // This avoids spuriously throwing when the caller computed 0 parallelism\n    // for an empty task set (which is a valid no-op scenario).\n    if (tasks.length === 0) {\n      return [];\n    }\n\n    // Validate pool size only when there is work to run.\n    if (maxParallelism <= 0) {\n      // Be forgiving and default to 1 instead of throwing ‚Äî callers may\n      // derive parallelism from dynamic level sizes that occasionally\n      // evaluate to 0. With tasks present, we need at least one worker.\n      maxParallelism = 1;\n    }\n\n    const results: PromiseSettledResult<T>[] = new Array(tasks.length);\n    let currentIndex = 0;\n    let shouldStop = false;\n\n    // Worker function that processes tasks\n    const worker = async (): Promise<void> => {\n      while (currentIndex < tasks.length && !shouldStop) {\n        const taskIndex = currentIndex++;\n        if (taskIndex >= tasks.length) break;\n\n        try {\n          const result = await tasks[taskIndex]();\n          results[taskIndex] = { status: 'fulfilled', value: result };\n\n          // Check if we should stop due to fail-fast\n          if (failFast && this.shouldFailFast(result)) {\n            shouldStop = true;\n            break;\n          }\n        } catch (error) {\n          results[taskIndex] = { status: 'rejected', reason: error };\n\n          // If fail-fast is enabled and we have an error, stop execution\n          if (failFast) {\n            shouldStop = true;\n            break;\n          }\n        }\n      }\n    };\n\n    // Create workers up to the parallelism limit\n    const workers: Promise<void>[] = [];\n    const workerCount = Math.min(maxParallelism, tasks.length);\n\n    for (let i = 0; i < workerCount; i++) {\n      workers.push(worker());\n    }\n\n    // Wait for all workers to complete\n    await Promise.all(workers);\n\n    return results;\n  }\n\n  /**\n   * Execute review checks using parallel execution for multiple AI checks\n   */\n  private async executeReviewChecks(\n    prInfo: PRInfo,\n    checks: string[],\n    timeout?: number,\n    config?: import('./types/config').VisorConfig,\n    outputFormat?: string,\n    debug?: boolean,\n    maxParallelism?: number,\n    failFast?: boolean\n  ): Promise<ReviewSummary> {\n    // Store config for use in filtering\n    this.config = config;\n\n    // Make provider-level debug discoverable to providers when engine debug is enabled.\n    // This lets AI providers emit per-call debug info used by E2E tests.\n    try {\n      if (debug) process.env.VISOR_PROVIDER_DEBUG = 'true';\n    } catch {}\n\n    // Determine where to send log messages based on output format\n    // Use debug logger for internal engine messages; important notices use logger.warn/info directly.\n    const logFn = (msg: string) => logger.debug(msg);\n\n    // Only output debug messages if debug mode is enabled\n    if (debug) {\n      logFn(`üîß Debug: executeReviewChecks called with checks: ${JSON.stringify(checks)}`);\n      logFn(`üîß Debug: Config available: ${!!config}, Config has checks: ${!!config?.checks}`);\n    }\n\n    // Filter checks based on current event type to prevent execution of checks that shouldn't run\n    const filteredChecks = this.filterChecksByEvent(checks, config, prInfo, logFn, debug);\n    if (filteredChecks.length !== checks.length && debug) {\n      logFn(\n        `üîß Debug: Event filtering reduced checks from ${checks.length} to ${filteredChecks.length}: ${JSON.stringify(filteredChecks)}`\n      );\n    }\n\n    // Use filtered checks for execution\n    checks = filteredChecks;\n\n    // If we have a config with individual check definitions, prefer dependency-aware execution\n    // even for a single check, so provider types other than 'ai' work consistently.\n    const allConfigured = config?.checks ? checks.every(name => !!config.checks![name]) : false;\n    if (allConfigured) {\n      if (debug) {\n        logFn(\n          `üîß Debug: Using dependency-aware execution for ${checks.length} configured check(s)`\n        );\n      }\n      return await this.executeDependencyAwareChecks(\n        prInfo,\n        checks,\n        timeout,\n        config,\n        logFn,\n        debug,\n        maxParallelism,\n        failFast,\n        config?.tag_filter\n      );\n    }\n\n    // Single check execution (existing logic)\n    if (checks.length === 1) {\n      if (debug) {\n        logFn(`üîß Debug: Using single check execution for: ${checks[0]}`);\n      }\n\n      // If we have a config definition for this check, use it\n      if (config?.checks?.[checks[0]]) {\n        return await this.executeSingleConfiguredCheck(prInfo, checks[0], timeout, config, logFn);\n      }\n\n      // Try provider system for single checks\n      if (this.providerRegistry.hasProvider(checks[0])) {\n        const provider = this.providerRegistry.getProviderOrThrow(checks[0]);\n        this.setProviderWebhookContext(provider);\n        const providerConfig: CheckProviderConfig = {\n          type: checks[0],\n          prompt: 'all',\n          eventContext: this.enrichEventContext(prInfo.eventContext),\n          ai: timeout ? { timeout } : undefined,\n        };\n        const __provStart = Date.now();\n        const result = await provider.execute(\n          prInfo,\n          providerConfig,\n          undefined,\n          this.executionContext\n        );\n        this.recordProviderDuration(checks[0], Date.now() - __provStart);\n\n        // Prefix issues with check name for consistent grouping\n        const prefixedIssues = (result.issues || []).map(issue => ({\n          ...issue,\n          ruleId: `${checks[0]}/${issue.ruleId}`,\n        }));\n\n        return {\n          ...result,\n          issues: prefixedIssues,\n        };\n      }\n    }\n\n    // Check if 'ai' provider is available for focus-based checks (legacy support)\n    if (this.providerRegistry.hasProvider('ai')) {\n      if (debug) {\n        logFn(`üîß Debug: Using AI provider with focus mapping`);\n      }\n      const provider = this.providerRegistry.getProviderOrThrow('ai');\n      this.setProviderWebhookContext(provider);\n\n      let focus = 'all';\n      let checkName = 'all';\n      if (checks.length === 1) {\n        checkName = checks[0];\n        if (checks[0] === 'security' || checks[0] === 'performance' || checks[0] === 'style') {\n          focus = checks[0];\n        }\n      } else {\n        // For multiple checks, combine them into 'all' focus\n        focus = 'all';\n      }\n\n      const providerConfig: CheckProviderConfig = {\n        type: 'ai',\n        prompt: focus,\n        focus: focus,\n        checkName,\n        eventContext: this.enrichEventContext(prInfo.eventContext),\n        ai: timeout ? { timeout } : undefined,\n        // Inherit global AI provider and model settings if config is available\n        ai_provider: config?.ai_provider,\n        ai_model: config?.ai_model,\n      };\n\n      const __provStart2 = Date.now();\n      const result = await provider.execute(\n        prInfo,\n        providerConfig,\n        undefined,\n        this.executionContext\n      );\n      this.recordProviderDuration(checkName, Date.now() - __provStart2);\n\n      // Prefix issues with check name for consistent grouping\n      const prefixedIssues = (result.issues || []).map(issue => ({\n        ...issue,\n        ruleId: `${checkName}/${issue.ruleId}`,\n      }));\n\n      return {\n        ...result,\n        issues: prefixedIssues,\n      };\n    }\n\n    // Fallback to existing PRReviewer for backward compatibility\n    if (debug) {\n      logFn(`üîß Debug: Using legacy PRReviewer fallback`);\n    }\n    const focusMap: Record<string, ReviewOptions['focus']> = {\n      security: 'security',\n      performance: 'performance',\n      style: 'style',\n      all: 'all',\n      architecture: 'all',\n    };\n\n    let focus: ReviewOptions['focus'] = 'all';\n    if (checks.length === 1 && focusMap[checks[0]]) {\n      focus = focusMap[checks[0]];\n    }\n\n    return await this.reviewer.reviewPR('local', 'repository', 0, prInfo, {\n      focus,\n      format: 'table',\n    });\n  }\n\n  /**\n   * Execute review checks and return grouped results with statistics for new architecture\n   */\n  public async executeGroupedChecks(\n    prInfo: PRInfo,\n    checks: string[],\n    timeout?: number,\n    config?: import('./types/config').VisorConfig,\n    outputFormat?: string,\n    debug?: boolean,\n    maxParallelism?: number,\n    failFast?: boolean,\n    tagFilter?: import('./types/config').TagFilter,\n    _pauseGate?: () => Promise<void>\n  ): Promise<ExecutionResult> {\n    // Always reset per-run state at the beginning of a grouped execution to ensure\n    // stage-local accounting in flows. This prevents leakage of executionStats and\n    // forward-run guards across test stages (e.g., pr-review-e2e-flow).\n    try {\n      this.resetPerRunState();\n    } catch {}\n    // Determine where to send log messages based on output format\n    const logFn =\n      outputFormat === 'json' || outputFormat === 'sarif'\n        ? debug\n          ? console.error\n          : () => {}\n        : console.log;\n\n    // Only output debug messages if debug mode is enabled\n    if (debug) {\n      logger.debug(`üîß Debug: executeGroupedChecks called with checks: ${JSON.stringify(checks)}`);\n      logger.debug(\n        `üîß Debug: Config available: ${!!config}, Config has checks: ${!!config?.checks}`\n      );\n    }\n\n    // Filter checks based on current event type to prevent execution of checks that shouldn't run\n    const filteredChecks = this.filterChecksByEvent(checks, config, prInfo, logFn, debug);\n    if (filteredChecks.length !== checks.length && debug) {\n      logger.debug(\n        `üîß Debug: Event filtering reduced checks from ${checks.length} to ${filteredChecks.length}: ${JSON.stringify(filteredChecks)}`\n      );\n    }\n\n    // Apply tag filtering if specified\n    const tagFilteredChecks = this.filterChecksByTags(\n      filteredChecks,\n      config,\n      tagFilter || config?.tag_filter\n    );\n\n    if (tagFilteredChecks.length !== filteredChecks.length && debug) {\n      logger.debug(\n        `üîß Debug: Tag filtering reduced checks from ${filteredChecks.length} to ${tagFilteredChecks.length}: ${JSON.stringify(tagFilteredChecks)}`\n      );\n    }\n\n    // Use filtered checks for execution\n    checks = tagFilteredChecks;\n    try {\n      if (process.env.VISOR_DEBUG === 'true') {\n        const ev = (prInfo as any)?.eventType || '(unknown)';\n        console.error(`[engine] final checks after filters (event=${ev}): [${checks.join(', ')}]`);\n      }\n    } catch {}\n\n    // Capture GitHub Action context (owner/repo/octokit) if available from environment\n    // This is used for context elevation when routing via goto_event\n    // Only initialize if not already set by constructor (which has the authenticated octokit)\n    if (!this.actionContext) {\n      try {\n        const repoEnv = process.env.GITHUB_REPOSITORY || '';\n        const [owner, repo] = repoEnv.split('/') as [string, string];\n        const token = process.env['INPUT_GITHUB-TOKEN'] || process.env['GITHUB_TOKEN'];\n        if (owner && repo) {\n          this.actionContext = { owner, repo };\n          if (token) {\n            const { Octokit } = await import('@octokit/rest');\n            this.actionContext.octokit = new Octokit({ auth: token });\n          }\n        }\n      } catch {\n        // Non-fatal: context elevation will be skipped if not available\n      }\n    }\n\n    // Check if we have any checks left after filtering\n    if (checks.length === 0) {\n      logger.warn('‚ö†Ô∏è No checks remain after tag filtering');\n      return {\n        results: {},\n        statistics: this.buildExecutionStatistics(),\n      };\n    }\n\n    if (!config?.checks) {\n      throw new Error('Config with check definitions required for grouped execution');\n    }\n\n    // If we have a config with individual check definitions, use dependency-aware execution\n    const hasDependencies = checks.some(checkName => {\n      const checkConfig = config.checks![checkName];\n      return checkConfig?.depends_on && checkConfig.depends_on.length > 0;\n    });\n    const hasRouting = checks.some(checkName => {\n      const c = config.checks![checkName];\n      return Boolean(c?.on_success || c?.on_fail);\n    });\n\n    if (checks.length > 1 || hasDependencies || hasRouting) {\n      try {\n        if (process.env.VISOR_DEBUG === 'true') {\n          console.error(\n            '[engine] grouped-dep path: checks=',\n            checks.join(','),\n            ' hasDeps=',\n            hasDependencies,\n            ' hasRouting=',\n            hasRouting\n          );\n        }\n      } catch {}\n      if (debug) {\n        logger.debug(\n          `üîß Debug: Using grouped dependency-aware execution for ${checks.length} checks (has dependencies: ${hasDependencies}, has routing: ${hasRouting})`\n        );\n      }\n      const execRes = await this.executeGroupedDependencyAwareChecks(\n        prInfo,\n        checks,\n        timeout,\n        config,\n        logFn,\n        debug,\n        maxParallelism,\n        failFast,\n        tagFilter\n      );\n\n      // Optional grouped-mode PR comment posting (used by tests via execution context)\n      try {\n        if (this.executionContext?.mode?.postGroupedComments && config?.output?.pr_comment) {\n          // Resolve owner/repo from cached action context or PRInfo.eventContext\n          let owner: string | undefined = this.actionContext?.owner;\n          let repo: string | undefined = this.actionContext?.repo;\n          if (!owner || !repo) {\n            try {\n              const anyInfo = prInfo as unknown as {\n                eventContext?: { repository?: { owner?: { login?: string }; name?: string } };\n              };\n              owner = anyInfo?.eventContext?.repository?.owner?.login || owner;\n              repo = anyInfo?.eventContext?.repository?.name || repo;\n            } catch {}\n          }\n          owner = owner || (process.env.GITHUB_REPOSITORY || 'owner/repo').split('/')[0];\n          repo = repo || (process.env.GITHUB_REPOSITORY || 'owner/repo').split('/')[1];\n          if (owner && repo && prInfo.number) {\n            await this.reviewer.postReviewComment(owner, repo, prInfo.number, execRes.results, {\n              config: config as any,\n              triggeredBy: prInfo.eventType || 'manual',\n              commentId: 'visor-review',\n              octokitOverride: (prInfo as any)?.eventContext?.octokit,\n            });\n          }\n        }\n      } catch {}\n\n      // Recompute statistics at the top level to ensure post on_finish inline runs\n      // are reflected in counts (e.g., routed apply-issue-labels second pass).\n      const freshStats = this.buildExecutionStatistics();\n      return { results: execRes.results, statistics: freshStats };\n    }\n\n    // Single check execution\n    if (checks.length === 1) {\n      try {\n        if (process.env.VISOR_DEBUG === 'true')\n          console.error('[engine] grouped-single path: check=', checks[0]);\n      } catch {}\n      if (debug) {\n        logger.debug(`üîß Debug: Using grouped single check execution for: ${checks[0]}`);\n      }\n      const checkResult = await this.executeSingleGroupedCheck(\n        prInfo,\n        checks[0],\n        timeout,\n        config,\n        logFn,\n        debug\n      );\n\n      const groupedResults: GroupedCheckResults = {};\n      groupedResults[checkResult.group] = [checkResult];\n      // Optional grouped-mode PR comment posting for single-check runs as well\n      try {\n        if (this.executionContext?.mode?.postGroupedComments && config?.output?.pr_comment) {\n          let owner: string | undefined = this.actionContext?.owner;\n          let repo: string | undefined = this.actionContext?.repo;\n          if (!owner || !repo) {\n            try {\n              const anyInfo = prInfo as unknown as {\n                eventContext?: { repository?: { owner?: { login?: string }; name?: string } };\n              };\n              owner = anyInfo?.eventContext?.repository?.owner?.login || owner;\n              repo = anyInfo?.eventContext?.repository?.name || repo;\n            } catch {}\n          }\n          owner = owner || (process.env.GITHUB_REPOSITORY || 'owner/repo').split('/')[0];\n          repo = repo || (process.env.GITHUB_REPOSITORY || 'owner/repo').split('/')[1];\n          if (owner && repo && prInfo.number) {\n            await this.reviewer.postReviewComment(owner, repo, prInfo.number, groupedResults, {\n              config: config as any,\n              triggeredBy: prInfo.eventType || 'manual',\n              commentId: 'visor-review',\n              octokitOverride: (prInfo as any)?.eventContext?.octokit,\n            });\n          }\n        }\n      } catch {}\n      return {\n        results: groupedResults,\n        statistics: this.buildExecutionStatistics(),\n      };\n    }\n\n    // No checks to execute\n    return {\n      results: {},\n      statistics: this.buildExecutionStatistics(),\n    };\n  }\n\n  /**\n   * Execute single check and return grouped result\n   */\n  private async executeSingleGroupedCheck(\n    prInfo: PRInfo,\n    checkName: string,\n    timeout?: number,\n    config?: import('./types/config').VisorConfig,\n    logFn?: (message: string) => void,\n    debug?: boolean\n  ): Promise<CheckResult> {\n    if (!config?.checks?.[checkName]) {\n      throw new Error(`No configuration found for check: ${checkName}`);\n    }\n\n    const checkConfig = config.checks![checkName];\n    const providerType = checkConfig.type || 'ai';\n    const provider = this.providerRegistry.getProviderOrThrow(providerType);\n    this.setProviderWebhookContext(provider);\n\n    const providerConfig: CheckProviderConfig = {\n      type: providerType,\n      prompt: checkConfig.prompt,\n      focus: checkConfig.focus || this.mapCheckNameToFocus(checkName),\n      schema: checkConfig.schema,\n      group: checkConfig.group,\n      eventContext: this.enrichEventContext(prInfo.eventContext),\n      ai: {\n        timeout: timeout || 600000,\n        debug: debug,\n        ...(checkConfig.ai || {}),\n      },\n      ai_provider: checkConfig.ai_provider || config.ai_provider,\n      ai_model: checkConfig.ai_model || config.ai_model,\n      // Pass claude_code config if present\n      claude_code: checkConfig.claude_code,\n      // Pass output history for loop/goto scenarios\n      __outputHistory: this.outputHistory,\n      // Pass any provider-specific config\n      ...checkConfig,\n    };\n    providerConfig.forEach = checkConfig.forEach;\n\n    // Ensure statistics are recorded for single-check path as well\n    if (!this.executionStats.has(checkName)) this.initializeCheckStats(checkName);\n    const __iterStart = this.recordIterationStart(checkName);\n    const __provStart = Date.now();\n    const result = await provider.execute(prInfo, providerConfig, undefined, this.executionContext);\n    // Normalize provider issues: ensure each issue carries the producing check name\n    try {\n      if (Array.isArray((result as any)?.issues)) {\n        (result as any).issues = (result as any).issues.map((iss: any) => {\n          if (iss && typeof iss === 'object' && !iss.checkName) {\n            return { ...iss, checkName };\n          }\n          return iss;\n        });\n      }\n    } catch {}\n    this.recordProviderDuration(checkName, Date.now() - __provStart);\n\n    // Validate forEach output (skip if there are already errors from transform_js or other sources)\n    if (checkConfig.forEach && (!result.issues || result.issues.length === 0)) {\n      const reviewSummaryWithOutput = result as ReviewSummary & { output?: unknown };\n      const validation = this.validateAndNormalizeForEachOutput(\n        checkName,\n        reviewSummaryWithOutput.output,\n        checkConfig.group\n      );\n\n      if (!validation.isValid) {\n        return validation.error;\n      }\n    }\n\n    // Evaluate fail_if conditions\n    if (config && (config.fail_if || checkConfig.fail_if)) {\n      const failureResults = await this.evaluateFailureConditions(\n        checkName,\n        result,\n        config,\n        prInfo\n      );\n\n      // Add failure condition issues to the result\n      if (failureResults.length > 0) {\n        const failureIssues = failureResults\n          .filter(f => f.failed)\n          .map(f => ({\n            file: 'system',\n            line: 0,\n            ruleId: f.conditionName,\n            message: f.message || `Failure condition met: ${f.expression}`,\n            severity: (f.severity || 'error') as 'info' | 'warning' | 'error' | 'critical',\n            category: 'logic' as const,\n          }));\n\n        result.issues = [...(result.issues || []), ...failureIssues];\n      }\n    }\n\n    // Render the check content using the appropriate template\n    const content = await this.renderCheckContent(checkName, result, checkConfig, prInfo);\n\n    // Determine the group generically: if a check declares `group`, use it; otherwise default to the check name\n    // This avoids any hardcoded mapping and keeps grouping stable for JSON/PR consumers.\n    const group = checkConfig.group || checkName;\n\n    // History is recorded centrally in executeCheckInline; avoid double-recording here.\n\n    const checkResult: CheckResult = {\n      checkName,\n      content,\n      group,\n      output: (result as any).output,\n      debug: result.debug,\n      issues: result.issues, // Include structured issues\n    };\n\n    // Record completion in execution statistics (success/failure + durations)\n    try {\n      const issuesArr = (result.issues || []).map(i => ({ ...i }));\n      const success = !this.hasFatal(issuesArr);\n      const outputVal: unknown = (result as any)?.output;\n      this.recordIterationComplete(checkName, __iterStart, success, issuesArr, outputVal);\n    } catch {}\n\n    return checkResult;\n  }\n\n  /**\n   * Validate and normalize forEach output\n   * Returns normalized array or throws validation error result\n   */\n  private validateAndNormalizeForEachOutput(\n    checkName: string,\n    output: unknown,\n    checkGroup?: string\n  ):\n    | {\n        isValid: true;\n        normalizedOutput: unknown[];\n      }\n    | {\n        isValid: false;\n        error: {\n          checkName: string;\n          content: string;\n          group: string;\n          issues: Array<{\n            file: string;\n            line: number;\n            ruleId: string;\n            message: string;\n            severity: 'error';\n            category: 'logic';\n          }>;\n        };\n      } {\n    if (output === undefined) {\n      logger.error(`‚úó forEach check \"${checkName}\" produced undefined output`);\n      return {\n        isValid: false,\n        error: {\n          checkName,\n          content: '',\n          group: checkGroup || 'default',\n          issues: [\n            {\n              file: 'system',\n              line: 0,\n              ruleId: 'forEach/undefined_output',\n              message: `forEach check \"${checkName}\" produced undefined output. Verify your command outputs valid data and your transform_js returns a value.`,\n              severity: 'error',\n              category: 'logic',\n            },\n          ],\n        },\n      };\n    }\n\n    // Normalize output to array\n    let normalizedOutput: unknown[];\n\n    if (Array.isArray(output)) {\n      normalizedOutput = output;\n    } else if (output && typeof output === 'object' && Array.isArray((output as any).items)) {\n      normalizedOutput = (output as any).items as unknown[];\n    } else if (typeof output === 'string') {\n      try {\n        const parsed = JSON.parse(output);\n        normalizedOutput = Array.isArray(parsed) ? parsed : [parsed];\n      } catch {\n        normalizedOutput = [output];\n      }\n    } else if (output === null) {\n      normalizedOutput = [];\n    } else {\n      normalizedOutput = [output];\n    }\n\n    // Log the result (empty arrays are valid, just result in 0 iterations)\n    logger.info(`  Found ${normalizedOutput.length} items for forEach iteration`);\n    return {\n      isValid: true,\n      normalizedOutput,\n    };\n  }\n\n  /**\n   * Execute multiple checks with dependency awareness - return grouped results with statistics\n   */\n  private async executeGroupedDependencyAwareChecks(\n    prInfo: PRInfo,\n    checks: string[],\n    timeout?: number,\n    config?: import('./types/config').VisorConfig,\n    logFn?: (message: string) => void,\n    debug?: boolean,\n    maxParallelism?: number,\n    failFast?: boolean,\n    tagFilter?: import('./types/config').TagFilter\n  ): Promise<ExecutionResult> {\n    // Ensure per-run guards do not leak across stages in a flow. In particular,\n    // forwardRunGuards must be cleared so on_finish routed targets (e.g.,\n    // issue-assistant) can be scheduled again in later stages that use the same\n    // event type. This fixes flaky counts like apply-issue-labels=1 instead of 2\n    // when running the entire pr-review-e2e-flow.\n    try {\n      this.resetPerRunState();\n    } catch {}\n    // Do not mutate MemoryStore inside the engine; stage scoping is achieved\n    // via output history and per-run guards only.\n    // Use the existing dependency-aware execution logic\n    const reviewSummary = await this.executeDependencyAwareChecks(\n      prInfo,\n      checks,\n      timeout,\n      config,\n      logFn,\n      debug,\n      maxParallelism,\n      failFast,\n      tagFilter || config?.tag_filter\n    );\n\n    // Build execution statistics\n    const executionStatistics = this.buildExecutionStatistics();\n\n    // Convert the flat ReviewSummary to grouped CheckResults\n    const groupedResults = await this.convertReviewSummaryToGroupedResults(\n      reviewSummary,\n      checks,\n      config,\n      prInfo\n    );\n\n    return {\n      results: groupedResults,\n      statistics: executionStatistics,\n    };\n  }\n\n  /**\n   * Convert ReviewSummary to GroupedCheckResults\n   */\n  private async convertReviewSummaryToGroupedResults(\n    reviewSummary: ReviewSummary,\n    checks: string[],\n    config?: import('./types/config').VisorConfig,\n    prInfo?: PRInfo\n  ): Promise<GroupedCheckResults> {\n    const groupedResults: GroupedCheckResults = {};\n    const agg = reviewSummary as ReviewSummary & {\n      __contents?: Record<string, string | undefined>;\n      __outputs?: Record<string, unknown>;\n      __executed?: string[];\n    };\n    const contentMap = agg.__contents;\n    const outputMap = agg.__outputs;\n    // Build a unified list of all checks that produced results:\n    //  - originally requested checks\n    //  - any checks that produced content/output during routing (e.g., forward-run after goto)\n    //  - any checks that emitted issues with checkName set\n    const allCheckNames: string[] = [];\n    const seen = new Set<string>();\n    const pushUnique = (n?: string) => {\n      if (!n) return;\n      if (!seen.has(n)) {\n        seen.add(n);\n        allCheckNames.push(n);\n      }\n    };\n    for (const n of checks) pushUnique(n);\n    if (contentMap) for (const n of Object.keys(contentMap)) pushUnique(n);\n    if (outputMap) for (const n of Object.keys(outputMap)) pushUnique(n);\n    for (const issue of reviewSummary.issues || []) pushUnique(issue.checkName);\n    if (Array.isArray(agg.__executed)) for (const n of agg.__executed) pushUnique(n);\n\n    // Process each discovered check individually\n    for (const checkName of allCheckNames) {\n      const checkConfig = config?.checks?.[checkName];\n      if (!checkConfig) continue;\n\n      // Extract issues for this check: rely strictly on explicit issue.checkName\n      const checkIssues = (reviewSummary.issues || []).filter(\n        issue => issue.checkName === checkName\n      );\n\n      // Create a mini ReviewSummary for this check\n      const checkSummary: ReviewSummary & { output?: unknown } = {\n        issues: checkIssues,\n        debug: reviewSummary.debug,\n      };\n\n      if (contentMap?.[checkName]) {\n        (checkSummary as any).content = contentMap[checkName];\n      }\n      if (outputMap && Object.prototype.hasOwnProperty.call(outputMap, checkName)) {\n        checkSummary.output = outputMap[checkName];\n      }\n\n      // Render content for this check (never let template errors abort the whole run)\n      let content: string = '';\n      let issuesForCheck = [...checkIssues];\n      try {\n        content = await this.renderCheckContent(checkName, checkSummary, checkConfig, prInfo);\n      } catch (e) {\n        const msg = e instanceof Error ? e.message : String(e);\n        console.error(`‚ùå Failed to render content for check '${checkName}': ${msg}`);\n        // Add a synthetic issue so it appears in output and GitHub Checks\n        issuesForCheck = [\n          ...issuesForCheck,\n          {\n            file: 'system',\n            line: 0,\n            ruleId: `${checkName}/render-error`,\n            message: `Template rendering failed: ${msg}`,\n            severity: 'error' as const,\n            category: 'logic' as const,\n          },\n        ];\n      }\n\n      // Determine group for grouped results: use explicit group or fall back to the check name\n      const group = checkConfig.group || checkName;\n\n      const DBG2 = process.env.VISOR_DEBUG === 'true' || (this as any).globalDebug === true;\n      if (DBG2) {\n        try {\n          console.error(\n            `[gh-debug] grouped result: check='${checkName}' issues=${issuesForCheck.length} hasContent=${\n              content.trim() ? 'yes' : 'no'\n            } group='${group}'`\n          );\n        } catch {}\n      }\n\n      const checkResult: CheckResult = {\n        checkName,\n        content,\n        group,\n        output: checkSummary.output,\n        debug: reviewSummary.debug,\n        issues: issuesForCheck, // Include structured issues + rendering error if any\n      };\n\n      // Add to appropriate group\n      if (!groupedResults[group]) {\n        groupedResults[group] = [];\n      }\n      groupedResults[group].push(checkResult);\n    }\n\n    return groupedResults;\n  }\n\n  /**\n   * Validates that a file path is safe and within the project directory\n   * Prevents path traversal attacks by:\n   * - Blocking absolute paths\n   * - Blocking paths with \"..\" segments\n   * - Ensuring resolved path is within project directory\n   * - Blocking special characters and null bytes\n   * - Enforcing .liquid file extension\n   */\n  private async validateTemplatePath(templatePath: string): Promise<string> {\n    const path = await import('path');\n\n    // Validate input\n    if (!templatePath || typeof templatePath !== 'string' || templatePath.trim() === '') {\n      throw new Error('Template path must be a non-empty string');\n    }\n\n    // Block null bytes and other dangerous characters\n    if (templatePath.includes('\\0') || templatePath.includes('\\x00')) {\n      throw new Error('Template path contains invalid characters');\n    }\n\n    // Enforce .liquid file extension\n    if (!templatePath.endsWith('.liquid')) {\n      throw new Error('Template file must have .liquid extension');\n    }\n\n    // Block absolute paths\n    if (path.isAbsolute(templatePath)) {\n      throw new Error('Template path must be relative to project directory');\n    }\n\n    // Block paths with \"..\" segments\n    if (templatePath.includes('..')) {\n      throw new Error('Template path cannot contain \"..\" segments');\n    }\n\n    // Block paths starting with ~ (home directory)\n    if (templatePath.startsWith('~')) {\n      throw new Error('Template path cannot reference home directory');\n    }\n\n    // Get the project root directory from git analyzer\n    const repositoryInfo = await this.gitAnalyzer.analyzeRepository();\n    const projectRoot = repositoryInfo.workingDirectory;\n\n    // Validate project root\n    if (!projectRoot || typeof projectRoot !== 'string') {\n      throw new Error('Unable to determine project root directory');\n    }\n\n    // Resolve the template path relative to project root\n    const resolvedPath = path.resolve(projectRoot, templatePath);\n    const resolvedProjectRoot = path.resolve(projectRoot);\n\n    // Validate resolved paths\n    if (\n      !resolvedPath ||\n      !resolvedProjectRoot ||\n      resolvedPath === '' ||\n      resolvedProjectRoot === ''\n    ) {\n      throw new Error(\n        `Unable to resolve template path: projectRoot=\"${projectRoot}\", templatePath=\"${templatePath}\", resolvedPath=\"${resolvedPath}\", resolvedProjectRoot=\"${resolvedProjectRoot}\"`\n      );\n    }\n\n    // Ensure the resolved path is still within the project directory\n    if (\n      !resolvedPath.startsWith(resolvedProjectRoot + path.sep) &&\n      resolvedPath !== resolvedProjectRoot\n    ) {\n      throw new Error('Template path escapes project directory');\n    }\n\n    return resolvedPath;\n  }\n\n  /**\n   * Unified helper to evaluate a check's `if` condition with optional fail-secure behavior.\n   * Returns a struct indicating whether to run; when failSecure=true, any evaluation error\n   * results in shouldRun=false with an error message.\n   */\n  private async shouldRunCheck(\n    checkName: string,\n    condition: string,\n    prInfo: PRInfo,\n    results: Map<string, ReviewSummary>,\n    debug?: boolean,\n    eventOverride?: import('./types/config').EventTrigger,\n    failSecure = false\n  ): Promise<{ shouldRun: boolean; error?: string }> {\n    try {\n      const eventName = eventOverride\n        ? eventOverride.startsWith('pr_')\n          ? 'pull_request'\n          : eventOverride === 'issue_comment'\n            ? 'issue_comment'\n            : eventOverride.startsWith('issue_')\n              ? 'issues'\n              : 'manual'\n        : prInfo.eventType && prInfo.eventType.startsWith('pr_')\n          ? 'pull_request'\n          : prInfo.eventType === 'issue_comment'\n            ? 'issue_comment'\n            : prInfo.eventType && prInfo.eventType.startsWith('issue_')\n              ? 'issues'\n              : 'manual';\n\n      const commenterAssoc = resolveAssociationFromEvent(\n        (prInfo as any)?.eventContext,\n        prInfo.authorAssociation\n      );\n\n      const shouldRun = await this.failureEvaluator.evaluateIfCondition(checkName, condition, {\n        branch: prInfo.head,\n        baseBranch: prInfo.base,\n        filesChanged: prInfo.files.map(f => f.filename),\n        event: eventName,\n        environment: getSafeEnvironmentVariables(),\n        previousResults: results,\n        authorAssociation: commenterAssoc,\n      });\n\n      if (!shouldRun && debug) {\n        logger.debug(`üîß Debug: Skipping check '${checkName}' - if condition evaluated to false`);\n      }\n      return { shouldRun };\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : String(error);\n      if (failSecure) {\n        try {\n          logger.error(`Failed to evaluate if condition for ${checkName}: ${msg}`);\n        } catch {}\n        return { shouldRun: false, error: msg };\n      }\n      // Legacy behavior: on evaluation error, default to running the check\n      try {\n        if (debug) logger.debug(`‚ö†Ô∏è Debug: if evaluation error for ${checkName}: ${msg}`);\n      } catch {}\n      return { shouldRun: true, error: msg };\n    }\n  }\n\n  /**\n   * Render check content using the appropriate template\n   */\n  private async renderCheckContent(\n    checkName: string,\n    reviewSummary: ReviewSummary,\n    checkConfig: CheckConfig,\n    _prInfo?: PRInfo\n  ): Promise<string> {\n    const directContent = (reviewSummary as ReviewSummary & { content?: string }).content;\n    if (typeof directContent === 'string' && directContent.trim()) {\n      return directContent.trim();\n    }\n\n    // Import the liquid template system\n    const { createExtendedLiquid } = await import('./liquid-extensions');\n    const fs = await import('fs/promises');\n    const path = await import('path');\n\n    const liquid = createExtendedLiquid({\n      trimTagLeft: false,\n      trimTagRight: false,\n      trimOutputLeft: false,\n      trimOutputRight: false,\n      greedy: false,\n    });\n\n    // Determine template to use\n    // If schema is an object (inline JSON schema), use 'plain' rendering\n    // If schema is a file path (legitimate path with / and ends with .json), treat as plain (schema file reference)\n    let schemaName: string;\n    if (typeof checkConfig.schema === 'object') {\n      schemaName = 'plain';\n    } else if (\n      typeof checkConfig.schema === 'string' &&\n      checkConfig.schema.includes('/') &&\n      checkConfig.schema.endsWith('.json') &&\n      !checkConfig.schema.includes('..') // Reject paths containing .. (parent directory)\n    ) {\n      // Schema is a file path reference - use plain rendering\n      // The schema file will be handled by the AI provider when making the request\n      schemaName = 'plain';\n    } else {\n      schemaName = checkConfig.schema || 'plain';\n    }\n\n    let templateContent: string = '';\n    let enrichAssistantContext = false;\n\n    const DBG = process.env.VISOR_DEBUG === 'true' || (this as any).globalDebug === true;\n\n    if (checkConfig.template) {\n      // Custom template\n      if (checkConfig.template.content) {\n        templateContent = checkConfig.template.content;\n      } else if (checkConfig.template.file) {\n        // Validate the template file path to prevent path traversal attacks\n        const validatedPath = await this.validateTemplatePath(checkConfig.template.file);\n        templateContent = await fs.readFile(validatedPath, 'utf-8');\n      } else {\n        throw new Error('Custom template must specify either \"file\" or \"content\"');\n      }\n    } else if (schemaName === 'plain') {\n      if (DBG) {\n        try {\n          console.error(\n            `[gh-debug] render plain content for check='${checkName}' issues=${\n              (reviewSummary.issues || []).length\n            }`\n          );\n        } catch {}\n      }\n      // Plain schema - return raw content directly\n      return reviewSummary.issues?.[0]?.message || '';\n    } else {\n      // Use built-in schema template\n      const sanitizedSchema = schemaName.replace(/[^a-zA-Z0-9-]/g, '');\n      if (!sanitizedSchema) {\n        throw new Error('Invalid schema name');\n      }\n      // Locate built-in template. In GitHub Action bundle templates live under dist/output.\n      // In local dev (ts-node/jest) templates live under project/output.\n      // Also try historical dist/output1 fallback.\n      const candidateTemplatePaths = [\n        path.join(__dirname, `output/${sanitizedSchema}/template.liquid`),\n        path.join(process.cwd(), `output/${sanitizedSchema}/template.liquid`),\n      ];\n\n      let foundTemplate: string | undefined;\n      for (const p of candidateTemplatePaths) {\n        try {\n          templateContent = await fs.readFile(p, 'utf-8');\n          foundTemplate = p;\n          break;\n        } catch {\n          // try next candidate\n        }\n      }\n      if (!foundTemplate) {\n        const distPath = path.join(__dirname, `output/${sanitizedSchema}/template.liquid`);\n        const cwdPath = path.join(process.cwd(), `output/${sanitizedSchema}/template.liquid`);\n        throw new Error(\n          `Template file not found for schema '${sanitizedSchema}'. Tried: ${distPath} and ${cwdPath}.`\n        );\n      }\n      if (DBG) {\n        try {\n          console.error(\n            `[gh-debug] template resolved for check='${checkName}' schema='${sanitizedSchema}' path='${foundTemplate}'`\n          );\n        } catch {}\n      }\n      // Only enrich built-in issue-assistant with event/permission context\n      if (sanitizedSchema === 'issue-assistant') {\n        enrichAssistantContext = true;\n      }\n    }\n\n    // Prepare template data\n    // Filter out system-level issues (fail_if conditions, internal errors) which should not appear in output\n    const filteredIssues = (reviewSummary.issues || []).filter(\n      issue => !(issue.file === 'system' && issue.line === 0)\n    );\n    if (DBG) {\n      try {\n        const sample = filteredIssues.slice(0, 2).map(i => ({\n          file: i.file,\n          line: i.line,\n          severity: i.severity,\n          ruleId: i.ruleId,\n          checkName: (i as any).checkName,\n          category: (i as any).category,\n        }));\n        console.error(\n          `[gh-debug] render data for check='${checkName}' issues=${filteredIssues.length} content=${\n            (reviewSummary as any).content ? 'yes' : 'no'\n          } sample=${JSON.stringify(sample)}`\n        );\n      } catch {}\n    }\n\n    const templateData: Record<string, unknown> = {\n      issues: filteredIssues,\n      checkName: checkName,\n      // Expose structured output for custom schemas/templates (e.g., overview)\n      // This allows templates to render fields like output.text or output.tags\n      output: (reviewSummary as unknown as { output?: unknown }).output,\n    };\n\n    if (enrichAssistantContext) {\n      // Provide minimal event and permission context for the assistant template only\n      let authorAssociation: string | undefined;\n      let eventName = 'manual';\n      let eventAction: string | undefined;\n      try {\n        const anyInfo = _prInfo as unknown as { eventContext?: any; authorAssociation?: string };\n        authorAssociation = resolveAssociationFromEvent(\n          anyInfo?.eventContext,\n          anyInfo?.authorAssociation\n        );\n        eventName = anyInfo?.eventContext?.event_name || (anyInfo as any)?.eventType || 'manual';\n        eventAction = anyInfo?.eventContext?.action;\n      } catch {}\n      templateData.authorAssociation = authorAssociation;\n      templateData.event = { name: eventName, action: eventAction };\n    }\n\n    // Establish permissions context for filters so templates can call permission filters\n    // without passing authorAssociation explicitly.\n    const { withPermissionsContext } = (await import('./liquid-extensions')) as unknown as {\n      withPermissionsContext?: (\n        ctx: { authorAssociation?: string },\n        fn: () => Promise<string>\n      ) => Promise<string>;\n    };\n    // Try to derive author association from PR info (commenter preferred)\n    let authorAssociationForFilters: string | undefined;\n    try {\n      const anyInfo = _prInfo as unknown as { eventContext?: any; authorAssociation?: string };\n      authorAssociationForFilters = resolveAssociationFromEvent(\n        anyInfo?.eventContext,\n        anyInfo?.authorAssociation\n      );\n    } catch {}\n\n    let rendered: string;\n    if (typeof withPermissionsContext === 'function') {\n      rendered = await withPermissionsContext(\n        { authorAssociation: authorAssociationForFilters },\n        async () => await liquid.parseAndRender(templateContent, templateData)\n      );\n      if (rendered === undefined || rendered === null) {\n        // Defensive: some test environments mock the helper without implementation\n        rendered = await liquid.parseAndRender(templateContent, templateData);\n      }\n    } else {\n      rendered = await liquid.parseAndRender(templateContent, templateData);\n    }\n    const finalRendered = rendered.trim();\n    try {\n      const { emitMermaidFromMarkdown } = await import('./utils/mermaid-telemetry');\n      emitMermaidFromMarkdown(checkName, finalRendered, 'content');\n    } catch {}\n    return finalRendered;\n  }\n\n  /**\n   * Attempt to elevate an issue/issue_comment context to full PR context when routing via goto_event.\n   * Returns a new PRInfo with files/diff when possible; otherwise returns null.\n   */\n  private async elevateContextToPullRequest(\n    prInfo: PRInfo,\n    targetEvent: import('./types/config').EventTrigger,\n    log?: (msg: string) => void,\n    debug?: boolean\n  ): Promise<PRInfo | null> {\n    try {\n      // Only elevate for PR-style events\n      if (targetEvent !== 'pr_opened' && targetEvent !== 'pr_updated') return null;\n\n      // Only meaningful to elevate from issue contexts\n      const isIssueContext = (prInfo as PRInfo & { isIssue?: boolean }).isIssue === true;\n      const ctx: any = (prInfo as any).eventContext || {};\n      const isPRThread = Boolean(ctx?.issue?.pull_request);\n      if (!isIssueContext || !isPRThread) return null;\n\n      // Resolve owner/repo from cached action context or environment\n      let owner = this.actionContext?.owner;\n      let repo = this.actionContext?.repo;\n      if (!owner || !repo) {\n        const repoEnv = process.env.GITHUB_REPOSITORY || '';\n        [owner, repo] = repoEnv.split('/') as [string, string];\n      }\n      if (!owner || !repo) return null;\n\n      // Determine PR number from event context or prInfo.number\n      const prNumber = (ctx?.issue?.number as number) || prInfo.number;\n      if (!prNumber) return null;\n\n      // Build Octokit; prefer cached instance\n      let octokit = this.actionContext?.octokit;\n      if (!octokit) {\n        const token = process.env['INPUT_GITHUB-TOKEN'] || process.env['GITHUB_TOKEN'];\n        if (!token) return null;\n        const { Octokit } = await import('@octokit/rest');\n        octokit = new Octokit({ auth: token });\n      }\n\n      // Fetch full PR diff\n      const analyzer = new PRAnalyzer(octokit);\n      const elevated = await analyzer.fetchPRDiff(owner, repo, prNumber, undefined, targetEvent);\n      // Preserve event context and helpful flags\n      (elevated as any).eventContext = (prInfo as any).eventContext || ctx;\n      (elevated as any).isPRContext = true;\n      (elevated as any).includeCodeContext = true;\n      if (debug)\n        log?.(`üîß Debug: Elevated context to PR #${prNumber} for goto_event=${targetEvent}`);\n      return elevated;\n    } catch (e) {\n      if (debug) {\n        const msg = e instanceof Error ? e.message : String(e);\n        log?.(`‚ö†Ô∏è Debug: Context elevation to PR failed: ${msg}`);\n      }\n      return null;\n    }\n  }\n\n  /**\n   * Execute multiple checks with dependency awareness - intelligently parallel and sequential\n   */\n  private async executeDependencyAwareChecks(\n    prInfo: PRInfo,\n    checks: string[],\n    timeout?: number,\n    config?: import('./types/config').VisorConfig,\n    logFn?: (message: string) => void,\n    debug?: boolean,\n    maxParallelism?: number,\n    failFast?: boolean,\n    tagFilter?: import('./types/config').TagFilter\n  ): Promise<ReviewSummary> {\n    const log = logFn || console.error;\n    try {\n      if (process.env.VISOR_DEBUG === 'true') {\n        console.error('[engine] enter executeDependencyAwareChecks (dbg=', debug, ')');\n        console.error('  [engine] root checks in (pre-expand): [', checks.join(', '), ']');\n      }\n    } catch {}\n\n    if (debug) {\n      log(`üîß Debug: Starting dependency-aware execution of ${checks.length} checks`);\n    }\n\n    if (!config?.checks) {\n      throw new Error('Config with check definitions required for dependency-aware execution');\n    }\n\n    // Determine effective max parallelism (CLI > config > default)\n    const effectiveMaxParallelism = maxParallelism ?? config.max_parallelism ?? 3;\n    // Determine effective fail-fast setting (CLI > config > default)\n    const effectiveFailFast = failFast ?? config.fail_fast ?? false;\n\n    if (debug) {\n      log(`üîß Debug: Using max parallelism: ${effectiveMaxParallelism}`);\n      log(`üîß Debug: Using fail-fast: ${effectiveFailFast}`);\n    }\n\n    // Build dependency graph and check for session reuse requirements\n    let dependencies: Record<string, string[]> = {};\n    const sessionReuseChecks = new Set<string>();\n    const sessionProviders = new Map<string, string>(); // checkName -> parent session provider\n\n    for (const checkName of checks) {\n      const checkConfig = config.checks![checkName];\n      if (checkConfig) {\n        dependencies[checkName] = checkConfig.depends_on || [];\n\n        // Track checks that need session reuse\n        if (debug) {\n          try {\n            log(\n              `üîß Debug: reuse_ai_session for '${checkName}' ‚Üí ${String(\n                (checkConfig as any).reuse_ai_session\n              )}`\n            );\n          } catch {}\n        }\n        if (\n          checkConfig.reuse_ai_session === true ||\n          typeof (checkConfig.reuse_ai_session as unknown) === 'string'\n        ) {\n          sessionReuseChecks.add(checkName);\n\n          // Determine the session provider check name\n          if (typeof checkConfig.reuse_ai_session === 'string') {\n            // Explicit check name provided\n            sessionProviders.set(checkName, checkConfig.reuse_ai_session);\n          } else if (checkConfig.reuse_ai_session === true) {\n            // Use first dependency as fallback\n            if (checkConfig.depends_on && checkConfig.depends_on.length > 0) {\n              sessionProviders.set(checkName, checkConfig.depends_on[0]);\n            }\n          }\n        }\n      } else {\n        dependencies[checkName] = [];\n      }\n    }\n\n    if (sessionReuseChecks.size > 0 && debug) {\n      log(\n        `üîÑ Debug: Found ${sessionReuseChecks.size} checks requiring session reuse: ${Array.from(sessionReuseChecks).join(', ')}`\n      );\n    }\n\n    // (moved) dependency validation runs after we include transitive dependencies\n\n    // Expand requested checks with transitive dependencies present in config for execution\n    const expandWithTransitives = (rootChecks: string[]): string[] => {\n      if (!config?.checks) return rootChecks;\n      const set = new Set<string>(rootChecks);\n      const allowByTags = (name: string): boolean => {\n        if (!tagFilter) return true;\n        const cfg = config!.checks?.[name];\n        const tags: string[] = (cfg && (cfg as any).tags) || [];\n        if (tagFilter.exclude && tagFilter.exclude.some(t => tags.includes(t))) return false;\n        if (tagFilter.include && tagFilter.include.length > 0) {\n          return tagFilter.include.some(t => tags.includes(t));\n        }\n        return true;\n      };\n      const allowByEvent = (name: string): boolean => {\n        try {\n          const cfg = config!.checks?.[name];\n          const triggers: import('./types/config').EventTrigger[] = (cfg?.on || []) as any;\n          // No triggers => allowed for all events\n          if (!triggers || triggers.length === 0) return true;\n          const current = prInfo?.eventType || 'manual';\n          return triggers.includes(current as any);\n        } catch {\n          return true;\n        }\n      };\n      const visit = (name: string) => {\n        const cfg = config.checks![name];\n        if (!cfg || !cfg.depends_on) return;\n        const depTokens = Array.isArray(cfg.depends_on) ? cfg.depends_on : [cfg.depends_on];\n        const expand = (tok: any): string[] => {\n          if (typeof tok === 'string' && tok.includes('|')) {\n            return tok\n              .split('|')\n              .map(s => s.trim())\n              .filter(Boolean);\n          }\n          return tok ? [String(tok)] : [];\n        };\n        const deps = depTokens.flatMap(expand);\n        for (const depName of deps) {\n          if (!config.checks![depName]) continue;\n          if (!allowByTags(depName)) continue;\n          if (!allowByEvent(depName)) continue;\n          if (!set.has(depName)) {\n            set.add(depName);\n            visit(depName);\n          }\n        }\n      };\n      for (const c of rootChecks) visit(c);\n      return Array.from(set);\n    };\n\n    checks = expandWithTransitives(checks);\n    try {\n      if (process.env.VISOR_DEBUG === 'true') {\n        console.error('  [engine] checks after expandWithTransitives: [', checks.join(', '), ']');\n      }\n    } catch {}\n\n    // Rebuild dependencies map for the expanded set (expand OR groups and prune by event)\n    for (const checkName of checks) {\n      const checkConfig = config.checks![checkName];\n      const depTokens: any[] = Array.isArray(checkConfig?.depends_on)\n        ? (checkConfig!.depends_on as any[])\n        : checkConfig?.depends_on\n          ? [checkConfig.depends_on]\n          : [];\n      const expandedDeps = depTokens.flatMap(tok =>\n        typeof tok === 'string' && tok.includes('|')\n          ? tok\n              .split('|')\n              .map(s => s.trim())\n              .filter(Boolean)\n          : tok\n            ? [String(tok)]\n            : []\n      );\n      dependencies[checkName] = expandedDeps;\n    }\n    // Prune dependencies that are not applicable for the current event.\n    // This avoids false validation failures for dual-source deps like\n    // extract-facts depending on both issue-assistant (issue_opened) and\n    // comment-assistant (issue_comment). Only keep deps whose own `on`\n    // includes the current event (or have no `on`).\n    try {\n      // Only prune by event when we have an explicit event context (GitHub webhook path)\n      if (prInfo && (prInfo as any).eventType) {\n        const currentEv = ((prInfo as any).eventType || 'manual') as any;\n        for (const [name, deps] of Object.entries(dependencies)) {\n          const filtered = (deps || []).filter(dep => {\n            const cfg = config.checks?.[dep];\n            if (!cfg) return false;\n            const trig = (cfg.on || []) as any;\n            if (!trig || (Array.isArray(trig) && trig.length === 0)) return true;\n            return Array.isArray(trig) ? trig.includes(currentEv) : trig === currentEv;\n          });\n          dependencies[name] = filtered;\n        }\n      }\n    } catch {}\n\n    // Validate dependencies after expansion so transitive deps are considered\n    {\n      const validation2 = DependencyResolver.validateDependencies(checks, dependencies);\n      if (!validation2.valid) {\n        return {\n          issues: [\n            {\n              severity: 'error' as const,\n              message: `Dependency validation failed: ${validation2.errors.join(', ')}`,\n              file: '',\n              line: 0,\n              ruleId: 'dependency-validation-error',\n              category: 'logic' as const,\n            },\n          ],\n        };\n      }\n    }\n\n    // Build dependency graph\n    let dependencyGraph = DependencyResolver.buildDependencyGraph(dependencies);\n\n    if (dependencyGraph.hasCycles) {\n      return {\n        issues: [\n          {\n            severity: 'error' as const,\n            message: `Circular dependencies detected: ${dependencyGraph.cycleNodes?.join(' -> ')}`,\n            file: '',\n            line: 0,\n            ruleId: 'circular-dependency-error',\n            category: 'logic' as const,\n          },\n        ],\n      };\n    }\n\n    // Build children-by-parent mapping for inline branch-first execution\n    const childrenByParent = new Map<string, string[]>();\n    for (const [child, depsArr] of Object.entries(dependencies)) {\n      for (const p of depsArr || []) {\n        if (!childrenByParent.has(p)) childrenByParent.set(p, []);\n        childrenByParent.get(p)!.push(child);\n      }\n    }\n\n    // Log execution plan\n    let stats = DependencyResolver.getExecutionStats(dependencyGraph);\n    if (debug) {\n      log(\n        `üîß Debug: Execution plan - ${stats.totalChecks} checks in ${stats.parallelLevels} levels, max parallelism: ${stats.maxParallelism}`\n      );\n    }\n\n    // Execute checks in waves when on_fail forward-runs occur during a pass\n    const results = new Map<string, ReviewSummary>();\n    const maxWaves = config?.routing?.max_loops ?? 10;\n    let wave = 1;\n    const runWave = async (): Promise<void> => {\n      // Reset per-wave forward scheduling/dedupe guards\n      try {\n        this.forwardDependentsScheduled.clear();\n      } catch {}\n      try {\n        this.forwardRunGuards.clear();\n      } catch {}\n      try {\n        this.oncePerRunScheduleGuards.clear();\n      } catch {}\n      // Clear forward-run markers\n      (this as any).onFailForwardRunSeen = false;\n      (this as any).onFinishForwardRunSeen = false;\n      (this as any).onSuccessForwardRunSeen = false;\n    };\n    await runWave();\n    const sessionRegistry = require('./session-registry').SessionRegistry.getInstance();\n    // Note: We'll get the provider dynamically per check, not a single one for all\n    const sessionIds = new Map<string, string>(); // checkName -> sessionId\n    let shouldStopExecution = false;\n    let completedChecksCount = 0;\n    let totalChecksCount = stats.totalChecks;\n\n    // Initialize execution statistics for all checks\n    for (const checkName of checks) {\n      this.initializeCheckStats(checkName);\n    }\n\n    const executeLevels = async (): Promise<void> => {\n      for (\n        let levelIndex = 0;\n        levelIndex < dependencyGraph.executionOrder.length && !shouldStopExecution;\n        levelIndex++\n      ) {\n        const executionGroup = dependencyGraph.executionOrder[levelIndex];\n        try {\n          console.error(\n            `  [engine] level ${executionGroup.level} parallel=[${executionGroup.parallel.join(', ')}] (wave ${wave})`\n          );\n        } catch {}\n\n        // Check for session reuse conflicts - only force sequential execution when there are actual conflicts\n        const checksInLevel = Array.isArray((executionGroup as any).parallel)\n          ? (executionGroup as any).parallel\n          : [];\n        // In correction waves, planning excludes dependents already; no ad-hoc suppression here.\n\n        // Group checks by their session parent\n        const sessionReuseGroups = new Map<string, string[]>();\n        checksInLevel.forEach((checkName: string) => {\n          if (sessionReuseChecks.has(checkName)) {\n            const parentCheckName = sessionProviders.get(checkName);\n            if (parentCheckName) {\n              if (!sessionReuseGroups.has(parentCheckName)) {\n                sessionReuseGroups.set(parentCheckName, []);\n              }\n              sessionReuseGroups.get(parentCheckName)!.push(checkName);\n            }\n          }\n        });\n\n        // Only force sequential execution if multiple checks share the same session parent\n        const hasConflictingSessionReuse = Array.from(sessionReuseGroups.values()).some(\n          group => group.length > 1\n        );\n\n        let actualParallelism = Math.min(effectiveMaxParallelism, checksInLevel.length);\n        if (hasConflictingSessionReuse) {\n          // Force sequential execution when there are actual session conflicts\n          actualParallelism = 1;\n          if (debug) {\n            const conflictingGroups = Array.from(sessionReuseGroups.entries())\n              .filter(([_, checks]) => checks.length > 1)\n              .map(([parent, checks]) => `${parent} -> [${checks.join(', ')}]`)\n              .join('; ');\n            log(\n              `üîÑ Debug: Level ${executionGroup.level} has session conflicts (${conflictingGroups}) - forcing sequential execution (parallelism: 1)`\n            );\n          }\n        } else if (sessionReuseGroups.size > 0 && debug) {\n          log(\n            `‚úÖ Debug: Level ${executionGroup.level} has session reuse but no conflicts - allowing parallel execution`\n          );\n        }\n\n        if (debug) {\n          log(\n            `üîß Debug: Executing level ${executionGroup.level} with ${executionGroup.parallel.length} checks (parallelism: ${actualParallelism})`\n          );\n        }\n\n        // Create task functions for checks in this level. Do not pre-filter by\n        // results.has(name) because forEach parents may satisfy dependents inline\n        // during their execution. Each task will re-check and skip at run time.\n        let levelChecks = checksInLevel;\n        // Guard: during correction waves (on_finish), do not re-run forEach parents\n        // that already executed earlier in this grouped run.\n        try {\n          const inCorrection = Boolean((this as any).onFinishForwardRunSeen);\n          if (inCorrection) {\n            levelChecks = levelChecks.filter((name: string) => {\n              const cfg = (config.checks || {})[name] as any;\n              if (!cfg || cfg.forEach !== true) return true;\n              const st = this.executionStats.get(name);\n              return !st || (st.totalRuns || 0) === 0;\n            });\n          }\n        } catch {}\n        try {\n          if (process.env.VISOR_DEBUG === 'true') {\n            console.error('  [engine] levelChecks = [', levelChecks.join(', '), ']');\n          }\n        } catch {}\n        const levelTaskFunctions = levelChecks.map((checkName: string) => async () => {\n          // Generic per-run cap: respect per-step max_runs/global limits\n          try {\n            const cap = this.resolveMaxRuns(config, checkName);\n            if (typeof cap === 'number' && cap > 0) {\n              const k = this.buildRunKey(checkName, undefined);\n              const soFar = this.runCounters.get(k) || 0;\n              if (soFar >= cap) {\n                if (debug) log(`üîß Debug: Skipping ${checkName} due to max_runs cap (${cap})`);\n                this.recordSkip(checkName, 'fail_fast', 'max_runs');\n                return {\n                  checkName,\n                  error: null,\n                  result: {\n                    issues: [\n                      {\n                        file: '',\n                        line: 0,\n                        ruleId: `${checkName}/limits/max_runs_exceeded`,\n                        message: `Run limit exceeded for '${checkName}' (attempt ${soFar + 1} > ${cap}).`,\n                        severity: 'error',\n                        category: 'logic',\n                      },\n                    ],\n                  },\n                } as any;\n              }\n              this.runCounters.set(k, soFar + 1);\n            }\n          } catch {}\n          // Skip if this check was already completed by item-level branch scheduler\n          if (results.has(checkName)) {\n            if (debug) log(`üîß Debug: Skipping ${checkName} (already satisfied earlier)`);\n            return { checkName, error: null, result: results.get(checkName)! };\n          }\n          const checkConfig = config.checks![checkName];\n          if (!checkConfig) {\n            return {\n              checkName,\n              error: `No configuration found for check: ${checkName}`,\n              result: null,\n            };\n          }\n\n          // Global one_shot tag: if this check already ran in this grouped run, skip\n          try {\n            const tags = (checkConfig.tags || []) as string[];\n            const isOneShot = Array.isArray(tags) && tags.includes('one_shot');\n            const ran = (this.executionStats.get(checkName)?.totalRuns || 0) > 0;\n            if (isOneShot && ran) {\n              if (debug) log(`‚è≠  Skipped (one_shot already executed): ${checkName}`);\n              return { checkName, error: null, result: results.get(checkName)! };\n            }\n          } catch {}\n\n          // Intra-level dependency barrier: if any direct dependencies of this check\n          // are also scheduled in this level, wait until they finish and populate\n          // the results map (this ensures forEach parents run before their dependents).\n          try {\n            const depsInLevel = (dependencies[checkName] || []).filter((d: string) =>\n              checksInLevel.includes(d)\n            );\n            const hasForEachParent = (checkConfig.depends_on || []).some(\n              (d: string) => (config.checks?.[d] as any)?.forEach === true\n            );\n            if (depsInLevel.length > 0) {\n              const deadline = Date.now() + 10_000; // 10s safety\n              // Wait for parents in this level to finish\n              while (depsInLevel.some((d: string) => !results.has(d))) {\n                await this.sleep(2);\n                if (Date.now() > deadline) break;\n              }\n              // If parent produced this check inline (per-item), results will have it\n              if (hasForEachParent) {\n                const deadline2 = Date.now() + 10_000;\n                while (!results.has(checkName) && Date.now() <= deadline2) {\n                  await this.sleep(2);\n                }\n              }\n              // If this step was scheduled via forward-run, wait briefly for it to complete to avoid duplicate execution\n              if (this.forwardDependentsScheduled.has(checkName)) {\n                const deadline3 = Date.now() + 10_000;\n                while (!results.has(checkName) && Date.now() <= deadline3) await this.sleep(2);\n              }\n              if (results.has(checkName)) {\n                if (debug)\n                  log(`üîß Debug: Skipping ${checkName} (satisfied inline by forEach parent)`);\n                return { checkName, error: null, result: results.get(checkName)! };\n              }\n            }\n          } catch {}\n\n          const checkStartTime = Date.now();\n          // (dedupe handled by tagging result object when pre-stored before routing)\n          completedChecksCount++;\n          logger.step(`Running check: ${checkName} [${completedChecksCount}/${totalChecksCount}]`);\n\n          try {\n            if (debug) {\n              log(`üîß Debug: Starting check: ${checkName} at level ${executionGroup.level}`);\n            }\n\n            // Get the appropriate provider for this check type\n            const providerType = checkConfig.type || 'ai';\n            const provider = this.providerRegistry.getProviderOrThrow(providerType);\n            if (debug) {\n              log(`üîß Debug: Provider for '${checkName}' is '${providerType}'`);\n            } else if (process.env.VISOR_DEBUG === 'true') {\n              try {\n                console.log(`[engine] provider for ${checkName} -> ${providerType}`);\n              } catch {}\n            }\n            this.setProviderWebhookContext(provider);\n\n            // Create provider config for this specific check\n            const extendedCheckConfig = checkConfig as CheckConfig & {\n              level?: string;\n              message?: string;\n            };\n\n            const providerConfig: CheckProviderConfig = {\n              type: providerType,\n              prompt: checkConfig.prompt,\n              exec: checkConfig.exec,\n              focus: checkConfig.focus || this.mapCheckNameToFocus(checkName),\n              schema: checkConfig.schema,\n              group: checkConfig.group,\n              checkName: checkName, // Add checkName for sessionID\n              eventContext: this.enrichEventContext(prInfo.eventContext),\n              transform: checkConfig.transform,\n              transform_js: checkConfig.transform_js,\n              // Important: pass through provider-level timeout from check config\n              // (e.g., command/http_client providers expect seconds/ms here)\n              timeout: checkConfig.timeout,\n              level: extendedCheckConfig.level,\n              message: extendedCheckConfig.message,\n              env: checkConfig.env,\n              forEach: checkConfig.forEach,\n              // Provide output history so providers can access latest outputs for Liquid rendering\n              __outputHistory: this.outputHistory,\n              // Pass through any provider-specific keys (e.g., op/values for github provider)\n              ...checkConfig,\n              ai: {\n                ...(checkConfig.ai || {}),\n                timeout: timeout || 600000,\n                debug: debug,\n              },\n            };\n\n            // Pass results from ALL transitive dependencies (not just direct ones)\n            // This ensures the \"outputs\" variable has access to all ancestor check results\n            const dependencyResults = new Map<string, ReviewSummary>();\n            let isForEachDependent = false;\n            let forEachItems: unknown[] = [];\n            let forEachParentName: string | undefined;\n            const forEachParents: string[] = []; // Track ALL forEach parents\n\n            // Get all transitive dependencies (ancestors) for this check\n            const allDependencies = DependencyResolver.getAllDependencies(\n              checkName,\n              dependencyGraph.nodes\n            );\n\n            // Include results from ALL dependencies (direct and transitive)\n            for (const depId of allDependencies) {\n              if (results.has(depId)) {\n                const depResult = results.get(depId)!;\n                dependencyResults.set(depId, depResult);\n              }\n            }\n\n            // If any direct dependency failed or was skipped, skip this check\n            // Support OR-groups using pipe syntax: \"a|b|c\" means any of these satisfies the dependency\n            const depTokens = checkConfig.depends_on || [];\n            const allOfDeps: string[] = [];\n            const anyOfGroups: string[][] = [];\n            for (const tok of depTokens) {\n              if (typeof tok === 'string' && tok.includes('|')) {\n                const group = tok\n                  .split('|')\n                  .map(s => s.trim())\n                  .filter(Boolean);\n                if (group.length > 0) anyOfGroups.push(group);\n              } else if (tok) {\n                allOfDeps.push(String(tok));\n              }\n            }\n            const failedDeps: string[] = [];\n            // Evaluate ALL-OF dependencies normally\n            for (const depId of allOfDeps) {\n              const depRes = results.get(depId);\n              // If a direct dependency has not produced a result in this run, consider it unsatisfied\n              // and gate the current check. This prevents executing dependents before their prerequisites.\n              if (!depRes) {\n                failedDeps.push(depId);\n                continue;\n              }\n\n              // Check if dependency was skipped\n              const wasSkipped = (depRes.issues || []).some(issue => {\n                const id = issue.ruleId || '';\n                return id.endsWith('/__skipped');\n              });\n\n              // If dependency is a forEach parent, do NOT apply global fatal gating here.\n              // We'll gate per-item inside the forEach loop to avoid stopping other branches.\n              const depExtended = depRes as ExtendedReviewSummary;\n              const isDepForEachParent = !!depExtended.isForEach;\n\n              // Treat these as fatal in direct dependencies (non-forEach only):\n              //  - provider/command execution errors and timeouts\n              //  - transform errors\n              //  - forEach validation/iteration errors\n              //  - fail_if conditions (global or check-specific)\n              // For forEach parents we defer gating to per-item handling below.\n              let hasFatalFailure = false;\n              if (!isDepForEachParent) {\n                const issues = depRes.issues || [];\n                hasFatalFailure = issues.some(i => this.isGatingFatal(i));\n              }\n\n              // Respect dependency's continue_on_failure: if set, do not gate dependents on failure\n              try {\n                const depCfg = config?.checks?.[depId] as\n                  | import('./types/config').CheckConfig\n                  | undefined;\n                if (depCfg?.continue_on_failure) {\n                  if (hasFatalFailure && debug) {\n                    log(\n                      `üîß Debug: dependency '${depId}' failed but continue_on_failure=true ‚Äî not gating`\n                    );\n                  }\n                  hasFatalFailure = false;\n                }\n              } catch {}\n\n              if (debug) {\n                log(\n                  `üîß Debug: gating check '${checkName}' against dep '${depId}': wasSkipped=${wasSkipped} hasFatalFailure=${hasFatalFailure}`\n                );\n              }\n              if (wasSkipped || hasFatalFailure) failedDeps.push(depId);\n            }\n\n            // Evaluate ANY-OF groups: each group must have at least one satisfied dependency\n            for (const group of anyOfGroups) {\n              let groupSatisfied = false;\n              for (const depId of group) {\n                const depRes = results.get(depId);\n                if (!depRes) continue;\n                const wasSkipped = (depRes.issues || []).some(issue => {\n                  const id = issue.ruleId || '';\n                  return id.endsWith('/__skipped');\n                });\n                const depExtended = depRes as ExtendedReviewSummary;\n                const isDepForEachParent = !!depExtended.isForEach;\n                let hasFatalFailure = false;\n                if (!isDepForEachParent) {\n                  const issues = depRes.issues || [];\n                  hasFatalFailure = issues.some(i => this.isGatingFatal(i));\n                }\n                // Respect continue_on_failure\n                try {\n                  const depCfg = config?.checks?.[depId] as\n                    | import('./types/config').CheckConfig\n                    | undefined;\n                  if (depCfg?.continue_on_failure) {\n                    hasFatalFailure = false;\n                  }\n                } catch {}\n                if (!wasSkipped && !hasFatalFailure) {\n                  groupSatisfied = true;\n                  break;\n                }\n              }\n              if (!groupSatisfied) {\n                failedDeps.push(group.join('|'));\n              }\n            }\n\n            if (failedDeps.length > 0) {\n              // If this step was explicitly scheduled by a correction cycle (on_fail forward-run),\n              // bypass dependency gating so the corrective chain can execute deterministically.\n              const isCorrectionCycle = this.forwardDependentsScheduled.has(checkName);\n              if (!isCorrectionCycle) {\n                this.recordSkip(checkName, 'dependency_failed');\n                logger.info(`‚è≠  Skipped (dependency failed: ${failedDeps.join(', ')})`);\n                return {\n                  checkName,\n                  error: null,\n                  result: { issues: [] },\n                  skipped: true,\n                };\n              } else {\n                try {\n                  logger.info(\n                    `‚Ü™ correction-cycle: bypassing dependency gate for '${checkName}' (failed: ${failedDeps.join(', ')})`\n                  );\n                } catch {}\n              }\n            }\n\n            // Check direct dependencies (including OR-group members) for forEach behavior\n            const expandedForEachDeps: string[] = [];\n            for (const tok of depTokens) {\n              if (typeof tok === 'string' && tok.includes('|'))\n                expandedForEachDeps.push(\n                  ...tok\n                    .split('|')\n                    .map(s => s.trim())\n                    .filter(Boolean)\n                );\n              else if (tok) expandedForEachDeps.push(String(tok));\n            }\n            for (const depId of expandedForEachDeps) {\n              if (results.has(depId)) {\n                const depResult = results.get(depId)!;\n\n                // Check if this dependency has forEach enabled\n                const depForEachResult = depResult as ExtendedReviewSummary;\n\n                if (\n                  depForEachResult.isForEach ||\n                  Array.isArray(depForEachResult.forEachItemResults) ||\n                  Array.isArray(depForEachResult.forEachItems)\n                ) {\n                  if (!isForEachDependent) {\n                    // First forEach dependency found - use it as the primary\n                    isForEachDependent = true;\n                    forEachItems = Array.isArray(depForEachResult.forEachItems)\n                      ? depForEachResult.forEachItems!\n                      : new Array(\n                          Array.isArray(depForEachResult.forEachItemResults)\n                            ? depForEachResult.forEachItemResults!.length\n                            : 0\n                        ).fill(undefined);\n                    forEachParentName = depId;\n                  }\n                  // Track all forEach parents for unwrapping\n                  forEachParents.push(depId);\n                }\n              }\n            }\n\n            // Determine if we should use session reuse\n            let sessionInfo: { parentSessionId?: string; reuseSession?: boolean } | undefined =\n              undefined;\n            if (sessionReuseChecks.has(checkName)) {\n              let parentCheckName = sessionProviders.get(checkName);\n              if (parentCheckName && parentCheckName.includes && parentCheckName.includes('|')) {\n                parentCheckName = parentCheckName.split('|')[0].trim();\n              }\n              if (parentCheckName && sessionIds.has(parentCheckName)) {\n                const parentSessionId = sessionIds.get(parentCheckName)!;\n\n                sessionInfo = {\n                  parentSessionId: parentSessionId,\n                  reuseSession: true,\n                };\n\n                if (debug) {\n                  log(\n                    `üîÑ Debug: Check ${checkName} will reuse session from parent ${parentCheckName}: ${parentSessionId}`\n                  );\n                }\n              } else {\n                if (debug) {\n                  log(\n                    `‚ö†Ô∏è Warning: Check ${checkName} requires session reuse but parent ${parentCheckName} session not found`\n                  );\n                }\n              }\n            }\n\n            // For checks that create new sessions, generate a session ID\n            let currentSessionId: string | undefined = undefined;\n            if (!sessionInfo?.reuseSession) {\n              const timestamp = new Date().toISOString();\n              currentSessionId = `visor-${timestamp.replace(/[:.]/g, '-')}-${checkName}`;\n              sessionIds.set(checkName, currentSessionId);\n              if (debug) {\n                log(`üÜï Debug: Check ${checkName} will create new session: ${currentSessionId}`);\n              }\n\n              // Add session ID to provider config\n              providerConfig.sessionId = currentSessionId;\n            }\n\n            // Handle forEach dependent execution\n            let finalResult: ReviewSummary;\n\n            if (isForEachDependent && forEachParentName) {\n              if (!Array.isArray(forEachItems)) {\n                forEachItems = [];\n              }\n              if (!Array.isArray(forEachItems)) {\n                this.recordSkip(checkName, 'dependency_failed');\n                return {\n                  checkName,\n                  error: null,\n                  result: { issues: [] },\n                  skipped: true,\n                };\n              }\n              // Record forEach preview items\n              this.recordForEachPreview(checkName, forEachItems);\n\n              try {\n                if (process.env.VISOR_DEBUG === 'true') {\n                  console.error(\n                    `[foreach] check=${checkName} forEachItems=${forEachItems.length} hasIf=${String(\n                      !!checkConfig.if\n                    )} ifExpr=${checkConfig.if ? this.truncate(checkConfig.if, 80) : ''}`\n                  );\n                }\n              } catch {}\n\n              // If the forEach parent returned an empty array, skip this check entirely\n              if (forEachItems.length === 0) {\n                if (debug) {\n                  log(\n                    `üîÑ Debug: Skipping check \"${checkName}\" - forEach check \"${forEachParentName}\" returned 0 items`\n                  );\n                }\n                logger.info(`  forEach: no items from \"${forEachParentName}\", skipping check...`);\n                this.recordSkip(checkName, 'dependency_failed');\n\n                // Return a special marker result so that dependent checks can detect the skip\n                finalResult = {\n                  issues: [],\n                  output: [],\n                } as ReviewSummary;\n\n                // Mark this result as forEach-capable but with empty items\n                (finalResult as ExtendedReviewSummary).isForEach = true;\n                (finalResult as ExtendedReviewSummary).forEachItems = [];\n\n                // Skip to the end - don't execute this check\n              } else {\n                // Emit explicit debug to stdout so CLI e2e can assert it\n                if (\n                  debug &&\n                  process.env.VISOR_OUTPUT_FORMAT !== 'json' &&\n                  process.env.VISOR_OUTPUT_FORMAT !== 'sarif'\n                ) {\n                  console.log(\n                    `üîÑ Debug: Check \"${checkName}\" depends on forEach check \"${forEachParentName}\", executing ${forEachItems.length} times`\n                  );\n                }\n\n                // Log forEach processing start (non-debug)\n                const __itemCount = Array.isArray(forEachItems) ? forEachItems.length : 0;\n                logger.info(\n                  `  forEach: processing ${__itemCount} items from \"${forEachParentName}\"...`\n                );\n\n                const allIssues: ReviewIssue[] = [];\n                const allOutputs: unknown[] = new Array(forEachItems.length);\n                const aggregatedContents: string[] = [];\n                const perItemResults: Array<ReviewSummary | undefined> = new Array(\n                  forEachItems.length\n                );\n\n                // Aggregators for inline descendant execution (branch-first mode for simple chains)\n                const inlineAgg = new Map<\n                  string,\n                  {\n                    issues: ReviewIssue[];\n                    outputs: unknown[];\n                    contents: string[];\n                    perItemResults: ReviewSummary[];\n                  }\n                >();\n\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const execInlineDescendants = async (\n                  parentName: string,\n                  itemIndex: number,\n                  baseDeps: Map<string, ReviewSummary>\n                ): Promise<void> => {\n                  const children = (childrenByParent.get(parentName) || []).filter(child => {\n                    const deps = dependencies[child] || [];\n                    // Only handle simple chains inline: exactly one dependency which is the parent\n                    return deps.length === 1 && deps[0] === parentName;\n                  });\n\n                  for (const childName of children) {\n                    const childCfg = config.checks![childName];\n                    const childProviderType = childCfg.type || 'ai';\n                    const childProv = this.providerRegistry.getProviderOrThrow(childProviderType);\n                    this.setProviderWebhookContext(childProv);\n                    const childProviderConfig: CheckProviderConfig = {\n                      type: childProviderType,\n                      prompt: childCfg.prompt,\n                      exec: childCfg.exec,\n                      focus: childCfg.focus || this.mapCheckNameToFocus(childName),\n                      schema: childCfg.schema,\n                      group: childCfg.group,\n                      checkName: childName,\n                      eventContext: this.enrichEventContext(prInfo.eventContext),\n                      transform: childCfg.transform,\n                      transform_js: childCfg.transform_js,\n                      env: childCfg.env,\n                      forEach: childCfg.forEach,\n                      // Include provider-specific keys like op/values for non-AI providers\n                      ...childCfg,\n                      ai: {\n                        ...(childCfg.ai || {}),\n                        timeout: timeout || 600000,\n                        debug: debug,\n                      },\n                    };\n                    try {\n                      emitNdjsonSpanWithEvents('visor.check', { 'visor.check.id': checkName }, [\n                        { name: 'check.started' },\n                        { name: 'check.completed' },\n                      ]);\n                    } catch {}\n\n                    // If the parent item had a fatal failure per mask, skip this child for this branch\n                    const parentAgg = results.get(parentName) as ExtendedReviewSummary | undefined;\n                    const maskFatal =\n                      !!parentAgg?.forEachFatalMask &&\n                      parentAgg!.forEachFatalMask![itemIndex] === true;\n                    if (maskFatal) {\n                      continue;\n                    }\n\n                    // Evaluate per-item if condition\n                    if (childCfg.if) {\n                      const itemScope: ScopePath = [{ check: parentName, index: itemIndex }];\n                      const condResults = this.buildSnapshotDependencyResults(\n                        itemScope,\n                        undefined,\n                        prInfo.eventType\n                      );\n                      for (const [k, v] of baseDeps.entries()) condResults.set(k, v);\n                      const gateChild = await this.shouldRunCheck(\n                        childName,\n                        childCfg.if,\n                        prInfo,\n                        condResults,\n                        debug,\n                        undefined,\n                        /* failSecure */ true\n                      );\n                      if (!gateChild.shouldRun) {\n                        continue;\n                      }\n                    }\n\n                    // Execute child for this item (record stats)\n                    const childIterStart = this.recordIterationStart(childName);\n                    // Build snapshot-based dependency view for this item scope\n                    const itemScope: ScopePath = [{ check: parentName, index: itemIndex }];\n                    const snapshotDeps = this.buildSnapshotDependencyResults(\n                      itemScope,\n                      undefined,\n                      prInfo.eventType\n                    );\n                    for (const [k, v] of baseDeps.entries()) snapshotDeps.set(k, v);\n\n                    let childItemRes: ReviewSummary;\n                    try {\n                      childItemRes = await this.executeWithRouting(\n                        childName,\n                        childCfg,\n                        childProv,\n                        childProviderConfig,\n                        prInfo,\n                        snapshotDeps,\n                        sessionInfo,\n                        config,\n                        dependencyGraph,\n                        debug,\n                        results,\n                        { index: itemIndex, total: forEachItems.length, parent: parentName }\n                      );\n                    } catch (error) {\n                      const msg = error instanceof Error ? error.message : String(error);\n                      childItemRes = {\n                        issues: [\n                          {\n                            file: '',\n                            line: 0,\n                            ruleId: `${childName}/forEach/iteration_error`,\n                            message: msg,\n                            severity: 'error',\n                            category: 'logic',\n                          },\n                        ],\n                      } as ReviewSummary;\n                    }\n\n                    // Per-item fail_if\n                    if (config && (config.fail_if || childCfg.fail_if)) {\n                      const fRes = await this.evaluateFailureConditions(\n                        childName,\n                        childItemRes,\n                        config,\n                        prInfo,\n                        results\n                      );\n                      if (fRes.length > 0) {\n                        const fIssues = fRes\n                          .filter(f => f.failed)\n                          .map(f => ({\n                            file: 'system',\n                            line: 0,\n                            ruleId: f.conditionName,\n                            message: f.message || `Failure condition met: ${f.expression}`,\n                            severity: (f.severity || 'error') as\n                              | 'info'\n                              | 'warning'\n                              | 'error'\n                              | 'critical',\n                            category: 'logic' as const,\n                          }));\n                        childItemRes.issues = [...(childItemRes.issues || []), ...fIssues];\n                      }\n                    }\n\n                    if (!inlineAgg.has(childName)) {\n                      inlineAgg.set(childName, {\n                        issues: [],\n                        outputs: new Array(forEachItems.length),\n                        contents: [],\n                        perItemResults: new Array(forEachItems.length),\n                      });\n                    }\n                    const agg = inlineAgg.get(childName)!;\n                    if (childItemRes.issues) agg.issues.push(...childItemRes.issues);\n                    const out = (childItemRes as any).output;\n                    agg.outputs[itemIndex] = out;\n                    agg.perItemResults[itemIndex] = childItemRes;\n                    const c = (childItemRes as any).content;\n                    if (typeof c === 'string' && c.trim()) agg.contents.push(c.trim());\n\n                    // Record iteration completion for stats\n                    const childHadFatal = this.hasFatal(childItemRes.issues || []);\n                    this.recordIterationComplete(\n                      childName,\n                      childIterStart,\n                      !childHadFatal,\n                      childItemRes.issues || [],\n                      (childItemRes as any).output\n                    );\n\n                    // Track per-item outputs in history so on_finish.goto_js can\n                    // compute waves from outputs_history['child'] reliably.\n                    try {\n                      const outVal: any = (childItemRes as any).output;\n                      // Only push non-array values (arrays are reserved for forEach parents)\n                      if (outVal !== undefined && !Array.isArray(outVal)) {\n                        this.trackOutputHistory(childName, outVal);\n                      }\n                    } catch {}\n\n                    // Recurse further for simple chains\n                    const nextBase = new Map(baseDeps);\n                    nextBase.set(childName, childItemRes);\n                    await execInlineDescendants(childName, itemIndex, nextBase);\n                  }\n                };\n\n                // Create task functions (not executed yet) - these will be executed with controlled concurrency\n                // via executeWithLimitedParallelism to respect maxParallelism setting\n                const itemTasks = forEachItems.map((item, itemIndex) => async () => {\n                  try {\n                    emitNdjsonSpanWithEvents(\n                      'visor.foreach.item',\n                      {\n                        'visor.check.id': checkName,\n                        'visor.foreach.index': itemIndex,\n                        'visor.foreach.total': forEachItems.length,\n                      },\n                      []\n                    );\n                  } catch {}\n                  // Build snapshot-based dependency view for this item scope (no per-item cloning)\n                  const itemScope: ScopePath = [{ check: forEachParentName!, index: itemIndex }];\n                  const snapshotDeps = this.buildSnapshotDependencyResults(\n                    itemScope,\n                    undefined,\n                    prInfo.eventType\n                  );\n\n                  // Per-item dependency gating for forEach parents: if a dependency failed for this item, skip this iteration\n                  if ((checkConfig.depends_on || []).length > 0) {\n                    // Do not short-circuit per-item execution solely based on parent fatality masks.\n                    // Downstream fail_if on the child will surface errors appropriately.\n                    // This keeps dependent validations running and avoids total suppression.\n                  }\n\n                  // Evaluate if condition for this forEach item\n                  if (checkConfig.if) {\n                    const gateItem = await this.shouldRunCheck(\n                      checkName,\n                      checkConfig.if,\n                      prInfo,\n                      snapshotDeps,\n                      debug,\n                      undefined,\n                      /* failSecure */ true\n                    );\n                    try {\n                      if (process.env.VISOR_DEBUG === 'true') {\n                        console.error(\n                          `[if-gate-item] check=${checkName} expr=\"${checkConfig.if}\" shouldRun=${String(gateItem.shouldRun)} env.ENABLE_FACT_VALIDATION=${String(process.env.ENABLE_FACT_VALIDATION)}`\n                        );\n                      }\n                    } catch {}\n\n                    if (!gateItem.shouldRun) {\n                      if (debug) {\n                        log(\n                          `üîÑ Debug: Skipping forEach item ${itemIndex + 1} for check \"${checkName}\" (if condition evaluated to false)`\n                        );\n                      }\n                      // Return empty result for skipped items\n                      return {\n                        index: itemIndex,\n                        itemResult: { issues: [] } as ReviewSummary,\n                        skipped: true,\n                      };\n                    }\n                  }\n\n                  if (debug) {\n                    log(\n                      `üîÑ Debug: Executing check \"${checkName}\" for item ${itemIndex + 1}/${forEachItems.length}`\n                    );\n                  }\n\n                  // Track iteration start\n                  const iterationStart = this.recordIterationStart(checkName);\n\n                  // Execute with retry/routing semantics per item\n                  let itemResult: ReviewSummary;\n                  try {\n                    itemResult = await this.executeWithRouting(\n                      checkName,\n                      checkConfig,\n                      provider,\n                      providerConfig,\n                      prInfo,\n                      snapshotDeps,\n                      sessionInfo,\n                      config,\n                      dependencyGraph,\n                      debug,\n                      results,\n                      /*foreachContext*/ {\n                        index: itemIndex,\n                        total: forEachItems.length,\n                        parent: forEachParentName,\n                      }\n                    );\n                  } catch (error) {\n                    const errorMessage = error instanceof Error ? error.message : String(error);\n                    itemResult = {\n                      issues: [\n                        {\n                          file: '',\n                          line: 0,\n                          ruleId: `${checkName}/forEach/iteration_error`,\n                          message: errorMessage,\n                          severity: 'error',\n                          category: 'logic',\n                        },\n                      ],\n                    } as ReviewSummary;\n                  }\n                  // no-op\n\n                  // Evaluate fail_if per item so a single failing branch does not stop others\n                  if (config && (config.fail_if || checkConfig.fail_if)) {\n                    const itemFailures = await this.evaluateFailureConditions(\n                      checkName,\n                      itemResult,\n                      config,\n                      prInfo,\n                      results\n                    );\n                    if (itemFailures.length > 0) {\n                      const failureIssues = itemFailures\n                        .filter(f => f.failed)\n                        .map(f => ({\n                          file: 'system',\n                          line: 0,\n                          ruleId: f.conditionName,\n                          message: f.message || `Failure condition met: ${f.expression}`,\n                          severity: (f.severity || 'error') as\n                            | 'info'\n                            | 'warning'\n                            | 'error'\n                            | 'critical',\n                          category: 'logic' as const,\n                        }));\n                      itemResult.issues = [...(itemResult.issues || []), ...failureIssues];\n                    }\n                  }\n\n                  // Record iteration completion\n                  // Check if this iteration had fatal errors\n                  const hadFatalError = (itemResult.issues || []).some(issue => {\n                    const id = issue.ruleId || '';\n                    return (\n                      id === 'command/execution_error' ||\n                      id.endsWith('/command/execution_error') ||\n                      id === 'command/transform_js_error' ||\n                      id.endsWith('/command/transform_js_error') ||\n                      id === 'command/transform_error' ||\n                      id.endsWith('/command/transform_error') ||\n                      id === 'forEach/undefined_output' ||\n                      id.endsWith('/forEach/undefined_output')\n                    );\n                  });\n                  const iterationDuration = (Date.now() - iterationStart) / 1000;\n                  this.recordIterationComplete(\n                    checkName,\n                    iterationStart,\n                    !hadFatalError, // Success if no fatal errors\n                    itemResult.issues || [],\n                    (itemResult as any).output\n                  );\n\n                  // Track output history for each forEach child iteration so\n                  // stage-level selectors and aggregators can reason about\n                  // the last wave across items.\n                  const itemOutput = (itemResult as any).output;\n                  if (itemOutput !== undefined) {\n                    // Tag history entry with loop info from parent\n                    let parentLoopIdx = 0;\n                    try {\n                      const ph = (this.outputHistory.get(forEachParentName!) || []) as unknown[];\n                      parentLoopIdx = ph.filter(x => Array.isArray(x)).length;\n                    } catch {}\n                    let histEntry: any;\n                    const itemId = (() => {\n                      try {\n                        return String((itemOutput as any)?.id ?? itemIndex + 1);\n                      } catch {\n                        return String(itemIndex + 1);\n                      }\n                    })();\n                    if (itemOutput && typeof itemOutput === 'object') {\n                      histEntry = {\n                        ...(itemOutput as any),\n                        id: itemId,\n                        parent: forEachParentName,\n                        loop_idx: parentLoopIdx,\n                        last_loop: true,\n                      };\n                    } else {\n                      histEntry = {\n                        value: itemOutput,\n                        id: itemId,\n                        parent: forEachParentName,\n                        loop_idx: parentLoopIdx,\n                        last_loop: true,\n                      } as any;\n                    }\n                    try {\n                      if ((itemResult as any).__histTracked === true) {\n                        // Provider already tracked this iteration; enrich the last entry with wave metadata\n                        const arr = (this.outputHistory.get(checkName) || []) as any[];\n                        if (\n                          arr.length > 0 &&\n                          arr[arr.length - 1] &&\n                          typeof arr[arr.length - 1] === 'object'\n                        ) {\n                          Object.assign(arr[arr.length - 1], {\n                            id: (arr[arr.length - 1] as any).id || histEntry.id,\n                            parent: forEachParentName,\n                            loop_idx: parentLoopIdx,\n                            last_loop: true,\n                          });\n                          this.outputHistory.set(checkName, arr);\n                        } else {\n                          this.trackOutputHistory(checkName, histEntry);\n                        }\n                      } else {\n                        this.trackOutputHistory(checkName, histEntry);\n                      }\n                    } catch {}\n                  } else {\n                    // Ensure completeness: synthesize a last_loop record for this item\n                    // so routing can scan only the child history without consulting the parent.\n                    let parentLoopIdx = 0;\n                    try {\n                      const ph = (this.outputHistory.get(forEachParentName!) || []) as unknown[];\n                      parentLoopIdx = ph.filter(x => Array.isArray(x)).length;\n                    } catch {}\n                    const itemId = String(itemIndex + 1);\n                    const synth: any = {\n                      id: itemId,\n                      parent: forEachParentName,\n                      loop_idx: parentLoopIdx,\n                      last_loop: true,\n                      is_valid: false,\n                      confidence: 'low',\n                      reason: 'missing',\n                    };\n                    this.trackOutputHistory(checkName, synth);\n                  }\n\n                  // General branch-first scheduling for this item: execute all descendants (from current node only) when ready\n                  const descendantSet = (() => {\n                    const visited = new Set<string>();\n                    const stack = [checkName];\n                    while (stack.length) {\n                      const p = stack.pop()!;\n                      const kids = childrenByParent.get(p) || [];\n                      for (const k of kids) {\n                        if (!visited.has(k)) {\n                          visited.add(k);\n                          stack.push(k);\n                        }\n                      }\n                    }\n                    return visited;\n                  })();\n\n                  const perItemDone = new Set<string>([...forEachParents, checkName]);\n                  const perItemDepMap = new Map<string, ReviewSummary>();\n                  perItemDepMap.set(checkName, itemResult);\n\n                  const isFatal = (r: ReviewSummary | undefined): boolean => {\n                    if (!r) return true;\n                    return this.hasFatal(r.issues || []);\n                  };\n\n                  while (true) {\n                    let progressed = false;\n                    for (const node of descendantSet) {\n                      if (perItemDone.has(node)) continue;\n                      const nodeCfg = config.checks![node];\n                      if (!nodeCfg) continue;\n                      const deps = dependencies[node] || [];\n\n                      // Are all deps satisfied for this item according to aggregate visibility/masks?\n                      let ready = true;\n                      for (const d of deps) {\n                        // If we have a per-item result for this dependency, honor its fatality\n                        const perItemRes = perItemDepMap.get(d);\n                        if (perItemRes) {\n                          if (isFatal(perItemRes)) {\n                            ready = false;\n                            break;\n                          }\n                          continue;\n                        }\n                        // If this dependency was executed earlier in this item's chain, it's satisfied\n                        if (perItemDone.has(d)) continue;\n                        const agg = results.get(d) as ExtendedReviewSummary | undefined;\n                        if (!agg) {\n                          ready = false;\n                          break;\n                        }\n                        if (agg.isForEach || Array.isArray(agg.forEachItemResults)) {\n                          const maskFatal =\n                            !!agg.forEachFatalMask && agg.forEachFatalMask[itemIndex] === true;\n                          if (maskFatal) {\n                            ready = false;\n                            break;\n                          }\n                        } else {\n                          if (isFatal(agg)) {\n                            ready = false;\n                            break;\n                          }\n                        }\n                      }\n                      if (!ready) continue;\n\n                      // if condition per item\n                      if (nodeCfg.if) {\n                        const itemScope: ScopePath = [\n                          { check: forEachParentName, index: itemIndex },\n                        ];\n                        const condResults = this.buildSnapshotDependencyResults(\n                          itemScope,\n                          undefined,\n                          prInfo.eventType\n                        );\n                        for (const [k, v] of perItemDepMap.entries()) condResults.set(k, v);\n                        const gateNode = await this.shouldRunCheck(\n                          node,\n                          nodeCfg.if,\n                          prInfo,\n                          condResults,\n                          debug,\n                          undefined,\n                          /* failSecure */ true\n                        );\n                        if (!gateNode.shouldRun) {\n                          perItemDone.add(node);\n                          progressed = true;\n                          continue;\n                        }\n                      }\n\n                      // Execute node for this item\n                      const nodeProvType = nodeCfg.type || 'ai';\n                      const nodeProv = this.providerRegistry.getProviderOrThrow(nodeProvType);\n                      this.setProviderWebhookContext(nodeProv);\n                      const nodeProviderConfig: CheckProviderConfig = {\n                        type: nodeProvType,\n                        prompt: nodeCfg.prompt,\n                        exec: nodeCfg.exec,\n                        focus: nodeCfg.focus || this.mapCheckNameToFocus(node),\n                        schema: nodeCfg.schema,\n                        group: nodeCfg.group,\n                        checkName: node,\n                        eventContext: this.enrichEventContext(prInfo.eventContext),\n                        transform: nodeCfg.transform,\n                        transform_js: nodeCfg.transform_js,\n                        env: nodeCfg.env,\n                        forEach: nodeCfg.forEach,\n                        ai: { timeout: timeout || 600000, debug: debug, ...(nodeCfg.ai || {}) },\n                      };\n\n                      const iterStart = this.recordIterationStart(node);\n                      // Build snapshot-based dependency map at item scope\n                      const itemScope: ScopePath = [{ check: forEachParentName, index: itemIndex }];\n                      const execDepMap = this.buildSnapshotDependencyResults(\n                        itemScope,\n                        undefined,\n                        prInfo.eventType\n                      );\n                      for (const [k, v] of perItemDepMap.entries()) execDepMap.set(k, v);\n\n                      let nodeItemRes: ReviewSummary;\n                      try {\n                        nodeItemRes = await this.executeWithRouting(\n                          node,\n                          nodeCfg,\n                          nodeProv,\n                          nodeProviderConfig,\n                          prInfo,\n                          execDepMap,\n                          sessionInfo,\n                          config,\n                          dependencyGraph,\n                          debug,\n                          results,\n                          {\n                            index: itemIndex,\n                            total: forEachItems.length,\n                            parent: forEachParentName,\n                          }\n                        );\n                      } catch (error) {\n                        const message = error instanceof Error ? error.message : String(error);\n                        nodeItemRes = {\n                          issues: [\n                            {\n                              file: '',\n                              line: 0,\n                              ruleId: `${node}/forEach/iteration_error`,\n                              message,\n                              severity: 'error',\n                              category: 'logic',\n                            },\n                          ],\n                        } as ReviewSummary;\n                      }\n\n                      if (config && (config.fail_if || nodeCfg.fail_if)) {\n                        const fRes = await this.evaluateFailureConditions(\n                          node,\n                          nodeItemRes,\n                          config,\n                          prInfo,\n                          results\n                        );\n                        if (fRes.length > 0) {\n                          const fIssues = fRes\n                            .filter(f => f.failed)\n                            .map(f => ({\n                              file: 'system',\n                              line: 0,\n                              ruleId: f.conditionName,\n                              message: f.message || `Failure condition met: ${f.expression}`,\n                              severity: (f.severity || 'error') as\n                                | 'info'\n                                | 'warning'\n                                | 'error'\n                                | 'critical',\n                              category: 'logic' as const,\n                            }));\n                          nodeItemRes.issues = [...(nodeItemRes.issues || []), ...fIssues];\n                        }\n                      }\n\n                      const hadFatal = isFatal(nodeItemRes);\n                      this.recordIterationComplete(\n                        node,\n                        iterStart,\n                        !hadFatal,\n                        nodeItemRes.issues || [],\n                        (nodeItemRes as any).output\n                      );\n\n                      // Aggregate results for this node across items\n                      if (!inlineAgg.has(node))\n                        inlineAgg.set(node, {\n                          issues: [],\n                          outputs: [],\n                          contents: [],\n                          perItemResults: [],\n                        });\n                      const agg = inlineAgg.get(node)!;\n                      if (nodeItemRes.issues) agg.issues.push(...nodeItemRes.issues);\n                      const nout = (nodeItemRes as any).output;\n                      if (nout !== undefined) agg.outputs.push(nout);\n                      agg.perItemResults.push(nodeItemRes);\n                      const ncontent = (nodeItemRes as any).content;\n                      if (typeof ncontent === 'string' && ncontent.trim())\n                        agg.contents.push(ncontent.trim());\n\n                      perItemDepMap.set(node, nodeItemRes);\n                      perItemDone.add(node);\n                      progressed = true;\n                    }\n                    if (!progressed) break;\n                  }\n\n                  // Log iteration progress\n                  logger.info(\n                    `  ‚úî ${itemIndex + 1}/${forEachItems.length} (${iterationDuration.toFixed(1)}s)`\n                  );\n\n                  perItemResults[itemIndex] = itemResult;\n                  return { index: itemIndex, itemResult };\n                });\n\n                // Determine runnable indices by intersecting masks across all direct forEach parents\n                const directForEachParents = (checkConfig.depends_on || []).filter(dep => {\n                  const r = results.get(dep) as ExtendedReviewSummary | undefined;\n                  return (\n                    !!r &&\n                    (r.isForEach ||\n                      Array.isArray(r.forEachItemResults) ||\n                      Array.isArray(r.forEachItems))\n                  );\n                });\n                if (directForEachParents.length > 0) {\n                  logger.debug(\n                    `  forEach: direct parents for \"${checkName}\": ${directForEachParents.join(', ')}`\n                  );\n                }\n\n                const isIndexFatalForParent = async (\n                  parent: string,\n                  idx: number\n                ): Promise<boolean> => {\n                  const agg = results.get(parent) as ExtendedReviewSummary | undefined;\n                  if (!agg) return false; // if missing, do not gate\n                  if (agg.forEachFatalMask && agg.forEachFatalMask[idx] === true) return true;\n                  const r = (agg.forEachItemResults && agg.forEachItemResults[idx]) || undefined;\n                  if (!r) return false;\n                  // 1) Issues-based fatality (provider/transform/timeout/fail_if markers)\n                  const hadFatalByIssues = this.hasFatal(r.issues || []);\n                  if (hadFatalByIssues) return true;\n                  // 2) Fail_if based fatality evaluated directly on the parent per-item result\n                  try {\n                    // For gating runnable indices, only consider the parent's own fail_if,\n                    // not the global fail_if. Global conditions are evaluated at the check\n                    // level and should not suppress per-item dependent execution.\n                    const parentFailIf =\n                      config && config.checks && config.checks[parent]\n                        ? (config.checks as any)[parent]?.fail_if\n                        : undefined;\n                    if (parentFailIf) {\n                      // If output is a string, try parsing JSON (full or tail) to honor fail_if semantics\n                      let rForEval: ReviewSummary = r;\n                      const rawOut = (r as any)?.output;\n                      if (typeof rawOut === 'string') {\n                        const parseTail = (text: string): unknown | null => {\n                          try {\n                            const lines = text.split('\\n');\n                            for (let i = lines.length - 1; i >= 0; i--) {\n                              const t = lines[i].trim();\n                              if (t.startsWith('{') || t.startsWith('[')) {\n                                const candidate = lines.slice(i).join('\\n').trim();\n                                if (\n                                  (candidate.startsWith('{') && candidate.endsWith('}')) ||\n                                  (candidate.startsWith('[') && candidate.endsWith(']'))\n                                ) {\n                                  return JSON.parse(candidate);\n                                }\n                              }\n                            }\n                          } catch {}\n                          try {\n                            return JSON.parse(text);\n                          } catch {\n                            return null;\n                          }\n                        };\n                        const parsed = parseTail(rawOut);\n                        if (parsed && typeof parsed === 'object') {\n                          rForEval = { ...r, output: parsed } as ReviewSummary & {\n                            output?: unknown;\n                          };\n                        }\n                      }\n                      const failures = await this.evaluateFailureConditions(\n                        parent,\n                        rForEval,\n                        // Evaluate against a shallow config that only carries the parent's fail_if\n                        {\n                          ...config,\n                          fail_if: undefined,\n                          checks: {\n                            ...(config?.checks || {}),\n                            [parent]: {\n                              ...(config?.checks as any)?.[parent],\n                              fail_if: parentFailIf,\n                            },\n                          },\n                        } as any,\n                        prInfo,\n                        results\n                      );\n                      if (failures.some(f => f.failed)) {\n                        // Temporary: surface why index is gated\n                      }\n                      if (failures.some(f => f.failed)) return true;\n                    }\n                  } catch {}\n                  return false;\n                };\n\n                // General behavior: when a check depends on a forEach parent, attempt to\n                // run for every produced item unless there are explicit fatal markers\n                // on the corresponding parent items. This avoids accidental suppression\n                // due to broad/global conditions and matches intuitive pipeline semantics.\n                const runnableIndices: number[] = [];\n                for (let idx = 0; idx < forEachItems.length; idx++) {\n                  let blocked = false;\n                  for (const p of directForEachParents) {\n                    if (await isIndexFatalForParent(p, idx)) {\n                      blocked = true;\n                      break;\n                    }\n                  }\n                  if (!blocked && typeof itemTasks[idx] === 'function') runnableIndices.push(idx);\n                }\n\n                // no-op\n                // Early skip if no runnable items after intersecting masks across all direct forEach parents\n                if (runnableIndices.length === 0) {\n                  // Failsafe: if the parent produced items but all were masked by dependency gating\n                  // and there are no explicit fatal markers on the parent per-item results,\n                  // attempt to run all items. This prevents accidental total gating due to\n                  // overly-broad fail_if on ancestors. This is general-purpose and keeps\n                  // dependent checks functional when parents are non-fatal.\n                  const parent = directForEachParents[0];\n                  let anyExplicitFatal = false;\n                  if (parent) {\n                    const agg = results.get(parent) as ExtendedReviewSummary | undefined;\n                    if (agg && Array.isArray(agg.forEachItemResults)) {\n                      for (const r of agg.forEachItemResults) {\n                        if (!r) continue;\n                        if (this.hasFatal(r?.issues || [])) {\n                          anyExplicitFatal = true;\n                          break;\n                        }\n                      }\n                    }\n                  }\n                  if (!anyExplicitFatal && forEachItems.length > 0) {\n                    logger.warn(\n                      `‚ö†Ô∏è  forEach: no runnable items for \"${checkName}\" after gating ‚Äî falling back to run all ${forEachItems.length}`\n                    );\n                    for (let idx = 0; idx < forEachItems.length; idx++) {\n                      if (typeof itemTasks[idx] === 'function') runnableIndices.push(idx);\n                    }\n                  }\n                  if (runnableIndices.length === 0) {\n                    this.recordSkip(checkName, 'dependency_failed');\n                    logger.info(`‚è≠  Skipped (dependency failed: no runnable items)`);\n                    return {\n                      checkName,\n                      error: null,\n                      result: { issues: [] },\n                      skipped: true,\n                    };\n                  }\n                }\n\n                const forEachConcurrency = Math.max(\n                  1,\n                  Math.min(runnableIndices.length, effectiveMaxParallelism)\n                );\n\n                if (debug && forEachConcurrency > 1) {\n                  log(\n                    `üîÑ Debug: Limiting forEach concurrency for check \"${checkName}\" to ${forEachConcurrency}`\n                  );\n                }\n\n                const scheduledTasks = runnableIndices\n                  .map(i => itemTasks[i])\n                  .filter(fn => typeof fn === 'function');\n                const forEachResults = await this.executeWithLimitedParallelism(\n                  scheduledTasks,\n                  forEachConcurrency,\n                  false\n                );\n\n                let processedCount = 0;\n                for (const result of forEachResults) {\n                  if (result.status === 'rejected') {\n                    // Instead of throwing, record the failure and continue with other iterations\n                    const error = result.reason;\n                    const errorMessage = error instanceof Error ? error.message : String(error);\n\n                    // Create an error issue for this failed iteration\n                    allIssues.push({\n                      ruleId: `${checkName}/forEach/iteration_error`,\n                      severity: 'error',\n                      category: 'logic',\n                      message: `forEach iteration failed: ${errorMessage}`,\n                      file: '',\n                      line: 0,\n                    });\n\n                    if (debug) {\n                      log(\n                        `üîÑ Debug: forEach iteration for check \"${checkName}\" failed: ${errorMessage}`\n                      );\n                    }\n                    continue;\n                  }\n\n                  // Skip results from skipped items (those gated by dependencies/if)\n                  if ((result.value as any).skipped) {\n                    continue;\n                  }\n\n                  const { index: finishedIndex, itemResult } = result.value as any;\n                  processedCount++;\n\n                  if (itemResult.issues) {\n                    allIssues.push(...itemResult.issues);\n                  }\n\n                  const resultWithOutput = itemResult as ReviewSummary & {\n                    output?: unknown;\n                    content?: string;\n                  };\n\n                  allOutputs[finishedIndex] = resultWithOutput.output;\n\n                  const itemContent = resultWithOutput.content;\n                  if (typeof itemContent === 'string' && itemContent.trim()) {\n                    aggregatedContents.push(itemContent.trim());\n                  } else {\n                    const outStr =\n                      typeof resultWithOutput.output === 'string'\n                        ? (resultWithOutput.output as string).trim()\n                        : '';\n                    if (outStr) aggregatedContents.push(outStr);\n                  }\n                }\n\n                // If no items were processed (all gated), mark this check as skipped for dependency_failed\n                if (processedCount === 0) {\n                  this.recordSkip(checkName, 'dependency_failed');\n                  logger.info(`‚è≠  Skipped (dependency failed for all items)`);\n                  return {\n                    checkName,\n                    error: null,\n                    result: { issues: [] },\n                    skipped: true,\n                  };\n                }\n\n                const finalOutput = allOutputs.length > 0 ? allOutputs : undefined;\n\n                finalResult = {\n                  issues: allIssues,\n                  ...(finalOutput !== undefined ? { output: finalOutput } : {}),\n                } as ExtendedReviewSummary;\n\n                // Mark this result as forEach-capable and attach per-item results for precise downstream gating\n                (finalResult as ExtendedReviewSummary).isForEach = true;\n                (finalResult as ExtendedReviewSummary).forEachItems = allOutputs;\n                (finalResult as ExtendedReviewSummary).forEachItemResults =\n                  perItemResults as ReviewSummary[];\n                // Compute fatal mask\n                try {\n                  const mask: boolean[] = (finalResult as ExtendedReviewSummary).forEachItemResults\n                    ? await Promise.all(\n                        Array.from({ length: forEachItems.length }, async (_, idx) => {\n                          const r = (finalResult as ExtendedReviewSummary).forEachItemResults![idx];\n                          if (!r) return false; // no result (skipped) ‚Üí not fatal for descendants\n                          let hadFatal = this.hasFatal(r.issues || []);\n                          try {\n                            const ids = (r.issues || []).map(i => i.ruleId).join(',');\n                            logger.debug(\n                              `  forEach: item ${idx + 1}/${forEachItems.length} issues=${(r.issues || []).length} ids=[${ids}]`\n                            );\n                          } catch {}\n                          if (!hadFatal && config && (config.fail_if || checkConfig.fail_if)) {\n                            try {\n                              const failures = await this.evaluateFailureConditions(\n                                checkName,\n                                r,\n                                config,\n                                prInfo,\n                                results\n                              );\n                              hadFatal = failures.some(f => f.failed);\n                            } catch {}\n                          }\n                          return hadFatal;\n                        })\n                      )\n                    : [];\n                  (finalResult as ExtendedReviewSummary).forEachFatalMask = mask;\n                  logger.debug(\n                    `  forEach: mask for \"${checkName}\" ‚Üí fatals=${mask.filter(Boolean).length}/${mask.length}`\n                  );\n                } catch {}\n\n                if (aggregatedContents.length > 0) {\n                  (finalResult as ReviewSummary & { content?: string }).content =\n                    aggregatedContents.join('\\n');\n                }\n\n                // Finalize inline descendant aggregations to full results, so later levels skip them\n                for (const [childName, agg] of inlineAgg.entries()) {\n                  const childCfg = config.checks![childName];\n                  const childEnrichedIssues = (agg.issues || []).map(issue => ({\n                    ...issue,\n                    checkName: childName,\n                    ruleId: `${childName}/${issue.ruleId}`,\n                    group: childCfg.group,\n                    schema: typeof childCfg.schema === 'object' ? 'custom' : childCfg.schema,\n                    template: childCfg.template,\n                    timestamp: Date.now(),\n                  }));\n                  const childFinal: ExtendedReviewSummary = {\n                    issues: childEnrichedIssues,\n                    ...(agg.outputs.length > 0 ? { output: agg.outputs } : {}),\n                    isForEach: true,\n                    forEachItems: agg.outputs,\n                    forEachItemResults: agg.perItemResults,\n                    ...(agg.contents.length > 0 ? { content: agg.contents.join('\\n') } : {}),\n                  };\n                  // Compute fatal mask for child aggregate\n                  try {\n                    const mask: boolean[] = Array.from(\n                      { length: agg.perItemResults.length },\n                      (_, idx) => {\n                        const r = agg.perItemResults[idx];\n                        if (!r) return false; // skipped item is not fatal for descendants\n                        const hadFatal = (r.issues || []).some(issue => {\n                          const id = issue.ruleId || '';\n                          return (\n                            issue.severity === 'error' ||\n                            issue.severity === 'critical' ||\n                            id === 'command/execution_error' ||\n                            id.endsWith('/command/execution_error') ||\n                            id === 'command/timeout' ||\n                            id.endsWith('/command/timeout') ||\n                            id === 'command/transform_js_error' ||\n                            id.endsWith('/command/transform_js_error') ||\n                            id === 'command/transform_error' ||\n                            id.endsWith('/command/transform_error') ||\n                            id.endsWith('/forEach/iteration_error') ||\n                            id === 'forEach/undefined_output' ||\n                            id.endsWith('/forEach/undefined_output') ||\n                            id.endsWith('_fail_if') ||\n                            id.endsWith('/global_fail_if')\n                          );\n                        });\n                        return hadFatal;\n                      }\n                    );\n                    childFinal.forEachFatalMask = mask;\n                  } catch {}\n                  results.set(childName, childFinal);\n                }\n\n                if (\n                  debug &&\n                  process.env.VISOR_OUTPUT_FORMAT !== 'json' &&\n                  process.env.VISOR_OUTPUT_FORMAT !== 'sarif'\n                ) {\n                  console.log(\n                    `üîÑ Debug: Completed forEach execution for check \"${checkName}\", total issues: ${allIssues.length}`\n                  );\n                }\n              } // End of else block for forEachItems.length > 0\n            } else {\n              // Normal single execution\n              // Evaluate if condition for non-forEach-dependent checks\n              if (checkConfig.if) {\n                const gate = await this.shouldRunCheck(\n                  checkName,\n                  checkConfig.if,\n                  prInfo,\n                  results,\n                  debug,\n                  undefined,\n                  /* failSecure */ true\n                );\n\n                if (!gate.shouldRun) {\n                  // Record skip with condition\n                  this.recordSkip(checkName, 'if_condition', checkConfig.if);\n                  logger.info(`‚è≠  Skipped (if: ${this.truncate(checkConfig.if, 40)})`);\n                  return {\n                    checkName,\n                    error: null,\n                    result: {\n                      issues: [],\n                    },\n                    skipped: true,\n                  };\n                }\n              }\n\n              // Execute with retry/routing semantics\n              finalResult = await this.executeWithRouting(\n                checkName,\n                checkConfig,\n                provider,\n                providerConfig,\n                prInfo,\n                dependencyResults,\n                sessionInfo,\n                config,\n                dependencyGraph,\n                debug,\n                results\n              );\n              try {\n                emitNdjsonSpanWithEvents('visor.check', { 'visor.check.id': checkName }, [\n                  { name: 'check.started' },\n                  { name: 'check.completed' },\n                ]);\n              } catch {}\n\n              // Pre-fail_if debug only; history is tracked earlier after provider execution.\n              try {\n                const outVal = (finalResult as any)?.output;\n                if (process.env.VISOR_DEBUG === 'true' && checkName === 'refine') {\n                  console.error(`[pre-fail-if refine] hasOutput=${String(outVal !== undefined)}`);\n                }\n              } catch {}\n\n              // Evaluate fail_if for normal (non-forEach) execution\n              if (config && (config.fail_if || checkConfig.fail_if)) {\n                try {\n                  if (debug) {\n                    const outAny = (finalResult as any)?.output;\n                    const keys =\n                      outAny && typeof outAny === 'object'\n                        ? Object.keys(outAny).join(',')\n                        : typeof outAny;\n                    console.log(`[debug] pre-fail_if ${checkName} output keys=${keys}`);\n                  }\n                } catch {}\n                const failureResults = await this.evaluateFailureConditions(\n                  checkName,\n                  finalResult,\n                  config,\n                  prInfo,\n                  results\n                );\n                // Make this result visible to subsequent inline routing before we possibly goto.\n                try {\n                  results.set(checkName, finalResult as ReviewSummary);\n                  this.commitJournal(\n                    checkName,\n                    finalResult as ExtendedReviewSummary,\n                    prInfo.eventType\n                  );\n                  try {\n                    (finalResult as any).__storedVisible = true;\n                  } catch {}\n                } catch {}\n                if (failureResults.length > 0) {\n                  // Do not override fail_if outcomes implicitly. Routing decisions\n                  // should be explicit via on_fail and bounded by routing.max_loops.\n                  const failureIssues = failureResults\n                    .filter(f => f.failed)\n                    .map(f => ({\n                      file: 'system',\n                      line: 0,\n                      ruleId: f.conditionName,\n                      message: f.message || `Failure condition met: ${f.expression}`,\n                      severity: (f.severity || 'error') as\n                        | 'info'\n                        | 'warning'\n                        | 'error'\n                        | 'critical',\n                      category: 'logic' as const,\n                    }));\n                  finalResult.issues = [...(finalResult.issues || []), ...failureIssues];\n\n                  // Post-evaluation routing: if fail_if produced any triggered condition and on_fail.goto is\n                  // configured, honor goto routing here as a soft-failure. This ensures checks that signal\n                  // failure via fail_if (without provider errors) can still drive refine loops.\n                  try {\n                    const hadTriggered = failureResults.some(r => r.failed === true);\n                    const ofCfg: OnFailConfig | undefined = checkConfig.on_fail\n                      ? { ...(config?.routing?.defaults?.on_fail || {}), ...checkConfig.on_fail }\n                      : undefined;\n                    if (hadTriggered && ofCfg && (ofCfg.goto || ofCfg.goto_js)) {\n                      const scope = {\n                        step: {\n                          id: checkName,\n                          tags: checkConfig.tags || [],\n                          group: checkConfig.group,\n                        },\n                        outputs: Object.fromEntries(results.entries()),\n                        output: (finalResult as any)?.output,\n                        event: { name: prInfo.eventType || 'manual' },\n                      };\n                      const target = await this.evaluateGotoTarget(\n                        (ofCfg.goto_js as string | undefined) || undefined,\n                        (ofCfg.goto as string | undefined) || undefined,\n                        scope,\n                        debug || false,\n                        log\n                      );\n                      if (target) {\n                        try {\n                          require('./logger').logger.info(\n                            `‚Ü™ on_fail.goto(post-fail_if): jumping to '${target}' from '${checkName}'`\n                          );\n                        } catch {}\n                        await this.scheduleGoto(\n                          'on_fail',\n                          target,\n                          ofCfg.goto_event,\n                          checkName,\n                          checkConfig,\n                          [],\n                          config!,\n                          dependencyGraph,\n                          prInfo,\n                          results,\n                          debug\n                        );\n                      }\n                    }\n                  } catch {}\n                }\n              }\n\n              // Record normal (non-forEach) execution\n              // Check if this check had fatal errors\n              const hadFatalError = (finalResult.issues || []).some(issue => {\n                const id = issue.ruleId || '';\n                return (\n                  id === 'command/execution_error' ||\n                  id.endsWith('/command/execution_error') ||\n                  id === 'command/timeout' ||\n                  id.endsWith('/command/timeout') ||\n                  id === 'command/transform_js_error' ||\n                  id.endsWith('/command/transform_js_error') ||\n                  id === 'command/transform_error' ||\n                  id.endsWith('/command/transform_error') ||\n                  id === 'forEach/undefined_output' ||\n                  id.endsWith('/forEach/undefined_output')\n                );\n              });\n              this.recordIterationComplete(\n                checkName,\n                checkStartTime,\n                !hadFatalError, // Success if no fatal errors\n                finalResult.issues || [],\n                (finalResult as any).output\n              );\n\n              // (history handled centrally in executeCheckInline)\n\n              if (checkConfig.forEach) {\n                try {\n                  const finalResultWithOutput = finalResult as ExtendedReviewSummary;\n                  const outputPreview =\n                    JSON.stringify(finalResultWithOutput.output)?.slice(0, 200) || '(empty)';\n                  logger.debug(\n                    `üîß Debug: Check \"${checkName}\" provider returned: ${outputPreview}`\n                  );\n                } catch {\n                  // Ignore logging errors\n                }\n              }\n\n              if (debug) {\n                log(\n                  `üîß Debug: Completed check: ${checkName}, issues found: ${(finalResult.issues || []).length}`\n                );\n              }\n\n              // Track cloned session IDs for cleanup\n              if (finalResult.sessionId) {\n                sessionIds.set(checkName, finalResult.sessionId);\n                if (debug) {\n                  log(`üîß Debug: Tracked cloned session for cleanup: ${finalResult.sessionId}`);\n                }\n              }\n            }\n\n            // Add checkName, group, schema, template info and timestamp to issues from config\n            const enrichedIssues = (finalResult.issues || []).map(issue => ({\n              ...issue,\n              checkName: checkName,\n              ruleId: `${checkName}/${issue.ruleId}`,\n              group: checkConfig.group,\n              schema: typeof checkConfig.schema === 'object' ? 'custom' : checkConfig.schema,\n              template: checkConfig.template,\n              timestamp: Date.now(),\n            }));\n\n            const enrichedResult = {\n              ...finalResult,\n              issues: enrichedIssues,\n            };\n\n            const checkDuration = ((Date.now() - checkStartTime) / 1000).toFixed(1);\n            const issueCount = enrichedIssues.length;\n            const checkStats = this.executionStats.get(checkName);\n\n            // Enhanced completion message with forEach stats\n            if (checkStats && checkStats.totalRuns > 1) {\n              if (issueCount > 0) {\n                logger.success(\n                  `Check complete: ${checkName} (${checkDuration}s) - ${checkStats.totalRuns} runs, ${issueCount} issue${issueCount === 1 ? '' : 's'}`\n                );\n              } else {\n                logger.success(\n                  `Check complete: ${checkName} (${checkDuration}s) - ${checkStats.totalRuns} runs`\n                );\n              }\n            } else if (checkStats && checkStats.outputsProduced && checkStats.outputsProduced > 0) {\n              logger.success(\n                `Check complete: ${checkName} (${checkDuration}s) - ${checkStats.outputsProduced} items`\n              );\n            } else if (issueCount > 0) {\n              logger.success(\n                `Check complete: ${checkName} (${checkDuration}s) - ${issueCount} issue${issueCount === 1 ? '' : 's'} found`\n              );\n            } else {\n              logger.success(`Check complete: ${checkName} (${checkDuration}s)`);\n            }\n\n            return {\n              checkName,\n              error: null,\n              result: enrichedResult,\n            };\n          } catch (error) {\n            const errorMessage =\n              error instanceof Error ? `${error.message}\\n${error.stack || ''}` : String(error);\n            const checkDuration = ((Date.now() - checkStartTime) / 1000).toFixed(1);\n\n            // Record error in stats\n            this.recordError(checkName, error instanceof Error ? error : new Error(String(error)));\n            this.recordIterationComplete(checkName, checkStartTime, false, [], undefined);\n\n            logger.error(`‚úñ Check failed: ${checkName} (${checkDuration}s) - ${errorMessage}`);\n\n            if (debug) {\n              log(`üîß Debug: Error in check ${checkName}: ${errorMessage}`);\n            }\n\n            return {\n              checkName,\n              error: errorMessage,\n              result: null,\n            };\n          }\n        });\n\n        // Execute checks in this level with controlled parallelism\n        const levelResults = await this.executeWithLimitedParallelism(\n          levelTaskFunctions,\n          actualParallelism,\n          effectiveFailFast\n        );\n\n        // Process results and store them for next level\n        const levelChecksList = checksInLevel.filter((name: string) => !results.has(name));\n        for (let i = 0; i < levelResults.length; i++) {\n          const checkName = levelChecksList[i];\n          const result = levelResults[i] as any;\n          if (!checkName) continue;\n          const checkConfig = config.checks![checkName];\n          if (!checkConfig) continue;\n\n          const isFulfilled = result && result.status === 'fulfilled';\n          const value: any = isFulfilled ? result.value : undefined;\n          if (isFulfilled && value?.result && !value?.error) {\n            // For skipped checks, store a marker so dependent checks can detect the skip\n            if ((value as any).skipped) {\n              if (debug) {\n                log(`üîß Debug: Storing skip marker for skipped check \"${checkName}\"`);\n              }\n              // Store a special marker result with a skip issue so dependencies can detect it\n              results.set(checkName, {\n                issues: [\n                  {\n                    ruleId: `${checkName}/__skipped`,\n                    severity: 'info',\n                    category: 'logic',\n                    message: 'Check was skipped',\n                    file: '',\n                    line: 0,\n                  },\n                ],\n              });\n              continue;\n            }\n            const reviewResult = value.result as ReviewSummary;\n\n            // Handle forEach logic - process array outputs\n            const reviewSummaryWithOutput = reviewResult as ExtendedReviewSummary;\n\n            if (\n              checkConfig?.forEach &&\n              (!reviewResult.issues || reviewResult.issues.length === 0)\n            ) {\n              const validation = this.validateAndNormalizeForEachOutput(\n                checkName,\n                reviewSummaryWithOutput.output,\n                checkConfig.group\n              );\n\n              if (!validation.isValid) {\n                results.set(\n                  checkName,\n                  validation.error.issues ? { issues: validation.error.issues } : {}\n                );\n                continue;\n              }\n\n              const normalizedOutput = validation.normalizedOutput;\n\n              logger.debug(\n                `üîß Debug: Raw output for forEach check ${checkName}: ${\n                  Array.isArray(reviewSummaryWithOutput.output)\n                    ? `array(${reviewSummaryWithOutput.output.length})`\n                    : typeof reviewSummaryWithOutput.output\n                }`\n              );\n\n              try {\n                const preview = JSON.stringify(normalizedOutput);\n                logger.debug(\n                  `üîß Debug: Check \"${checkName}\" forEach output: ${preview?.slice(0, 200) || '(empty)'}`\n                );\n              } catch {\n                // Ignore logging errors\n              }\n\n              // Store the array for iteration by dependent checks\n              reviewSummaryWithOutput.forEachItems = normalizedOutput;\n              reviewSummaryWithOutput.isForEach = true;\n              try {\n                const st = this.executionStats.get(checkName);\n                if (st) st.outputsProduced = normalizedOutput.length;\n              } catch {}\n            }\n\n            try {\n              emitNdjsonSpanWithEvents('visor.check', { 'visor.check.id': checkName }, [\n                { name: 'check.started' },\n                { name: 'check.completed' },\n              ]);\n            } catch {}\n\n            // Track output history for loop/goto scenarios (unconditional for non-forEach checks)\n            const reviewResultWithOutput = reviewResult as ExtendedReviewSummary & {\n              output?: unknown;\n            };\n            const hasOutput = reviewResultWithOutput.output !== undefined;\n            if (hasOutput) {\n              const isForEachAggregateChild =\n                !checkConfig.forEach &&\n                (reviewResultWithOutput as any).isForEach === true &&\n                (Array.isArray(reviewResultWithOutput.forEachItems) ||\n                  Array.isArray((reviewResultWithOutput as any).output));\n\n              // Do not push aggregated array output for:\n              //  - forEach dependents (map children): per-item outputs are recorded elsewhere\n              //  - forEach parents themselves: the aggregate array is pushed once in the\n              //    dedicated forEach commit block below. Skipping here avoids double count.\n              // Always track history for non-forEach checks. Tests and real runs\n              // both rely on outputs_history to drive correction loops and exact\n              // run counting; gating on test mode caused under-counting.\n              if (!isForEachAggregateChild && !checkConfig.forEach) {\n                try {\n                  const already = (reviewResultWithOutput as any).__histTracked === true;\n                  try {\n                    if (process.env.VISOR_DEBUG === 'true' && checkName === 'refine') {\n                      console.error(`[grouped-hist] ${checkName} __histTracked=${String(already)}`);\n                    }\n                  } catch {}\n                  if (!already) {\n                    const outVal: any = reviewResultWithOutput.output as any;\n                    let histVal: any = outVal;\n                    if (Array.isArray(outVal)) {\n                      histVal = outVal;\n                    } else if (outVal !== null && typeof outVal === 'object') {\n                      histVal = { ...outVal };\n                      if ((histVal as any).ts === undefined) (histVal as any).ts = Date.now();\n                    } else {\n                      histVal = { text: String(outVal), ts: Date.now() };\n                    }\n                    this.trackOutputHistory(checkName, histVal);\n                  }\n                } catch {\n                  try {\n                    this.trackOutputHistory(checkName, reviewResultWithOutput.output);\n                  } catch {}\n                }\n              }\n            } else {\n              // Even if provider returned no output, ensure history array exists for this check\n              try {\n                if (!this.outputHistory.has(checkName)) this.outputHistory.set(checkName, []);\n              } catch {}\n            }\n\n            results.set(checkName, reviewResult);\n            // Phase 4: commit aggregate and per-item entries for forEach checks; else single aggregate\n            const agg = reviewResult as ExtendedReviewSummary;\n            if (\n              checkConfig?.forEach &&\n              (Array.isArray(agg.forEachItems) || Array.isArray((agg as any).output))\n            ) {\n              // Compute next loop index for this forEach parent and clear previous last_loop flags\n              let loopIdx = 1;\n              try {\n                const hist = (this.outputHistory.get(checkName) || []) as unknown[];\n                const arraysSoFar = hist.filter(x => Array.isArray(x)).length;\n                loopIdx = arraysSoFar + 1;\n              } catch {}\n              try {\n                for (const [, arr] of this.outputHistory.entries()) {\n                  if (!Array.isArray(arr)) continue;\n                  for (const e of arr as unknown[]) {\n                    if (e && typeof e === 'object' && (e as any).last_loop === true) {\n                      try {\n                        (e as any).last_loop = false;\n                      } catch {}\n                    }\n                  }\n                }\n              } catch {}\n              // Track aggregate array in history so on_finish.goto_js can compute\n              // per-wave item counts from outputs_history['extract-facts'].\n              try {\n                const arrForHist: unknown[] = Array.isArray(agg.forEachItems)\n                  ? (agg.forEachItems as unknown[])\n                  : Array.isArray((agg as any).output)\n                    ? ((agg as any).output as unknown[])\n                    : [];\n                this.trackOutputHistory(checkName, arrForHist);\n                // Also push a loop marker with ids and last_loop flag\n                const ids: string[] = [];\n                for (let i = 0; i < arrForHist.length; i++) {\n                  const it = arrForHist[i] as any;\n                  const id = it && (it.id != null ? String(it.id) : String(i + 1));\n                  ids.push(id);\n                }\n                this.trackOutputHistory(checkName, {\n                  loop_idx: loopIdx,\n                  last_loop: true,\n                  items: ids,\n                });\n              } catch {}\n              // Commit aggregate at root scope\n              this.commitJournal(checkName, agg, prInfo.eventType, []);\n              const items: unknown[] = Array.isArray(agg.forEachItems)\n                ? (agg.forEachItems as unknown[])\n                : Array.isArray((agg as any).output)\n                  ? ((agg as any).output as unknown[])\n                  : [];\n              for (let i = 0; i < items.length; i++) {\n                const item = items[i];\n                try {\n                  this.commitJournal(\n                    checkName,\n                    { issues: [], output: item } as ExtendedReviewSummary,\n                    prInfo.eventType,\n                    [{ check: checkName, index: i }]\n                  );\n                } catch {}\n              }\n            } else {\n              try {\n                const __already = (reviewResult as any).__storedVisible === true;\n                if (!__already) {\n                  this.commitJournal(\n                    checkName,\n                    reviewResult as ExtendedReviewSummary,\n                    prInfo.eventType\n                  );\n                }\n              } catch {\n                this.commitJournal(\n                  checkName,\n                  reviewResult as ExtendedReviewSummary,\n                  prInfo.eventType\n                );\n              }\n            }\n          } else {\n            // Store error result for dependency tracking\n            const errorSummary: ReviewSummary = {\n              issues: [\n                {\n                  file: 'system',\n                  line: 0,\n                  endLine: undefined,\n                  ruleId: `${checkName}/error`,\n                  message: isFulfilled\n                    ? value?.error || 'Unknown error'\n                    : result?.reason instanceof Error\n                      ? result.reason.message\n                      : String(result?.reason),\n                  severity: 'error',\n                  category: 'logic',\n                  suggestion: undefined,\n                  replacement: undefined,\n                },\n              ],\n            };\n            results.set(checkName, errorSummary);\n            // Phase 0: commit to journal (with event scoping)\n            this.commitJournal(checkName, errorSummary as ExtendedReviewSummary, prInfo.eventType);\n\n            // Check if we should stop execution due to fail-fast\n            if (effectiveFailFast) {\n              if (debug) {\n                log(`üõë Check \"${checkName}\" failed and fail-fast is enabled - stopping execution`);\n              }\n              shouldStopExecution = true;\n              break;\n            }\n          }\n        }\n\n        // If fail-fast is enabled, check if any successful checks have failure conditions\n        if (effectiveFailFast && !shouldStopExecution) {\n          for (let i = 0; i < levelResults.length; i++) {\n            const checkName = checksInLevel[i];\n            const result = levelResults[i] as any;\n            if (!checkName) continue;\n\n            if (result?.status === 'fulfilled' && result?.value?.result && !result?.value?.error) {\n              // Check for issues that should trigger fail-fast\n              const hasFailuresToReport = ((result.value.result.issues || []) as any[]).some(\n                (issue: any) => issue.severity === 'error' || issue.severity === 'critical'\n              );\n\n              if (hasFailuresToReport) {\n                if (debug) {\n                  log(\n                    `üõë Check \"${checkName}\" found critical/high issues and fail-fast is enabled - stopping execution`\n                  );\n                }\n                shouldStopExecution = true;\n                break;\n              }\n            }\n          }\n        }\n      }\n    };\n\n    // Wave loop: run levels; if an on_fail forward-run happened, schedule another wave\n    for (; wave <= maxWaves && !shouldStopExecution; wave++) {\n      if (wave > 1) {\n        // Prepare new wave: allow re-execution of steps; keep history\n        results.clear();\n        await runWave();\n      }\n      await executeLevels();\n      const sawFail = Boolean((this as any).onFailForwardRunSeen);\n      const sawFinish = Boolean((this as any).onFinishForwardRunSeen);\n      const sawSuccess = Boolean((this as any).onSuccessForwardRunSeen);\n      const saw = sawFail || sawFinish || sawSuccess;\n      const pending = (() => {\n        try {\n          return this.forwardDependentsScheduled && this.forwardDependentsScheduled.size > 0;\n        } catch {\n          return false;\n        }\n      })();\n      if (debug)\n        (config?.output?.pr_comment ? console.error : console.log)(\n          `üîÅ Debug: wave ${wave} saw onFailForwardRunSeen=${String(saw)} pendingForward=${String(pending)}`\n        );\n      // Only schedule another wave if a correction was signaled AND at least one target was\n      // marked for forward execution. This prevents unnecessary extra waves after success.\n      if (!(saw && pending)) break;\n      // New wave planning; reset per-wave suppression list\n      try {\n        this.gotoSuppressedChecks.clear();\n      } catch {}\n      // Merge forward-scheduled targets into a fresh planned checks set and rebuild the\n      // dependency graph for the next wave so routed children execute via the DAG.\n      // IMPORTANT: start from an empty set rather than the previous wave's\n      // full set. Keeping the previous set causes unrelated, event-matching\n      // roots (e.g., comment-assistant) to persist across waves and re-run\n      // indefinitely whenever any forward-run occurs. Next waves must contain\n      // only the routed target(s) and, for success/fail-originated routing,\n      // their DAG dependents that match the effective event.\n      try {\n        const forwardTargets = Array.from(\n          (this.forwardDependentsScheduled || new Map<string, Set<string>>()).keys()\n        );\n        if (forwardTargets.length > 0) {\n          const nextSet = new Set<string>();\n          const allChecks = Object.keys(config?.checks || {});\n          const expandTokFwd = (tok: any): string[] =>\n            typeof tok === 'string' && tok.includes('|')\n              ? tok\n                  .split('|')\n                  .map(s => s.trim())\n                  .filter(Boolean)\n              : tok\n                ? [String(tok)]\n                : [];\n          const dependsOn = (\n            candidate: string,\n            root: string,\n            seen = new Set<string>()\n          ): boolean => {\n            if (seen.has(candidate)) return false;\n            seen.add(candidate);\n            const cfg = (config?.checks || {})[candidate];\n            const depTokens: any[] = Array.isArray(cfg?.depends_on)\n              ? (cfg!.depends_on as any[])\n              : cfg?.depends_on\n                ? [cfg.depends_on]\n                : [];\n            const deps = depTokens.flatMap(expandTokFwd);\n            if (deps.includes(root)) return true;\n            return deps.some(d => dependsOn(d, root, seen));\n          };\n          // Seed next wave with forward targets\n          for (const t of forwardTargets) {\n            nextSet.add(t);\n            const includeDeps = this.forwardIncludeDependents.get(t);\n            const shouldInclude = includeDeps !== false; // default true\n            if (!shouldInclude) continue;\n            const effEvent =\n              this.forwardEventOverrides.get(t) || (prInfo.eventType as any) || 'manual';\n            for (const cand of allChecks) {\n              if (cand === t) continue;\n              if (!dependsOn(cand, t)) continue;\n              const cCfg = (config.checks || {})[cand];\n              // Optional filter: for correction waves we may exclude forEach parents\n              const excludeForEach = this.forwardExcludeForEachDependents.get(t) === true;\n              if (excludeForEach && (cCfg as any)?.forEach) continue;\n              const trig = ((cCfg && (cCfg as any).on) || []) as any[];\n              const allow =\n                !trig || (Array.isArray(trig) && (trig.length === 0 || trig.includes(effEvent)));\n              if (allow) nextSet.add(cand);\n            }\n          }\n\n          // Ensure ancestors (dependencies) of all planned checks are present so\n          // the rebuilt dependency graph is valid and complete. This fixes the\n          // case where a forward target (e.g., 'consumer') depends on an\n          // ancestor (e.g., 'producer') that wasn't part of the initial run.\n          const expandOr = (tok: unknown): string[] => {\n            const s = String(tok ?? '').trim();\n            if (!s) return [];\n            if (s.includes('|'))\n              return s\n                .split('|')\n                .map(x => x.trim())\n                .filter(Boolean);\n            return [s];\n          };\n          const collectAncestors = (name: string, seen = new Set<string>()) => {\n            if (seen.has(name)) return;\n            seen.add(name);\n            const cfg = (config.checks || {})[name];\n            if (!cfg) return;\n            const raw = (cfg as any).depends_on || [];\n            for (const tok of raw) {\n              for (const d of expandOr(tok)) {\n                if (!d || !(config.checks || {})[d]) continue;\n                nextSet.add(d);\n                collectAncestors(d, seen);\n              }\n            }\n          };\n          for (const name of Array.from(nextSet)) collectAncestors(name);\n          // Add missing ancestors for all planned checks to build a valid graph\n          const expandOr2 = (tok: unknown): string[] => {\n            const s = String(tok ?? '').trim();\n            if (!s) return [];\n            if (s.includes('|'))\n              return s\n                .split('|')\n                .map(x => x.trim())\n                .filter(Boolean);\n            return [s];\n          };\n          const addAncestors2 = (name: string, seen = new Set<string>()) => {\n            if (seen.has(name)) return;\n            seen.add(name);\n            const cfg = (config.checks || {})[name];\n            if (!cfg) return;\n            const raw = (cfg as any).depends_on || [];\n            for (const tok of raw) {\n              for (const d of expandOr2(tok)) {\n                if (!d || !(config.checks || {})[d]) continue;\n                nextSet.add(d);\n                addAncestors2(d, seen);\n              }\n            }\n          };\n          for (const nm of Array.from(nextSet)) addAncestors2(nm);\n          checks = Array.from(nextSet);\n          if (sawFinish) {\n            try {\n              checks = checks.filter(n => !((config.checks || {})[n] as any)?.forEach);\n            } catch {}\n          }\n          // Recompute dependencies for the expanded set (expand OR-groups);\n          // skip event pruning here so goto_event can elevate children.\n          const expandTok = (tok: any): string[] =>\n            typeof tok === 'string' && tok.includes('|')\n              ? tok\n                  .split('|')\n                  .map(s => s.trim())\n                  .filter(Boolean)\n              : tok\n                ? [String(tok)]\n                : [];\n          const newDeps: Record<string, string[]> = {};\n          for (const name of checks) {\n            const cfg = (config.checks || {})[name];\n            if (!cfg) continue;\n            const depTokens: any[] = Array.isArray(cfg.depends_on)\n              ? (cfg.depends_on as any[])\n              : cfg.depends_on\n                ? [cfg.depends_on]\n                : [];\n            newDeps[name] = depTokens.flatMap(expandTok);\n          }\n          // Suppress goto for checks that are only dependencies (not forward targets)\n          try {\n            const fset = new Set(forwardTargets);\n            for (const [child, deps] of Object.entries(newDeps)) {\n              if (fset.has(child)) continue;\n              for (const d of deps || []) this.gotoSuppressedChecks.add(d);\n            }\n          } catch {}\n          dependencies = newDeps;\n          dependencyGraph = DependencyResolver.buildDependencyGraph(dependencies);\n          stats = DependencyResolver.getExecutionStats(dependencyGraph);\n          totalChecksCount = stats.totalChecks;\n          // Ensure execution statistics exist for any newly planned checks so\n          // their runs are counted in this.engine statistics (used by tests)\n          try {\n            for (const c of checks) if (!this.executionStats.has(c)) this.initializeCheckStats(c);\n          } catch {}\n        }\n        // Clear overrides after applying for the next wave\n        try {\n          this.forwardEventOverrides.clear();\n        } catch {}\n      } catch {}\n      try {\n        logger.info(`üîÅ Wave ${wave} completed with forward-run; scheduling next wave...`);\n      } catch {}\n    }\n\n    if (debug) {\n      if (shouldStopExecution) {\n        log(\n          `üõë Execution stopped early due to fail-fast after processing ${results.size} of ${checks.length} checks`\n        );\n      } else {\n        log(`‚úÖ Dependency-aware execution completed successfully for all ${results.size} checks`);\n      }\n    }\n\n    // Handle on_finish hooks for forEach checks after ALL dependents complete\n    if (!shouldStopExecution) {\n      try {\n        logger.info('üß≠ on_finish: invoking handleOnFinishHooks');\n      } catch {}\n      try {\n        if (debug) console.error('[engine] calling handleOnFinishHooks');\n      } catch {}\n      await this.handleOnFinishHooks(config, dependencyGraph, results, prInfo, debug || false);\n      // If on_finish scheduled forward targets (via goto/goto_js), execute additional\n      // correction wave(s) until no pending targets remain or wave budget is reached.\n      for (; wave <= maxWaves && this.forwardDependentsScheduled.size > 0; wave++) {\n        // Build the next wave plan from the pending on_finish targets BEFORE resetting per-wave guards.\n        try {\n          const fwdMap = this.forwardDependentsScheduled || new Map<string, Set<string>>();\n          const forwardTargetsRaw = Array.from(fwdMap.keys());\n          // Filter out targets that are not allowed for the effective event; if none remain, stop.\n          const allowedTargets = forwardTargetsRaw.filter(t => {\n            try {\n              const effEvent =\n                this.forwardEventOverrides.get(t) || (prInfo.eventType as any) || 'manual';\n              const cCfg = (config.checks || {})[t];\n              const trig = ((cCfg && (cCfg as any).on) || []) as any[];\n              const allow =\n                !trig || (Array.isArray(trig) && (trig.length === 0 || trig.includes(effEvent)));\n              return allow;\n            } catch {\n              return true;\n            }\n          });\n          if (allowedTargets.length === 0) {\n            // Nothing actionable for the next wave; clear and exit the loop\n            try {\n              this.forwardDependentsScheduled.clear();\n              this.forwardEventOverrides.clear();\n            } catch {}\n            break;\n          }\n          // Execute any per-item scoped runs immediately for allowed targets,\n          // then keep only unscoped (root) entries for DAG planning.\n          const executedScopedChildren = new Set<string>();\n          try {\n            for (const t of allowedTargets) {\n              const scopeSet = fwdMap.get(t);\n              if (!scopeSet || scopeSet.size === 0) continue;\n              const effEvent =\n                this.forwardEventOverrides.get(t) || (prInfo.eventType as any) || 'manual';\n              const toRemove: string[] = [];\n              for (const s of Array.from(scopeSet)) {\n                // s is JSON-encoded ScopePath; '[]' means unscoped\n                if (s === '[]') continue;\n                let scope: ScopePath = [];\n                try {\n                  scope = JSON.parse(s);\n                } catch {\n                  scope = [];\n                }\n                await this.runNamedCheck(t, scope, {\n                  origin: 'on_finish',\n                  config: config!,\n                  dependencyGraph,\n                  prInfo,\n                  resultsMap: results,\n                  debug: !!debug,\n                  eventOverride: effEvent,\n                });\n                toRemove.push(s);\n              }\n              // Remove executed per-item scopes from the scheduled map\n              for (const s of toRemove) scopeSet.delete(s);\n              if (scopeSet.size === 0) {\n                fwdMap.delete(t);\n              }\n\n              // If t is a forEach parent, proactively execute its immediate\n              // dependents that declare fanout: 'map' for each item scope.\n              try {\n                const tCfg = (config.checks || {})[t] as any;\n                if (tCfg && tCfg.forEach === true) {\n                  const hist = this.outputHistory.get(t);\n                  const arrays = Array.isArray(hist) ? (hist as unknown[]) : [];\n                  const lastArr = arrays.filter(Array.isArray).slice(-1)[0] as\n                    | unknown[]\n                    | undefined;\n                  const itemsLen = Array.isArray(lastArr) ? lastArr.length : 0;\n                  if (itemsLen > 0) {\n                    for (const [cand, candCfgAny] of Object.entries(config.checks || {})) {\n                      const candCfg = candCfgAny as any;\n                      const depsRaw = Array.isArray(candCfg?.depends_on)\n                        ? (candCfg.depends_on as any[])\n                        : candCfg?.depends_on\n                          ? [candCfg.depends_on]\n                          : [];\n                      const deps = depsRaw\n                        .flatMap((x: any) =>\n                          String(x ?? '')\n                            .split('|')\n                            .map((s: string) => s.trim())\n                            .filter(Boolean)\n                        )\n                        .filter(Boolean);\n                      const isChild = deps.includes(t);\n                      const isMap = candCfg?.fanout === 'map';\n                      if (isChild && isMap) {\n                        for (let i = 0; i < itemsLen; i++) {\n                          const itemScope: ScopePath = [{ check: t, index: i }];\n                          await this.runNamedCheck(cand, itemScope, {\n                            origin: 'on_finish',\n                            config: config!,\n                            dependencyGraph,\n                            prInfo,\n                            resultsMap: results,\n                            debug: !!debug,\n                            eventOverride: effEvent,\n                          });\n                        }\n                        executedScopedChildren.add(cand);\n                      }\n                    }\n                  }\n                }\n              } catch {}\n            }\n          } catch {}\n          // Construct a fresh checks set consisting only of the allowed targets and their dependents for the effective event\n          const nextSet = new Set<string>();\n          const allChecks = Object.keys(config?.checks || {});\n          const expandTok = (tok: any): string[] =>\n            typeof tok === 'string' && tok.includes('|')\n              ? tok\n                  .split('|')\n                  .map(s => s.trim())\n                  .filter(Boolean)\n              : tok\n                ? [String(tok)]\n                : [];\n          const dependsOn = (\n            candidate: string,\n            root: string,\n            seen = new Set<string>()\n          ): boolean => {\n            if (seen.has(candidate)) return false;\n            seen.add(candidate);\n            const cfg = (config?.checks || {})[candidate];\n            const depTokens: any[] = Array.isArray(cfg?.depends_on)\n              ? (cfg!.depends_on as any[])\n              : cfg?.depends_on\n                ? [cfg.depends_on]\n                : [];\n            const deps = depTokens.flatMap(expandTok);\n            if (deps.includes(root)) return true;\n            return deps.some(d => dependsOn(d, root, seen));\n          };\n          for (const t of allowedTargets) {\n            const scopeSet = fwdMap.get(t);\n            // If only per-item scopes were scheduled and all executed above, skip adding this target\n            if (scopeSet && scopeSet.size > 0 && !scopeSet.has('[]')) {\n              continue;\n            }\n            nextSet.add(t);\n            const includeDeps = this.forwardIncludeDependents.get(t);\n            const shouldInclude = includeDeps !== false; // default true\n            if (!shouldInclude) continue; // on_finish correction waves: only targets\n            const effEvent =\n              this.forwardEventOverrides.get(t) || (prInfo.eventType as any) || 'manual';\n            for (const cand of allChecks) {\n              if (cand === t) continue;\n              if (!dependsOn(cand, t)) continue;\n              const cCfg = (config.checks || {})[cand];\n              // Skip children we have already executed per-item above\n              try {\n                if ((executedScopedChildren as any)?.has?.(cand)) continue;\n              } catch {}\n              const excludeForEach = this.forwardExcludeForEachDependents.get(t) === true;\n              if (excludeForEach && (cCfg as any)?.forEach) continue;\n              const trig = ((cCfg && (cCfg as any).on) || []) as any[];\n              const allow =\n                !trig || (Array.isArray(trig) && (trig.length === 0 || trig.includes(effEvent)));\n              if (allow) nextSet.add(cand);\n            }\n          }\n          checks = Array.from(nextSet);\n          // In correction waves triggered by on_finish, avoid re-running forEach parents\n          try {\n            checks = checks.filter(n => !((config.checks || {})[n] as any)?.forEach);\n          } catch {}\n          // Recompute dependencies for the planned set (tokens expanded), then rebuild the graph\n          const newDeps: Record<string, string[]> = {};\n          for (const name of checks) {\n            const cfg = (config.checks || {})[name];\n            if (!cfg) continue;\n            const depTokens: any[] = Array.isArray((cfg as any).depends_on)\n              ? ((cfg as any).depends_on as any[])\n              : (cfg as any).depends_on\n                ? [(cfg as any).depends_on]\n                : [];\n            newDeps[name] = depTokens.flatMap(expandTok);\n          }\n          // Suppress goto for checks that are only dependencies in this correction wave\n          try {\n            const tset = new Set(allowedTargets);\n            for (const [child, deps] of Object.entries(newDeps)) {\n              if (tset.has(child)) continue;\n              for (const d of deps || []) this.gotoSuppressedChecks.add(d);\n            }\n          } catch {}\n          dependencies = newDeps;\n          dependencyGraph = DependencyResolver.buildDependencyGraph(dependencies);\n          stats = DependencyResolver.getExecutionStats(dependencyGraph);\n          totalChecksCount = stats.totalChecks;\n          // Ensure statistics are initialized for any newly added checks\n          try {\n            for (const c of checks) if (!this.executionStats.has(c)) this.initializeCheckStats(c);\n          } catch {}\n          // Clear overrides and pending list now that the plan is materialized\n          try {\n            this.forwardDependentsScheduled.clear();\n            this.forwardEventOverrides.clear();\n          } catch {}\n        } catch {}\n        try {\n          logger.info(`üîÅ Wave ${wave} scheduled from on_finish; executing...`);\n        } catch {}\n        results.clear();\n        await runWave();\n        await executeLevels();\n        // Process on_finish again for potential further routing\n        await this.handleOnFinishHooks(config, dependencyGraph, results, prInfo, debug || false);\n      }\n      // Removed fallback re-execution of on_finish.run static steps to avoid double-counting and\n      // unintended duplicate runs within a single stage. The primary on_finish handler above is\n      // authoritative and records history/stats for reporters.\n    } else {\n      try {\n        logger.info('üß≠ on_finish: skipped due to shouldStopExecution');\n      } catch {}\n    }\n\n    // Cleanup sessions BEFORE printing summary to avoid mixing debug logs with table output\n    if (sessionIds.size > 0 && debug) {\n      log(`üßπ Cleaning up ${sessionIds.size} AI sessions...`);\n      for (const [checkName, sessionId] of sessionIds) {\n        try {\n          sessionRegistry.unregisterSession(sessionId);\n          log(`üóëÔ∏è Cleaned up session for check ${checkName}: ${sessionId}`);\n        } catch (error) {\n          log(`‚ö†Ô∏è Failed to cleanup session for check ${checkName}: ${error}`);\n        }\n      }\n    }\n\n    // Ensure all AI sessions are cleaned up (safety net)\n    try {\n      if (sessionIds.size > 0) {\n        const { SessionRegistry } = require('./session-registry');\n        SessionRegistry.getInstance().clearAllSessions();\n      }\n    } catch {}\n\n    // Build and log final execution summary\n    const executionStatistics = this.buildExecutionStatistics();\n\n    // Show detailed summary table (only if logFn outputs to console)\n    // Skip when output format is JSON/SARIF to avoid polluting structured output\n    // Check if logFn is console.log (not a no-op or console.error)\n    if (logFn === console.log) {\n      this.logExecutionSummary(executionStatistics);\n    }\n\n    // Add warning if execution stopped early\n    if (shouldStopExecution) {\n      logger.info('');\n      logger.warn(`‚ö†Ô∏è  Execution stopped early due to fail-fast`);\n    }\n\n    // In strict modes, surface internal check errors as test failures\n    try {\n      const strictEnv = process.env.VISOR_STRICT_ERRORS === 'true';\n      if (strictEnv) {\n        const failures: Array<{ name: string; message: string }> = [];\n        for (const [name, r] of results.entries()) {\n          const issues = (r?.issues || []) as Array<{\n            ruleId?: string;\n            message?: string;\n            severity?: string;\n          }>;\n          if (\n            issues.some(\n              i => i.ruleId && (i.ruleId.endsWith('/error') || i.ruleId.includes('/promise-error'))\n            )\n          ) {\n            const first = issues.find(i => i.ruleId?.includes('/error')) || issues[0];\n            failures.push({ name, message: first?.message || 'check error' });\n          }\n        }\n        if (failures.length > 0) {\n          const msg = 'Check failures: ' + failures.map(f => `${f.name}: ${f.message}`).join('; ');\n          throw new Error(msg);\n        }\n      }\n    } catch (e) {\n      // Re-throw to caller; executeChecks will honor strict mode and propagate in tests.\n      throw e;\n    }\n\n    // Aggregate all results\n    return this.aggregateDependencyAwareResults(\n      results,\n      dependencyGraph,\n      debug,\n      shouldStopExecution\n    );\n  }\n\n  /**\n   * Execute multiple checks in parallel using controlled parallelism (legacy method)\n   */\n  private async executeParallelChecks(\n    prInfo: PRInfo,\n    checks: string[],\n    timeout?: number,\n    config?: import('./types/config').VisorConfig,\n    logFn?: (message: string) => void,\n    debug?: boolean,\n    maxParallelism?: number,\n    failFast?: boolean\n  ): Promise<ReviewSummary> {\n    const log = logFn || console.error;\n    log(`üîß Debug: Starting parallel execution of ${checks.length} checks`);\n\n    if (!config?.checks) {\n      throw new Error('Config with check definitions required for parallel execution');\n    }\n\n    // Determine effective max parallelism (CLI > config > default)\n    const effectiveMaxParallelism = maxParallelism ?? config.max_parallelism ?? 3;\n    // Determine effective fail-fast setting (CLI > config > default)\n    const effectiveFailFast = failFast ?? config.fail_fast ?? false;\n    log(`üîß Debug: Using max parallelism: ${effectiveMaxParallelism}`);\n    log(`üîß Debug: Using fail-fast: ${effectiveFailFast}`);\n\n    const provider = this.providerRegistry.getProviderOrThrow('ai');\n    this.setProviderWebhookContext(provider);\n\n    // Create individual check task functions\n    const checkTaskFunctions = checks.map(checkName => async () => {\n      const checkConfig = config.checks![checkName];\n      if (!checkConfig) {\n        log(`üîß Debug: No config found for check: ${checkName}`);\n        return {\n          checkName,\n          error: `No configuration found for check: ${checkName}`,\n          result: null,\n        };\n      }\n\n      try {\n        console.error(\n          `üîß Debug: Starting check: ${checkName} with prompt type: ${typeof checkConfig.prompt}`\n        );\n\n        // Evaluate if condition to determine whether to run this check\n        if (checkConfig.if) {\n          const gate = await this.shouldRunCheck(\n            checkName,\n            checkConfig.if,\n            prInfo,\n            new Map<string, ReviewSummary>(),\n            debug,\n            this.routingEventOverride,\n            /* failSecure */ true\n          );\n\n          if (!gate.shouldRun) {\n            console.error(\n              `üîß Debug: Skipping check '${checkName}' - if condition evaluated to false`\n            );\n            return {\n              checkName,\n              error: null,\n              result: {\n                issues: [],\n              },\n            };\n          }\n        }\n\n        // Create provider config for this specific check\n        const providerConfig: CheckProviderConfig = {\n          type: (checkConfig.type as any) || 'ai',\n          prompt: checkConfig.prompt,\n          focus: checkConfig.focus || this.mapCheckNameToFocus(checkName),\n          schema: checkConfig.schema,\n          group: checkConfig.group,\n          checkName,\n          eventContext: this.enrichEventContext(prInfo.eventContext),\n          ai: {\n            timeout: timeout || 600000,\n            debug: debug, // Pass debug flag to AI provider\n            ...(checkConfig.ai || {}),\n          },\n          // Preserve all other provider-specific fields (e.g., memory.operation, github.op)\n          ...checkConfig,\n        } as any;\n\n        const result = await provider.execute(\n          prInfo,\n          providerConfig,\n          undefined,\n          this.executionContext\n        );\n        console.error(\n          `üîß Debug: Completed check: ${checkName}, issues found: ${(result.issues || []).length}`\n        );\n\n        // Add group, schema info and timestamp to issues from config\n        const enrichedIssues = (result.issues || []).map(issue => ({\n          ...issue,\n          ruleId: `${checkName}/${issue.ruleId}`,\n          group: checkConfig.group,\n          schema: typeof checkConfig.schema === 'object' ? 'custom' : checkConfig.schema,\n          template: checkConfig.template,\n          timestamp: Date.now(),\n        }));\n\n        const enrichedResult = {\n          ...result,\n          issues: enrichedIssues,\n        };\n\n        return {\n          checkName,\n          error: null,\n          result: enrichedResult,\n        };\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        log(`üîß Debug: Error in check ${checkName}: ${errorMessage}`);\n\n        return {\n          checkName,\n          error: errorMessage,\n          result: null,\n        };\n      }\n    });\n\n    // Execute all checks with controlled parallelism\n    log(\n      `üîß Debug: Executing ${checkTaskFunctions.length} checks with max parallelism: ${effectiveMaxParallelism}`\n    );\n    const results = await this.executeWithLimitedParallelism(\n      checkTaskFunctions,\n      effectiveMaxParallelism,\n      effectiveFailFast\n    );\n\n    // Check if execution was stopped early\n    const completedChecks = results.filter(\n      r => r.status === 'fulfilled' || r.status === 'rejected'\n    ).length;\n    const stoppedEarly = completedChecks < checks.length;\n\n    if (stoppedEarly && effectiveFailFast) {\n      log(\n        `üõë Parallel execution stopped early due to fail-fast after processing ${completedChecks} of ${checks.length} checks`\n      );\n    } else {\n      log(`‚úÖ Parallel execution completed for all ${completedChecks} checks`);\n    }\n\n    // Aggregate results from all checks\n    return this.aggregateParallelResults(results, checks, debug, stoppedEarly);\n  }\n\n  /**\n   * Execute a single configured check\n   */\n  private async executeSingleConfiguredCheck(\n    prInfo: PRInfo,\n    checkName: string,\n    timeout?: number,\n    config?: import('./types/config').VisorConfig,\n    _logFn?: (message: string) => void\n  ): Promise<ReviewSummary> {\n    if (!config?.checks?.[checkName]) {\n      throw new Error(`No configuration found for check: ${checkName}`);\n    }\n\n    const checkConfig = config.checks![checkName];\n    const provider = this.providerRegistry.getProviderOrThrow('ai');\n    this.setProviderWebhookContext(provider);\n\n    const providerConfig: CheckProviderConfig = {\n      type: 'ai',\n      prompt: checkConfig.prompt,\n      focus: checkConfig.focus || this.mapCheckNameToFocus(checkName),\n      schema: checkConfig.schema,\n      group: checkConfig.group,\n      eventContext: this.enrichEventContext(prInfo.eventContext),\n      ai: {\n        timeout: timeout || 600000,\n        ...(checkConfig.ai || {}),\n      },\n      // Inherit global AI provider and model settings\n      ai_provider: checkConfig.ai_provider || config.ai_provider,\n      ai_model: checkConfig.ai_model || config.ai_model,\n    };\n\n    const result = await provider.execute(prInfo, providerConfig, undefined, this.executionContext);\n\n    // Prefix issues with check name and add group/schema info and timestamp from config\n    const prefixedIssues = (result.issues || []).map(issue => ({\n      ...issue,\n      ruleId: `${checkName}/${issue.ruleId}`,\n      group: checkConfig.group,\n      schema: typeof checkConfig.schema === 'object' ? 'custom' : checkConfig.schema,\n      timestamp: Date.now(),\n    }));\n\n    return {\n      ...result,\n      issues: prefixedIssues,\n    };\n  }\n\n  /**\n   * Map check name to focus for AI provider\n   * This is a fallback when focus is not explicitly configured\n   */\n  private mapCheckNameToFocus(checkName: string): string {\n    const focusMap: Record<string, string> = {\n      security: 'security',\n      performance: 'performance',\n      style: 'style',\n      architecture: 'architecture',\n    };\n\n    return focusMap[checkName] || 'all';\n  }\n\n  /**\n   * Aggregate results from dependency-aware check execution\n   */\n  private aggregateDependencyAwareResults(\n    results: Map<string, ReviewSummary>,\n    dependencyGraph: DependencyGraph,\n    debug?: boolean,\n    stoppedEarly?: boolean\n  ): ReviewSummary {\n    const aggregatedIssues: ReviewSummary['issues'] = [];\n    const debugInfo: string[] = [];\n    const contentMap: Record<string, string> = {};\n    const outputsMap: Record<string, unknown> = {};\n\n    // Add execution plan info\n    const stats = DependencyResolver.getExecutionStats(dependencyGraph);\n    const executionInfo = [\n      stoppedEarly\n        ? `üõë Dependency-aware execution stopped early (fail-fast):`\n        : `üîç Dependency-aware execution completed:`,\n      `  - ${results.size} of ${stats.totalChecks} checks processed`,\n      `  - Execution levels: ${stats.parallelLevels}`,\n      `  - Maximum parallelism: ${stats.maxParallelism}`,\n      `  - Average parallelism: ${stats.averageParallelism.toFixed(1)}`,\n      `  - Checks with dependencies: ${stats.checksWithDependencies}`,\n      stoppedEarly ? `  - Stopped early due to fail-fast behavior` : ``,\n    ].filter(Boolean);\n\n    debugInfo.push(...executionInfo);\n\n    // Track which checks we've aggregated already\n    const processed = new Set<string>();\n\n    // Process results in dependency order for better output organization\n    for (const executionGroup of dependencyGraph.executionOrder) {\n      for (const checkName of executionGroup.parallel) {\n        const result = results.get(checkName);\n\n        if (!result) {\n          debugInfo.push(`‚ùå Check \"${checkName}\" had no result`);\n          continue;\n        }\n\n        // Check if this was a successful result\n        const hasErrors = (result.issues || []).some(\n          issue => issue.ruleId?.includes('/error') || issue.ruleId?.includes('/promise-error')\n        );\n\n        if (hasErrors) {\n          debugInfo.push(`‚ùå Check \"${checkName}\" failed with errors`);\n        } else {\n          debugInfo.push(\n            `‚úÖ Check \"${checkName}\" completed: ${(result.issues || []).length} issues found (level ${executionGroup.level})`\n          );\n        }\n\n        // Mark as processed\n        processed.add(checkName);\n\n        // Issues are already prefixed and enriched with group/schema info\n        // Filter out internal __skipped markers\n        let nonInternalIssues = (result.issues || []).filter(\n          issue => !issue.ruleId?.endsWith('/__skipped')\n        );\n        // Safety: ensure aggregated issues retain producing check association\n        nonInternalIssues = nonInternalIssues.map((i: ReviewIssue) =>\n          i.checkName ? i : { ...i, checkName }\n        );\n        aggregatedIssues.push(...nonInternalIssues);\n\n        const resultSummary = result as ExtendedReviewSummary & { output?: unknown };\n        const resultContent = resultSummary.content;\n        if (typeof resultContent === 'string' && resultContent.trim()) {\n          contentMap[checkName] = resultContent.trim();\n        }\n        if (resultSummary.output !== undefined) {\n          outputsMap[checkName] = resultSummary.output;\n        }\n      }\n    }\n\n    // Include any additional results that were produced at runtime (e.g., forward-run via goto)\n    // but were not part of the original execution DAG for the selected checks.\n    for (const [checkName, result] of results.entries()) {\n      if (processed.has(checkName)) continue;\n      if (!result) continue;\n\n      // Issues (already enriched)\n      let dynNonInternal = (result.issues || []).filter(\n        issue => !issue.ruleId?.endsWith('/__skipped')\n      );\n      dynNonInternal = dynNonInternal.map((i: ReviewIssue) =>\n        i.checkName ? i : { ...i, checkName }\n      );\n      aggregatedIssues.push(...dynNonInternal);\n\n      const resultSummary = result as ExtendedReviewSummary & { output?: unknown };\n      const resultContent = (resultSummary as { content?: string }).content;\n      if (typeof resultContent === 'string' && resultContent.trim()) {\n        contentMap[checkName] = resultContent.trim();\n      }\n      if (resultSummary.output !== undefined) {\n        outputsMap[checkName] = resultSummary.output;\n      }\n\n      debugInfo.push(\n        `‚úÖ (dynamic) Check \"${checkName}\" included: ${(result.issues || []).length} issues found`\n      );\n    }\n\n    if (debug) {\n      console.error(\n        `üîß Debug: Aggregated ${aggregatedIssues.length} issues from ${results.size} dependency-aware checks`\n      );\n    }\n\n    // Fallback surfacing for routing loop-budget diagnostics in edge environments\n    // where no check results were recorded (e.g., extremely early routing aborts\n    // under artificial budgets in tests). Only trigger when nothing executed.\n    if (results.size === 0 && (!aggregatedIssues || aggregatedIssues.length === 0)) {\n      try {\n        const cfg = this.config || ({} as any);\n        const maxLoops = (cfg.routing && cfg.routing.max_loops) ?? undefined;\n        if (typeof maxLoops === 'number') {\n          const checksToScan = Object.keys((cfg.checks || {}) as Record<string, any>);\n          for (const name of checksToScan) {\n            const c = (cfg.checks as any)[name] || {};\n            if (c.on_success && Array.isArray(c.on_success.run) && c.on_success.run.length > 0) {\n              aggregatedIssues.push({\n                file: 'system',\n                line: 0,\n                ruleId: `${name}/routing/loop_budget_exceeded`,\n                message: `Routing loop budget exceeded (max_loops=${maxLoops}) during on_success run`,\n                severity: 'error',\n                category: 'logic',\n              });\n            }\n            if (c.on_fail && (c.on_fail.goto || c.on_fail.goto_js)) {\n              aggregatedIssues.push({\n                file: 'system',\n                line: 0,\n                ruleId: `${name}/routing/loop_budget_exceeded`,\n                message: `Routing loop budget exceeded (max_loops=${maxLoops}) during on_fail goto`,\n                severity: 'error',\n                category: 'logic',\n              });\n            }\n          }\n        }\n      } catch {}\n    }\n\n    // Apply issue suppression filtering\n    const suppressionEnabled = this.config?.output?.suppressionEnabled !== false;\n    const issueFilter = new IssueFilter(suppressionEnabled);\n    const filteredIssues = issueFilter.filterIssues(aggregatedIssues, this.workingDirectory);\n\n    // Collect debug information when debug mode is enabled\n    let aggregatedDebug: import('./ai-review-service').AIDebugInfo | undefined;\n    if (debug) {\n      const debugResults = Array.from(results.entries()).filter(([_, result]) => result.debug);\n\n      if (debugResults.length > 0) {\n        const [, firstResult] = debugResults[0];\n        const firstDebug = firstResult.debug!;\n\n        const totalProcessingTime = debugResults.reduce((sum, [_, result]) => {\n          return sum + (result.debug!.processingTime || 0);\n        }, 0);\n\n        aggregatedDebug = {\n          provider: firstDebug.provider,\n          model: firstDebug.model,\n          apiKeySource: firstDebug.apiKeySource,\n          processingTime: totalProcessingTime,\n          prompt: debugResults\n            .map(([checkName, result]) => `[${checkName}]\\n${result.debug!.prompt}`)\n            .join('\\n\\n'),\n          rawResponse: debugResults\n            .map(([checkName, result]) => `[${checkName}]\\n${result.debug!.rawResponse}`)\n            .join('\\n\\n'),\n          promptLength: debugResults.reduce(\n            (sum, [_, result]) => sum + (result.debug!.promptLength || 0),\n            0\n          ),\n          responseLength: debugResults.reduce(\n            (sum, [_, result]) => sum + (result.debug!.responseLength || 0),\n            0\n          ),\n          jsonParseSuccess: debugResults.every(([_, result]) => result.debug!.jsonParseSuccess),\n          errors: debugResults.flatMap(([checkName, result]) =>\n            (result.debug!.errors || []).map((error: string) => `[${checkName}] ${error}`)\n          ),\n          timestamp: new Date().toISOString(),\n          totalApiCalls: debugResults.length,\n          apiCallDetails: debugResults.map(([checkName, result]) => ({\n            checkName,\n            provider: result.debug!.provider,\n            model: result.debug!.model,\n            processingTime: result.debug!.processingTime,\n            success: result.debug!.jsonParseSuccess,\n          })),\n        };\n      }\n    }\n\n    const summary: ReviewSummary & {\n      __contents?: Record<string, string>;\n      __outputs?: Record<string, unknown>;\n      __executed?: string[];\n    } = {\n      issues: filteredIssues,\n      debug: aggregatedDebug,\n    };\n\n    if (Object.keys(contentMap).length > 0) {\n      summary.__contents = contentMap;\n    }\n    if (Object.keys(outputsMap).length > 0) {\n      summary.__outputs = outputsMap;\n    }\n\n    // Attach outputs history for tests and scripts that inspect reviewSummary.history\n    try {\n      const hist: Record<string, unknown[]> = {};\n      for (const [k, v] of this.outputHistory.entries()) hist[k] = Array.isArray(v) ? v : [];\n      (summary as any).history = hist;\n    } catch {}\n\n    // Preserve the list of executed checks (keys in results Map) so downstream\n    // grouping/formatting can include dynamically routed children even when they\n    // produced neither issues nor output content (e.g., log-only steps).\n    summary.__executed = Array.from(results.keys());\n\n    return summary;\n  }\n\n  /**\n   * Aggregate results from parallel check execution (legacy method)\n   */\n  private aggregateParallelResults(\n    results: PromiseSettledResult<{\n      checkName: string;\n      error: string | null;\n      result: ReviewSummary | null;\n    }>[],\n    checkNames: string[],\n    debug?: boolean,\n    _stoppedEarly?: boolean\n  ): ReviewSummary {\n    const aggregatedIssues: ReviewSummary['issues'] = [];\n    const debugInfo: string[] = [];\n\n    results.forEach((result, index) => {\n      const checkName = checkNames[index];\n\n      if (result.status === 'fulfilled') {\n        const checkResult = result.value;\n\n        if (checkResult.error) {\n          logger.debug(`üîß Debug: Check ${checkName} failed: ${checkResult.error}`);\n          debugInfo.push(`‚ùå Check \"${checkName}\" failed: ${checkResult.error}`);\n\n          // Check if this is a critical error\n          const isCriticalError =\n            checkResult.error.includes('API rate limit') ||\n            checkResult.error.includes('403') ||\n            checkResult.error.includes('401') ||\n            checkResult.error.includes('authentication') ||\n            checkResult.error.includes('API key');\n\n          // Add error as an issue with appropriate severity\n          aggregatedIssues.push({\n            file: 'system',\n            line: 0,\n            endLine: undefined,\n            ruleId: `${checkName}/error`,\n            message: `Check \"${checkName}\" failed: ${checkResult.error}`,\n            severity: isCriticalError ? 'critical' : 'error',\n            category: 'logic',\n            suggestion: isCriticalError\n              ? 'Please check your API credentials and rate limits'\n              : undefined,\n            replacement: undefined,\n          });\n        } else if (checkResult.result) {\n          logger.debug(\n            `üîß Debug: Check ${checkName} succeeded with ${(checkResult.result.issues || []).length} issues`\n          );\n          debugInfo.push(\n            `‚úÖ Check \"${checkName}\" completed: ${(checkResult.result.issues || []).length} issues found`\n          );\n\n          // Issues are already prefixed and enriched with group/schema info\n          aggregatedIssues.push(...(checkResult.result.issues || []));\n        }\n      } else {\n        const errorMessage =\n          result.reason instanceof Error ? result.reason.message : String(result.reason);\n        logger.debug(`üîß Debug: Check ${checkName} promise rejected: ${errorMessage}`);\n        debugInfo.push(`‚ùå Check \"${checkName}\" promise rejected: ${errorMessage}`);\n\n        // Check if this is a critical error\n        const isCriticalError =\n          errorMessage.includes('API rate limit') ||\n          errorMessage.includes('403') ||\n          errorMessage.includes('401') ||\n          errorMessage.includes('authentication') ||\n          errorMessage.includes('API key');\n\n        aggregatedIssues.push({\n          file: 'system',\n          line: 0,\n          endLine: undefined,\n          ruleId: `${checkName}/promise-error`,\n          message: `Check \"${checkName}\" execution failed: ${errorMessage}`,\n          severity: isCriticalError ? 'critical' : 'error',\n          category: 'logic',\n          suggestion: isCriticalError\n            ? 'Please check your API credentials and rate limits'\n            : undefined,\n          replacement: undefined,\n        });\n      }\n    });\n\n    if (debug) {\n      console.error(\n        `üîß Debug: Aggregated ${aggregatedIssues.length} issues from ${results.length} checks`\n      );\n    }\n\n    // Apply issue suppression filtering\n    const suppressionEnabled = this.config?.output?.suppressionEnabled !== false;\n    const issueFilter = new IssueFilter(suppressionEnabled);\n    const filteredIssues = issueFilter.filterIssues(aggregatedIssues, this.workingDirectory);\n\n    // Collect debug information when debug mode is enabled\n    let aggregatedDebug: import('./ai-review-service').AIDebugInfo | undefined;\n    if (debug) {\n      // Find the first successful result with debug information to use as template\n      const debugResults = results\n        .map((result, index) => ({\n          result,\n          checkName: checkNames[index],\n        }))\n        .filter(({ result }) => result.status === 'fulfilled' && result.value?.result?.debug);\n\n      if (debugResults.length > 0) {\n        const firstResult = debugResults[0].result;\n        if (firstResult.status === 'fulfilled') {\n          const firstDebug = firstResult.value!.result!.debug!;\n          const totalProcessingTime = debugResults.reduce((sum, { result }) => {\n            if (result.status === 'fulfilled') {\n              return sum + (result.value!.result!.debug!.processingTime || 0);\n            }\n            return sum;\n          }, 0);\n\n          aggregatedDebug = {\n            // Use first result as template for provider/model info\n            provider: firstDebug.provider,\n            model: firstDebug.model,\n            apiKeySource: firstDebug.apiKeySource,\n            // Aggregate processing time from all checks\n            processingTime: totalProcessingTime,\n            // Combine prompts with check names\n            prompt: debugResults\n              .map(({ checkName, result }) => {\n                if (result.status === 'fulfilled') {\n                  return `[${checkName}]\\n${result.value!.result!.debug!.prompt}`;\n                }\n                return `[${checkName}] Error: Promise was rejected`;\n              })\n              .join('\\n\\n'),\n            // Combine responses\n            rawResponse: debugResults\n              .map(({ checkName, result }) => {\n                if (result.status === 'fulfilled') {\n                  return `[${checkName}]\\n${result.value!.result!.debug!.rawResponse}`;\n                }\n                return `[${checkName}] Error: Promise was rejected`;\n              })\n              .join('\\n\\n'),\n            promptLength: debugResults.reduce((sum, { result }) => {\n              if (result.status === 'fulfilled') {\n                return sum + (result.value!.result!.debug!.promptLength || 0);\n              }\n              return sum;\n            }, 0),\n            responseLength: debugResults.reduce((sum, { result }) => {\n              if (result.status === 'fulfilled') {\n                return sum + (result.value!.result!.debug!.responseLength || 0);\n              }\n              return sum;\n            }, 0),\n            jsonParseSuccess: debugResults.every(({ result }) => {\n              if (result.status === 'fulfilled') {\n                return result.value!.result!.debug!.jsonParseSuccess;\n              }\n              return false;\n            }),\n            errors: debugResults.flatMap(({ result, checkName }) => {\n              if (result.status === 'fulfilled') {\n                return (result.value!.result!.debug!.errors || []).map(\n                  (error: string) => `[${checkName}] ${error}`\n                );\n              }\n              return [`[${checkName}] Promise was rejected`];\n            }),\n            timestamp: new Date().toISOString(),\n            // Add additional debug information for parallel execution\n            totalApiCalls: debugResults.length,\n            apiCallDetails: debugResults.map(({ checkName, result }) => {\n              if (result.status === 'fulfilled') {\n                return {\n                  checkName,\n                  provider: result.value!.result!.debug!.provider,\n                  model: result.value!.result!.debug!.model,\n                  processingTime: result.value!.result!.debug!.processingTime,\n                  success: result.value!.result!.debug!.jsonParseSuccess,\n                };\n              }\n              return {\n                checkName,\n                provider: 'unknown',\n                model: 'unknown',\n                processingTime: 0,\n                success: false,\n              };\n            }),\n          };\n        }\n      }\n    }\n\n    return {\n      issues: filteredIssues,\n      debug: aggregatedDebug,\n    };\n  }\n\n  /**\n   * Get available check types from providers\n   * Note: Check names are now config-driven. This returns provider types only.\n   */\n  static getAvailableCheckTypes(): string[] {\n    const registry = CheckProviderRegistry.getInstance();\n    return registry.getAvailableProviders();\n  }\n\n  /**\n   * Validate check types\n   */\n  static validateCheckTypes(checks: string[]): { valid: string[]; invalid: string[] } {\n    const availableChecks = CheckExecutionEngine.getAvailableCheckTypes();\n    const valid: string[] = [];\n    const invalid: string[] = [];\n\n    for (const check of checks) {\n      if (availableChecks.includes(check)) {\n        valid.push(check);\n      } else {\n        invalid.push(check);\n      }\n    }\n\n    return { valid, invalid };\n  }\n\n  /**\n   * List available providers with their status\n   */\n  async listProviders(): Promise<\n    Array<{\n      name: string;\n      description: string;\n      available: boolean;\n      requirements: string[];\n    }>\n  > {\n    return await this.providerRegistry.listProviders();\n  }\n\n  /**\n   * Create a mock Octokit instance for local analysis\n   */\n  private createMockOctokit(): MockOctokit {\n    // Create simple mock functions that return promises\n    const mockGet = async () => ({\n      data: {\n        number: 0,\n        title: 'Local Analysis',\n        body: 'Local repository analysis',\n        user: { login: 'local-user' },\n        base: { ref: 'main' },\n        head: { ref: 'HEAD' },\n      },\n    });\n\n    const mockListFiles = async () => ({\n      data: [],\n    });\n\n    const mockListComments = async () => ({\n      data: [],\n    });\n\n    const mockCreateComment = async () => ({\n      data: { id: 1 },\n    });\n\n    return {\n      rest: {\n        pulls: {\n          get: mockGet,\n          listFiles: mockListFiles,\n        },\n        issues: {\n          listComments: mockListComments,\n          createComment: mockCreateComment,\n        },\n      },\n      request: async () => ({ data: {} }),\n      graphql: async () => ({}),\n      log: {\n        debug: () => {},\n        info: () => {},\n        warn: () => {},\n        error: () => {},\n      },\n      hook: {\n        before: () => {},\n        after: () => {},\n        error: () => {},\n        wrap: () => {},\n      },\n      auth: async () => ({ token: 'mock-token' }),\n    };\n  }\n\n  /**\n   * Create an error result\n   */\n  private createErrorResult(\n    repositoryInfo: GitRepositoryInfo,\n    errorMessage: string,\n    startTime: number,\n    timestamp: string,\n    checksExecuted: string[]\n  ): AnalysisResult {\n    const executionTime = Date.now() - startTime;\n\n    return {\n      repositoryInfo,\n      reviewSummary: {\n        issues: [\n          {\n            file: 'system',\n            line: 0,\n            endLine: undefined,\n            ruleId: 'system/error',\n            message: errorMessage,\n            severity: 'error',\n            category: 'logic',\n            suggestion: undefined,\n            replacement: undefined,\n          },\n        ],\n      },\n      executionTime,\n      timestamp,\n      checksExecuted,\n    };\n  }\n\n  /**\n   * Check if a task result should trigger fail-fast behavior\n   */\n  private isFailFastCandidate(value: unknown): value is {\n    error?: string;\n    result?: { issues?: Array<{ severity?: string }> };\n  } {\n    if (typeof value !== 'object' || value === null) {\n      return false;\n    }\n\n    const candidate = value as {\n      error?: unknown;\n      result?: unknown;\n    };\n\n    if (candidate.error !== undefined && typeof candidate.error !== 'string') {\n      return false;\n    }\n\n    if (candidate.result !== undefined) {\n      if (typeof candidate.result !== 'object' || candidate.result === null) {\n        return false;\n      }\n\n      const issues = (candidate.result as { issues?: unknown }).issues;\n      if (issues !== undefined && !Array.isArray(issues)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private shouldFailFast(result: unknown): boolean {\n    if (!this.isFailFastCandidate(result)) {\n      return false;\n    }\n\n    if (result.error) {\n      return true;\n    }\n\n    // If the result has a result with critical or error issues, it should fail fast\n    const issues = result.result?.issues;\n    if (Array.isArray(issues)) {\n      return issues.some(issue => issue?.severity === 'error' || issue?.severity === 'critical');\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if the working directory is a valid git repository\n   */\n  async isGitRepository(): Promise<boolean> {\n    try {\n      const repositoryInfo = await this.gitAnalyzer.analyzeRepository();\n      return repositoryInfo.isGitRepository;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Evaluate failure conditions for a check result\n   */\n  async evaluateFailureConditions(\n    checkName: string,\n    reviewSummary: ReviewSummary,\n    config?: import('./types/config').VisorConfig,\n    prInfo?: PRInfo,\n    previousOutputs?: Record<string, ReviewSummary> | Map<string, ReviewSummary>\n  ): Promise<FailureConditionResult[]> {\n    if (!config) {\n      return [];\n    }\n\n    const checkConfig = config.checks![checkName];\n    const checkSchema =\n      typeof checkConfig?.schema === 'object' ? 'custom' : checkConfig?.schema || '';\n    const checkGroup = checkConfig?.group || '';\n\n    // Convert previousOutputs Map to Record if needed\n    const outputsRecord: Record<string, ReviewSummary> | undefined = previousOutputs\n      ? previousOutputs instanceof Map\n        ? Object.fromEntries(previousOutputs.entries())\n        : previousOutputs\n      : undefined;\n\n    // Handle new simple fail_if syntax\n    const globalFailIf = config.fail_if;\n    const checkFailIf = checkConfig?.fail_if;\n\n    // If using new fail_if syntax\n    if (globalFailIf || checkFailIf) {\n      const results: FailureConditionResult[] = [];\n\n      // Evaluate global fail_if\n      if (globalFailIf) {\n        const failed = await this.failureEvaluator.evaluateSimpleCondition(\n          checkName,\n          checkSchema,\n          checkGroup,\n          reviewSummary,\n          globalFailIf,\n          outputsRecord\n        );\n\n        try {\n          addEvent('fail_if.evaluated', {\n            check: checkName,\n            scope: 'global',\n            name: 'global_fail_if',\n            expression: globalFailIf,\n          });\n        } catch {}\n        if (failed) {\n          try {\n            addEvent('fail_if.triggered', {\n              check: checkName,\n              scope: 'global',\n              name: 'global_fail_if',\n              expression: globalFailIf,\n              severity: 'error',\n            });\n          } catch {}\n          try {\n            addFailIfTriggered(checkName, 'global');\n          } catch {}\n          try {\n            const { emitNdjsonSpanWithEvents } = require('./telemetry/fallback-ndjson');\n            emitNdjsonSpanWithEvents(\n              'visor.fail_if',\n              { check: checkName, scope: 'global', name: 'global_fail_if' },\n              [\n                {\n                  name: 'fail_if.triggered',\n                  attrs: {\n                    check: checkName,\n                    scope: 'global',\n                    name: 'global_fail_if',\n                    expression: globalFailIf,\n                    severity: 'error',\n                  },\n                },\n              ]\n            );\n          } catch {}\n          logger.warn(`‚ö†Ô∏è  Check \"${checkName}\" - global fail_if condition met: ${globalFailIf}`);\n          results.push({\n            conditionName: 'global_fail_if',\n            expression: globalFailIf,\n            failed: true,\n            severity: 'error',\n            message: 'Global failure condition met',\n            haltExecution: false,\n          });\n        } else {\n          logger.debug(`‚úì Check \"${checkName}\" - global fail_if condition passed`);\n        }\n      }\n\n      // Evaluate check-specific fail_if (overrides global if present)\n      if (checkFailIf) {\n        const failed = await this.failureEvaluator.evaluateSimpleCondition(\n          checkName,\n          checkSchema,\n          checkGroup,\n          reviewSummary,\n          checkFailIf,\n          outputsRecord\n        );\n\n        try {\n          addEvent('fail_if.evaluated', {\n            check: checkName,\n            scope: 'check',\n            name: `${checkName}_fail_if`,\n            expression: checkFailIf,\n          });\n        } catch {}\n        try {\n          const { emitNdjsonSpanWithEvents } = require('./telemetry/fallback-ndjson');\n          emitNdjsonSpanWithEvents(\n            'visor.fail_if',\n            { check: checkName, scope: 'check', name: `${checkName}_fail_if` },\n            [\n              {\n                name: 'fail_if.evaluated',\n                attrs: {\n                  check: checkName,\n                  scope: 'check',\n                  name: `${checkName}_fail_if`,\n                  expression: checkFailIf,\n                },\n              },\n            ]\n          );\n        } catch {}\n        if (failed) {\n          try {\n            addEvent('fail_if.triggered', {\n              check: checkName,\n              scope: 'check',\n              name: `${checkName}_fail_if`,\n              expression: checkFailIf,\n              severity: 'error',\n            });\n          } catch {}\n          try {\n            addEvent('fail_if.evaluated', {\n              check: checkName,\n              scope: 'check',\n              name: `${checkName}_fail_if`,\n              expression: checkFailIf,\n            });\n          } catch {}\n          try {\n            addFailIfTriggered(checkName, 'check');\n          } catch {}\n          try {\n            const { emitNdjsonSpanWithEvents } = require('./telemetry/fallback-ndjson');\n            emitNdjsonSpanWithEvents(\n              'visor.fail_if',\n              { check: checkName, scope: 'check', name: `${checkName}_fail_if` },\n              [\n                {\n                  name: 'fail_if.triggered',\n                  attrs: {\n                    check: checkName,\n                    scope: 'check',\n                    name: `${checkName}_fail_if`,\n                    expression: checkFailIf,\n                    severity: 'error',\n                  },\n                },\n              ]\n            );\n          } catch {}\n          logger.warn(`‚ö†Ô∏è  Check \"${checkName}\" - fail_if condition met: ${checkFailIf}`);\n          results.push({\n            conditionName: `${checkName}_fail_if`,\n            expression: checkFailIf,\n            failed: true,\n            severity: 'error',\n            message: `Check ${checkName} failure condition met`,\n            haltExecution: false,\n          });\n        } else {\n          logger.debug(`‚úì Check \"${checkName}\" - fail_if condition passed`);\n        }\n      }\n\n      try {\n        const { emitNdjsonSpanWithEvents } = require('./telemetry/fallback-ndjson');\n        const hadTriggered = results.some(r => r.failed === true);\n        emitNdjsonSpanWithEvents(\n          'visor.fail_if',\n          {\n            check: checkName,\n            scope: hadTriggered\n              ? checkFailIf\n                ? 'check'\n                : 'global'\n              : checkFailIf\n                ? 'check'\n                : 'global',\n          },\n          [\n            {\n              name: 'fail_if.evaluated',\n              attrs: { check: checkName, scope: checkFailIf ? 'check' : 'global' },\n            },\n          ].concat(\n            hadTriggered\n              ? [\n                  {\n                    name: 'fail_if.triggered',\n                    attrs: { check: checkName, scope: checkFailIf ? 'check' : 'global' },\n                  },\n                ]\n              : []\n          )\n        );\n      } catch {}\n      return results;\n    }\n\n    // Fall back to old failure_conditions syntax\n    const globalConditions = config.failure_conditions;\n    const checkConditions = checkConfig?.failure_conditions;\n\n    return await this.failureEvaluator.evaluateConditions(\n      checkName,\n      checkSchema,\n      checkGroup,\n      reviewSummary,\n      globalConditions,\n      checkConditions,\n      undefined, // previousOutputs\n      prInfo?.authorAssociation\n    );\n  }\n\n  /**\n   * Get repository status summary\n   */\n  async getRepositoryStatus(): Promise<{\n    isGitRepository: boolean;\n    hasChanges: boolean;\n    branch: string;\n    filesChanged: number;\n  }> {\n    try {\n      const repositoryInfo = await this.gitAnalyzer.analyzeRepository();\n      return {\n        isGitRepository: repositoryInfo.isGitRepository,\n        hasChanges: repositoryInfo.files.length > 0,\n        branch: repositoryInfo.head,\n        filesChanged: repositoryInfo.files.length,\n      };\n    } catch {\n      return {\n        isGitRepository: false,\n        hasChanges: false,\n        branch: 'unknown',\n        filesChanged: 0,\n      };\n    }\n  }\n\n  /**\n   * Initialize GitHub check runs for each configured check\n   */\n  private async initializeGitHubChecks(\n    options: CheckExecutionOptions,\n    logFn: (message: string) => void\n  ): Promise<void> {\n    if (\n      !options.githubChecks?.octokit ||\n      !options.githubChecks.owner ||\n      !options.githubChecks.repo ||\n      !options.githubChecks.headSha\n    ) {\n      logFn('‚ö†Ô∏è GitHub checks enabled but missing required parameters');\n      return;\n    }\n\n    try {\n      this.githubCheckService = new GitHubCheckService(options.githubChecks.octokit);\n      this.checkRunMap = new Map();\n      this.githubContext = {\n        owner: options.githubChecks.owner,\n        repo: options.githubChecks.repo,\n      };\n\n      logFn(`üîç Creating GitHub check runs for ${options.checks.length} checks...`);\n\n      for (const checkName of options.checks) {\n        try {\n          const checkRunOptions: CheckRunOptions = {\n            owner: options.githubChecks.owner,\n            repo: options.githubChecks.repo,\n            head_sha: options.githubChecks.headSha,\n            name: `Visor: ${checkName}`,\n            external_id: `visor-${checkName}-${options.githubChecks.headSha.substring(0, 7)}`,\n          };\n\n          const checkRun = await this.githubCheckService.createCheckRun(checkRunOptions, {\n            title: `${checkName} Analysis`,\n            summary: `Running ${checkName} check using AI-powered analysis...`,\n          });\n\n          this.checkRunMap.set(checkName, checkRun);\n          logFn(`‚úÖ Created check run for ${checkName}: ${checkRun.url}`);\n        } catch (error) {\n          logFn(`‚ùå Failed to create check run for ${checkName}: ${error}`);\n        }\n      }\n    } catch (error) {\n      // Check if this is a permissions error\n      if (\n        error instanceof Error &&\n        (error.message.includes('403') || error.message.includes('checks:write'))\n      ) {\n        logFn(\n          '‚ö†Ô∏è GitHub checks API not available - insufficient permissions. Check runs will be skipped.'\n        );\n        logFn('üí° To enable check runs, ensure your GitHub token has \"checks:write\" permission.');\n        this.githubCheckService = undefined;\n        this.checkRunMap = undefined;\n      } else {\n        logFn(`‚ùå Failed to initialize GitHub check runs: ${error}`);\n        this.githubCheckService = undefined;\n        this.checkRunMap = undefined;\n      }\n    }\n  }\n\n  /**\n   * Update GitHub check runs to in-progress status\n   */\n  private async updateGitHubChecksInProgress(options: CheckExecutionOptions): Promise<void> {\n    if (\n      !this.githubCheckService ||\n      !this.checkRunMap ||\n      !options.githubChecks?.owner ||\n      !options.githubChecks.repo\n    ) {\n      return;\n    }\n\n    for (const [checkName, checkRun] of this.checkRunMap) {\n      try {\n        await this.githubCheckService.updateCheckRunInProgress(\n          options.githubChecks.owner,\n          options.githubChecks.repo,\n          checkRun.id,\n          {\n            title: `Analyzing with ${checkName}...`,\n            summary: `AI-powered analysis is in progress for ${checkName} check.`,\n          }\n        );\n        console.log(`üîÑ Updated ${checkName} check to in-progress status`);\n      } catch (error) {\n        console.error(`‚ùå Failed to update ${checkName} check to in-progress: ${error}`);\n      }\n    }\n  }\n\n  /**\n   * Complete GitHub check runs with results\n   */\n  private async completeGitHubChecksWithResults(\n    reviewSummary: ReviewSummary,\n    options: CheckExecutionOptions,\n    prInfo: import('./pr-analyzer').PRInfo\n  ): Promise<void> {\n    const GH_DBG = process.env.VISOR_DEBUG_GITHUB_COMMENTS === 'true';\n    if (\n      !this.githubCheckService ||\n      !this.checkRunMap ||\n      !options.githubChecks?.owner ||\n      !options.githubChecks.repo\n    ) {\n      return;\n    }\n\n    // Group issues by check name\n    const issuesByCheck = new Map<string, import('./reviewer').ReviewIssue[]>();\n\n    // Initialize empty arrays for all checks\n    for (const checkName of this.checkRunMap.keys()) {\n      issuesByCheck.set(checkName, []);\n    }\n\n    // Group issues by their producing check (explicit checkName only)\n    for (const issue of reviewSummary.issues || []) {\n      if (issue.checkName && issuesByCheck.has(issue.checkName)) {\n        issuesByCheck.get(issue.checkName)!.push(issue);\n      }\n    }\n    if (GH_DBG) {\n      try {\n        const counts = Array.from(issuesByCheck.entries()).map(([k, v]) => ({\n          check: k,\n          issues: v.length,\n        }));\n        const sample = (reviewSummary.issues || []).slice(0, 3).map(i => ({\n          file: i.file,\n          line: i.line,\n          severity: i.severity,\n          ruleId: i.ruleId,\n          checkName: (i as any).checkName,\n        }));\n        console.error(\n          `[gh-debug] GH checks grouping: ${JSON.stringify(counts)} sample=${JSON.stringify(sample)}`\n        );\n      } catch {}\n    }\n\n    console.log(`üèÅ Completing ${this.checkRunMap.size} GitHub check runs...`);\n\n    for (const [checkName, checkRun] of this.checkRunMap) {\n      try {\n        const checkIssues = issuesByCheck.get(checkName) || [];\n\n        // Evaluate failure conditions for this specific check\n        const failureResults = await this.evaluateFailureConditions(\n          checkName,\n          { issues: checkIssues },\n          options.config\n        );\n\n        // Detect command execution failure patterns to mark check as failed without requiring fail_if\n        // We treat issues with ruleId starting with 'command/' as execution errors\n        const execErrorIssue = checkIssues.find(i => i.ruleId?.startsWith('command/'));\n\n        await this.githubCheckService.completeCheckRun(\n          options.githubChecks.owner,\n          options.githubChecks.repo,\n          checkRun.id,\n          checkName,\n          failureResults,\n          checkIssues,\n          execErrorIssue ? execErrorIssue.message : undefined, // executionError\n          prInfo.files.map((f: import('./pr-analyzer').PRFile) => f.filename), // filesChangedInCommit\n          options.githubChecks.prNumber, // prNumber\n          options.githubChecks.headSha // currentCommitSha\n        );\n        if (GH_DBG) {\n          try {\n            console.error(\n              `[gh-debug] Completed GH check='${checkName}' with ${checkIssues.length} issues; failureIf=${\n                (failureResults || []).filter(f => f.failed).length\n              }`\n            );\n          } catch {}\n        }\n        console.log(`‚úÖ Completed ${checkName} check with ${checkIssues.length} issues`);\n      } catch (error) {\n        console.error(`‚ùå Failed to complete ${checkName} check: ${error}`);\n\n        // Try to mark the check as failed due to execution error\n        try {\n          await this.githubCheckService.completeCheckRun(\n            options.githubChecks.owner,\n            options.githubChecks.repo,\n            checkRun.id,\n            checkName,\n            [],\n            [],\n            error instanceof Error ? error.message : 'Unknown error occurred'\n          );\n        } catch (finalError) {\n          console.error(`‚ùå Failed to mark ${checkName} check as failed: ${finalError}`);\n        }\n      }\n    }\n  }\n\n  /**\n   * Complete GitHub check runs with error status\n   */\n  private async completeGitHubChecksWithError(errorMessage: string): Promise<void> {\n    if (!this.githubCheckService || !this.checkRunMap || !this.githubContext) {\n      return;\n    }\n\n    console.log(`‚ùå Completing ${this.checkRunMap.size} GitHub check runs with error...`);\n\n    for (const [checkName, checkRun] of this.checkRunMap) {\n      try {\n        await this.githubCheckService.completeCheckRun(\n          this.githubContext.owner,\n          this.githubContext.repo,\n          checkRun.id,\n          checkName,\n          [],\n          [],\n          errorMessage\n        );\n        console.log(`‚ùå Completed ${checkName} check with error: ${errorMessage}`);\n      } catch (error) {\n        console.error(`‚ùå Failed to complete ${checkName} check with error: ${error}`);\n      }\n    }\n  }\n\n  /**\n   * Filter checks based on their event triggers to prevent execution of checks\n   * that shouldn't run for the current event type\n   */\n  private filterChecksByEvent(\n    checks: string[],\n    config?: import('./types/config').VisorConfig,\n    prInfo?: PRInfo,\n    logFn?: (message: string) => void,\n    debug?: boolean\n  ): string[] {\n    if (!config?.checks) {\n      // No config available, return all checks (fallback behavior)\n      return checks;\n    }\n\n    // If we have event context from GitHub (prInfo with eventType), apply strict filtering\n    // Otherwise (CLI, tests), use conservative filtering\n    const prInfoWithEvent = prInfo as PRInfo & {\n      eventType?: import('./types/config').EventTrigger;\n    };\n    const hasEventContext =\n      prInfoWithEvent && 'eventType' in prInfoWithEvent && prInfoWithEvent.eventType;\n\n    if (hasEventContext) {\n      // GitHub Action context - apply strict event filtering\n      const currentEvent = prInfoWithEvent.eventType!;\n      if (debug) {\n        logFn?.(`üîß Debug: GitHub Action context, current event: ${currentEvent}`);\n      }\n\n      const filteredChecks: string[] = [];\n      for (const checkName of checks) {\n        const checkConfig = config.checks![checkName];\n        if (!checkConfig) {\n          filteredChecks.push(checkName);\n          continue;\n        }\n\n        const hasOn = Object.prototype.hasOwnProperty.call(checkConfig, 'on');\n        const eventTriggers = checkConfig.on || [];\n        // Semantics: missing 'on' OR empty 'on: []' ‚Üí include for all events\n        if (!hasOn || eventTriggers.length === 0) {\n          filteredChecks.push(checkName);\n          if (debug)\n            logFn?.(\n              `üîß Debug: Check '${checkName}' has ${!hasOn ? 'no' : 'empty'} 'on' field, including for '${currentEvent}'`\n            );\n          continue;\n        }\n\n        if (eventTriggers.includes(currentEvent)) {\n          filteredChecks.push(checkName);\n          if (debug)\n            logFn?.(`üîß Debug: Check '${checkName}' matches event '${currentEvent}', including`);\n        } else if (debug) {\n          logFn?.(\n            `üîß Debug: Check '${checkName}' does not match event '${currentEvent}' (triggers: ${JSON.stringify(\n              eventTriggers\n            )}), skipping`\n          );\n        }\n      }\n      return filteredChecks;\n    } else {\n      // CLI/Test context - conservative filtering\n      if (debug) {\n        logFn?.(`üîß Debug: CLI/Test context, using conservative filtering`);\n      }\n\n      const filteredChecks: string[] = [];\n      for (const checkName of checks) {\n        const checkConfig = config.checks![checkName];\n        if (!checkConfig) {\n          filteredChecks.push(checkName);\n          continue;\n        }\n\n        const eventTriggers = checkConfig.on || [];\n        // Empty or missing 'on' ‚Üí include on all\n        if (eventTriggers.length === 0) {\n          filteredChecks.push(checkName);\n          if (debug) logFn?.(`üîß Debug: Check '${checkName}' included (on: [])`);\n          continue;\n        }\n        // Otherwise include; CLI context does not strictly filter by event\n        filteredChecks.push(checkName);\n        if (debug)\n          logFn?.(\n            `üîß Debug: Check '${checkName}' included (triggers: ${JSON.stringify(eventTriggers)})`\n          );\n      }\n      return filteredChecks;\n    }\n  }\n\n  /**\n   * Determine the current event type from PR info\n   */\n  private getCurrentEventType(prInfo?: PRInfo): import('./types/config').EventTrigger {\n    if (!prInfo) {\n      return 'pr_opened'; // Default fallback\n    }\n\n    // For now, assume all PR-related operations are 'pr_updated' since we don't have\n    // direct access to the original GitHub event here. This is a simplification.\n    // In the future, we could pass the actual event type through the call chain.\n\n    // The key insight is that issue-assistant should only run on issue_opened/issue_comment\n    // events, which don't generate PRInfo objects in the first place.\n    return 'pr_updated';\n  }\n\n  /**\n   * Initialize execution statistics for a check\n   */\n  private initializeCheckStats(checkName: string): void {\n    this.executionStats.set(checkName, {\n      checkName,\n      totalRuns: 0,\n      successfulRuns: 0,\n      failedRuns: 0,\n      skipped: false,\n      totalDuration: 0,\n      providerDurationMs: 0,\n      issuesFound: 0,\n      issuesBySeverity: {\n        critical: 0,\n        error: 0,\n        warning: 0,\n        info: 0,\n      },\n      perIterationDuration: [],\n    });\n  }\n\n  /**\n   * Record the start of a check iteration\n   * Returns the start timestamp for duration tracking\n   */\n  private recordIterationStart(_checkName: string): number {\n    return Date.now();\n  }\n\n  /**\n   * Record completion of a check iteration\n   */\n  private recordIterationComplete(\n    checkName: string,\n    startTime: number,\n    success: boolean,\n    issues: ReviewIssue[],\n    output?: unknown\n  ): void {\n    const stats = this.executionStats.get(checkName);\n    if (!stats) return;\n\n    const duration = Date.now() - startTime;\n    // debug noise removed (kept locally when VISOR_DEBUG needed)\n    stats.totalRuns++;\n    if (success) {\n      stats.successfulRuns++;\n    } else {\n      stats.failedRuns++;\n    }\n    stats.totalDuration += duration;\n    stats.perIterationDuration!.push(duration);\n\n    // If we previously marked this check as skipped in an earlier wave/level,\n    // clear the skip flag now that an execution actually occurred. This ensures\n    // coverage accounting (calls/executed) reflects the latest run.\n    try {\n      if (stats.skipped) {\n        stats.skipped = false;\n        stats.skipReason = undefined;\n        stats.skipCondition = undefined;\n      }\n    } catch {}\n\n    // Count issues by severity\n    for (const issue of issues) {\n      stats.issuesFound++;\n      if (issue.severity === 'critical') stats.issuesBySeverity.critical++;\n      else if (issue.severity === 'error') stats.issuesBySeverity.error++;\n      else if (issue.severity === 'warning') stats.issuesBySeverity.warning++;\n      else if (issue.severity === 'info') stats.issuesBySeverity.info++;\n    }\n\n    // Track outputs produced\n    if (output !== undefined) {\n      stats.outputsProduced = (stats.outputsProduced || 0) + 1;\n    }\n  }\n\n  /**\n   * Record provider/self execution time (in milliseconds) for a check\n   */\n  private recordProviderDuration(checkName: string, ms: number): void {\n    const stats = this.executionStats.get(checkName);\n    if (!stats) return;\n    stats.providerDurationMs = (stats.providerDurationMs || 0) + Math.max(0, Math.floor(ms));\n  }\n\n  /**\n   * Track output in history for loop/goto scenarios\n   */\n  private trackOutputHistory(checkName: string, output: unknown): void {\n    if (output === undefined) return;\n\n    if (!this.outputHistory.has(checkName)) {\n      this.outputHistory.set(checkName, []);\n    }\n    const arr = this.outputHistory.get(checkName)!;\n    arr.push(output);\n    try {\n      if (process.env.VISOR_DEBUG === 'true' && (checkName === 'refine' || checkName === 'ask')) {\n        console.error(`[hist] push ${checkName} (len now ${arr.length})`);\n      }\n    } catch {}\n    // avoid noisy history prints\n  }\n\n  /**\n   * Snapshot of output history per step for test assertions\n   */\n  public getOutputHistorySnapshot(): Record<string, unknown[]> {\n    const out: Record<string, unknown[]> = {};\n    for (const [k, v] of this.outputHistory.entries()) {\n      out[k] = Array.isArray(v) ? [...v] : [];\n    }\n    return out;\n  }\n\n  /**\n   * Record that a check was skipped\n   */\n  private recordSkip(\n    checkName: string,\n    reason: 'if_condition' | 'fail_fast' | 'dependency_failed',\n    condition?: string\n  ): void {\n    const stats = this.executionStats.get(checkName);\n    if (!stats) return;\n\n    stats.skipped = true;\n    stats.skipReason = reason;\n    if (condition) {\n      stats.skipCondition = condition;\n    }\n  }\n\n  /**\n   * Record forEach preview items\n   */\n  private recordForEachPreview(checkName: string, items: unknown[] | undefined): void {\n    const stats = this.executionStats.get(checkName);\n    if (!stats) return;\n    if (!Array.isArray(items) || items.length === 0) return;\n\n    // Store preview of first 3 items\n    const preview = items.slice(0, 3).map(item => {\n      let str: string;\n      if (typeof item === 'string') {\n        str = item;\n      } else if (item === undefined || item === null) {\n        str = '(empty)';\n      } else {\n        try {\n          const j = JSON.stringify(item);\n          str = typeof j === 'string' ? j : String(item);\n        } catch {\n          str = String(item);\n        }\n      }\n      return str.length > 50 ? str.substring(0, 47) + '...' : str;\n    });\n\n    if (items.length > 3) {\n      preview.push(`...${items.length - 3} more`);\n    }\n\n    stats.forEachPreview = preview;\n  }\n\n  /**\n   * Record an error for a check\n   */\n  private recordError(checkName: string, error: Error | string): void {\n    const stats = this.executionStats.get(checkName);\n    if (!stats) return;\n\n    stats.errorMessage = error instanceof Error ? error.message : String(error);\n  }\n\n  /**\n   * Build the final execution statistics object\n   */\n  private buildExecutionStatistics(): ExecutionStatistics {\n    const checks = Array.from(this.executionStats.values());\n    const totalExecutions = checks.reduce((sum, s) => sum + s.totalRuns, 0);\n    const successfulExecutions = checks.reduce((sum, s) => sum + s.successfulRuns, 0);\n    const failedExecutions = checks.reduce((sum, s) => sum + s.failedRuns, 0);\n    const skippedChecks = checks.filter(s => s.skipped).length;\n    const totalDuration = checks.reduce((sum, s) => sum + s.totalDuration, 0);\n\n    return {\n      totalChecksConfigured: checks.length,\n      totalExecutions,\n      successfulExecutions,\n      failedExecutions,\n      skippedChecks,\n      totalDuration,\n      checks,\n    };\n  }\n\n  // Generic fatality helpers to avoid duplication\n  private isFatalRule(id: string, severity?: string): boolean {\n    const sev = (severity || '').toLowerCase();\n    return (\n      sev === 'error' ||\n      sev === 'critical' ||\n      id === 'command/execution_error' ||\n      id.endsWith('/command/execution_error') ||\n      id === 'command/timeout' ||\n      id.endsWith('/command/timeout') ||\n      id === 'command/transform_js_error' ||\n      id.endsWith('/command/transform_js_error') ||\n      id === 'command/transform_error' ||\n      id.endsWith('/command/transform_error') ||\n      id.endsWith('/forEach/iteration_error') ||\n      id === 'forEach/undefined_output' ||\n      id.endsWith('/forEach/undefined_output') ||\n      id.endsWith('_fail_if') ||\n      id.endsWith('/global_fail_if')\n    );\n  }\n\n  private hasFatal(issues: ReviewIssue[] | undefined): boolean {\n    if (!issues || issues.length === 0) return false;\n    return issues.some(i => this.isFatalRule(i.ruleId || '', i.severity));\n  }\n\n  // Gating-specific fatality: ignore generic severity-only errors. Only gate on\n  // well-known provider/command/forEach failures and explicit fail_if markers.\n  private isGatingFatal(issue: ReviewIssue): boolean {\n    const id = (issue.ruleId || '').toString();\n    return (\n      id === 'command/execution_error' ||\n      id.endsWith('/command/execution_error') ||\n      id === 'command/timeout' ||\n      id.endsWith('/command/timeout') ||\n      id === 'command/transform_js_error' ||\n      id.endsWith('/command/transform_js_error') ||\n      id === 'command/transform_error' ||\n      id.endsWith('/command/transform_error') ||\n      id.endsWith('/forEach/iteration_error') ||\n      id === 'forEach/undefined_output' ||\n      id.endsWith('/forEach/undefined_output') ||\n      id.endsWith('_fail_if') ||\n      id.endsWith('/global_fail_if')\n    );\n  }\n\n  private async failIfTriggered(\n    checkName: string,\n    result: ReviewSummary,\n    config?: import('./types/config').VisorConfig,\n    previousOutputs?: Record<string, ReviewSummary> | Map<string, ReviewSummary>\n  ): Promise<boolean> {\n    if (!config) return false;\n    const failures = await this.evaluateFailureConditions(\n      checkName,\n      result,\n      config,\n      undefined,\n      previousOutputs\n    );\n    return failures.some(f => f.failed);\n  }\n\n  /**\n   * Truncate a string to max length with ellipsis\n   */\n  private truncate(str: string, maxLen: number): string {\n    if (str.length <= maxLen) return str;\n    return str.substring(0, maxLen - 3) + '...';\n  }\n\n  /**\n   * Format the Status column for execution summary table\n   */\n  private formatStatusColumn(stats: CheckExecutionStats): string {\n    if (stats.skipped) {\n      if (stats.skipReason === 'if_condition') return '‚è≠ if';\n      if (stats.skipReason === 'fail_fast') return '‚è≠ ff';\n      if (stats.skipReason === 'dependency_failed') return '‚è≠ dep';\n      return '‚è≠';\n    }\n\n    // Prefer history length when it indicates more actual executions than our counter\n    const historyLen = (() => {\n      try {\n        return this.outputHistory.get(stats.checkName)?.length || 0;\n      } catch {\n        return 0;\n      }\n    })();\n    const totalRuns = Math.max(stats.totalRuns || 0, historyLen);\n    if (totalRuns === 0) return '-';\n\n    const symbol = stats.failedRuns === 0 ? '‚úî' : stats.successfulRuns === 0 ? '‚úñ' : '‚úî/‚úñ';\n\n    // Show iteration count if > 1\n    if (totalRuns > 1) {\n      if (stats.failedRuns > 0 && stats.successfulRuns > 0) {\n        // Partial success\n        return `${symbol} ${stats.successfulRuns}/${totalRuns}`;\n      } else {\n        // All success or all failed\n        return `${symbol} √ó${totalRuns}`;\n      }\n    }\n\n    return symbol;\n  }\n\n  /**\n   * Format the Details column for execution summary table\n   */\n  private formatDetailsColumn(stats: CheckExecutionStats, _isForEachParent?: boolean): string {\n    const parts: string[] = [];\n\n    // Simpler summary: do not show passes/items here to avoid confusion.\n    // Status column already shows √óN when runs > 1.\n\n    // Show self/provider time to disambiguate inclusive duration in the main column\n    if (typeof stats.providerDurationMs === 'number' && stats.providerDurationMs > 0) {\n      const selfSec = (stats.providerDurationMs / 1000).toFixed(1);\n      parts.unshift(`self:${selfSec}s`);\n    }\n\n    // Outputs produced (forEach)\n    if (stats.outputsProduced && stats.outputsProduced > 0) {\n      parts.push(`‚Üí${stats.outputsProduced}`);\n    }\n\n    // Critical issues\n    if (stats.issuesBySeverity.critical > 0) {\n      parts.push(`${stats.issuesBySeverity.critical}üî¥`);\n    }\n\n    // Warnings\n    if (stats.issuesBySeverity.warning > 0) {\n      parts.push(`${stats.issuesBySeverity.warning}‚ö†Ô∏è`);\n    }\n\n    // Info (only if no critical/warnings)\n    if (\n      stats.issuesBySeverity.info > 0 &&\n      stats.issuesBySeverity.critical === 0 &&\n      stats.issuesBySeverity.warning === 0\n    ) {\n      parts.push(`${stats.issuesBySeverity.info}üí°`);\n    }\n\n    // Error message or skip condition\n    if (stats.errorMessage) {\n      parts.push(this.truncate(stats.errorMessage, 20));\n    } else if (stats.skipCondition) {\n      parts.push(this.truncate(stats.skipCondition, 20));\n    }\n\n    return parts.join(' ');\n  }\n\n  /**\n   * Log the execution summary table\n   */\n  private logExecutionSummary(stats: ExecutionStatistics): void {\n    const totalIssues = stats.checks.reduce((sum, s) => sum + s.issuesFound, 0);\n    const criticalIssues = stats.checks.reduce((sum, s) => sum + s.issuesBySeverity.critical, 0);\n    const warningIssues = stats.checks.reduce((sum, s) => sum + s.issuesBySeverity.warning, 0);\n    const durationSec = (stats.totalDuration / 1000).toFixed(1);\n\n    // Summary box\n    const summaryTable = new (require('cli-table3'))({\n      style: {\n        head: [],\n        border: [],\n      },\n      colWidths: [41],\n    });\n\n    summaryTable.push(\n      [`Checks Complete (${durationSec}s)`],\n      [`Checks: ${stats.totalChecksConfigured} configured ‚Üí ${stats.totalExecutions} executions`],\n      [\n        `Status: ${stats.successfulExecutions} ‚úî ‚îÇ ${stats.failedExecutions} ‚úñ ‚îÇ ${stats.skippedChecks} ‚è≠`,\n      ]\n    );\n\n    if (totalIssues > 0) {\n      let issuesLine = `Issues: ${totalIssues} total`;\n      if (criticalIssues > 0) issuesLine += ` (${criticalIssues} üî¥`;\n      if (warningIssues > 0) issuesLine += `${criticalIssues > 0 ? ' ' : ' ('}${warningIssues} ‚ö†Ô∏è)`;\n      else if (criticalIssues > 0) issuesLine += ')';\n      summaryTable.push([issuesLine]);\n    }\n\n    logger.info('');\n    logger.info(summaryTable.toString());\n\n    // Details table\n    logger.info('');\n    logger.info('Check Details:');\n\n    const detailsTable = new (require('cli-table3'))({\n      head: ['Check', 'Duration', 'Status', 'Details'],\n      colWidths: [21, 18, 10, 21],\n      style: {\n        head: ['cyan'],\n        border: ['grey'],\n      },\n    });\n\n    for (const checkStats of stats.checks) {\n      const isForEachParent = !!this.config?.checks?.[checkStats.checkName]?.forEach;\n      // Show only the self/provider total time across all runs.\n      const selfMs =\n        typeof checkStats.providerDurationMs === 'number' && checkStats.providerDurationMs > 0\n          ? checkStats.providerDurationMs\n          : checkStats.totalDuration; // fallback if provider time missing\n      const duration = checkStats.skipped ? '-' : `${(selfMs / 1000).toFixed(1)}s`;\n      const status = this.formatStatusColumn(checkStats);\n      const details = this.formatDetailsColumn(checkStats, isForEachParent);\n\n      detailsTable.push([checkStats.checkName, duration, status, details]);\n    }\n\n    logger.info(detailsTable.toString());\n\n    // Clarify that we will finalize GitHub check runs after the table (if enabled)\n    try {\n      if (this.checkRunMap && this.checkRunMap.size > 0) {\n        logger.info('');\n        logger.info('‚è≥ Finalizing GitHub check runs...');\n      }\n    } catch {}\n\n    // Legend\n    logger.info('');\n    logger.info(\n      'Legend: ‚úî=success ‚îÇ ‚úñ=failed ‚îÇ ‚è≠=skipped ‚îÇ √óN=iterations ‚îÇ ‚ÜíN=outputs ‚îÇ Nüî¥=critical ‚îÇ N‚ö†Ô∏è=warnings'\n    );\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { VisorConfig, CheckConfig } from '../types/config';\n\n/**\n * Utility class for merging Visor configurations with proper override semantics\n */\nexport class ConfigMerger {\n  /**\n   * Merge two configurations with child overriding parent\n   * @param parent - Base configuration\n   * @param child - Configuration to merge on top\n   * @returns Merged configuration\n   */\n  public merge(parent: Partial<VisorConfig>, child: Partial<VisorConfig>): Partial<VisorConfig> {\n    // Start with a deep copy of parent\n    const result: Partial<VisorConfig> = this.deepCopy(parent);\n\n    // Merge simple properties (child overrides parent)\n    if (child.version !== undefined) result.version = child.version;\n    if (child.ai_model !== undefined) result.ai_model = child.ai_model;\n    if (child.ai_provider !== undefined) result.ai_provider = child.ai_provider;\n    if (child.max_parallelism !== undefined) result.max_parallelism = child.max_parallelism;\n    if (child.fail_fast !== undefined) result.fail_fast = child.fail_fast;\n    if (child.fail_if !== undefined) result.fail_if = child.fail_if;\n    if (child.failure_conditions !== undefined)\n      result.failure_conditions = child.failure_conditions;\n\n    // Merge environment variables (deep merge)\n    if (child.env) {\n      result.env = this.mergeObjects(parent.env || {}, child.env);\n    }\n\n    // Merge output configuration (deep merge)\n    if (child.output) {\n      result.output = this.mergeOutputConfig(parent.output, child.output);\n    }\n\n    // Merge checks (special handling)\n    if (child.checks) {\n      result.checks = this.mergeChecks(parent.checks || {}, child.checks);\n    }\n\n    // Merge custom tools\n    if (child.tools) {\n      result.tools = this.mergeObjects(parent.tools || {}, child.tools);\n    }\n\n    // Merge workflow imports (concatenate arrays)\n    if (child.imports) {\n      const parentImports = parent.imports || [];\n      const childImports = child.imports || [];\n      // Combine and deduplicate\n      result.imports = [...new Set([...parentImports, ...childImports])];\n    }\n\n    // Note: extends/include should not be in the final merged config\n    // They are only used during the loading process\n\n    return result;\n  }\n\n  /**\n   * Deep copy an object\n   */\n  private deepCopy<T>(obj: T): T {\n    if (obj === null || obj === undefined) {\n      return obj;\n    }\n    if (obj instanceof Date) {\n      return new Date(obj.getTime()) as unknown as T;\n    }\n    if (obj instanceof Array) {\n      const copy: unknown[] = [];\n      for (const item of obj) {\n        copy.push(this.deepCopy(item));\n      }\n      return copy as unknown as T;\n    }\n    if (obj instanceof Object) {\n      const copy = {} as Record<string, unknown>;\n      for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          copy[key] = this.deepCopy((obj as any)[key]);\n        }\n      }\n      return copy as T;\n    }\n    return obj;\n  }\n\n  /**\n   * Merge two objects (child overrides parent)\n   */\n  private mergeObjects<T extends Record<string, any>>(parent: T, child: T): T {\n    const result: any = { ...parent };\n\n    for (const key in child) {\n      if (Object.prototype.hasOwnProperty.call(child, key)) {\n        const parentValue = parent[key];\n        const childValue = child[key];\n\n        if (childValue === null || childValue === undefined) {\n          // null/undefined in child removes the key\n          delete result[key];\n        } else if (\n          typeof parentValue === 'object' &&\n          typeof childValue === 'object' &&\n          !Array.isArray(parentValue) &&\n          !Array.isArray(childValue) &&\n          parentValue !== null &&\n          childValue !== null\n        ) {\n          // Deep merge objects\n          result[key] = this.mergeObjects(\n            parentValue as Record<string, any>,\n            childValue as Record<string, any>\n          );\n        } else {\n          // Child overrides parent (including arrays)\n          result[key] = this.deepCopy(childValue);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Merge output configurations\n   */\n  private mergeOutputConfig(\n    parent?: Partial<VisorConfig>['output'],\n    child?: Partial<VisorConfig>['output']\n  ): Partial<VisorConfig>['output'] {\n    if (!child) return parent;\n    if (!parent) return child;\n\n    const result: any = this.deepCopy(parent);\n\n    // Merge pr_comment\n    if (child.pr_comment) {\n      result.pr_comment = this.mergeObjects(\n        (parent.pr_comment || {}) as Record<string, any>,\n        child.pr_comment as Record<string, any>\n      ) as any;\n    }\n\n    // Merge file_comment\n    if (child.file_comment !== undefined) {\n      if (child.file_comment === null) {\n        delete result.file_comment;\n      } else {\n        result.file_comment = this.mergeObjects(\n          (parent.file_comment || {}) as Record<string, any>,\n          child.file_comment as Record<string, any>\n        ) as any;\n      }\n    }\n\n    // Merge github_checks\n    if (child.github_checks !== undefined) {\n      if (child.github_checks === null) {\n        delete result.github_checks;\n      } else {\n        result.github_checks = this.mergeObjects(\n          (parent.github_checks || {}) as Record<string, any>,\n          child.github_checks as Record<string, any>\n        ) as any;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Merge check configurations with special handling\n   */\n  private mergeChecks(\n    parent: Record<string, CheckConfig>,\n    child: Record<string, CheckConfig>\n  ): Record<string, CheckConfig> {\n    const result: Record<string, CheckConfig> = {};\n\n    // Start with all parent checks\n    for (const [checkName, checkConfig] of Object.entries(parent)) {\n      result[checkName] = this.deepCopy(checkConfig);\n    }\n\n    // Process child checks\n    for (const [checkName, childConfig] of Object.entries(child)) {\n      const parentConfig = parent[checkName];\n\n      if (!parentConfig) {\n        // New check - need to process appendPrompt even without parent\n        const copiedConfig = this.deepCopy(childConfig);\n\n        // Default to 'ai' type if not specified\n        if (!copiedConfig.type) {\n          copiedConfig.type = 'ai';\n        }\n\n        // Default 'on' to ['manual'] if not specified\n        if (!copiedConfig.on) {\n          copiedConfig.on = ['manual'];\n        }\n\n        // Handle appendPrompt for new checks (convert to prompt)\n        if (copiedConfig.appendPrompt !== undefined) {\n          // If there's no parent, appendPrompt becomes the prompt\n          if (!copiedConfig.prompt) {\n            copiedConfig.prompt = copiedConfig.appendPrompt;\n          } else {\n            // If both prompt and appendPrompt exist in child, append them\n            copiedConfig.prompt = copiedConfig.prompt + '\\n\\n' + copiedConfig.appendPrompt;\n          }\n          // Remove appendPrompt from final config\n          delete copiedConfig.appendPrompt;\n        }\n\n        result[checkName] = copiedConfig;\n      } else {\n        // Merge existing check\n        result[checkName] = this.mergeCheckConfig(parentConfig, childConfig);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Merge individual check configurations\n   */\n  private mergeCheckConfig(parent: CheckConfig, child: CheckConfig): CheckConfig {\n    const result: CheckConfig = this.deepCopy(parent);\n\n    // Simple properties (child overrides parent)\n    if (child.type !== undefined) result.type = child.type;\n\n    // Default to 'ai' type if not specified in either parent or child\n    if (!result.type) {\n      result.type = 'ai';\n    }\n    if (child.prompt !== undefined) result.prompt = child.prompt;\n\n    // Handle appendPrompt - append to existing prompt\n    if (child.appendPrompt !== undefined) {\n      if (result.prompt) {\n        // Append with a newline separator if parent has a prompt\n        result.prompt = result.prompt + '\\n\\n' + child.appendPrompt;\n      } else {\n        // If no parent prompt, appendPrompt becomes the prompt\n        result.prompt = child.appendPrompt;\n      }\n      // Don't carry forward appendPrompt to avoid re-appending\n      delete result.appendPrompt;\n    }\n\n    if (child.exec !== undefined) result.exec = child.exec;\n    if (child.stdin !== undefined) result.stdin = child.stdin;\n    if (child.url !== undefined) result.url = child.url;\n    if (child.focus !== undefined) result.focus = child.focus;\n    if (child.command !== undefined) result.command = child.command;\n    if (child.ai_model !== undefined) result.ai_model = child.ai_model;\n    if (child.ai_provider !== undefined) result.ai_provider = child.ai_provider;\n    if (child.group !== undefined) result.group = child.group;\n    if (child.schema !== undefined) result.schema = child.schema;\n    if (child.if !== undefined) result.if = child.if;\n    if (child.reuse_ai_session !== undefined) result.reuse_ai_session = child.reuse_ai_session;\n    if (child.fail_if !== undefined) result.fail_if = child.fail_if;\n    if (child.failure_conditions !== undefined)\n      result.failure_conditions = child.failure_conditions;\n\n    // Special handling for 'on' array\n    if (child.on !== undefined) {\n      if (Array.isArray(child.on) && child.on.length === 0) {\n        // Empty array disables the check\n        result.on = [];\n      } else {\n        // Replace parent's on array\n        result.on = [...child.on];\n      }\n    }\n\n    // Default 'on' to ['manual'] if still not specified\n    if (!result.on) {\n      result.on = ['manual'];\n    }\n\n    // Arrays that get replaced (not concatenated)\n    if (child.triggers !== undefined) {\n      result.triggers = child.triggers ? [...child.triggers] : undefined;\n    }\n    if (child.depends_on !== undefined) {\n      result.depends_on = child.depends_on ? [...child.depends_on] : undefined;\n    }\n\n    // Deep merge objects\n    if (child.env) {\n      result.env = this.mergeObjects(\n        (parent.env || {}) as Record<string, any>,\n        child.env as Record<string, any>\n      );\n    }\n    if (child.ai) {\n      result.ai = this.mergeObjects(\n        (parent.ai || {}) as Record<string, any>,\n        child.ai as Record<string, any>\n      );\n    }\n    if (child.template) {\n      result.template = this.mergeObjects(\n        (parent.template || {}) as Record<string, any>,\n        child.template as Record<string, any>\n      );\n    }\n\n    return result;\n  }\n\n  /**\n   * Check if a check is disabled (has empty 'on' array)\n   */\n  public isCheckDisabled(check: CheckConfig): boolean {\n    return Array.isArray(check.on) && check.on.length === 0;\n  }\n\n  /**\n   * Remove disabled checks from the configuration\n   */\n  public removeDisabledChecks(config: Partial<VisorConfig>): Partial<VisorConfig> {\n    if (!config.checks) return config;\n\n    const result = this.deepCopy(config);\n    const enabledChecks: Record<string, CheckConfig> = {};\n\n    for (const [checkName, checkConfig] of Object.entries(result.checks!)) {\n      if (!this.isCheckDisabled(checkConfig)) {\n        enabledChecks[checkName] = checkConfig;\n      } else {\n        console.log(`‚ÑπÔ∏è  Check '${checkName}' is disabled (empty 'on' array)`);\n      }\n    }\n\n    result.checks = enabledChecks;\n    return result;\n  }\n}\n","// AUTO-GENERATED FILE. DO NOT EDIT.\n// Generated by scripts/generate-config-schema.js from src/types/config.ts\nexport const configSchema = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  $ref: '#/definitions/VisorConfigSchema',\n  definitions: {\n    VisorConfigSchema: {\n      type: 'object',\n      additionalProperties: false,\n      properties: {\n        hooks: {\n          $ref: '#/definitions/Record%3Cstring%2Cunknown%3E',\n        },\n        version: {\n          type: 'string',\n          description: 'Configuration version',\n        },\n        extends: {\n          anyOf: [\n            {\n              type: 'string',\n            },\n            {\n              type: 'array',\n              items: {\n                type: 'string',\n              },\n            },\n          ],\n          description:\n            'Extends from other configurations - can be file path, HTTP(S) URL, or \"default\"',\n        },\n        include: {\n          anyOf: [\n            {\n              type: 'string',\n            },\n            {\n              type: 'array',\n              items: {\n                type: 'string',\n              },\n            },\n          ],\n          description:\n            'Alias for extends - include from other configurations (backward compatibility)',\n        },\n        tools: {\n          $ref: '#/definitions/Record%3Cstring%2CCustomToolDefinition%3E',\n          description: 'Custom tool definitions that can be used in MCP blocks',\n        },\n        imports: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description: 'Import workflow definitions from external files or URLs',\n        },\n        steps: {\n          $ref: '#/definitions/Record%3Cstring%2CCheckConfig%3E',\n          description: 'Step configurations (recommended)',\n        },\n        checks: {\n          $ref: '#/definitions/Record%3Cstring%2CCheckConfig%3E',\n          description:\n            \"Check configurations (legacy, use 'steps' instead) - always populated after normalization\",\n        },\n        output: {\n          $ref: '#/definitions/OutputConfig',\n          description: 'Output configuration',\n        },\n        http_server: {\n          $ref: '#/definitions/HttpServerConfig',\n          description: 'HTTP server configuration for receiving webhooks',\n        },\n        memory: {\n          $ref: '#/definitions/MemoryConfig',\n          description: 'Memory storage configuration',\n        },\n        env: {\n          $ref: '#/definitions/EnvConfig',\n          description: 'Global environment variables',\n        },\n        ai_model: {\n          type: 'string',\n          description: 'Global AI model setting',\n        },\n        ai_provider: {\n          type: 'string',\n          description: 'Global AI provider setting',\n        },\n        ai_mcp_servers: {\n          $ref: '#/definitions/Record%3Cstring%2CMcpServerConfig%3E',\n          description: 'Global MCP servers configuration for AI checks',\n        },\n        max_parallelism: {\n          type: 'number',\n          description: 'Maximum number of checks to run in parallel (default: 3)',\n        },\n        fail_fast: {\n          type: 'boolean',\n          description: 'Stop execution when any check fails (default: false)',\n        },\n        fail_if: {\n          type: 'string',\n          description: 'Simple global fail condition - fails if expression evaluates to true',\n        },\n        failure_conditions: {\n          $ref: '#/definitions/FailureConditions',\n          description: 'Global failure conditions - optional (deprecated, use fail_if)',\n        },\n        tag_filter: {\n          $ref: '#/definitions/TagFilter',\n          description: 'Tag filter for selective check execution',\n        },\n        routing: {\n          $ref: '#/definitions/RoutingDefaults',\n          description: 'Optional routing defaults for retry/goto/run policies',\n        },\n        limits: {\n          $ref: '#/definitions/LimitsConfig',\n          description: 'Global execution limits',\n        },\n      },\n      required: ['output', 'version'],\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    'Record<string,unknown>': {\n      type: 'object',\n      additionalProperties: {},\n    },\n    'Record<string,CustomToolDefinition>': {\n      type: 'object',\n      additionalProperties: {\n        $ref: '#/definitions/CustomToolDefinition',\n      },\n    },\n    CustomToolDefinition: {\n      type: 'object',\n      properties: {\n        name: {\n          type: 'string',\n          description: 'Tool name - used to reference the tool in MCP blocks',\n        },\n        description: {\n          type: 'string',\n          description: 'Description of what the tool does',\n        },\n        inputSchema: {\n          type: 'object',\n          properties: {\n            type: {\n              type: 'string',\n              const: 'object',\n            },\n            properties: {\n              $ref: '#/definitions/Record%3Cstring%2Cunknown%3E',\n            },\n            required: {\n              type: 'array',\n              items: {\n                type: 'string',\n              },\n            },\n            additionalProperties: {\n              type: 'boolean',\n            },\n          },\n          required: ['type'],\n          additionalProperties: false,\n          description: 'Input schema for the tool (JSON Schema format)',\n          patternProperties: {\n            '^x-': {},\n          },\n        },\n        exec: {\n          type: 'string',\n          description: 'Command to execute - supports Liquid template',\n        },\n        stdin: {\n          type: 'string',\n          description: 'Optional stdin input - supports Liquid template',\n        },\n        transform: {\n          type: 'string',\n          description: 'Transform the raw output - supports Liquid template',\n        },\n        transform_js: {\n          type: 'string',\n          description: 'Transform the output using JavaScript - alternative to transform',\n        },\n        cwd: {\n          type: 'string',\n          description: 'Working directory for command execution',\n        },\n        env: {\n          $ref: '#/definitions/Record%3Cstring%2Cstring%3E',\n          description: 'Environment variables for the command',\n        },\n        timeout: {\n          type: 'number',\n          description: 'Timeout in milliseconds',\n        },\n        parseJson: {\n          type: 'boolean',\n          description: 'Whether to parse output as JSON automatically',\n        },\n        outputSchema: {\n          $ref: '#/definitions/Record%3Cstring%2Cunknown%3E',\n          description: 'Expected output schema for validation',\n        },\n      },\n      required: ['name', 'exec'],\n      additionalProperties: false,\n      description: 'Custom tool definition for use in MCP blocks',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    'Record<string,string>': {\n      type: 'object',\n      additionalProperties: {\n        type: 'string',\n      },\n    },\n    'Record<string,CheckConfig>': {\n      type: 'object',\n      additionalProperties: {\n        $ref: '#/definitions/CheckConfig',\n      },\n    },\n    CheckConfig: {\n      type: 'object',\n      properties: {\n        type: {\n          $ref: '#/definitions/ConfigCheckType',\n          description: \"Type of check to perform (defaults to 'ai' if not specified)\",\n        },\n        prompt: {\n          type: 'string',\n          description:\n            'AI prompt for the check - can be inline string or file path (auto-detected) - required for AI checks',\n        },\n        appendPrompt: {\n          type: 'string',\n          description:\n            'Additional prompt to append when extending configurations - merged with parent prompt',\n        },\n        exec: {\n          type: 'string',\n          description:\n            'Command execution with Liquid template support - required for command checks',\n        },\n        stdin: {\n          type: 'string',\n          description:\n            'Stdin input for tools with Liquid template support - optional for tool checks',\n        },\n        url: {\n          type: 'string',\n          description: 'HTTP URL - required for http output checks',\n        },\n        body: {\n          type: 'string',\n          description: 'HTTP body template (Liquid) - required for http output checks',\n        },\n        method: {\n          type: 'string',\n          description: 'HTTP method (defaults to POST)',\n        },\n        headers: {\n          $ref: '#/definitions/Record%3Cstring%2Cstring%3E',\n          description: 'HTTP headers',\n        },\n        endpoint: {\n          type: 'string',\n          description: 'HTTP endpoint path - required for http_input checks',\n        },\n        transform: {\n          type: 'string',\n          description: 'Transform template for http_input data (Liquid) - optional',\n        },\n        transform_js: {\n          type: 'string',\n          description:\n            'Transform using JavaScript expressions (evaluated in secure sandbox) - optional',\n        },\n        content: {\n          type: 'string',\n          description: 'Script content to execute for script checks',\n        },\n        schedule: {\n          type: 'string',\n          description: 'Cron schedule expression (e.g., \"0 2 * * *\") - optional for any check type',\n        },\n        focus: {\n          type: 'string',\n          description:\n            'Focus area for the check (security/performance/style/architecture/all) - optional',\n        },\n        command: {\n          type: 'string',\n          description:\n            'Command that triggers this check (e.g., \"review\", \"security-scan\") - optional',\n        },\n        on: {\n          type: 'array',\n          items: {\n            $ref: '#/definitions/EventTrigger',\n          },\n          description: \"Events that trigger this check (defaults to ['manual'] if not specified)\",\n        },\n        triggers: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description: 'File patterns that trigger this check (optional)',\n        },\n        ai: {\n          $ref: '#/definitions/AIProviderConfig',\n          description: 'AI provider configuration (optional)',\n        },\n        ai_model: {\n          type: 'string',\n          description: 'AI model to use for this check - overrides global setting',\n        },\n        ai_provider: {\n          type: 'string',\n          description: 'AI provider to use for this check - overrides global setting',\n        },\n        ai_persona: {\n          type: 'string',\n          description: \"Optional persona hint, prepended to the prompt as 'Persona: <value>'\",\n        },\n        ai_prompt_type: {\n          type: 'string',\n          description: 'Probe promptType for this check (underscore style)',\n        },\n        ai_system_prompt: {\n          type: 'string',\n          description: 'System prompt for this check (underscore style)',\n        },\n        ai_custom_prompt: {\n          type: 'string',\n          description: 'Legacy customPrompt (underscore style) ‚Äî deprecated, use ai_system_prompt',\n        },\n        ai_mcp_servers: {\n          $ref: '#/definitions/Record%3Cstring%2CMcpServerConfig%3E',\n          description: 'MCP servers for this AI check - overrides global setting',\n        },\n        claude_code: {\n          $ref: '#/definitions/ClaudeCodeConfig',\n          description: 'Claude Code configuration (for claude-code type checks)',\n        },\n        env: {\n          $ref: '#/definitions/EnvConfig',\n          description: 'Environment variables for this check',\n        },\n        timeout: {\n          type: 'number',\n          description: 'Timeout in seconds for command execution (default: 60)',\n        },\n        depends_on: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description: 'Check IDs that this check depends on (optional)',\n        },\n        group: {\n          type: 'string',\n          description:\n            'Group name for comment separation (e.g., \"code-review\", \"pr-overview\") - optional',\n        },\n        schema: {\n          anyOf: [\n            {\n              type: 'string',\n            },\n            {\n              $ref: '#/definitions/Record%3Cstring%2Cunknown%3E',\n            },\n          ],\n          description:\n            'Schema type for template rendering (e.g., \"code-review\", \"markdown\") or inline JSON schema object - optional',\n        },\n        template: {\n          $ref: '#/definitions/CustomTemplateConfig',\n          description: 'Custom template configuration - optional',\n        },\n        if: {\n          type: 'string',\n          description:\n            'Condition to determine if check should run - runs if expression evaluates to true',\n        },\n        reuse_ai_session: {\n          type: ['string', 'boolean'],\n          description:\n            'Check name to reuse AI session from, or true to use first dependency (only works with depends_on)',\n        },\n        session_mode: {\n          type: 'string',\n          enum: ['clone', 'append'],\n          description:\n            \"How to reuse AI session: 'clone' (default, copy history) or 'append' (share history)\",\n        },\n        fail_if: {\n          type: 'string',\n          description: 'Simple fail condition - fails check if expression evaluates to true',\n        },\n        failure_conditions: {\n          $ref: '#/definitions/FailureConditions',\n          description: 'Check-specific failure conditions - optional (deprecated, use fail_if)',\n        },\n        tags: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description:\n            'Tags for categorizing and filtering checks (e.g., [\"local\", \"fast\", \"security\"])',\n        },\n        continue_on_failure: {\n          type: 'boolean',\n          description:\n            \"Allow dependents to run even if this step fails. Defaults to false (dependents are gated when this step fails). Similar to GitHub Actions' continue-on-error.\",\n        },\n        forEach: {\n          type: 'boolean',\n          description: 'Process output as array and run dependent checks for each item',\n        },\n        fanout: {\n          type: 'string',\n          enum: ['map', 'reduce'],\n          description:\n            \"Control scheduling behavior when this check is triggered via routing (run/goto) from a forEach scope.\\n- 'map': schedule once per item (fan-out) using item scopes.\\n- 'reduce': schedule a single run at the parent scope (aggregation). If unset, the current default is a single run (reduce) for backward compatibility.\",\n        },\n        reduce: {\n          type: 'boolean',\n          description: \"Alias for fanout: 'reduce'\",\n        },\n        on_fail: {\n          $ref: '#/definitions/OnFailConfig',\n          description: 'Failure routing configuration for this check (retry/goto/run)',\n        },\n        on_success: {\n          $ref: '#/definitions/OnSuccessConfig',\n          description:\n            'Success routing configuration for this check (post-actions and optional goto)',\n        },\n        on_finish: {\n          $ref: '#/definitions/OnFinishConfig',\n          description:\n            'Finish routing configuration for forEach checks (runs after ALL iterations complete)',\n        },\n        max_runs: {\n          type: 'number',\n          description:\n            'Hard cap on how many times this check may execute within a single engine run. Overrides global limits.max_runs_per_check. Set to 0 or negative to disable for this step.',\n        },\n        message: {\n          type: 'string',\n          description: 'Message template for log checks',\n        },\n        level: {\n          type: 'string',\n          enum: ['debug', 'info', 'warn', 'error'],\n          description: 'Log level for log checks',\n        },\n        include_pr_context: {\n          type: 'boolean',\n          description: 'Include PR context in log output',\n        },\n        include_dependencies: {\n          type: 'boolean',\n          description: 'Include dependency summaries in log output',\n        },\n        include_metadata: {\n          type: 'boolean',\n          description: 'Include execution metadata in log output',\n        },\n        output_format: {\n          type: 'string',\n          enum: ['json', 'text'],\n          description:\n            \"Output parsing hint for command provider (optional) When set to 'json', command stdout is expected to be JSON. When 'text', treat as plain text. Note: command provider attempts JSON parsing heuristically; this flag mainly suppresses schema warnings and may be used by providers to alter parsing behavior in the future.\",\n        },\n        operation: {\n          type: 'string',\n          enum: ['get', 'set', 'append', 'increment', 'delete', 'clear', 'list'],\n          description: \"Memory operation to perform. Use `type: 'script'` for custom JavaScript.\",\n        },\n        key: {\n          type: 'string',\n          description: 'Key for memory operation',\n        },\n        value: {\n          description: 'Value for set/append operations',\n        },\n        value_js: {\n          type: 'string',\n          description: 'JavaScript expression to compute value dynamically',\n        },\n        namespace: {\n          type: 'string',\n          description: 'Override namespace for this check',\n        },\n        op: {\n          type: 'string',\n          description:\n            \"GitHub operation to perform (e.g., 'labels.add', 'labels.remove', 'comment.create')\",\n        },\n        values: {\n          anyOf: [\n            {\n              type: 'array',\n              items: {\n                type: 'string',\n              },\n            },\n            {\n              type: 'string',\n            },\n          ],\n          description: 'Values for GitHub operations (can be array or single value)',\n        },\n        transport: {\n          type: 'string',\n          enum: ['stdio', 'sse', 'http'],\n          description:\n            'Transport type for MCP: stdio (default), sse (legacy), or http (streamable HTTP)',\n        },\n        methodArgs: {\n          $ref: '#/definitions/Record%3Cstring%2Cunknown%3E',\n          description: 'Arguments to pass to the MCP method (supports Liquid templates)',\n        },\n        argsTransform: {\n          type: 'string',\n          description: 'Transform template for method arguments (Liquid)',\n        },\n        sessionId: {\n          type: 'string',\n          description: 'Session ID for HTTP transport (optional, server may generate one)',\n        },\n        command_args: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description: 'Command arguments (for stdio transport in MCP checks)',\n        },\n        workingDirectory: {\n          type: 'string',\n          description: 'Working directory (for stdio transport in MCP checks)',\n        },\n        placeholder: {\n          type: 'string',\n          description: 'Placeholder text to show in input field',\n        },\n        allow_empty: {\n          type: 'boolean',\n          description: 'Allow empty input (default: false)',\n        },\n        multiline: {\n          type: 'boolean',\n          description: 'Support multiline input (default: false)',\n        },\n        default: {\n          type: 'string',\n          description: 'Default value if timeout occurs or empty input when allow_empty is true',\n        },\n        workflow: {\n          type: 'string',\n          description: 'Workflow ID or path to workflow file',\n        },\n        args: {\n          $ref: '#/definitions/Record%3Cstring%2Cunknown%3E',\n          description: 'Arguments/inputs for the workflow',\n        },\n        overrides: {\n          $ref: '#/definitions/Record%3Cstring%2CPartial%3Cinterface-src_types_config.ts-10692-19410-src_types_config.ts-0-31513%3E%3E',\n          description: 'Override specific step configurations in the workflow',\n        },\n        output_mapping: {\n          $ref: '#/definitions/Record%3Cstring%2Cstring%3E',\n          description: 'Map workflow outputs to check outputs',\n        },\n      },\n      additionalProperties: false,\n      description: 'Configuration for a single check',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    ConfigCheckType: {\n      type: 'string',\n      enum: [\n        'ai',\n        'command',\n        'script',\n        'http',\n        'http_input',\n        'http_client',\n        'noop',\n        'log',\n        'memory',\n        'github',\n        'claude-code',\n        'mcp',\n        'human-input',\n        'workflow',\n      ],\n      description: 'Valid check types in configuration',\n    },\n    EventTrigger: {\n      type: 'string',\n      enum: [\n        'pr_opened',\n        'pr_updated',\n        'pr_closed',\n        'issue_opened',\n        'issue_comment',\n        'manual',\n        'schedule',\n        'webhook_received',\n      ],\n      description: 'Valid event triggers for checks',\n    },\n    AIProviderConfig: {\n      type: 'object',\n      properties: {\n        provider: {\n          type: 'string',\n          enum: ['google', 'anthropic', 'openai', 'bedrock', 'mock'],\n          description: 'AI provider to use',\n        },\n        model: {\n          type: 'string',\n          description: 'Model name to use',\n        },\n        apiKey: {\n          type: 'string',\n          description: 'API key (usually from environment variables)',\n        },\n        timeout: {\n          type: 'number',\n          description: 'Request timeout in milliseconds',\n        },\n        debug: {\n          type: 'boolean',\n          description: 'Enable debug mode',\n        },\n        prompt_type: {\n          type: 'string',\n          description: 'Probe promptType to use (e.g., engineer, code-review, architect)',\n        },\n        system_prompt: {\n          type: 'string',\n          description: 'System prompt (baseline preamble). Replaces legacy custom_prompt.',\n        },\n        custom_prompt: {\n          type: 'string',\n          description:\n            'Probe customPrompt (baseline/system prompt) ‚Äî deprecated, use system_prompt',\n        },\n        skip_code_context: {\n          type: 'boolean',\n          description: 'Skip adding code context (diffs, files, PR info) to the prompt',\n        },\n        mcpServers: {\n          $ref: '#/definitions/Record%3Cstring%2CMcpServerConfig%3E',\n          description: 'MCP servers configuration',\n        },\n        enableDelegate: {\n          type: 'boolean',\n          description: 'Enable the delegate tool for task distribution to subagents',\n        },\n        retry: {\n          $ref: '#/definitions/AIRetryConfig',\n          description: 'Retry configuration for this provider',\n        },\n        fallback: {\n          $ref: '#/definitions/AIFallbackConfig',\n          description: 'Fallback configuration for provider failures',\n        },\n        allowEdit: {\n          type: 'boolean',\n          description:\n            'Enable Edit and Create tools for file modification (disabled by default for security)',\n        },\n        allowedTools: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description:\n            'Filter allowed tools - supports whitelist, exclusion (!prefix), or raw AI mode (empty array)',\n        },\n        disableTools: {\n          type: 'boolean',\n          description: 'Disable all tools for raw AI mode (alternative to allowedTools: [])',\n        },\n        allowBash: {\n          type: 'boolean',\n          description: 'Enable bash command execution (shorthand for bashConfig.enabled)',\n        },\n        bashConfig: {\n          $ref: '#/definitions/BashConfig',\n          description: 'Advanced bash command execution configuration',\n        },\n      },\n      additionalProperties: false,\n      description: 'AI provider configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    'Record<string,McpServerConfig>': {\n      type: 'object',\n      additionalProperties: {\n        $ref: '#/definitions/McpServerConfig',\n      },\n    },\n    McpServerConfig: {\n      type: 'object',\n      properties: {\n        command: {\n          type: 'string',\n          description: 'Command to execute for the MCP server',\n        },\n        args: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description: 'Arguments to pass to the command',\n        },\n        env: {\n          $ref: '#/definitions/Record%3Cstring%2Cstring%3E',\n          description: 'Environment variables for the MCP server',\n        },\n      },\n      required: ['command'],\n      additionalProperties: false,\n      description: 'MCP Server configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    AIRetryConfig: {\n      type: 'object',\n      properties: {\n        maxRetries: {\n          type: 'number',\n          description: 'Maximum retry attempts (0-50)',\n        },\n        initialDelay: {\n          type: 'number',\n          description: 'Initial delay in milliseconds (0-60000)',\n        },\n        maxDelay: {\n          type: 'number',\n          description: 'Maximum delay cap in milliseconds (0-300000)',\n        },\n        backoffFactor: {\n          type: 'number',\n          description: 'Exponential backoff multiplier (1-10)',\n        },\n        retryableErrors: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description: 'Custom error patterns to retry on',\n        },\n      },\n      additionalProperties: false,\n      description: 'Retry configuration for AI provider calls',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    AIFallbackConfig: {\n      type: 'object',\n      properties: {\n        strategy: {\n          type: 'string',\n          enum: ['same-model', 'same-provider', 'any', 'custom'],\n          description: \"Fallback strategy: 'same-model', 'same-provider', 'any', or 'custom'\",\n        },\n        providers: {\n          type: 'array',\n          items: {\n            $ref: '#/definitions/AIFallbackProviderConfig',\n          },\n          description: 'Array of fallback provider configurations',\n        },\n        maxTotalAttempts: {\n          type: 'number',\n          description: 'Maximum total attempts across all providers',\n        },\n        auto: {\n          type: 'boolean',\n          description: 'Enable automatic fallback using available environment variables',\n        },\n      },\n      additionalProperties: false,\n      description: 'Fallback configuration for AI providers',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    AIFallbackProviderConfig: {\n      type: 'object',\n      properties: {\n        provider: {\n          type: 'string',\n          enum: ['google', 'anthropic', 'openai', 'bedrock'],\n          description: 'AI provider to use',\n        },\n        model: {\n          type: 'string',\n          description: 'Model name to use',\n        },\n        apiKey: {\n          type: 'string',\n          description: 'API key for this provider',\n        },\n        maxRetries: {\n          type: 'number',\n          description: 'Per-provider retry override',\n        },\n        region: {\n          type: 'string',\n          description: 'AWS region (for Bedrock)',\n        },\n        accessKeyId: {\n          type: 'string',\n          description: 'AWS access key ID (for Bedrock)',\n        },\n        secretAccessKey: {\n          type: 'string',\n          description: 'AWS secret access key (for Bedrock)',\n        },\n      },\n      required: ['provider', 'model'],\n      additionalProperties: false,\n      description: 'Fallback provider configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    BashConfig: {\n      type: 'object',\n      properties: {\n        allow: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description: \"Array of permitted command patterns (e.g., ['ls', 'git status'])\",\n        },\n        deny: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description: \"Array of blocked command patterns (e.g., ['rm -rf', 'sudo'])\",\n        },\n        noDefaultAllow: {\n          type: 'boolean',\n          description: 'Disable default safe command list (use with caution)',\n        },\n        noDefaultDeny: {\n          type: 'boolean',\n          description: 'Disable default dangerous command blocklist (use with extreme caution)',\n        },\n        timeout: {\n          type: 'number',\n          description: 'Execution timeout in milliseconds',\n        },\n        workingDirectory: {\n          type: 'string',\n          description: 'Default working directory for command execution',\n        },\n      },\n      additionalProperties: false,\n      description:\n        \"Bash command execution configuration for ProbeAgent Note: Use 'allowBash: true' in AIProviderConfig to enable bash execution\",\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    ClaudeCodeConfig: {\n      type: 'object',\n      properties: {\n        allowedTools: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description: 'List of allowed tools for Claude Code to use',\n        },\n        maxTurns: {\n          type: 'number',\n          description: 'Maximum number of turns in conversation',\n        },\n        systemPrompt: {\n          type: 'string',\n          description: 'System prompt for Claude Code',\n        },\n        mcpServers: {\n          $ref: '#/definitions/Record%3Cstring%2CMcpServerConfig%3E',\n          description: 'MCP servers configuration',\n        },\n        subagent: {\n          type: 'string',\n          description: 'Path to subagent script',\n        },\n        enableDelegate: {\n          type: 'boolean',\n          description: 'Enable the delegate tool for task distribution to subagents',\n        },\n        hooks: {\n          type: 'object',\n          properties: {\n            onStart: {\n              type: 'string',\n              description: 'Called when check starts',\n            },\n            onEnd: {\n              type: 'string',\n              description: 'Called when check ends',\n            },\n            onError: {\n              type: 'string',\n              description: 'Called when check encounters an error',\n            },\n          },\n          additionalProperties: false,\n          description: 'Event hooks for lifecycle management',\n          patternProperties: {\n            '^x-': {},\n          },\n        },\n      },\n      additionalProperties: false,\n      description: 'Claude Code configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    EnvConfig: {\n      type: 'object',\n      additionalProperties: {\n        type: ['string', 'number', 'boolean'],\n      },\n      description: 'Environment variable reference configuration',\n    },\n    CustomTemplateConfig: {\n      type: 'object',\n      properties: {\n        file: {\n          type: 'string',\n          description: 'Path to custom template file (relative to config file or absolute)',\n        },\n        content: {\n          type: 'string',\n          description: 'Raw template content as string',\n        },\n      },\n      additionalProperties: false,\n      description: 'Custom template configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    FailureConditions: {\n      type: 'object',\n      additionalProperties: {\n        $ref: '#/definitions/FailureCondition',\n      },\n      description: 'Collection of failure conditions',\n    },\n    FailureCondition: {\n      anyOf: [\n        {\n          $ref: '#/definitions/SimpleFailureCondition',\n        },\n        {\n          $ref: '#/definitions/ComplexFailureCondition',\n        },\n      ],\n      description: 'Failure condition - can be a simple expression string or complex object',\n    },\n    SimpleFailureCondition: {\n      type: 'string',\n      description: 'Simple failure condition - just an expression string',\n    },\n    ComplexFailureCondition: {\n      type: 'object',\n      properties: {\n        condition: {\n          type: 'string',\n          description: 'Expression to evaluate using Function Constructor',\n        },\n        message: {\n          type: 'string',\n          description: 'Human-readable message when condition is met',\n        },\n        severity: {\n          $ref: '#/definitions/FailureConditionSeverity',\n          description: 'Severity level of the failure',\n        },\n        halt_execution: {\n          type: 'boolean',\n          description: 'Whether this condition should halt execution',\n        },\n      },\n      required: ['condition'],\n      additionalProperties: false,\n      description: 'Complex failure condition with additional metadata',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    FailureConditionSeverity: {\n      type: 'string',\n      enum: ['error', 'warning', 'info'],\n      description: 'Failure condition severity levels',\n    },\n    OnFailConfig: {\n      type: 'object',\n      properties: {\n        retry: {\n          $ref: '#/definitions/RetryPolicy',\n          description: 'Retry policy',\n        },\n        run: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description: 'Remediation steps to run before reattempt',\n        },\n        goto: {\n          type: 'string',\n          description: 'Jump back to an ancestor step (by id)',\n        },\n        goto_event: {\n          $ref: '#/definitions/EventTrigger',\n          description: \"Simulate a different event when performing goto (e.g., 'pr_updated')\",\n        },\n        goto_js: {\n          type: 'string',\n          description: 'Dynamic goto: JS expression returning step id or null',\n        },\n        run_js: {\n          type: 'string',\n          description: 'Dynamic remediation list: JS expression returning string[]',\n        },\n      },\n      additionalProperties: false,\n      description: 'Failure routing configuration per check',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    RetryPolicy: {\n      type: 'object',\n      properties: {\n        max: {\n          type: 'number',\n          description: 'Maximum retry attempts (excluding the first attempt)',\n        },\n        backoff: {\n          $ref: '#/definitions/BackoffPolicy',\n          description: 'Backoff policy',\n        },\n      },\n      additionalProperties: false,\n      description: 'Retry policy for a step',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    BackoffPolicy: {\n      type: 'object',\n      properties: {\n        mode: {\n          type: 'string',\n          enum: ['fixed', 'exponential'],\n          description: 'Backoff mode',\n        },\n        delay_ms: {\n          type: 'number',\n          description: 'Initial delay in milliseconds',\n        },\n      },\n      additionalProperties: false,\n      description: 'Backoff policy for retries',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    OnSuccessConfig: {\n      type: 'object',\n      properties: {\n        run: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description: 'Post-success steps to run',\n        },\n        goto: {\n          type: 'string',\n          description: 'Optional jump back to ancestor step (by id)',\n        },\n        goto_event: {\n          $ref: '#/definitions/EventTrigger',\n          description: \"Simulate a different event when performing goto (e.g., 'pr_updated')\",\n        },\n        goto_js: {\n          type: 'string',\n          description: 'Dynamic goto: JS expression returning step id or null',\n        },\n        run_js: {\n          type: 'string',\n          description: 'Dynamic post-success steps: JS expression returning string[]',\n        },\n      },\n      additionalProperties: false,\n      description: 'Success routing configuration per check',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    OnFinishConfig: {\n      type: 'object',\n      properties: {\n        run: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description: 'Post-finish steps to run',\n        },\n        goto: {\n          type: 'string',\n          description: 'Optional jump back to ancestor step (by id)',\n        },\n        goto_event: {\n          $ref: '#/definitions/EventTrigger',\n          description: \"Simulate a different event when performing goto (e.g., 'pr_updated')\",\n        },\n        goto_js: {\n          type: 'string',\n          description: 'Dynamic goto: JS expression returning step id or null',\n        },\n        run_js: {\n          type: 'string',\n          description: 'Dynamic post-finish steps: JS expression returning string[]',\n        },\n      },\n      additionalProperties: false,\n      description:\n        'Finish routing configuration for forEach checks Runs once after ALL iterations of forEach and ALL dependent checks complete',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    'Record<string,Partial<interface-src_types_config.ts-10692-19410-src_types_config.ts-0-31513>>':\n      {\n        type: 'object',\n        additionalProperties: {\n          $ref: '#/definitions/Partial%3Cinterface-src_types_config.ts-10692-19410-src_types_config.ts-0-31513%3E',\n        },\n      },\n    'Partial<interface-src_types_config.ts-10692-19410-src_types_config.ts-0-31513>': {\n      type: 'object',\n      additionalProperties: false,\n    },\n    OutputConfig: {\n      type: 'object',\n      properties: {\n        pr_comment: {\n          $ref: '#/definitions/PrCommentOutput',\n          description: 'PR comment configuration',\n        },\n        file_comment: {\n          $ref: '#/definitions/FileCommentOutput',\n          description: 'File comment configuration (optional)',\n        },\n        github_checks: {\n          $ref: '#/definitions/GitHubCheckOutput',\n          description: 'GitHub check runs configuration (optional)',\n        },\n        suppressionEnabled: {\n          type: 'boolean',\n          description:\n            'Whether to enable issue suppression via visor-disable comments (default: true)',\n        },\n      },\n      required: ['pr_comment'],\n      additionalProperties: false,\n      description: 'Output configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    PrCommentOutput: {\n      type: 'object',\n      properties: {\n        format: {\n          $ref: '#/definitions/ConfigOutputFormat',\n          description: 'Format of the output',\n        },\n        group_by: {\n          $ref: '#/definitions/GroupByOption',\n          description: 'How to group the results',\n        },\n        collapse: {\n          type: 'boolean',\n          description: 'Whether to collapse sections by default',\n        },\n        debug: {\n          $ref: '#/definitions/DebugConfig',\n          description: 'Debug mode configuration (optional)',\n        },\n      },\n      required: ['format', 'group_by', 'collapse'],\n      additionalProperties: false,\n      description: 'PR comment output configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    ConfigOutputFormat: {\n      type: 'string',\n      enum: ['table', 'json', 'markdown', 'sarif'],\n      description: 'Valid output formats',\n    },\n    GroupByOption: {\n      type: 'string',\n      enum: ['check', 'file', 'severity', 'group'],\n      description: 'Valid grouping options',\n    },\n    DebugConfig: {\n      type: 'object',\n      properties: {\n        enabled: {\n          type: 'boolean',\n          description: 'Enable debug mode',\n        },\n        includePrompts: {\n          type: 'boolean',\n          description: 'Include AI prompts in debug output',\n        },\n        includeRawResponses: {\n          type: 'boolean',\n          description: 'Include raw AI responses in debug output',\n        },\n        includeTiming: {\n          type: 'boolean',\n          description: 'Include timing information',\n        },\n        includeProviderInfo: {\n          type: 'boolean',\n          description: 'Include provider information',\n        },\n      },\n      required: [\n        'enabled',\n        'includePrompts',\n        'includeRawResponses',\n        'includeTiming',\n        'includeProviderInfo',\n      ],\n      additionalProperties: false,\n      description: 'Debug mode configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    FileCommentOutput: {\n      type: 'object',\n      properties: {\n        enabled: {\n          type: 'boolean',\n          description: 'Whether file comments are enabled',\n        },\n        inline: {\n          type: 'boolean',\n          description: 'Whether to show inline comments',\n        },\n      },\n      required: ['enabled', 'inline'],\n      additionalProperties: false,\n      description: 'File comment output configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    GitHubCheckOutput: {\n      type: 'object',\n      properties: {\n        enabled: {\n          type: 'boolean',\n          description: 'Whether GitHub check runs are enabled',\n        },\n        per_check: {\n          type: 'boolean',\n          description: 'Whether to create individual check runs per configured check',\n        },\n        name_prefix: {\n          type: 'string',\n          description: 'Custom name prefix for check runs',\n        },\n      },\n      required: ['enabled', 'per_check'],\n      additionalProperties: false,\n      description: 'GitHub Check Runs output configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    HttpServerConfig: {\n      type: 'object',\n      properties: {\n        enabled: {\n          type: 'boolean',\n          description: 'Whether HTTP server is enabled',\n        },\n        port: {\n          type: 'number',\n          description: 'Port to listen on',\n        },\n        host: {\n          type: 'string',\n          description: 'Host/IP to bind to (defaults to 0.0.0.0)',\n        },\n        tls: {\n          $ref: '#/definitions/TlsConfig',\n          description: 'TLS/SSL configuration for HTTPS',\n        },\n        auth: {\n          $ref: '#/definitions/HttpAuthConfig',\n          description: 'Authentication configuration',\n        },\n        endpoints: {\n          type: 'array',\n          items: {\n            $ref: '#/definitions/HttpEndpointConfig',\n          },\n          description: 'HTTP endpoints configuration',\n        },\n      },\n      required: ['enabled', 'port'],\n      additionalProperties: false,\n      description: 'HTTP server configuration for receiving webhooks',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    TlsConfig: {\n      type: 'object',\n      properties: {\n        enabled: {\n          type: 'boolean',\n          description: 'Enable TLS/HTTPS',\n        },\n        cert: {\n          type: 'string',\n          description: 'Path to TLS certificate file or certificate content',\n        },\n        key: {\n          type: 'string',\n          description: 'Path to TLS key file or key content',\n        },\n        ca: {\n          type: 'string',\n          description: 'Path to CA certificate file or CA content (optional)',\n        },\n        rejectUnauthorized: {\n          type: 'boolean',\n          description: 'Reject unauthorized connections (default: true)',\n        },\n      },\n      required: ['enabled'],\n      additionalProperties: false,\n      description: 'TLS/SSL configuration for HTTPS server',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    HttpAuthConfig: {\n      type: 'object',\n      properties: {\n        type: {\n          type: 'string',\n          enum: ['bearer_token', 'hmac', 'basic', 'none'],\n          description: 'Authentication type',\n        },\n        secret: {\n          type: 'string',\n          description: 'Secret or token for authentication',\n        },\n        username: {\n          type: 'string',\n          description: 'Username for basic auth',\n        },\n        password: {\n          type: 'string',\n          description: 'Password for basic auth',\n        },\n      },\n      required: ['type'],\n      additionalProperties: false,\n      description: 'HTTP server authentication configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    HttpEndpointConfig: {\n      type: 'object',\n      properties: {\n        path: {\n          type: 'string',\n          description: 'Path for the webhook endpoint',\n        },\n        transform: {\n          type: 'string',\n          description: 'Optional transform template (Liquid) for the received data',\n        },\n        name: {\n          type: 'string',\n          description: 'Optional name/ID for this endpoint',\n        },\n      },\n      required: ['path'],\n      additionalProperties: false,\n      description: 'HTTP server endpoint configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    MemoryConfig: {\n      type: 'object',\n      properties: {\n        storage: {\n          type: 'string',\n          enum: ['memory', 'file'],\n          description: 'Storage mode: \"memory\" (in-memory, default) or \"file\" (persistent)',\n        },\n        format: {\n          type: 'string',\n          enum: ['json', 'csv'],\n          description: 'Storage format (only for file storage, default: json)',\n        },\n        file: {\n          type: 'string',\n          description: 'File path (required if storage: file)',\n        },\n        namespace: {\n          type: 'string',\n          description: 'Default namespace (default: \"default\")',\n        },\n        auto_load: {\n          type: 'boolean',\n          description: 'Auto-load on startup (default: true if storage: file)',\n        },\n        auto_save: {\n          type: 'boolean',\n          description: 'Auto-save after operations (default: true if storage: file)',\n        },\n      },\n      additionalProperties: false,\n      description: 'Memory storage configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    TagFilter: {\n      type: 'object',\n      properties: {\n        include: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description: 'Tags that checks must have to be included (ANY match)',\n        },\n        exclude: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description: 'Tags that will exclude checks if present (ANY match)',\n        },\n      },\n      additionalProperties: false,\n      description: 'Tag filter configuration for selective check execution',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    RoutingDefaults: {\n      type: 'object',\n      properties: {\n        max_loops: {\n          type: 'number',\n          description: 'Per-scope cap on routing transitions (success + failure)',\n        },\n        defaults: {\n          type: 'object',\n          properties: {\n            on_fail: {\n              $ref: '#/definitions/OnFailConfig',\n            },\n          },\n          additionalProperties: false,\n          description: 'Default policies applied to checks (step-level overrides take precedence)',\n          patternProperties: {\n            '^x-': {},\n          },\n        },\n      },\n      additionalProperties: false,\n      description: 'Global routing defaults',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    LimitsConfig: {\n      type: 'object',\n      properties: {\n        max_runs_per_check: {\n          type: 'number',\n          description:\n            'Maximum number of executions per check within a single engine run. Applies to each distinct scope independently for forEach item executions. Set to 0 or negative to disable. Default: 50.',\n        },\n      },\n      additionalProperties: false,\n      description: 'Global engine limits',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n  },\n} as const;\nexport default configSchema;\n","/*\n Thin SDK fa√ßade for programmatic use of Visor.\n - No new execution logic; delegates to existing engine and config manager.\n - Dual ESM/CJS bundle via tsup.\n*/\n\nimport { CheckExecutionEngine } from './check-execution-engine';\nimport { ConfigManager } from './config';\nimport type { AnalysisResult } from './output-formatters';\nimport type { VisorConfig, TagFilter, HumanInputRequest } from './types/config';\nimport type { ExecutionContext } from './providers/check-provider.interface';\n\nexport type { VisorConfig, TagFilter, HumanInputRequest, ExecutionContext };\n\nexport interface VisorOptions {\n  cwd?: string;\n  debug?: boolean;\n  maxParallelism?: number;\n  failFast?: boolean;\n  tagFilter?: TagFilter;\n}\n\nexport interface RunOptions extends VisorOptions {\n  config?: VisorConfig;\n  configPath?: string;\n  checks?: string[]; // default: all checks from config\n  timeoutMs?: number;\n  output?: { format?: 'table' | 'json' | 'markdown' | 'sarif' };\n  /** Strict mode: treat config warnings (like unknown keys) as errors (default: false) */\n  strictValidation?: boolean;\n  /** Execution context for providers (CLI message, hooks, etc.) */\n  executionContext?: ExecutionContext;\n}\n\n/**\n * Load and validate a Visor config.\n * @param configOrPath - Config object, file path, or omit to discover defaults\n * @param options - Validation options\n * @returns Validated config with defaults applied\n */\nexport async function loadConfig(\n  configOrPath?: string | Partial<VisorConfig>,\n  options?: { strict?: boolean }\n): Promise<VisorConfig> {\n  const cm = new ConfigManager();\n\n  // If it's an object, validate and return with defaults\n  if (typeof configOrPath === 'object' && configOrPath !== null) {\n    cm.validateConfig(configOrPath, options?.strict ?? false);\n\n    // Apply lightweight defaults without expensive file system operations\n    const defaultConfig: Partial<VisorConfig> = {\n      version: '1.0',\n      checks: {},\n      max_parallelism: 3,\n      fail_fast: false,\n    };\n\n    return {\n      ...defaultConfig,\n      ...configOrPath,\n      checks: configOrPath.checks || {},\n    } as VisorConfig;\n  }\n\n  // If it's a string, load from file\n  if (typeof configOrPath === 'string') {\n    return cm.loadConfig(configOrPath);\n  }\n\n  // Otherwise discover default config file\n  return cm.findAndLoadConfig();\n}\n\n/** Expand check IDs by including their dependencies (shallow->deep). */\nexport function resolveChecks(checkIds: string[], config: VisorConfig | undefined): string[] {\n  if (!config?.checks) return Array.from(new Set(checkIds));\n  const resolved = new Set<string>();\n  const visiting = new Set<string>();\n  const result: string[] = [];\n\n  const dfs = (id: string, stack: string[] = []) => {\n    if (resolved.has(id)) return;\n    if (visiting.has(id)) {\n      const cycle = [...stack, id].join(' -> ');\n      throw new Error(`Circular dependency detected involving check: ${id} (path: ${cycle})`);\n    }\n    visiting.add(id);\n    const deps = config.checks![id]?.depends_on || [];\n    for (const d of deps) dfs(d, [...stack, id]);\n    if (!result.includes(id)) result.push(id);\n    visiting.delete(id);\n    resolved.add(id);\n  };\n\n  for (const id of checkIds) dfs(id);\n  return result;\n}\n\n/**\n * Run Visor checks programmatically. Returns the same AnalysisResult shape used by the CLI.\n * Thin wrapper around CheckExecutionEngine.executeChecks.\n */\nexport async function runChecks(opts: RunOptions = {}): Promise<AnalysisResult> {\n  const cm = new ConfigManager();\n  let config: VisorConfig;\n\n  if (opts.config) {\n    // Validate manually constructed config\n    // In strict mode, unknown keys are treated as errors\n    cm.validateConfig(opts.config, opts.strictValidation ?? false);\n    config = opts.config;\n  } else if (opts.configPath) {\n    config = await cm.loadConfig(opts.configPath);\n  } else {\n    config = await cm.findAndLoadConfig();\n  }\n\n  const checks =\n    opts.checks && opts.checks.length > 0\n      ? resolveChecks(opts.checks, config)\n      : Object.keys(config.checks || {});\n\n  const engine = new CheckExecutionEngine(opts.cwd);\n\n  // Set execution context if provided\n  if (opts.executionContext) {\n    engine.setExecutionContext(opts.executionContext);\n  }\n\n  const result = await engine.executeChecks({\n    checks,\n    workingDirectory: opts.cwd,\n    timeout: opts.timeoutMs,\n    maxParallelism: opts.maxParallelism,\n    failFast: opts.failFast,\n    outputFormat: opts.output?.format,\n    config,\n    debug: opts.debug,\n    tagFilter: opts.tagFilter,\n  });\n\n  return result;\n}\n","import * as yaml from 'js-yaml';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { logger } from './logger';\nimport simpleGit from 'simple-git';\nimport {\n  VisorConfig,\n  CheckConfig,\n  ConfigCheckType,\n  EventTrigger,\n  ConfigOutputFormat,\n  GroupByOption,\n  ConfigValidationError,\n  EnvironmentOverrides,\n  MergedConfig,\n  ConfigLoadOptions,\n} from './types/config';\nimport { CliOptions } from './types/cli';\nimport { ConfigLoader, ConfigLoaderOptions } from './utils/config-loader';\nimport { ConfigMerger } from './utils/config-merger';\nimport Ajv from 'ajv';\nimport addFormats from 'ajv-formats';\n\n/**\n * Valid event triggers for checks\n * Exported as a constant to serve as the single source of truth for event validation\n */\nexport const VALID_EVENT_TRIGGERS: readonly EventTrigger[] = [\n  'pr_opened',\n  'pr_updated',\n  'pr_closed',\n  'issue_opened',\n  'issue_comment',\n  'manual',\n  'schedule',\n  'webhook_received',\n] as const;\n\n/**\n * Configuration manager for Visor\n */\nexport class ConfigManager {\n  private validCheckTypes: ConfigCheckType[] = [\n    'ai',\n    'claude-code',\n    'mcp',\n    'command',\n    'script',\n    'http',\n    'http_input',\n    'http_client',\n    'memory',\n    'noop',\n    'log',\n    'github',\n    'human-input',\n    'workflow',\n  ];\n  private validEventTriggers: EventTrigger[] = [...VALID_EVENT_TRIGGERS];\n  private validOutputFormats: ConfigOutputFormat[] = ['table', 'json', 'markdown', 'sarif'];\n  private validGroupByOptions: GroupByOption[] = ['check', 'file', 'severity', 'group'];\n\n  /**\n   * Load configuration from a file\n   */\n  public async loadConfig(\n    configPath: string,\n    options: ConfigLoadOptions = {}\n  ): Promise<VisorConfig> {\n    const { validate = true, mergeDefaults = true, allowedRemotePatterns } = options;\n\n    // Resolve relative paths to absolute paths based on current working directory\n    const resolvedPath = path.isAbsolute(configPath)\n      ? configPath\n      : path.resolve(process.cwd(), configPath);\n\n    try {\n      let configContent: string;\n      try {\n        // Attempt to read directly; if not found or not accessible, an error will be thrown\n        configContent = fs.readFileSync(resolvedPath, 'utf8');\n      } catch (readErr: any) {\n        if (readErr && (readErr.code === 'ENOENT' || readErr.code === 'ENOTDIR')) {\n          throw new Error(`Configuration file not found: ${resolvedPath}`);\n        }\n        throw new Error(\n          `Failed to read configuration file ${resolvedPath}: ${readErr?.message || String(readErr)}`\n        );\n      }\n      let parsedConfig: Partial<VisorConfig>;\n\n      try {\n        parsedConfig = yaml.load(configContent) as Partial<VisorConfig>;\n      } catch (yamlError) {\n        const errorMessage = yamlError instanceof Error ? yamlError.message : String(yamlError);\n        throw new Error(`Invalid YAML syntax in ${resolvedPath}: ${errorMessage}`);\n      }\n\n      if (!parsedConfig || typeof parsedConfig !== 'object') {\n        throw new Error('Configuration file must contain a valid YAML object');\n      }\n\n      // Handle extends/include directive (include is an alias for extends)\n      const extendsValue = parsedConfig.extends || (parsedConfig as any).include;\n      if (extendsValue) {\n        const loaderOptions: ConfigLoaderOptions = {\n          baseDir: path.dirname(resolvedPath),\n          allowRemote: this.isRemoteExtendsAllowed(),\n          maxDepth: 10,\n          allowedRemotePatterns,\n        };\n\n        const loader = new ConfigLoader(loaderOptions);\n        const merger = new ConfigMerger();\n\n        // Process extends/include\n        const extends_ = Array.isArray(extendsValue) ? extendsValue : [extendsValue];\n\n        // Remove extends and include fields from config\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { extends: _, include: __, ...configWithoutExtends } = parsedConfig as any;\n\n        // Load and merge all parent configurations\n        let mergedConfig: Partial<VisorConfig> = {};\n        for (const source of extends_) {\n          console.log(`üì¶ Extending from: ${source}`);\n          const parentConfig = await loader.fetchConfig(source);\n          mergedConfig = merger.merge(mergedConfig, parentConfig);\n        }\n\n        // Merge with current config (child overrides parent)\n        parsedConfig = merger.merge(mergedConfig, configWithoutExtends);\n\n        // Remove disabled checks (those with empty 'on' array)\n        parsedConfig = merger.removeDisabledChecks(parsedConfig);\n      }\n\n      // Check if this is a workflow definition file (has 'id' field indicating it's a workflow)\n      // Do this BEFORE normalizing to avoid copying workflow steps to checks\n      if ((parsedConfig as any).id && typeof (parsedConfig as any).id === 'string') {\n        parsedConfig = await this.convertWorkflowToConfig(parsedConfig, path.dirname(resolvedPath));\n      }\n\n      // Normalize 'checks' and 'steps' - support both keys for backward compatibility\n      parsedConfig = this.normalizeStepsAndChecks(parsedConfig);\n\n      // Load workflows if defined\n      await this.loadWorkflows(parsedConfig, path.dirname(resolvedPath));\n\n      if (validate) {\n        this.validateConfig(parsedConfig);\n      }\n\n      let finalConfig = parsedConfig;\n      if (mergeDefaults) {\n        finalConfig = this.mergeWithDefaults(parsedConfig);\n      }\n\n      return finalConfig as VisorConfig;\n    } catch (error) {\n      if (error instanceof Error) {\n        // Pass through detailed error messages unchanged\n        if (\n          error.message.includes('not found') ||\n          error.message.includes('Invalid YAML') ||\n          error.message.includes('extends') ||\n          error.message.includes('EACCES') ||\n          error.message.includes('EISDIR')\n        ) {\n          throw error;\n        }\n        // Add more context for generic errors\n        if (error.message.includes('ENOENT')) {\n          throw new Error(`Configuration file not found: ${resolvedPath}`);\n        }\n        if (error.message.includes('EPERM')) {\n          throw new Error(`Permission denied reading configuration file: ${resolvedPath}`);\n        }\n        throw new Error(`Failed to read configuration file ${resolvedPath}: ${error.message}`);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Find and load configuration from default locations\n   */\n  public async findAndLoadConfig(options: ConfigLoadOptions = {}): Promise<VisorConfig> {\n    // Try to find the git repository root first, fall back to current directory\n    const gitRoot = await this.findGitRepositoryRoot();\n    const searchDirs = [gitRoot, process.cwd()].filter(Boolean) as string[];\n\n    for (const baseDir of searchDirs) {\n      const candidates = ['visor.yaml', 'visor.yml', '.visor.yaml', '.visor.yml'].map(p =>\n        path.join(baseDir, p)\n      );\n\n      for (const p of candidates) {\n        try {\n          const st = fs.statSync(p);\n          if (!st.isFile()) continue;\n          const isLegacy = path.basename(p).startsWith('.');\n          if (isLegacy) {\n            // Allow legacy dotfile unless strict mode enabled\n            if (process.env.VISOR_STRICT_CONFIG_NAME === 'true') {\n              const rel = path.relative(baseDir, p);\n              throw new Error(\n                `Legacy config detected: ${rel}. Please rename to visor.yaml (or visor.yml).`\n              );\n            }\n            return this.loadConfig(p, options);\n          }\n          return this.loadConfig(p, options);\n        } catch (e: any) {\n          if (e && e.code === 'ENOENT') continue; // try next\n          // Surface unexpected errors\n          if (e) throw e;\n        }\n      }\n    }\n\n    // Try to load bundled default config\n    const bundledConfig = this.loadBundledDefaultConfig();\n    if (bundledConfig) {\n      return bundledConfig;\n    }\n\n    // Return minimal default config if no bundled config found\n    return this.getDefaultConfig();\n  }\n\n  /**\n   * Find the git repository root directory\n   */\n  private async findGitRepositoryRoot(): Promise<string | null> {\n    try {\n      const git = simpleGit();\n      const isRepo = await git.checkIsRepo();\n      if (!isRepo) {\n        return null;\n      }\n\n      // Get the repository root directory\n      const rootDir = await git.revparse(['--show-toplevel']);\n      return rootDir.trim();\n    } catch {\n      // Not in a git repository or git not available\n      return null;\n    }\n  }\n\n  /**\n   * Get default configuration\n   */\n  public async getDefaultConfig(): Promise<VisorConfig> {\n    return {\n      version: '1.0',\n      steps: {},\n      checks: {}, // Keep for backward compatibility\n      max_parallelism: 3,\n      output: {\n        pr_comment: {\n          format: 'markdown',\n          group_by: 'check',\n          collapse: true,\n        },\n      },\n    };\n  }\n\n  /**\n   * Load bundled default configuration from the package\n   */\n  public loadBundledDefaultConfig(): VisorConfig | null {\n    try {\n      // Try different paths to find the bundled default config (support CJS and ESM)\n      const possiblePaths: string[] = [];\n\n      // __dirname is available in CJS; guard for ESM builds\n      if (typeof __dirname !== 'undefined') {\n        // Only support new non-dot filename\n        possiblePaths.push(\n          path.join(__dirname, 'defaults', 'visor.yaml'),\n          path.join(__dirname, '..', 'defaults', 'visor.yaml')\n        );\n      }\n\n      // Try via package root\n      const pkgRoot = this.findPackageRoot();\n      if (pkgRoot) {\n        possiblePaths.push(path.join(pkgRoot, 'defaults', 'visor.yaml'));\n      }\n\n      // GitHub Action environment variable\n      if (process.env.GITHUB_ACTION_PATH) {\n        possiblePaths.push(\n          path.join(process.env.GITHUB_ACTION_PATH, 'defaults', 'visor.yaml'),\n          path.join(process.env.GITHUB_ACTION_PATH, 'dist', 'defaults', 'visor.yaml')\n        );\n      }\n\n      let bundledConfigPath: string | undefined;\n      for (const possiblePath of possiblePaths) {\n        if (fs.existsSync(possiblePath)) {\n          bundledConfigPath = possiblePath;\n          break;\n        }\n      }\n\n      if (bundledConfigPath) {\n        // Always log to stderr to avoid contaminating formatted output\n        console.error(`üì¶ Loading bundled default configuration from ${bundledConfigPath}`);\n        const configContent = fs.readFileSync(bundledConfigPath, 'utf8');\n        let parsedConfig = yaml.load(configContent) as Partial<VisorConfig>;\n\n        if (!parsedConfig || typeof parsedConfig !== 'object') {\n          return null;\n        }\n\n        // Normalize 'checks' and 'steps' for backward compatibility\n        parsedConfig = this.normalizeStepsAndChecks(parsedConfig);\n\n        // Validate and merge with defaults\n        this.validateConfig(parsedConfig);\n        return this.mergeWithDefaults(parsedConfig) as VisorConfig;\n      }\n    } catch (error) {\n      // Silently fail and return null - will fall back to minimal default\n      console.warn(\n        'Failed to load bundled default config:',\n        error instanceof Error ? error.message : String(error)\n      );\n    }\n\n    return null;\n  }\n\n  /**\n   * Find the root directory of the Visor package\n   */\n  private findPackageRoot(): string | null {\n    let currentDir = __dirname;\n\n    // Walk up the directory tree to find package.json\n    while (currentDir !== path.dirname(currentDir)) {\n      const packageJsonPath = path.join(currentDir, 'package.json');\n      if (fs.existsSync(packageJsonPath)) {\n        try {\n          const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));\n          // Check if this is the Visor package\n          if (packageJson.name === '@probelabs/visor') {\n            return currentDir;\n          }\n        } catch {\n          // Continue searching if package.json is invalid\n        }\n      }\n      currentDir = path.dirname(currentDir);\n    }\n\n    return null;\n  }\n\n  /**\n   * Convert a workflow definition file to a visor config\n   * When a workflow YAML is run standalone, register the workflow and use its tests as checks\n   */\n  private async convertWorkflowToConfig(\n    workflowData: any,\n    _basePath: string\n  ): Promise<Partial<VisorConfig>> {\n    const { WorkflowRegistry } = await import('./workflow-registry');\n    const registry = WorkflowRegistry.getInstance();\n\n    // Register the workflow\n    const workflowId = workflowData.id;\n    logger.info(`Detected standalone workflow file: ${workflowId}`);\n\n    // Extract tests before modifying workflowData\n    const tests = workflowData.tests || {};\n\n    // Create a clean workflow definition (without tests)\n    const workflowDefinition = { ...workflowData };\n    delete workflowDefinition.tests;\n\n    // Register the workflow itself\n    const result = registry.register(workflowDefinition, 'standalone', { override: true });\n    if (!result.valid && result.errors) {\n      const errors = result.errors.map(e => `  ${e.path}: ${e.message}`).join('\\n');\n      throw new Error(`Failed to register workflow '${workflowId}':\\n${errors}`);\n    }\n\n    logger.info(`Registered workflow '${workflowId}' for standalone execution`);\n\n    // Create a COMPLETELY NEW visor config with ONLY the test checks\n    // This prevents any workflow fields from leaking into the config\n    const visorConfig: Partial<VisorConfig> = {\n      version: '1.0',\n      steps: tests,\n      checks: tests, // Backward compatibility\n    };\n\n    logger.debug(`Standalone workflow config has ${Object.keys(tests).length} test checks`);\n    logger.debug(`Test check names: ${Object.keys(tests).join(', ')}`);\n    logger.debug(`Config keys after conversion: ${Object.keys(visorConfig).join(', ')}`);\n\n    return visorConfig;\n  }\n\n  /**\n   * Load and register workflows from configuration\n   */\n  private async loadWorkflows(config: Partial<VisorConfig>, basePath: string): Promise<void> {\n    // Only import workflows from external files\n    if (!config.imports || config.imports.length === 0) {\n      return;\n    }\n\n    const { WorkflowRegistry } = await import('./workflow-registry');\n    const registry = WorkflowRegistry.getInstance();\n\n    // Import workflow files\n    for (const source of config.imports) {\n      const results = await registry.import(source, { basePath, validate: true });\n      for (const result of results) {\n        if (!result.valid && result.errors) {\n          const errors = result.errors.map(e => `  ${e.path}: ${e.message}`).join('\\n');\n          throw new Error(`Failed to import workflow from '${source}':\\n${errors}`);\n        }\n      }\n      logger.info(`Imported workflows from: ${source}`);\n    }\n  }\n\n  /**\n   * Normalize 'checks' and 'steps' keys for backward compatibility\n   * Ensures both keys are present and contain the same data\n   */\n  private normalizeStepsAndChecks(config: Partial<VisorConfig>): Partial<VisorConfig> {\n    // If both are present, 'steps' takes precedence\n    if (config.steps && config.checks) {\n      // Use steps as the source of truth\n      config.checks = config.steps;\n    } else if (config.steps && !config.checks) {\n      // Copy steps to checks for internal compatibility\n      config.checks = config.steps;\n    } else if (config.checks && !config.steps) {\n      // Copy checks to steps for forward compatibility\n      config.steps = config.checks;\n    }\n\n    return config;\n  }\n\n  /**\n   * Merge configuration with CLI options\n   */\n  public mergeWithCliOptions(config: Partial<VisorConfig>, cliOptions: CliOptions): MergedConfig {\n    // Apply CLI overrides to the config\n    const mergedConfig = { ...config };\n\n    // Override max_parallelism if specified in CLI\n    if (cliOptions.maxParallelism !== undefined) {\n      mergedConfig.max_parallelism = cliOptions.maxParallelism;\n    }\n\n    // Override fail_fast if specified in CLI\n    if (cliOptions.failFast !== undefined) {\n      mergedConfig.fail_fast = cliOptions.failFast;\n    }\n\n    return {\n      config: mergedConfig,\n      cliChecks: cliOptions.checks || [],\n      cliOutput: cliOptions.output || 'table',\n    };\n  }\n\n  /**\n   * Load configuration with environment variable overrides\n   */\n  public async loadConfigWithEnvOverrides(): Promise<{\n    config?: VisorConfig;\n    environmentOverrides: EnvironmentOverrides;\n  }> {\n    const environmentOverrides: EnvironmentOverrides = {};\n\n    // Check for environment variable overrides\n    if (process.env.VISOR_CONFIG_PATH) {\n      environmentOverrides.configPath = process.env.VISOR_CONFIG_PATH;\n    }\n    if (process.env.VISOR_OUTPUT_FORMAT) {\n      environmentOverrides.outputFormat = process.env.VISOR_OUTPUT_FORMAT;\n    }\n\n    let config: VisorConfig | undefined;\n\n    if (environmentOverrides.configPath) {\n      try {\n        config = await this.loadConfig(environmentOverrides.configPath);\n      } catch {\n        // If environment config fails, fall back to default discovery\n        config = await this.findAndLoadConfig();\n      }\n    } else {\n      config = await this.findAndLoadConfig();\n    }\n\n    return { config, environmentOverrides };\n  }\n\n  /**\n   * Validate configuration against schema\n   * @param config The config to validate\n   * @param strict If true, treat warnings as errors (default: false)\n   */\n  public validateConfig(config: Partial<VisorConfig>, strict = false): void {\n    const errors: ConfigValidationError[] = [];\n    const warnings: ConfigValidationError[] = [];\n\n    // First, run schema-based validation (runtime-generated).\n    // Unknown keys become schema errors (we convert additionalProperties to warnings by default).\n    this.validateWithAjvSchema(config, errors, warnings);\n\n    // Validate required fields\n    if (!config.version) {\n      errors.push({\n        field: 'version',\n        message: 'Missing required field: version',\n      });\n    }\n\n    // Unknown key warnings are produced by Ajv using the pre-generated schema.\n\n    // Validate that either 'checks' or 'steps' is present\n    if (!config.checks && !config.steps) {\n      errors.push({\n        field: 'checks/steps',\n        message:\n          'Missing required field: either \"checks\" or \"steps\" must be defined. \"steps\" is recommended for new configurations.',\n      });\n    }\n\n    // Use normalized checks for validation (both should be present after normalization)\n    const checksToValidate = config.checks || config.steps;\n    if (checksToValidate) {\n      // Validate each check configuration\n      for (const [checkName, checkConfig] of Object.entries(checksToValidate)) {\n        // Default type to 'ai' if not specified\n        if (!checkConfig.type) {\n          checkConfig.type = 'ai';\n        }\n        // 'on' field is optional - if not specified, check can run on any event\n        this.validateCheckConfig(checkName, checkConfig, errors, config);\n\n        // Unknown/typo keys at the check level are produced by Ajv.\n\n        // Validate MCP servers at check-level (basic shape only)\n        if (checkConfig.ai_mcp_servers) {\n          this.validateMcpServersObject(\n            checkConfig.ai_mcp_servers,\n            `checks.${checkName}.ai_mcp_servers`,\n            errors,\n            warnings\n          );\n        }\n        if ((checkConfig as CheckConfig).ai?.mcpServers) {\n          this.validateMcpServersObject(\n            (checkConfig as CheckConfig).ai!.mcpServers as Record<string, unknown>,\n            `checks.${checkName}.ai.mcpServers`,\n            errors,\n            warnings\n          );\n        }\n        // 3) Precedence warning if both are provided\n        if (checkConfig.ai_mcp_servers && (checkConfig as CheckConfig).ai?.mcpServers) {\n          const lower = Object.keys(checkConfig.ai_mcp_servers);\n          const higher = Object.keys((checkConfig as CheckConfig).ai!.mcpServers!);\n          const overridden = lower.filter(k => higher.includes(k));\n          warnings.push({\n            field: `checks.${checkName}.ai.mcpServers`,\n            message:\n              overridden.length > 0\n                ? `Both ai_mcp_servers and ai.mcpServers are set; ai.mcpServers overrides these servers: ${overridden.join(\n                    ', '\n                  )}`\n                : 'Both ai_mcp_servers and ai.mcpServers are set; ai.mcpServers takes precedence for this check.',\n          });\n        }\n\n        // Type-specific guidance for MCP placement to avoid silent ignores\n        try {\n          const anyCheck = checkConfig as unknown as Record<string, unknown>;\n          const aiObj = (anyCheck.ai as Record<string, unknown>) || undefined;\n          const hasBareMcpAtCheck = Object.prototype.hasOwnProperty.call(anyCheck, 'mcpServers');\n          const hasAiMcp = aiObj && Object.prototype.hasOwnProperty.call(aiObj, 'mcpServers');\n          const hasClaudeCodeMcp =\n            anyCheck.claude_code &&\n            typeof anyCheck.claude_code === 'object' &&\n            Object.prototype.hasOwnProperty.call(\n              anyCheck.claude_code as Record<string, unknown>,\n              'mcpServers'\n            );\n\n          if (checkConfig.type === 'ai') {\n            if (hasBareMcpAtCheck) {\n              warnings.push({\n                field: `checks.${checkName}.mcpServers`,\n                message:\n                  \"'mcpServers' at the check root is ignored for type 'ai'. Use 'ai.mcpServers' or 'ai_mcp_servers' instead.\",\n                value: (anyCheck as any).mcpServers,\n              });\n            }\n            if (hasClaudeCodeMcp) {\n              warnings.push({\n                field: `checks.${checkName}.claude_code.mcpServers`,\n                message:\n                  \"'claude_code.mcpServers' is ignored for type 'ai'. Use 'ai.mcpServers' or 'ai_mcp_servers' instead.\",\n              });\n            }\n          }\n\n          if (checkConfig.type === 'claude-code') {\n            if (hasAiMcp || checkConfig.ai_mcp_servers) {\n              warnings.push({\n                field: hasAiMcp\n                  ? `checks.${checkName}.ai.mcpServers`\n                  : `checks.${checkName}.ai_mcp_servers`,\n                message:\n                  \"For type 'claude-code', MCP must be configured under 'claude_code.mcpServers'. 'ai.mcpServers' and 'ai_mcp_servers' are ignored for this check.\",\n              });\n            }\n          }\n        } catch {\n          // best-effort hints; never fail validation here\n        }\n      }\n    }\n\n    // Validate global MCP servers if present\n    if (config.ai_mcp_servers) {\n      this.validateMcpServersObject(config.ai_mcp_servers, 'ai_mcp_servers', errors, warnings);\n    }\n\n    // Validate output configuration if present\n    if (config.output) {\n      this.validateOutputConfig(config.output as unknown as Record<string, unknown>, errors);\n    }\n\n    // Validate HTTP server configuration if present\n    if (config.http_server) {\n      this.validateHttpServerConfig(\n        config.http_server as unknown as Record<string, unknown>,\n        errors\n      );\n    }\n\n    // Validate max_parallelism if present\n    if (config.max_parallelism !== undefined) {\n      if (\n        typeof config.max_parallelism !== 'number' ||\n        config.max_parallelism < 1 ||\n        !Number.isInteger(config.max_parallelism)\n      ) {\n        errors.push({\n          field: 'max_parallelism',\n          message: 'max_parallelism must be a positive integer (minimum 1)',\n          value: config.max_parallelism,\n        });\n      }\n    }\n\n    // Validate tag_filter if present\n    if (config.tag_filter) {\n      this.validateTagFilter(config.tag_filter as unknown as Record<string, unknown>, errors);\n    }\n\n    // In strict mode, treat warnings as errors\n    if (strict && warnings.length > 0) {\n      errors.push(...warnings);\n    }\n\n    if (errors.length > 0) {\n      throw new Error(errors[0].message);\n    }\n\n    // Emit warnings (do not block execution) - only in non-strict mode\n    if (!strict && warnings.length > 0) {\n      for (const w of warnings) {\n        logger.warn(`‚ö†Ô∏è  Config warning [${w.field}]: ${w.message}`);\n      }\n    }\n  }\n\n  /**\n   * Validate individual check configuration\n   */\n  private validateCheckConfig(\n    checkName: string,\n    checkConfig: CheckConfig,\n    errors: ConfigValidationError[],\n    config?: Partial<VisorConfig>\n  ): void {\n    // Default to 'ai' if no type specified\n    if (!checkConfig.type) {\n      checkConfig.type = 'ai';\n    }\n    // Backward-compat alias: accept 'logger' as 'log'\n    if ((checkConfig as any).type === 'logger') {\n      (checkConfig as any).type = 'log';\n    }\n\n    if (!this.validCheckTypes.includes(checkConfig.type)) {\n      errors.push({\n        field: `checks.${checkName}.type`,\n        message: `Invalid check type \"${checkConfig.type}\". Must be: ${this.validCheckTypes.join(', ')}`,\n        value: checkConfig.type,\n      });\n    }\n\n    // Only AI checks require prompts\n    if (checkConfig.type === 'ai' && !checkConfig.prompt) {\n      errors.push({\n        field: `checks.${checkName}.prompt`,\n        message: `Invalid check configuration for \"${checkName}\": missing prompt (required for AI checks)`,\n      });\n    }\n\n    // Command checks require exec field\n    if (checkConfig.type === 'command' && !checkConfig.exec) {\n      errors.push({\n        field: `checks.${checkName}.exec`,\n        message: `Invalid check configuration for \"${checkName}\": missing exec field (required for command checks)`,\n      });\n    }\n\n    // HTTP output checks require url and body fields\n    if (checkConfig.type === 'http') {\n      if (!checkConfig.url) {\n        errors.push({\n          field: `checks.${checkName}.url`,\n          message: `Invalid check configuration for \"${checkName}\": missing url field (required for http checks)`,\n        });\n      }\n      if (!checkConfig.body) {\n        errors.push({\n          field: `checks.${checkName}.body`,\n          message: `Invalid check configuration for \"${checkName}\": missing body field (required for http checks)`,\n        });\n      }\n    }\n\n    // Note: Do not add special-case validation for log 'message' here.\n    // Schema (Ajv) permits 'message' and related keys; provider enforces at execution time.\n\n    // HTTP input checks require endpoint field\n    if (checkConfig.type === 'http_input' && !checkConfig.endpoint) {\n      errors.push({\n        field: `checks.${checkName}.endpoint`,\n        message: `Invalid check configuration for \"${checkName}\": missing endpoint field (required for http_input checks)`,\n      });\n    }\n\n    // HTTP client checks require url field\n    if (checkConfig.type === 'http_client' && !checkConfig.url) {\n      errors.push({\n        field: `checks.${checkName}.url`,\n        message: `Invalid check configuration for \"${checkName}\": missing url field (required for http_client checks)`,\n      });\n    }\n\n    // Validate cron schedule if specified\n    if (checkConfig.schedule) {\n      // Basic cron validation - could use node-cron.validate() for better validation\n      const cronParts = checkConfig.schedule.split(' ');\n      if (cronParts.length < 5 || cronParts.length > 6) {\n        errors.push({\n          field: `checks.${checkName}.schedule`,\n          message: `Invalid cron expression for \"${checkName}\": ${checkConfig.schedule}`,\n          value: checkConfig.schedule,\n        });\n      }\n    }\n\n    // 'on' field is optional - if not specified, check can be triggered by any event\n    if (checkConfig.on) {\n      if (!Array.isArray(checkConfig.on)) {\n        errors.push({\n          field: `checks.${checkName}.on`,\n          message: `Invalid check configuration for \"${checkName}\": 'on' field must be an array`,\n        });\n      } else {\n        // Validate event triggers\n        for (const event of checkConfig.on) {\n          if (!this.validEventTriggers.includes(event)) {\n            errors.push({\n              field: `checks.${checkName}.on`,\n              message: `Invalid event \"${event}\". Must be one of: ${this.validEventTriggers.join(', ')}`,\n              value: event,\n            });\n          }\n        }\n      }\n    }\n\n    // Validate reuse_ai_session configuration\n    if (checkConfig.reuse_ai_session !== undefined) {\n      const isString = typeof checkConfig.reuse_ai_session === 'string';\n      const isBoolean = typeof checkConfig.reuse_ai_session === 'boolean';\n\n      if (!isString && !isBoolean) {\n        errors.push({\n          field: `checks.${checkName}.reuse_ai_session`,\n          message: `Invalid reuse_ai_session value for \"${checkName}\": must be string (check name) or boolean`,\n          value: checkConfig.reuse_ai_session,\n        });\n      } else if (isString) {\n        // When reuse_ai_session is a string, it must refer to a valid check\n        const targetCheckName = checkConfig.reuse_ai_session as string;\n        if (!config?.checks || !config.checks[targetCheckName]) {\n          errors.push({\n            field: `checks.${checkName}.reuse_ai_session`,\n            message: `Check \"${checkName}\" references non-existent check \"${targetCheckName}\" for session reuse`,\n            value: checkConfig.reuse_ai_session,\n          });\n        }\n      } else if (checkConfig.reuse_ai_session === true) {\n        // When reuse_ai_session is true, depends_on must be specified and non-empty\n        if (\n          !checkConfig.depends_on ||\n          !Array.isArray(checkConfig.depends_on) ||\n          checkConfig.depends_on.length === 0\n        ) {\n          errors.push({\n            field: `checks.${checkName}.reuse_ai_session`,\n            message: `Check \"${checkName}\" has reuse_ai_session=true but missing or empty depends_on. Session reuse requires dependency on another check.`,\n            value: checkConfig.reuse_ai_session,\n          });\n        }\n      }\n    }\n\n    // Validate session_mode configuration\n    if (checkConfig.session_mode !== undefined) {\n      if (checkConfig.session_mode !== 'clone' && checkConfig.session_mode !== 'append') {\n        errors.push({\n          field: `checks.${checkName}.session_mode`,\n          message: `Invalid session_mode value for \"${checkName}\": must be 'clone' or 'append'`,\n          value: checkConfig.session_mode,\n        });\n      }\n\n      // session_mode only makes sense with reuse_ai_session\n      if (!checkConfig.reuse_ai_session) {\n        errors.push({\n          field: `checks.${checkName}.session_mode`,\n          message: `Check \"${checkName}\" has session_mode but no reuse_ai_session. session_mode requires reuse_ai_session to be set.`,\n          value: checkConfig.session_mode,\n        });\n      }\n    }\n\n    // Validate tags configuration\n    if (checkConfig.tags !== undefined) {\n      if (!Array.isArray(checkConfig.tags)) {\n        errors.push({\n          field: `checks.${checkName}.tags`,\n          message: `Invalid tags value for \"${checkName}\": must be an array of strings`,\n          value: checkConfig.tags,\n        });\n      } else {\n        // Validate each tag\n        const validTagPattern = /^[a-zA-Z0-9][a-zA-Z0-9-_]*$/;\n        checkConfig.tags.forEach((tag, index) => {\n          if (typeof tag !== 'string') {\n            errors.push({\n              field: `checks.${checkName}.tags[${index}]`,\n              message: `Invalid tag at index ${index} for \"${checkName}\": must be a string`,\n              value: tag,\n            });\n          } else if (!validTagPattern.test(tag)) {\n            errors.push({\n              field: `checks.${checkName}.tags[${index}]`,\n              message: `Invalid tag \"${tag}\" for \"${checkName}\": tags must be alphanumeric with hyphens or underscores (start with alphanumeric)`,\n              value: tag,\n            });\n          }\n        });\n      }\n    }\n\n    // Validate on_finish configuration\n    if (checkConfig.on_finish !== undefined) {\n      if (!checkConfig.forEach) {\n        errors.push({\n          field: `checks.${checkName}.on_finish`,\n          message: `Check \"${checkName}\" has on_finish but forEach is not true. on_finish is only valid on forEach checks.`,\n          value: checkConfig.on_finish,\n        });\n      }\n    }\n  }\n\n  /**\n   * Validate MCP servers object shape and values (basic shape only)\n   */\n  private validateMcpServersObject(\n    mcpServers: unknown,\n    fieldPrefix: string,\n    errors: ConfigValidationError[],\n    _warnings: ConfigValidationError[]\n  ): void {\n    if (typeof mcpServers !== 'object' || mcpServers === null) {\n      errors.push({\n        field: fieldPrefix,\n        message: `${fieldPrefix} must be an object mapping server names to { command, args?, env? }`,\n        value: mcpServers,\n      });\n      return;\n    }\n\n    for (const [serverName, cfg] of Object.entries(mcpServers as Record<string, unknown>)) {\n      const pathStr = `${fieldPrefix}.${serverName}`;\n      if (!cfg || typeof cfg !== 'object') {\n        errors.push({ field: pathStr, message: `${pathStr} must be an object`, value: cfg });\n        continue;\n      }\n      const { command, args, env } = cfg as { command?: unknown; args?: unknown; env?: unknown };\n      if (typeof command !== 'string' || command.trim() === '') {\n        errors.push({\n          field: `${pathStr}.command`,\n          message: `${pathStr}.command must be a non-empty string`,\n          value: command,\n        });\n      }\n      if (args !== undefined && !Array.isArray(args)) {\n        errors.push({\n          field: `${pathStr}.args`,\n          message: `${pathStr}.args must be an array of strings`,\n          value: args,\n        });\n      }\n      if (env !== undefined) {\n        if (typeof env !== 'object' || env === null) {\n          errors.push({\n            field: `${pathStr}.env`,\n            message: `${pathStr}.env must be an object of string values`,\n            value: env,\n          });\n        } else {\n          for (const [k, v] of Object.entries(env as Record<string, unknown>)) {\n            if (typeof v !== 'string') {\n              errors.push({\n                field: `${pathStr}.env.${k}`,\n                message: `${pathStr}.env.${k} must be a string`,\n                value: v,\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Validate configuration using generated JSON Schema via Ajv, if available.\n   * Adds to errors/warnings but does not throw directly.\n   */\n  private validateWithAjvSchema(\n    config: Partial<VisorConfig>,\n    errors: ConfigValidationError[],\n    warnings: ConfigValidationError[]\n  ): void {\n    try {\n      if (!__ajvValidate) {\n        // Preferred fast path: try plain JSON in dist/generated first\n        try {\n          const jsonPath = path.resolve(__dirname, 'generated', 'config-schema.json');\n\n          const jsonSchema = require(jsonPath);\n          if (jsonSchema) {\n            const ajv = new Ajv({ allErrors: true, allowUnionTypes: true, strict: false });\n            addFormats(ajv);\n            const validate = ajv.compile(jsonSchema);\n            __ajvValidate = (data: unknown) => validate(data);\n            __ajvErrors = () => validate.errors;\n          }\n        } catch {}\n        // Fallback: use embedded TS module (bundled by ncc)\n        if (!__ajvValidate) {\n          try {\n            const mod = require('./generated/config-schema');\n            const schema = mod?.configSchema || mod?.default || mod;\n            if (schema) {\n              const ajv = new Ajv({ allErrors: true, allowUnionTypes: true, strict: false });\n              addFormats(ajv);\n              const validate = ajv.compile(schema);\n              __ajvValidate = (data: unknown) => validate(data);\n              __ajvErrors = () => validate.errors;\n            } else {\n              return;\n            }\n          } catch {\n            return;\n          }\n        }\n      }\n\n      const ok = __ajvValidate(config);\n      const errs = __ajvErrors ? __ajvErrors() : null;\n      if (!ok && Array.isArray(errs)) {\n        for (const e of errs) {\n          const pathStr = e.instancePath\n            ? e.instancePath.replace(/^\\//, '').replace(/\\//g, '.')\n            : '';\n          const msg = e.message || 'Invalid configuration';\n          if (e.keyword === 'additionalProperties') {\n            const addl = (e.params && (e.params as any).additionalProperty) || 'unknown';\n            const fullField = pathStr ? `${pathStr}.${addl}` : addl;\n            const topLevel = !pathStr;\n            warnings.push({\n              field: fullField || 'config',\n              message: topLevel\n                ? `Unknown top-level key '${addl}' will be ignored.`\n                : `Unknown key '${addl}' will be ignored`,\n            });\n          } else {\n            // Defer to our existing programmatic validators for required/type errors\n            // to preserve friendly, stable error messages and avoid duplication.\n            logger.debug(`Ajv note [${pathStr || 'config'}]: ${msg}`);\n          }\n        }\n      }\n    } catch (err) {\n      logger.debug(`Ajv validation skipped: ${err instanceof Error ? err.message : String(err)}`);\n    }\n  }\n\n  // Unknown-key warnings are fully handled by Ajv using the generated schema\n  // Unknown-key hints are produced by Ajv (additionalProperties=false)\n\n  /**\n   * Validate tag filter configuration\n   */\n  private validateTagFilter(\n    tagFilter: Record<string, unknown>,\n    errors: ConfigValidationError[]\n  ): void {\n    const validTagPattern = /^[a-zA-Z0-9][a-zA-Z0-9-_]*$/;\n\n    // Validate include tags\n    if (tagFilter.include !== undefined) {\n      if (!Array.isArray(tagFilter.include)) {\n        errors.push({\n          field: 'tag_filter.include',\n          message: 'tag_filter.include must be an array of strings',\n          value: tagFilter.include,\n        });\n      } else {\n        tagFilter.include.forEach((tag: unknown, index: number) => {\n          if (typeof tag !== 'string') {\n            errors.push({\n              field: `tag_filter.include[${index}]`,\n              message: `Invalid tag at index ${index}: must be a string`,\n              value: tag,\n            });\n          } else if (!validTagPattern.test(tag as string)) {\n            errors.push({\n              field: `tag_filter.include[${index}]`,\n              message: `Invalid tag \"${tag}\": tags must be alphanumeric with hyphens or underscores`,\n              value: tag,\n            });\n          }\n        });\n      }\n    }\n\n    // Validate exclude tags\n    if (tagFilter.exclude !== undefined) {\n      if (!Array.isArray(tagFilter.exclude)) {\n        errors.push({\n          field: 'tag_filter.exclude',\n          message: 'tag_filter.exclude must be an array of strings',\n          value: tagFilter.exclude,\n        });\n      } else {\n        tagFilter.exclude.forEach((tag: unknown, index: number) => {\n          if (typeof tag !== 'string') {\n            errors.push({\n              field: `tag_filter.exclude[${index}]`,\n              message: `Invalid tag at index ${index}: must be a string`,\n              value: tag,\n            });\n          } else if (!validTagPattern.test(tag as string)) {\n            errors.push({\n              field: `tag_filter.exclude[${index}]`,\n              message: `Invalid tag \"${tag}\": tags must be alphanumeric with hyphens or underscores`,\n              value: tag,\n            });\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * Validate HTTP server configuration\n   */\n  private validateHttpServerConfig(\n    httpServerConfig: Record<string, unknown>,\n    errors: ConfigValidationError[]\n  ): void {\n    if (typeof httpServerConfig.enabled !== 'boolean') {\n      errors.push({\n        field: 'http_server.enabled',\n        message: 'http_server.enabled must be a boolean',\n        value: httpServerConfig.enabled,\n      });\n    }\n\n    if (httpServerConfig.enabled === true) {\n      // Port is required when enabled\n      if (\n        typeof httpServerConfig.port !== 'number' ||\n        httpServerConfig.port < 1 ||\n        httpServerConfig.port > 65535\n      ) {\n        errors.push({\n          field: 'http_server.port',\n          message: 'http_server.port must be a number between 1 and 65535',\n          value: httpServerConfig.port,\n        });\n      }\n\n      // Validate auth if present\n      if (httpServerConfig.auth) {\n        const auth = httpServerConfig.auth as Record<string, unknown>;\n        const validAuthTypes = ['bearer_token', 'hmac', 'basic', 'none'];\n\n        if (!auth.type || !validAuthTypes.includes(auth.type as string)) {\n          errors.push({\n            field: 'http_server.auth.type',\n            message: `Invalid auth type. Must be one of: ${validAuthTypes.join(', ')}`,\n            value: auth.type,\n          });\n        }\n      }\n\n      // Validate TLS configuration if present\n      if (httpServerConfig.tls && typeof httpServerConfig.tls === 'object') {\n        const tls = httpServerConfig.tls as Record<string, unknown>;\n\n        if (tls.enabled === true) {\n          // Cert and key are required when TLS is enabled\n          if (!tls.cert) {\n            errors.push({\n              field: 'http_server.tls.cert',\n              message: 'TLS certificate is required when TLS is enabled',\n            });\n          }\n          if (!tls.key) {\n            errors.push({\n              field: 'http_server.tls.key',\n              message: 'TLS key is required when TLS is enabled',\n            });\n          }\n        }\n      }\n\n      // Validate endpoints if present\n      if (httpServerConfig.endpoints && Array.isArray(httpServerConfig.endpoints)) {\n        for (let i = 0; i < httpServerConfig.endpoints.length; i++) {\n          const endpoint = httpServerConfig.endpoints[i] as Record<string, unknown>;\n          if (!endpoint.path || typeof endpoint.path !== 'string') {\n            errors.push({\n              field: `http_server.endpoints[${i}].path`,\n              message: 'Endpoint path must be a string',\n              value: endpoint.path,\n            });\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Validate output configuration\n   */\n  private validateOutputConfig(\n    outputConfig: Record<string, unknown>,\n    errors: ConfigValidationError[]\n  ): void {\n    if (outputConfig.pr_comment) {\n      const prComment = outputConfig.pr_comment as Record<string, unknown>;\n\n      if (\n        typeof prComment.format === 'string' &&\n        !this.validOutputFormats.includes(prComment.format as ConfigOutputFormat)\n      ) {\n        errors.push({\n          field: 'output.pr_comment.format',\n          message: `Invalid output format \"${prComment.format}\". Must be one of: ${this.validOutputFormats.join(', ')}`,\n          value: prComment.format as string,\n        });\n      }\n\n      if (\n        typeof prComment.group_by === 'string' &&\n        !this.validGroupByOptions.includes(prComment.group_by as GroupByOption)\n      ) {\n        errors.push({\n          field: 'output.pr_comment.group_by',\n          message: `Invalid group_by option \"${prComment.group_by}\". Must be one of: ${this.validGroupByOptions.join(', ')}`,\n          value: prComment.group_by as string,\n        });\n      }\n    }\n  }\n\n  /**\n   * Check if remote extends are allowed\n   */\n  private isRemoteExtendsAllowed(): boolean {\n    // Check environment variable first\n    if (\n      process.env.VISOR_NO_REMOTE_EXTENDS === 'true' ||\n      process.env.VISOR_NO_REMOTE_EXTENDS === '1'\n    ) {\n      return false;\n    }\n    // Default to allowing remote extends\n    return true;\n  }\n\n  /**\n   * Merge configuration with default values\n   */\n  private mergeWithDefaults(config: Partial<VisorConfig>): Partial<VisorConfig> {\n    const defaultConfig = {\n      version: '1.0',\n      checks: {},\n      max_parallelism: 3,\n      output: {\n        pr_comment: {\n          format: 'markdown' as ConfigOutputFormat,\n          group_by: 'check' as GroupByOption,\n          collapse: true,\n        },\n      },\n    };\n\n    // Deep merge with defaults\n    const merged = { ...defaultConfig, ...config };\n\n    // Ensure output has default values\n    if (merged.output) {\n      merged.output.pr_comment = {\n        ...defaultConfig.output.pr_comment,\n        ...merged.output.pr_comment,\n      };\n    } else {\n      merged.output = defaultConfig.output;\n    }\n\n    return merged;\n  }\n}\n\n// Cache Ajv validator across loads to avoid repeated heavy generation\nlet __ajvValidate: ((data: unknown) => boolean) | null = null;\nlet __ajvErrors: (() => import('ajv').ErrorObject[] | null | undefined) | null = null;\n","import * as fs from 'fs';\nimport * as path from 'path';\nimport * as yaml from 'js-yaml';\nimport { VisorConfig } from '../types/config';\n\n/**\n * Configuration source types\n */\nexport enum ConfigSourceType {\n  LOCAL = 'local',\n  REMOTE = 'remote',\n  DEFAULT = 'default',\n}\n\n/**\n * Cache entry for remote configurations\n */\ninterface CacheEntry {\n  config: Partial<VisorConfig>;\n  timestamp: number;\n  ttl: number;\n}\n\n/**\n * Options for loading configurations\n */\nexport interface ConfigLoaderOptions {\n  /** Base directory for resolving relative paths */\n  baseDir?: string;\n  /** Whether to allow remote extends (default: true) */\n  allowRemote?: boolean;\n  /** Cache TTL in milliseconds (default: 5 minutes) */\n  cacheTTL?: number;\n  /** Request timeout in milliseconds (default: 30 seconds) */\n  timeout?: number;\n  /** Maximum recursion depth (default: 10) */\n  maxDepth?: number;\n  /** Allowed remote URL patterns (default: ['https://github.com/', 'https://raw.githubusercontent.com/']) */\n  allowedRemotePatterns?: string[];\n  /** Project root directory for path traversal protection */\n  projectRoot?: string;\n}\n\n/**\n * Utility class for loading configurations from various sources\n */\nexport class ConfigLoader {\n  private cache: Map<string, CacheEntry> = new Map();\n  private loadedConfigs: Set<string> = new Set();\n\n  constructor(private options: ConfigLoaderOptions = {}) {\n    this.options = {\n      allowRemote: true,\n      cacheTTL: 5 * 60 * 1000, // 5 minutes\n      timeout: 30 * 1000, // 30 seconds\n      maxDepth: 10,\n      allowedRemotePatterns: [], // Empty by default for security\n      projectRoot: this.findProjectRoot(),\n      ...options,\n    };\n  }\n\n  /**\n   * Determine the source type from a string\n   */\n  private getSourceType(source: string): ConfigSourceType {\n    if (source === 'default') {\n      return ConfigSourceType.DEFAULT;\n    }\n    if (source.startsWith('http://') || source.startsWith('https://')) {\n      return ConfigSourceType.REMOTE;\n    }\n    return ConfigSourceType.LOCAL;\n  }\n\n  /**\n   * Fetch configuration from any source\n   */\n  public async fetchConfig(\n    source: string,\n    currentDepth: number = 0\n  ): Promise<Partial<VisorConfig>> {\n    // Check recursion depth\n    if (currentDepth >= (this.options.maxDepth || 10)) {\n      throw new Error(\n        `Maximum extends depth (${this.options.maxDepth}) exceeded. Check for circular dependencies.`\n      );\n    }\n\n    // Check for circular dependencies\n    const normalizedSource = this.normalizeSource(source);\n    if (this.loadedConfigs.has(normalizedSource)) {\n      throw new Error(\n        `Circular dependency detected: ${normalizedSource} is already in the extends chain`\n      );\n    }\n\n    const sourceType = this.getSourceType(source);\n\n    try {\n      this.loadedConfigs.add(normalizedSource);\n\n      switch (sourceType) {\n        case ConfigSourceType.DEFAULT:\n          return await this.fetchDefaultConfig();\n        case ConfigSourceType.REMOTE:\n          if (!this.options.allowRemote) {\n            throw new Error(\n              'Remote extends are disabled. Enable with --allow-remote-extends or remove VISOR_NO_REMOTE_EXTENDS environment variable.'\n            );\n          }\n          return await this.fetchRemoteConfig(source);\n        case ConfigSourceType.LOCAL:\n          return await this.fetchLocalConfig(source);\n        default:\n          throw new Error(`Unknown configuration source: ${source}`);\n      }\n    } finally {\n      this.loadedConfigs.delete(normalizedSource);\n    }\n  }\n\n  /**\n   * Normalize source path/URL for comparison\n   */\n  private normalizeSource(source: string): string {\n    const sourceType = this.getSourceType(source);\n\n    switch (sourceType) {\n      case ConfigSourceType.DEFAULT:\n        return 'default';\n      case ConfigSourceType.REMOTE:\n        return source.toLowerCase();\n      case ConfigSourceType.LOCAL:\n        const basePath = this.options.baseDir || process.cwd();\n        return path.resolve(basePath, source);\n      default:\n        return source;\n    }\n  }\n\n  /**\n   * Load configuration from local file system\n   */\n  private async fetchLocalConfig(filePath: string): Promise<Partial<VisorConfig>> {\n    const basePath = this.options.baseDir || process.cwd();\n    const resolvedPath = path.resolve(basePath, filePath);\n\n    // Validate against path traversal attacks\n    this.validateLocalPath(resolvedPath);\n\n    try {\n      const content = fs.readFileSync(resolvedPath, 'utf8');\n      const config = yaml.load(content) as Partial<VisorConfig>;\n\n      if (!config || typeof config !== 'object') {\n        throw new Error(`Invalid YAML in configuration file: ${resolvedPath}`);\n      }\n\n      // Update base directory for nested extends\n      const previousBaseDir = this.options.baseDir;\n      this.options.baseDir = path.dirname(resolvedPath);\n\n      try {\n        // Process extends if present\n        if (config.extends) {\n          const processedConfig = await this.processExtends(config);\n          return processedConfig;\n        }\n\n        return config;\n      } finally {\n        // Restore previous base directory\n        this.options.baseDir = previousBaseDir;\n      }\n    } catch (error: any) {\n      if (error && (error.code === 'ENOENT' || error.code === 'ENOTDIR')) {\n        throw new Error(`Configuration file not found: ${resolvedPath}`);\n      }\n      if (error instanceof Error) {\n        throw new Error(`Failed to load configuration from ${resolvedPath}: ${error.message}`);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Fetch configuration from remote URL\n   */\n  private async fetchRemoteConfig(url: string): Promise<Partial<VisorConfig>> {\n    // Validate URL protocol\n    if (!url.startsWith('http://') && !url.startsWith('https://')) {\n      throw new Error(`Invalid URL: ${url}. Only HTTP and HTTPS protocols are supported.`);\n    }\n\n    // Validate against SSRF attacks\n    this.validateRemoteURL(url);\n\n    // Check cache\n    const cacheEntry = this.cache.get(url);\n    if (cacheEntry && Date.now() - cacheEntry.timestamp < cacheEntry.ttl) {\n      // Use stderr to avoid contaminating JSON/SARIF output\n      const outputFormat = process.env.VISOR_OUTPUT_FORMAT;\n      const logFn =\n        outputFormat === 'json' || outputFormat === 'sarif' ? console.error : console.log;\n      logFn(`üì¶ Using cached configuration from: ${url}`);\n      return cacheEntry.config;\n    }\n\n    // Use stderr to avoid contaminating JSON/SARIF output\n    const outputFormat = process.env.VISOR_OUTPUT_FORMAT;\n    const logFn = outputFormat === 'json' || outputFormat === 'sarif' ? console.error : console.log;\n    logFn(`‚¨áÔ∏è  Fetching remote configuration from: ${url}`);\n\n    const controller = new AbortController();\n    const timeoutMs = this.options.timeout ?? 30000;\n    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);\n\n    try {\n      const response = await fetch(url, {\n        signal: controller.signal,\n        headers: {\n          'User-Agent': 'Visor/1.0',\n        },\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to fetch config: ${response.status} ${response.statusText}`);\n      }\n\n      const content = await response.text();\n      const config = yaml.load(content) as Partial<VisorConfig>;\n\n      if (!config || typeof config !== 'object') {\n        throw new Error(`Invalid YAML in remote configuration: ${url}`);\n      }\n\n      // Cache the configuration\n      this.cache.set(url, {\n        config,\n        timestamp: Date.now(),\n        ttl: this.options.cacheTTL || 5 * 60 * 1000,\n      });\n\n      // Process extends if present\n      if (config.extends) {\n        return await this.processExtends(config);\n      }\n\n      return config;\n    } catch (error) {\n      if (error instanceof Error) {\n        if (error.name === 'AbortError') {\n          throw new Error(`Timeout fetching configuration from ${url} (${timeoutMs}ms)`);\n        }\n        throw new Error(`Failed to fetch remote configuration from ${url}: ${error.message}`);\n      }\n      throw error;\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  }\n\n  /**\n   * Load bundled default configuration\n   */\n  private async fetchDefaultConfig(): Promise<Partial<VisorConfig>> {\n    // Try different paths to find the bundled default config\n    const possiblePaths = [\n      // Only support new non-dot filename\n      path.join(__dirname, 'defaults', 'visor.yaml'),\n      // When running from source\n      path.join(__dirname, '..', '..', 'defaults', 'visor.yaml'),\n      // Try via package root\n      this.findPackageRoot() ? path.join(this.findPackageRoot()!, 'defaults', 'visor.yaml') : '',\n      // GitHub Action environment variable\n      process.env.GITHUB_ACTION_PATH\n        ? path.join(process.env.GITHUB_ACTION_PATH, 'defaults', 'visor.yaml')\n        : '',\n      process.env.GITHUB_ACTION_PATH\n        ? path.join(process.env.GITHUB_ACTION_PATH, 'dist', 'defaults', 'visor.yaml')\n        : '',\n    ].filter(p => p); // Remove empty paths\n\n    let defaultConfigPath: string | undefined;\n    for (const possiblePath of possiblePaths) {\n      if (fs.existsSync(possiblePath)) {\n        defaultConfigPath = possiblePath;\n        break;\n      }\n    }\n\n    if (defaultConfigPath) {\n      // Always log to stderr to avoid contaminating formatted output\n      console.error(`üì¶ Loading bundled default configuration from ${defaultConfigPath}`);\n      const content = fs.readFileSync(defaultConfigPath, 'utf8');\n      let config = yaml.load(content) as Partial<VisorConfig>;\n\n      if (!config || typeof config !== 'object') {\n        throw new Error('Invalid default configuration');\n      }\n\n      // Normalize 'checks' and 'steps' for backward compatibility\n      config = this.normalizeStepsAndChecks(config);\n\n      // Default configs shouldn't have extends, but handle it just in case\n      if (config.extends) {\n        return await this.processExtends(config);\n      }\n\n      return config;\n    }\n\n    // Return minimal default if bundled config not found\n    console.warn('‚ö†Ô∏è  Bundled default configuration not found, using minimal defaults');\n    return {\n      version: '1.0',\n      checks: {},\n      output: {\n        pr_comment: {\n          format: 'markdown',\n          group_by: 'check',\n          collapse: true,\n        },\n      },\n    };\n  }\n\n  /**\n   * Process extends directive in a configuration\n   */\n  private async processExtends(config: Partial<VisorConfig>): Promise<Partial<VisorConfig>> {\n    if (!config.extends) {\n      return config;\n    }\n\n    const extends_ = Array.isArray(config.extends) ? config.extends : [config.extends];\n\n    // Remove extends from the config to avoid infinite recursion\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const { extends: _extendsField, ...configWithoutExtends } = config;\n\n    // Load all parent configurations\n    const parentConfigs: Partial<VisorConfig>[] = [];\n    for (const source of extends_) {\n      const parentConfig = await this.fetchConfig(source, this.loadedConfigs.size);\n      parentConfigs.push(parentConfig);\n    }\n\n    // Merge configurations (will be implemented in config-merger.ts)\n    // For now, we'll import it dynamically\n    const { ConfigMerger } = await import('./config-merger');\n    const merger = new ConfigMerger();\n\n    // Merge all parent configs together first\n    let mergedParents: Partial<VisorConfig> = {};\n    for (const parentConfig of parentConfigs) {\n      mergedParents = merger.merge(mergedParents, parentConfig);\n    }\n\n    // Then merge with the current config (child overrides parent)\n    return merger.merge(mergedParents, configWithoutExtends);\n  }\n\n  /**\n   * Find project root directory (for security validation)\n   */\n  private findProjectRoot(): string {\n    // Try to find git root first\n    try {\n      const { execSync } = require('child_process');\n      const gitRoot = execSync('git rev-parse --show-toplevel', { encoding: 'utf8' }).trim();\n      if (gitRoot) return gitRoot;\n    } catch {\n      // Not a git repo, continue\n    }\n\n    // Fall back to finding package.json\n    const packageRoot = this.findPackageRoot();\n    if (packageRoot) return packageRoot;\n\n    // Last resort: use current working directory\n    return process.cwd();\n  }\n\n  /**\n   * Validate remote URL against allowlist\n   */\n  private validateRemoteURL(url: string): void {\n    // If allowlist is empty, allow all URLs (backward compatibility)\n    const allowedPatterns = this.options.allowedRemotePatterns || [];\n    if (allowedPatterns.length === 0) {\n      return;\n    }\n\n    // Check if URL matches any allowed pattern\n    const isAllowed = allowedPatterns.some(pattern => url.startsWith(pattern));\n    if (!isAllowed) {\n      throw new Error(\n        `Security error: URL ${url} is not in the allowed list. Allowed patterns: ${allowedPatterns.join(', ')}`\n      );\n    }\n  }\n\n  /**\n   * Validate local path against traversal attacks\n   */\n  private validateLocalPath(resolvedPath: string): void {\n    const projectRoot = this.options.projectRoot || process.cwd();\n    const normalizedPath = path.normalize(resolvedPath);\n    const normalizedRoot = path.normalize(projectRoot);\n\n    // Check if the resolved path is within the project root\n    if (!normalizedPath.startsWith(normalizedRoot)) {\n      throw new Error(\n        `Security error: Path traversal detected. Cannot access files outside project root: ${projectRoot}`\n      );\n    }\n\n    // Additional check for sensitive system files\n    const sensitivePatterns = [\n      '/etc/passwd',\n      '/etc/shadow',\n      '/.ssh/',\n      '/.aws/',\n      '/.env',\n      '/private/',\n    ];\n\n    const lowerPath = normalizedPath.toLowerCase();\n    for (const pattern of sensitivePatterns) {\n      if (lowerPath.includes(pattern)) {\n        throw new Error(`Security error: Cannot access potentially sensitive file: ${pattern}`);\n      }\n    }\n  }\n\n  /**\n   * Find package root directory\n   */\n  private findPackageRoot(): string | null {\n    let currentDir = __dirname;\n    const root = path.parse(currentDir).root;\n\n    while (currentDir !== root) {\n      const packageJsonPath = path.join(currentDir, 'package.json');\n      if (fs.existsSync(packageJsonPath)) {\n        try {\n          const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));\n          // Check if this is the Visor package\n          if (packageJson.name === '@probelabs/visor') {\n            return currentDir;\n          }\n        } catch {\n          // Continue searching\n        }\n      }\n      currentDir = path.dirname(currentDir);\n    }\n\n    return null;\n  }\n\n  /**\n   * Clear the configuration cache\n   */\n  public clearCache(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Reset the loaded configs tracking (for testing)\n   */\n  public reset(): void {\n    this.loadedConfigs.clear();\n    this.clearCache();\n  }\n\n  /**\n   * Normalize 'checks' and 'steps' keys for backward compatibility\n   * Ensures both keys are present and contain the same data\n   */\n  private normalizeStepsAndChecks(config: Partial<VisorConfig>): Partial<VisorConfig> {\n    // If both are present, 'steps' takes precedence\n    if (config.steps && config.checks) {\n      // Use steps as the source of truth\n      config.checks = config.steps;\n    } else if (config.steps && !config.checks) {\n      // Copy steps to checks for internal compatibility\n      config.checks = config.steps;\n    } else if (config.checks && !config.steps) {\n      // Copy checks to steps for forward compatibility\n      config.steps = config.checks;\n    }\n\n    return config;\n  }\n}\n"],"mappings":"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","names":["uuidv4","resolve","initializeTracer","fs","path","import_probe","context","triggeringComment","fs","path","agentAny","result","resolve","CheckExecutionEngine","fs","path","normalize","fs","path","ignore","path","fs","status","path","resolve","fs","path","content","lines","path","fs","path","import_promises","import_path","fs","context","context","fs","path","import_promises","import_path","path","fs","emitNdjsonSpanWithEvents","SessionRegistry","context","context","Sandbox","exec","getGlobalRecorder","arr","import_promises","import_path","path","fs","resolve","context","emitNdjsonSpanWithEvents","arr","buildSandboxEnv","context","key","context","Ajv","context","context","buildSandboxEnv","resolve","resolve","fs","path","buildSandboxEnv","context","path","import_ajv","Ajv","addFormats","fs","import_liquidjs","context","import_liquidjs","context","resolve","emitNdjsonSpanWithEvents","context","emitNdjsonSpanWithEvents","checkName","normalize","log","issues","hasMinPermission","isOwner","isMember","isCollaborator","isContributor","isFirstTimer","exec","log","compileAndRun","withIds","log","exec","last","fs","path","buildSandboxEnv","global","context","log","exec","resolve","wave","depResults","fs","path","props","out","mode","tcfg","focus","createExtendedLiquid","withPermissionsContext","emitMermaidFromMarkdown","checks","itemScope","agg","i","SessionRegistry","emitNdjsonSpanWithEvents","yaml","fs","path","import_simple_git","fs","path","yaml","outputFormat","logFn","ConfigMerger","import_ajv","import_ajv_formats","simpleGit","WorkflowRegistry","Ajv","addFormats"]}