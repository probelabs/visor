{"version":3,"sources":["../../src/logger.ts","../../src/footer.ts","../../src/github-comments.ts","../../src/utils/tracer-init.ts","../../src/session-registry.ts","../../src/utils/diff-processor.ts","../../src/ai-review-service.ts","../../src/reviewer.ts","../../src/utils/file-exclusion.ts","../../src/git-repository-analyzer.ts","../../src/pr-analyzer.ts","../../src/providers/check-provider.interface.ts","../../src/utils/env-resolver.ts","../../src/issue-filter.ts","../../src/utils/author-permissions.ts","../../src/memory-store.ts","../../src/liquid-extensions.ts","../../src/telemetry/lazy-otel.ts","../../src/telemetry/state-capture.ts","../../src/telemetry/fallback-ndjson.ts","../../src/providers/ai-check-provider.ts","../../src/providers/http-check-provider.ts","../../src/providers/http-input-provider.ts","../../src/providers/http-client-provider.ts","../../src/providers/noop-check-provider.ts","../../src/providers/log-check-provider.ts","../../src/utils/sandbox.ts","../../src/providers/github-ops-provider.ts","../../src/providers/claude-code-types.ts","../../src/providers/claude-code-check-provider.ts","../../src/utils/env-exposure.ts","../../src/providers/command-check-provider.ts","../../src/providers/memory-check-provider.ts","../../src/providers/mcp-check-provider.ts","../../src/utils/interactive-prompt.ts","../../src/utils/stdin-reader.ts","../../src/providers/human-input-check-provider.ts","../../src/providers/check-provider-registry.ts","../../src/dependency-resolver.ts","../../src/telemetry/trace-helpers.ts","../../src/telemetry/metrics.ts","../../src/failure-condition-evaluator.ts","../../src/github-check-service.ts","../../src/snapshot-store.ts","../../src/utils/mermaid-telemetry.ts","../../src/check-execution-engine.ts","../../src/utils/config-merger.ts","../../src/generated/config-schema.ts","../../src/sdk.ts","../../src/config.ts","../../src/utils/config-loader.ts"],"sourcesContent":["/*\n * Centralized logger for Visor CLI and Action modes.\n * - Respects output format (suppresses info in JSON/SARIF unless debug)\n * - Supports levels: silent < error < warn < info < verbose < debug\n * - Routes logs to stderr to keep stdout clean for machine-readable output\n */\n\nexport type LogLevel = 'silent' | 'error' | 'warn' | 'info' | 'verbose' | 'debug';\n\nfunction levelToNumber(level: LogLevel): number {\n  switch (level) {\n    case 'silent':\n      return 0;\n    case 'error':\n      return 10;\n    case 'warn':\n      return 20;\n    case 'info':\n      return 30;\n    case 'verbose':\n      return 40;\n    case 'debug':\n      return 50;\n  }\n}\n\nclass Logger {\n  private level: LogLevel = 'info';\n  private isJsonLike: boolean = false;\n  private isTTY: boolean = typeof process !== 'undefined' ? !!process.stderr.isTTY : false;\n\n  configure(\n    opts: {\n      outputFormat?: string;\n      level?: LogLevel;\n      debug?: boolean;\n      verbose?: boolean;\n      quiet?: boolean;\n    } = {}\n  ): void {\n    // Determine base level\n    let lvl: LogLevel = 'info';\n\n    if (opts.debug || process.env.VISOR_DEBUG === 'true') {\n      lvl = 'debug';\n    } else if (opts.verbose || process.env.VISOR_LOG_LEVEL === 'verbose') {\n      lvl = 'verbose';\n    } else if (opts.quiet || process.env.VISOR_LOG_LEVEL === 'quiet') {\n      lvl = 'warn';\n    } else if (opts.level) {\n      lvl = opts.level;\n    } else if (process.env.VISOR_LOG_LEVEL) {\n      const envLvl = process.env.VISOR_LOG_LEVEL as LogLevel;\n      if (['silent', 'error', 'warn', 'info', 'verbose', 'debug'].includes(envLvl)) {\n        lvl = envLvl as LogLevel;\n      }\n    }\n\n    this.level = lvl;\n    const output = opts.outputFormat || process.env.VISOR_OUTPUT_FORMAT || 'table';\n    // In JSON/SARIF we suppress non-error logs unless explicitly verbose/debug\n    this.isJsonLike = output === 'json' || output === 'sarif';\n  }\n\n  private shouldLog(level: LogLevel): boolean {\n    const desired = levelToNumber(level);\n    const current = levelToNumber(this.level);\n    if (desired > current) return false;\n    if (\n      this.isJsonLike &&\n      desired < levelToNumber('error') &&\n      this.level !== 'debug' &&\n      this.level !== 'verbose'\n    ) {\n      // In JSON/SARIF, hide info/warn unless explicitly verbose/debug\n      return false;\n    }\n    return true;\n  }\n\n  private write(msg: string): void {\n    // Always route to stderr to keep stdout clean for results\n    try {\n      process.stderr.write(msg + '\\n');\n    } catch {\n      // Ignore write errors\n    }\n  }\n\n  info(msg: string): void {\n    if (this.shouldLog('info')) this.write(msg);\n  }\n\n  warn(msg: string): void {\n    if (this.shouldLog('warn')) this.write(msg);\n  }\n\n  error(msg: string): void {\n    if (this.shouldLog('error')) this.write(msg);\n  }\n\n  verbose(msg: string): void {\n    if (this.shouldLog('verbose')) this.write(msg);\n  }\n\n  debug(msg: string): void {\n    if (this.shouldLog('debug')) this.write(msg);\n  }\n\n  step(msg: string): void {\n    // High-level phase indicator\n    if (this.shouldLog('info')) this.write(`▶ ${msg}`);\n  }\n\n  success(msg: string): void {\n    if (this.shouldLog('info')) this.write(`✔ ${msg}`);\n  }\n}\n\n// Singleton instance\nexport const logger = new Logger();\n\n// Helper to configure from CLI options in a single place\nexport function configureLoggerFromCli(options: {\n  output?: string;\n  debug?: boolean;\n  verbose?: boolean;\n  quiet?: boolean;\n}): void {\n  logger.configure({\n    outputFormat: options.output,\n    debug: options.debug,\n    verbose: options.verbose,\n    quiet: options.quiet,\n  });\n\n  // Expose output format and debug to process env for modules that need to gate\n  // stdout emissions without plumbing the value through every call site.\n  try {\n    if (options.output) process.env.VISOR_OUTPUT_FORMAT = String(options.output);\n    if (typeof options.debug === 'boolean') {\n      process.env.VISOR_DEBUG = options.debug ? 'true' : 'false';\n    }\n  } catch {\n    // ignore\n  }\n}\n","/**\n * Centralized footer generation for Visor comments and outputs\n */\n\nexport interface FooterOptions {\n  /**\n   * Include metadata like lastUpdated, triggeredBy, commitSha\n   */\n  includeMetadata?: {\n    lastUpdated: string;\n    triggeredBy: string;\n    commitSha?: string;\n  };\n  /**\n   * Include horizontal rule separator before footer\n   */\n  includeSeparator?: boolean;\n}\n\n/**\n * Generate a standard Visor footer with branding and optional tip\n */\nexport function generateFooter(options: FooterOptions = {}): string {\n  const { includeMetadata, includeSeparator = true } = options;\n\n  const parts: string[] = [];\n\n  // Add separator\n  if (includeSeparator) {\n    parts.push('---');\n    parts.push('');\n  }\n\n  // Add branding\n  parts.push(\n    '*Powered by [Visor](https://probelabs.com/visor) from [Probelabs](https://probelabs.com)*'\n  );\n\n  // Add metadata if provided\n  if (includeMetadata) {\n    const { lastUpdated, triggeredBy, commitSha } = includeMetadata;\n    const commitInfo = commitSha ? ` | Commit: ${commitSha.substring(0, 7)}` : '';\n    parts.push('');\n    parts.push(`*Last updated: ${lastUpdated} | Triggered by: ${triggeredBy}${commitInfo}*`);\n  }\n\n  // Add tip\n  parts.push('');\n  parts.push('💡 **TIP:** You can chat with Visor using `/visor ask <your question>`');\n\n  return parts.join('\\n');\n}\n\n/**\n * Check if a string contains a Visor footer\n */\nexport function hasVisorFooter(text: string): boolean {\n  return (\n    text.includes('*Powered by [Visor](https://probelabs.com/visor)') ||\n    text.includes('*Powered by [Visor](https://github.com/probelabs/visor)')\n  );\n}\n","import { Octokit } from '@octokit/rest';\nimport { v4 as uuidv4 } from 'uuid';\nimport { logger } from './logger';\nimport { generateFooter } from './footer';\n\nexport interface Comment {\n  id: number;\n  body: string;\n  user: {\n    login: string;\n  };\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface RetryConfig {\n  maxRetries: number;\n  baseDelay: number;\n  maxDelay: number;\n  backoffFactor: number;\n}\n\nexport interface CommentMetadata {\n  commentId: string;\n  lastUpdated: string;\n  triggeredBy: string;\n  commitSha?: string;\n}\n\ninterface GitHubApiError {\n  status?: number;\n  response?: {\n    status?: number;\n    data?: {\n      message?: string;\n    };\n  };\n}\n\n/**\n * Manages GitHub PR comments with dynamic updating capabilities\n */\nexport class CommentManager {\n  private octokit: Octokit;\n  private retryConfig: RetryConfig;\n\n  constructor(octokit: Octokit, retryConfig?: Partial<RetryConfig>) {\n    this.octokit = octokit;\n    this.retryConfig = {\n      maxRetries: 3,\n      baseDelay: 1000,\n      maxDelay: 10000,\n      backoffFactor: 2,\n      ...retryConfig,\n    };\n  }\n\n  /**\n   * Find existing Visor comment by comment ID marker\n   */\n  public async findVisorComment(\n    owner: string,\n    repo: string,\n    prNumber: number,\n    commentId?: string\n  ): Promise<Comment | null> {\n    try {\n      const comments = await this.octokit.rest.issues.listComments({\n        owner,\n        repo,\n        issue_number: prNumber,\n        per_page: 100, // GitHub default max\n      });\n\n      for (const comment of comments.data) {\n        if (comment.body && this.isVisorComment(comment.body, commentId)) {\n          return comment as Comment;\n        }\n      }\n\n      return null;\n    } catch (error) {\n      if (\n        this.isRateLimitError(\n          error as { status?: number; response?: { data?: { message?: string } } }\n        )\n      ) {\n        await this.handleRateLimit(error as { response?: { headers?: Record<string, string> } });\n        return this.findVisorComment(owner, repo, prNumber, commentId);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Update existing comment or create new one with collision detection\n   */\n  public async updateOrCreateComment(\n    owner: string,\n    repo: string,\n    prNumber: number,\n    content: string,\n    options: {\n      commentId?: string;\n      triggeredBy?: string;\n      allowConcurrentUpdates?: boolean;\n      commitSha?: string;\n    } = {}\n  ): Promise<Comment> {\n    const {\n      commentId = this.generateCommentId(),\n      triggeredBy = 'unknown',\n      allowConcurrentUpdates = false,\n      commitSha,\n    } = options;\n\n    return this.withRetry(async () => {\n      const existingComment = await this.findVisorComment(owner, repo, prNumber, commentId);\n\n      const formattedContent = this.formatCommentWithMetadata(content, {\n        commentId,\n        lastUpdated: new Date().toISOString(),\n        triggeredBy,\n        commitSha,\n      });\n\n      if (existingComment) {\n        // Check for collision if not allowing concurrent updates\n        if (!allowConcurrentUpdates) {\n          const currentComment = await this.octokit.rest.issues.getComment({\n            owner,\n            repo,\n            comment_id: existingComment.id,\n          });\n\n          if (currentComment.data.updated_at !== existingComment.updated_at) {\n            throw new Error(\n              `Comment collision detected for comment ${commentId}. Another process may have updated it.`\n            );\n          }\n        }\n\n        const updatedComment = await this.octokit.rest.issues.updateComment({\n          owner,\n          repo,\n          comment_id: existingComment.id,\n          body: formattedContent,\n        });\n\n        logger.info(\n          `✅ Successfully updated comment (ID: ${commentId}, GitHub ID: ${existingComment.id}) on PR #${prNumber} in ${owner}/${repo}`\n        );\n\n        return updatedComment.data as Comment;\n      } else {\n        const newComment = await this.octokit.rest.issues.createComment({\n          owner,\n          repo,\n          issue_number: prNumber,\n          body: formattedContent,\n        });\n\n        logger.info(\n          `✅ Successfully created comment (ID: ${commentId}, GitHub ID: ${newComment.data.id}) on PR #${prNumber} in ${owner}/${repo}`\n        );\n\n        return newComment.data as Comment;\n      }\n    });\n  }\n\n  /**\n   * Format comment content with metadata markers\n   */\n  public formatCommentWithMetadata(content: string, metadata: CommentMetadata): string {\n    const { commentId, lastUpdated, triggeredBy, commitSha } = metadata;\n\n    const footer = generateFooter({\n      includeMetadata: {\n        lastUpdated,\n        triggeredBy,\n        commitSha,\n      },\n    });\n\n    return `<!-- visor-comment-id:${commentId} -->\n${content}\n\n${footer}\n<!-- /visor-comment-id:${commentId} -->`;\n  }\n\n  /**\n   * Create collapsible sections for comment content\n   */\n  public createCollapsibleSection(\n    title: string,\n    content: string,\n    isExpanded: boolean = false\n  ): string {\n    const openAttribute = isExpanded ? ' open' : '';\n    return `<details${openAttribute}>\n<summary>${title}</summary>\n\n${content}\n\n</details>`;\n  }\n\n  /**\n   * Group review results by check type with collapsible sections\n   */\n  public formatGroupedResults(\n    results: Array<{ checkType: string; content: string; score?: number; issuesFound?: number }>,\n    groupBy: 'check' | 'severity' = 'check'\n  ): string {\n    const grouped = this.groupResults(results, groupBy);\n    const sections: string[] = [];\n\n    for (const [groupKey, items] of Object.entries(grouped)) {\n      const totalScore = items.reduce((sum, item) => sum + (item.score || 0), 0) / items.length;\n      const totalIssues = items.reduce((sum, item) => sum + (item.issuesFound || 0), 0);\n\n      const emoji = this.getCheckTypeEmoji(groupKey);\n      const title = `${emoji} ${this.formatGroupTitle(groupKey, totalScore, totalIssues)}`;\n\n      const sectionContent = items.map(item => item.content).join('\\n\\n');\n      sections.push(this.createCollapsibleSection(title, sectionContent, totalIssues > 0));\n    }\n\n    return sections.join('\\n\\n');\n  }\n\n  /**\n   * Generate unique comment ID\n   */\n  private generateCommentId(): string {\n    return uuidv4().substring(0, 8);\n  }\n\n  /**\n   * Check if comment is a Visor comment\n   */\n  private isVisorComment(body: string, commentId?: string): boolean {\n    if (commentId) {\n      // Check for the new format with exact matching - look for the exact ID followed by space or \" -->\"\n      if (\n        body.includes(`visor-comment-id:${commentId} `) ||\n        body.includes(`visor-comment-id:${commentId} -->`)\n      ) {\n        return true;\n      }\n      // Check for legacy format (visor-review-* pattern) for backwards compatibility\n      if (commentId.startsWith('pr-review-') && body.includes('visor-review-')) {\n        return true;\n      }\n      // If we have a specific commentId but no exact match, return false\n      return false;\n    }\n    // General Visor comment detection (only when no specific commentId provided)\n    return (\n      (body.includes('visor-comment-id:') && body.includes('<!-- /visor-comment-id:')) ||\n      body.includes('visor-review-')\n    );\n  }\n\n  /**\n   * Extract comment ID from comment body\n   */\n  public extractCommentId(body: string): string | null {\n    const match = body.match(/visor-comment-id:([a-f0-9-]+)/);\n    return match ? match[1] : null;\n  }\n\n  /**\n   * Handle rate limiting with exponential backoff\n   */\n  private async handleRateLimit(error: {\n    response?: { headers?: Record<string, string> };\n  }): Promise<void> {\n    const resetTime = error.response?.headers?.['x-ratelimit-reset'];\n    if (resetTime) {\n      const resetDate = new Date(parseInt(resetTime) * 1000);\n      const waitTime = Math.max(resetDate.getTime() - Date.now(), this.retryConfig.baseDelay);\n      console.log(`Rate limit exceeded. Waiting ${Math.round(waitTime / 1000)}s until reset...`);\n      await this.sleep(Math.min(waitTime, this.retryConfig.maxDelay));\n    } else {\n      await this.sleep(this.retryConfig.baseDelay);\n    }\n  }\n\n  /**\n   * Check if error is a rate limit error\n   */\n  private isRateLimitError(error: GitHubApiError): boolean {\n    return error.status === 403 && (error.response?.data?.message?.includes('rate limit') ?? false);\n  }\n\n  /**\n   * Check if error should not be retried (auth errors, not found, etc.)\n   */\n  private isNonRetryableError(error: GitHubApiError): boolean {\n    // Don't retry auth errors, not found, etc., but allow rate limit errors to be handled separately\n    const nonRetryableStatuses = [401, 404, 422]; // Unauthorized, Not Found, Unprocessable Entity\n    const status = error.status || error.response?.status;\n\n    // 403 is non-retryable unless it's a rate limit error\n    if (status === 403) {\n      return !this.isRateLimitError(error);\n    }\n\n    return status !== undefined && nonRetryableStatuses.includes(status);\n  }\n\n  /**\n   * Retry wrapper with exponential backoff\n   */\n  private async withRetry<T>(operation: () => Promise<T>): Promise<T> {\n    let lastError: Error = new Error('Unknown error');\n\n    for (let attempt = 0; attempt <= this.retryConfig.maxRetries; attempt++) {\n      try {\n        return await operation();\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n\n        if (attempt === this.retryConfig.maxRetries) {\n          break;\n        }\n\n        if (\n          this.isRateLimitError(\n            error as { status?: number; response?: { data?: { message?: string } } }\n          )\n        ) {\n          await this.handleRateLimit(error as { response?: { headers?: Record<string, string> } });\n        } else if (this.isNonRetryableError(error as GitHubApiError)) {\n          // Don't retry auth errors, not found errors, etc.\n          throw error;\n        } else {\n          const delay = Math.min(\n            this.retryConfig.baseDelay * Math.pow(this.retryConfig.backoffFactor, attempt),\n            this.retryConfig.maxDelay\n          );\n          await this.sleep(delay);\n        }\n      }\n    }\n\n    throw lastError;\n  }\n\n  /**\n   * Sleep utility\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Group results by specified criteria\n   */\n  private groupResults(\n    results: Array<{ checkType: string; content: string; score?: number; issuesFound?: number }>,\n    groupBy: 'check' | 'severity'\n  ): Record<\n    string,\n    Array<{ checkType: string; content: string; score?: number; issuesFound?: number }>\n  > {\n    const grouped: Record<\n      string,\n      Array<{ checkType: string; content: string; score?: number; issuesFound?: number }>\n    > = {};\n\n    for (const result of results) {\n      const key = groupBy === 'check' ? result.checkType : this.getSeverityGroup(result.score);\n      if (!grouped[key]) {\n        grouped[key] = [];\n      }\n      grouped[key].push(result);\n    }\n\n    return grouped;\n  }\n\n  /**\n   * Get severity group based on score\n   */\n  private getSeverityGroup(score?: number): string {\n    if (!score) return 'Unknown';\n    if (score >= 90) return 'Excellent';\n    if (score >= 75) return 'Good';\n    if (score >= 50) return 'Needs Improvement';\n    return 'Critical Issues';\n  }\n\n  /**\n   * Get emoji for check type\n   */\n  private getCheckTypeEmoji(checkType: string): string {\n    const emojiMap: Record<string, string> = {\n      performance: '📈',\n      security: '🔒',\n      architecture: '🏗️',\n      style: '🎨',\n      all: '🔍',\n      Excellent: '✅',\n      Good: '👍',\n      'Needs Improvement': '⚠️',\n      'Critical Issues': '🚨',\n      Unknown: '❓',\n    };\n    return emojiMap[checkType] || '📝';\n  }\n\n  /**\n   * Format group title with score and issue count\n   */\n  private formatGroupTitle(groupKey: string, score: number, issuesFound: number): string {\n    const formattedScore = Math.round(score);\n    return `${groupKey} Review (Score: ${formattedScore}/100)${issuesFound > 0 ? ` - ${issuesFound} issues found` : ''}`;\n  }\n}\n","import * as path from 'path';\nimport * as fs from 'fs';\n\n/**\n * Safely initialize a tracer for ProbeAgent with proper path sanitization\n * Uses SimpleTelemetry for lightweight tracing\n * This prevents path traversal vulnerabilities by sanitizing the checkName\n */\ntype ProbeModule =\n  | {\n      SimpleTelemetry?: new (opts: {\n        enableFile: boolean;\n        filePath: string;\n        enableConsole?: boolean;\n      }) => unknown;\n      SimpleAppTracer?: new (telemetry: unknown, sessionId: string) => unknown;\n    }\n  | undefined;\n\nexport async function initializeTracer(\n  sessionId: string,\n  checkName?: string\n): Promise<{ tracer: unknown; telemetryConfig: unknown; filePath: string } | null> {\n  try {\n    // Load Probe lib in a way that works in both ESM and CJS bundles\n    let ProbeLib: ProbeModule;\n    try {\n      ProbeLib = (await import('@probelabs/probe')) as ProbeModule;\n    } catch {\n      try {\n        // Fallback to CJS require if available\n\n        ProbeLib = require('@probelabs/probe') as ProbeModule;\n      } catch {\n        ProbeLib = {} as unknown as ProbeModule;\n      }\n    }\n\n    // Use SimpleTelemetry (probe no longer exports full OpenTelemetry classes)\n    const SimpleTelemetry = ProbeLib?.SimpleTelemetry;\n    const SimpleAppTracer = ProbeLib?.SimpleAppTracer;\n    if (SimpleTelemetry && SimpleAppTracer) {\n      // SECURITY: Sanitize checkName to prevent path traversal attacks\n      const sanitizedCheckName = checkName ? path.basename(checkName) : 'check';\n\n      // Create trace file path in debug-artifacts directory\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n      const traceDir = process.env.GITHUB_WORKSPACE\n        ? path.join(process.env.GITHUB_WORKSPACE, 'debug-artifacts')\n        : path.join(process.cwd(), 'debug-artifacts');\n\n      // Create traces directory if it doesn't exist\n      if (!fs.existsSync(traceDir)) {\n        fs.mkdirSync(traceDir, { recursive: true });\n      }\n\n      // SECURITY: Use path.join to safely construct the path\n      const traceFilePath = path.join(traceDir, `trace-${sanitizedCheckName}-${timestamp}.jsonl`);\n\n      // SECURITY: Verify the resolved path is within the intended directory\n      const resolvedTracePath = path.resolve(traceFilePath);\n      const resolvedTraceDir = path.resolve(traceDir);\n      if (!resolvedTracePath.startsWith(resolvedTraceDir)) {\n        console.error(\n          `⚠️ Security: Attempted path traversal detected. Check name: ${checkName}, resolved path: ${resolvedTracePath}`\n        );\n        return null;\n      }\n\n      // Initialize simple telemetry\n      const telemetry = new SimpleTelemetry({\n        enableFile: true,\n        filePath: traceFilePath,\n        enableConsole: false,\n      });\n\n      const tracer = new SimpleAppTracer(telemetry, sessionId);\n\n      console.error(`📊 Simple tracing enabled, will save to: ${traceFilePath}`);\n\n      // If in GitHub Actions, log the path for artifact upload\n      if (process.env.GITHUB_ACTIONS) {\n        console.log(`::notice title=AI Trace::Trace will be saved to ${traceFilePath}`);\n        console.log(`::set-output name=trace-path::${traceFilePath}`);\n      }\n\n      // Return with SimpleTelemetry\n      return {\n        tracer,\n        telemetryConfig: telemetry,\n        filePath: traceFilePath,\n      };\n    }\n\n    console.error('⚠️ Telemetry classes not available in ProbeAgent, skipping tracing');\n    return null;\n  } catch (error) {\n    console.error('⚠️ Warning: Failed to initialize tracing:', error);\n    return null;\n  }\n}\n","import { ProbeAgent } from '@probelabs/probe';\n\n/**\n * Extended ProbeAgent interface that includes tracing properties\n */\ninterface TracedProbeAgent extends ProbeAgent {\n  tracer?: any; // AppTracer removed from probe\n  _telemetryConfig?: any; // TelemetryConfig removed from probe\n  _traceFilePath?: string;\n}\n\n/**\n * Registry to manage active ProbeAgent sessions for session reuse\n */\nexport class SessionRegistry {\n  private static instance: SessionRegistry;\n  private sessions: Map<string, TracedProbeAgent> = new Map();\n  private exitHandlerRegistered = false;\n\n  private constructor() {\n    // Register process exit handlers to cleanup sessions\n    this.registerExitHandlers();\n  }\n\n  /**\n   * Get the singleton instance of SessionRegistry\n   */\n  public static getInstance(): SessionRegistry {\n    if (!SessionRegistry.instance) {\n      SessionRegistry.instance = new SessionRegistry();\n    }\n    return SessionRegistry.instance;\n  }\n\n  /**\n   * Register a ProbeAgent session\n   */\n  public registerSession(sessionId: string, agent: TracedProbeAgent): void {\n    console.error(`🔄 Registering AI session: ${sessionId}`);\n    this.sessions.set(sessionId, agent);\n  }\n\n  /**\n   * Get an existing ProbeAgent session\n   */\n  public getSession(sessionId: string): TracedProbeAgent | undefined {\n    const agent = this.sessions.get(sessionId);\n    if (agent) {\n      console.error(`♻️  Reusing AI session: ${sessionId}`);\n    }\n    return agent;\n  }\n\n  /**\n   * Remove a session from the registry\n   */\n  public unregisterSession(sessionId: string): void {\n    if (this.sessions.has(sessionId)) {\n      console.error(`🗑️  Unregistering AI session: ${sessionId}`);\n      const agent = this.sessions.get(sessionId);\n      this.sessions.delete(sessionId);\n\n      // Cleanup the ProbeAgent instance to prevent hanging processes\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      if (agent && typeof (agent as any).cleanup === 'function') {\n        try {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (agent as any).cleanup();\n        } catch (error) {\n          console.error(`⚠️  Warning: Failed to cleanup ProbeAgent: ${error}`);\n        }\n      }\n    }\n  }\n\n  /**\n   * Clear all sessions (useful for cleanup)\n   */\n  public clearAllSessions(): void {\n    console.error(`🧹 Clearing all AI sessions (${this.sessions.size} sessions)`);\n\n    // Cleanup each ProbeAgent instance before clearing\n    for (const [, agent] of this.sessions.entries()) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      if (agent && typeof (agent as any).cleanup === 'function') {\n        try {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (agent as any).cleanup();\n        } catch {\n          // Silent fail during bulk cleanup\n        }\n      }\n    }\n\n    this.sessions.clear();\n  }\n\n  /**\n   * Get all active session IDs\n   */\n  public getActiveSessionIds(): string[] {\n    return Array.from(this.sessions.keys());\n  }\n\n  /**\n   * Check if a session exists\n   */\n  public hasSession(sessionId: string): boolean {\n    return this.sessions.has(sessionId);\n  }\n\n  /**\n   * Clone a session with a new session ID using ProbeAgent's official clone() method\n   * This uses ProbeAgent's built-in cloning which automatically handles:\n   * - Intelligent filtering of internal messages (schema reminders, tool prompts, etc.)\n   * - Preserving system message for cache efficiency\n   * - Deep copying conversation history\n   * - Copying agent configuration\n   */\n  public async cloneSession(\n    sourceSessionId: string,\n    newSessionId: string,\n    checkName?: string\n  ): Promise<ProbeAgent | undefined> {\n    const sourceAgent = this.sessions.get(sourceSessionId);\n    if (!sourceAgent) {\n      console.error(`⚠️  Cannot clone session: ${sourceSessionId} not found`);\n      return undefined;\n    }\n\n    try {\n      // Use ProbeAgent's official clone() method with options\n      // This handles intelligent message filtering automatically\n      const clonedAgent = (sourceAgent as any).clone({\n        sessionId: newSessionId,\n        stripInternalMessages: true, // Remove schema reminders, tool prompts, etc.\n        keepSystemMessage: true, // Keep for cache efficiency\n        deepCopy: true, // Safe deep copy of history\n      }) as TracedProbeAgent;\n\n      // Set up tracing for cloned session if debug mode is enabled\n      if ((sourceAgent as any).debug && checkName) {\n        try {\n          const { initializeTracer } = await import('./utils/tracer-init');\n          const tracerResult = await initializeTracer(newSessionId, checkName);\n          if (tracerResult) {\n            clonedAgent.tracer = tracerResult.tracer;\n            // Store telemetry config and trace file path for proper shutdown\n            clonedAgent._telemetryConfig = tracerResult.telemetryConfig;\n            clonedAgent._traceFilePath = tracerResult.filePath;\n          }\n        } catch (traceError) {\n          console.error(\n            '⚠️  Warning: Failed to initialize tracing for cloned session:',\n            traceError\n          );\n        }\n      }\n\n      // Initialize MCP tools if the source agent had them initialized\n      if (\n        (sourceAgent as any)._mcpInitialized &&\n        typeof (clonedAgent as any).initialize === 'function'\n      ) {\n        try {\n          await (clonedAgent as any).initialize();\n          console.error(`🔧 Initialized MCP tools for cloned session`);\n        } catch (initError) {\n          console.error(`⚠️  Warning: Failed to initialize cloned agent: ${initError}`);\n        }\n      }\n\n      // Get history length for logging\n      const historyLength = (clonedAgent as any).history?.length || 0;\n\n      console.error(\n        `📋 Cloned session ${sourceSessionId} → ${newSessionId} using ProbeAgent.clone() (${historyLength} messages, internal messages filtered)`\n      );\n\n      // Register the cloned session\n      this.registerSession(newSessionId, clonedAgent);\n\n      return clonedAgent;\n    } catch (error) {\n      console.error(`⚠️  Failed to clone session ${sourceSessionId}:`, error);\n      return undefined;\n    }\n  }\n\n  /**\n   * Register process exit handlers to cleanup sessions on exit\n   */\n  private registerExitHandlers(): void {\n    if (this.exitHandlerRegistered) {\n      return;\n    }\n\n    const cleanupAndExit = (signal: string) => {\n      if (this.sessions.size > 0) {\n        console.error(`\\n🧹 [${signal}] Cleaning up ${this.sessions.size} active AI sessions...`);\n        this.clearAllSessions();\n      }\n    };\n\n    // Handle normal process exit\n    process.on('exit', () => {\n      if (this.sessions.size > 0) {\n        console.error(`🧹 [exit] Cleaning up ${this.sessions.size} active AI sessions...`);\n        // Note: async operations won't complete here, but sync cleanup methods will\n        for (const [, agent] of this.sessions.entries()) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          if (agent && typeof (agent as any).cleanup === 'function') {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              (agent as any).cleanup();\n            } catch {\n              // Silent fail on exit\n            }\n          }\n        }\n        this.sessions.clear();\n      }\n    });\n\n    // Handle SIGINT (Ctrl+C)\n    process.on('SIGINT', () => {\n      cleanupAndExit('SIGINT');\n      process.exit(0);\n    });\n\n    // Handle SIGTERM\n    process.on('SIGTERM', () => {\n      cleanupAndExit('SIGTERM');\n      process.exit(0);\n    });\n\n    this.exitHandlerRegistered = true;\n  }\n}\n","import { extract } from '@probelabs/probe';\nimport * as path from 'path';\n\n/**\n * Process diff content using the outline-diff format from @probelabs/probe\n * This extracts a structured outline from the diff without requiring a temporary file\n */\nexport async function processDiffWithOutline(diffContent: string): Promise<string> {\n  if (!diffContent || diffContent.trim().length === 0) {\n    return diffContent;\n  }\n\n  try {\n    // Set PROBE_PATH to use the bundled binary with outline-diff support\n    // The SDK by default may download an older binary that doesn't support outline-diff\n    const originalProbePath = process.env.PROBE_PATH;\n\n    // Try multiple possible locations for the probe binary\n    // When bundled with ncc, __dirname may not be reliable\n    const fs = require('fs');\n    const possiblePaths = [\n      // Relative to current working directory (most common in production)\n      path.join(process.cwd(), 'node_modules/@probelabs/probe/bin/probe-binary'),\n      // Relative to __dirname (for unbundled development)\n      path.join(__dirname, '../..', 'node_modules/@probelabs/probe/bin/probe-binary'),\n      // Relative to dist directory (for bundled CLI)\n      path.join(__dirname, 'node_modules/@probelabs/probe/bin/probe-binary'),\n    ];\n\n    let probeBinaryPath: string | undefined;\n    for (const candidatePath of possiblePaths) {\n      if (fs.existsSync(candidatePath)) {\n        probeBinaryPath = candidatePath;\n        break;\n      }\n    }\n\n    // Only process if binary exists, otherwise fall back to original diff\n    if (!probeBinaryPath) {\n      if (process.env.DEBUG === '1' || process.env.VERBOSE === '1') {\n        console.error('Probe binary not found. Tried:', possiblePaths);\n      }\n      return diffContent;\n    }\n\n    process.env.PROBE_PATH = probeBinaryPath;\n\n    // Use extract with content parameter (can be string or Buffer)\n    // The TypeScript types haven't been updated yet, but the runtime supports it\n    // Add timeout to avoid hanging\n    const extractPromise = (extract as any)({\n      content: diffContent,\n      format: 'outline-diff',\n      allowTests: true, // Allow test files and test code blocks in extraction results\n    });\n\n    const timeoutPromise = new Promise((_, reject) => {\n      setTimeout(() => reject(new Error('Extract timeout after 30s')), 30000);\n    });\n\n    const result = await Promise.race([extractPromise, timeoutPromise]);\n\n    // Restore original PROBE_PATH\n    if (originalProbePath !== undefined) {\n      process.env.PROBE_PATH = originalProbePath;\n    } else {\n      delete process.env.PROBE_PATH;\n    }\n\n    // Return the processed outline diff\n    return typeof result === 'string' ? result : JSON.stringify(result);\n  } catch (error) {\n    // If outline-diff processing fails, fall back to the original diff\n    // Use console.error instead of console.warn to avoid polluting JSON output\n    if (process.env.DEBUG === '1' || process.env.VERBOSE === '1') {\n      console.error('Failed to process diff with outline-diff format:', error);\n    }\n    return diffContent;\n  }\n}\n","import { ProbeAgent } from '@probelabs/probe';\nimport type { ProbeAgentOptions } from '@probelabs/probe';\nimport { PRInfo } from './pr-analyzer';\nimport { ReviewSummary, ReviewIssue } from './reviewer';\nimport { SessionRegistry } from './session-registry';\nimport { logger } from './logger';\nimport { initializeTracer } from './utils/tracer-init';\nimport { processDiffWithOutline } from './utils/diff-processor';\n\n/**\n * Helper function to log debug messages using the centralized logger\n */\nfunction log(...args: unknown[]): void {\n  logger.debug(args.join(' '));\n}\n\n/**\n * Extended ProbeAgent interface that includes tracing properties\n */\ninterface TracedProbeAgent extends ProbeAgent {\n  tracer?: unknown; // SimpleTelemetry tracer (probe removed AppTracer)\n  _telemetryConfig?: unknown; // SimpleTelemetry config (probe removed TelemetryConfig)\n  _traceFilePath?: string;\n}\n\n/**\n * Extended ProbeAgentOptions interface that includes tracing properties\n */\ninterface TracedProbeAgentOptions extends ProbeAgentOptions {\n  tracer?: unknown; // SimpleTelemetry tracer\n  _telemetryConfig?: unknown; // SimpleTelemetry config\n  _traceFilePath?: string;\n}\n\nexport interface AIReviewConfig {\n  apiKey?: string; // From env: GOOGLE_API_KEY, ANTHROPIC_API_KEY, OPENAI_API_KEY, CLAUDE_CODE_API_KEY, or AWS credentials\n  model?: string; // From env: MODEL_NAME (e.g., gemini-2.5-pro-preview-06-05)\n  timeout?: number; // Default: 600000ms (10 minutes)\n  provider?: 'google' | 'anthropic' | 'openai' | 'bedrock' | 'mock' | 'claude-code';\n  debug?: boolean; // Enable debug mode\n  tools?: Array<{ name: string; [key: string]: unknown }>; // (unused) Legacy tool listing\n  // Pass-through MCP server configuration for ProbeAgent\n  mcpServers?: Record<string, import('./types/config').McpServerConfig>;\n  // Enable delegate tool for task distribution to subagents\n  enableDelegate?: boolean;\n}\n\nexport interface AIDebugInfo {\n  /** The prompt sent to the AI */\n  prompt: string;\n  /** Raw response from the AI service */\n  rawResponse: string;\n  /** Provider used (google, anthropic, openai) */\n  provider: string;\n  /** Model used */\n  model: string;\n  /** API key source (for privacy, just show which env var) */\n  apiKeySource: string;\n  /** Processing time in milliseconds */\n  processingTime: number;\n  /** Prompt length in characters */\n  promptLength: number;\n  /** Response length in characters */\n  responseLength: number;\n  /** Any errors encountered */\n  errors?: string[];\n  /** Whether JSON parsing succeeded */\n  jsonParseSuccess: boolean;\n  /** Schema used for response validation */\n  schema?: string;\n  /** Schema name/type requested */\n  schemaName?: string;\n  /** Checks executed during this review */\n  checksExecuted?: string[];\n  /** Whether parallel execution was used */\n  parallelExecution?: boolean;\n  /** Timestamp when request was made */\n  timestamp: string;\n  /** Total API calls made */\n  totalApiCalls?: number;\n  /** Details about API calls made */\n  apiCallDetails?: Array<{\n    checkName: string;\n    provider: string;\n    model: string;\n    processingTime: number;\n    success: boolean;\n  }>;\n}\n\n// REMOVED: ReviewFocus type - only use custom prompts from .visor.yaml\n\ninterface AIResponseFormat {\n  // Array of issues for code review\n  issues?: Array<{\n    file: string;\n    line: number;\n    endLine?: number;\n    ruleId: string;\n    message: string;\n    severity: 'info' | 'warning' | 'error' | 'critical';\n    category: 'security' | 'performance' | 'style' | 'logic' | 'documentation';\n    suggestion?: string;\n    replacement?: string;\n  }>;\n}\n\nexport class AIReviewService {\n  private config: AIReviewConfig;\n  private sessionRegistry: SessionRegistry;\n\n  constructor(config: AIReviewConfig = {}) {\n    this.config = {\n      timeout: 600000, // Increased timeout to 10 minutes for AI responses\n      ...config,\n    };\n\n    this.sessionRegistry = SessionRegistry.getInstance();\n\n    // Auto-detect provider and API key from environment\n    if (!this.config.apiKey) {\n      if (process.env.CLAUDE_CODE_API_KEY) {\n        this.config.apiKey = process.env.CLAUDE_CODE_API_KEY;\n        this.config.provider = 'claude-code';\n      } else if (process.env.GOOGLE_API_KEY) {\n        this.config.apiKey = process.env.GOOGLE_API_KEY;\n        this.config.provider = 'google';\n      } else if (process.env.ANTHROPIC_API_KEY) {\n        this.config.apiKey = process.env.ANTHROPIC_API_KEY;\n        this.config.provider = 'anthropic';\n      } else if (process.env.OPENAI_API_KEY) {\n        this.config.apiKey = process.env.OPENAI_API_KEY;\n        this.config.provider = 'openai';\n      } else if (\n        // Check for AWS Bedrock credentials\n        (process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY) ||\n        process.env.AWS_BEDROCK_API_KEY\n      ) {\n        // For Bedrock, we don't set apiKey as it uses AWS credentials\n        // ProbeAgent will handle the authentication internally\n        this.config.provider = 'bedrock';\n        // Set a placeholder to pass validation\n        this.config.apiKey = 'AWS_CREDENTIALS';\n      }\n    }\n\n    // Auto-detect model from environment\n    if (!this.config.model && process.env.MODEL_NAME) {\n      this.config.model = process.env.MODEL_NAME;\n    }\n  }\n\n  // NOTE: per request, no additional redaction/encryption helpers are used.\n\n  /**\n   * Execute AI review using probe agent\n   */\n  async executeReview(\n    prInfo: PRInfo,\n    customPrompt: string,\n    schema?: string | Record<string, unknown>,\n    checkName?: string,\n    sessionId?: string\n  ): Promise<ReviewSummary> {\n    const startTime = Date.now();\n    const timestamp = new Date().toISOString();\n\n    // Build prompt from custom instructions\n    const prompt = await this.buildCustomPrompt(prInfo, customPrompt, schema);\n\n    log(`Executing AI review with ${this.config.provider} provider...`);\n    log(`🔧 Debug: Raw schema parameter: ${JSON.stringify(schema)} (type: ${typeof schema})`);\n    log(`Schema type: ${schema || 'none (no schema)'}`);\n\n    let debugInfo: AIDebugInfo | undefined;\n    if (this.config.debug) {\n      debugInfo = {\n        prompt,\n        rawResponse: '',\n        provider: this.config.provider || 'unknown',\n        model: this.config.model || 'default',\n        apiKeySource: this.getApiKeySource(),\n        processingTime: 0,\n        promptLength: prompt.length,\n        responseLength: 0,\n        errors: [],\n        jsonParseSuccess: false,\n        timestamp,\n        schemaName: typeof schema === 'object' ? 'custom' : schema,\n        schema: undefined, // Will be populated when schema is loaded\n      };\n    }\n\n    // Handle mock model/provider first (no API key needed)\n    if (this.config.model === 'mock' || this.config.provider === 'mock') {\n      log('🎭 Using mock AI model/provider for testing - skipping API key validation');\n    } else {\n      // Check if API key is available for real AI models\n      if (!this.config.apiKey) {\n        const errorMessage =\n          'No API key configured. Please set GOOGLE_API_KEY, ANTHROPIC_API_KEY, OPENAI_API_KEY environment variable, or configure AWS credentials for Bedrock (AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY).';\n\n        // In debug mode, return a result that still renders for custom schemas\n        if (debugInfo) {\n          debugInfo.errors = [errorMessage];\n          debugInfo.processingTime = Date.now() - startTime;\n          debugInfo.rawResponse = 'API call not attempted - no API key configured';\n\n          // Detect custom schemas (issue-assistant, overview, inline, file-based)\n          const isCustomSchema =\n            (typeof schema === 'string' && schema !== 'code-review') || typeof schema === 'object';\n\n          if (isCustomSchema) {\n            const out = {\n              // Provide a friendly, bounded fallback so built-in templates render\n              text: '⚠️ AI provider is not configured for this run. Set GOOGLE_API_KEY/ANTHROPIC_API_KEY/OPENAI_API_KEY or AWS credentials to enable real responses.\\n\\nThis is a placeholder response so your workflow still posts a comment.',\n            } as Record<string, unknown>;\n            const res: any = {\n              issues: [],\n              output: out,\n              debug: debugInfo,\n            };\n            return res;\n          }\n\n          // Non-custom schemas: return error as an issue (previous behavior)\n          return {\n            issues: [\n              {\n                file: 'system',\n                line: 0,\n                ruleId: 'system/api-key-missing',\n                message: errorMessage,\n                severity: 'error',\n                category: 'logic',\n              },\n            ],\n            debug: debugInfo,\n          };\n        }\n\n        throw new Error(errorMessage);\n      }\n    }\n\n    try {\n      const call = this.callProbeAgent(prompt, schema, debugInfo, checkName, sessionId);\n      const timeoutMs = Math.max(0, this.config.timeout || 0);\n      const { response, effectiveSchema } =\n        timeoutMs > 0 ? await this.withTimeout(call, timeoutMs, 'AI review') : await call;\n      const processingTime = Date.now() - startTime;\n\n      if (debugInfo) {\n        debugInfo.rawResponse = response;\n        debugInfo.responseLength = response.length;\n        debugInfo.processingTime = processingTime;\n      }\n\n      const result = this.parseAIResponse(response, debugInfo, effectiveSchema);\n\n      if (debugInfo) {\n        result.debug = debugInfo;\n      }\n\n      return result;\n    } catch (error) {\n      if (debugInfo) {\n        debugInfo.errors = [error instanceof Error ? error.message : String(error)];\n        debugInfo.processingTime = Date.now() - startTime;\n\n        // In debug mode, return a review with the error captured\n        return {\n          issues: [\n            {\n              file: 'system',\n              line: 0,\n              ruleId: 'system/ai-execution-error',\n              message: error instanceof Error ? error.message : String(error),\n              severity: 'error',\n              category: 'logic',\n            },\n          ],\n          debug: debugInfo,\n        };\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Execute AI review using session reuse - reuses an existing ProbeAgent session\n   * @param sessionMode - 'clone' (default) clones history, 'append' shares history\n   */\n  async executeReviewWithSessionReuse(\n    prInfo: PRInfo,\n    customPrompt: string,\n    parentSessionId: string,\n    schema?: string | Record<string, unknown>,\n    checkName?: string,\n    sessionMode: 'clone' | 'append' = 'clone'\n  ): Promise<ReviewSummary> {\n    const startTime = Date.now();\n    const timestamp = new Date().toISOString();\n\n    // Get the existing session\n    const existingAgent = this.sessionRegistry.getSession(parentSessionId);\n    if (!existingAgent) {\n      throw new Error(\n        `Session not found for reuse: ${parentSessionId}. Ensure the parent check completed successfully.`\n      );\n    }\n\n    // Build prompt from custom instructions\n    // When reusing session, skip PR context since it's already in the conversation history\n    const prompt = await this.buildCustomPrompt(prInfo, customPrompt, schema, {\n      skipPRContext: true,\n    });\n\n    // Determine which agent to use based on session mode\n    let agentToUse: typeof existingAgent;\n    let currentSessionId: string;\n\n    if (sessionMode === 'clone') {\n      // Clone the session - creates a new agent with copied history\n      // Include check name in the session ID for better tracing\n      currentSessionId = `${checkName}-session-${Date.now()}`;\n      log(\n        `📋 Cloning AI session ${parentSessionId} → ${currentSessionId} for ${checkName} check...`\n      );\n\n      const clonedAgent = await this.sessionRegistry.cloneSession(\n        parentSessionId,\n        currentSessionId,\n        checkName // Pass checkName for tracing\n      );\n      if (!clonedAgent) {\n        throw new Error(`Failed to clone session ${parentSessionId}`);\n      }\n      agentToUse = clonedAgent;\n    } else {\n      // Append mode - use the same agent instance\n      log(`🔄 Appending to AI session ${parentSessionId} (shared history)...`);\n      agentToUse = existingAgent;\n      currentSessionId = parentSessionId;\n    }\n\n    log(`🔧 Debug: Raw schema parameter: ${JSON.stringify(schema)} (type: ${typeof schema})`);\n    log(`📋 Schema for this check: ${schema || 'none (no schema)'}`);\n    if (sessionMode === 'clone') {\n      log(`✅ Cloned agent will use NEW schema (${schema}) - parent schema does not persist`);\n      log(`🔄 Clone operation ensures fresh agent with copied history but new configuration`);\n    } else {\n      log(`🔄 Append mode - using existing agent instance with shared history and configuration`);\n    }\n\n    let debugInfo: AIDebugInfo | undefined;\n    if (this.config.debug) {\n      debugInfo = {\n        prompt,\n        rawResponse: '',\n        provider: this.config.provider || 'unknown',\n        model: this.config.model || 'default',\n        apiKeySource: this.getApiKeySource(),\n        processingTime: 0,\n        promptLength: prompt.length,\n        responseLength: 0,\n        errors: [],\n        jsonParseSuccess: false,\n        timestamp,\n        schemaName: typeof schema === 'object' ? 'custom' : schema,\n        schema: undefined, // Will be populated when schema is loaded\n      };\n    }\n\n    try {\n      // Use the determined agent (cloned or original)\n      const call = this.callProbeAgentWithExistingSession(\n        agentToUse,\n        prompt,\n        schema,\n        debugInfo,\n        checkName\n      );\n      const timeoutMs = Math.max(0, this.config.timeout || 0);\n      const { response, effectiveSchema } =\n        timeoutMs > 0 ? await this.withTimeout(call, timeoutMs, 'AI review (session)') : await call;\n      const processingTime = Date.now() - startTime;\n\n      if (debugInfo) {\n        debugInfo.rawResponse = response;\n        debugInfo.responseLength = response.length;\n        debugInfo.processingTime = processingTime;\n      }\n\n      const result = this.parseAIResponse(response, debugInfo, effectiveSchema);\n\n      if (debugInfo) {\n        result.debug = debugInfo;\n      }\n\n      // Include the session ID in the result for cleanup tracking\n      // Only include if we created a new cloned session\n      if (sessionMode === 'clone' && currentSessionId !== parentSessionId) {\n        result.sessionId = currentSessionId;\n      }\n\n      return result;\n    } catch (error) {\n      if (debugInfo) {\n        debugInfo.errors = [error instanceof Error ? error.message : String(error)];\n        debugInfo.processingTime = Date.now() - startTime;\n\n        // In debug mode, return a review with the error captured\n        return {\n          issues: [\n            {\n              file: 'system',\n              line: 0,\n              ruleId: 'system/ai-session-reuse-error',\n              message: error instanceof Error ? error.message : String(error),\n              severity: 'error',\n              category: 'logic',\n            },\n          ],\n          debug: debugInfo,\n        };\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Promise timeout helper that rejects after ms if unresolved\n   */\n  private async withTimeout<T>(p: Promise<T>, ms: number, label = 'operation'): Promise<T> {\n    let timer: NodeJS.Timeout | undefined;\n    try {\n      const timeout = new Promise<never>((_, reject) => {\n        timer = setTimeout(() => reject(new Error(`${label} timed out after ${ms}ms`)), ms);\n      });\n      return (await Promise.race([p, timeout])) as T;\n    } finally {\n      if (timer) clearTimeout(timer);\n    }\n  }\n\n  /**\n   * Register a new AI session in the session registry\n   */\n  registerSession(sessionId: string, agent: TracedProbeAgent): void {\n    this.sessionRegistry.registerSession(sessionId, agent);\n  }\n\n  /**\n   * Cleanup a session from the registry\n   */\n  cleanupSession(sessionId: string): void {\n    this.sessionRegistry.unregisterSession(sessionId);\n  }\n\n  /**\n   * Build a custom prompt for AI review with XML-formatted data\n   */\n  private async buildCustomPrompt(\n    prInfo: PRInfo,\n    customInstructions: string,\n    schema?: string | Record<string, unknown>,\n    options?: { skipPRContext?: boolean; checkName?: string }\n  ): Promise<string> {\n    // When reusing sessions, skip PR context to avoid sending duplicate diff data\n    const skipPRContext = options?.skipPRContext === true;\n\n    // Check if we're using the code-review schema\n    const isCodeReviewSchema = schema === 'code-review';\n\n    const prContext = skipPRContext ? '' : await this.formatPRContext(prInfo, isCodeReviewSchema);\n    const isIssue = (prInfo as PRInfo & { isIssue?: boolean }).isIssue === true;\n\n    if (isIssue) {\n      // Issue context - no code analysis needed\n      if (skipPRContext) {\n        // Session reuse: just send new instructions\n        return `<instructions>\n${customInstructions}\n</instructions>`;\n      }\n\n      return `<review_request>\n  <instructions>\n${customInstructions}\n  </instructions>\n\n  <context>\n${prContext}\n  </context>\n\n  <rules>\n    <rule>Understand the issue context and requirements from the XML data structure</rule>\n    <rule>Provide helpful, actionable guidance based on the issue details</rule>\n    <rule>Be constructive and supportive in your analysis</rule>\n    <rule>Consider project conventions and patterns when making recommendations</rule>\n    <rule>Suggest practical solutions or next steps that address the specific concern</rule>\n    <rule>Focus on addressing the specific concern raised in the issue</rule>\n    <rule>Reference relevant XML elements like metadata, description, labels, assignees when providing context</rule>\n  </rules>\n</review_request>`;\n    }\n\n    // Only add review_request wrapper and PR-specific rules for code-review schema\n    if (isCodeReviewSchema) {\n      // PR context with code-review schema - structured XML format\n      const analysisType = prInfo.isIncremental ? 'INCREMENTAL' : 'FULL';\n\n      if (skipPRContext) {\n        // Session reuse: just send new instructions without repeating the context\n        return `<instructions>\n${customInstructions}\n</instructions>\n\n<reminder>\n  <rule>The code context and diff were provided in the previous message</rule>\n  <rule>Focus on the new analysis instructions above</rule>\n  <rule>Only analyze code that appears with + (additions) or - (deletions) in the diff sections</rule>\n  <rule>STRICT OUTPUT POLICY: Report only actual problems, risks, or deficiencies</rule>\n  <rule>SEVERITY ASSIGNMENT: Assign severity ONLY to problems introduced or left unresolved by this change</rule>\n</reminder>`;\n      }\n\n      return `<review_request>\n  <analysis_type>${analysisType}</analysis_type>\n\n  <analysis_focus>\n    ${\n      analysisType === 'INCREMENTAL'\n        ? 'You are analyzing a NEW COMMIT added to an existing PR. Focus on the changes in the commit_diff section for this specific commit.'\n        : 'You are analyzing the COMPLETE PR. Review all changes in the full_diff section.'\n    }\n  </analysis_focus>\n\n  <instructions>\n${customInstructions}\n  </instructions>\n\n  <context>\n${prContext}\n  </context>\n\n  <rules>\n    <rule>Only analyze code that appears with + (additions) or - (deletions) in the diff sections</rule>\n    <rule>Ignore unchanged code unless directly relevant to understanding a change</rule>\n    <rule>Line numbers in your response should match actual file line numbers from the diff</rule>\n    <rule>Focus on real issues, not nitpicks or cosmetic concerns</rule>\n    <rule>Provide actionable, specific feedback with clear remediation steps</rule>\n    <rule>For INCREMENTAL analysis, ONLY review changes in commit_diff section</rule>\n    <rule>For FULL analysis, review all changes in full_diff section</rule>\n    <rule>Reference specific XML elements like files_summary, metadata when providing context</rule>\n    <rule>STRICT OUTPUT POLICY: Report only actual problems, risks, or deficiencies. Do not write praise, congratulations, or celebratory text. Do not create issues that merely restate improvements or say \"no action needed\".</rule>\n    <rule>SEVERITY ASSIGNMENT: Assign severity ONLY to problems introduced or left unresolved by this change (critical/error/warning/info as appropriate). Do NOT create issue entries solely to acknowledge improvements; if no problems exist, return zero issues.</rule>\n  </rules>\n</review_request>`;\n    }\n\n    // For non-code-review schemas, just provide instructions and context without review-specific wrapper\n    if (skipPRContext) {\n      // Session reuse: just send new instructions\n      return `<instructions>\n${customInstructions}\n</instructions>`;\n    }\n\n    return `<instructions>\n${customInstructions}\n</instructions>\n\n<context>\n${prContext}\n</context>`;\n  }\n\n  // REMOVED: Built-in prompts - only use custom prompts from .visor.yaml\n\n  // REMOVED: getFocusInstructions - only use custom prompts from .visor.yaml\n\n  /**\n   * Format PR or Issue context for the AI using XML structure\n   */\n  private async formatPRContext(prInfo: PRInfo, isCodeReviewSchema?: boolean): Promise<string> {\n    // Check if this is an issue (not a PR)\n    const prContextInfo = prInfo as PRInfo & {\n      isPRContext?: boolean;\n      includeCodeContext?: boolean;\n    };\n    const isIssue = prContextInfo.isIssue === true;\n\n    // Check if we should include code context (diffs)\n    const isPRContext = prContextInfo.isPRContext === true;\n    // In PR context, always include diffs. Otherwise check the flag.\n    const includeCodeContext = isPRContext || prContextInfo.includeCodeContext !== false;\n\n    // Log the decision for transparency (debug level)\n    if (isPRContext) {\n      log('🔍 Including full code diffs in AI context (PR mode)');\n    } else if (!includeCodeContext) {\n      log('📊 Including only file summary in AI context (no diffs)');\n    } else {\n      log('🔍 Including code diffs in AI context');\n    }\n\n    if (isIssue) {\n      // Format as issue context\n      let context = `<issue>\n  <!-- Core issue metadata including identification, status, and timeline information -->\n  <metadata>\n    <number>${prInfo.number}</number>\n    <title>${this.escapeXml(prInfo.title)}</title>\n    <author>${prInfo.author}</author>\n    <state>${(prInfo as PRInfo & { eventContext?: { issue?: { state?: string; created_at?: string; updated_at?: string; comments?: number } } }).eventContext?.issue?.state || 'open'}</state>\n    <created_at>${(prInfo as PRInfo & { eventContext?: { issue?: { state?: string; created_at?: string; updated_at?: string; comments?: number } } }).eventContext?.issue?.created_at || ''}</created_at>\n    <updated_at>${(prInfo as PRInfo & { eventContext?: { issue?: { state?: string; updated_at?: string; comments?: number } } }).eventContext?.issue?.updated_at || ''}</updated_at>\n    <comments_count>${(prInfo as PRInfo & { eventContext?: { issue?: { comments?: number } } }).eventContext?.issue?.comments || 0}</comments_count>\n  </metadata>`;\n\n      // Add issue body/description if available\n      if (prInfo.body) {\n        context += `\n  <!-- Full issue description and body text provided by the issue author -->\n  <description>\n${this.escapeXml(prInfo.body)}\n  </description>`;\n      }\n\n      // Add labels if available\n      const eventContext = prInfo as PRInfo & {\n        eventContext?: { issue?: { labels?: Array<{ name?: string } | string> } };\n      };\n      const labels = eventContext.eventContext?.issue?.labels;\n      if (labels && labels.length > 0) {\n        context += `\n  <!-- Applied labels for issue categorization and organization -->\n  <labels>`;\n        labels.forEach((label: { name?: string } | string) => {\n          const labelName = typeof label === 'string' ? label : label.name || 'unknown';\n          context += `\n    <label>${this.escapeXml(labelName)}</label>`;\n        });\n        context += `\n  </labels>`;\n      }\n\n      // Add assignees if available\n      const assignees = (\n        prInfo as PRInfo & {\n          eventContext?: { issue?: { assignees?: Array<{ login?: string } | string> } };\n        }\n      ).eventContext?.issue?.assignees;\n      if (assignees && assignees.length > 0) {\n        context += `\n  <!-- Users assigned to work on this issue -->\n  <assignees>`;\n        assignees.forEach((assignee: { login?: string } | string) => {\n          const assigneeName =\n            typeof assignee === 'string' ? assignee : assignee.login || 'unknown';\n          context += `\n    <assignee>${this.escapeXml(assigneeName)}</assignee>`;\n        });\n        context += `\n  </assignees>`;\n      }\n\n      // Add milestone if available\n      const milestone = (\n        prInfo as PRInfo & {\n          eventContext?: {\n            issue?: { milestone?: { title?: string; state?: string; due_on?: string } };\n          };\n        }\n      ).eventContext?.issue?.milestone;\n      if (milestone) {\n        context += `\n  <!-- Associated project milestone information -->\n  <milestone>\n    <title>${this.escapeXml(milestone.title || '')}</title>\n    <state>${milestone.state || 'open'}</state>\n    <due_on>${milestone.due_on || ''}</due_on>\n  </milestone>`;\n      }\n\n      // Add current/triggering comment if this is a comment event\n      const triggeringComment = (\n        prInfo as PRInfo & {\n          eventContext?: {\n            comment?: {\n              user?: { login?: string };\n              created_at?: string;\n              body?: string;\n              id?: number;\n            };\n          };\n        }\n      ).eventContext?.comment;\n      if (triggeringComment) {\n        context += `\n  <!-- The comment that triggered this analysis -->\n  <triggering_comment>\n    <author>${this.escapeXml(triggeringComment.user?.login || 'unknown')}</author>\n    <created_at>${triggeringComment.created_at || ''}</created_at>\n    <body>${this.escapeXml(triggeringComment.body || '')}</body>\n  </triggering_comment>`;\n      }\n\n      // Add comment history (excluding the current comment if it exists)\n      const issueComments = (\n        prInfo as PRInfo & {\n          comments?: Array<{ id?: number; author?: string; body?: string; createdAt?: string }>;\n        }\n      ).comments;\n      if (issueComments && issueComments.length > 0) {\n        // Filter out the triggering comment from history if present\n        let historicalComments = triggeringComment\n          ? issueComments.filter(c => c.id !== triggeringComment.id)\n          : issueComments;\n\n        // For code-review schema checks, filter out previous Visor code-review comments to avoid self-bias\n        // Comment IDs look like: <!-- visor-comment-id:pr-review-244-review -->\n        if (isCodeReviewSchema) {\n          historicalComments = historicalComments.filter(\n            c => !c.body || !c.body.includes('visor-comment-id:pr-review-')\n          );\n        }\n\n        if (historicalComments.length > 0) {\n          context += `\n  <!-- Previous comments in chronological order (excluding triggering comment) -->\n  <comment_history>`;\n          historicalComments.forEach(comment => {\n            context += `\n    <comment>\n      <author>${this.escapeXml(comment.author || 'unknown')}</author>\n      <created_at>${comment.createdAt || ''}</created_at>\n      <body>${this.escapeXml(comment.body || '')}</body>\n    </comment>`;\n          });\n          context += `\n  </comment_history>`;\n        }\n      }\n\n      // Close the issue tag\n      context += `\n</issue>`;\n\n      return context;\n    }\n\n    // Original PR context formatting\n    let context = `<pull_request>\n  <!-- Core pull request metadata including identification, branches, and change statistics -->\n  <metadata>\n    <number>${prInfo.number}</number>\n    <title>${this.escapeXml(prInfo.title)}</title>\n    <author>${prInfo.author}</author>\n    <base_branch>${prInfo.base}</base_branch>\n    <target_branch>${prInfo.head}</target_branch>\n    <total_additions>${prInfo.totalAdditions}</total_additions>\n    <total_deletions>${prInfo.totalDeletions}</total_deletions>\n    <files_changed_count>${prInfo.files.length}</files_changed_count>\n  </metadata>`;\n\n    // Add PR description if available\n    if (prInfo.body) {\n      context += `\n  <!-- Full pull request description provided by the author -->\n  <description>\n${this.escapeXml(prInfo.body)}\n  </description>`;\n    }\n\n    // Add diffs only if includeCodeContext is true (or in PR mode)\n    if (includeCodeContext) {\n      // Add full diff if available (for complete PR review)\n      if (prInfo.fullDiff) {\n        // Process the diff with outline-diff format for better structure\n        const processedFullDiff = await processDiffWithOutline(prInfo.fullDiff);\n        context += `\n  <!-- Complete unified diff showing all changes in the pull request (processed with outline-diff) -->\n  <full_diff>\n${this.escapeXml(processedFullDiff)}\n  </full_diff>`;\n      }\n\n      // Add incremental commit diff if available (for new commit analysis)\n      if (prInfo.isIncremental) {\n        if (prInfo.commitDiff && prInfo.commitDiff.length > 0) {\n          // Process the commit diff with outline-diff format for better structure\n          const processedCommitDiff = await processDiffWithOutline(prInfo.commitDiff);\n          context += `\n  <!-- Diff of only the latest commit for incremental analysis (processed with outline-diff) -->\n  <commit_diff>\n${this.escapeXml(processedCommitDiff)}\n  </commit_diff>`;\n        } else {\n          // Process the fallback full diff with outline-diff format\n          const processedFallbackDiff = prInfo.fullDiff\n            ? await processDiffWithOutline(prInfo.fullDiff)\n            : '';\n          context += `\n  <!-- Commit diff could not be retrieved - falling back to full diff analysis (processed with outline-diff) -->\n  <commit_diff>\n${this.escapeXml(processedFallbackDiff)}\n  </commit_diff>`;\n        }\n      }\n    } else {\n      // When not including diffs, add a note about it\n      context += `\n  <!-- Code diffs excluded to reduce token usage (no code-review schema detected or disabled by flag) -->`;\n    }\n\n    // Add file summary for context\n    if (prInfo.files.length > 0) {\n      context += `\n  <!-- Summary of all files changed with statistics -->\n  <files_summary>`;\n      prInfo.files.forEach(file => {\n        context += `\n    <file>\n      <filename>${this.escapeXml(file.filename)}</filename>\n      <status>${file.status}</status>\n      <additions>${file.additions}</additions>\n      <deletions>${file.deletions}</deletions>\n    </file>`;\n      });\n      context += `\n  </files_summary>`;\n    }\n\n    // Add current/triggering comment if this is a comment event\n    const triggeringComment = (\n      prInfo as PRInfo & {\n        eventContext?: {\n          comment?: { user?: { login?: string }; created_at?: string; body?: string; id?: number };\n        };\n      }\n    ).eventContext?.comment;\n    if (triggeringComment) {\n      context += `\n  <!-- The comment that triggered this analysis -->\n  <triggering_comment>\n    <author>${this.escapeXml(triggeringComment.user?.login || 'unknown')}</author>\n    <created_at>${triggeringComment.created_at || ''}</created_at>\n    <body>${this.escapeXml(triggeringComment.body || '')}</body>\n  </triggering_comment>`;\n    }\n\n    // Add comment history (excluding the current comment if it exists)\n    const prComments = (\n      prInfo as PRInfo & {\n        comments?: Array<{ id?: number; author?: string; body?: string; createdAt?: string }>;\n      }\n    ).comments;\n    if (prComments && prComments.length > 0) {\n      // Filter out the triggering comment from history if present\n      let historicalComments = triggeringComment\n        ? prComments.filter(c => c.id !== triggeringComment.id)\n        : prComments;\n\n      // For code-review schema checks, filter out previous Visor code-review comments to avoid self-bias\n      // Comment IDs look like: <!-- visor-comment-id:pr-review-244-review -->\n      if (isCodeReviewSchema) {\n        historicalComments = historicalComments.filter(\n          c => !c.body || !c.body.includes('visor-comment-id:pr-review-')\n        );\n      }\n\n      if (historicalComments.length > 0) {\n        context += `\n  <!-- Previous PR comments in chronological order (excluding triggering comment) -->\n  <comment_history>`;\n        historicalComments.forEach(comment => {\n          context += `\n    <comment>\n      <author>${this.escapeXml(comment.author || 'unknown')}</author>\n      <created_at>${comment.createdAt || ''}</created_at>\n      <body>${this.escapeXml(comment.body || '')}</body>\n    </comment>`;\n        });\n        context += `\n  </comment_history>`;\n      }\n    }\n\n    context += `\n</pull_request>`;\n\n    return context;\n  }\n\n  /**\n   * No longer escaping XML - returning text as-is\n   */\n  private escapeXml(text: string): string {\n    return text;\n  }\n\n  /**\n   * Call ProbeAgent with an existing session\n   */\n  private async callProbeAgentWithExistingSession(\n    agent: TracedProbeAgent,\n    prompt: string,\n    schema?: string | Record<string, unknown>,\n    debugInfo?: AIDebugInfo,\n    _checkName?: string\n  ): Promise<{ response: string; effectiveSchema?: string }> {\n    // Handle mock model/provider for testing\n    if (this.config.model === 'mock' || this.config.provider === 'mock') {\n      log('🎭 Using mock AI model/provider for testing (session reuse)');\n      const response = await this.generateMockResponse(prompt, _checkName, schema);\n      return { response, effectiveSchema: typeof schema === 'object' ? 'custom' : schema };\n    }\n\n    log('🔄 Reusing existing ProbeAgent session for AI review...');\n    log(`📝 Prompt length: ${prompt.length} characters`);\n    log(`⚙️ Model: ${this.config.model || 'default'}, Provider: ${this.config.provider || 'auto'}`);\n\n    try {\n      log('🚀 Calling existing ProbeAgent with answer()...');\n\n      // Load and pass the actual schema content if provided (skip for plain schema)\n      let schemaString: string | undefined = undefined;\n      let effectiveSchema: string | undefined = typeof schema === 'object' ? 'custom' : schema;\n\n      if (schema && schema !== 'plain') {\n        try {\n          schemaString = await this.loadSchemaContent(schema);\n          log(`📋 Loaded schema content for: ${schema}`);\n          log(`📄 Raw schema JSON:\\n${schemaString}`);\n        } catch (error) {\n          log(`⚠️ Failed to load schema ${schema}, proceeding without schema:`, error);\n          schemaString = undefined;\n          effectiveSchema = undefined; // Schema loading failed, treat as no schema\n          if (debugInfo && debugInfo.errors) {\n            debugInfo.errors.push(`Failed to load schema: ${error}`);\n          }\n        }\n      } else if (schema === 'plain') {\n        log(`📋 Using plain schema - no JSON validation will be applied`);\n      }\n\n      // Pass schema in options object with 'schema' property\n      const schemaOptions = schemaString ? { schema: schemaString } : undefined;\n\n      // Store the exact schema options being passed to ProbeAgent in debug info\n      if (debugInfo && schemaOptions) {\n        debugInfo.schema = JSON.stringify(schemaOptions, null, 2);\n      }\n\n      // Log the schema options being passed to ProbeAgent\n      if (schemaOptions) {\n        log(`🎯 Schema options passed to ProbeAgent.answer() (session reuse):`);\n        log(JSON.stringify(schemaOptions, null, 2));\n      }\n\n      // Save prompt and debug info for session reuse too (only if debug enabled)\n      if (process.env.VISOR_DEBUG_AI_SESSIONS === 'true') {\n        try {\n          const fs = require('fs');\n          const path = require('path');\n          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n          const provider = this.config.provider || 'auto';\n          const model = this.config.model || 'default';\n\n          // Try to extract conversation history from ProbeAgent\n          let conversationHistory: any[] = [];\n          try {\n            // ProbeAgent stores history in different ways depending on version\n            const agentAny = agent as any;\n            if (agentAny.history) {\n              conversationHistory = agentAny.history;\n            } else if (agentAny.messages) {\n              conversationHistory = agentAny.messages;\n            } else if (agentAny._messages) {\n              conversationHistory = agentAny._messages;\n            }\n          } catch {\n            // Ignore if we can't access history\n          }\n\n          const debugData = {\n            timestamp: timestamp,\n            checkName: _checkName || 'unknown',\n            provider: provider,\n            model: model,\n            schema: effectiveSchema,\n            schemaOptions: schemaOptions || 'none',\n            sessionInfo: {\n              isSessionReuse: true,\n              historyMessageCount: conversationHistory.length,\n            },\n            currentPromptLength: prompt.length,\n            currentPrompt: prompt,\n            conversationHistory: conversationHistory,\n          };\n\n          const debugJson = JSON.stringify(debugData, null, 2);\n\n          // Also create a human-readable version with clear separators\n          let readableVersion = `=============================================================\\n`;\n          readableVersion += `VISOR DEBUG REPORT - SESSION REUSE\\n`;\n          readableVersion += `=============================================================\\n`;\n          readableVersion += `Timestamp: ${timestamp}\\n`;\n          readableVersion += `Check Name: ${_checkName || 'unknown'}\\n`;\n          readableVersion += `Provider: ${provider}\\n`;\n          readableVersion += `Model: ${model}\\n`;\n          readableVersion += `Schema: ${effectiveSchema}\\n`;\n          readableVersion += `Schema Options: ${schemaOptions ? 'provided' : 'none'}\\n`;\n          readableVersion += `History Messages: ${conversationHistory.length}\\n`;\n          readableVersion += `=============================================================\\n\\n`;\n\n          // Add schema details if provided\n          if (schemaOptions) {\n            readableVersion += `\\n${'='.repeat(60)}\\n`;\n            readableVersion += `SCHEMA CONFIGURATION\\n`;\n            readableVersion += `${'='.repeat(60)}\\n`;\n            readableVersion += JSON.stringify(schemaOptions, null, 2);\n            readableVersion += `\\n`;\n          }\n\n          // Add conversation history with clear separators\n          if (conversationHistory.length > 0) {\n            readableVersion += `\\n${'='.repeat(60)}\\n`;\n            readableVersion += `CONVERSATION HISTORY (${conversationHistory.length} messages)\\n`;\n            readableVersion += `${'='.repeat(60)}\\n`;\n            conversationHistory.forEach((msg: any, index: number) => {\n              readableVersion += `\\n${'-'.repeat(60)}\\n`;\n              readableVersion += `MESSAGE #${index + 1}\\n`;\n              readableVersion += `Role: ${msg.role || 'unknown'}\\n`;\n              if (msg.content) {\n                const contentStr =\n                  typeof msg.content === 'string'\n                    ? msg.content\n                    : JSON.stringify(msg.content, null, 2);\n                readableVersion += `Length: ${contentStr.length} characters\\n`;\n                readableVersion += `${'-'.repeat(60)}\\n`;\n                readableVersion += `${contentStr}\\n`;\n              }\n            });\n          }\n\n          // Add current prompt\n          readableVersion += `\\n${'='.repeat(60)}\\n`;\n          readableVersion += `CURRENT PROMPT (NEW MESSAGE)\\n`;\n          readableVersion += `${'='.repeat(60)}\\n`;\n          readableVersion += `Length: ${prompt.length} characters\\n`;\n          readableVersion += `${'-'.repeat(60)}\\n`;\n          readableVersion += `${prompt}\\n`;\n          readableVersion += `\\n${'='.repeat(60)}\\n`;\n          readableVersion += `END OF DEBUG REPORT\\n`;\n          readableVersion += `${'='.repeat(60)}\\n`;\n\n          const debugArtifactsDir =\n            process.env.VISOR_DEBUG_ARTIFACTS || path.join(process.cwd(), 'debug-artifacts');\n          if (!fs.existsSync(debugArtifactsDir)) {\n            fs.mkdirSync(debugArtifactsDir, { recursive: true });\n          }\n\n          // Save JSON version\n          const debugFile = path.join(\n            debugArtifactsDir,\n            `prompt-${_checkName || 'unknown'}-${timestamp}.json`\n          );\n          fs.writeFileSync(debugFile, debugJson, 'utf-8');\n\n          // Save readable version\n          const readableFile = path.join(\n            debugArtifactsDir,\n            `prompt-${_checkName || 'unknown'}-${timestamp}.txt`\n          );\n          fs.writeFileSync(readableFile, readableVersion, 'utf-8');\n\n          log(`\\n💾 Full debug info saved to:`);\n          log(`   JSON: ${debugFile}`);\n          log(`   TXT:  ${readableFile}`);\n          log(`   - Includes: full conversation history, schema, current prompt`);\n        } catch (error) {\n          log(`⚠️ Could not save debug file: ${error}`);\n        }\n      }\n\n      // Use existing agent's answer method - this reuses the conversation context\n      // Wrap in a span for hierarchical tracing\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const agentAny = agent as any;\n      let response: string;\n      if (agentAny.tracer && typeof agentAny.tracer.withSpan === 'function') {\n        response = await agentAny.tracer.withSpan(\n          'visor.ai_check_reuse',\n          async () => {\n            return await agent.answer(prompt, undefined, schemaOptions);\n          },\n          {\n            'check.name': _checkName || 'unknown',\n            'check.mode': 'session_reuse',\n            'prompt.length': prompt.length,\n            'schema.type': effectiveSchema || 'none',\n          }\n        );\n      } else {\n        response = schemaOptions\n          ? await agent.answer(prompt, undefined, schemaOptions)\n          : await agent.answer(prompt);\n      }\n\n      log('✅ ProbeAgent session reuse completed successfully');\n      log(`📤 Response length: ${response.length} characters`);\n\n      // Save COMPLETE conversation history AFTER AI response (only if debug enabled)\n      if (process.env.VISOR_DEBUG_AI_SESSIONS === 'true') {\n        try {\n          const fs = require('fs');\n          const path = require('path');\n          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n\n          // Extract FULL conversation history AFTER the AI call\n          const agentAny = agent as any;\n          let fullHistory: any[] = [];\n\n          // Try multiple properties to get complete history\n          if (agentAny.history) {\n            fullHistory = agentAny.history;\n          } else if (agentAny.messages) {\n            fullHistory = agentAny.messages;\n          } else if (agentAny._messages) {\n            fullHistory = agentAny._messages;\n          }\n\n          const debugArtifactsDir =\n            process.env.VISOR_DEBUG_ARTIFACTS || path.join(process.cwd(), 'debug-artifacts');\n          // do not enforce directory perms here\n\n          // Save complete session history (all messages sent and received)\n          const sessionBase = path.join(\n            debugArtifactsDir,\n            `session-${_checkName || 'unknown'}-${timestamp}`\n          );\n          const sessionData = {\n            timestamp,\n            checkName: _checkName || 'unknown',\n            provider: this.config.provider || 'auto',\n            model: this.config.model || 'default',\n            schema: effectiveSchema,\n            totalMessages: fullHistory.length,\n          };\n          fs.writeFileSync(sessionBase + '.json', JSON.stringify(sessionData, null, 2), 'utf-8');\n\n          // Redacted textual summary\n          let readable = `=============================================================\n`;\n          readable += `COMPLETE AI SESSION HISTORY (AFTER RESPONSE)\n`;\n          readable += `=============================================================\n`;\n          readable += `Timestamp: ${timestamp}\n`;\n          readable += `Check: ${_checkName || 'unknown'}\n`;\n          readable += `Total Messages: ${fullHistory.length}\n`;\n          readable += `=============================================================\n\n`;\n          fullHistory.forEach((msg: any, idx: number) => {\n            const role = msg.role || 'unknown';\n            const content =\n              typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content, null, 2);\n            readable += `\n${'='.repeat(60)}\nMESSAGE ${idx + 1}/${fullHistory.length}\nRole: ${role}\n${'='.repeat(60)}\n`;\n            readable += content + '\\n';\n          });\n          fs.writeFileSync(sessionBase + '.summary.txt', readable, 'utf-8');\n\n          log(`💾 Complete session history saved:`);\n          // (paths omitted)\n          log(`   - Contains ALL ${fullHistory.length} messages (prompts + responses)`);\n        } catch (error) {\n          log(`⚠️ Could not save complete session history: ${error}`);\n        }\n      }\n\n      // Save response if debug is enabled\n      if (process.env.VISOR_DEBUG_AI_SESSIONS === 'true') {\n        try {\n          const fs = require('fs');\n          const path = require('path');\n          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n\n          const debugArtifactsDir =\n            process.env.VISOR_DEBUG_ARTIFACTS || path.join(process.cwd(), 'debug-artifacts');\n\n          // Create a response file with the same timestamp pattern\n          const responseFile = path.join(\n            debugArtifactsDir,\n            `response-${_checkName || 'unknown'}-${timestamp}.txt`\n          );\n\n          let responseContent = `=============================================================\\n`;\n          responseContent += `VISOR AI RESPONSE - SESSION REUSE\\n`;\n          responseContent += `=============================================================\\n`;\n          responseContent += `Timestamp: ${timestamp}\\n`;\n          responseContent += `Check Name: ${_checkName || 'unknown'}\\n`;\n          responseContent += `Response Length: ${response.length} characters\\n`;\n          responseContent += `=============================================================\\n\\n`;\n          responseContent += `${'='.repeat(60)}\\n`;\n          responseContent += `AI RESPONSE\\n`;\n          responseContent += `${'='.repeat(60)}\\n`;\n          responseContent += response;\n          responseContent += `\\n${'='.repeat(60)}\\n`;\n          responseContent += `END OF RESPONSE\\n`;\n          responseContent += `${'='.repeat(60)}\\n`;\n\n          fs.writeFileSync(responseFile, responseContent, 'utf-8');\n          log(`💾 Response saved to: ${responseFile}`);\n        } catch (error) {\n          log(`⚠️ Could not save response file: ${error}`);\n        }\n      }\n\n      // Finalize and save trace if this is a cloned session with tracing enabled\n      // Properly flush and shutdown OpenTelemetry to ensure all spans are exported\n      if (agentAny._traceFilePath && agentAny._telemetryConfig) {\n        try {\n          // First flush the tracer to export pending spans\n          if (agentAny.tracer && typeof agentAny.tracer.flush === 'function') {\n            await agentAny.tracer.flush();\n            log(`🔄 Flushed tracer spans for cloned session`);\n          }\n\n          // Then shutdown the telemetry config to finalize all exporters\n          if (\n            agentAny._telemetryConfig &&\n            typeof agentAny._telemetryConfig.shutdown === 'function'\n          ) {\n            await agentAny._telemetryConfig.shutdown();\n            log(`📊 OpenTelemetry trace saved to: ${agentAny._traceFilePath}`);\n\n            // In GitHub Actions, also log file size for verification\n            if (process.env.GITHUB_ACTIONS) {\n              const fs = require('fs');\n              if (fs.existsSync(agentAny._traceFilePath)) {\n                const stats = fs.statSync(agentAny._traceFilePath);\n                console.log(\n                  `::notice title=AI Trace Saved::${agentAny._traceFilePath} (${stats.size} bytes)`\n                );\n              }\n            }\n          } else if (agentAny.tracer && typeof agentAny.tracer.shutdown === 'function') {\n            // Fallback for SimpleTelemetry\n            await agentAny.tracer.shutdown();\n            log(`📊 Trace saved to: ${agentAny._traceFilePath}`);\n          }\n        } catch (exportError) {\n          logger.warn(`⚠️  Warning: Failed to export trace for cloned session: ${exportError}`);\n        }\n      }\n\n      return { response, effectiveSchema };\n    } catch (error) {\n      logger.error(\n        `❌ ProbeAgent session reuse failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n      throw new Error(\n        `ProbeAgent session reuse failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Call ProbeAgent SDK with built-in schema validation\n   */\n  private async callProbeAgent(\n    prompt: string,\n    schema?: string | Record<string, unknown>,\n    debugInfo?: AIDebugInfo,\n    _checkName?: string,\n    providedSessionId?: string\n  ): Promise<{ response: string; effectiveSchema?: string }> {\n    // Handle mock model/provider for testing\n    if (this.config.model === 'mock' || this.config.provider === 'mock') {\n      log('🎭 Using mock AI model/provider for testing');\n      const response = await this.generateMockResponse(prompt, _checkName, schema);\n      return { response, effectiveSchema: typeof schema === 'object' ? 'custom' : schema };\n    }\n\n    // Create ProbeAgent instance with proper options\n    const sessionId =\n      providedSessionId ||\n      (() => {\n        const timestamp = new Date().toISOString();\n        return `visor-${timestamp.replace(/[:.]/g, '-')}-${_checkName || 'unknown'}`;\n      })();\n\n    log('🤖 Creating ProbeAgent for AI review...');\n    log(`🆔 Session ID: ${sessionId}`);\n    log(`📝 Prompt length: ${prompt.length} characters`);\n    log(`⚙️ Model: ${this.config.model || 'default'}, Provider: ${this.config.provider || 'auto'}`);\n\n    // Store original env vars to restore later\n    const originalEnv: Record<string, string | undefined> = {\n      CLAUDE_CODE_API_KEY: process.env.CLAUDE_CODE_API_KEY,\n      GOOGLE_API_KEY: process.env.GOOGLE_API_KEY,\n      ANTHROPIC_API_KEY: process.env.ANTHROPIC_API_KEY,\n      OPENAI_API_KEY: process.env.OPENAI_API_KEY,\n    };\n\n    try {\n      // Set environment variables for ProbeAgent\n      // ProbeAgent SDK expects these to be in the environment\n      if (this.config.provider === 'claude-code' && this.config.apiKey) {\n        process.env.CLAUDE_CODE_API_KEY = this.config.apiKey;\n        // Also set ANTHROPIC_API_KEY as fallback since Claude Code uses Anthropic API\n        process.env.ANTHROPIC_API_KEY = this.config.apiKey;\n      } else if (this.config.provider === 'google' && this.config.apiKey) {\n        process.env.GOOGLE_API_KEY = this.config.apiKey;\n      } else if (this.config.provider === 'anthropic' && this.config.apiKey) {\n        process.env.ANTHROPIC_API_KEY = this.config.apiKey;\n      } else if (this.config.provider === 'openai' && this.config.apiKey) {\n        process.env.OPENAI_API_KEY = this.config.apiKey;\n      } else if (this.config.provider === 'bedrock') {\n        // For Bedrock, ProbeAgent will use AWS credentials from environment\n        // No need to set apiKey as it uses AWS SDK authentication\n        // ProbeAgent will check for AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, etc.\n      }\n      const options: TracedProbeAgentOptions = {\n        sessionId: sessionId,\n        promptType: schema ? ('code-review-template' as 'code-review') : undefined,\n        allowEdit: false, // We don't want the agent to modify files\n        debug: this.config.debug || false,\n      };\n\n      // Enable tracing in debug mode for better diagnostics\n      // This uses SimpleTelemetry for lightweight tracing\n      let traceFilePath = '';\n      let telemetryConfig: unknown = null;\n      if (this.config.debug) {\n        const tracerResult = await initializeTracer(sessionId, _checkName);\n        if (tracerResult) {\n          options.tracer = tracerResult.tracer;\n          telemetryConfig = tracerResult.telemetryConfig;\n          traceFilePath = tracerResult.filePath;\n        }\n      }\n\n      // Wire MCP configuration when provided\n      if (this.config.mcpServers && Object.keys(this.config.mcpServers).length > 0) {\n        (options as any).enableMcp = true;\n        (options as any).mcpConfig = { mcpServers: this.config.mcpServers };\n      }\n\n      // Enable delegate tool if configured\n      if (this.config.enableDelegate !== undefined) {\n        (options as any).enableDelegate = this.config.enableDelegate;\n      }\n\n      // Add provider-specific options if configured\n      if (this.config.provider) {\n        // Map claude-code to anthropic for ProbeAgent compatibility\n        // Map bedrock to anthropic temporarily until ProbeAgent adds bedrock type\n        const providerOverride: ProbeAgentOptions['provider'] | undefined =\n          this.config.provider === 'claude-code' || this.config.provider === 'bedrock'\n            ? 'anthropic'\n            : this.config.provider === 'anthropic' ||\n                this.config.provider === 'openai' ||\n                this.config.provider === 'google'\n              ? this.config.provider\n              : undefined;\n\n        if (providerOverride) {\n          options.provider = providerOverride;\n        }\n      }\n      if (this.config.model) {\n        options.model = this.config.model;\n      }\n\n      const agent = new ProbeAgent(options);\n\n      log('🚀 Calling ProbeAgent...');\n      // Load and pass the actual schema content if provided (skip for plain schema)\n      let schemaString: string | undefined = undefined;\n      let effectiveSchema: string | undefined = typeof schema === 'object' ? 'custom' : schema;\n\n      if (schema && schema !== 'plain') {\n        try {\n          schemaString = await this.loadSchemaContent(schema);\n          log(`📋 Loaded schema content for: ${schema}`);\n          log(`📄 Raw schema JSON:\\n${schemaString}`);\n        } catch (error) {\n          log(`⚠️ Failed to load schema ${schema}, proceeding without schema:`, error);\n          schemaString = undefined;\n          effectiveSchema = undefined; // Schema loading failed, treat as no schema\n          if (debugInfo && debugInfo.errors) {\n            debugInfo.errors.push(`Failed to load schema: ${error}`);\n          }\n        }\n      } else if (schema === 'plain') {\n        log(`📋 Using plain schema - no JSON validation will be applied`);\n      }\n\n      // ProbeAgent now handles schema formatting internally!\n      // Pass schema in options object with 'schema' property\n      const schemaOptions = schemaString ? { schema: schemaString } : undefined;\n\n      // Store the exact schema options being passed to ProbeAgent in debug info\n      if (debugInfo && schemaOptions) {\n        debugInfo.schema = JSON.stringify(schemaOptions, null, 2);\n      }\n\n      // Log the schema options being passed to ProbeAgent\n      if (schemaOptions) {\n        log(`🎯 Schema options passed to ProbeAgent.answer():`);\n        log(JSON.stringify(schemaOptions, null, 2));\n      }\n\n      // Log the equivalent CLI command for local reproduction\n      const provider = this.config.provider || 'auto';\n      const model = this.config.model || 'default';\n\n      // Save prompt to a temp file AND debug artifacts for easier reproduction (only if debug enabled)\n      if (process.env.VISOR_DEBUG_AI_SESSIONS === 'true') {\n        try {\n          const fs = require('fs');\n          const path = require('path');\n          const os = require('os');\n          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n\n          // Prepare debug info with full details\n          const debugData = {\n            timestamp,\n            checkName: _checkName || 'unknown',\n            provider,\n            model,\n            schema: effectiveSchema,\n            schemaOptions: schemaOptions || 'none',\n            sessionInfo: {\n              isSessionReuse: false,\n              isNewSession: true,\n            },\n            promptLength: prompt.length,\n            prompt: prompt,\n          };\n\n          const debugJson = JSON.stringify(debugData, null, 2);\n\n          // Create human-readable version with clear separators\n          let readableVersion = `=============================================================\\n`;\n          readableVersion += `VISOR DEBUG REPORT - NEW SESSION\\n`;\n          readableVersion += `=============================================================\\n`;\n          readableVersion += `Timestamp: ${timestamp}\\n`;\n          readableVersion += `Check Name: ${_checkName || 'unknown'}\\n`;\n          readableVersion += `Provider: ${provider}\\n`;\n          readableVersion += `Model: ${model}\\n`;\n          readableVersion += `Schema: ${effectiveSchema}\\n`;\n          readableVersion += `Schema Options: ${schemaOptions ? 'provided' : 'none'}\\n`;\n          readableVersion += `Session Type: New Session (no history)\\n`;\n          readableVersion += `=============================================================\\n\\n`;\n\n          // Add schema details if provided\n          if (schemaOptions) {\n            readableVersion += `\\n${'='.repeat(60)}\\n`;\n            readableVersion += `SCHEMA CONFIGURATION\\n`;\n            readableVersion += `${'='.repeat(60)}\\n`;\n            readableVersion += JSON.stringify(schemaOptions, null, 2);\n            readableVersion += `\\n`;\n          }\n\n          // Add prompt\n          readableVersion += `\\n${'='.repeat(60)}\\n`;\n          readableVersion += `PROMPT\\n`;\n          readableVersion += `${'='.repeat(60)}\\n`;\n          readableVersion += `Length: ${prompt.length} characters\\n`;\n          readableVersion += `${'-'.repeat(60)}\\n`;\n          readableVersion += `${prompt}\\n`;\n          readableVersion += `\\n${'='.repeat(60)}\\n`;\n          readableVersion += `END OF DEBUG REPORT\\n`;\n          readableVersion += `${'='.repeat(60)}\\n`;\n\n          // Save to temp directory\n          const tempDir = os.tmpdir();\n          const promptFile = path.join(tempDir, `visor-prompt-${timestamp}.txt`);\n          fs.writeFileSync(promptFile, prompt, 'utf-8');\n          log(`\\n💾 Prompt saved to: ${promptFile}`);\n\n          // Also save to debug-artifacts directory if available\n          const debugArtifactsDir =\n            process.env.VISOR_DEBUG_ARTIFACTS || path.join(process.cwd(), 'debug-artifacts');\n          try {\n            // do not enforce fs permissions here\n            const base = path.join(\n              debugArtifactsDir,\n              `prompt-${_checkName || 'unknown'}-${timestamp}`\n            );\n            fs.writeFileSync(base + '.json', debugJson, 'utf-8');\n            fs.writeFileSync(base + '.summary.txt', readableVersion, 'utf-8');\n            log(`\n💾 Full debug info saved to directory: ${debugArtifactsDir}`);\n          } catch {\n            // Ignore if we can't write to debug-artifacts\n          }\n\n          log(`\\n📝 To reproduce locally, run:`);\n\n          let cliCommand = `npx @probelabs/probe@latest agent`;\n          cliCommand += ` --provider ${provider}`;\n          if (model !== 'default') {\n            cliCommand += ` --model ${model}`;\n          }\n          if (schema) {\n            cliCommand += ` --schema output/${schema}/schema.json`;\n          }\n          cliCommand += ` \"${promptFile}\"`;\n\n          log(`\\n$ ${cliCommand}\\n`);\n        } catch (error) {\n          log(`⚠️ Could not save prompt file: ${error}`);\n        }\n      }\n\n      // Wrap the agent.answer() call in a span for hierarchical tracing\n      // This creates a parent span that will contain all ProbeAgent's child spans\n      let response: string;\n      const tracer = options.tracer as {\n        withSpan?: (\n          name: string,\n          fn: () => Promise<string>,\n          attrs?: Record<string, unknown>\n        ) => Promise<string>;\n      };\n      if (tracer && typeof tracer.withSpan === 'function') {\n        response = await tracer.withSpan(\n          'visor.ai_check',\n          async () => {\n            return await agent.answer(prompt, undefined, schemaOptions);\n          },\n          {\n            'check.name': _checkName || 'unknown',\n            'check.session_id': sessionId,\n            'prompt.length': prompt.length,\n            'schema.type': effectiveSchema || 'none',\n          }\n        );\n      } else {\n        response = schemaOptions\n          ? await agent.answer(prompt, undefined, schemaOptions)\n          : await agent.answer(prompt);\n      }\n\n      log('✅ ProbeAgent completed successfully');\n      log(`📤 Response length: ${response.length} characters`);\n\n      // Save COMPLETE conversation history AFTER AI response (only if debug enabled)\n      if (process.env.VISOR_DEBUG_AI_SESSIONS === 'true') {\n        try {\n          const fs = require('fs');\n          const path = require('path');\n          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n\n          // Extract FULL conversation history AFTER the AI call\n          const agentAny = agent as any;\n          let fullHistory: any[] = [];\n\n          // Try multiple properties to get complete history\n          if (agentAny.history) {\n            fullHistory = agentAny.history;\n          } else if (agentAny.messages) {\n            fullHistory = agentAny.messages;\n          } else if (agentAny._messages) {\n            fullHistory = agentAny._messages;\n          }\n\n          const debugArtifactsDir =\n            process.env.VISOR_DEBUG_ARTIFACTS || path.join(process.cwd(), 'debug-artifacts');\n          // do not enforce fs permissions here\n\n          // Save complete session history (all messages sent and received)\n          const sessionBase = path.join(\n            debugArtifactsDir,\n            `session-${_checkName || 'unknown'}-${timestamp}`\n          );\n          const sessionData = {\n            timestamp,\n            checkName: _checkName || 'unknown',\n            provider: this.config.provider || 'auto',\n            model: this.config.model || 'default',\n            schema: effectiveSchema,\n            totalMessages: fullHistory.length,\n          };\n          fs.writeFileSync(sessionBase + '.json', JSON.stringify(sessionData, null, 2), 'utf-8');\n\n          // Redacted textual summary\n          let readable = `=============================================================\n`;\n          readable += `COMPLETE AI SESSION HISTORY (AFTER RESPONSE)\n`;\n          readable += `=============================================================\n`;\n          readable += `Timestamp: ${timestamp}\n`;\n          readable += `Check: ${_checkName || 'unknown'}\n`;\n          readable += `Total Messages: ${fullHistory.length}\n`;\n          readable += `=============================================================\n\n`;\n          fullHistory.forEach((msg: any, idx: number) => {\n            const role = msg.role || 'unknown';\n            const content =\n              typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content, null, 2);\n            readable += `\n${'='.repeat(60)}\nMESSAGE ${idx + 1}/${fullHistory.length}\nRole: ${role}\n${'='.repeat(60)}\n`;\n            readable += content + '\\n';\n          });\n          fs.writeFileSync(sessionBase + '.summary.txt', readable, 'utf-8');\n\n          log(`💾 Complete session history saved:`);\n          // (paths omitted)\n          log(`   - Contains ALL ${fullHistory.length} messages (prompts + responses)`);\n        } catch (error) {\n          log(`⚠️ Could not save complete session history: ${error}`);\n        }\n      }\n\n      // Save response if debug is enabled\n      if (process.env.VISOR_DEBUG_AI_SESSIONS === 'true') {\n        try {\n          const fs = require('fs');\n          const path = require('path');\n          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n\n          const debugArtifactsDir =\n            process.env.VISOR_DEBUG_ARTIFACTS || path.join(process.cwd(), 'debug-artifacts');\n\n          // Create a response file\n          const responseFile = path.join(\n            debugArtifactsDir,\n            `response-${_checkName || 'unknown'}-${timestamp}.txt`\n          );\n\n          let responseContent = `=============================================================\\n`;\n          responseContent += `VISOR AI RESPONSE - NEW SESSION\\n`;\n          responseContent += `=============================================================\\n`;\n          responseContent += `Timestamp: ${timestamp}\\n`;\n          responseContent += `Check Name: ${_checkName || 'unknown'}\\n`;\n          responseContent += `Response Length: ${response.length} characters\\n`;\n          responseContent += `=============================================================\\n\\n`;\n          responseContent += `${'='.repeat(60)}\\n`;\n          responseContent += `AI RESPONSE\\n`;\n          responseContent += `${'='.repeat(60)}\\n`;\n          responseContent += response;\n          responseContent += `\\n${'='.repeat(60)}\\n`;\n          responseContent += `END OF RESPONSE\\n`;\n          responseContent += `${'='.repeat(60)}\\n`;\n\n          fs.writeFileSync(responseFile, responseContent, 'utf-8');\n          log(`💾 Response saved to: ${responseFile}`);\n        } catch (error) {\n          log(`⚠️ Could not save response file: ${error}`);\n        }\n      }\n\n      // Finalize and save trace if enabled\n      // Properly flush and shutdown telemetry to ensure all spans are exported\n      if (traceFilePath && telemetryConfig) {\n        try {\n          // Cast telemetryConfig to have optional methods\n          const telemetry = telemetryConfig as {\n            flush?: () => Promise<void>;\n            shutdown?: () => Promise<void>;\n          };\n          const tracerWithMethods = tracer as {\n            flush?: () => Promise<void>;\n            shutdown?: () => Promise<void>;\n          };\n\n          // First flush the tracer to export pending spans\n          if (tracerWithMethods && typeof tracerWithMethods.flush === 'function') {\n            await tracerWithMethods.flush();\n            log(`🔄 Flushed tracer spans`);\n          }\n\n          // Then shutdown the telemetry config to finalize all exporters\n          if (telemetry && typeof telemetry.shutdown === 'function') {\n            await telemetry.shutdown();\n            log(`📊 OpenTelemetry trace saved to: ${traceFilePath}`);\n\n            // In GitHub Actions, also log file size for verification\n            if (process.env.GITHUB_ACTIONS) {\n              const fs = require('fs');\n              if (fs.existsSync(traceFilePath)) {\n                const stats = fs.statSync(traceFilePath);\n                console.log(\n                  `::notice title=AI Trace Saved::OpenTelemetry trace file size: ${stats.size} bytes`\n                );\n              }\n            }\n          } else if (tracerWithMethods && typeof tracerWithMethods.shutdown === 'function') {\n            // Fallback for SimpleTelemetry\n            await tracerWithMethods.shutdown();\n            log(`📊 Trace saved to: ${traceFilePath}`);\n          }\n        } catch (exportError) {\n          logger.warn(`⚠️  Warning: Failed to export trace: ${exportError}`);\n        }\n      }\n\n      // Register the session for potential reuse by dependent checks\n      if (_checkName) {\n        // ProbeAgent.clone() will handle history filtering when this session is cloned\n        this.registerSession(sessionId, agent);\n        log(`🔧 Debug: Registered AI session for potential reuse: ${sessionId}`);\n      }\n\n      return { response, effectiveSchema };\n    } catch (error) {\n      console.error('❌ ProbeAgent failed:', error);\n      throw new Error(\n        `ProbeAgent execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    } finally {\n      // Restore original environment variables\n      Object.keys(originalEnv).forEach(key => {\n        if (originalEnv[key] === undefined) {\n          delete process.env[key];\n        } else {\n          process.env[key] = originalEnv[key];\n        }\n      });\n    }\n  }\n\n  /**\n   * Load schema content from schema files or inline definitions\n   */\n  private async loadSchemaContent(schema: string | Record<string, unknown>): Promise<string> {\n    const fs = require('fs').promises;\n    const path = require('path');\n\n    // Check if schema is already an object (inline definition from YAML)\n    if (typeof schema === 'object' && schema !== null) {\n      // It's already a schema object, convert to JSON string\n      log('📋 Using inline schema object from configuration');\n      return JSON.stringify(schema);\n    }\n\n    // Check if schema string is already a JSON schema (inline JSON string)\n    // This happens when a schema is passed directly as JSON instead of a reference\n    try {\n      const parsed = JSON.parse(schema);\n      if (typeof parsed === 'object' && parsed !== null) {\n        // It's already a valid JSON schema, return it as-is\n        log('📋 Using inline schema JSON string');\n        return schema;\n      }\n    } catch {\n      // Not JSON, treat as schema name reference or file path\n    }\n\n    // Check if it's a file path (starts with ./ or contains .json but not absolute paths)\n    if ((schema.startsWith('./') || schema.includes('.json')) && !path.isAbsolute(schema)) {\n      // It's a relative file path to a custom schema\n      // Validate the path to prevent traversal attacks\n      if (schema.includes('..') || schema.includes('\\x00')) {\n        throw new Error('Invalid schema path: path traversal not allowed');\n      }\n\n      try {\n        const schemaPath = path.resolve(process.cwd(), schema);\n        log(`📋 Loading custom schema from file: ${schemaPath}`);\n        const schemaContent = await fs.readFile(schemaPath, 'utf-8');\n        return schemaContent.trim();\n      } catch (error) {\n        throw new Error(\n          `Failed to load custom schema from ${schema}: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n      }\n    }\n\n    // Otherwise, treat as a built-in schema name\n    // Sanitize schema name to prevent path traversal attacks\n    const sanitizedSchemaName = schema.replace(/[^a-zA-Z0-9-]/g, '');\n    if (!sanitizedSchemaName || sanitizedSchemaName !== schema) {\n      throw new Error('Invalid schema name');\n    }\n\n    // Built-in schemas are bundled under dist/output when running as a GitHub Action.\n    // In local dev (ts-node/jest), schemas may live under project/output.\n    // Try dist-relative first, then fall back to CWD.\n    const candidatePaths = [\n      // GitHub Action bundle location\n      path.join(__dirname, 'output', sanitizedSchemaName, 'schema.json'),\n      // Historical fallback when src/output was inadvertently bundled as output1/\n      path.join(__dirname, 'output1', sanitizedSchemaName, 'schema.json'),\n      // Local dev (repo root)\n      path.join(process.cwd(), 'output', sanitizedSchemaName, 'schema.json'),\n    ];\n\n    for (const schemaPath of candidatePaths) {\n      try {\n        const schemaContent = await fs.readFile(schemaPath, 'utf-8');\n        return schemaContent.trim();\n      } catch {\n        // try next\n      }\n    }\n\n    // If neither path works, surface a helpful error\n    const distPath = path.join(__dirname, 'output', sanitizedSchemaName, 'schema.json');\n    const distAltPath = path.join(__dirname, 'output1', sanitizedSchemaName, 'schema.json');\n    const cwdPath = path.join(process.cwd(), 'output', sanitizedSchemaName, 'schema.json');\n    throw new Error(\n      `Failed to load schema '${sanitizedSchemaName}'. Tried: ${distPath}, ${distAltPath}, and ${cwdPath}. ` +\n        `Ensure build copies 'output/' into dist (build:cli), or provide a custom schema file/path.`\n    );\n  }\n\n  /**\n   * Parse AI response JSON\n   */\n  private parseAIResponse(\n    response: string,\n    debugInfo?: AIDebugInfo,\n    _schema?: string\n  ): ReviewSummary {\n    log('🔍 Parsing AI response...');\n    log(`📊 Raw response length: ${response.length} characters`);\n\n    // Log first and last 200 chars for debugging\n    if (response.length > 400) {\n      log('📋 Response preview (first 200 chars):', response.substring(0, 200));\n      log('📋 Response preview (last 200 chars):', response.substring(response.length - 200));\n    } else {\n      log('📋 Full response preview:', response);\n    }\n\n    // Note: Removed overly aggressive Liquid template check that was causing false positives\n    // JSON parsing below will catch actual malformed responses\n\n    try {\n      // Handle different schema types differently\n      let reviewData: AIResponseFormat;\n\n      // Handle plain schema or no schema - no JSON parsing, return response as-is\n      if (_schema === 'plain' || !_schema) {\n        log(\n          `📋 ${_schema === 'plain' ? 'Plain' : 'No'} schema detected - returning raw response without JSON parsing`\n        );\n\n        // For plain schema, return the raw response as an issue\n\n        return {\n          issues: [\n            {\n              file: 'AI_RESPONSE',\n              line: 1,\n              ruleId: 'ai/raw_response',\n              message: response,\n              severity: 'info',\n              category: 'documentation',\n            },\n          ],\n          debug: debugInfo,\n        };\n      }\n\n      {\n        // For other schemas (code-review, etc.), extract and parse JSON with boundary detection\n        log('🔍 Extracting JSON from AI response...');\n\n        // Try direct parsing first - if AI returned pure JSON\n        try {\n          reviewData = JSON.parse(response.trim());\n          log('✅ Successfully parsed direct JSON response');\n          if (debugInfo) debugInfo.jsonParseSuccess = true;\n        } catch {\n          log('🔍 Direct parsing failed, trying to extract JSON from response...');\n\n          // If the response starts with \"I cannot\" or similar, it's likely a refusal\n          if (\n            response.toLowerCase().includes('i cannot') ||\n            response.toLowerCase().includes('unable to')\n          ) {\n            console.error('🚫 AI refused to analyze - returning empty result');\n            return {\n              issues: [],\n            };\n          }\n\n          // Try to extract JSON using improved method with proper bracket matching\n          const jsonString = this.extractJsonFromResponse(response);\n\n          if (jsonString) {\n            try {\n              reviewData = JSON.parse(jsonString);\n              log('✅ Successfully parsed extracted JSON');\n              if (debugInfo) debugInfo.jsonParseSuccess = true;\n            } catch {\n              log('🔧 Extracted JSON parsing failed, falling back to plain text handling...');\n\n              // Check if response is plain text and doesn't contain structured data\n              if (!response.includes('{') && !response.includes('}')) {\n                log('🔧 Plain text response detected, creating structured fallback...');\n\n                reviewData = {\n                  issues: [\n                    {\n                      file: 'AI_RESPONSE',\n                      line: 1,\n                      ruleId: 'ai/raw_response',\n                      message: response,\n                      severity: 'info',\n                      category: 'documentation',\n                    },\n                  ],\n                };\n              } else {\n                // Fallback: treat the entire response as an issue\n                log('🔧 Creating fallback response from non-JSON content...');\n                reviewData = {\n                  issues: [\n                    {\n                      file: 'AI_RESPONSE',\n                      line: 1,\n                      ruleId: 'ai/raw_response',\n                      message: response,\n                      severity: 'info',\n                      category: 'documentation',\n                    },\n                  ],\n                };\n              }\n            }\n          } else {\n            // No JSON found at all - treat as plain text response\n            log('🔧 No JSON found in response, treating as plain text...');\n            reviewData = {\n              issues: [\n                {\n                  file: 'AI_RESPONSE',\n                  line: 1,\n                  ruleId: 'ai/raw_response',\n                  message: response,\n                  severity: 'info',\n                  category: 'documentation',\n                },\n              ],\n            };\n          }\n        }\n      }\n\n      // Decide how to interpret the parsed JSON based on the effective schema and the shape of data\n      // Built-ins:\n      //  - 'code-review' → expects { issues: [...] }\n      //  - 'overview' / assistants → expects { text: string, ... }\n      //  - 'plain' → handled earlier\n      //  - custom (object/file path) → free-form object, ensure output.text fallback\n      const looksLikeTextOutput =\n        reviewData &&\n        typeof reviewData === 'object' &&\n        typeof (reviewData as any).text === 'string' &&\n        String((reviewData as any).text).trim().length > 0;\n\n      // Treat as custom/text-style when:\n      //  - explicit custom schema\n      //  - schema is any non code-review built-in like 'overview', 'issue-assistant', 'comment-assistant'\n      //  - or schema is unknown/undefined but the payload clearly contains a text field\n      const isCustomSchema =\n        _schema === 'custom' ||\n        (_schema && (_schema.startsWith('./') || _schema.endsWith('.json'))) ||\n        (_schema && _schema !== 'code-review' && !_schema.includes('output/')) ||\n        (!_schema && looksLikeTextOutput);\n\n      const _debugSchemaLogging =\n        this.config.debug === true || process.env.VISOR_DEBUG_AI_SESSIONS === 'true';\n      if (_debugSchemaLogging) {\n        const details = {\n          schema: _schema,\n          isCustomSchema,\n          isCustomLiteral: _schema === 'custom',\n          startsWithDotSlash: typeof _schema === 'string' ? _schema.startsWith('./') : false,\n          endsWithJson: typeof _schema === 'string' ? _schema.endsWith('.json') : false,\n          notCodeReview: _schema !== 'code-review',\n          noOutputPrefix: typeof _schema === 'string' ? !_schema.includes('output/') : false,\n        };\n        try {\n          log(`🔍 Schema detection: ${JSON.stringify(details)}`);\n        } catch {\n          // Fallback if JSON.stringify throws on unexpected values\n          log(\n            `🔍 Schema detection: _schema=\"${String(_schema)}\", isCustomSchema=${isCustomSchema}`\n          );\n        }\n      }\n\n      if (isCustomSchema) {\n        // For custom schemas, preserve ALL fields from the parsed JSON and make sure\n        // we always have something renderable in templates (e.g., output.text).\n        log('📋 Custom schema detected - preserving all fields from parsed JSON');\n        log(`📊 Schema: ${_schema}`);\n        try {\n          log(`📊 Custom schema keys: ${Object.keys(reviewData).join(', ')}`);\n        } catch {}\n\n        // Ensure \"output\" is an object and has a sensible text fallback for templates\n        const out: Record<string, unknown> =\n          reviewData && typeof reviewData === 'object' ? (reviewData as any) : ({} as any);\n\n        const hasText =\n          typeof (out as any).text === 'string' && String((out as any).text).trim().length > 0;\n        if (!hasText) {\n          // Build a fallback string from the raw response or issue messages if available\n          let fallbackText = '';\n          try {\n            if (\n              Array.isArray((reviewData as any)?.issues) &&\n              (reviewData as any).issues.length > 0\n            ) {\n              // Join issue messages into a readable block\n              fallbackText = (reviewData as any).issues\n                .map((i: any) => (i && (i.message || i.text || i.response)) as string)\n                .filter((s: any) => typeof s === 'string' && s.trim().length > 0)\n                .join('\\n');\n            }\n          } catch {}\n          if (!fallbackText && typeof response === 'string' && response.trim()) {\n            // Use raw provider response (trim and bound length for safety)\n            fallbackText = response.trim().slice(0, 60000);\n          }\n          if (fallbackText) {\n            (out as any).text = fallbackText;\n          }\n        }\n\n        const result: ReviewSummary & { output?: unknown } = {\n          // Keep issues empty for custom-schema rendering; consumers read from output.*\n          issues: [],\n          output: out,\n        };\n\n        log(\n          '✅ Successfully created ReviewSummary with custom schema output (with fallback text when needed)'\n        );\n        return result;\n      }\n\n      // Standard code-review schema processing (only when schema is explicitly code-review\n      // or when the payload clearly has an issues array)\n      log('🔍 Validating parsed review data...');\n      log(`📊 Overall score: ${0}`);\n      log(`📋 Total issues: ${reviewData.issues?.length || 0}`);\n      log(\n        `🚨 Critical issues: ${reviewData.issues?.filter((i: { severity?: string }) => i.severity === 'critical').length || 0}`\n      );\n      log(`💬 Comments count: ${Array.isArray(reviewData.issues) ? reviewData.issues.length : 0}`);\n\n      // Process issues from the simplified format; if we don't have issues and the\n      // data looks like a text-style output, route through the custom path above.\n      const processedIssues = Array.isArray((reviewData as any).issues)\n        ? (reviewData as any).issues.map((issue: any, index: number) => {\n            log(`🔍 Processing issue ${index + 1}:`, issue);\n            return {\n              file: issue.file || 'unknown',\n              line: issue.line || 1,\n              endLine: issue.endLine,\n              ruleId: issue.ruleId || `${issue.category || 'general'}/unknown`,\n              message: issue.message || '',\n              severity: issue.severity,\n              category: issue.category,\n              suggestion: issue.suggestion,\n              replacement: issue.replacement,\n            } as ReviewIssue;\n          })\n        : [];\n\n      // Validate and convert to ReviewSummary format\n      const result: ReviewSummary = {\n        issues: processedIssues,\n      };\n\n      // Log issue counts\n      const criticalCount = (result.issues || []).filter(i => i.severity === 'critical').length;\n      if (criticalCount > 0) {\n        log(`🚨 Found ${criticalCount} critical severity issue(s)`);\n      }\n      log(`📈 Total issues: ${(result.issues || []).length}`);\n\n      log('✅ Successfully created ReviewSummary');\n      return result;\n    } catch (error) {\n      const detailed = this.config.debug === true || process.env.VISOR_DEBUG_AI_SESSIONS === 'true';\n      const message = error instanceof Error ? error.message : String(error);\n\n      if (detailed) {\n        logger.debug(`❌ Failed to parse AI response: ${message}`);\n        logger.debug('📄 FULL RAW RESPONSE:');\n        logger.debug('='.repeat(80));\n        logger.debug(response);\n        logger.debug('='.repeat(80));\n        logger.debug(`📏 Response length: ${response.length} characters`);\n\n        if (error instanceof SyntaxError) {\n          logger.debug('🔍 JSON parsing error - the response may not be valid JSON');\n          logger.debug(`🔍 Error details: ${error.message}`);\n\n          const errorMatch = error.message.match(/position (\\d+)/);\n          if (errorMatch) {\n            const position = parseInt(errorMatch[1]);\n            logger.debug(`🔍 Error at position ${position}:`);\n            const start = Math.max(0, position - 50);\n            const end = Math.min(response.length, position + 50);\n            logger.debug(`🔍 Context: \"${response.substring(start, end)}\"`);\n            logger.debug(`🔍 Response beginning: \"${response.substring(0, 100)}\"`);\n          }\n\n          if (response.includes('I cannot')) {\n            logger.debug('🔍 Response appears to be a refusal/explanation rather than JSON');\n          }\n          if (response.includes('```')) {\n            logger.debug('🔍 Response appears to contain markdown code blocks');\n          }\n          if (response.startsWith('<')) {\n            logger.debug('🔍 Response appears to start with XML/HTML');\n          }\n        }\n      } else {\n        logger.error(`❌ Failed to parse AI response: ${message}`);\n      }\n\n      throw new Error(\n        `Invalid AI response format: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Extract JSON from a response that might contain surrounding text\n   * Uses proper bracket matching to find valid JSON objects or arrays\n   */\n  private extractJsonFromResponse(response: string): string | null {\n    const text = response.trim();\n\n    // Try to find JSON objects first (higher priority)\n    let bestJson = this.findJsonWithBracketMatching(text, '{', '}');\n\n    // If no object found, try arrays\n    if (!bestJson) {\n      bestJson = this.findJsonWithBracketMatching(text, '[', ']');\n    }\n\n    return bestJson;\n  }\n\n  /**\n   * Find JSON with proper bracket matching to avoid false positives\n   */\n  private findJsonWithBracketMatching(\n    text: string,\n    openChar: string,\n    closeChar: string\n  ): string | null {\n    const firstIndex = text.indexOf(openChar);\n    if (firstIndex === -1) return null;\n\n    let depth = 0;\n    let inString = false;\n    let escaping = false;\n\n    for (let i = firstIndex; i < text.length; i++) {\n      const char = text[i];\n\n      if (escaping) {\n        escaping = false;\n        continue;\n      }\n\n      if (char === '\\\\' && inString) {\n        escaping = true;\n        continue;\n      }\n\n      if (char === '\"' && !escaping) {\n        inString = !inString;\n        continue;\n      }\n\n      if (!inString) {\n        if (char === openChar) {\n          depth++;\n        } else if (char === closeChar) {\n          depth--;\n          if (depth === 0) {\n            // Found matching closing bracket\n            const candidate = text.substring(firstIndex, i + 1);\n            try {\n              JSON.parse(candidate); // Validate it's actually valid JSON\n              return candidate;\n            } catch {\n              // This wasn't valid JSON, keep looking\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Generate mock response for testing\n   */\n  private async generateMockResponse(\n    _prompt: string,\n    _checkName?: string,\n    _schema?: string | Record<string, unknown>\n  ): Promise<string> {\n    // Simulate some processing time\n    await new Promise(resolve => setTimeout(resolve, 500));\n\n    // Schema-accurate mocks for default flows\n    const name = (_checkName || '').toLowerCase();\n    if (name.includes('extract-facts')) {\n      const arr = Array.from({ length: 6 }, (_, i) => ({\n        id: `fact-${i + 1}`,\n        category: 'Feature',\n        claim: `claim-${i + 1}`,\n        verifiable: true,\n        refs: [{ path: 'src/check-execution-engine.ts', lines: '6400-6460' }],\n      }));\n      return JSON.stringify(arr);\n    }\n    if (name.includes('validate-fact')) {\n      const idMatch = _prompt.match(/Fact ID:\\s*([\\w\\-]+)/i);\n      const claimMatch = _prompt.match(/\\*\\*Claim:\\*\\*\\s*(.+)/i);\n      const attemptMatch = _prompt.match(/Attempt:\\s*(\\d+)/i);\n      const factId = idMatch ? idMatch[1] : 'fact-1';\n      const claim = claimMatch ? claimMatch[1].trim() : 'unknown-claim';\n      const n = Number(factId.split('-')[1] || '0');\n      const attempt = attemptMatch ? Number(attemptMatch[1]) : 0;\n      const isValid = attempt >= 1 ? true : !(n >= 1 && n <= 3);\n      return JSON.stringify({\n        fact_id: factId,\n        claim,\n        is_valid: isValid,\n        confidence: 'high',\n        evidence: isValid ? 'verified' : 'not found',\n        correction: isValid ? null : `correct ${claim}`,\n      });\n    }\n    if (name.includes('issue-assistant') || name.includes('comment-assistant')) {\n      const text = '### Assistant Reply';\n      const intent = name.includes('issue') ? 'issue_triage' : 'comment_reply';\n      return JSON.stringify({ text, intent });\n    }\n    // Fallback\n    const mockResponse = { content: JSON.stringify({ issues: [], summary: { totalIssues: 0 } }) };\n    return JSON.stringify(mockResponse);\n  }\n\n  /**\n   * Get the API key source for debugging (without revealing the key)\n   */\n  private getApiKeySource(): string {\n    if (process.env.CLAUDE_CODE_API_KEY && this.config.provider === 'claude-code') {\n      return 'CLAUDE_CODE_API_KEY';\n    }\n    if (process.env.GOOGLE_API_KEY && this.config.provider === 'google') {\n      return 'GOOGLE_API_KEY';\n    }\n    if (process.env.ANTHROPIC_API_KEY && this.config.provider === 'anthropic') {\n      return 'ANTHROPIC_API_KEY';\n    }\n    if (process.env.OPENAI_API_KEY && this.config.provider === 'openai') {\n      return 'OPENAI_API_KEY';\n    }\n    if (this.config.provider === 'bedrock') {\n      if (process.env.AWS_BEDROCK_API_KEY) {\n        return 'AWS_BEDROCK_API_KEY';\n      }\n      if (process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY) {\n        return 'AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY';\n      }\n    }\n    return 'unknown';\n  }\n}\n","import { Octokit } from '@octokit/rest';\nimport { PRInfo } from './pr-analyzer';\nimport { CommentManager } from './github-comments';\nimport { AIReviewService, AIDebugInfo } from './ai-review-service';\n\nexport interface ReviewIssue {\n  // Location\n  file: string;\n  line: number;\n  endLine?: number;\n  // Issue details\n  ruleId: string;\n  message: string;\n  severity: 'info' | 'warning' | 'error' | 'critical';\n  category: 'security' | 'performance' | 'style' | 'logic' | 'documentation';\n  // Check identification - which check created this issue\n  checkName?: string;\n  // Group and schema for comment separation\n  group?: string;\n  schema?: string;\n  // Timestamp when the issue was created (for ordering)\n  timestamp?: number;\n  // Optional enhancement\n  suggestion?: string;\n  replacement?: string;\n}\n\n// Legacy interface - ONLY for GitHub integration compatibility\nexport interface ReviewComment {\n  file: string;\n  line: number;\n  message: string;\n  severity: 'info' | 'warning' | 'error' | 'critical';\n  category: 'security' | 'performance' | 'style' | 'logic' | 'documentation';\n  suggestion?: string;\n  replacement?: string;\n  ruleId?: string;\n}\n\n// Individual check result - each check produces one of these\nexport interface CheckResult {\n  checkName: string;\n  content: string; // Rendered output for this specific check\n  group: string; // Which group this check belongs to\n  // Optional structured output for custom schemas (e.g., overview, issue-assistant)\n  output?: unknown;\n  debug?: AIDebugInfo;\n  issues?: ReviewIssue[]; // Structured issues alongside rendered content\n}\n\n// Results grouped by group name\nexport interface GroupedCheckResults {\n  [groupName: string]: CheckResult[];\n}\n\n// Legacy interface - only for backward compatibility\nexport interface ReviewSummary {\n  issues?: ReviewIssue[];\n  debug?: AIDebugInfo;\n  /** Session ID created for this check (for cleanup tracking) */\n  sessionId?: string;\n}\n\n// Test utility function - Convert old ReviewSummary to new GroupedCheckResults format\n// This is for backward compatibility with tests only\nexport function convertReviewSummaryToGroupedResults(\n  reviewSummary: ReviewSummary,\n  checkName: string = 'test-check',\n  groupName: string = 'default'\n): GroupedCheckResults {\n  // Create a simple content string from issues\n  let content = '';\n\n  if (reviewSummary.issues && reviewSummary.issues.length > 0) {\n    content += `## Issues Found (${reviewSummary.issues.length})\\n\\n`;\n    reviewSummary.issues.forEach(issue => {\n      content += `- **${issue.severity.toUpperCase()}**: ${issue.message} (${issue.file}:${issue.line})\\n`;\n    });\n    content += '\\n';\n  }\n\n  if (!content) {\n    content = 'No issues found.';\n  }\n\n  const checkResult: CheckResult = {\n    checkName,\n    content: content.trim(),\n    group: groupName,\n    debug: reviewSummary.debug,\n    issues: reviewSummary.issues, // Include structured issues\n  };\n\n  const groupedResults: GroupedCheckResults = {};\n  groupedResults[groupName] = [checkResult];\n\n  return groupedResults;\n}\n\n// Helper functions for GitHub checks - ONLY for structured schemas that have issues\n// These are the ONLY acceptable hardcoded schema dependencies, and only for GitHub integration\nexport function calculateTotalIssues(issues?: ReviewIssue[]): number {\n  return (issues || []).length;\n}\n\nexport function calculateCriticalIssues(issues?: ReviewIssue[]): number {\n  return (issues || []).filter(i => i.severity === 'critical').length;\n}\n\n// Legacy converter - ONLY for GitHub integration compatibility\nexport function convertIssuesToComments(issues: ReviewIssue[]): ReviewComment[] {\n  return issues.map(issue => ({\n    file: issue.file,\n    line: issue.line,\n    message: issue.message,\n    severity: issue.severity,\n    category: issue.category,\n    suggestion: issue.suggestion,\n    replacement: issue.replacement,\n    ruleId: issue.ruleId,\n  }));\n}\n\nexport interface ReviewOptions {\n  focus?: string;\n  format?: 'table' | 'json' | 'markdown' | 'sarif';\n  debug?: boolean;\n  config?: import('./types/config').VisorConfig;\n  checks?: string[];\n  parallelExecution?: boolean;\n  // Optional tag filter to include/exclude checks by tags when running via GitHub Action path\n  tagFilter?: import('./types/config').TagFilter;\n}\n\nexport class PRReviewer {\n  private commentManager: CommentManager;\n  private aiReviewService: AIReviewService;\n\n  constructor(private octokit: Octokit) {\n    this.commentManager = new CommentManager(octokit);\n    this.aiReviewService = new AIReviewService();\n  }\n\n  async reviewPR(\n    owner: string,\n    repo: string,\n    prNumber: number,\n    prInfo: PRInfo,\n    options: ReviewOptions = {}\n  ): Promise<GroupedCheckResults> {\n    const { debug = false, config, checks } = options;\n\n    if (config && checks && checks.length > 0) {\n      const { CheckExecutionEngine } = await import('./check-execution-engine');\n      const engine = new CheckExecutionEngine();\n      const { results } = await engine.executeGroupedChecks(\n        prInfo,\n        checks,\n        undefined,\n        config,\n        undefined,\n        debug,\n        undefined,\n        undefined,\n        options.tagFilter\n      );\n      return results;\n    }\n\n    throw new Error(\n      'No configuration provided. Please create a .visor.yaml file with check definitions. ' +\n        'Built-in prompts have been removed - all checks must be explicitly configured.'\n    );\n  }\n\n  /**\n   * Helper to check if a schema is comment-generating\n   * Comment-generating schemas include:\n   * - Built-in schemas: code-review, overview, plain, text\n   * - Custom schemas with a \"text\" field in properties\n   */\n  private async isCommentGeneratingSchema(\n    schema: string | Record<string, unknown>\n  ): Promise<boolean> {\n    try {\n      // Check for built-in comment-generating schemas\n      if (typeof schema === 'string') {\n        // Well-known comment-generating schemas\n        if (['code-review', 'overview', 'plain', 'text'].includes(schema)) {\n          return true;\n        }\n\n        // Try to load and check custom string schema\n        const fs = require('fs').promises;\n        const path = require('path');\n\n        // Sanitize schema name\n        const sanitizedSchemaName = schema.replace(/[^a-zA-Z0-9-]/g, '');\n        if (!sanitizedSchemaName || sanitizedSchemaName !== schema) {\n          return false;\n        }\n\n        // Locate built-in schema JSON. In Actions, schemas live under dist/output (relative to __dirname).\n        // In local dev/tests, schemas live under project/output (relative to CWD).\n        const candidatePaths = [\n          path.join(__dirname, 'output', sanitizedSchemaName, 'schema.json'),\n          path.join(process.cwd(), 'output', sanitizedSchemaName, 'schema.json'),\n        ];\n\n        for (const schemaPath of candidatePaths) {\n          try {\n            const schemaContent = await fs.readFile(schemaPath, 'utf-8');\n            const schemaObj = JSON.parse(schemaContent);\n\n            // Check if schema has a \"text\" field in properties\n            const properties = schemaObj.properties as Record<string, unknown> | undefined;\n            return !!(properties && 'text' in properties);\n          } catch {\n            // try next location\n          }\n        }\n        // Schema file not found in any known location, not comment-generating\n        return false;\n      } else {\n        // Inline schema object - check if it has a \"text\" field in properties\n        const properties = schema.properties as Record<string, unknown> | undefined;\n        return !!(properties && 'text' in properties);\n      }\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Filter check results to only include those that should post GitHub comments\n   */\n  private async filterCommentGeneratingChecks(\n    checkResults: CheckResult[],\n    config: import('./types/config').VisorConfig\n  ): Promise<CheckResult[]> {\n    const filtered: CheckResult[] = [];\n\n    for (const r of checkResults) {\n      const cfg = config.checks?.[r.checkName];\n      const type = cfg?.type || 'ai'; // Default to 'ai' if not specified\n      const schema = cfg?.schema;\n\n      // Determine if this check should generate a comment\n      // Include checks with:\n      // 1. type: 'ai' or 'claude-code' with no schema or comment-generating schemas\n      // 2. Other types ONLY if they have explicit comment-generating schemas\n      let shouldPostComment = false;\n\n      // AI-powered checks generate comments by default\n      const isAICheck = type === 'ai' || type === 'claude-code';\n\n      if (!schema || schema === '') {\n        // No schema specified - only AI checks generate comments by default\n        // Other types (github, command, http, etc.) without schema are for orchestration\n        shouldPostComment = isAICheck;\n      } else {\n        // Check if the schema is comment-generating (built-in or custom with text field)\n        shouldPostComment = await this.isCommentGeneratingSchema(schema);\n      }\n\n      if (shouldPostComment) {\n        filtered.push(r);\n      }\n    }\n\n    return filtered;\n  }\n\n  async postReviewComment(\n    owner: string,\n    repo: string,\n    prNumber: number,\n    groupedResults: GroupedCheckResults,\n    options: ReviewOptions & { commentId?: string; triggeredBy?: string; commitSha?: string } = {}\n  ): Promise<void> {\n    // Post separate comments for each group\n    for (const [groupName, checkResults] of Object.entries(groupedResults)) {\n      // Only checks with comment-generating schemas should post PR comments\n      // AI checks (ai, claude-code) generate comments by default\n      // Other types need explicit comment-generating schemas\n      let filteredResults = options.config\n        ? await this.filterCommentGeneratingChecks(checkResults, options.config)\n        : checkResults;\n\n      // Collapse results to avoid concatenating mutually-exclusive or duplicate posts.\n      // For fact-validation flow, both 'post-verified-response' and 'post-unverified-warning'\n      // can appear across waves. Prefer the final intended output and drop earlier entries.\n      if (groupName === 'github-output' && filteredResults && filteredResults.length > 1) {\n        // Keep only the last occurrence per checkName.\n        const byName = new Map<string, any>();\n        for (const cr of filteredResults) byName.set(cr.checkName, cr);\n        let collapsed = Array.from(byName.values());\n        const hasVerified = collapsed.some((r: any) => r.checkName === 'post-verified-response');\n        if (hasVerified) {\n          collapsed = collapsed.filter((r: any) => r.checkName !== 'post-unverified-warning');\n        }\n        filteredResults = collapsed as any;\n      }\n\n      // If nothing to report after filtering, skip this group\n      if (!filteredResults || filteredResults.length === 0) {\n        continue;\n      }\n\n      const comment = await this.formatGroupComment(filteredResults, options, {\n        owner,\n        repo,\n        prNumber,\n        commitSha: options.commitSha,\n      });\n\n      // Generate comment ID - use unique ID for \"dynamic\" group\n      let commentId: string;\n      if (groupName === 'dynamic') {\n        // Dynamic group creates a new comment each time with timestamp-based ID\n        const timestamp = Date.now();\n        commentId = `visor-dynamic-${timestamp}`;\n      } else {\n        // Regular groups use static IDs that get updated\n        commentId = options.commentId\n          ? `${options.commentId}-${groupName}`\n          : `visor-review-${groupName}`;\n      }\n\n      // Do not post empty comments (possible if content is blank after fallbacks)\n      if (!comment || !comment.trim()) continue;\n\n      await this.commentManager.updateOrCreateComment(owner, repo, prNumber, comment, {\n        commentId,\n        triggeredBy: options.triggeredBy || 'unknown',\n        allowConcurrentUpdates: false,\n        commitSha: options.commitSha,\n      });\n    }\n  }\n\n  private async formatGroupComment(\n    checkResults: CheckResult[],\n    _options: ReviewOptions,\n    _githubContext?: { owner: string; repo: string; prNumber: number; commitSha?: string }\n  ): Promise<string> {\n    // Concatenate all check outputs in this group; fall back to structured output fields\n    const normalize = (s: string) => s.replace(/\\\\n/g, '\\n');\n    const checkContents = checkResults\n      .map(result => {\n        const trimmed = result.content?.trim();\n        if (trimmed) return normalize(trimmed);\n        // Fallback: if provider returned structured output with a common text field\n        const out = (result as unknown as { debug?: unknown; issues?: unknown; output?: any })\n          .output;\n        if (out) {\n          if (typeof out === 'string' && out.trim()) return normalize(out.trim());\n          if (typeof out === 'object') {\n            const txt = (out.text || out.response || out.message) as unknown;\n            if (typeof txt === 'string' && txt.trim()) return normalize(txt.trim());\n          }\n        }\n        return '';\n      })\n      .filter(content => content && content.trim());\n\n    // Add debug info if any check has it\n    const debugInfo = checkResults.find(result => result.debug)?.debug;\n\n    // Only generate comment if there's actual content or debug info\n    if (checkContents.length === 0 && !debugInfo) {\n      return '';\n    }\n\n    let comment = '';\n    comment += `## 🔍 Code Analysis Results\\n\\n`;\n    comment += checkContents.join('\\n\\n');\n\n    if (debugInfo) {\n      comment += '\\n\\n' + this.formatDebugSection(debugInfo);\n      comment += '\\n\\n';\n    }\n\n    // Footer will be added by formatCommentWithMetadata in github-comments.ts\n    return comment;\n  }\n\n  private formatDebugSection(debug: AIDebugInfo): string {\n    const formattedContent = [\n      `**Provider:** ${debug.provider}`,\n      `**Model:** ${debug.model}`,\n      `**API Key Source:** ${debug.apiKeySource}`,\n      `**Processing Time:** ${debug.processingTime}ms`,\n      `**Timestamp:** ${debug.timestamp}`,\n      `**Prompt Length:** ${debug.promptLength} characters`,\n      `**Response Length:** ${debug.responseLength} characters`,\n      `**JSON Parse Success:** ${debug.jsonParseSuccess ? '✅' : '❌'}`,\n    ];\n\n    if (debug.errors && debug.errors.length > 0) {\n      formattedContent.push('', '### Errors');\n      debug.errors.forEach(error => {\n        formattedContent.push(`- ${error}`);\n      });\n    }\n\n    const fullDebugContent = [\n      ...formattedContent,\n      '',\n      '### AI Prompt',\n      '```',\n      debug.prompt,\n      '```',\n      '',\n      '### Raw AI Response',\n      '```json',\n      debug.rawResponse,\n      '```',\n    ].join('\\n');\n\n    if (fullDebugContent.length > 60000) {\n      const artifactPath = this.saveDebugArtifact(debug);\n      formattedContent.push('');\n      formattedContent.push('### Debug Details');\n      formattedContent.push('⚠️ Debug information is too large for GitHub comments.');\n      if (artifactPath) {\n        formattedContent.push(\n          `📁 **Full debug information saved to artifact:** \\`${artifactPath}\\``\n        );\n        formattedContent.push('');\n        const runId = process.env.GITHUB_RUN_ID;\n        const repoUrl =\n          process.env.GITHUB_SERVER_URL && process.env.GITHUB_REPOSITORY\n            ? `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}`\n            : null;\n        if (runId && repoUrl) {\n          formattedContent.push(\n            `🔗 **Download Link:** [visor-debug-${process.env.GITHUB_RUN_NUMBER || runId}](${repoUrl}/actions/runs/${runId})`\n          );\n        }\n        formattedContent.push(\n          '💡 Go to the GitHub Action run above and download the debug artifact to view complete prompts and responses.'\n        );\n      } else {\n        formattedContent.push('📝 **Prompt preview:** ' + debug.prompt.substring(0, 500) + '...');\n        formattedContent.push(\n          '📝 **Response preview:** ' + debug.rawResponse.substring(0, 500) + '...'\n        );\n      }\n    } else {\n      formattedContent.push('');\n      formattedContent.push('### AI Prompt');\n      formattedContent.push('```');\n      formattedContent.push(debug.prompt);\n      formattedContent.push('```');\n      formattedContent.push('');\n      formattedContent.push('### Raw AI Response');\n      formattedContent.push('```json');\n      formattedContent.push(debug.rawResponse);\n      formattedContent.push('```');\n    }\n\n    return this.commentManager.createCollapsibleSection(\n      '🐛 Debug Information',\n      formattedContent.join('\\n'),\n      false\n    );\n  }\n\n  private saveDebugArtifact(debug: AIDebugInfo): string | null {\n    try {\n      const fs = require('fs');\n      const path = require('path');\n      const debugDir = path.join(process.cwd(), 'debug-artifacts');\n      if (!fs.existsSync(debugDir)) {\n        fs.mkdirSync(debugDir, { recursive: true });\n      }\n\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n      const filename = `visor-debug-${timestamp}.md`;\n      const filepath = path.join(debugDir, filename);\n\n      const content = [\n        `# Visor Debug Information`,\n        ``,\n        `**Timestamp:** ${debug.timestamp}`,\n        `**Provider:** ${debug.provider}`,\n        `**Model:** ${debug.model}`,\n        `**Processing Time:** ${debug.processingTime}ms`,\n        ``,\n        `## AI Prompt`,\n        ``,\n        '```',\n        debug.prompt,\n        '```',\n        ``,\n        `## Raw AI Response`,\n        ``,\n        '```json',\n        debug.rawResponse,\n        '```',\n      ].join('\\n');\n\n      fs.writeFileSync(filepath, content, 'utf8');\n      return filename;\n    } catch (error) {\n      console.error('Failed to save debug artifact:', error);\n      return null;\n    }\n  }\n}\n","import ignore from 'ignore';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n/**\n * Default exclusion patterns for common build artifacts and dependencies.\n * These can be overridden by providing custom patterns to the constructor.\n */\nconst DEFAULT_EXCLUSION_PATTERNS = [\n  'dist/',\n  'build/',\n  '.next/',\n  'out/',\n  'node_modules/',\n  'coverage/',\n  '.turbo/',\n  'bundled/',\n];\n\n/**\n * Shared utility for filtering files based on .gitignore patterns\n *\n * Design Decision: Synchronous I/O in Constructor\n * ------------------------------------------------\n * This class intentionally uses synchronous file I/O in the constructor for the following reasons:\n *\n * 1. **Initialization Context**: The constructor is called once during application startup,\n *    not in request handling or performance-critical paths.\n *\n * 2. **Small File Sizes**: .gitignore files are typically <10KB. Even in large monorepos,\n *    they rarely exceed 100KB. Reading such small files synchronously has negligible impact.\n *\n * 3. **Immediate Availability**: The exclusion patterns must be ready immediately for use.\n *    Asynchronous initialization would require either:\n *    - Async factory method (adds API complexity)\n *    - Lazy loading (race conditions, repeated checks)\n *    - Promise-based initialization (complicates usage across codebase)\n *\n * 4. **Simplicity**: Synchronous loading keeps the API simple and prevents async contagion\n *    throughout the codebase. Methods like shouldExcludeFile() remain synchronous.\n *\n * 5. **No DoS Risk**: The file reading happens exactly once per instance during construction.\n *    Attackers cannot trigger repeated synchronous reads.\n *\n * 6. **Consistency**: This follows the same pattern as other configuration loaders in Node.js\n *    ecosystem (e.g., require(), cosmiconfig's sync mode).\n *\n * Alternative Considered: Async factory pattern would add complexity without meaningful benefit\n * given the usage patterns and file sizes involved.\n */\nexport class FileExclusionHelper {\n  private gitignore: ReturnType<typeof ignore> | null = null;\n  private workingDirectory: string;\n\n  /**\n   * @param workingDirectory - Directory to search for .gitignore\n   * @param additionalPatterns - Additional patterns to include (optional, defaults to common build artifacts)\n   */\n  constructor(\n    workingDirectory: string = process.cwd(),\n    additionalPatterns: string[] | null = DEFAULT_EXCLUSION_PATTERNS\n  ) {\n    // Validate and normalize workingDirectory to prevent path traversal\n    const normalizedPath = path.resolve(workingDirectory);\n\n    // Ensure path doesn't contain suspicious patterns after normalization\n    // Check for null bytes which could be used for injection\n    if (normalizedPath.includes('\\0')) {\n      throw new Error('Invalid workingDirectory: contains null bytes');\n    }\n\n    this.workingDirectory = normalizedPath;\n\n    // Load gitignore synchronously during construction\n    // This is acceptable because:\n    // 1. Constructor is called once during initialization\n    // 2. .gitignore files are typically small (<10KB)\n    // 3. Synchronous loading ensures patterns are ready immediately\n    // 4. Avoids async constructor complexity\n    this.loadGitignore(additionalPatterns);\n  }\n\n  /**\n   * Load .gitignore patterns from the working directory (called once in constructor)\n   * @param additionalPatterns - Additional patterns to add to gitignore rules\n   */\n  private loadGitignore(additionalPatterns: string[] | null): void {\n    // Resolve both paths to absolute, normalized forms\n    const gitignorePath = path.resolve(this.workingDirectory, '.gitignore');\n    const resolvedWorkingDir = path.resolve(this.workingDirectory);\n\n    try {\n      // Robust path validation using path.relative()\n      // This handles symlinks and edge cases better than string comparison\n      const relativePath = path.relative(resolvedWorkingDir, gitignorePath);\n\n      // Security check: ensure .gitignore is within working directory\n      // Reject if:\n      // - Starts with '..' (parent directory)\n      // - Is an absolute path (should be relative after path.relative())\n      if (relativePath.startsWith('..') || path.isAbsolute(relativePath)) {\n        throw new Error('Invalid gitignore path: path traversal detected');\n      }\n\n      // Additionally verify it's exactly '.gitignore' (no subdirectories)\n      if (relativePath !== '.gitignore') {\n        throw new Error('Invalid gitignore path: must be .gitignore in working directory');\n      }\n\n      this.gitignore = ignore();\n\n      // Add additional patterns first (lower priority)\n      if (additionalPatterns && additionalPatterns.length > 0) {\n        this.gitignore.add(additionalPatterns);\n      }\n\n      // Load and add .gitignore patterns (higher priority)\n      if (fs.existsSync(gitignorePath)) {\n        const rawContent = fs.readFileSync(gitignorePath, 'utf8');\n\n        // Comprehensive sanitization to prevent injection attacks\n        const gitignoreContent = rawContent\n          .replace(/[\\r\\n]+/g, '\\n') // Normalize line endings first\n          .replace(/[\\x00-\\x09\\x0B-\\x1F\\x7F]/g, '') // Remove control chars except \\n (0x0A)\n          .split('\\n')\n          .filter(line => line.length < 1000) // Reject extremely long lines that could cause DoS\n          .join('\\n')\n          .trim();\n\n        this.gitignore.add(gitignoreContent);\n        console.error('✅ Loaded .gitignore patterns for file filtering');\n      } else if (additionalPatterns && additionalPatterns.length > 0) {\n        console.error('⚠️  No .gitignore found, using default exclusion patterns');\n      }\n    } catch (error) {\n      console.warn('⚠️ Failed to load .gitignore:', error instanceof Error ? error.message : error);\n    }\n  }\n\n  /**\n   * Check if a file should be excluded based on .gitignore patterns\n   */\n  shouldExcludeFile(filename: string): boolean {\n    // Check against .gitignore patterns if loaded\n    if (this.gitignore) {\n      return this.gitignore.ignores(filename);\n    }\n\n    return false;\n  }\n}\n","import { simpleGit, SimpleGit, type DefaultLogFields, type ListLogLine } from 'simple-git';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport { PRInfo, PRDiff } from './pr-analyzer';\nimport { FileExclusionHelper } from './utils/file-exclusion';\n\nexport interface GitFileChange {\n  filename: string;\n  status: 'added' | 'removed' | 'modified' | 'renamed';\n  additions: number;\n  deletions: number;\n  changes: number;\n  content?: string;\n  patch?: string;\n  truncated?: boolean;\n}\n\n// Maximum patch size in bytes (50KB) - helps prevent token limit issues\nconst MAX_PATCH_SIZE = 50 * 1024;\n\nexport interface GitRepositoryInfo {\n  title: string;\n  body: string;\n  author: string;\n  base: string;\n  head: string;\n  files: GitFileChange[];\n  totalAdditions: number;\n  totalDeletions: number;\n  isGitRepository: boolean;\n  workingDirectory: string;\n}\n\nexport class GitRepositoryAnalyzer {\n  private git: SimpleGit;\n  private cwd: string;\n  private fileExclusionHelper: FileExclusionHelper;\n\n  constructor(workingDirectory: string = process.cwd()) {\n    this.cwd = workingDirectory;\n    this.git = simpleGit(workingDirectory);\n    this.fileExclusionHelper = new FileExclusionHelper(workingDirectory);\n  }\n\n  /**\n   * Analyze the current git repository state and return data compatible with PRInfo interface\n   */\n  async analyzeRepository(\n    includeContext: boolean = true,\n    enableBranchDiff: boolean = false\n  ): Promise<GitRepositoryInfo> {\n    // Check if we're in a git repository\n    const isRepo = await this.isGitRepository();\n    if (!isRepo) {\n      return this.createEmptyRepositoryInfo('Not a git repository');\n    }\n\n    try {\n      // Get current branch and status\n      const [status, currentBranch, baseBranch] = await Promise.all([\n        this.git.status(),\n        this.getCurrentBranch(),\n        this.getBaseBranch(),\n      ]);\n\n      // Determine if we're on a feature branch\n      const isFeatureBranch =\n        currentBranch !== baseBranch && currentBranch !== 'main' && currentBranch !== 'master';\n\n      // Get uncommitted changes first\n      let uncommittedFiles = await this.getUncommittedChanges(includeContext);\n\n      // If branch diff is explicitly enabled, use branch diff (ignoring uncommitted changes)\n      // Otherwise, if on a feature branch with no uncommitted changes AND branch diff is enabled, get diff vs base branch\n      if (isFeatureBranch && includeContext && enableBranchDiff) {\n        if (uncommittedFiles.length > 0) {\n          console.error(`📊 Feature branch detected: ${currentBranch}`);\n          console.error(\n            `⚠️  Ignoring ${uncommittedFiles.length} uncommitted file(s) due to --analyze-branch-diff flag`\n          );\n        } else {\n          console.error(`📊 Feature branch detected: ${currentBranch}`);\n        }\n        console.error(\n          `📂 Analyzing diff vs ${baseBranch} (${uncommittedFiles.length > 0 ? 'forced by --analyze-branch-diff' : 'auto-enabled for code-review schemas'})`\n        );\n        uncommittedFiles = await this.getBranchDiff(baseBranch, includeContext);\n      } else if (uncommittedFiles.length > 0) {\n        console.error(`📝 Analyzing uncommitted changes (${uncommittedFiles.length} files)`);\n      }\n\n      // Get recent commit info (handle repos with no commits)\n      let lastCommit: (ListLogLine & DefaultLogFields) | null = null;\n      try {\n        const recentCommits = await this.git.log({ maxCount: 1 });\n        lastCommit = recentCommits.latest;\n      } catch {\n        // Repository has no commits yet - this is OK\n        console.error('📝 Repository has no commits yet, analyzing uncommitted changes');\n      }\n\n      // Get author from git config if no commits exist\n      let author = lastCommit?.author_name;\n      if (!author) {\n        try {\n          // Read ONLY repository-local config to avoid leaking global user identity into tests\n          const [userName, userEmail] = await Promise.all([\n            this.git.raw(['config', '--local', 'user.name']).catch(() => null),\n            this.git.raw(['config', '--local', 'user.email']).catch(() => null),\n          ]);\n          author = userName?.trim() || userEmail?.trim() || 'unknown';\n        } catch {\n          author = 'unknown';\n        }\n      }\n\n      // Create repository info\n      const repositoryInfo: GitRepositoryInfo = {\n        title: this.generateTitle(status, currentBranch),\n        body: this.generateDescription(status, lastCommit),\n        author,\n        base: baseBranch,\n        head: currentBranch,\n        files: uncommittedFiles,\n        totalAdditions: uncommittedFiles.reduce((sum, file) => sum + file.additions, 0),\n        totalDeletions: uncommittedFiles.reduce((sum, file) => sum + file.deletions, 0),\n        isGitRepository: true,\n        workingDirectory: this.cwd,\n      };\n\n      return repositoryInfo;\n    } catch (error) {\n      // Don't log the full error object to avoid confusing stack traces\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      console.error('Error analyzing git repository:', errorMessage);\n      return this.createEmptyRepositoryInfo('Error analyzing git repository');\n    }\n  }\n\n  /**\n   * Convert GitRepositoryInfo to PRInfo format for compatibility with existing PRReviewer\n   */\n  toPRInfo(repositoryInfo: GitRepositoryInfo, includeContext: boolean = true): PRInfo {\n    const files = repositoryInfo.files.map(\n      (file): PRDiff => ({\n        filename: file.filename,\n        additions: file.additions,\n        deletions: file.deletions,\n        changes: file.changes,\n        patch: includeContext ? file.patch : undefined,\n        status: file.status,\n      })\n    );\n\n    // Generate fullDiff from patches if includeContext is true\n    let fullDiff: string | undefined;\n    if (includeContext) {\n      fullDiff = files\n        .filter(file => file.patch)\n        .map(file => `--- ${file.filename}\\n${file.patch}`)\n        .join('\\n\\n');\n    }\n\n    return {\n      number: 0, // Local analysis doesn't have PR number\n      title: repositoryInfo.title,\n      body: repositoryInfo.body,\n      author: repositoryInfo.author,\n      base: repositoryInfo.base,\n      head: repositoryInfo.head,\n      files,\n      totalAdditions: repositoryInfo.totalAdditions,\n      totalDeletions: repositoryInfo.totalDeletions,\n      fullDiff,\n    };\n  }\n\n  private async isGitRepository(): Promise<boolean> {\n    try {\n      await this.git.checkIsRepo();\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  private async getCurrentBranch(): Promise<string> {\n    try {\n      const branchSummary = await this.git.branch();\n      return branchSummary.current || 'unknown';\n    } catch {\n      return 'unknown';\n    }\n  }\n\n  private async getBaseBranch(): Promise<string> {\n    try {\n      // Try to get the default branch from remote\n      const branches = await this.git.branch(['-r']);\n      const mainBranches = ['origin/main', 'origin/master', 'origin/develop'];\n\n      for (const mainBranch of mainBranches) {\n        if (branches.all.includes(mainBranch)) {\n          return mainBranch.replace('origin/', '');\n        }\n      }\n\n      // Fallback to main/master\n      return 'main';\n    } catch {\n      return 'main';\n    }\n  }\n\n  /**\n   * Truncate a patch if it exceeds MAX_PATCH_SIZE\n   */\n  private truncatePatch(patch: string, filename: string): { patch: string; truncated: boolean } {\n    const patchSize = Buffer.byteLength(patch, 'utf8');\n\n    if (patchSize <= MAX_PATCH_SIZE) {\n      return { patch, truncated: false };\n    }\n\n    // Truncate to MAX_PATCH_SIZE and add a notice\n    const truncated = patch.substring(0, MAX_PATCH_SIZE);\n    const truncatedPatch = `${truncated}\\n\\n... [TRUNCATED: Diff too large (${(patchSize / 1024).toFixed(1)}KB), showing first ${(MAX_PATCH_SIZE / 1024).toFixed(0)}KB] ...`;\n\n    console.error(\n      `⚠️  Truncated diff for ${filename} (${(patchSize / 1024).toFixed(1)}KB → ${(MAX_PATCH_SIZE / 1024).toFixed(0)}KB)`\n    );\n\n    return { patch: truncatedPatch, truncated: true };\n  }\n\n  private async getRemoteInfo(): Promise<{ name: string; url: string } | null> {\n    try {\n      const remotes = await this.git.getRemotes(true);\n      const origin = remotes.find(r => r.name === 'origin');\n      return origin\n        ? { name: origin.name, url: origin.refs.fetch || origin.refs.push || '' }\n        : null;\n    } catch {\n      return null;\n    }\n  }\n\n  private async getUncommittedChanges(includeContext: boolean = true): Promise<GitFileChange[]> {\n    try {\n      const status = await this.git.status();\n      const changes: GitFileChange[] = [];\n\n      // Process different types of changes\n      const fileChanges = [\n        ...status.created.map(f => ({ file: f, status: 'added' as const })),\n        ...status.deleted.map(f => ({ file: f, status: 'removed' as const })),\n        ...status.modified.map(f => ({ file: f, status: 'modified' as const })),\n        ...status.renamed.map(f => ({\n          file: typeof f === 'string' ? f : f.to || f.from,\n          status: 'renamed' as const,\n        })),\n      ];\n\n      for (const { file, status } of fileChanges) {\n        // Skip files that should be excluded from analysis\n        // FileExclusionHelper uses .gitignore patterns, which is sufficient\n        if (this.fileExclusionHelper.shouldExcludeFile(file)) {\n          console.error(`⏭️  Skipping excluded file: ${file}`);\n          continue;\n        }\n\n        const filePath = path.join(this.cwd, file);\n        const fileChange = await this.analyzeFileChange(file, status, filePath, includeContext);\n        changes.push(fileChange);\n      }\n\n      return changes;\n    } catch (error) {\n      console.error('Error getting uncommitted changes:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Get diff between current branch and base branch (for feature branch analysis)\n   */\n  private async getBranchDiff(\n    baseBranch: string,\n    includeContext: boolean = true\n  ): Promise<GitFileChange[]> {\n    try {\n      // Get the list of changed files between base and current branch\n      const diffSummary = await this.git.diffSummary([baseBranch]);\n      const changes: GitFileChange[] = [];\n\n      if (!diffSummary || !diffSummary.files) {\n        return [];\n      }\n\n      for (const file of diffSummary.files) {\n        // Skip files that should be excluded from analysis\n        // FileExclusionHelper uses .gitignore patterns, which is sufficient\n        if (this.fileExclusionHelper.shouldExcludeFile(file.file)) {\n          console.error(`⏭️  Skipping excluded file: ${file.file}`);\n          continue;\n        }\n\n        // Handle different file types (binary files don't have insertions/deletions)\n        const isBinary = 'binary' in file && file.binary;\n        const insertions = 'insertions' in file ? file.insertions : 0;\n        const deletions = 'deletions' in file ? file.deletions : 0;\n        const fileChanges = 'changes' in file ? file.changes : 0;\n\n        // Determine status based on insertions/deletions\n        let status: 'added' | 'removed' | 'modified' | 'renamed';\n        if (isBinary) {\n          status = 'modified';\n        } else if (insertions > 0 && deletions === 0) {\n          status = 'added';\n        } else if (insertions === 0 && deletions > 0) {\n          status = 'removed';\n        } else {\n          status = 'modified';\n        }\n\n        // Get the actual diff patch if needed\n        let patch: string | undefined;\n        let truncated = false;\n        if (includeContext && !isBinary) {\n          try {\n            const rawPatch = await this.git.diff([baseBranch, '--', file.file]);\n            if (rawPatch) {\n              const result = this.truncatePatch(rawPatch, file.file);\n              patch = result.patch;\n              truncated = result.truncated;\n            }\n          } catch {\n            // Ignore diff errors for specific files\n          }\n        }\n\n        const fileChange: GitFileChange = {\n          filename: file.file,\n          additions: insertions,\n          deletions: deletions,\n          changes: fileChanges,\n          status,\n          patch,\n          truncated,\n        };\n\n        changes.push(fileChange);\n      }\n\n      return changes;\n    } catch (error) {\n      console.error('Error getting branch diff:', error);\n      return [];\n    }\n  }\n\n  private async analyzeFileChange(\n    filename: string,\n    status: 'added' | 'removed' | 'modified' | 'renamed',\n    filePath: string,\n    includeContext: boolean = true\n  ): Promise<GitFileChange> {\n    let additions = 0;\n    let deletions = 0;\n    let patch: string | undefined;\n    let content: string | undefined;\n    let truncated = false;\n\n    try {\n      // Get diff for the file if it exists and is not binary\n      if (includeContext && status !== 'added' && fs.existsSync(filePath)) {\n        const diff = await this.git.diff(['--', filename]).catch(() => '');\n        if (diff) {\n          const result = this.truncatePatch(diff, filename);\n          patch = result.patch;\n          truncated = result.truncated;\n          // Count additions and deletions from diff\n          const lines = diff.split('\\n');\n          additions = lines.filter(line => line.startsWith('+')).length;\n          deletions = lines.filter(line => line.startsWith('-')).length;\n        }\n      } else if (status !== 'added' && fs.existsSync(filePath)) {\n        // If not including context, still count changes for statistics\n        const diff = await this.git.diff(['--', filename]).catch(() => '');\n        if (diff) {\n          const lines = diff.split('\\n');\n          additions = lines.filter(line => line.startsWith('+')).length;\n          deletions = lines.filter(line => line.startsWith('-')).length;\n        }\n      }\n\n      // For added files\n      if (status === 'added' && fs.existsSync(filePath)) {\n        try {\n          const stats = fs.statSync(filePath);\n          if (stats.isFile() && stats.size < 1024 * 1024) {\n            // Skip files larger than 1MB\n            if (includeContext) {\n              content = fs.readFileSync(filePath, 'utf8');\n              const result = this.truncatePatch(content, filename);\n              patch = result.patch; // For new files, the entire content is the \"patch\"\n              truncated = result.truncated;\n            }\n            // Always count additions for statistics\n            const fileContent = includeContext ? content : fs.readFileSync(filePath, 'utf8');\n            additions = fileContent!.split('\\n').length;\n          }\n        } catch {\n          // Skip binary or unreadable files\n        }\n      }\n\n      // For removed files, we can't easily count the lines without the previous version\n      if (status === 'removed') {\n        deletions = 1; // Placeholder - in real git we'd need the previous version\n      }\n    } catch (error) {\n      console.error(`Error analyzing file change for ${filename}:`, error);\n    }\n\n    return {\n      filename,\n      status,\n      additions,\n      deletions,\n      changes: additions + deletions,\n      content,\n      patch,\n      truncated,\n    };\n  }\n\n  private generateTitle(status: import('simple-git').StatusResult, branch: string): string {\n    if (status.files.length === 0) {\n      return `Local Analysis: ${branch} (No changes)`;\n    }\n\n    const changeTypes = [];\n    if (status.created.length > 0) changeTypes.push(`${status.created.length} added`);\n    if (status.modified.length > 0) changeTypes.push(`${status.modified.length} modified`);\n    if (status.deleted.length > 0) changeTypes.push(`${status.deleted.length} deleted`);\n    if (status.renamed.length > 0) changeTypes.push(`${status.renamed.length} renamed`);\n\n    return `Local Analysis: ${branch} (${changeTypes.join(', ')})`;\n  }\n\n  private generateDescription(\n    status: import('simple-git').StatusResult,\n    lastCommit: import('simple-git').DefaultLogFields | null\n  ): string {\n    let description = `Analysis of local git repository working directory.\\n\\n`;\n\n    if (lastCommit) {\n      description += `**Last Commit:** ${lastCommit.message}\\n`;\n      description += `**Author:** ${lastCommit.author_name} <${lastCommit.author_email}>\\n`;\n      description += `**Date:** ${lastCommit.date}\\n\\n`;\n    }\n\n    if (status.files.length === 0) {\n      description += `**Status:** Working directory is clean - no uncommitted changes found.\\n`;\n    } else {\n      description += `**Changes Summary:**\\n`;\n      description += `- Files to be committed: ${status.staged.length}\\n`;\n      description += `- Modified files: ${status.modified.length}\\n`;\n      description += `- Untracked files: ${status.not_added.length}\\n`;\n\n      if (status.conflicted.length > 0) {\n        description += `- Conflicted files: ${status.conflicted.length}\\n`;\n      }\n    }\n\n    return description;\n  }\n\n  private createEmptyRepositoryInfo(reason: string): GitRepositoryInfo {\n    return {\n      title: `Local Analysis: ${reason}`,\n      body: `Unable to analyze repository: ${reason}`,\n      author: 'system',\n      base: 'main',\n      head: 'HEAD',\n      files: [],\n      totalAdditions: 0,\n      totalDeletions: 0,\n      isGitRepository: false,\n      workingDirectory: this.cwd,\n    };\n  }\n}\n","import { Octokit } from '@octokit/rest';\nimport * as path from 'path';\nimport { FileExclusionHelper } from './utils/file-exclusion';\n\nexport interface PRFile {\n  filename: string;\n  additions: number;\n  deletions: number;\n  changes: number;\n  patch?: string;\n  status: 'added' | 'removed' | 'modified' | 'renamed';\n}\n\nexport interface PRDiff {\n  filename: string;\n  additions: number;\n  deletions: number;\n  changes: number;\n  patch?: string;\n  status: 'added' | 'removed' | 'modified' | 'renamed';\n}\n\nexport interface PRComment {\n  id: number;\n  author: string;\n  body: string;\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface PRInfo {\n  number: number;\n  title: string;\n  body: string;\n  author: string;\n  authorAssociation?: string; // GitHub author_association: OWNER, MEMBER, COLLABORATOR, CONTRIBUTOR, etc.\n  base: string;\n  head: string;\n  files: PRDiff[];\n  totalAdditions: number;\n  totalDeletions: number;\n  eventType?: import('./types/config').EventTrigger;\n  fullDiff?: string;\n  commitDiff?: string;\n  isIncremental?: boolean; // Flag to indicate if this was intended as incremental analysis\n  isIssue?: boolean; // Flag to indicate this is an issue, not a PR\n  eventContext?: Record<string, unknown>; // GitHub event context for templates\n  comments?: PRComment[]; // Comments added dynamically\n  labels?: string[]; // Labels applied to the PR (for behavior overrides)\n}\n\ninterface NetworkError {\n  code?: string;\n  message?: string;\n  status?: number;\n}\n\nexport class PRAnalyzer {\n  private fileExclusionHelper: FileExclusionHelper;\n\n  constructor(\n    private octokit: Octokit,\n    private maxRetries: number = 3,\n    workingDirectory: string = path.resolve(process.cwd())\n  ) {\n    this.fileExclusionHelper = new FileExclusionHelper(workingDirectory);\n  }\n\n  /**\n   * Fetch commit diff for incremental analysis\n   */\n  async fetchCommitDiff(owner: string, repo: string, commitSha: string): Promise<string> {\n    try {\n      const { data: commit } = await this.withRetry(() =>\n        this.octokit.rest.repos.getCommit({\n          owner,\n          repo,\n          ref: commitSha,\n        })\n      );\n\n      // Extract patches from all files in the commit\n      const patches =\n        commit.files\n          ?.filter(file => file.patch)\n          .map(file => `--- ${file.filename}\\n${file.patch}`)\n          .join('\\n\\n') || '';\n\n      return patches;\n    } catch (error) {\n      console.warn(`Failed to fetch commit diff for ${commitSha}:`, error);\n      return '';\n    }\n  }\n\n  /**\n   * Generate unified diff for all PR files\n   */\n  private generateFullDiff(files: PRDiff[]): string {\n    return files\n      .filter(file => file.patch)\n      .map(file => `--- ${file.filename}\\n${file.patch}`)\n      .join('\\n\\n');\n  }\n\n  async fetchPRDiff(\n    owner: string,\n    repo: string,\n    prNumber: number,\n    commitSha?: string,\n    eventType?: import('./types/config').EventTrigger\n  ): Promise<PRInfo> {\n    const [prData, filesData] = await Promise.all([\n      this.withRetry(() =>\n        this.octokit.rest.pulls.get({\n          owner,\n          repo,\n          pull_number: prNumber,\n        })\n      ),\n      this.withRetry(() =>\n        this.octokit.rest.pulls.listFiles({\n          owner,\n          repo,\n          pull_number: prNumber,\n        })\n      ),\n    ]);\n\n    const pr = prData?.data;\n    const files = filesData?.data || [];\n\n    // Handle missing or malformed PR data gracefully\n    if (!pr) {\n      throw new Error('Invalid or missing pull request data');\n    }\n\n    // Validate critical fields and provide defaults for missing data\n    const title = typeof pr.title === 'string' ? pr.title : pr.title ? String(pr.title) : 'MISSING';\n    const body = typeof pr.body === 'string' ? pr.body : pr.body ? String(pr.body) : '';\n    const author =\n      pr.user && typeof pr.user === 'object' && pr.user.login\n        ? typeof pr.user.login === 'string'\n          ? pr.user.login\n          : String(pr.user.login)\n        : 'unknown';\n    const authorAssociation =\n      pr.author_association && typeof pr.author_association === 'string'\n        ? pr.author_association\n        : undefined;\n    const base =\n      pr.base && typeof pr.base === 'object' && pr.base.ref\n        ? typeof pr.base.ref === 'string'\n          ? pr.base.ref\n          : String(pr.base.ref)\n        : 'main';\n    const head =\n      pr.head && typeof pr.head === 'object' && pr.head.ref\n        ? typeof pr.head.ref === 'string'\n          ? pr.head.ref\n          : String(pr.head.ref)\n        : 'feature';\n\n    // Filter out malformed files and handle invalid data types\n    // Apply exclusion filtering early to avoid unnecessary processing\n    let skippedCount = 0;\n    const validFiles = files\n      ? files\n          .filter(file => file && typeof file === 'object' && file.filename)\n          .filter(file => {\n            // Early filtering: check exclusion before processing\n            const filename =\n              typeof file.filename === 'string'\n                ? file.filename\n                : String(file.filename || 'unknown');\n            if (!filename || this.fileExclusionHelper.shouldExcludeFile(filename)) {\n              skippedCount++;\n              return false;\n            }\n            return true;\n          })\n          .map(file => ({\n            filename:\n              typeof file.filename === 'string'\n                ? file.filename\n                : String(file.filename || 'unknown'),\n            additions: typeof file.additions === 'number' ? Math.max(0, file.additions) : 0,\n            deletions: typeof file.deletions === 'number' ? Math.max(0, file.deletions) : 0,\n            changes: typeof file.changes === 'number' ? Math.max(0, file.changes) : 0,\n            patch: typeof file.patch === 'string' ? file.patch : undefined,\n            status: (['added', 'removed', 'modified', 'renamed'].includes(file.status)\n              ? file.status\n              : 'modified') as 'added' | 'removed' | 'modified' | 'renamed',\n          }))\n      : [];\n\n    // Log skipped files summary\n    if (skippedCount > 0) {\n      console.log(`⏭️  Skipped ${skippedCount} excluded file(s)`);\n    }\n\n    const prInfo: PRInfo = {\n      number: typeof pr.number === 'number' ? pr.number : parseInt(String(pr.number || 1), 10),\n      title,\n      body,\n      author,\n      authorAssociation,\n      base,\n      head,\n      files: validFiles,\n      totalAdditions: validFiles.reduce((sum, file) => sum + file.additions, 0),\n      totalDeletions: validFiles.reduce((sum, file) => sum + file.deletions, 0),\n      fullDiff: this.generateFullDiff(validFiles),\n      eventType,\n    };\n\n    // Fetch comment history for better context\n    try {\n      console.log(`💬 Fetching comment history for PR #${prInfo.number}`);\n      const comments = await this.fetchPRComments(owner, repo, prInfo.number);\n      (prInfo as PRInfo & { comments: PRComment[] }).comments = comments;\n      console.log(`✅ Retrieved ${comments.length} comments`);\n    } catch (error) {\n      console.warn(\n        `⚠️ Could not fetch comments: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n      (prInfo as PRInfo & { comments: PRComment[] }).comments = [];\n    }\n\n    // Add commit diff for incremental analysis\n    if (commitSha) {\n      console.log(`🔧 Fetching incremental diff for commit: ${commitSha}`);\n      prInfo.commitDiff = await this.fetchCommitDiff(owner, repo, commitSha);\n      prInfo.isIncremental = true;\n      if (!prInfo.commitDiff || prInfo.commitDiff.length === 0) {\n        console.warn(\n          `⚠️ No commit diff retrieved for ${commitSha}, will use full diff as fallback`\n        );\n      } else {\n        console.log(`✅ Incremental diff retrieved (${prInfo.commitDiff.length} chars)`);\n      }\n    } else {\n      prInfo.isIncremental = false;\n    }\n\n    return prInfo;\n  }\n\n  async fetchPRComments(owner: string, repo: string, prNumber: number) {\n    const { data: comments } = await this.withRetry(() =>\n      this.octokit.rest.issues.listComments({\n        owner,\n        repo,\n        issue_number: prNumber,\n      })\n    );\n\n    return comments.map(comment => ({\n      id: comment.id,\n      author: comment.user?.login || 'unknown',\n      body: comment.body || '',\n      createdAt: comment.created_at,\n      updatedAt: comment.updated_at,\n    }));\n  }\n\n  private async withRetry<T>(operation: () => Promise<T>): Promise<T> {\n    let lastError: Error = new Error('Unknown error');\n\n    for (let attempt = 0; attempt <= this.maxRetries; attempt++) {\n      try {\n        return await operation();\n      } catch (error) {\n        // Preserve the original error object if possible\n        if (error instanceof Error) {\n          lastError = error;\n        } else if (typeof error === 'object' && error !== null) {\n          // For objects like {code: 'ETIMEDOUT', message: 'Network timeout'}\n          const errorObj = error as NetworkError;\n          const message = errorObj.message || errorObj.code || 'Unknown error';\n          lastError = new Error(String(message));\n          // Preserve important properties\n          Object.assign(lastError, error);\n        } else {\n          lastError = new Error(String(error));\n        }\n\n        // Don't retry on the last attempt\n        if (attempt === this.maxRetries) {\n          break;\n        }\n\n        // Check if this is a retryable error\n        if (this.isRetryableError(error)) {\n          const delay = Math.min(1000 * Math.pow(2, attempt), 5000); // Exponential backoff, max 5s\n          await new Promise(resolve => setTimeout(resolve, delay));\n        } else {\n          // Non-retryable error, fail immediately with original error\n          throw error;\n        }\n      }\n    }\n\n    throw lastError;\n  }\n\n  private isRetryableError(error: unknown): boolean {\n    // Retry on network timeouts, connection errors, and temporary server errors\n    const retryableErrors = ['ETIMEDOUT', 'ECONNRESET', 'ECONNREFUSED', 'ENOTFOUND', 'EAI_AGAIN'];\n    const retryableStatuses = [408, 429, 500, 502, 503, 504];\n\n    // Type guard for error objects\n    if (typeof error !== 'object' || error === null) {\n      return false;\n    }\n\n    const err = error as NetworkError & { response?: { status?: number } };\n\n    return (\n      (err.code !== undefined && retryableErrors.includes(err.code)) ||\n      (err.status !== undefined && retryableStatuses.includes(err.status)) ||\n      (err.response?.status !== undefined && retryableStatuses.includes(err.response.status))\n    );\n  }\n}\n","import { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { EnvConfig, HumanInputRequest } from '../types/config';\n\n/**\n * Configuration for a check provider\n */\nexport interface CheckProviderConfig {\n  type: string;\n  prompt?: string;\n  eventContext?: Record<string, unknown>;\n  focus?: string;\n  command?: string; // For PR comment triggers\n  exec?: string; // For command execution (supports Liquid templates)\n  stdin?: string; // Optional stdin input (supports Liquid templates)\n  args?: string[]; // Deprecated: use exec with inline args instead\n  interpreter?: string;\n  url?: string;\n  method?: string;\n  headers?: Record<string, string>;\n  timeout?: number;\n  metadata?: Record<string, unknown>;\n  workingDirectory?: string;\n  env?: EnvConfig;\n  ai?: import('../types/config').AIProviderConfig;\n  /** AI model to use for this check - overrides global setting */\n  ai_model?: string;\n  /** AI provider to use for this check - overrides global setting */\n  ai_provider?: 'google' | 'anthropic' | 'openai' | string;\n  /** Check name for sessionID and logging purposes */\n  checkName?: string;\n  /** Session ID for AI session management */\n  sessionId?: string;\n  [key: string]: unknown;\n}\n\n/**\n * Execution context passed to check providers\n */\nexport interface ExecutionContext {\n  /** Session information for AI session reuse */\n  parentSessionId?: string;\n  reuseSession?: boolean;\n  /** CLI message value (from --message argument) */\n  cliMessage?: string;\n  /** SDK hooks for human input */\n  hooks?: {\n    onHumanInput?: (request: HumanInputRequest) => Promise<string>;\n  };\n}\n\n/**\n * Abstract base class for all check providers\n * Implementing classes provide specific check functionality (AI, tool, script, etc.)\n */\nexport abstract class CheckProvider {\n  /**\n   * Get the unique name/type of this provider\n   */\n  abstract getName(): string;\n\n  /**\n   * Get a human-readable description of this provider\n   */\n  abstract getDescription(): string;\n\n  /**\n   * Validate provider-specific configuration\n   * @param config The configuration to validate\n   * @returns true if configuration is valid, false otherwise\n   */\n  abstract validateConfig(config: unknown): Promise<boolean>;\n\n  /**\n   * Execute the check on the given PR information\n   * @param prInfo Information about the pull request\n   * @param config Provider-specific configuration\n   * @param dependencyResults Optional results from dependency checks that this check depends on\n   * @param context Optional execution context with session info, hooks, and CLI state\n   * @returns Review summary with scores, issues, and comments\n   */\n  abstract execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    context?: ExecutionContext\n  ): Promise<ReviewSummary>;\n\n  /**\n   * Get the list of configuration keys this provider supports\n   * Used for documentation and validation\n   */\n  abstract getSupportedConfigKeys(): string[];\n\n  /**\n   * Check if this provider is available (e.g., has required API keys)\n   * @returns true if provider can be used, false otherwise\n   */\n  abstract isAvailable(): Promise<boolean>;\n\n  /**\n   * Get provider requirements (e.g., environment variables needed)\n   */\n  abstract getRequirements(): string[];\n\n  /**\n   * Set webhook context for providers that need access to webhook data\n   * This is optional and only used by http_input providers\n   * @param webhookContext Map of endpoint paths to webhook data\n   */\n  setWebhookContext?(webhookContext: Map<string, unknown>): void;\n}\n","/**\n * Environment variable resolution utilities\n * Supports GitHub Actions-like syntax for referencing environment variables\n */\n\nimport { EnvConfig } from '../types/config';\n\n/**\n * Resolves environment variables in configuration values\n * Supports the following syntaxes:\n * - ${{ env.VARIABLE_NAME }} (GitHub Actions style)\n * - ${VARIABLE_NAME} (shell style)\n * - $VARIABLE_NAME (simple shell style)\n * - Direct environment variable names\n */\nexport class EnvironmentResolver {\n  /**\n   * Resolves a single configuration value that may contain environment variable references\n   */\n  static resolveValue(value: string | number | boolean): string | number | boolean {\n    if (typeof value !== 'string') {\n      return value;\n    }\n\n    // GitHub Actions style: ${{ env.VARIABLE_NAME }}\n    let resolved = value.replace(/\\$\\{\\{\\s*env\\.([A-Z_][A-Z0-9_]*)\\s*\\}\\}/g, (match, envVar) => {\n      return process.env[envVar] || match;\n    });\n\n    // Shell style: ${VARIABLE_NAME}\n    resolved = resolved.replace(/\\$\\{([A-Z_][A-Z0-9_]*)\\}/g, (match, envVar) => {\n      return process.env[envVar] || match;\n    });\n\n    // Simple shell style: $VARIABLE_NAME\n    resolved = resolved.replace(/\\$([A-Z_][A-Z0-9_]*)/g, (match, envVar) => {\n      return process.env[envVar] || match;\n    });\n\n    return resolved;\n  }\n\n  /**\n   * Resolves all environment variables in an EnvConfig object\n   */\n  static resolveEnvConfig(envConfig: EnvConfig): EnvConfig {\n    const resolved: EnvConfig = {};\n\n    for (const [key, value] of Object.entries(envConfig)) {\n      resolved[key] = this.resolveValue(value);\n    }\n\n    return resolved;\n  }\n\n  /**\n   * Applies environment configuration to the process environment\n   * This allows checks to access their specific environment variables\n   */\n  static applyEnvConfig(envConfig: EnvConfig): void {\n    const resolved = this.resolveEnvConfig(envConfig);\n\n    for (const [key, value] of Object.entries(resolved)) {\n      if (value !== undefined) {\n        process.env[key] = String(value);\n      }\n    }\n  }\n\n  /**\n   * Creates a temporary environment for a specific check execution\n   * Returns a cleanup function to restore the original environment\n   */\n  static withTemporaryEnv<T>(envConfig: EnvConfig, callback: () => T | Promise<T>): T | Promise<T> {\n    const resolved = this.resolveEnvConfig(envConfig);\n    const originalValues: Record<string, string | undefined> = {};\n\n    // Store original values and apply new ones\n    for (const [key, value] of Object.entries(resolved)) {\n      originalValues[key] = process.env[key];\n      if (value !== undefined) {\n        process.env[key] = String(value);\n      }\n    }\n\n    try {\n      const result = callback();\n\n      // If callback returns a promise, handle cleanup after it resolves\n      if (result instanceof Promise) {\n        return result.finally(() => {\n          // Restore original values\n          for (const [key, originalValue] of Object.entries(originalValues)) {\n            if (originalValue === undefined) {\n              delete process.env[key];\n            } else {\n              process.env[key] = originalValue;\n            }\n          }\n        });\n      }\n\n      // Restore original values immediately for sync callbacks\n      for (const [key, originalValue] of Object.entries(originalValues)) {\n        if (originalValue === undefined) {\n          delete process.env[key];\n        } else {\n          process.env[key] = originalValue;\n        }\n      }\n\n      return result;\n    } catch (error) {\n      // Restore original values on error\n      for (const [key, originalValue] of Object.entries(originalValues)) {\n        if (originalValue === undefined) {\n          delete process.env[key];\n        } else {\n          process.env[key] = originalValue;\n        }\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Validates that all required environment variables are available\n   */\n  static validateRequiredEnvVars(envConfig: EnvConfig, requiredVars: string[]): string[] {\n    const resolved = this.resolveEnvConfig(envConfig);\n    const missing: string[] = [];\n\n    for (const varName of requiredVars) {\n      const value = resolved[varName] || process.env[varName];\n      if (!value) {\n        missing.push(varName);\n      }\n    }\n\n    return missing;\n  }\n\n  /**\n   * Resolves environment variables in HTTP headers\n   * Each header value is processed through resolveValue to replace env var references\n   */\n  static resolveHeaders(headers: Record<string, string>): Record<string, string> {\n    const resolved: Record<string, string> = {};\n    for (const [key, value] of Object.entries(headers)) {\n      resolved[key] = String(this.resolveValue(value));\n    }\n    return resolved;\n  }\n\n  /**\n   * Sanitizes headers for logging/telemetry by redacting sensitive values\n   * Headers like Authorization, API keys, and cookies are replaced with [REDACTED]\n   */\n  static sanitizeHeaders(headers: Record<string, string>): Record<string, string> {\n    const sensitiveHeaders = ['authorization', 'x-api-key', 'cookie', 'set-cookie'];\n    const sanitized: Record<string, string> = {};\n\n    for (const [key, value] of Object.entries(headers)) {\n      if (sensitiveHeaders.includes(key.toLowerCase())) {\n        sanitized[key] = '[REDACTED]';\n      } else {\n        sanitized[key] = value;\n      }\n    }\n\n    return sanitized;\n  }\n}\n","import * as fs from 'fs';\nimport * as path from 'path';\nimport { ReviewIssue } from './reviewer';\n\n/**\n * Filter for suppressing Visor issues based on special comments in code\n */\nexport class IssueFilter {\n  private fileCache: Map<string, string[]> = new Map();\n  private suppressionEnabled: boolean;\n\n  constructor(suppressionEnabled: boolean = true) {\n    this.suppressionEnabled = suppressionEnabled;\n  }\n\n  /**\n   * Filter out issues that have suppression comments\n   * @param issues Array of issues to filter\n   * @param workingDir Working directory for resolving file paths\n   * @returns Filtered array of issues with suppressed ones removed\n   */\n  public filterIssues(issues: ReviewIssue[], workingDir: string = process.cwd()): ReviewIssue[] {\n    if (!this.suppressionEnabled || !issues || issues.length === 0) {\n      return issues;\n    }\n\n    const filteredIssues: ReviewIssue[] = [];\n    const suppressedCount: { [file: string]: number } = {};\n\n    for (const issue of issues) {\n      if (this.shouldSuppressIssue(issue, workingDir)) {\n        // Track suppressed issues for logging\n        suppressedCount[issue.file] = (suppressedCount[issue.file] || 0) + 1;\n      } else {\n        filteredIssues.push(issue);\n      }\n    }\n\n    // Log suppression summary if any issues were suppressed\n    const totalSuppressed = Object.values(suppressedCount).reduce((sum, count) => sum + count, 0);\n    if (totalSuppressed > 0) {\n      console.log(`🔇 Suppressed ${totalSuppressed} issue(s) via visor-disable comments:`);\n      for (const [file, count] of Object.entries(suppressedCount)) {\n        console.log(`   - ${file}: ${count} issue(s)`);\n      }\n    }\n\n    return filteredIssues;\n  }\n\n  /**\n   * Check if an issue should be suppressed based on comments in the file\n   */\n  private shouldSuppressIssue(issue: ReviewIssue, workingDir: string): boolean {\n    // Skip system-level issues or issues without file/line info\n    if (!issue.file || issue.file === 'system' || issue.file === 'webhook' || issue.line === 0) {\n      return false;\n    }\n\n    const lines = this.getFileLines(issue.file, workingDir);\n    if (!lines || lines.length === 0) {\n      return false;\n    }\n\n    // Check for file-level suppression (visor-disable-file in first 5 lines)\n    const firstFiveLines = lines.slice(0, 5).join('\\n').toLowerCase();\n    if (firstFiveLines.includes('visor-disable-file')) {\n      return true;\n    }\n\n    // Check for line-level suppression (visor-disable within ±2 lines)\n    const lineIndex = issue.line - 1; // Convert to 0-based index\n    const startLine = Math.max(0, lineIndex - 2);\n    const endLine = Math.min(lines.length - 1, lineIndex + 2);\n\n    for (let i = startLine; i <= endLine; i++) {\n      if (lines[i].toLowerCase().includes('visor-disable')) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Get file lines from cache or read from disk\n   */\n  private getFileLines(filePath: string, workingDir: string): string[] | null {\n    // Check cache first\n    if (this.fileCache.has(filePath)) {\n      return this.fileCache.get(filePath)!;\n    }\n\n    try {\n      // Resolve the file path\n      const resolvedPath = path.isAbsolute(filePath) ? filePath : path.join(workingDir, filePath);\n\n      if (!fs.existsSync(resolvedPath)) {\n        // Try without working directory if the file doesn't exist\n        if (fs.existsSync(filePath)) {\n          const content = fs.readFileSync(filePath, 'utf8');\n          const lines = content.split('\\n');\n          this.fileCache.set(filePath, lines);\n          return lines;\n        }\n        return null;\n      }\n\n      const content = fs.readFileSync(resolvedPath, 'utf8');\n      const lines = content.split('\\n');\n      this.fileCache.set(filePath, lines);\n      return lines;\n    } catch {\n      // Silently skip files that can't be read\n      return null;\n    }\n  }\n\n  /**\n   * Clear the file cache (useful for testing or long-running processes)\n   */\n  public clearCache(): void {\n    this.fileCache.clear();\n  }\n}\n","/**\n * Author permission utilities for checking GitHub author associations\n *\n * GitHub provides author_association field with these values (in order of privilege):\n * - OWNER: Repository owner\n * - MEMBER: Organization member\n * - COLLABORATOR: Invited collaborator\n * - CONTRIBUTOR: Has contributed before\n * - FIRST_TIME_CONTRIBUTOR: First PR to this repo\n * - FIRST_TIMER: First GitHub contribution ever\n * - NONE: No association\n */\n\nexport type AuthorAssociation =\n  | 'OWNER'\n  | 'MEMBER'\n  | 'COLLABORATOR'\n  | 'CONTRIBUTOR'\n  | 'FIRST_TIME_CONTRIBUTOR'\n  | 'FIRST_TIMER'\n  | 'NONE';\n\n/**\n * Permission hierarchy (from highest to lowest privilege)\n */\nconst PERMISSION_HIERARCHY: AuthorAssociation[] = [\n  'OWNER',\n  'MEMBER',\n  'COLLABORATOR',\n  'CONTRIBUTOR',\n  'FIRST_TIME_CONTRIBUTOR',\n  'FIRST_TIMER',\n  'NONE',\n];\n\n/**\n * Get permission level (0 = highest, higher number = lower privilege)\n */\nfunction getPermissionLevel(association: string | undefined): number {\n  if (!association) return PERMISSION_HIERARCHY.length; // Treat unknown as lowest\n  const index = PERMISSION_HIERARCHY.indexOf(association.toUpperCase() as AuthorAssociation);\n  return index === -1 ? PERMISSION_HIERARCHY.length : index;\n}\n\n/**\n * Check if author has at least the specified permission level (>= logic)\n *\n * @param authorAssociation - The author's association from GitHub API\n * @param minPermission - Minimum required permission level\n * @param isLocalMode - Whether running in local/CLI mode (defaults to true for local runs)\n * @returns true if author has at least the specified permission level\n *\n * @example\n * hasMinPermission('MEMBER', 'MEMBER') // true (exact match)\n * hasMinPermission('OWNER', 'MEMBER') // true (owner >= member)\n * hasMinPermission('COLLABORATOR', 'MEMBER') // false (collaborator < member)\n * hasMinPermission(undefined, 'OWNER', true) // true (local mode)\n */\nexport function hasMinPermission(\n  authorAssociation: string | undefined,\n  minPermission: AuthorAssociation,\n  isLocalMode: boolean = false\n): boolean {\n  // In local mode (not GitHub Actions), treat as owner\n  if (isLocalMode) {\n    return true;\n  }\n\n  const authorLevel = getPermissionLevel(authorAssociation);\n  const minLevel = getPermissionLevel(minPermission);\n\n  // Lower number = higher privilege, so author must have equal or lower number\n  return authorLevel <= minLevel;\n}\n\n/**\n * Check if author is exactly the repository owner\n */\nexport function isOwner(\n  authorAssociation: string | undefined,\n  isLocalMode: boolean = false\n): boolean {\n  if (isLocalMode) return true;\n  return authorAssociation?.toUpperCase() === 'OWNER';\n}\n\n/**\n * Check if author is an organization member or owner\n */\nexport function isMember(\n  authorAssociation: string | undefined,\n  isLocalMode: boolean = false\n): boolean {\n  if (isLocalMode) return true;\n  return hasMinPermission(authorAssociation, 'MEMBER', isLocalMode);\n}\n\n/**\n * Check if author is a collaborator (or higher)\n */\nexport function isCollaborator(\n  authorAssociation: string | undefined,\n  isLocalMode: boolean = false\n): boolean {\n  if (isLocalMode) return true;\n  return hasMinPermission(authorAssociation, 'COLLABORATOR', isLocalMode);\n}\n\n/**\n * Check if author is a contributor (has contributed before)\n */\nexport function isContributor(\n  authorAssociation: string | undefined,\n  isLocalMode: boolean = false\n): boolean {\n  if (isLocalMode) return true;\n  return hasMinPermission(authorAssociation, 'CONTRIBUTOR', isLocalMode);\n}\n\n/**\n * Check if author is a first-time contributor (to this repo or GitHub)\n */\nexport function isFirstTimer(\n  authorAssociation: string | undefined,\n  isLocalMode: boolean = false\n): boolean {\n  if (isLocalMode) return false; // In local mode, not a first-timer\n  const assoc = authorAssociation?.toUpperCase();\n  return assoc === 'FIRST_TIME_CONTRIBUTOR' || assoc === 'FIRST_TIMER';\n}\n\n/**\n * Create permission helper functions bound to a specific author association\n * This is used to inject functions into JavaScript execution contexts\n *\n * @param authorAssociation - The author's association from PR data\n * @param isLocalMode - Whether running in local/CLI mode\n */\nexport function createPermissionHelpers(\n  authorAssociation: string | undefined,\n  isLocalMode: boolean = false\n) {\n  return {\n    hasMinPermission: (minPermission: AuthorAssociation) =>\n      hasMinPermission(authorAssociation, minPermission, isLocalMode),\n    isOwner: () => isOwner(authorAssociation, isLocalMode),\n    isMember: () => isMember(authorAssociation, isLocalMode),\n    isCollaborator: () => isCollaborator(authorAssociation, isLocalMode),\n    isContributor: () => isContributor(authorAssociation, isLocalMode),\n    isFirstTimer: () => isFirstTimer(authorAssociation, isLocalMode),\n  };\n}\n\n/**\n * Determine if we're running in local mode (not GitHub Actions)\n */\nexport function detectLocalMode(): boolean {\n  return !process.env.GITHUB_ACTIONS;\n}\n\n/**\n * Resolve the most relevant GitHub author association from an event context.\n * Prefers commenter association for issue_comment events, then issue/PR author,\n * and finally falls back to the provided default association.\n */\nexport function resolveAssociationFromEvent(\n  eventContext: any | undefined,\n  fallback?: string\n): string | undefined {\n  try {\n    const ec = eventContext || {};\n    return (\n      ec?.comment?.author_association ||\n      ec?.issue?.author_association ||\n      ec?.pull_request?.author_association ||\n      fallback\n    );\n  } catch {\n    return fallback;\n  }\n}\n","import fs from 'fs/promises';\nimport path from 'path';\nimport { MemoryConfig } from './types/config';\nimport { logger } from './logger';\n\n/**\n * Memory store for persistent key-value storage across checks\n * Supports namespaces for isolation and both in-memory and file-based persistence\n */\nexport class MemoryStore {\n  private static instance: MemoryStore;\n  private data: Map<string, Map<string, unknown>>; // namespace -> key -> value\n  private config: MemoryConfig;\n  private initialized = false;\n\n  private constructor(config?: MemoryConfig) {\n    this.data = new Map();\n    this.config = this.normalizeConfig(config);\n  }\n\n  /**\n   * Get singleton instance\n   */\n  static getInstance(config?: MemoryConfig): MemoryStore {\n    if (!MemoryStore.instance) {\n      MemoryStore.instance = new MemoryStore(config);\n    } else if (config && !MemoryStore.instance.initialized) {\n      // Update config if not yet initialized\n      MemoryStore.instance.config = MemoryStore.instance.normalizeConfig(config);\n    }\n    return MemoryStore.instance;\n  }\n\n  /**\n   * Reset singleton instance (for testing)\n   */\n  static resetInstance(): void {\n    MemoryStore.instance = undefined!;\n  }\n\n  /**\n   * Initialize memory store (load from file if configured)\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      return;\n    }\n\n    // Auto-load if file storage is configured\n    if (this.config.storage === 'file' && this.config.auto_load && this.config.file) {\n      try {\n        await this.load();\n        logger.debug(`Memory store loaded from ${this.config.file}`);\n      } catch (error) {\n        // If file doesn't exist, that's ok - we'll create it on first save\n        if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {\n          logger.warn(\n            `Failed to load memory store from ${this.config.file}: ${\n              error instanceof Error ? error.message : 'Unknown error'\n            }`\n          );\n        }\n      }\n    }\n\n    this.initialized = true;\n  }\n\n  /**\n   * Normalize and apply defaults to config\n   */\n  private normalizeConfig(config?: MemoryConfig): MemoryConfig {\n    const storage = config?.storage || 'memory';\n    return {\n      storage,\n      format: config?.format || 'json',\n      file: config?.file,\n      namespace: config?.namespace || 'default',\n      auto_load: config?.auto_load !== false,\n      auto_save: config?.auto_save !== false,\n    };\n  }\n\n  /**\n   * Get the default namespace\n   */\n  getDefaultNamespace(): string {\n    return this.config.namespace || 'default';\n  }\n\n  /**\n   * Get a value from memory\n   */\n  get(key: string, namespace?: string): unknown {\n    const ns = namespace || this.getDefaultNamespace();\n    const nsData = this.data.get(ns);\n    return nsData?.get(key);\n  }\n\n  /**\n   * Check if a key exists in memory\n   */\n  has(key: string, namespace?: string): boolean {\n    const ns = namespace || this.getDefaultNamespace();\n    const nsData = this.data.get(ns);\n    return nsData?.has(key) || false;\n  }\n\n  /**\n   * Set a value in memory (override existing)\n   */\n  async set(key: string, value: unknown, namespace?: string): Promise<void> {\n    const ns = namespace || this.getDefaultNamespace();\n\n    // Ensure namespace exists\n    if (!this.data.has(ns)) {\n      this.data.set(ns, new Map());\n    }\n\n    const nsData = this.data.get(ns)!;\n    nsData.set(key, value);\n\n    try {\n      if (process.env.VISOR_DEBUG === 'true' || process.env.JEST_WORKER_ID !== undefined) {\n        if (ns === 'fact-validation' && (key === 'total_validations' || key === 'all_valid')) {\n          console.log('[MemoryStore] SET ' + ns + '.' + key + ' = ' + JSON.stringify(value));\n        }\n      }\n    } catch {}\n\n    try {\n      if (process.env.VISOR_DEBUG === 'true' || process.env.JEST_WORKER_ID !== undefined) {\n        if (ns === 'fact-validation' && (key === 'total_validations' || key === 'all_valid')) {\n          console.log();\n        }\n      }\n    } catch {}\n\n    // Auto-save if configured\n    if (this.config.storage === 'file' && this.config.auto_save) {\n      await this.save();\n    }\n  }\n\n  /**\n   * Append a value to an array in memory\n   * If key doesn't exist, creates a new array\n   * If key exists but is not an array, converts it to an array\n   */\n  async append(key: string, value: unknown, namespace?: string): Promise<void> {\n    const ns = namespace || this.getDefaultNamespace();\n    const existing = this.get(key, ns);\n\n    let newValue: unknown[];\n    if (existing === undefined) {\n      // Create new array\n      newValue = [value];\n    } else if (Array.isArray(existing)) {\n      // Append to existing array\n      newValue = [...existing, value];\n    } else {\n      // Convert single value to array with both values\n      newValue = [existing, value];\n    }\n\n    await this.set(key, newValue, ns);\n  }\n\n  /**\n   * Increment a numeric value in memory\n   * If key doesn't exist, initializes to 0 before incrementing\n   * If key exists but is not a number, throws an error\n   */\n  async increment(key: string, amount = 1, namespace?: string): Promise<number> {\n    const ns = namespace || this.getDefaultNamespace();\n    const existing = this.get(key, ns);\n\n    let newValue: number;\n    if (existing === undefined || existing === null) {\n      // Initialize to 0 and then increment\n      newValue = amount;\n    } else if (typeof existing === 'number') {\n      // Increment existing number\n      newValue = existing + amount;\n    } else {\n      throw new Error(\n        `Cannot increment non-numeric value at key '${key}' (type: ${typeof existing})`\n      );\n    }\n\n    await this.set(key, newValue, ns);\n    return newValue;\n  }\n\n  /**\n   * Delete a key from memory\n   */\n  async delete(key: string, namespace?: string): Promise<boolean> {\n    const ns = namespace || this.getDefaultNamespace();\n    const nsData = this.data.get(ns);\n\n    if (!nsData) {\n      return false;\n    }\n\n    const deleted = nsData.delete(key);\n\n    // Auto-save if configured\n    if (deleted && this.config.storage === 'file' && this.config.auto_save) {\n      await this.save();\n    }\n\n    return deleted;\n  }\n\n  /**\n   * Clear all keys in a namespace (or all namespaces if none specified)\n   */\n  async clear(namespace?: string): Promise<void> {\n    if (namespace) {\n      // Clear specific namespace\n      this.data.delete(namespace);\n    } else {\n      // Clear all namespaces\n      this.data.clear();\n    }\n\n    // Auto-save if configured\n    if (this.config.storage === 'file' && this.config.auto_save) {\n      await this.save();\n    }\n  }\n\n  /**\n   * List all keys in a namespace\n   */\n  list(namespace?: string): string[] {\n    const ns = namespace || this.getDefaultNamespace();\n    const nsData = this.data.get(ns);\n    return nsData ? Array.from(nsData.keys()) : [];\n  }\n\n  /**\n   * List all namespaces\n   */\n  listNamespaces(): string[] {\n    return Array.from(this.data.keys());\n  }\n\n  /**\n   * Get all data in a namespace\n   */\n  getAll(namespace?: string): Record<string, unknown> {\n    const ns = namespace || this.getDefaultNamespace();\n    const nsData = this.data.get(ns);\n    if (!nsData) {\n      return {};\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const [key, value] of nsData.entries()) {\n      result[key] = value;\n    }\n    return result;\n  }\n\n  /**\n   * Load data from file\n   */\n  async load(): Promise<void> {\n    if (!this.config.file) {\n      throw new Error('No file path configured for memory store');\n    }\n\n    const filePath = path.resolve(process.cwd(), this.config.file);\n    const content = await fs.readFile(filePath, 'utf-8');\n\n    if (this.config.format === 'json') {\n      await this.loadFromJson(content);\n    } else if (this.config.format === 'csv') {\n      await this.loadFromCsv(content);\n    } else {\n      throw new Error(`Unsupported format: ${this.config.format}`);\n    }\n  }\n\n  /**\n   * Save data to file\n   */\n  async save(): Promise<void> {\n    if (!this.config.file) {\n      throw new Error('No file path configured for memory store');\n    }\n\n    const filePath = path.resolve(process.cwd(), this.config.file);\n\n    // Ensure directory exists\n    const dir = path.dirname(filePath);\n    await fs.mkdir(dir, { recursive: true });\n\n    let content: string;\n    if (this.config.format === 'json') {\n      content = this.saveToJson();\n    } else if (this.config.format === 'csv') {\n      content = this.saveToCsv();\n    } else {\n      throw new Error(`Unsupported format: ${this.config.format}`);\n    }\n\n    await fs.writeFile(filePath, content, 'utf-8');\n  }\n\n  /**\n   * Load data from JSON format\n   */\n  private async loadFromJson(content: string): Promise<void> {\n    const data = JSON.parse(content);\n\n    // Clear existing data\n    this.data.clear();\n\n    // Load namespaces\n    for (const [namespace, nsData] of Object.entries(data)) {\n      if (typeof nsData === 'object' && nsData !== null && !Array.isArray(nsData)) {\n        const nsMap = new Map<string, unknown>();\n        for (const [key, value] of Object.entries(nsData)) {\n          nsMap.set(key, value);\n        }\n        this.data.set(namespace, nsMap);\n      }\n    }\n  }\n\n  /**\n   * Save data to JSON format\n   */\n  private saveToJson(): string {\n    const result: Record<string, Record<string, unknown>> = {};\n\n    for (const [namespace, nsData] of this.data.entries()) {\n      const nsObj: Record<string, unknown> = {};\n      for (const [key, value] of nsData.entries()) {\n        nsObj[key] = value;\n      }\n      result[namespace] = nsObj;\n    }\n\n    return JSON.stringify(result, null, 2);\n  }\n\n  /**\n   * Load data from CSV format\n   * CSV format: namespace,key,value,type\n   */\n  private async loadFromCsv(content: string): Promise<void> {\n    const lines = content.split('\\n').filter(line => line.trim());\n\n    // Skip header if present\n    let startIndex = 0;\n    if (lines[0]?.startsWith('namespace,')) {\n      startIndex = 1;\n    }\n\n    // Clear existing data\n    this.data.clear();\n\n    // Track arrays (keys that have multiple values)\n    const arrays = new Map<string, Map<string, unknown[]>>(); // namespace -> key -> values[]\n\n    for (let i = startIndex; i < lines.length; i++) {\n      const line = lines[i];\n      const parts = this.parseCsvLine(line);\n\n      if (parts.length < 3) {\n        logger.warn(`Invalid CSV line ${i + 1}: ${line}`);\n        continue;\n      }\n\n      const [namespace, key, valueStr, typeStr] = parts;\n      const value = this.parseCsvValue(valueStr, typeStr);\n\n      // Ensure namespace exists in data\n      if (!this.data.has(namespace)) {\n        this.data.set(namespace, new Map());\n        arrays.set(namespace, new Map());\n      }\n\n      const nsData = this.data.get(namespace)!;\n      const nsArrays = arrays.get(namespace)!;\n\n      // Check if this is a duplicate key (array)\n      if (nsData.has(key)) {\n        // Convert to array if not already\n        if (!nsArrays.has(key)) {\n          const existingValue = nsData.get(key);\n          nsArrays.set(key, [existingValue]);\n        }\n        nsArrays.get(key)!.push(value);\n        nsData.set(key, nsArrays.get(key)!);\n      } else {\n        // First occurrence\n        nsData.set(key, value);\n      }\n    }\n  }\n\n  /**\n   * Save data to CSV format\n   */\n  private saveToCsv(): string {\n    const lines: string[] = ['namespace,key,value,type'];\n\n    for (const [namespace, nsData] of this.data.entries()) {\n      for (const [key, value] of nsData.entries()) {\n        if (Array.isArray(value)) {\n          // Multiple rows for arrays\n          for (const item of value) {\n            lines.push(this.formatCsvLine(namespace, key, item));\n          }\n        } else {\n          // Single row\n          lines.push(this.formatCsvLine(namespace, key, value));\n        }\n      }\n    }\n\n    return lines.join('\\n') + '\\n';\n  }\n\n  /**\n   * Parse a CSV line, handling quoted values with commas\n   */\n  private parseCsvLine(line: string): string[] {\n    const parts: string[] = [];\n    let current = '';\n    let inQuotes = false;\n\n    for (let i = 0; i < line.length; i++) {\n      const char = line[i];\n\n      if (char === '\"') {\n        if (inQuotes && line[i + 1] === '\"') {\n          // Escaped quote\n          current += '\"';\n          i++;\n        } else {\n          // Toggle quotes\n          inQuotes = !inQuotes;\n        }\n      } else if (char === ',' && !inQuotes) {\n        // End of field\n        parts.push(current);\n        current = '';\n      } else {\n        current += char;\n      }\n    }\n\n    // Add last field\n    parts.push(current);\n\n    return parts;\n  }\n\n  /**\n   * Format a CSV line with proper escaping\n   */\n  private formatCsvLine(namespace: string, key: string, value: unknown): string {\n    const type = this.getValueType(value);\n    const valueStr = this.formatCsvValue(value);\n\n    return `${this.escapeCsv(namespace)},${this.escapeCsv(key)},${valueStr},${type}`;\n  }\n\n  /**\n   * Escape a CSV value\n   */\n  private escapeCsv(value: string): string {\n    if (value.includes(',') || value.includes('\"') || value.includes('\\n')) {\n      return `\"${value.replace(/\"/g, '\"\"')}\"`;\n    }\n    return value;\n  }\n\n  /**\n   * Format a value for CSV storage\n   */\n  private formatCsvValue(value: unknown): string {\n    if (value === null) {\n      return '\"\"';\n    }\n    if (value === undefined) {\n      return '\"\"';\n    }\n    if (typeof value === 'string') {\n      return this.escapeCsv(value);\n    }\n    if (typeof value === 'number' || typeof value === 'boolean') {\n      return this.escapeCsv(String(value));\n    }\n    // Objects and arrays are serialized as JSON\n    return this.escapeCsv(JSON.stringify(value));\n  }\n\n  /**\n   * Parse a CSV value based on its type\n   */\n  private parseCsvValue(valueStr: string, typeStr?: string): unknown {\n    if (!typeStr || typeStr === 'string') {\n      return valueStr;\n    }\n    if (typeStr === 'number') {\n      return Number(valueStr);\n    }\n    if (typeStr === 'boolean') {\n      return valueStr === 'true';\n    }\n    if (typeStr === 'object' || typeStr === 'array') {\n      try {\n        return JSON.parse(valueStr);\n      } catch {\n        return valueStr;\n      }\n    }\n    return valueStr;\n  }\n\n  /**\n   * Get the type of a value for CSV storage\n   */\n  private getValueType(value: unknown): string {\n    if (value === null || value === undefined) {\n      return 'string';\n    }\n    if (typeof value === 'number') {\n      return 'number';\n    }\n    if (typeof value === 'boolean') {\n      return 'boolean';\n    }\n    if (Array.isArray(value)) {\n      return 'array';\n    }\n    if (typeof value === 'object') {\n      return 'object';\n    }\n    return 'string';\n  }\n\n  /**\n   * Get the current configuration\n   */\n  getConfig(): MemoryConfig {\n    return { ...this.config };\n  }\n}\n","import { Liquid, TagToken, Context, TopLevelToken, Tag, Value, Emitter } from 'liquidjs';\nimport { AsyncLocalStorage } from 'async_hooks';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport {\n  hasMinPermission,\n  isOwner,\n  isMember,\n  isCollaborator,\n  isContributor,\n  isFirstTimer,\n  detectLocalMode,\n} from './utils/author-permissions';\nimport { MemoryStore } from './memory-store';\n\n/**\n * Sanitize label strings to only allow [A-Za-z0-9:/\\- ] characters (including spaces and hyphens)\n * @param value - Label value to sanitize\n * @returns Sanitized label string\n */\nexport function sanitizeLabel(value: unknown): string {\n  if (value == null) return '';\n  const s = String(value);\n  // Keep only alphanumerics, colon, slash, hyphen, and space; collapse repeated slashes and trim\n  return s\n    .replace(/[^A-Za-z0-9:\\/\\- ]/g, '')\n    .replace(/\\/{2,}/g, '/')\n    .trim();\n}\n\n/**\n * Sanitize an array of labels\n * @param labels - Array of label values\n * @returns Array of sanitized, non-empty label strings\n */\nexport function sanitizeLabelList(labels: unknown): string[] {\n  if (!Array.isArray(labels)) return [];\n  return (labels as unknown[]).map(v => sanitizeLabel(v)).filter(s => s.length > 0);\n}\n\n/**\n * Custom ReadFile tag for Liquid templates\n * Usage: {% readfile \"path/to/file.txt\" %}\n * or with variable: {% readfile filename %}\n */\nexport class ReadFileTag extends Tag {\n  private filepath: Value;\n\n  constructor(token: TagToken, remainTokens: TopLevelToken[], liquid: Liquid) {\n    super(token, remainTokens, liquid);\n    this.filepath = new Value(token.args, liquid);\n  }\n\n  *render(ctx: Context, emitter: Emitter): Generator<unknown, void, unknown> {\n    const filePath = yield this.filepath.value(ctx, false);\n\n    // Validate the path\n    if (!filePath || typeof filePath !== 'string') {\n      emitter.write('[Error: Invalid file path]');\n      return;\n    }\n\n    // Security: Resolve path relative to project root to prevent directory traversal\n    const projectRoot = process.cwd();\n    const resolvedPath = path.resolve(projectRoot, filePath.toString());\n\n    // Ensure the resolved path is within the project directory\n    if (!resolvedPath.startsWith(projectRoot)) {\n      emitter.write('[Error: File path escapes project directory]');\n      return;\n    }\n\n    // Read the file content\n    try {\n      const content = yield fs.readFile(resolvedPath, 'utf-8');\n      emitter.write(content);\n    } catch (error) {\n      // Handle file read errors gracefully\n      const errorMessage =\n        error instanceof Error\n          ? error.message\n          : (error as NodeJS.ErrnoException)?.code || 'Unknown error';\n      emitter.write(`[Error reading file: ${errorMessage}]`);\n    }\n  }\n}\n\n// Async-local permissions context for filters (per-render)\nconst permissionsALS = new AsyncLocalStorage<{ authorAssociation?: string }>();\n\nexport async function withPermissionsContext<T>(\n  ctx: { authorAssociation?: string },\n  fn: () => Promise<T>\n): Promise<T> {\n  return await permissionsALS.run(ctx, fn as any);\n}\n\n/**\n * Configure a Liquid instance with custom extensions\n */\nexport function configureLiquidWithExtensions(liquid: Liquid): void {\n  // Register the readfile tag\n  liquid.registerTag('readfile', ReadFileTag);\n\n  // Register parse_json filter to parse JSON strings into objects\n  liquid.registerFilter('parse_json', (value: string) => {\n    if (typeof value !== 'string') {\n      return value;\n    }\n    try {\n      return JSON.parse(value);\n    } catch {\n      // Return original value if parsing fails\n      return value;\n    }\n  });\n\n  // Register to_json filter as alias for json (for consistency)\n  liquid.registerFilter('to_json', (value: unknown) => {\n    try {\n      return JSON.stringify(value);\n    } catch {\n      return '[Error: Unable to serialize to JSON]';\n    }\n  });\n\n  // Sanitize a label to allowed characters only: [A-Za-z0-9:/]\n  liquid.registerFilter('safe_label', (value: unknown) => sanitizeLabel(value));\n\n  // Sanitize an array of labels\n  liquid.registerFilter('safe_label_list', (value: unknown) => sanitizeLabelList(value));\n\n  // Convert literal escape sequences (e.g., \"\\n\") into actual newlines\n  liquid.registerFilter('unescape_newlines', (value: unknown) => {\n    if (value == null) return '';\n    const s = String(value);\n    return s.replace(/\\\\n/g, '\\n').replace(/\\\\r/g, '\\r').replace(/\\\\t/g, '\\t');\n  });\n\n  // Register author permission filters (from main)\n  // These filters check the author's permission level; detect local mode for tests\n  const isLocal = detectLocalMode();\n\n  const resolveAssoc = (val: unknown): string | undefined => {\n    if (typeof val === 'string' && val.length > 0) return val;\n    const store = permissionsALS.getStore();\n    return store?.authorAssociation;\n  };\n\n  liquid.registerFilter('has_min_permission', (authorAssociation: unknown, level: string) => {\n    return hasMinPermission(resolveAssoc(authorAssociation), level as any, isLocal);\n  });\n\n  liquid.registerFilter('is_owner', (authorAssociation: unknown) => {\n    return isOwner(resolveAssoc(authorAssociation), isLocal);\n  });\n\n  liquid.registerFilter('is_member', (authorAssociation: unknown) => {\n    return isMember(resolveAssoc(authorAssociation), isLocal);\n  });\n\n  liquid.registerFilter('is_collaborator', (authorAssociation: unknown) => {\n    return isCollaborator(resolveAssoc(authorAssociation), isLocal);\n  });\n\n  liquid.registerFilter('is_contributor', (authorAssociation: unknown) => {\n    return isContributor(resolveAssoc(authorAssociation), isLocal);\n  });\n\n  liquid.registerFilter('is_first_timer', (authorAssociation: unknown) => {\n    return isFirstTimer(resolveAssoc(authorAssociation), isLocal);\n  });\n\n  // Register memory filters for accessing memory store\n  const memoryStore = MemoryStore.getInstance();\n\n  liquid.registerFilter('memory_get', (key: string, namespace?: string) => {\n    if (typeof key !== 'string') {\n      return undefined;\n    }\n    return memoryStore.get(key, namespace);\n  });\n\n  liquid.registerFilter('memory_has', (key: string, namespace?: string) => {\n    if (typeof key !== 'string') {\n      return false;\n    }\n    return memoryStore.has(key, namespace);\n  });\n\n  liquid.registerFilter('memory_list', (namespace?: string) => {\n    return memoryStore.list(namespace);\n  });\n}\n\n/**\n * Create a new Liquid instance with custom extensions\n */\nexport function createExtendedLiquid(options: Record<string, unknown> = {}): Liquid {\n  const liquid = new Liquid({\n    cache: false,\n    strictFilters: false,\n    strictVariables: false,\n    ...options,\n  });\n\n  configureLiquidWithExtensions(liquid);\n  return liquid;\n}\n","/**\n * Lazy-loading wrapper for OpenTelemetry API.\n * Returns no-op implementations if OpenTelemetry is not installed.\n * Uses hardcoded module name for security - no dynamic module loading.\n */\n\nlet otelApi: any = null;\nlet otelApiAttempted = false;\n\n// Hardcoded allowed module name to prevent module loading attacks\nconst OTEL_API_MODULE = '@opentelemetry/api';\n\nfunction getOtelApi() {\n  if (otelApiAttempted) return otelApi;\n  otelApiAttempted = true;\n\n  try {\n    // Security: Only load the specific @opentelemetry/api module\n    // Use dynamic require to prevent bundlers from including this module\n\n    otelApi = (function (name: string) {\n      return require(name);\n    })(OTEL_API_MODULE);\n  } catch {\n    // OpenTelemetry not installed - provide no-op implementations\n    otelApi = null;\n  }\n\n  return otelApi;\n}\n\n// Export lazy-loaded trace API\nexport const trace = {\n  getTracer(name: string, version?: string) {\n    const api = getOtelApi();\n    if (!api) return createNoOpTracer();\n    return api.trace.getTracer(name, version);\n  },\n  getSpan(context: any) {\n    const api = getOtelApi();\n    if (!api) return undefined;\n    return api.trace.getSpan(context);\n  },\n  getActiveSpan() {\n    const api = getOtelApi();\n    if (!api) return undefined;\n    return api.trace.getActiveSpan();\n  },\n};\n\n// Export lazy-loaded context API\nexport const context = {\n  active() {\n    const api = getOtelApi();\n    if (!api) return {};\n    return api.context.active();\n  },\n  with(context: any, fn: Function, thisArg?: any, ...args: any[]) {\n    const api = getOtelApi();\n    if (!api) return fn.call(thisArg, ...args);\n    return api.context.with(context, fn, thisArg, ...args);\n  },\n};\n\n// Export lazy-loaded metrics API\nexport const metrics = {\n  getMeter(name: string, version?: string) {\n    const api = getOtelApi();\n    if (!api?.metrics) return createNoOpMeter();\n    return api.metrics.getMeter(name, version);\n  },\n};\n\n// Export types and enums\nexport const SpanStatusCode = {\n  get UNSET() {\n    const api = getOtelApi();\n    return api?.SpanStatusCode?.UNSET ?? 0;\n  },\n  get OK() {\n    const api = getOtelApi();\n    return api?.SpanStatusCode?.OK ?? 1;\n  },\n  get ERROR() {\n    const api = getOtelApi();\n    return api?.SpanStatusCode?.ERROR ?? 2;\n  },\n};\n\nexport const SpanKind = {\n  get INTERNAL() {\n    const api = getOtelApi();\n    return api?.SpanKind?.INTERNAL ?? 0;\n  },\n  get SERVER() {\n    const api = getOtelApi();\n    return api?.SpanKind?.SERVER ?? 1;\n  },\n  get CLIENT() {\n    const api = getOtelApi();\n    return api?.SpanKind?.CLIENT ?? 2;\n  },\n  get PRODUCER() {\n    const api = getOtelApi();\n    return api?.SpanKind?.PRODUCER ?? 3;\n  },\n  get CONSUMER() {\n    const api = getOtelApi();\n    return api?.SpanKind?.CONSUMER ?? 4;\n  },\n};\n\n// Export diag API\nexport const diag = {\n  setLogger(logger: any, level?: any) {\n    const api = getOtelApi();\n    if (!api) return;\n    return api.diag.setLogger(logger, level);\n  },\n};\n\n// Lazy-loaded DiagConsoleLogger and DiagLogLevel for consistency\nexport const DiagConsoleLogger = {\n  get() {\n    const api = getOtelApi();\n    return api?.DiagConsoleLogger;\n  },\n};\n\nexport const DiagLogLevel = {\n  get NONE() {\n    const api = getOtelApi();\n    return api?.DiagLogLevel?.NONE ?? 0;\n  },\n  get ERROR() {\n    const api = getOtelApi();\n    return api?.DiagLogLevel?.ERROR ?? 30;\n  },\n  get WARN() {\n    const api = getOtelApi();\n    return api?.DiagLogLevel?.WARN ?? 50;\n  },\n  get INFO() {\n    const api = getOtelApi();\n    return api?.DiagLogLevel?.INFO ?? 60;\n  },\n  get DEBUG() {\n    const api = getOtelApi();\n    return api?.DiagLogLevel?.DEBUG ?? 70;\n  },\n  get VERBOSE() {\n    const api = getOtelApi();\n    return api?.DiagLogLevel?.VERBOSE ?? 80;\n  },\n  get ALL() {\n    const api = getOtelApi();\n    return api?.DiagLogLevel?.ALL ?? 9999;\n  },\n};\n\n// Type exports for TypeScript\nexport type Span = any;\nexport type Attributes = Record<string, any>;\nexport type HrTime = [number, number];\n\n// No-op implementations\nfunction createNoOpTracer() {\n  return {\n    startSpan: () => createNoOpSpan(),\n    // Support both OTel v1 and v2 overloads:\n    // - startActiveSpan(name, callback)\n    // - startActiveSpan(name, options, callback)\n    // - startActiveSpan(name, options, context, callback)\n    startActiveSpan: (name: string, arg2?: any, arg3?: any, arg4?: any) => {\n      const span = createNoOpSpan();\n      let cb: any = undefined;\n      if (typeof arg2 === 'function') cb = arg2;\n      else if (typeof arg3 === 'function') cb = arg3;\n      else if (typeof arg4 === 'function') cb = arg4;\n      if (typeof cb === 'function') {\n        try {\n          return cb(span);\n        } catch {\n          // swallow errors in no-op implementation\n          return undefined;\n        }\n      }\n      // No callback supplied: return a no-op span like the real API would\n      return span;\n    },\n  };\n}\n\nfunction createNoOpSpan() {\n  return {\n    spanContext: () => ({ traceId: '', spanId: '', traceFlags: 0 }),\n    setAttribute: () => {},\n    setAttributes: () => {},\n    addEvent: () => {},\n    setStatus: () => {},\n    updateName: () => {},\n    end: () => {},\n    isRecording: () => false,\n    recordException: () => {},\n  };\n}\n\nfunction createNoOpMeter() {\n  return {\n    createCounter: () => ({ add: () => {} }),\n    createHistogram: () => ({ record: () => {} }),\n    createUpDownCounter: () => ({ add: () => {} }),\n    createObservableGauge: () => {},\n    createObservableCounter: () => {},\n    createObservableUpDownCounter: () => {},\n  };\n}\n","/**\n * Enhanced state capture for OTEL spans to enable interactive debugging.\n *\n * This module provides utilities to capture complete execution state in span\n * attributes, enabling time-travel debugging and full state inspection.\n */\n\nimport { Span } from './lazy-otel';\n\nconst MAX_ATTRIBUTE_LENGTH = 10000; // Truncate large values\nconst MAX_ARRAY_ITEMS = 100; // Limit array size in attributes\n\n/**\n * Safely serialize a value for OTEL span attributes.\n * Handles truncation, circular refs, and type conversions.\n */\nfunction safeSerialize(value: unknown, maxLength = MAX_ATTRIBUTE_LENGTH): string {\n  try {\n    if (value === undefined || value === null) return String(value);\n\n    // Detect circular references\n    const seen = new WeakSet();\n    const json = JSON.stringify(value, (key, val) => {\n      if (typeof val === 'object' && val !== null) {\n        if (seen.has(val)) return '[Circular]';\n        seen.add(val);\n      }\n      // Truncate long strings\n      if (typeof val === 'string' && val.length > maxLength) {\n        return val.substring(0, maxLength) + '...[truncated]';\n      }\n      return val;\n    });\n\n    if (json.length > maxLength) {\n      return json.substring(0, maxLength) + '...[truncated]';\n    }\n    return json;\n  } catch (err) {\n    return `[Error serializing: ${err instanceof Error ? err.message : String(err)}]`;\n  }\n}\n\n/**\n * Capture check input context (Liquid template variables) in span.\n */\nexport function captureCheckInputContext(span: Span, context: Record<string, unknown>): void {\n  try {\n    // Capture key context variables\n    const keys = Object.keys(context);\n    span.setAttribute('visor.check.input.keys', keys.join(','));\n    span.setAttribute('visor.check.input.count', keys.length);\n\n    // Capture full context as JSON (with size limit)\n    span.setAttribute('visor.check.input.context', safeSerialize(context));\n\n    // Capture specific important variables separately for easy querying\n    if (context.pr) {\n      span.setAttribute('visor.check.input.pr', safeSerialize(context.pr, 1000));\n    }\n    if (context.outputs) {\n      span.setAttribute('visor.check.input.outputs', safeSerialize(context.outputs, 5000));\n    }\n    if (context.env) {\n      span.setAttribute('visor.check.input.env_keys', Object.keys(context.env as object).join(','));\n    }\n  } catch (err) {\n    try {\n      span.setAttribute('visor.check.input.error', String(err));\n    } catch {\n      // Ignore if we can't even set the error attribute\n    }\n  }\n}\n\n/**\n * Capture check output in span.\n */\nexport function captureCheckOutput(span: Span, output: unknown): void {\n  try {\n    span.setAttribute('visor.check.output.type', typeof output);\n\n    if (Array.isArray(output)) {\n      span.setAttribute('visor.check.output.length', output.length);\n      // Store first few items for preview\n      const preview = output.slice(0, 10);\n      span.setAttribute('visor.check.output.preview', safeSerialize(preview, 2000));\n    }\n\n    // Full output (truncated if needed)\n    span.setAttribute('visor.check.output', safeSerialize(output));\n  } catch (err) {\n    try {\n      span.setAttribute('visor.check.output.error', String(err));\n    } catch {\n      // Ignore if we can't even set the error attribute\n    }\n  }\n}\n\n/**\n * Capture forEach iteration state.\n */\nexport function captureForEachState(\n  span: Span,\n  items: unknown[],\n  index: number,\n  currentItem: unknown\n): void {\n  try {\n    span.setAttribute('visor.foreach.total', items.length);\n    span.setAttribute('visor.foreach.index', index);\n    span.setAttribute('visor.foreach.current_item', safeSerialize(currentItem, 500));\n\n    // Store all items if not too large\n    if (items.length <= MAX_ARRAY_ITEMS) {\n      span.setAttribute('visor.foreach.items', safeSerialize(items));\n    } else {\n      span.setAttribute(\n        'visor.foreach.items.preview',\n        safeSerialize(items.slice(0, MAX_ARRAY_ITEMS))\n      );\n      span.setAttribute('visor.foreach.items.truncated', true);\n    }\n  } catch (err) {\n    span.setAttribute('visor.foreach.error', String(err));\n  }\n}\n\n/**\n * Capture Liquid template evaluation details.\n */\nexport function captureLiquidEvaluation(\n  span: Span,\n  template: string,\n  context: Record<string, unknown>,\n  result: string\n): void {\n  try {\n    span.setAttribute('visor.liquid.template', template.substring(0, 1000));\n    span.setAttribute('visor.liquid.template.length', template.length);\n    span.setAttribute('visor.liquid.result', result.substring(0, 2000));\n    span.setAttribute('visor.liquid.result.length', result.length);\n    span.setAttribute('visor.liquid.context', safeSerialize(context, 3000));\n  } catch (err) {\n    span.setAttribute('visor.liquid.error', String(err));\n  }\n}\n\n/**\n * Capture JavaScript transform execution.\n */\nexport function captureTransformJS(\n  span: Span,\n  code: string,\n  input: unknown,\n  output: unknown\n): void {\n  try {\n    // Truncate long code while keeping plain string (no JSON quoting)\n    const codePreview = code.length > 2000 ? code.substring(0, 2000) + '...[truncated]' : code;\n    span.setAttribute('visor.transform.code', codePreview);\n    span.setAttribute('visor.transform.code.length', code.length);\n    span.setAttribute('visor.transform.input', safeSerialize(input, 2000));\n    span.setAttribute('visor.transform.output', safeSerialize(output, 2000));\n  } catch (err) {\n    span.setAttribute('visor.transform.error', String(err));\n  }\n}\n\n/**\n * Capture provider request/response summary (safe, no raw AI content).\n */\nexport function captureProviderCall(\n  span: Span,\n  providerType: string,\n  request: { prompt?: string; model?: string; [key: string]: unknown },\n  response: { content?: string; tokens?: number; [key: string]: unknown }\n): void {\n  try {\n    span.setAttribute('visor.provider.type', providerType);\n\n    // Request summary\n    if (request.model) span.setAttribute('visor.provider.request.model', String(request.model));\n    if (request.prompt) {\n      span.setAttribute('visor.provider.request.prompt.length', request.prompt.length);\n      span.setAttribute('visor.provider.request.prompt.preview', request.prompt.substring(0, 500));\n    }\n\n    // Response summary\n    if (response.content) {\n      span.setAttribute('visor.provider.response.length', response.content.length);\n      span.setAttribute('visor.provider.response.preview', response.content.substring(0, 500));\n    }\n    if (response.tokens) {\n      span.setAttribute('visor.provider.response.tokens', response.tokens);\n    }\n  } catch (err) {\n    span.setAttribute('visor.provider.error', String(err));\n  }\n}\n\n/**\n * Capture conditional evaluation (if/fail_if).\n */\nexport function captureConditionalEvaluation(\n  span: Span,\n  condition: string,\n  result: boolean,\n  context: Record<string, unknown>\n): void {\n  try {\n    span.setAttribute('visor.condition.expression', condition.substring(0, 500));\n    span.setAttribute('visor.condition.result', result);\n    span.setAttribute('visor.condition.context', safeSerialize(context, 2000));\n  } catch (err) {\n    span.setAttribute('visor.condition.error', String(err));\n  }\n}\n\n/**\n * Capture routing decision (retry/goto/run).\n */\nexport function captureRoutingDecision(\n  span: Span,\n  action: 'retry' | 'goto' | 'run',\n  target: string | string[],\n  condition?: string\n): void {\n  try {\n    span.setAttribute('visor.routing.action', action);\n    span.setAttribute('visor.routing.target', Array.isArray(target) ? target.join(',') : target);\n    if (condition) {\n      span.setAttribute('visor.routing.condition', condition.substring(0, 500));\n    }\n  } catch (err) {\n    span.setAttribute('visor.routing.error', String(err));\n  }\n}\n\n/**\n * Create a snapshot of the entire execution state at a point in time.\n * This is added as a span event for time-travel debugging.\n */\nexport function captureStateSnapshot(\n  span: Span,\n  checkId: string,\n  outputs: Record<string, unknown>,\n  memory: Record<string, unknown>\n): void {\n  try {\n    span.addEvent('state.snapshot', {\n      'visor.snapshot.check_id': checkId,\n      'visor.snapshot.outputs': safeSerialize(outputs, 5000),\n      'visor.snapshot.memory': safeSerialize(memory, 5000),\n      'visor.snapshot.timestamp': new Date().toISOString(),\n    });\n  } catch (err) {\n    span.setAttribute('visor.snapshot.error', String(err));\n  }\n}\n","import * as fs from 'fs';\nimport * as path from 'path';\n\nlet CURRENT_FILE: string | null = null;\nlet dirReady = false;\nlet writeChain: Promise<void> = Promise.resolve();\nfunction resolveTargetPath(outDir: string): string {\n  if (process.env.VISOR_FALLBACK_TRACE_FILE) {\n    CURRENT_FILE = process.env.VISOR_FALLBACK_TRACE_FILE;\n    return CURRENT_FILE;\n  }\n  if (CURRENT_FILE) return CURRENT_FILE;\n  const ts = new Date().toISOString().replace(/[:.]/g, '-');\n  CURRENT_FILE = path.join(outDir, `${ts}.ndjson`);\n  return CURRENT_FILE;\n}\n\nfunction isEnabled(): boolean {\n  // Enable when CLI set a fallback file (serverless mode), or when explicit file sink is enabled\n  if (process.env.VISOR_FALLBACK_TRACE_FILE) return true;\n  return (\n    process.env.VISOR_TELEMETRY_ENABLED === 'true' &&\n    (process.env.VISOR_TELEMETRY_SINK || 'file') === 'file'\n  );\n}\n\nfunction appendAsync(outDir: string, line: string): void {\n  writeChain = writeChain\n    .then(async () => {\n      if (!dirReady) {\n        try {\n          await fs.promises.mkdir(outDir, { recursive: true });\n        } catch {}\n        dirReady = true;\n      }\n      const target = resolveTargetPath(outDir);\n      await fs.promises.appendFile(target, line, 'utf8');\n    })\n    .catch(() => {});\n}\n\nexport async function flushNdjson(): Promise<void> {\n  try {\n    await writeChain;\n  } catch {}\n}\n\nexport function emitNdjsonFallback(name: string, attrs: Record<string, unknown>): void {\n  try {\n    if (!isEnabled()) return;\n    const outDir = process.env.VISOR_TRACE_DIR || path.join(process.cwd(), 'output', 'traces');\n    const line = JSON.stringify({ name, attributes: attrs }) + '\\n';\n    appendAsync(outDir, line);\n  } catch {\n    // ignore\n  }\n}\n\nexport function emitNdjsonSpanWithEvents(\n  name: string,\n  attrs: Record<string, unknown>,\n  events: Array<{ name: string; attrs?: Record<string, unknown> }>\n): void {\n  try {\n    if (!isEnabled()) return;\n    const outDir = process.env.VISOR_TRACE_DIR || path.join(process.cwd(), 'output', 'traces');\n    const line = JSON.stringify({ name, attributes: attrs, events }) + '\\n';\n    appendAsync(outDir, line);\n  } catch {\n    // ignore\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { AIReviewService, AIReviewConfig } from '../ai-review-service';\nimport { EnvironmentResolver } from '../utils/env-resolver';\nimport { IssueFilter } from '../issue-filter';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { trace, context as otContext } from '../telemetry/lazy-otel';\nimport {\n  captureCheckInputContext,\n  captureCheckOutput,\n  captureProviderCall,\n} from '../telemetry/state-capture';\n\n/**\n * AI-powered check provider using probe agent\n */\nexport class AICheckProvider extends CheckProvider {\n  private aiReviewService: AIReviewService;\n  private liquidEngine: Liquid;\n\n  constructor() {\n    super();\n    this.aiReviewService = new AIReviewService();\n    this.liquidEngine = createExtendedLiquid();\n  }\n\n  getName(): string {\n    return 'ai';\n  }\n\n  getDescription(): string {\n    return 'AI-powered code review using Google Gemini, Anthropic Claude, OpenAI GPT, or AWS Bedrock models';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'ai'\n    if (cfg.type !== 'ai') {\n      return false;\n    }\n\n    // Check for prompt or focus\n    const prompt = cfg.prompt || cfg.focus;\n    if (typeof prompt !== 'string') {\n      return false;\n    }\n\n    // Focus is now config-driven - any string value is acceptable\n    // No validation needed here as focus is just a hint to the AI\n\n    // Validate AI provider config if present\n    if (cfg.ai) {\n      if (\n        cfg.ai.provider &&\n        !['google', 'anthropic', 'openai', 'bedrock', 'mock'].includes(cfg.ai.provider as string)\n      ) {\n        return false;\n      }\n\n      // Validate mcpServers if present\n      if (cfg.ai.mcpServers) {\n        if (!this.validateMcpServers(cfg.ai.mcpServers)) {\n          return false;\n        }\n      }\n    }\n\n    // Validate check-level MCP servers if present\n    const checkLevelMcpServers = (cfg as CheckProviderConfig & { ai_mcp_servers?: unknown })\n      .ai_mcp_servers;\n    if (checkLevelMcpServers) {\n      if (!this.validateMcpServers(checkLevelMcpServers)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Validate MCP servers configuration\n   */\n  private validateMcpServers(mcpServers: unknown): boolean {\n    if (typeof mcpServers !== 'object' || mcpServers === null) {\n      return false;\n    }\n\n    for (const serverConfig of Object.values(mcpServers)) {\n      if (!serverConfig || typeof serverConfig !== 'object') {\n        return false;\n      }\n      const config = serverConfig as { command?: unknown; args?: unknown };\n      if (typeof config.command !== 'string') {\n        return false;\n      }\n      if (config.args !== undefined && !Array.isArray(config.args)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Group files by their file extension for template context\n   */\n  private groupFilesByExtension(\n    files: import('../pr-analyzer').PRFile[]\n  ): Record<string, import('../pr-analyzer').PRFile[]> {\n    const grouped: Record<string, import('../pr-analyzer').PRFile[]> = {};\n\n    files.forEach(file => {\n      const parts = file.filename.split('.');\n      const ext = parts.length > 1 ? parts.pop()?.toLowerCase() || 'noext' : 'noext';\n      if (!grouped[ext]) {\n        grouped[ext] = [];\n      }\n      grouped[ext].push(file);\n    });\n\n    return grouped;\n  }\n\n  /**\n   * Process prompt configuration to resolve final prompt string\n   */\n  private async processPrompt(\n    promptConfig: string,\n    prInfo: PRInfo,\n    eventContext?: Record<string, unknown>,\n    dependencyResults?: Map<string, ReviewSummary>,\n    outputHistory?: Map<string, unknown[]>\n  ): Promise<string> {\n    let promptContent: string;\n\n    // Auto-detect if it's a file path or inline content\n    if (await this.isFilePath(promptConfig)) {\n      promptContent = await this.loadPromptFromFile(promptConfig);\n    } else {\n      promptContent = promptConfig;\n    }\n\n    // Process Liquid templates in the prompt\n    return await this.renderPromptTemplate(\n      promptContent,\n      prInfo,\n      eventContext,\n      dependencyResults,\n      outputHistory\n    );\n  }\n\n  /**\n   * Detect if a string is likely a file path and if the file exists\n   */\n  private async isFilePath(str: string): Promise<boolean> {\n    // Quick checks to exclude obvious non-file-path content\n    if (!str || str.trim() !== str || str.length > 512) {\n      return false;\n    }\n\n    // Exclude strings that are clearly content (contain common content indicators)\n    // But be more careful with paths that might contain common words as directory names\n    if (\n      /\\s{2,}/.test(str) || // Multiple consecutive spaces\n      /\\n/.test(str) || // Contains newlines\n      /^(please|analyze|review|check|find|identify|look|search)/i.test(str.trim()) || // Starts with command words\n      str.split(' ').length > 8 // Too many words for a typical file path\n    ) {\n      return false;\n    }\n\n    // For strings with path separators, be more lenient about common words\n    // as they might be legitimate directory names\n    if (!/[\\/\\\\]/.test(str)) {\n      // Only apply strict English word filter to non-path strings\n      if (/\\b(the|and|or|but|for|with|by|from|in|on|at|as)\\b/i.test(str)) {\n        return false;\n      }\n    }\n\n    // Positive indicators for file paths\n    const hasFileExtension = /\\.[a-zA-Z0-9]{1,10}$/i.test(str);\n    const hasPathSeparators = /[\\/\\\\]/.test(str);\n    const isRelativePath = /^\\.{1,2}\\//.test(str);\n    const isAbsolutePath = path.isAbsolute(str);\n    const hasTypicalFileChars = /^[a-zA-Z0-9._\\-\\/\\\\:~]+$/.test(str);\n\n    // Must have at least one strong indicator\n    if (!(hasFileExtension || isRelativePath || isAbsolutePath || hasPathSeparators)) {\n      return false;\n    }\n\n    // Must contain only typical file path characters\n    if (!hasTypicalFileChars) {\n      return false;\n    }\n\n    // Additional validation for suspected file paths\n    try {\n      // Try to resolve and check if file exists\n      let resolvedPath: string;\n\n      if (path.isAbsolute(str)) {\n        resolvedPath = path.normalize(str);\n      } else {\n        // Resolve relative to current working directory\n        resolvedPath = path.resolve(process.cwd(), str);\n      }\n\n      // Check if file exists\n      const fs = require('fs').promises;\n      try {\n        const stat = await fs.stat(resolvedPath);\n        return stat.isFile();\n      } catch {\n        // File doesn't exist, but might still be a valid file path format\n        // Return true if it has strong file path indicators\n        return hasFileExtension && (isRelativePath || isAbsolutePath || hasPathSeparators);\n      }\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Load prompt content from file with security validation\n   */\n  private async loadPromptFromFile(promptPath: string): Promise<string> {\n    // Enforce .liquid file extension for all prompt files\n    if (!promptPath.endsWith('.liquid')) {\n      throw new Error('Prompt file must have .liquid extension');\n    }\n\n    let resolvedPath: string;\n\n    if (path.isAbsolute(promptPath)) {\n      // Absolute path - use as-is\n      resolvedPath = promptPath;\n    } else {\n      // Relative path - resolve relative to current working directory\n      resolvedPath = path.resolve(process.cwd(), promptPath);\n    }\n\n    // Security: For relative paths, ensure they don't escape the current directory\n    if (!path.isAbsolute(promptPath)) {\n      const normalizedPath = path.normalize(resolvedPath);\n      const currentDir = path.resolve(process.cwd());\n      if (!normalizedPath.startsWith(currentDir)) {\n        throw new Error('Invalid prompt file path: path traversal detected');\n      }\n    }\n\n    // Security: Check for obvious path traversal patterns\n    if (promptPath.includes('../..')) {\n      throw new Error('Invalid prompt file path: path traversal detected');\n    }\n\n    try {\n      const promptContent = await fs.readFile(resolvedPath, 'utf-8');\n      return promptContent;\n    } catch (error) {\n      throw new Error(\n        `Failed to load prompt from ${resolvedPath}: ${\n          error instanceof Error ? error.message : 'Unknown error'\n        }`\n      );\n    }\n  }\n\n  /**\n   * Render Liquid template in prompt with comprehensive event context\n   */\n  private async renderPromptTemplate(\n    promptContent: string,\n    prInfo: PRInfo,\n    eventContext?: Record<string, unknown>,\n    dependencyResults?: Map<string, ReviewSummary>,\n    outputHistory?: Map<string, unknown[]>\n  ): Promise<string> {\n    // Build outputs_raw from -raw keys (aggregate parent values)\n    const outputsRaw: Record<string, unknown> = {};\n    if (dependencyResults) {\n      for (const [k, v] of dependencyResults.entries()) {\n        if (typeof k !== 'string') continue;\n        if (k.endsWith('-raw')) {\n          const name = k.slice(0, -4);\n          const summary = v as ReviewSummary & { output?: unknown };\n          outputsRaw[name] = summary.output !== undefined ? summary.output : summary;\n        }\n      }\n    }\n\n    // Create comprehensive template context with PR and event information\n    const templateContext = {\n      // PR Information\n      pr: {\n        number: prInfo.number,\n        title: prInfo.title,\n        body: prInfo.body,\n        author: prInfo.author,\n        baseBranch: prInfo.base,\n        headBranch: prInfo.head,\n        isIncremental: prInfo.isIncremental,\n        filesChanged: prInfo.files?.map(f => f.filename) || [],\n        totalAdditions: prInfo.files?.reduce((sum, f) => sum + f.additions, 0) || 0,\n        totalDeletions: prInfo.files?.reduce((sum, f) => sum + f.deletions, 0) || 0,\n        totalChanges: prInfo.files?.reduce((sum, f) => sum + f.changes, 0) || 0,\n        base: prInfo.base,\n        head: prInfo.head,\n      },\n\n      // File Details\n      files: prInfo.files || [],\n      description: prInfo.body || '',\n\n      // GitHub Event Context\n      event: eventContext\n        ? {\n            name: eventContext.event_name || 'unknown',\n            action: eventContext.action,\n            isPullRequest: !prInfo.isIssue, // Set based on whether this is a PR or an issue\n\n            // Repository Info\n            repository: eventContext.repository\n              ? {\n                  owner: (eventContext.repository as { owner?: { login?: string } })?.owner?.login,\n                  name: (eventContext.repository as { name?: string })?.name,\n                  fullName: eventContext.repository\n                    ? `${(eventContext.repository as { owner?: { login?: string } })?.owner?.login}/${(eventContext.repository as { name?: string })?.name}`\n                    : undefined,\n                }\n              : undefined,\n\n            // Comment Data (for comment events)\n            comment: eventContext.comment\n              ? {\n                  body: (eventContext.comment as { body?: string })?.body,\n                  author: (eventContext.comment as { user?: { login?: string } })?.user?.login,\n                }\n              : undefined,\n\n            // Issue Data (for issue events)\n            issue: eventContext.issue\n              ? {\n                  number: (eventContext.issue as { number?: number })?.number,\n                  title: (eventContext.issue as { title?: string })?.title,\n                  body: (eventContext.issue as { body?: string })?.body,\n                  state: (eventContext.issue as { state?: string })?.state,\n                  author: (eventContext.issue as { user?: { login?: string } })?.user?.login,\n                  labels: (eventContext.issue as { labels?: unknown[] })?.labels || [],\n                  assignees:\n                    (\n                      eventContext as { issue?: { assignees?: Array<{ login: string }> } }\n                    )?.issue?.assignees?.map(a => a.login) || [],\n                  createdAt: (eventContext.issue as { created_at?: string })?.created_at,\n                  updatedAt: (eventContext.issue as { updated_at?: string })?.updated_at,\n                  isPullRequest: !!(eventContext.issue as { pull_request?: unknown })?.pull_request,\n                }\n              : undefined,\n\n            // Pull Request Event Data\n            pullRequest: eventContext.pull_request\n              ? {\n                  number: (eventContext.pull_request as { number?: number })?.number,\n                  state: (eventContext.pull_request as { state?: string })?.state,\n                  draft: (eventContext.pull_request as { draft?: boolean })?.draft,\n                  headSha: (eventContext.pull_request as { head?: { sha?: string } })?.head?.sha,\n                  headRef: (eventContext.pull_request as { head?: { ref?: string } })?.head?.ref,\n                  baseSha: (eventContext.pull_request as { base?: { sha?: string } })?.base?.sha,\n                  baseRef: (eventContext.pull_request as { base?: { ref?: string } })?.base?.ref,\n                }\n              : undefined,\n\n            // Raw event payload for advanced use cases\n            payload: eventContext,\n          }\n        : undefined,\n\n      // Utility data for templates\n      utils: {\n        // Date/time helpers\n        now: new Date().toISOString(),\n        today: new Date().toISOString().split('T')[0],\n\n        // Dynamic file grouping by extension\n        filesByExtension: this.groupFilesByExtension(prInfo.files || []),\n\n        // File status categorizations\n        addedFiles: (prInfo.files || []).filter(f => f.status === 'added'),\n        modifiedFiles: (prInfo.files || []).filter(f => f.status === 'modified'),\n        removedFiles: (prInfo.files || []).filter(f => f.status === 'removed'),\n        renamedFiles: (prInfo.files || []).filter(f => f.status === 'renamed'),\n\n        // Change analysis\n        hasLargeChanges: (prInfo.files || []).some(f => f.changes > 50),\n        totalFiles: (prInfo.files || []).length,\n      },\n\n      // Previous check outputs (dependency results)\n      // Expose raw output directly if available, otherwise expose the result as-is\n      outputs: dependencyResults\n        ? Object.fromEntries(\n            Array.from(dependencyResults.entries()).map(([checkName, result]) => [\n              checkName,\n              (() => {\n                const summary = result as ReviewSummary & { output?: unknown };\n                return summary.output !== undefined ? summary.output : summary;\n              })(),\n            ])\n          )\n        : {},\n      // Alias for consistency with other providers\n      outputs_history: (() => {\n        const hist: Record<string, unknown[]> = {};\n        if (outputHistory) {\n          for (const [k, v] of outputHistory.entries()) hist[k] = v;\n        }\n        return hist;\n      })(),\n      // New: outputs_raw exposes aggregate values (e.g., full arrays for forEach parents)\n      outputs_raw: outputsRaw,\n    };\n\n    try {\n      return await this.liquidEngine.parseAndRender(promptContent, templateContext);\n    } catch (error) {\n      throw new Error(\n        `Failed to render prompt template: ${\n          error instanceof Error ? error.message : 'Unknown error'\n        }`\n      );\n    }\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    _dependencyResults?: Map<string, ReviewSummary>,\n    sessionInfo?: { parentSessionId?: string; reuseSession?: boolean }\n  ): Promise<ReviewSummary> {\n    // Apply environment configuration if present\n    if (config.env) {\n      const result = EnvironmentResolver.withTemporaryEnv(config.env, () => {\n        // This will be executed with the temporary environment\n        return this.executeWithConfig(prInfo, config, _dependencyResults, sessionInfo);\n      });\n\n      if (result instanceof Promise) {\n        return result;\n      }\n      return result;\n    }\n\n    return this.executeWithConfig(prInfo, config, _dependencyResults, sessionInfo);\n  }\n\n  private async executeWithConfig(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    _dependencyResults?: Map<string, ReviewSummary>,\n    sessionInfo?: { parentSessionId?: string; reuseSession?: boolean }\n  ): Promise<ReviewSummary> {\n    // Extract AI configuration - only set properties that are explicitly provided\n    const aiConfig: AIReviewConfig = {};\n\n    // Check-level AI configuration (ai object)\n    if (config.ai) {\n      // Only set properties that are actually defined to avoid overriding env vars\n      if (config.ai.apiKey !== undefined) {\n        aiConfig.apiKey = config.ai.apiKey as string;\n      }\n      if (config.ai.model !== undefined) {\n        aiConfig.model = config.ai.model as string;\n      }\n      if (config.ai.timeout !== undefined) {\n        aiConfig.timeout = config.ai.timeout as number;\n      }\n      if (config.ai.provider !== undefined) {\n        aiConfig.provider = config.ai.provider as\n          | 'google'\n          | 'anthropic'\n          | 'openai'\n          | 'bedrock'\n          | 'mock';\n      }\n      if (config.ai.debug !== undefined) {\n        aiConfig.debug = config.ai.debug as boolean;\n      }\n      if (config.ai.enableDelegate !== undefined) {\n        aiConfig.enableDelegate = config.ai.enableDelegate as boolean;\n      }\n      if (config.ai.skip_code_context !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (aiConfig as any).skip_code_context = config.ai.skip_code_context as boolean;\n      }\n    }\n\n    // Check-level AI model and provider (top-level properties)\n    if (config.ai_model !== undefined) {\n      aiConfig.model = config.ai_model as string;\n    }\n    if (config.ai_provider !== undefined) {\n      aiConfig.provider = config.ai_provider as\n        | 'google'\n        | 'anthropic'\n        | 'openai'\n        | 'bedrock'\n        | 'mock';\n    }\n\n    // Get custom prompt from config - REQUIRED, no fallbacks\n    const customPrompt = config.prompt;\n\n    if (!customPrompt) {\n      throw new Error(\n        `No prompt defined for check. All checks must have prompts defined in .visor.yaml configuration.`\n      );\n    }\n\n    // Setup MCP tools from multiple configuration levels\n    const mcpServers: Record<string, import('../types/config').McpServerConfig> = {};\n\n    // 1. Start with global MCP servers (from visor config root)\n    const globalConfig = config as CheckProviderConfig & {\n      ai_mcp_servers?: Record<string, import('../types/config').McpServerConfig>;\n    };\n    if (globalConfig.ai_mcp_servers) {\n      Object.assign(mcpServers, globalConfig.ai_mcp_servers);\n    }\n\n    // 2. Add check-level MCP servers (overrides global)\n    if (config.ai_mcp_servers) {\n      Object.assign(mcpServers, config.ai_mcp_servers);\n    }\n\n    // 3. Add ai.mcpServers (overrides everything)\n    if (config.ai?.mcpServers) {\n      Object.assign(mcpServers, config.ai.mcpServers);\n    }\n\n    // Pass MCP server config directly to AI service (unless tools are disabled)\n    if (Object.keys(mcpServers).length > 0 && !config.ai?.disable_tools) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (aiConfig as any).mcpServers = mcpServers;\n      if (aiConfig.debug) {\n        console.error(\n          `🔧 Debug: AI check MCP configured with ${Object.keys(mcpServers).length} servers`\n        );\n      }\n    } else if (config.ai?.disable_tools && aiConfig.debug) {\n      console.error(`🔧 Debug: AI check has tools disabled - MCP servers will not be passed`);\n    }\n\n    // Build template context for state capture\n    const templateContext = {\n      pr: {\n        number: prInfo.number,\n        title: prInfo.title,\n        author: prInfo.author,\n        branch: prInfo.head,\n        base: prInfo.base,\n      },\n      files: prInfo.files,\n      outputs: _dependencyResults\n        ? Object.fromEntries(\n            Array.from(_dependencyResults.entries()).map(([checkName, result]) => [\n              checkName,\n              (result as any).output !== undefined ? (result as any).output : result,\n            ])\n          )\n        : {},\n    };\n\n    // Capture input context in active OTEL span\n    try {\n      const span = trace.getSpan(otContext.active());\n      if (span) {\n        captureCheckInputContext(span, templateContext);\n      }\n    } catch {\n      // Ignore telemetry errors\n    }\n    // Fallback NDJSON for input context (non-OTEL environments)\n    try {\n      const checkId = (config as any).checkName || (config as any).id || 'unknown';\n      const ctxJson = JSON.stringify(templateContext);\n      const { emitNdjsonSpanWithEvents } = require('../telemetry/fallback-ndjson');\n      emitNdjsonSpanWithEvents(\n        'visor.check',\n        { 'visor.check.id': checkId, 'visor.check.input.context': ctxJson },\n        []\n      );\n    } catch {}\n\n    // Process prompt with Liquid templates and file loading\n    // Skip event context (PR diffs, files, etc.) if requested\n    const eventContext = config.ai?.skip_code_context ? {} : config.eventContext;\n    const processedPrompt = await this.processPrompt(\n      customPrompt,\n      prInfo,\n      eventContext,\n      _dependencyResults,\n      (config as any).__outputHistory as Map<string, unknown[]> | undefined\n    );\n\n    // Create AI service with config - environment variables will be used if aiConfig is empty\n    const service = new AIReviewService(aiConfig);\n\n    // Pass the custom prompt and schema - no fallbacks\n    const schema = config.schema as string | Record<string, unknown> | undefined;\n\n    // Only output debug messages if debug mode is enabled\n    if (aiConfig.debug) {\n      console.error(\n        `🔧 Debug: AICheckProvider using processed prompt: ${processedPrompt.substring(0, 100)}...`\n      );\n      console.error(`🔧 Debug: AICheckProvider schema from config: ${JSON.stringify(schema)}`);\n      console.error(`🔧 Debug: AICheckProvider full config: ${JSON.stringify(config, null, 2)}`);\n    }\n\n    try {\n      if (aiConfig.debug) {\n        console.error(\n          `🔧 Debug: AICheckProvider passing checkName: ${config.checkName} to service`\n        );\n      }\n\n      let result: ReviewSummary;\n\n      // Check if we should use session reuse\n      if (sessionInfo?.reuseSession && sessionInfo.parentSessionId) {\n        // Get session_mode from config, default to 'clone'\n        const sessionMode = (config.session_mode as 'clone' | 'append') || 'clone';\n\n        if (aiConfig.debug) {\n          console.error(\n            `🔄 Debug: Using session reuse with parent session: ${sessionInfo.parentSessionId} (mode: ${sessionMode})`\n          );\n        }\n        result = await service.executeReviewWithSessionReuse(\n          prInfo,\n          processedPrompt,\n          sessionInfo.parentSessionId,\n          schema,\n          config.checkName,\n          sessionMode\n        );\n      } else {\n        if (aiConfig.debug) {\n          console.error(`🆕 Debug: Creating new AI session for check: ${config.checkName}`);\n        }\n        result = await service.executeReview(\n          prInfo,\n          processedPrompt,\n          schema,\n          config.checkName,\n          config.sessionId\n        );\n      }\n\n      // Apply issue suppression filtering\n      const suppressionEnabled = config.suppressionEnabled !== false;\n      const issueFilter = new IssueFilter(suppressionEnabled);\n      const filteredIssues = issueFilter.filterIssues(result.issues || [], process.cwd());\n\n      const finalResult = {\n        ...result,\n        issues: filteredIssues,\n      };\n\n      // Capture AI provider call and output in active OTEL span\n      try {\n        const span = trace.getSpan(otContext.active());\n        if (span) {\n          captureProviderCall(\n            span,\n            'ai',\n            {\n              prompt: processedPrompt.substring(0, 500), // Preview only\n              model: aiConfig.model,\n            },\n            {\n              content: JSON.stringify(finalResult).substring(0, 500),\n              tokens: (result as any).usage?.totalTokens,\n            }\n          );\n          const outputForSpan = (finalResult as { output?: unknown }).output ?? finalResult;\n          captureCheckOutput(span, outputForSpan);\n        }\n      } catch {\n        // Ignore telemetry errors\n      }\n      // Fallback NDJSON for output (non-OTEL environments)\n      try {\n        const checkId = (config as any).checkName || (config as any).id || 'unknown';\n        const outJson = JSON.stringify((finalResult as any).output ?? finalResult);\n        const { emitNdjsonSpanWithEvents } = require('../telemetry/fallback-ndjson');\n        emitNdjsonSpanWithEvents(\n          'visor.check',\n          { 'visor.check.id': checkId, 'visor.check.output': outJson },\n          []\n        );\n      } catch {}\n\n      return finalResult;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n\n      // Log detailed error information\n      console.error(`❌ AI Check Provider Error for check: ${errorMessage}`);\n\n      // Check if this is a critical error (authentication, rate limits, etc)\n      const isCriticalError =\n        errorMessage.includes('API rate limit') ||\n        errorMessage.includes('403') ||\n        errorMessage.includes('401') ||\n        errorMessage.includes('authentication') ||\n        errorMessage.includes('API key');\n\n      if (isCriticalError) {\n        console.error(`🚨 CRITICAL ERROR: AI provider authentication or rate limit issue detected`);\n        console.error(`🚨 This check cannot proceed without valid API credentials`);\n      }\n\n      // Re-throw with more context\n      throw new Error(`AI analysis failed: ${errorMessage}`);\n    }\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'prompt',\n      'focus',\n      'schema',\n      'group',\n      'ai.provider',\n      'ai.model',\n      'ai.apiKey',\n      'ai.timeout',\n      'ai.mcpServers',\n      'ai.enableDelegate',\n      'ai_model',\n      'ai_provider',\n      'ai_mcp_servers',\n      'env',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // Check if any AI API key is available\n    return !!(\n      process.env.GOOGLE_API_KEY ||\n      process.env.ANTHROPIC_API_KEY ||\n      process.env.OPENAI_API_KEY ||\n      // AWS Bedrock credentials check\n      (process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY) ||\n      process.env.AWS_BEDROCK_API_KEY\n    );\n  }\n\n  getRequirements(): string[] {\n    return [\n      'At least one of: GOOGLE_API_KEY, ANTHROPIC_API_KEY, OPENAI_API_KEY, or AWS credentials (AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY)',\n      'Optional: MODEL_NAME environment variable',\n      'Optional: AWS_REGION for Bedrock provider',\n      'Network access to AI provider APIs',\n    ];\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary, ReviewIssue } from '../reviewer';\nimport { IssueFilter } from '../issue-filter';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { trace, context as otContext } from '../telemetry/lazy-otel';\nimport {\n  captureCheckInputContext,\n  captureCheckOutput,\n  captureProviderCall,\n} from '../telemetry/state-capture';\nimport { EnvironmentResolver } from '../utils/env-resolver';\n\n/**\n * Check provider that sends data to an HTTP endpoint, typically used as an output/notification provider\n */\nexport class HttpCheckProvider extends CheckProvider {\n  private liquid: Liquid;\n\n  constructor() {\n    super();\n    this.liquid = createExtendedLiquid();\n  }\n  getName(): string {\n    return 'http';\n  }\n\n  getDescription(): string {\n    return 'Send data to external HTTP endpoint for notifications or integration';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'http'\n    if (cfg.type !== 'http') {\n      return false;\n    }\n\n    // Must have URL specified\n    if (typeof cfg.url !== 'string' || !cfg.url) {\n      return false;\n    }\n\n    // Must have body template specified\n    if (typeof cfg.body !== 'string' || !cfg.body) {\n      return false;\n    }\n\n    // Validate URL format\n    try {\n      new URL(cfg.url as string);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    _sessionInfo?: { parentSessionId?: string; reuseSession?: boolean }\n  ): Promise<ReviewSummary> {\n    const url = config.url as string;\n    const bodyTemplate = config.body as string;\n    const method = (config.method as string) || 'POST';\n    const headers = (config.headers as Record<string, string>) || {};\n    const timeout = (config.timeout as number) || 30000;\n\n    // Prepare template context with all available data\n    const templateContext = {\n      pr: {\n        number: prInfo.number,\n        title: prInfo.title,\n        body: prInfo.body,\n        author: prInfo.author,\n        base: prInfo.base,\n        head: prInfo.head,\n        totalAdditions: prInfo.totalAdditions,\n        totalDeletions: prInfo.totalDeletions,\n      },\n      files: prInfo.files.map(f => ({\n        filename: f.filename,\n        status: f.status,\n        additions: f.additions,\n        deletions: f.deletions,\n        changes: f.changes,\n        patch: f.patch,\n      })),\n      outputs: dependencyResults ? Object.fromEntries(dependencyResults) : {},\n      metadata: config.metadata || {},\n    };\n\n    // Capture input context in active OTEL span\n    try {\n      const span = trace.getSpan(otContext.active());\n      if (span) {\n        captureCheckInputContext(span, templateContext);\n      }\n    } catch {\n      // Ignore telemetry errors\n    }\n\n    // Render the body template\n    let payload: Record<string, unknown>;\n    try {\n      const renderedBody = await this.liquid.parseAndRender(bodyTemplate, templateContext);\n      // Try to parse as JSON, otherwise send as plain text\n      try {\n        payload = JSON.parse(renderedBody);\n      } catch {\n        payload = { message: renderedBody };\n      }\n    } catch (error) {\n      return this.createErrorResult(\n        url,\n        new Error(\n          `Template rendering failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n        )\n      );\n    }\n\n    try {\n      // Resolve environment variables in headers\n      const resolvedHeaders = EnvironmentResolver.resolveHeaders(headers);\n\n      // Send webhook request\n      const response = await this.sendWebhookRequest(\n        url,\n        method,\n        resolvedHeaders,\n        payload,\n        timeout\n      );\n\n      // Parse webhook response\n      const result = this.parseWebhookResponse(response, url);\n\n      // Apply issue suppression filtering\n      const suppressionEnabled = config.suppressionEnabled !== false;\n      const issueFilter = new IssueFilter(suppressionEnabled);\n      const filteredIssues = issueFilter.filterIssues(result.issues || [], process.cwd());\n\n      const finalResult = {\n        ...result,\n        issues: filteredIssues,\n      };\n\n      // Capture HTTP provider call and output in active OTEL span\n      try {\n        const span = trace.getSpan(otContext.active());\n        if (span) {\n          // Sanitize headers for telemetry to avoid exposing sensitive data\n          const sanitizedHeaders = EnvironmentResolver.sanitizeHeaders(resolvedHeaders);\n          captureProviderCall(\n            span,\n            'http',\n            {\n              url,\n              method,\n              headers: sanitizedHeaders,\n              body: JSON.stringify(payload).substring(0, 500),\n            },\n            {\n              content: JSON.stringify(response).substring(0, 500),\n            }\n          );\n          const outputForSpan = (finalResult as { output?: unknown }).output ?? finalResult;\n          captureCheckOutput(span, outputForSpan);\n        }\n      } catch {\n        // Ignore telemetry errors\n      }\n\n      return finalResult;\n    } catch (error) {\n      return this.createErrorResult(url, error);\n    }\n  }\n\n  private async sendWebhookRequest(\n    url: string,\n    method: string,\n    headers: Record<string, string>,\n    payload: Record<string, unknown>,\n    timeout: number\n  ): Promise<Record<string, unknown>> {\n    // Check if fetch is available (Node 18+)\n    if (typeof fetch === 'undefined') {\n      throw new Error('Webhook provider requires Node.js 18+ or node-fetch package');\n    }\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n    try {\n      const response = await fetch(url, {\n        method,\n        headers: {\n          'Content-Type': 'application/json',\n          ...headers,\n        },\n        body: JSON.stringify(payload),\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        throw new Error(`Webhook returned ${response.status}: ${response.statusText}`);\n      }\n\n      return (await response.json()) as Record<string, unknown>;\n    } catch (error: unknown) {\n      clearTimeout(timeoutId);\n\n      if (error instanceof Error && error.name === 'AbortError') {\n        throw new Error(`Webhook request timed out after ${timeout}ms`);\n      }\n\n      throw error;\n    }\n  }\n\n  private parseWebhookResponse(response: Record<string, unknown>, url: string): ReviewSummary {\n    // Validate and normalize the webhook response\n    if (!response || typeof response !== 'object') {\n      return this.createErrorResult(url, new Error('Invalid webhook response format'));\n    }\n\n    const issues: ReviewIssue[] = Array.isArray(response.comments)\n      ? (response.comments as Array<Record<string, unknown>>).map(c => ({\n          file: (c.file as string) || 'unknown',\n          line: (c.line as number) || 0,\n          endLine: c.endLine as number | undefined,\n          ruleId: (c.ruleId as string) || `webhook/${this.validateCategory(c.category)}`,\n          message: (c.message as string) || '',\n          severity: this.validateSeverity(c.severity),\n          category: this.validateCategory(c.category),\n          suggestion: c.suggestion as string | undefined,\n          replacement: c.replacement as string | undefined,\n        }))\n      : [];\n\n    return {\n      issues,\n    };\n  }\n\n  private createErrorResult(url: string, error: unknown): ReviewSummary {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\n    return {\n      issues: [\n        {\n          file: 'webhook',\n          line: 0,\n          endLine: undefined,\n          ruleId: 'webhook/error',\n          message: `Webhook execution error: ${errorMessage}`,\n          severity: 'error',\n          category: 'logic',\n          suggestion: undefined,\n          replacement: undefined,\n        },\n      ],\n    };\n  }\n\n  private validateSeverity(severity: unknown): 'info' | 'warning' | 'error' | 'critical' {\n    const valid = ['info', 'warning', 'error', 'critical'];\n    return valid.includes(severity as string)\n      ? (severity as 'info' | 'warning' | 'error' | 'critical')\n      : 'info';\n  }\n\n  private validateCategory(\n    category: unknown\n  ): 'security' | 'performance' | 'style' | 'logic' | 'documentation' {\n    const valid = ['security', 'performance', 'style', 'logic', 'documentation'];\n    return valid.includes(category as string)\n      ? (category as 'security' | 'performance' | 'style' | 'logic' | 'documentation')\n      : 'logic';\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'url',\n      'body',\n      'method',\n      'headers',\n      'timeout',\n      'metadata',\n      'depends_on',\n      'on',\n      'if',\n      'group',\n      'schedule',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // HTTP provider is available if fetch is available\n    return typeof fetch !== 'undefined';\n  }\n\n  getRequirements(): string[] {\n    return [\n      'Valid HTTP URL',\n      'Body template (Liquid) for payload construction',\n      'Network access to HTTP endpoint',\n      'Optional: Dependencies for accessing their outputs in templates',\n    ];\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { logger } from '../logger';\n\n/**\n * Check provider that receives input from HTTP webhooks and makes it available to dependent checks\n */\nexport class HttpInputProvider extends CheckProvider {\n  private liquid: Liquid;\n  private webhookContext?: Map<string, unknown>;\n\n  constructor() {\n    super();\n    this.liquid = createExtendedLiquid();\n  }\n\n  /**\n   * Set webhook context for accessing webhook data\n   */\n  setWebhookContext(webhookContext: Map<string, unknown>): void {\n    this.webhookContext = webhookContext;\n  }\n\n  getName(): string {\n    return 'http_input';\n  }\n\n  getDescription(): string {\n    return 'Receive and process HTTP webhook input data for use by dependent checks';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'http_input'\n    if (cfg.type !== 'http_input') {\n      return false;\n    }\n\n    // Must have endpoint specified\n    if (typeof cfg.endpoint !== 'string' || !cfg.endpoint) {\n      return false;\n    }\n\n    // Transform is optional but must be string if provided\n    if (cfg.transform !== undefined && typeof cfg.transform !== 'string') {\n      return false;\n    }\n\n    return true;\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    _dependencyResults?: Map<string, ReviewSummary>,\n    _sessionInfo?: { parentSessionId?: string; reuseSession?: boolean }\n  ): Promise<ReviewSummary> {\n    const endpoint = config.endpoint as string;\n    const transform = config.transform as string | undefined;\n\n    // In actual implementation, this would receive data from the webhook server\n    // For now, we'll check if there's webhook data in the execution context\n    const webhookData = this.getWebhookData(endpoint);\n\n    if (!webhookData) {\n      return {\n        issues: [],\n      };\n    }\n\n    // Apply transformation if specified\n    let processedData = webhookData;\n    if (transform) {\n      try {\n        const templateContext = {\n          webhook: webhookData,\n          pr: {\n            number: prInfo.number,\n            title: prInfo.title,\n            author: prInfo.author,\n            base: prInfo.base,\n            head: prInfo.head,\n          },\n        };\n        const rendered = await this.liquid.parseAndRender(transform, templateContext);\n        processedData = JSON.parse(rendered);\n        logger.verbose(`✓ Applied webhook transform successfully`);\n      } catch (error) {\n        logger.error(\n          `✗ Failed to transform webhook data: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n        return {\n          issues: [\n            {\n              file: 'webhook_input',\n              line: 0,\n              ruleId: 'webhook_input/transform_error',\n              message: `Failed to transform webhook data: ${error instanceof Error ? error.message : 'Unknown error'}`,\n              severity: 'error',\n              category: 'logic',\n            },\n          ],\n        };\n      }\n    }\n\n    // Return the processed data as a custom field for dependent checks to access\n    // This will be available in outputs for dependent checks\n    return {\n      issues: [],\n      // Add custom data field that will be passed through\n      data: processedData,\n    } as ReviewSummary & { data: unknown };\n  }\n\n  private getWebhookData(endpoint: string): Record<string, unknown> | null {\n    // Use webhook context if available (preferred method)\n    if (this.webhookContext) {\n      return (this.webhookContext.get(endpoint) as Record<string, unknown>) || null;\n    }\n\n    // Fallback to global store for backwards compatibility\n    // This should be removed once all usages are migrated\n    const globalWebhookStore = (global as Record<string, unknown>).__visor_webhook_data as\n      | Map<string, Record<string, unknown>>\n      | undefined;\n    if (globalWebhookStore && globalWebhookStore.get) {\n      console.warn(\n        'HttpInputProvider: Using deprecated global webhook store. Please use webhook context instead.'\n      );\n      return globalWebhookStore.get(endpoint) || null;\n    }\n\n    return null;\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return ['type', 'endpoint', 'transform', 'on', 'depends_on', 'if', 'group'];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // Available if webhook server is configured and running\n    return true;\n  }\n\n  getRequirements(): string[] {\n    return [\n      'HTTP server must be configured and running',\n      'Valid endpoint path specified',\n      'Optional: Transform template for data processing',\n    ];\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { EnvironmentResolver } from '../utils/env-resolver';\n\n/**\n * Check provider that fetches data from HTTP endpoints\n */\nexport class HttpClientProvider extends CheckProvider {\n  private liquid: Liquid;\n\n  constructor() {\n    super();\n    this.liquid = createExtendedLiquid();\n  }\n\n  getName(): string {\n    return 'http_client';\n  }\n\n  getDescription(): string {\n    return 'Fetch data from HTTP endpoints for use by dependent checks';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'http_client'\n    if (cfg.type !== 'http_client') {\n      return false;\n    }\n\n    // Must have URL specified\n    if (typeof cfg.url !== 'string' || !cfg.url) {\n      return false;\n    }\n\n    // Validate URL format\n    try {\n      new URL(cfg.url as string);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    _sessionInfo?: { parentSessionId?: string; reuseSession?: boolean }\n  ): Promise<ReviewSummary> {\n    const url = config.url as string;\n    const method = (config.method as string) || 'GET';\n    const headers = (config.headers as Record<string, string>) || {};\n    const timeout = (config.timeout as number) || 30000;\n    const transform = config.transform as string | undefined;\n    const bodyTemplate = config.body as string | undefined;\n\n    try {\n      // Prepare template context for URL and body\n      const templateContext = {\n        pr: {\n          number: prInfo.number,\n          title: prInfo.title,\n          body: prInfo.body,\n          author: prInfo.author,\n          base: prInfo.base,\n          head: prInfo.head,\n          totalAdditions: prInfo.totalAdditions,\n          totalDeletions: prInfo.totalDeletions,\n        },\n        outputs: dependencyResults ? Object.fromEntries(dependencyResults) : {},\n        env: process.env,\n      };\n\n      // Render URL with template if it contains liquid syntax\n      let renderedUrl = url;\n      if (url.includes('{{') || url.includes('{%')) {\n        renderedUrl = await this.liquid.parseAndRender(url, templateContext);\n      }\n\n      // Prepare request body if provided\n      let requestBody: string | undefined;\n      if (bodyTemplate) {\n        const renderedBody = await this.liquid.parseAndRender(bodyTemplate, templateContext);\n        requestBody = renderedBody;\n      }\n\n      // Resolve environment variables in headers\n      const resolvedHeaders = EnvironmentResolver.resolveHeaders(headers);\n\n      // Fetch data from the endpoint\n      const data = await this.fetchData(renderedUrl, method, resolvedHeaders, requestBody, timeout);\n\n      // Apply transformation if specified\n      let processedData = data;\n      if (transform) {\n        try {\n          const transformContext = {\n            response: data,\n            pr: templateContext.pr,\n            outputs: templateContext.outputs,\n          };\n          const rendered = await this.liquid.parseAndRender(transform, transformContext);\n          // Try to parse as JSON if the transform result looks like JSON\n          if (rendered.trim().startsWith('{') || rendered.trim().startsWith('[')) {\n            processedData = JSON.parse(rendered);\n          } else {\n            processedData = rendered;\n          }\n        } catch (error) {\n          return {\n            issues: [\n              {\n                file: 'http_client',\n                line: 0,\n                ruleId: 'http_client/transform_error',\n                message: `Failed to transform response data: ${error instanceof Error ? error.message : 'Unknown error'}`,\n                severity: 'error',\n                category: 'logic',\n              },\n            ],\n          };\n        }\n      }\n\n      // Return the fetched data as a custom field for dependent checks to access\n      return {\n        issues: [],\n        // Add custom data field that will be passed through to dependent checks\n        data: processedData,\n      } as ReviewSummary & { data: unknown };\n    } catch (error) {\n      return {\n        issues: [\n          {\n            file: 'http_client',\n            line: 0,\n            ruleId: 'http_client/fetch_error',\n            message: `Failed to fetch from ${url}: ${error instanceof Error ? error.message : 'Unknown error'}`,\n            severity: 'error',\n            category: 'logic',\n          },\n        ],\n      };\n    }\n  }\n\n  private async fetchData(\n    url: string,\n    method: string,\n    headers: Record<string, string>,\n    body?: string,\n    timeout: number = 30000\n  ): Promise<unknown> {\n    // Check if fetch is available (Node 18+)\n    if (typeof fetch === 'undefined') {\n      throw new Error('HTTP client provider requires Node.js 18+ or node-fetch package');\n    }\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n    try {\n      const requestOptions: RequestInit = {\n        method,\n        headers: {\n          ...headers,\n        },\n        signal: controller.signal,\n      };\n\n      // Add body for non-GET requests\n      if (method !== 'GET' && body) {\n        requestOptions.body = body;\n        // Set Content-Type if not already set\n        if (!headers['Content-Type'] && !headers['content-type']) {\n          requestOptions.headers = {\n            ...requestOptions.headers,\n            'Content-Type': 'application/json',\n          };\n        }\n      }\n\n      const response = await fetch(url, requestOptions);\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      // Try to parse as JSON first\n      const contentType = response.headers.get('content-type');\n      if (contentType && contentType.includes('application/json')) {\n        return await response.json();\n      }\n\n      // Otherwise return as text\n      const text = await response.text();\n\n      // Try to parse as JSON if it looks like JSON\n      if (text.trim().startsWith('{') || text.trim().startsWith('[')) {\n        try {\n          return JSON.parse(text);\n        } catch {\n          // Not JSON, return as text\n          return text;\n        }\n      }\n\n      return text;\n    } catch (error: unknown) {\n      clearTimeout(timeoutId);\n\n      if (error instanceof Error && error.name === 'AbortError') {\n        throw new Error(`Request timed out after ${timeout}ms`);\n      }\n\n      throw error;\n    }\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'url',\n      'method',\n      'headers',\n      'body',\n      'transform',\n      'timeout',\n      'depends_on',\n      'on',\n      'if',\n      'group',\n      'schedule',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // HTTP client is available if fetch is available\n    return typeof fetch !== 'undefined';\n  }\n\n  getRequirements(): string[] {\n    return [\n      'Valid HTTP/HTTPS URL to fetch from',\n      'Network access to the endpoint',\n      'Optional: Transform template for processing response data',\n      'Optional: Body template for POST/PUT requests',\n    ];\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\n\n/**\n * No-operation check provider that doesn't perform any analysis.\n *\n * This provider is designed for command orchestration - it allows creating\n * checks that exist purely to trigger other checks through dependencies.\n *\n * Example use case: A \"/review\" command that triggers multiple analysis checks\n * without performing any analysis itself.\n */\nexport class NoopCheckProvider extends CheckProvider {\n  getName(): string {\n    return 'noop';\n  }\n\n  getDescription(): string {\n    return 'No-operation provider for command orchestration and dependency triggering';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'noop'\n    if (cfg.type !== 'noop') {\n      return false;\n    }\n\n    return true;\n  }\n\n  async execute(\n    _prInfo: PRInfo,\n    _config: CheckProviderConfig,\n    _dependencyResults?: Map<string, ReviewSummary>,\n    _sessionInfo?: { parentSessionId?: string; reuseSession?: boolean }\n  ): Promise<ReviewSummary> {\n    // Noop provider doesn't perform any analysis\n    // It exists purely for command orchestration and dependency triggering\n    return {\n      issues: [],\n    };\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return ['type', 'command', 'depends_on', 'on', 'if', 'group'];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // Noop provider is always available\n    return true;\n  }\n\n  getRequirements(): string[] {\n    return [\n      'No external dependencies required',\n      'Used for command orchestration and dependency triggering',\n    ];\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { logger } from '../logger';\n\n/**\n * Log levels supported by the log provider\n */\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\n/**\n * Check provider that outputs debugging and logging information.\n * Useful for troubleshooting check workflows and understanding execution flow.\n */\nexport class LogCheckProvider extends CheckProvider {\n  private liquid: Liquid;\n\n  constructor() {\n    super();\n    this.liquid = createExtendedLiquid({\n      strictVariables: false,\n      strictFilters: false,\n    });\n  }\n\n  getName(): string {\n    return 'log';\n  }\n\n  getDescription(): string {\n    return 'Output debugging and logging information for troubleshooting check workflows';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'log'\n    if (cfg.type !== 'log') {\n      return false;\n    }\n\n    // Message is required\n    if (!cfg.message || typeof cfg.message !== 'string') {\n      return false;\n    }\n\n    // Validate log level if provided\n    if (cfg.level && !['debug', 'info', 'warn', 'error'].includes(cfg.level as string)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    _sessionInfo?: { parentSessionId?: string; reuseSession?: boolean }\n  ): Promise<ReviewSummary> {\n    const message = config.message as string;\n    const level = (config.level as LogLevel) || 'info';\n    const includePrContext = config.include_pr_context !== false;\n    const includeDependencies = config.include_dependencies !== false;\n    const includeMetadata = config.include_metadata !== false;\n\n    // Prepare template context\n    const templateContext = this.buildTemplateContext(\n      prInfo,\n      dependencyResults,\n      includePrContext,\n      includeDependencies,\n      includeMetadata,\n      config.__outputHistory as Map<string, unknown[]> | undefined\n    );\n\n    // Render the log message template\n    const renderedMessage = await this.liquid.parseAndRender(message, templateContext);\n\n    // Build the log output\n    const logOutput = this.formatLogOutput(\n      level,\n      renderedMessage,\n      templateContext,\n      includePrContext,\n      includeDependencies,\n      includeMetadata\n    );\n\n    // Route through centralized logger to keep stdout clean in JSON/SARIF\n    if (level === 'error') logger.error(logOutput);\n    else if (level === 'warn') logger.warn(logOutput);\n    else if (level === 'debug') logger.debug(logOutput);\n    else logger.info(logOutput);\n\n    // Return with the log content as custom data for dependent checks\n    return {\n      issues: [],\n      // Add log output as custom field\n      logOutput,\n    } as ReviewSummary & { logOutput: string };\n  }\n\n  private buildTemplateContext(\n    prInfo: PRInfo,\n    dependencyResults?: Map<string, ReviewSummary>,\n    _includePrContext: boolean = true,\n    _includeDependencies: boolean = true,\n    includeMetadata: boolean = true,\n    outputHistory?: Map<string, unknown[]>\n  ): Record<string, unknown> {\n    const context: Record<string, unknown> = {};\n\n    // Always provide pr context for template rendering\n    context.pr = {\n      number: prInfo.number,\n      title: prInfo.title,\n      body: prInfo.body,\n      author: prInfo.author,\n      base: prInfo.base,\n      head: prInfo.head,\n      totalAdditions: prInfo.totalAdditions,\n      totalDeletions: prInfo.totalDeletions,\n      files: prInfo.files.map(f => ({\n        filename: f.filename,\n        status: f.status,\n        additions: f.additions,\n        deletions: f.deletions,\n        changes: f.changes,\n      })),\n    };\n\n    // Add convenience data\n    context.filenames = prInfo.files.map(f => f.filename);\n    context.fileCount = prInfo.files.length;\n\n    // Always provide dependency data for template rendering\n    if (dependencyResults) {\n      const dependencies: Record<string, unknown> = {};\n      const outputs: Record<string, unknown> = {};\n      const outputsRaw: Record<string, unknown> = {};\n      const history: Record<string, unknown[]> = {};\n      context.dependencyCount = dependencyResults.size;\n\n      for (const [checkName, result] of dependencyResults.entries()) {\n        if (typeof checkName !== 'string') continue;\n        dependencies[checkName] = {\n          issueCount: result.issues?.length || 0,\n          suggestionCount: 0,\n          issues: result.issues || [],\n        };\n\n        // Add outputs namespace for accessing dependency results directly\n        const summary = result as import('../reviewer').ReviewSummary & { output?: unknown };\n        if (typeof checkName === 'string' && checkName.endsWith('-raw')) {\n          const name = checkName.slice(0, -4);\n          outputsRaw[name] = summary.output !== undefined ? summary.output : summary;\n        } else {\n          outputs[checkName] = summary.output !== undefined ? summary.output : summary;\n        }\n      }\n\n      // Add history for each check if available\n      if (outputHistory) {\n        for (const [checkName, historyArray] of outputHistory) {\n          history[checkName] = historyArray;\n        }\n      }\n\n      // Attach history to the outputs object\n      (outputs as any).history = history;\n\n      context.dependencies = dependencies;\n      context.outputs = outputs;\n      // Alias: outputs_history mirrors outputs.history for consistency\n      (context as any).outputs_history = history;\n      // New: outputs_raw exposes aggregate values (e.g., arrays) for forEach parents\n      (context as any).outputs_raw = outputsRaw;\n    }\n\n    if (includeMetadata) {\n      context.metadata = {\n        timestamp: new Date().toISOString(),\n        executionTime: Date.now(),\n        nodeVersion: process.version,\n        platform: process.platform,\n        workingDirectory: process.cwd(),\n      };\n    }\n\n    return context;\n  }\n\n  private formatLogOutput(\n    level: LogLevel,\n    message: string,\n    templateContext: Record<string, unknown>,\n    includePrContext: boolean,\n    includeDependencies: boolean,\n    includeMetadata: boolean\n  ): string {\n    const sections: string[] = [];\n\n    // Log level and message\n    const levelEmoji = this.getLevelEmoji(level);\n    sections.push(`${levelEmoji} **${level.toUpperCase()}**: ${message}`);\n\n    // PR context section\n    if (includePrContext && templateContext.pr) {\n      const pr = templateContext.pr as Record<string, unknown>;\n      sections.push('');\n      sections.push('### PR Context');\n      sections.push(`- **PR #${pr.number}**: ${pr.title}`);\n      sections.push(`- **Author**: ${pr.author}`);\n      sections.push(`- **Base**: ${pr.base} → **Head**: ${pr.head}`);\n      sections.push(`- **Changes**: +${pr.totalAdditions} -${pr.totalDeletions}`);\n      sections.push(`- **Files Modified**: ${templateContext.fileCount}`);\n    }\n\n    // Dependencies section\n    if (includeDependencies && templateContext.dependencies) {\n      const deps = templateContext.dependencies as Record<string, Record<string, unknown>>;\n      sections.push('');\n      sections.push('### Dependency Results');\n\n      if (Object.keys(deps).length === 0) {\n        sections.push('- No dependency results available');\n      } else {\n        for (const [checkName, result] of Object.entries(deps)) {\n          sections.push(\n            `- **${checkName}**: ${result.issueCount} issues, ${result.suggestionCount} suggestions`\n          );\n        }\n      }\n    }\n\n    // Metadata section\n    if (includeMetadata && templateContext.metadata) {\n      const meta = templateContext.metadata as Record<string, unknown>;\n      sections.push('');\n      sections.push('### Execution Metadata');\n      sections.push(`- **Timestamp**: ${meta.timestamp}`);\n      sections.push(`- **Node Version**: ${meta.nodeVersion}`);\n      sections.push(`- **Platform**: ${meta.platform}`);\n      sections.push(`- **Working Directory**: ${meta.workingDirectory}`);\n    }\n\n    return sections.join('\\n');\n  }\n\n  private getLevelEmoji(level: LogLevel): string {\n    switch (level) {\n      case 'debug':\n        return '🐛';\n      case 'info':\n        return 'ℹ️';\n      case 'warn':\n        return '⚠️';\n      case 'error':\n        return '❌';\n      default:\n        return 'ℹ️';\n    }\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'message',\n      'level',\n      'include_pr_context',\n      'include_dependencies',\n      'include_metadata',\n      'group',\n      'command',\n      'depends_on',\n      'on',\n      'if',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // Log provider is always available\n    return true;\n  }\n\n  getRequirements(): string[] {\n    return [\n      'No external dependencies required',\n      'Used for debugging and logging check execution flow',\n    ];\n  }\n}\n","import Sandbox from '@nyariv/sandboxjs';\n\n/**\n * Centralized helpers for creating and using SandboxJS instances consistently\n * across providers. The goal is to have one place to define allowed globals\n * and prototype whitelists, and to offer a small helper to inject a `log`\n * utility inside user-provided JS snippets.\n */\n\nexport interface CompileOptions {\n  injectLog?: boolean;\n  logPrefix?: string;\n  /** When true, wrap the code in a function and `return` its result */\n  wrapFunction?: boolean;\n}\n\n/**\n * Create a hardened Sandbox with a consistent set of globals and prototype\n * whitelists. This is a superset of the sets previously used by individual\n * providers, kept intentionally minimal and side‑effect free.\n */\nexport function createSecureSandbox(): Sandbox {\n  const globals = {\n    ...Sandbox.SAFE_GLOBALS,\n    Math,\n    JSON,\n    // Provide console with limited surface. Calls are harmless in CI logs and\n    // help with debugging value_js / transform_js expressions.\n    console: {\n      log: console.log,\n      warn: console.warn,\n      error: console.error,\n    },\n  } as Record<string, unknown>;\n\n  const prototypeWhitelist = new Map(Sandbox.SAFE_PROTOTYPES);\n\n  // Arrays — union of methods used around the codebase\n  const arrayMethods = new Set<string>([\n    'some',\n    'every',\n    'filter',\n    'map',\n    'reduce',\n    'find',\n    'includes',\n    'indexOf',\n    'length',\n    'slice',\n    'concat',\n    'join',\n    'push',\n    'pop',\n    'shift',\n    'unshift',\n    'sort',\n    'reverse',\n    'flat',\n    'flatMap',\n  ]);\n  prototypeWhitelist.set(Array.prototype, arrayMethods);\n\n  // Strings — allow common, safe manipulation helpers\n  const stringMethods = new Set<string>([\n    'toLowerCase',\n    'toUpperCase',\n    'includes',\n    'indexOf',\n    'startsWith',\n    'endsWith',\n    'slice',\n    'substring',\n    'length',\n    'trim',\n    'split',\n    'replace',\n    'match',\n    'padStart',\n    'padEnd',\n  ]);\n  prototypeWhitelist.set(String.prototype, stringMethods);\n\n  // Objects — keep to basic safe operations\n  const objectMethods = new Set<string>([\n    'hasOwnProperty',\n    'toString',\n    'valueOf',\n    'keys',\n    'values',\n  ]);\n  prototypeWhitelist.set(Object.prototype, objectMethods);\n\n  return new Sandbox({ globals, prototypeWhitelist });\n}\n\n/**\n * Compile and execute user-provided JS inside the sandbox with optional\n * helper injection. By default, code is wrapped in a function to keep the\n * global scope clean.\n */\nexport function compileAndRun<T = unknown>(\n  sandbox: Sandbox,\n  userCode: string,\n  scope: Record<string, unknown>,\n  opts: CompileOptions = { injectLog: true, wrapFunction: true, logPrefix: '[sandbox]' }\n): T {\n  const inject = opts?.injectLog === true;\n  let safePrefix = String(opts?.logPrefix ?? '[sandbox]');\n  // Sanitize prefix aggressively: drop control chars and risky tokens, limit length\n  safePrefix = safePrefix\n    .replace(/[\\r\\n\\t\\0]/g, '')\n    .replace(/[`$\\\\]/g, '') // strip backticks, dollar (template) and backslashes\n    .replace(/\\$\\{/g, '') // remove template openings if present\n    .slice(0, 64);\n  // Build a safe header without string concatenation inside user code\n  const header = inject\n    ? `const __lp = ${JSON.stringify(safePrefix)}; const log = (...a) => { try { console.log(__lp, ...a); } catch {} };\\n`\n    : '';\n  const body = opts.wrapFunction\n    ? `const __fn = () => {\\n${userCode}\\n};\\nreturn __fn();\\n`\n    : `${userCode}`;\n  const code = `${header}${body}`;\n  let exec: ReturnType<typeof sandbox.compile>;\n  try {\n    exec = sandbox.compile(code);\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    throw new Error(`sandbox_compile_error: ${msg}`);\n  }\n\n  let out: any;\n  try {\n    out = exec(scope);\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    throw new Error(`sandbox_execution_error: ${msg}`);\n  }\n\n  if (out && typeof out.run === 'function') {\n    try {\n      return out.run();\n    } catch (e) {\n      const msg = e instanceof Error ? e.message : String(e);\n      throw new Error(`sandbox_runner_error: ${msg}`);\n    }\n  }\n  return out as T;\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport Sandbox from '@nyariv/sandboxjs';\nimport { createSecureSandbox, compileAndRun } from '../utils/sandbox';\nimport { createExtendedLiquid } from '../liquid-extensions';\n\nexport class GitHubOpsProvider extends CheckProvider {\n  private sandbox?: Sandbox;\n\n  getName(): string {\n    return 'github';\n  }\n\n  getDescription(): string {\n    return 'Native GitHub operations (labels, comments, reviewers) executed via Octokit';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') return false;\n    const cfg = config as CheckProviderConfig & { op?: string };\n    return typeof cfg.op === 'string' && cfg.op.length > 0;\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return ['op', 'values', 'value', 'value_js'];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // Available when running in GitHub context or when a token is provided\n    return Boolean(\n      process.env.GITHUB_TOKEN || process.env['INPUT_GITHUB-TOKEN'] || process.env.GITHUB_REPOSITORY\n    );\n  }\n\n  getRequirements(): string[] {\n    return ['GITHUB_TOKEN or INPUT_GITHUB-TOKEN', 'GITHUB_REPOSITORY'];\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>\n  ): Promise<ReviewSummary> {\n    const cfg = config as CheckProviderConfig & {\n      op: string;\n      values?: string[] | string;\n      value?: string;\n      value_js?: string;\n    };\n\n    // IMPORTANT: Always prefer authenticated octokit from event context (GitHub App or token)\n    // This ensures proper bot identity in reactions, labels, and comments\n    const octokit: import('@octokit/rest').Octokit | undefined = config.eventContext?.octokit as\n      | import('@octokit/rest').Octokit\n      | undefined;\n\n    if (!octokit) {\n      return {\n        issues: [\n          {\n            file: 'system',\n            line: 0,\n            ruleId: 'github/missing_octokit',\n            message:\n              'No authenticated Octokit instance available in event context. GitHub operations require proper authentication context.',\n            severity: 'error',\n            category: 'logic',\n          },\n        ],\n      };\n    }\n\n    const repoEnv = process.env.GITHUB_REPOSITORY || '';\n    const [owner, repo] = repoEnv.split('/') as [string, string];\n    if (!owner || !repo || !prInfo?.number) {\n      return {\n        issues: [\n          {\n            file: 'system',\n            line: 0,\n            ruleId: 'github/missing_context',\n            message: 'Missing owner/repo or PR number; GitHub operations require Action context',\n            severity: 'error',\n            category: 'logic',\n          },\n        ],\n      };\n    }\n\n    // Build values list (allow string or array), render Liquid templates if present, and normalize\n    let valuesRaw: string[] = [];\n    if (Array.isArray(cfg.values)) valuesRaw = (cfg.values as unknown[]).map(v => String(v));\n    else if (typeof cfg.values === 'string') valuesRaw = [cfg.values];\n    else if (typeof cfg.value === 'string') valuesRaw = [cfg.value];\n\n    // Liquid render helper for values\n    const renderValues = async (arr: string[]): Promise<string[]> => {\n      if (!arr || arr.length === 0) return [];\n      const liq = createExtendedLiquid({\n        cache: false,\n        strictFilters: false,\n        strictVariables: false,\n      });\n      const outputs: Record<string, unknown> = {};\n      if (dependencyResults) {\n        for (const [name, result] of dependencyResults.entries()) {\n          const summary = result as ReviewSummary & { output?: unknown };\n          outputs[name] = summary.output !== undefined ? summary.output : summary;\n        }\n      }\n      const ctx = {\n        pr: {\n          number: prInfo.number,\n          title: prInfo.title,\n          author: prInfo.author,\n          branch: prInfo.head,\n          base: prInfo.base,\n          authorAssociation: prInfo.authorAssociation,\n        },\n        outputs,\n      };\n      const out: string[] = [];\n      for (const item of arr) {\n        if (typeof item === 'string' && (item.includes('{{') || item.includes('{%'))) {\n          try {\n            const rendered = await liq.parseAndRender(item, ctx);\n            out.push(rendered);\n          } catch (e) {\n            // If Liquid fails, surface as a provider error\n            const msg = e instanceof Error ? e.message : String(e);\n            return Promise.reject({\n              issues: [\n                {\n                  file: 'system',\n                  line: 0,\n                  ruleId: 'github/liquid_render_error',\n                  message: `Failed to render template: ${msg}`,\n                  severity: 'error',\n                  category: 'logic',\n                },\n              ],\n            } as ReviewSummary);\n          }\n        } else {\n          out.push(String(item));\n        }\n      }\n      return out;\n    };\n\n    let values: string[] = await renderValues(valuesRaw);\n\n    if (cfg.value_js && cfg.value_js.trim()) {\n      try {\n        // Evaluate user-provided value_js in a restricted sandbox (no process/global exposure)\n        const sandbox = this.getSecureSandbox();\n\n        // Build dependency outputs map (mirrors Liquid context construction)\n        const depOutputs: Record<string, unknown> = {};\n        if (dependencyResults) {\n          for (const [name, result] of dependencyResults.entries()) {\n            const summary = result as ReviewSummary & { output?: unknown };\n            depOutputs[name] = summary.output !== undefined ? summary.output : summary;\n          }\n        }\n\n        const res = compileAndRun<unknown>(\n          sandbox,\n          cfg.value_js,\n          { pr: prInfo, values, outputs: depOutputs },\n          { injectLog: true, wrapFunction: true, logPrefix: '[github:value_js]' }\n        );\n        if (typeof res === 'string') values = [res];\n        else if (Array.isArray(res)) values = (res as unknown[]).map(v => String(v));\n      } catch (e) {\n        const msg = e instanceof Error ? e.message : String(e);\n        return {\n          issues: [\n            {\n              file: 'system',\n              line: 0,\n              ruleId: 'github/value_js_error',\n              message: `value_js evaluation failed: ${msg}`,\n              severity: 'error',\n              category: 'logic',\n            },\n          ],\n        };\n      }\n    }\n\n    // Trim, drop empty, and de-duplicate values regardless of source\n    values = values.map(v => v.trim()).filter(v => v.length > 0);\n    values = Array.from(new Set(values));\n\n    try {\n      switch (cfg.op) {\n        case 'labels.add': {\n          if (values.length === 0) break; // no-op if nothing to add\n          await octokit.rest.issues.addLabels({\n            owner,\n            repo,\n            issue_number: prInfo.number,\n            labels: values,\n          });\n          break;\n        }\n        case 'labels.remove': {\n          for (const l of values) {\n            await octokit.rest.issues.removeLabel({\n              owner,\n              repo,\n              issue_number: prInfo.number,\n              name: l,\n            });\n          }\n          break;\n        }\n        case 'comment.create': {\n          const body = values.join('\\n').trim();\n          if (body)\n            await octokit.rest.issues.createComment({\n              owner,\n              repo,\n              issue_number: prInfo.number,\n              body,\n            });\n          break;\n        }\n        default:\n          return {\n            issues: [\n              {\n                file: 'system',\n                line: 0,\n                ruleId: 'github/unsupported_op',\n                message: `Unsupported GitHub op: ${cfg.op}`,\n                severity: 'error',\n                category: 'logic',\n              },\n            ],\n          };\n      }\n\n      return { issues: [] };\n    } catch (e) {\n      const msg = e instanceof Error ? e.message : String(e);\n      return {\n        issues: [\n          {\n            file: 'system',\n            line: 0,\n            ruleId: 'github/op_failed',\n            message: `GitHub operation failed (${cfg.op}): ${msg}`,\n            severity: 'error',\n            category: 'logic',\n          },\n        ],\n      };\n    }\n  }\n\n  /**\n   * Create a secure sandbox for evaluating small expressions without access to process/env\n   */\n  private getSecureSandbox(): Sandbox {\n    if (this.sandbox) return this.sandbox;\n    this.sandbox = createSecureSandbox();\n    return this.sandbox;\n  }\n}\n","/**\n * Type definitions for Claude Code SDK and MCP SDK\n * These are placeholder types for when the packages aren't installed\n */\n\n// Claude Code SDK types\nexport interface ClaudeCodeQuery {\n  query: string;\n  tools?: Array<{\n    name: string;\n    [key: string]: unknown;\n  }>;\n  subagent?: string;\n  maxTurns?: number;\n  systemPrompt?: string;\n  sessionId?: string;\n}\n\nexport interface ClaudeCodeResponse {\n  content: string;\n  usage?: {\n    input_tokens: number;\n    output_tokens: number;\n  };\n  turn_count?: number;\n  session_id?: string;\n}\n\nexport interface ClaudeCodeClient {\n  query(options: ClaudeCodeQuery): Promise<ClaudeCodeResponse>;\n}\n\n// MCP Server configuration interface\nexport interface McpServerConfig {\n  command: string;\n  args?: string[];\n  env?: Record<string, string>;\n}\n\n// MCP Tool interface\nexport interface McpTool {\n  name: string;\n  description?: string;\n  inputSchema?: Record<string, unknown>;\n  handler?: (args: Record<string, unknown>) => Promise<unknown>;\n}\n\n// MCP Server interface\nexport interface McpServer {\n  name: string;\n  command?: string;\n  args?: string[];\n  env?: Record<string, string>;\n  tools?: McpTool[];\n}\n\n// MCP Server Instance interface\nexport interface McpServerInstance {\n  name: string;\n  listTools(): Promise<McpTool[]>;\n  callTool(name: string, args: Record<string, unknown>): Promise<unknown>;\n  close(): Promise<void>;\n}\n\n// Claude Code configuration interface\nexport interface ClaudeCodeConfig {\n  allowedTools?: string[];\n  maxTurns?: number;\n  systemPrompt?: string;\n  mcpServers?: Record<string, McpServerConfig>;\n  subagent?: string;\n  hooks?: {\n    onStart?: string;\n    onEnd?: string;\n    onError?: string;\n  };\n}\n\n/**\n * Utility function to safely import optional dependencies\n */\nexport async function safeImport<T>(moduleName: string): Promise<T | null> {\n  try {\n    return await import(moduleName);\n  } catch {\n    return null;\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { EnvironmentResolver } from '../utils/env-resolver';\nimport { IssueFilter } from '../issue-filter';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport {\n  ClaudeCodeQuery,\n  ClaudeCodeResponse,\n  ClaudeCodeConfig,\n  ClaudeCodeClient,\n  safeImport,\n} from './claude-code-types';\n\ntype ClaudeCodeConstructor = new (options: { apiKey: string }) => ClaudeCodeClient;\n\nfunction isClaudeCodeConstructor(value: unknown): value is ClaudeCodeConstructor {\n  return typeof value === 'function';\n}\n\n/**\n * Error thrown when Claude Code SDK is not installed\n */\nexport class ClaudeCodeSDKNotInstalledError extends Error {\n  constructor() {\n    super(\n      'Claude Code SDK is not installed. Install with: npm install @anthropic/claude-code-sdk @modelcontextprotocol/sdk'\n    );\n    this.name = 'ClaudeCodeSDKNotInstalledError';\n  }\n}\n\n/**\n * Error thrown when Claude Code API key is not configured\n */\nexport class ClaudeCodeAPIKeyMissingError extends Error {\n  constructor() {\n    super(\n      'No API key found for Claude Code provider. Set CLAUDE_CODE_API_KEY or ANTHROPIC_API_KEY environment variable.'\n    );\n    this.name = 'ClaudeCodeAPIKeyMissingError';\n  }\n}\n\n/**\n * Claude Code check provider using the Claude Code TypeScript SDK\n * Supports MCP tools and streaming responses\n */\nexport class ClaudeCodeCheckProvider extends CheckProvider {\n  private liquidEngine: Liquid;\n  private claudeCodeClient: ClaudeCodeClient | null = null;\n\n  constructor() {\n    super();\n    this.liquidEngine = createExtendedLiquid();\n  }\n\n  getName(): string {\n    return 'claude-code';\n  }\n\n  getDescription(): string {\n    return 'AI-powered code review using Claude Code with MCP tools support';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'claude-code'\n    if (cfg.type !== 'claude-code') {\n      return false;\n    }\n\n    // Check for prompt\n    if (!cfg.prompt || typeof cfg.prompt !== 'string') {\n      return false;\n    }\n\n    // Validate Claude Code specific configuration\n    if (cfg.claude_code) {\n      const claudeCodeConfig = cfg.claude_code as ClaudeCodeConfig;\n\n      // Validate allowedTools if present\n      if (claudeCodeConfig.allowedTools && !Array.isArray(claudeCodeConfig.allowedTools)) {\n        return false;\n      }\n\n      // Validate maxTurns if present\n      if (claudeCodeConfig.maxTurns && typeof claudeCodeConfig.maxTurns !== 'number') {\n        return false;\n      }\n\n      // Validate systemPrompt if present\n      if (claudeCodeConfig.systemPrompt && typeof claudeCodeConfig.systemPrompt !== 'string') {\n        return false;\n      }\n\n      // Validate mcpServers if present\n      if (claudeCodeConfig.mcpServers) {\n        if (typeof claudeCodeConfig.mcpServers !== 'object') {\n          return false;\n        }\n\n        for (const serverConfig of Object.values(claudeCodeConfig.mcpServers)) {\n          if (!serverConfig.command || typeof serverConfig.command !== 'string') {\n            return false;\n          }\n          if (serverConfig.args && !Array.isArray(serverConfig.args)) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Initialize Claude Code SDK client\n   */\n  private async initializeClaudeCodeClient(): Promise<ClaudeCodeClient> {\n    if (this.claudeCodeClient) {\n      return this.claudeCodeClient;\n    }\n\n    // Use safe import to avoid TypeScript compilation errors\n    const claudeCodeModule = await safeImport<{\n      ClaudeCode?: unknown;\n      default?: { ClaudeCode?: unknown };\n    }>('@anthropic/claude-code-sdk');\n\n    if (!claudeCodeModule) {\n      throw new ClaudeCodeSDKNotInstalledError();\n    }\n\n    const ClaudeCodeCtor = claudeCodeModule.ClaudeCode || claudeCodeModule.default?.ClaudeCode;\n\n    if (!isClaudeCodeConstructor(ClaudeCodeCtor)) {\n      throw new Error('ClaudeCode class not found in @anthropic/claude-code-sdk');\n    }\n\n    // Initialize with API key from environment\n    const apiKey = process.env.CLAUDE_CODE_API_KEY || process.env.ANTHROPIC_API_KEY;\n    if (!apiKey) {\n      throw new ClaudeCodeAPIKeyMissingError();\n    }\n\n    try {\n      const client = new ClaudeCodeCtor({\n        apiKey,\n      }) as ClaudeCodeClient;\n\n      this.claudeCodeClient = client;\n      return client;\n    } catch (error) {\n      throw new Error(\n        `Failed to initialize Claude Code SDK: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Group files by their file extension for template context\n   */\n  private groupFilesByExtension(\n    files: import('../pr-analyzer').PRFile[]\n  ): Record<string, import('../pr-analyzer').PRFile[]> {\n    const grouped: Record<string, import('../pr-analyzer').PRFile[]> = {};\n\n    files.forEach(file => {\n      const parts = file.filename.split('.');\n      const ext = parts.length > 1 ? parts.pop()?.toLowerCase() || 'noext' : 'noext';\n      if (!grouped[ext]) {\n        grouped[ext] = [];\n      }\n      grouped[ext].push(file);\n    });\n\n    return grouped;\n  }\n\n  /**\n   * Process prompt configuration to resolve final prompt string\n   */\n  private async processPrompt(\n    promptConfig: string,\n    prInfo: PRInfo,\n    eventContext?: Record<string, unknown>,\n    dependencyResults?: Map<string, ReviewSummary>\n  ): Promise<string> {\n    let promptContent: string;\n\n    // Auto-detect if it's a file path or inline content\n    if (await this.isFilePath(promptConfig)) {\n      promptContent = await this.loadPromptFromFile(promptConfig);\n    } else {\n      promptContent = promptConfig;\n    }\n\n    // Process Liquid templates in the prompt\n    return await this.renderPromptTemplate(promptContent, prInfo, eventContext, dependencyResults);\n  }\n\n  /**\n   * Detect if a string is likely a file path and if the file exists\n   */\n  private async isFilePath(str: string): Promise<boolean> {\n    // Quick checks to exclude obvious non-file-path content\n    if (!str || str.trim() !== str || str.length > 512) {\n      return false;\n    }\n\n    // Exclude strings that are clearly content (contain common content indicators)\n    if (\n      /\\s{2,}/.test(str) || // Multiple consecutive spaces\n      /\\n/.test(str) || // Contains newlines\n      /^(please|analyze|review|check|find|identify|look|search)/i.test(str.trim()) || // Starts with command words\n      str.split(' ').length > 8 // Too many words for a typical file path\n    ) {\n      return false;\n    }\n\n    // For strings with path separators, be more lenient about common words\n    if (!/[\\/\\\\]/.test(str)) {\n      // Only apply strict English word filter to non-path strings\n      if (/\\b(the|and|or|but|for|with|by|from|in|on|at|as)\\b/i.test(str)) {\n        return false;\n      }\n    }\n\n    // Positive indicators for file paths\n    const hasFileExtension = /\\.[a-zA-Z0-9]{1,10}$/i.test(str);\n    const hasPathSeparators = /[\\/\\\\]/.test(str);\n    const isRelativePath = /^\\.{1,2}\\//.test(str);\n    const isAbsolutePath = path.isAbsolute(str);\n    const hasTypicalFileChars = /^[a-zA-Z0-9._\\-\\/\\\\:~]+$/.test(str);\n\n    // Must have at least one strong indicator\n    if (!(hasFileExtension || isRelativePath || isAbsolutePath || hasPathSeparators)) {\n      return false;\n    }\n\n    // Must contain only typical file path characters\n    if (!hasTypicalFileChars) {\n      return false;\n    }\n\n    // Additional validation for suspected file paths\n    try {\n      // Try to resolve and check if file exists\n      let resolvedPath: string;\n\n      if (path.isAbsolute(str)) {\n        resolvedPath = path.normalize(str);\n      } else {\n        // Resolve relative to current working directory\n        resolvedPath = path.resolve(process.cwd(), str);\n      }\n\n      // Check if file exists\n      try {\n        const stat = await fs.stat(resolvedPath);\n        return stat.isFile();\n      } catch {\n        // File doesn't exist, but might still be a valid file path format\n        return hasFileExtension && (isRelativePath || isAbsolutePath || hasPathSeparators);\n      }\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Load prompt content from file with security validation\n   */\n  private async loadPromptFromFile(promptPath: string): Promise<string> {\n    // Enforce .liquid file extension for all prompt files\n    if (!promptPath.endsWith('.liquid')) {\n      throw new Error('Prompt file must have .liquid extension');\n    }\n\n    let resolvedPath: string;\n\n    if (path.isAbsolute(promptPath)) {\n      // Absolute path - use as-is\n      resolvedPath = promptPath;\n    } else {\n      // Relative path - resolve relative to current working directory\n      resolvedPath = path.resolve(process.cwd(), promptPath);\n    }\n\n    // Security: For relative paths, ensure they don't escape the current directory\n    if (!path.isAbsolute(promptPath)) {\n      const normalizedPath = path.normalize(resolvedPath);\n      const currentDir = path.resolve(process.cwd());\n      if (!normalizedPath.startsWith(currentDir)) {\n        throw new Error('Invalid prompt file path: path traversal detected');\n      }\n    }\n\n    // Security: Check for obvious path traversal patterns\n    if (promptPath.includes('../..')) {\n      throw new Error('Invalid prompt file path: path traversal detected');\n    }\n\n    try {\n      const promptContent = await fs.readFile(resolvedPath, 'utf-8');\n      return promptContent;\n    } catch (error) {\n      throw new Error(\n        `Failed to load prompt from ${resolvedPath}: ${\n          error instanceof Error ? error.message : 'Unknown error'\n        }`\n      );\n    }\n  }\n\n  /**\n   * Render Liquid template in prompt with comprehensive context\n   */\n  private async renderPromptTemplate(\n    promptContent: string,\n    prInfo: PRInfo,\n    eventContext?: Record<string, unknown>,\n    dependencyResults?: Map<string, ReviewSummary>\n  ): Promise<string> {\n    // Create comprehensive template context with PR and event information\n    const templateContext = {\n      // PR Information\n      pr: {\n        number: prInfo.number,\n        title: prInfo.title,\n        body: prInfo.body,\n        author: prInfo.author,\n        baseBranch: prInfo.base,\n        headBranch: prInfo.head,\n        isIncremental: prInfo.isIncremental,\n        filesChanged: prInfo.files?.map(f => f.filename) || [],\n        totalAdditions: prInfo.files?.reduce((sum, f) => sum + f.additions, 0) || 0,\n        totalDeletions: prInfo.files?.reduce((sum, f) => sum + f.deletions, 0) || 0,\n        totalChanges: prInfo.files?.reduce((sum, f) => sum + f.changes, 0) || 0,\n        base: prInfo.base,\n        head: prInfo.head,\n      },\n\n      // File Details\n      files: prInfo.files || [],\n      description: prInfo.body || '',\n\n      // GitHub Event Context\n      event: eventContext\n        ? {\n            name: eventContext.event_name || 'unknown',\n            action: eventContext.action,\n            isPullRequest: !prInfo.isIssue,\n\n            // Repository Info\n            repository: eventContext.repository\n              ? {\n                  owner: (eventContext.repository as { owner?: { login?: string } })?.owner?.login,\n                  name: (eventContext.repository as { name?: string })?.name,\n                  fullName: eventContext.repository\n                    ? `${(eventContext.repository as { owner?: { login?: string } })?.owner?.login}/${(eventContext.repository as { name?: string })?.name}`\n                    : undefined,\n                }\n              : undefined,\n\n            // Comment Data (for comment events)\n            comment: eventContext.comment\n              ? {\n                  body: (eventContext.comment as { body?: string })?.body,\n                  author: (eventContext.comment as { user?: { login?: string } })?.user?.login,\n                }\n              : undefined,\n\n            // Raw event payload for advanced use cases\n            payload: eventContext,\n          }\n        : undefined,\n\n      // Utility data for templates\n      utils: {\n        // Date/time helpers\n        now: new Date().toISOString(),\n        today: new Date().toISOString().split('T')[0],\n\n        // Dynamic file grouping by extension\n        filesByExtension: this.groupFilesByExtension(prInfo.files || []),\n\n        // File status categorizations\n        addedFiles: (prInfo.files || []).filter(f => f.status === 'added'),\n        modifiedFiles: (prInfo.files || []).filter(f => f.status === 'modified'),\n        removedFiles: (prInfo.files || []).filter(f => f.status === 'removed'),\n        renamedFiles: (prInfo.files || []).filter(f => f.status === 'renamed'),\n\n        // Change analysis\n        hasLargeChanges: (prInfo.files || []).some(f => f.changes > 50),\n        totalFiles: (prInfo.files || []).length,\n      },\n\n      // Previous check outputs (dependency results)\n      // Expose raw output directly if available, otherwise expose the result as-is\n      outputs: dependencyResults\n        ? Object.fromEntries(\n            Array.from(dependencyResults.entries()).map(([checkName, result]) => [\n              checkName,\n              // If the result has a direct output field, use it directly\n              // Otherwise, expose the entire result\n              (() => {\n                const summary = result as ReviewSummary & { output?: unknown };\n                return summary.output !== undefined ? summary.output : summary;\n              })(),\n            ])\n          )\n        : {},\n    };\n\n    try {\n      return await this.liquidEngine.parseAndRender(promptContent, templateContext);\n    } catch (error) {\n      throw new Error(\n        `Failed to render prompt template: ${\n          error instanceof Error ? error.message : 'Unknown error'\n        }`\n      );\n    }\n  }\n\n  /**\n   * Parse structured response from Claude Code\n   */\n  private parseStructuredResponse(content: string): ReviewSummary {\n    try {\n      // Try to parse as JSON first\n      const parsed = JSON.parse(content);\n\n      // Convert to ReviewSummary format\n      return {\n        issues: parsed.issues || [],\n      };\n    } catch {\n      // If not JSON, treat as plain text comment\n      return {\n        issues: [],\n      };\n    }\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    sessionInfo?: { parentSessionId?: string; reuseSession?: boolean }\n  ): Promise<ReviewSummary> {\n    // Apply environment configuration if present\n    if (config.env) {\n      const result = EnvironmentResolver.withTemporaryEnv(config.env, () => {\n        return this.executeWithConfig(prInfo, config, dependencyResults, sessionInfo);\n      });\n\n      if (result instanceof Promise) {\n        return result;\n      }\n      return result;\n    }\n\n    return this.executeWithConfig(prInfo, config, dependencyResults, sessionInfo);\n  }\n\n  private async executeWithConfig(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    sessionInfo?: { parentSessionId?: string; reuseSession?: boolean }\n  ): Promise<ReviewSummary> {\n    // Extract Claude Code configuration\n    const claudeCodeConfig = (config.claude_code as ClaudeCodeConfig) || {};\n\n    // Get custom prompt from config - REQUIRED\n    const customPrompt = config.prompt;\n    if (!customPrompt) {\n      throw new Error(\n        `No prompt defined for check. All checks must have prompts defined in .visor.yaml configuration.`\n      );\n    }\n\n    // Process prompt with Liquid templates and file loading\n    const processedPrompt = await this.processPrompt(\n      customPrompt,\n      prInfo,\n      config.eventContext,\n      dependencyResults\n    );\n\n    const startTime = Date.now();\n\n    try {\n      // Initialize Claude Code client\n      const client = await this.initializeClaudeCodeClient();\n\n      // Prepare query object with MCP servers passed directly to SDK\n      const query: ClaudeCodeQuery = {\n        query: processedPrompt,\n        maxTurns: claudeCodeConfig.maxTurns || 5,\n        systemPrompt: claudeCodeConfig.systemPrompt,\n        subagent: claudeCodeConfig.subagent,\n      };\n\n      // Add allowed tools if specified\n      if (claudeCodeConfig.allowedTools && claudeCodeConfig.allowedTools.length > 0) {\n        query.tools = claudeCodeConfig.allowedTools.map(name => ({ name }));\n      }\n\n      // Pass MCP servers directly to the SDK - let it handle spawning and tool discovery\n      if (claudeCodeConfig.mcpServers && Object.keys(claudeCodeConfig.mcpServers).length > 0) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (query as any).mcpServers = claudeCodeConfig.mcpServers;\n      }\n\n      // Execute query with Claude Code\n      let response: ClaudeCodeResponse;\n\n      if (sessionInfo?.reuseSession && sessionInfo.parentSessionId) {\n        // Use session reuse if available\n        response = await client.query({\n          ...query,\n          sessionId: sessionInfo.parentSessionId,\n        });\n      } else {\n        // Create new session\n        response = await client.query(query);\n      }\n\n      // Parse the response\n      const result = this.parseStructuredResponse(response.content) as ReviewSummary & {\n        debug?: import('../ai-review-service').AIDebugInfo & {\n          sessionId?: string;\n          turnCount?: number;\n          usage?: unknown;\n          toolsUsed?: string[];\n        };\n      };\n\n      result.debug = {\n        prompt: processedPrompt,\n        rawResponse: response.content,\n        provider: 'claude-code',\n        model: 'claude-code',\n        apiKeySource: 'CLAUDE_CODE_API_KEY',\n        processingTime: Date.now() - startTime,\n        promptLength: processedPrompt.length,\n        responseLength: response.content.length,\n        jsonParseSuccess: true,\n        errors: [],\n        checksExecuted: [config.checkName || 'claude-code-check'],\n        parallelExecution: false,\n        timestamp: new Date().toISOString(),\n        // Claude Code specific debug info\n        sessionId: response.session_id,\n        turnCount: response.turn_count,\n        usage: response.usage,\n      };\n\n      // Apply issue suppression filtering\n      const suppressionEnabled = config.suppressionEnabled !== false;\n      const issueFilter = new IssueFilter(suppressionEnabled);\n      const filteredIssues = issueFilter.filterIssues(result.issues || [], process.cwd());\n\n      return {\n        ...result,\n        issues: filteredIssues,\n      };\n    } catch (error) {\n      // Re-throw setup/configuration errors that should terminate the application\n      if (\n        error instanceof ClaudeCodeSDKNotInstalledError ||\n        error instanceof ClaudeCodeAPIKeyMissingError\n      ) {\n        throw error;\n      }\n\n      const errorMessage = error instanceof Error ? error.message : String(error);\n\n      // Log detailed error information\n      console.error(`❌ Claude Code Check Provider Error: ${errorMessage}`);\n\n      // Check if this is a critical error\n      const isCriticalError =\n        errorMessage.includes('API rate limit') ||\n        errorMessage.includes('403') ||\n        errorMessage.includes('401') ||\n        errorMessage.includes('authentication');\n\n      if (isCriticalError) {\n        console.error(\n          `🚨 CRITICAL ERROR: Claude Code provider authentication or setup issue detected`\n        );\n        console.error(\n          `🚨 This check cannot proceed without valid API credentials and SDK installation`\n        );\n      }\n\n      // Re-throw with more context\n      throw new Error(`Claude Code analysis failed: ${errorMessage}`);\n    }\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'prompt',\n      'claude_code.allowedTools',\n      'claude_code.maxTurns',\n      'claude_code.systemPrompt',\n      'claude_code.mcpServers',\n      'claude_code.subagent',\n      'claude_code.hooks',\n      'env',\n      'checkName',\n      'sessionId',\n      'suppressionEnabled',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    try {\n      // Check if Claude Code API key is available\n      const hasApiKey = !!(process.env.CLAUDE_CODE_API_KEY || process.env.ANTHROPIC_API_KEY);\n\n      if (!hasApiKey) {\n        return false;\n      }\n\n      // Try to import the SDK to check if it's installed\n      const claudeCodeModule = await safeImport<{\n        ClaudeCode?: unknown;\n        default?: { ClaudeCode?: unknown };\n      }>('@anthropic/claude-code-sdk');\n      if (!claudeCodeModule) {\n        return false;\n      }\n      const ClaudeCode = claudeCodeModule.ClaudeCode || claudeCodeModule.default?.ClaudeCode;\n\n      return !!ClaudeCode;\n    } catch {\n      // If import fails, the SDK is not installed\n      return false;\n    }\n  }\n\n  getRequirements(): string[] {\n    return [\n      'CLAUDE_CODE_API_KEY or ANTHROPIC_API_KEY environment variable',\n      '@anthropic/claude-code-sdk npm package',\n      '@modelcontextprotocol/sdk npm package (for MCP support)',\n      'Network access to Claude Code API',\n    ];\n  }\n}\n","export type EnvMap = Record<string, string>;\n\n// Default: expose all env vars except a conservative denylist.\n// If VISOR_ALLOW_ENV is set and not '*', restrict to that allowlist.\n// VISOR_DENY_ENV can further mask exact keys or prefix* patterns.\nexport function buildSandboxEnv(input: NodeJS.ProcessEnv): EnvMap {\n  const denyDefaults = [\n    'GITHUB_TOKEN',\n    'INPUT_GITHUB-TOKEN',\n    'ACTIONS_RUNTIME_TOKEN',\n    'ACTIONS_ID_TOKEN_REQUEST_TOKEN',\n    'AWS_ACCESS_KEY_ID',\n    'AWS_SECRET_ACCESS_KEY',\n    'AWS_SESSION_TOKEN',\n    'AZURE_CLIENT_SECRET',\n    'GOOGLE_APPLICATION_CREDENTIALS',\n    'OPENAI_API_KEY',\n    'ANTHROPIC_API_KEY',\n    'HUGGINGFACE_API_KEY',\n    'CLAUDE_CODE_API_KEY',\n    'PROBE_API_KEY',\n  ];\n\n  const denyExtra = (input.VISOR_DENY_ENV || '')\n    .split(',')\n    .map(s => s.trim())\n    .filter(Boolean);\n  const deny = Array.from(new Set([...denyDefaults, ...denyExtra]));\n  const allowSpec = (input.VISOR_ALLOW_ENV || '*').trim();\n\n  const denyMatch = (key: string): boolean => {\n    for (const pat of deny) {\n      if (!pat) continue;\n      if (pat.endsWith('*')) {\n        const prefix = pat.slice(0, -1);\n        if (key.startsWith(prefix)) return true;\n      } else if (key === pat) {\n        return true;\n      }\n    }\n    if (/(_TOKEN|_SECRET|_PASSWORD|_PRIVATE_KEY)$/i.test(key)) return true;\n    return false;\n  };\n\n  const out: EnvMap = {};\n  if (allowSpec !== '*') {\n    const allow = allowSpec\n      .split(',')\n      .map(s => s.trim())\n      .filter(Boolean);\n    for (const key of allow) {\n      const val = input[key];\n      if (key && val !== undefined && !denyMatch(key)) out[key] = String(val);\n    }\n    return out;\n  }\n\n  for (const [k, v] of Object.entries(input)) {\n    if (v === undefined || v === null) continue;\n    if (denyMatch(k)) continue;\n    out[k] = String(v);\n  }\n  return out;\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary, ReviewIssue } from '../reviewer';\nimport { Liquid } from 'liquidjs';\nimport Sandbox from '@nyariv/sandboxjs';\nimport { createSecureSandbox, compileAndRun } from '../utils/sandbox';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { logger } from '../logger';\nimport {\n  createPermissionHelpers,\n  detectLocalMode,\n  resolveAssociationFromEvent,\n} from '../utils/author-permissions';\nimport { trace, context as otContext } from '../telemetry/lazy-otel';\nimport {\n  captureCheckInputContext,\n  captureCheckOutput,\n  captureTransformJS,\n} from '../telemetry/state-capture';\n\n/**\n * Check provider that executes shell commands and captures their output\n * Supports JSON parsing and integration with forEach functionality\n */\nexport class CommandCheckProvider extends CheckProvider {\n  private liquid: Liquid;\n  private sandbox?: Sandbox;\n\n  constructor() {\n    super();\n    this.liquid = createExtendedLiquid({\n      cache: false,\n      strictFilters: false,\n      strictVariables: false,\n    });\n    // Lazily create sandbox only when transform_js is used\n  }\n\n  private createSecureSandbox(): Sandbox {\n    return createSecureSandbox();\n  }\n\n  getName(): string {\n    return 'command';\n  }\n\n  getDescription(): string {\n    return 'Execute shell commands and capture output for processing';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Must have exec specified\n    if (!cfg.exec || typeof cfg.exec !== 'string') {\n      return false;\n    }\n\n    return true;\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>\n  ): Promise<ReviewSummary> {\n    try {\n      logger.info(\n        `  command provider: executing check=${String((config as any).checkName || config.type)} hasTransformJs=${Boolean(\n          (config as any).transform_js\n        )}`\n      );\n    } catch {}\n    const command = config.exec as string;\n    const transform = config.transform as string | undefined;\n    const transformJs = config.transform_js as string | undefined;\n\n    // Prepare template context for Liquid rendering\n    const outputsObj = this.buildOutputContext(\n      dependencyResults,\n      config.__outputHistory as Map<string, unknown[]> | undefined\n    );\n\n    // Build outputs_raw from -raw keys in dependencyResults\n    const outputsRaw: Record<string, unknown> = {};\n    if (dependencyResults) {\n      for (const [key, value] of dependencyResults.entries()) {\n        if (typeof key !== 'string') continue;\n        if (key.endsWith('-raw')) {\n          const name = key.slice(0, -4);\n          const summary = value as ReviewSummary & { output?: unknown };\n          outputsRaw[name] = summary.output !== undefined ? summary.output : summary;\n        }\n      }\n    }\n\n    const templateContext = {\n      pr: {\n        number: prInfo.number,\n        title: prInfo.title,\n        author: prInfo.author,\n        branch: prInfo.head,\n        base: prInfo.base,\n      },\n      files: prInfo.files,\n      fileCount: prInfo.files.length,\n      outputs: outputsObj,\n      // Alias: outputs_history mirrors outputs.history for consistency\n      outputs_history: (outputsObj as any).history || {},\n      // New: outputs_raw exposes aggregate values (e.g., full arrays for forEach parents)\n      outputs_raw: outputsRaw,\n      env: this.getSafeEnvironmentVariables(),\n    };\n\n    logger.debug(\n      `🔧 Debug: Template outputs keys: ${Object.keys(templateContext.outputs || {}).join(', ')}`\n    );\n\n    // Capture input context in active OTEL span\n    try {\n      const span = trace.getSpan(otContext.active());\n      if (span) {\n        captureCheckInputContext(span, templateContext);\n      }\n    } catch {\n      // Ignore telemetry errors\n    }\n    // Fallback NDJSON for input context (non-OTEL environments)\n    try {\n      const checkId = (config as any).checkName || (config as any).id || 'unknown';\n      const ctxJson = JSON.stringify(templateContext);\n      const { emitNdjsonSpanWithEvents } = require('../telemetry/fallback-ndjson');\n      // Emit both start and completion markers together for deterministic E2E assertions\n      emitNdjsonSpanWithEvents(\n        'visor.check',\n        { 'visor.check.id': checkId, 'visor.check.input.context': ctxJson },\n        [{ name: 'check.started' }, { name: 'check.completed' }]\n      );\n    } catch {}\n\n    try {\n      // Render the command with Liquid templates if needed\n      let renderedCommand = command;\n      if (command.includes('{{') || command.includes('{%')) {\n        renderedCommand = await this.renderCommandTemplate(command, templateContext);\n      }\n      logger.debug(`🔧 Debug: Rendered command: ${renderedCommand}`);\n\n      // Prepare environment variables - convert all to strings\n      const scriptEnv: Record<string, string> = {};\n      for (const [key, value] of Object.entries(process.env)) {\n        if (value !== undefined) {\n          scriptEnv[key] = value;\n        }\n      }\n      if (config.env) {\n        for (const [key, value] of Object.entries(config.env)) {\n          if (value !== undefined && value !== null) {\n            scriptEnv[key] = String(value);\n          }\n        }\n      }\n\n      // Execute the script using dynamic import to avoid Jest issues\n      const { exec } = await import('child_process');\n      const { promisify } = await import('util');\n      const execAsync = promisify(exec);\n\n      // Get timeout from config (in seconds) or use default (60 seconds)\n      const timeoutSeconds = (config.timeout as number) || 60;\n      const timeoutMs = timeoutSeconds * 1000;\n\n      // Normalize only the eval payload for `node -e|--eval` invocations that may contain\n      // literal newlines due to YAML processing (\"\\n\" -> newline). We re-escape newlines\n      // inside the quoted eval argument to keep JS string literals valid, without touching\n      // the rest of the command.\n      const normalizeNodeEval = (cmd: string): string => {\n        const re =\n          /^(?<prefix>\\s*(?:\\/usr\\/bin\\/env\\s+)?node(?:\\.exe)?\\s+(?:-e|--eval)\\s+)(['\"])([\\s\\S]*?)\\2(?<suffix>\\s|$)/;\n        const m = cmd.match(re) as\n          | (RegExpMatchArray & { groups?: { prefix: string; suffix?: string } })\n          | null;\n        if (!m || !m.groups) return cmd;\n        const prefix = m.groups.prefix;\n        const quote = m[2];\n        const code = m[3];\n        const suffix = m.groups.suffix || '';\n        if (!code.includes('\\n')) return cmd;\n        const escaped = code.replace(/\\n/g, '\\\\n');\n        return cmd.replace(re, `${prefix}${quote}${escaped}${quote}${suffix}`);\n      };\n\n      const safeCommand = normalizeNodeEval(renderedCommand);\n\n      const { stdout, stderr } = await execAsync(safeCommand, {\n        env: scriptEnv,\n        timeout: timeoutMs,\n        maxBuffer: 10 * 1024 * 1024, // 10MB buffer\n      });\n\n      if (stderr) {\n        logger.debug(`Command stderr: ${stderr}`);\n      }\n\n      // Keep raw output for transforms\n      const rawOutput = stdout.trim();\n\n      // Try to parse output as JSON for default behavior\n      // no debug\n      let output: unknown = rawOutput;\n      try {\n        // Attempt to parse as JSON\n        const parsed = JSON.parse(rawOutput);\n        output = parsed;\n        logger.debug(`🔧 Debug: Parsed entire output as JSON successfully`);\n      } catch {\n        // Try to extract JSON from the end of output (for commands with debug logs)\n        const extractedTail = this.extractJsonFromEnd(rawOutput);\n        if (extractedTail) {\n          try {\n            output = JSON.parse(extractedTail);\n          } catch {\n            output = rawOutput;\n          }\n        } else {\n          // Try to extract any balanced JSON substring anywhere\n          const extractedAny = this.extractJsonAnywhere(rawOutput);\n          if (extractedAny) {\n            try {\n              output = JSON.parse(extractedAny);\n            } catch {\n              output = rawOutput;\n            }\n          } else {\n            // Last resort: detect common boolean flags like error:true or error=false for fail_if gating\n            const m = /\\berror\\b\\s*[:=]\\s*(true|false)/i.exec(rawOutput);\n            if (m) {\n              output = { error: m[1].toLowerCase() === 'true' } as any;\n            } else {\n              output = rawOutput;\n            }\n          }\n        }\n      }\n\n      // Log the parsed structure for debugging\n      // no debug\n\n      // Apply transform if specified (Liquid or JavaScript)\n      let finalOutput = output;\n\n      // First apply Liquid transform if present\n      if (transform) {\n        try {\n          const transformContext = {\n            ...templateContext,\n            output: output, // Use parsed output for Liquid (object if JSON, string otherwise)\n          };\n          const rendered = await this.liquid.parseAndRender(transform, transformContext);\n\n          // Try to parse the transformed result as JSON\n          try {\n            finalOutput = JSON.parse(rendered.trim());\n            logger.verbose(`✓ Applied Liquid transform successfully (parsed as JSON)`);\n          } catch {\n            finalOutput = rendered.trim();\n            logger.verbose(`✓ Applied Liquid transform successfully (string output)`);\n          }\n        } catch (error) {\n          logger.error(\n            `✗ Failed to apply Liquid transform: ${error instanceof Error ? error.message : 'Unknown error'}`\n          );\n          return {\n            issues: [\n              {\n                file: 'command',\n                line: 0,\n                ruleId: 'command/transform_error',\n                message: `Failed to apply Liquid transform: ${error instanceof Error ? error.message : 'Unknown error'}`,\n                severity: 'error',\n                category: 'logic',\n              },\n            ],\n          };\n        }\n      }\n\n      // Then apply JavaScript transform if present\n      if (transformJs) {\n        try {\n          // For transform_js, provide a JSON-smart wrapper that:\n          //  - behaves like a string when coerced (so JSON.parse(output) still works)\n          //  - exposes parsed JSON properties if stdout is valid JSON (so output.key works)\n          const jsContext = {\n            output: this.makeJsonSmart(rawOutput),\n            pr: templateContext.pr,\n            files: templateContext.files,\n            outputs: this.makeOutputsJsonSmart(templateContext.outputs),\n            env: templateContext.env,\n            permissions: createPermissionHelpers(\n              resolveAssociationFromEvent((prInfo as any).eventContext, prInfo.authorAssociation),\n              detectLocalMode()\n            ),\n          };\n\n          // Compile and execute the JavaScript expression\n          // Use direct property access instead of destructuring to avoid syntax issues\n          const trimmedTransform = transformJs.trim();\n          // Build a safe function body that supports statements + implicit last-expression return.\n          const buildBodyWithReturn = (raw: string): string => {\n            const t = raw.trim();\n            // Find last non-empty line\n            const lines = t.split(/\\n/);\n            let i = lines.length - 1;\n            while (i >= 0 && lines[i].trim().length === 0) i--;\n            if (i < 0) return 'return undefined;';\n            const lastLine = lines[i].trim();\n            if (/^return\\b/i.test(lastLine)) {\n              return t;\n            }\n            const idx = t.lastIndexOf(lastLine);\n            const head = idx >= 0 ? t.slice(0, idx) : '';\n            const lastExpr = lastLine.replace(/;\\s*$/, '');\n            return `${head}\\nreturn (${lastExpr});`;\n          };\n          const bodyWithReturn = buildBodyWithReturn(trimmedTransform);\n\n          const code = `\n            const output = scope.output;\n            const pr = scope.pr;\n            const files = scope.files;\n            const outputs = scope.outputs;\n            const env = scope.env;\n            const log = (...args) => { console.log('🔍 Debug:', ...args); };\n            const hasMinPermission = scope.permissions.hasMinPermission;\n            const isOwner = scope.permissions.isOwner;\n            const isMember = scope.permissions.isMember;\n            const isCollaborator = scope.permissions.isCollaborator;\n            const isContributor = scope.permissions.isContributor;\n            const isFirstTimer = scope.permissions.isFirstTimer;\n            const __result = (function(){\n${bodyWithReturn}\n            })();\n            return __result;\n          `;\n\n          // Execute user code exclusively inside the sandbox\n          if (!this.sandbox) {\n            this.sandbox = this.createSecureSandbox();\n          }\n          // Try to serialize result to JSON string inside sandbox to preserve primitives like booleans\n          let parsedFromSandboxJson: any = undefined;\n          try {\n            const stringifyCode = `\n              const output = scope.output;\n              const pr = scope.pr;\n              const files = scope.files;\n              const outputs = scope.outputs;\n              const env = scope.env;\n              const log = (...args) => { console.log('🔍 Debug:', ...args); };\n              const hasMinPermission = scope.permissions.hasMinPermission;\n              const isOwner = scope.permissions.isOwner;\n              const isMember = scope.permissions.isMember;\n              const isCollaborator = scope.permissions.isCollaborator;\n              const isContributor = scope.permissions.isContributor;\n              const isFirstTimer = scope.permissions.isFirstTimer;\n              const __ret = (function(){\n${bodyWithReturn}\n              })();\n              return typeof __ret === 'object' && __ret !== null ? JSON.stringify(__ret) : null;\n            `;\n            const stringifyExec = this.sandbox.compile(stringifyCode);\n            const jsonStr = stringifyExec({ scope: jsContext }).run();\n            if (typeof jsonStr === 'string' && jsonStr.trim().startsWith('{')) {\n              parsedFromSandboxJson = JSON.parse(jsonStr);\n            }\n          } catch {}\n\n          if (parsedFromSandboxJson !== undefined) {\n            finalOutput = parsedFromSandboxJson;\n          } else {\n            finalOutput = compileAndRun<unknown>(\n              this.sandbox,\n              code,\n              { scope: jsContext },\n              { injectLog: false, wrapFunction: false }\n            );\n          }\n\n          // Fallback: if sandbox could not preserve primitives (e.g., booleans lost),\n          // attempt to re-evaluate the transform in a locked Node VM context to get plain JS values.\n          try {\n            if (\n              finalOutput &&\n              typeof finalOutput === 'object' &&\n              !Array.isArray(finalOutput) &&\n              ((finalOutput as any).error === undefined ||\n                (finalOutput as any).issues === undefined)\n            ) {\n              const vm = await import('node:vm');\n              const vmContext = vm.createContext({ scope: jsContext });\n              const vmCode = `\n                (function(){\n                  const output = scope.output; const pr = scope.pr; const files = scope.files; const outputs = scope.outputs; const env = scope.env; const log = ()=>{};\n${bodyWithReturn}\n                })()\n              `;\n              const vmResult = vm.runInContext(vmCode, vmContext, { timeout: 1000 });\n              if (vmResult && typeof vmResult === 'object') {\n                finalOutput = vmResult;\n              }\n            }\n          } catch {}\n          // Create a plain JSON snapshot of the transform result to avoid proxy/getter surprises\n          // Prefer JSON stringify inside the sandbox realm (so it knows how to serialize its own objects),\n          // then fall back to host-side JSON clone and finally to a shallow copy of own enumerable properties.\n          let finalSnapshot: Record<string, unknown> | null = null;\n          try {\n            if (finalOutput && typeof finalOutput === 'object' && !Array.isArray(finalOutput)) {\n              // Try realm-local stringify first\n              try {\n                const stringifyExec = this.sandbox!.compile('return JSON.stringify(scope.obj);');\n                const jsonStr = stringifyExec({ obj: finalOutput }).run();\n                if (typeof jsonStr === 'string' && jsonStr.trim().startsWith('{')) {\n                  finalSnapshot = JSON.parse(jsonStr);\n                }\n              } catch {}\n              if (!finalSnapshot) {\n                try {\n                  finalSnapshot = JSON.parse(JSON.stringify(finalOutput));\n                } catch {}\n              }\n              if (!finalSnapshot) {\n                const tmp: Record<string, unknown> = {};\n                for (const k of Object.keys(finalOutput as Record<string, unknown>)) {\n                  (tmp as any)[k] = (finalOutput as any)[k];\n                }\n                finalSnapshot = tmp;\n              }\n            }\n          } catch {}\n          // @ts-ignore store for later extraction path\n          (this as any).__lastTransformSnapshot = finalSnapshot;\n          try {\n            const isObj =\n              finalOutput && typeof finalOutput === 'object' && !Array.isArray(finalOutput);\n            const keys = isObj\n              ? Object.keys(finalOutput as Record<string, unknown>).join(',')\n              : typeof finalOutput;\n            logger.debug(\n              `  transform_js: output typeof=${Array.isArray(finalOutput) ? 'array' : typeof finalOutput} keys=${keys}`\n            );\n            if (isObj && (finalOutput as any).issues) {\n              const mi: any = (finalOutput as any).issues;\n              logger.debug(\n                `  transform_js: issues typeof=${Array.isArray(mi) ? 'array' : typeof mi} len=${(mi && mi.length) || 0}`\n              );\n            }\n            try {\n              if (isObj)\n                logger.debug(`  transform_js: error value=${String((finalOutput as any).error)}`);\n            } catch {}\n          } catch {}\n\n          logger.verbose(`✓ Applied JavaScript transform successfully`);\n          // Already normalized in sandbox result\n          // no debug\n        } catch (error) {\n          logger.error(\n            `✗ Failed to apply JavaScript transform: ${error instanceof Error ? error.message : 'Unknown error'}`\n          );\n          return {\n            issues: [\n              {\n                file: 'command',\n                line: 0,\n                ruleId: 'command/transform_js_error',\n                message: `Failed to apply JavaScript transform: ${error instanceof Error ? error.message : 'Unknown error'}`,\n                severity: 'error',\n                category: 'logic',\n              },\n            ],\n          };\n        }\n      }\n\n      // Extract structured issues when the command returns them (skip for forEach parents)\n      // no debug\n      let issues: ReviewIssue[] = [];\n      let outputForDependents: unknown = finalOutput;\n      // Capture a shallow snapshot created earlier if available (within transform_js path)\n      // @ts-ignore - finalSnapshot is defined in the transform_js scope above when applicable\n      // @ts-ignore retrieve snapshot captured after transform_js (if any)\n      const snapshotForExtraction: Record<string, unknown> | null =\n        (this as any).__lastTransformSnapshot || null;\n      try {\n        if (snapshotForExtraction) {\n          logger.debug(`  provider: snapshot keys=${Object.keys(snapshotForExtraction).join(',')}`);\n        } else {\n          logger.debug(`  provider: snapshot is null`);\n        }\n      } catch {}\n      // Some shells may wrap JSON output inside a one-element array due to quoting.\n      // If we see a single-element array containing a JSON string or object, unwrap it.\n      try {\n        if (Array.isArray(outputForDependents) && (outputForDependents as unknown[]).length === 1) {\n          const first = (outputForDependents as unknown[])[0];\n          if (typeof first === 'string') {\n            try {\n              outputForDependents = JSON.parse(first);\n            } catch {}\n          } else if (first && typeof first === 'object') {\n            outputForDependents = first as unknown;\n          }\n        }\n      } catch {}\n\n      let content: string | undefined;\n      let extracted: { issues: ReviewIssue[]; remainingOutput: unknown } | null = null;\n\n      const trimmedRawOutput = typeof rawOutput === 'string' ? rawOutput.trim() : undefined;\n\n      const commandConfig = config as CheckProviderConfig & { forEach?: boolean };\n      const isForEachParent = commandConfig.forEach === true;\n\n      if (!isForEachParent) {\n        // Generic: if transform output is an object and contains an 'issues' field,\n        // expose all other fields to dependents regardless of whether we successfully\n        // normalized the issues array. This preserves flags like 'error' for fail_if.\n        try {\n          const baseObj = (snapshotForExtraction || (finalOutput as any)) as Record<\n            string,\n            unknown\n          >;\n          if (\n            baseObj &&\n            typeof baseObj === 'object' &&\n            Object.prototype.hasOwnProperty.call(baseObj, 'issues')\n          ) {\n            const remaining = { ...baseObj } as Record<string, unknown>;\n            delete (remaining as any).issues;\n            outputForDependents = Object.keys(remaining).length > 0 ? remaining : undefined;\n            try {\n              const k =\n                outputForDependents && typeof outputForDependents === 'object'\n                  ? Object.keys(outputForDependents as any).join(',')\n                  : String(outputForDependents);\n              logger.debug(`  provider: generic-remaining keys=${k}`);\n            } catch {}\n          }\n        } catch {}\n        // Fast path for transform_js objects that include an issues array (realm-agnostic)\n        const objForExtraction = (snapshotForExtraction || (finalOutput as any)) as Record<\n          string,\n          unknown\n        >;\n        if (objForExtraction && typeof objForExtraction === 'object') {\n          try {\n            const rec = objForExtraction;\n            const maybeIssues: any = (rec as any).issues;\n            const toPlainArray = (v: any): any[] | null => {\n              if (Array.isArray(v)) return v;\n              try {\n                if (v && typeof v === 'object' && typeof v[Symbol.iterator] === 'function') {\n                  return Array.from(v);\n                }\n              } catch {}\n              const len = Number((v || {}).length);\n              if (Number.isFinite(len) && len >= 0) {\n                const arr: any[] = [];\n                for (let i = 0; i < len; i++) arr.push(v[i]);\n                return arr;\n              }\n              try {\n                const cloned = JSON.parse(JSON.stringify(v));\n                return Array.isArray(cloned) ? cloned : null;\n              } catch {\n                return null;\n              }\n            };\n            try {\n              const ctor =\n                maybeIssues && (maybeIssues as any).constructor\n                  ? (maybeIssues as any).constructor.name\n                  : 'unknown';\n              logger.debug(\n                `  provider: issues inspect typeof=${typeof maybeIssues} Array.isArray=${Array.isArray(\n                  maybeIssues\n                )} ctor=${ctor} keys=${Object.keys((maybeIssues || {}) as any).join(',')}`\n              );\n            } catch {}\n            const arr = toPlainArray(maybeIssues);\n            if (arr) {\n              const norm = this.normalizeIssueArray(arr);\n              if (norm) {\n                issues = norm;\n                const remaining = { ...rec } as Record<string, unknown>;\n                delete (remaining as any).issues;\n                outputForDependents = Object.keys(remaining).length > 0 ? remaining : undefined;\n                try {\n                  const keys =\n                    outputForDependents && typeof outputForDependents === 'object'\n                      ? Object.keys(outputForDependents as any).join(',')\n                      : String(outputForDependents);\n                  logger.info(\n                    `  provider: fast-path issues=${issues.length} remaining keys=${keys}`\n                  );\n                } catch {}\n              } else {\n                try {\n                  logger.info('  provider: fast-path norm failed');\n                } catch {}\n              }\n            } else {\n              try {\n                logger.info('  provider: fast-path arr unavailable');\n              } catch {}\n            }\n          } catch {}\n        }\n        // Normalize extraction target: unwrap one-element arrays like [\"{...}\"] or [{...}]\n        let extractionTarget: unknown = snapshotForExtraction || finalOutput;\n        try {\n          if (Array.isArray(extractionTarget) && (extractionTarget as unknown[]).length === 1) {\n            const first = (extractionTarget as unknown[])[0];\n            if (typeof first === 'string') {\n              try {\n                extractionTarget = JSON.parse(first);\n              } catch {\n                extractionTarget = first;\n              }\n            } else if (first && typeof first === 'object') {\n              extractionTarget = first as unknown;\n            }\n          }\n        } catch {}\n        extracted = this.extractIssuesFromOutput(extractionTarget);\n        try {\n          if (extractionTarget !== (snapshotForExtraction || finalOutput)) {\n            finalOutput = extractionTarget;\n          }\n        } catch {}\n        // no debug\n        // Handle cross-realm Arrays from sandbox: issues may look like an array but fail Array.isArray\n        if (!extracted && finalOutput && typeof finalOutput === 'object') {\n          try {\n            const rec = finalOutput as Record<string, unknown>;\n            const maybeIssues: any = (rec as any).issues;\n            if (maybeIssues && typeof maybeIssues === 'object') {\n              let arr: any[] | null = null;\n              // Prefer iterator if present\n              try {\n                if (typeof maybeIssues[Symbol.iterator] === 'function') {\n                  arr = Array.from(maybeIssues);\n                }\n              } catch {}\n              // Fallback to length-based copy\n              if (!arr) {\n                const len = Number((maybeIssues as any).length);\n                if (Number.isFinite(len) && len >= 0) {\n                  arr = [];\n                  for (let i = 0; i < len; i++) arr.push(maybeIssues[i]);\n                }\n              }\n              // Last resort: JSON clone\n              if (!arr) {\n                try {\n                  arr = JSON.parse(JSON.stringify(maybeIssues));\n                } catch {}\n              }\n              if (arr && Array.isArray(arr)) {\n                const norm = this.normalizeIssueArray(arr);\n                if (norm) {\n                  issues = norm;\n                  const remaining = { ...rec } as Record<string, unknown>;\n                  delete (remaining as any).issues;\n                  outputForDependents = Object.keys(remaining).length > 0 ? remaining : undefined;\n                }\n              }\n            }\n          } catch {}\n        }\n        if (!extracted && typeof finalOutput === 'string') {\n          // Attempt to parse string output as JSON and extract issues again\n          try {\n            const parsed = JSON.parse(finalOutput);\n            extracted = this.extractIssuesFromOutput(parsed);\n            if (extracted) {\n              issues = extracted.issues;\n              outputForDependents = extracted.remainingOutput;\n              // If remainingOutput carries a content field, pick it up\n              if (\n                typeof extracted.remainingOutput === 'object' &&\n                extracted.remainingOutput !== null &&\n                typeof (extracted.remainingOutput as any).content === 'string'\n              ) {\n                const c = String((extracted.remainingOutput as any).content).trim();\n                if (c) content = c;\n              }\n            }\n          } catch {\n            // Try to salvage JSON from anywhere within the string (stripped logs/ansi)\n            try {\n              const any = this.extractJsonAnywhere(finalOutput);\n              if (any) {\n                const parsed = JSON.parse(any);\n                extracted = this.extractIssuesFromOutput(parsed);\n                if (extracted) {\n                  issues = extracted.issues;\n                  outputForDependents = extracted.remainingOutput;\n                  if (\n                    typeof extracted.remainingOutput === 'object' &&\n                    extracted.remainingOutput !== null &&\n                    typeof (extracted.remainingOutput as any).content === 'string'\n                  ) {\n                    const c = String((extracted.remainingOutput as any).content).trim();\n                    if (c) content = c;\n                  }\n                }\n              }\n            } catch {\n              // leave as-is\n            }\n          }\n        } else if (extracted) {\n          issues = extracted.issues;\n          outputForDependents = extracted.remainingOutput;\n          // Also propagate embedded content when remainingOutput is an object { content, ... }\n          if (\n            typeof extracted.remainingOutput === 'object' &&\n            extracted.remainingOutput !== null &&\n            typeof (extracted.remainingOutput as any).content === 'string'\n          ) {\n            const c = String((extracted.remainingOutput as any).content).trim();\n            if (c) content = c;\n          }\n        }\n\n        if (!issues.length && this.shouldTreatAsTextOutput(trimmedRawOutput)) {\n          content = trimmedRawOutput;\n        } else if (issues.length && typeof extracted?.remainingOutput === 'string') {\n          const trimmed = extracted.remainingOutput.trim();\n          if (trimmed) {\n            content = trimmed;\n          }\n        }\n\n        // Generic fallback: if issues are still empty, try to parse raw stdout as JSON and extract issues.\n        if (!issues.length && typeof trimmedRawOutput === 'string') {\n          try {\n            const tryParsed = JSON.parse(trimmedRawOutput);\n            const reextract = this.extractIssuesFromOutput(tryParsed);\n            if (reextract && reextract.issues && reextract.issues.length) {\n              issues = reextract.issues;\n              if (!outputForDependents && reextract.remainingOutput) {\n                outputForDependents = reextract.remainingOutput;\n              }\n            } else if (Array.isArray(tryParsed)) {\n              // Treat parsed array as potential issues array or array of { issues: [...] }\n              const first = tryParsed[0];\n              if (first && typeof first === 'object' && Array.isArray((first as any).issues)) {\n                const merged: unknown[] = [];\n                for (const el of tryParsed as unknown[]) {\n                  if (el && typeof el === 'object' && Array.isArray((el as any).issues)) {\n                    merged.push(...((el as any).issues as unknown[]));\n                  }\n                }\n                const flat = this.normalizeIssueArray(merged);\n                if (flat) issues = flat;\n              } else {\n                // Try to parse string elements into JSON objects and extract\n                const converted: unknown[] = [];\n                for (const el of tryParsed as unknown[]) {\n                  if (typeof el === 'string') {\n                    try {\n                      const obj = JSON.parse(el);\n                      converted.push(obj);\n                    } catch {\n                      // keep as-is\n                    }\n                  } else {\n                    converted.push(el);\n                  }\n                }\n                const flat = this.normalizeIssueArray(converted as unknown[]);\n                if (flat) issues = flat;\n              }\n            }\n          } catch {}\n          if (!issues.length) {\n            try {\n              const any = this.extractJsonAnywhere(trimmedRawOutput);\n              if (any) {\n                const tryParsed = JSON.parse(any);\n                const reextract = this.extractIssuesFromOutput(tryParsed);\n                if (reextract && reextract.issues && reextract.issues.length) {\n                  issues = reextract.issues;\n                  if (!outputForDependents && reextract.remainingOutput) {\n                    outputForDependents = reextract.remainingOutput;\n                  }\n                }\n              }\n            } catch {}\n          }\n        }\n\n        // Preserve all primitive flags (boolean/number/string) from original transform output\n        try {\n          const srcObj = (snapshotForExtraction || (finalOutput as any)) as Record<string, unknown>;\n          if (\n            outputForDependents &&\n            typeof outputForDependents === 'object' &&\n            srcObj &&\n            typeof srcObj === 'object'\n          ) {\n            for (const k of Object.keys(srcObj)) {\n              const v: any = (srcObj as any)[k];\n              if (typeof v === 'boolean' || typeof v === 'number' || typeof v === 'string') {\n                (outputForDependents as any)[k] = v;\n              }\n            }\n          }\n        } catch {}\n\n        // Normalize output object to a plain shallow object (avoid JSON stringify drop of false booleans)\n        try {\n          if (\n            outputForDependents &&\n            typeof outputForDependents === 'object' &&\n            !Array.isArray(outputForDependents)\n          ) {\n            const plain: Record<string, unknown> = {};\n            for (const k of Object.keys(outputForDependents as any)) {\n              (plain as any)[k] = (outputForDependents as any)[k];\n            }\n            outputForDependents = plain;\n          }\n        } catch {}\n      }\n\n      if (!content && this.shouldTreatAsTextOutput(trimmedRawOutput) && !isForEachParent) {\n        content = trimmedRawOutput;\n      }\n\n      // Normalize output object to plain JSON to avoid cross-realm proxy quirks\n      try {\n        if (outputForDependents && typeof outputForDependents === 'object') {\n          outputForDependents = JSON.parse(JSON.stringify(outputForDependents));\n        }\n      } catch {}\n\n      // Promote primitive flags from original transform output to top-level result fields (schema-agnostic)\n      const promoted: Record<string, unknown> = {};\n      try {\n        const srcObj = (snapshotForExtraction || (finalOutput as any)) as Record<string, unknown>;\n        if (srcObj && typeof srcObj === 'object') {\n          for (const k of Object.keys(srcObj)) {\n            const v: any = (srcObj as any)[k];\n            if (typeof v === 'boolean') {\n              if (v === true && promoted[k] === undefined) promoted[k] = true;\n            } else if (\n              (typeof v === 'number' || typeof v === 'string') &&\n              promoted[k] === undefined\n            ) {\n              promoted[k] = v;\n            }\n          }\n        }\n      } catch {}\n\n      // Return the output and issues as part of the review summary so dependent checks can use them\n      const result = {\n        issues,\n        output: outputForDependents,\n        ...(content ? { content } : {}),\n        ...promoted,\n      } as ReviewSummary;\n\n      // Capture output and transform details in active OTEL span\n      try {\n        const span = trace.getSpan(otContext.active());\n        if (span) {\n          captureCheckOutput(span, outputForDependents);\n          if (transformJs && output !== finalOutput) {\n            captureTransformJS(span, transformJs, output, finalOutput);\n          }\n        }\n      } catch {\n        // Ignore telemetry errors\n      }\n      // Fallback NDJSON for output (non-OTEL environments)\n      try {\n        const checkId = (config as any).checkName || (config as any).id || 'unknown';\n        const outJson = JSON.stringify((result as any).output ?? result);\n        const { emitNdjsonSpanWithEvents } = require('../telemetry/fallback-ndjson');\n        emitNdjsonSpanWithEvents(\n          'visor.check',\n          { 'visor.check.id': checkId, 'visor.check.output': outJson },\n          [{ name: 'check.started' }, { name: 'check.completed' }]\n        );\n      } catch {}\n\n      // Attach raw transform object only when transform_js was used (avoid polluting plain command outputs)\n      try {\n        if (transformJs) {\n          const rawObj = (snapshotForExtraction || (finalOutput as any)) as Record<string, unknown>;\n          if (rawObj && typeof rawObj === 'object') {\n            (result as any).__raw = rawObj;\n          }\n        }\n      } catch {}\n\n      // Final safeguard: ensure primitive flags from original transform output are present in result.output.\n      // Do this without dropping explicit false values (important for fail_if like `output.error`).\n      try {\n        const srcObj = (snapshotForExtraction || (finalOutput as any)) as Record<string, unknown>;\n        const srcErr = ((): boolean | undefined => {\n          try {\n            if (\n              snapshotForExtraction &&\n              typeof snapshotForExtraction === 'object' &&\n              (snapshotForExtraction as any).error !== undefined\n            ) {\n              return Boolean((snapshotForExtraction as any).error);\n            }\n            if (\n              finalOutput &&\n              typeof finalOutput === 'object' &&\n              (finalOutput as any).error !== undefined\n            ) {\n              return Boolean((finalOutput as any).error);\n            }\n          } catch {}\n          return undefined;\n        })();\n        const dst = (result as any).output;\n        if (srcObj && typeof srcObj === 'object' && dst && typeof dst === 'object') {\n          try {\n            logger.debug(\n              `  provider: safeguard src.error typeof=${typeof (srcObj as any).error} val=${String((srcObj as any).error)} dst.hasErrorBefore=${String((dst as any).error !== undefined)}`\n            );\n          } catch {}\n          for (const k of Object.keys(srcObj)) {\n            const v: any = (srcObj as any)[k];\n            if (typeof v === 'boolean' || typeof v === 'number' || typeof v === 'string') {\n              (dst as any)[k] = v;\n            }\n          }\n          // Explicitly normalize a common flag used in tests/pipelines\n          if (srcErr !== undefined && (dst as any).error === undefined) {\n            (dst as any).error = srcErr;\n            try {\n              const k = Object.keys(dst as any).join(',');\n              logger.debug(\n                `  provider: safeguard merged error -> output keys=${k} val=${String((dst as any).error)}`\n              );\n            } catch {}\n          }\n        }\n      } catch {}\n\n      try {\n        const out: any = (result as any).output;\n        if (out && typeof out === 'object') {\n          const k = Object.keys(out as Record<string, unknown>).join(',');\n          logger.debug(`  provider: return output keys=${k}`);\n        } else {\n          logger.debug(`  provider: return output type=${typeof out}`);\n        }\n      } catch {}\n\n      // no debug\n\n      return result;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\n      // Check if this is a timeout error\n      let isTimeout = false;\n      if (error && typeof error === 'object') {\n        const execError = error as { killed?: boolean; signal?: string; code?: string | number };\n        // Node's child_process sets killed=true and signal='SIGTERM' on timeout\n        if (execError.killed && execError.signal === 'SIGTERM') {\n          isTimeout = true;\n        }\n        // Some versions may also set code to 'ETIMEDOUT'\n        if (execError.code === 'ETIMEDOUT') {\n          isTimeout = true;\n        }\n      }\n\n      // Extract stderr from the error if available (child_process errors include stdout/stderr)\n      let stderrOutput = '';\n      if (error && typeof error === 'object') {\n        const execError = error as { stderr?: string; stdout?: string };\n        if (execError.stderr) {\n          stderrOutput = execError.stderr.trim();\n        }\n      }\n\n      // Construct detailed error message\n      let detailedMessage: string;\n      let ruleId: string;\n\n      if (isTimeout) {\n        const timeoutSeconds = (config.timeout as number) || 60;\n        detailedMessage = `Command execution timed out after ${timeoutSeconds} seconds`;\n        if (stderrOutput) {\n          detailedMessage += `\\n\\nStderr output:\\n${stderrOutput}`;\n        }\n        ruleId = 'command/timeout';\n      } else {\n        detailedMessage = stderrOutput\n          ? `Command execution failed: ${errorMessage}\\n\\nStderr output:\\n${stderrOutput}`\n          : `Command execution failed: ${errorMessage}`;\n        ruleId = 'command/execution_error';\n      }\n\n      logger.error(`✗ ${detailedMessage}`);\n\n      return {\n        issues: [\n          {\n            file: 'command',\n            line: 0,\n            ruleId,\n            message: detailedMessage,\n            severity: 'error',\n            category: 'logic',\n          },\n        ],\n      };\n    }\n  }\n\n  private buildOutputContext(\n    dependencyResults?: Map<string, ReviewSummary>,\n    outputHistory?: Map<string, unknown[]>\n  ): Record<string, unknown> {\n    if (!dependencyResults) {\n      return {};\n    }\n\n    const outputs: Record<string, unknown> = {};\n    const history: Record<string, unknown[]> = {};\n\n    for (const [checkName, result] of dependencyResults) {\n      // If the result has a direct output field, use it directly\n      // Otherwise, expose the entire result as-is\n      const summary = result as ReviewSummary & { output?: unknown };\n      const value = summary.output !== undefined ? summary.output : summary;\n      outputs[checkName] = this.makeJsonSmart(value);\n    }\n\n    // Add history for each check if available\n    if (outputHistory) {\n      for (const [checkName, historyArray] of outputHistory) {\n        history[checkName] = historyArray.map(val => this.makeJsonSmart(val));\n      }\n    }\n\n    // Attach history to the outputs object\n    (outputs as any).history = history;\n\n    return outputs;\n  }\n\n  /**\n   * Wrap a value with JSON-smart behavior:\n   *  - If it's a JSON string, expose parsed properties via Proxy (e.g., value.key)\n   *  - When coerced to string (toString/valueOf/Symbol.toPrimitive), return the original raw string\n   *  - If parsing fails or value is not a string, return the value unchanged\n   *  - Attempts to extract JSON from the end of the output if full parse fails\n   */\n  private makeJsonSmart<T = unknown>(value: T): T | any {\n    if (typeof value !== 'string') {\n      return value;\n    }\n\n    const raw = value as unknown as string;\n    let parsed: any;\n\n    // First try: parse the entire string as JSON\n    try {\n      parsed = JSON.parse(raw);\n    } catch {\n      // Second try: extract JSON from the end of the output\n      // Look for { or [ at the start of a line and take everything after it\n      const jsonMatch = this.extractJsonFromEnd(raw);\n      if (jsonMatch) {\n        try {\n          parsed = JSON.parse(jsonMatch);\n          logger.debug(\n            `🔧 Debug: Extracted JSON from end of output (${jsonMatch.length} chars from ${raw.length} total)`\n          );\n        } catch {\n          // Not valid JSON even after extraction, return original string\n          return raw;\n        }\n      } else {\n        // Not JSON, return original string\n        return raw;\n      }\n    }\n\n    // Use a boxed string so string methods still work via Proxy fallback\n    const boxed = new String(raw);\n    const handler: ProxyHandler<any> = {\n      get(target, prop, receiver) {\n        if (prop === 'toString' || prop === 'valueOf') {\n          return () => raw;\n        }\n        if (prop === Symbol.toPrimitive) {\n          return () => raw;\n        }\n        if (parsed != null && (typeof parsed === 'object' || Array.isArray(parsed))) {\n          if (prop in parsed) {\n            return (parsed as any)[prop as any];\n          }\n        }\n        return Reflect.get(target, prop, receiver);\n      },\n      has(_target, prop) {\n        if (parsed != null && (typeof parsed === 'object' || Array.isArray(parsed))) {\n          if (prop in parsed) return true;\n        }\n        return false;\n      },\n      ownKeys(_target) {\n        if (parsed != null && (typeof parsed === 'object' || Array.isArray(parsed))) {\n          try {\n            return Reflect.ownKeys(parsed);\n          } catch {\n            return [];\n          }\n        }\n        return [];\n      },\n      getOwnPropertyDescriptor(_target, prop) {\n        if (parsed != null && (typeof parsed === 'object' || Array.isArray(parsed))) {\n          const descriptor = Object.getOwnPropertyDescriptor(parsed, prop as any);\n          if (descriptor) return descriptor;\n        }\n        return {\n          configurable: true,\n          enumerable: true,\n          writable: false,\n          value: undefined,\n        };\n      },\n    };\n    return new Proxy(boxed, handler);\n  }\n\n  /**\n   * Extract JSON from the end of a string that may contain logs/debug output\n   * Looks for the last occurrence of { or [ and tries to parse from there\n   */\n  private extractJsonFromEnd(text: string): string | null {\n    // Robust strategy: find the last closing brace/bracket, then walk backwards to the matching opener\n    const lastBrace = Math.max(text.lastIndexOf('}'), text.lastIndexOf(']'));\n    if (lastBrace === -1) return null;\n    // Scan backwards to find matching opener with a simple counter\n    let open = 0;\n    for (let i = lastBrace; i >= 0; i--) {\n      const ch = text[i];\n      if (ch === '}' || ch === ']') open++;\n      else if (ch === '{' || ch === '[') open--;\n      if (open === 0 && (ch === '{' || ch === '[')) {\n        const candidate = text.slice(i, lastBrace + 1).trim();\n        try {\n          JSON.parse(candidate);\n          return candidate;\n        } catch {\n          return null;\n        }\n      }\n    }\n    return null;\n  }\n\n  // Extract any balanced JSON object/array substring from anywhere in the text\n  private extractJsonAnywhere(text: string): string | null {\n    const n = text.length;\n    let best: string | null = null;\n    for (let i = 0; i < n; i++) {\n      const start = text[i];\n      if (start !== '{' && start !== '[') continue;\n      let open = 0;\n      let inString = false;\n      let escape = false;\n      for (let j = i; j < n; j++) {\n        const ch = text[j];\n        if (escape) {\n          escape = false;\n          continue;\n        }\n        if (ch === '\\\\') {\n          escape = true;\n          continue;\n        }\n        if (ch === '\"') {\n          inString = !inString;\n          continue;\n        }\n        if (inString) continue;\n        if (ch === '{' || ch === '[') open++;\n        else if (ch === '}' || ch === ']') open--;\n        if (open === 0 && (ch === '}' || ch === ']')) {\n          const candidate = text.slice(i, j + 1).trim();\n          try {\n            JSON.parse(candidate);\n            best = candidate; // keep the last valid one we find\n          } catch {\n            // Try a loose-to-strict conversion (quote keys and barewords)\n            const strict = this.looseJsonToStrict(candidate);\n            if (strict) {\n              try {\n                JSON.parse(strict);\n                best = strict;\n              } catch {}\n            }\n          }\n          break;\n        }\n      }\n    }\n    return best;\n  }\n\n  // Best-effort conversion of object-literal-like strings to strict JSON\n  private looseJsonToStrict(candidate: string): string | null {\n    try {\n      let s = candidate.trim();\n      // Convert single quotes to double quotes conservatively\n      s = s.replace(/'/g, '\"');\n      // Quote unquoted keys: {key: ...} or ,key: ...\n      s = s.replace(/([\\{,]\\s*)([A-Za-z_][A-Za-z0-9_-]*)\\s*:/g, '$1\"$2\":');\n      // Quote bareword values except true/false/null and numbers\n      s = s.replace(/:\\s*([A-Za-z_][A-Za-z0-9_-]*)\\s*(?=[,}])/g, (m, word) => {\n        const lw = String(word).toLowerCase();\n        if (lw === 'true' || lw === 'false' || lw === 'null') return `:${lw}`;\n        return `:\"${word}\"`;\n      });\n      return s;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Recursively apply JSON-smart wrapper to outputs object values\n   */\n  private makeOutputsJsonSmart(outputs: Record<string, unknown>): Record<string, unknown> {\n    const wrapped: Record<string, unknown> = {};\n    for (const [k, v] of Object.entries(outputs || {})) {\n      wrapped[k] = this.makeJsonSmart(v);\n    }\n    return wrapped;\n  }\n\n  private getSafeEnvironmentVariables(): Record<string, string> {\n    const safeVars: Record<string, string> = {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const allowedPrefixes: string[] = []; // replaced by buildSandboxEnv\n\n    const { buildSandboxEnv } = require('../utils/env-exposure');\n    const merged = buildSandboxEnv(process.env);\n    for (const [key, value] of Object.entries(merged)) {\n      safeVars[key] = String(value);\n    }\n\n    // Add current working directory\n    safeVars['PWD'] = process.cwd();\n\n    return safeVars;\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'exec',\n      'transform',\n      'transform_js',\n      'env',\n      'timeout',\n      'depends_on',\n      'on',\n      'if',\n      'group',\n      'forEach',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // Command provider is always available as long as we can execute commands\n    return true;\n  }\n\n  getRequirements(): string[] {\n    return [\n      'Valid shell command to execute',\n      'Shell environment available',\n      'Optional: Transform template for processing output',\n    ];\n  }\n\n  private extractIssuesFromOutput(\n    output: unknown\n  ): { issues: ReviewIssue[]; remainingOutput: unknown } | null {\n    try {\n      logger.info(\n        `  extractIssuesFromOutput: typeof=${Array.isArray(output) ? 'array' : typeof output}`\n      );\n      if (typeof output === 'object' && output) {\n        const rec = output as Record<string, unknown>;\n        logger.info(\n          `  extractIssuesFromOutput: keys=${Object.keys(rec).join(',')} issuesIsArray=${Array.isArray(\n            (rec as any).issues\n          )}`\n        );\n      }\n    } catch {}\n    if (output === null || output === undefined) {\n      return null;\n    }\n\n    // If output is already a string, do not treat it as issues here (caller may try parsing JSON)\n    if (typeof output === 'string') {\n      return null;\n    }\n\n    if (Array.isArray(output)) {\n      // Two supported shapes:\n      //  1) Array<ReviewIssue-like>\n      //  2) Array<{ issues: Array<ReviewIssue-like> }>\n      const first = output[0];\n      if (\n        first &&\n        typeof first === 'object' &&\n        !Array.isArray((first as any).message) &&\n        Array.isArray((first as any).issues)\n      ) {\n        // flatten nested issues arrays\n        const merged: unknown[] = [];\n        for (const el of output as unknown[]) {\n          if (el && typeof el === 'object' && Array.isArray((el as any).issues)) {\n            merged.push(...((el as any).issues as unknown[]));\n          }\n        }\n        const flat = this.normalizeIssueArray(merged);\n        if (flat) return { issues: flat, remainingOutput: undefined };\n      } else {\n        const issues = this.normalizeIssueArray(output);\n        if (issues) {\n          return { issues, remainingOutput: undefined };\n        }\n      }\n      return null;\n    }\n\n    if (typeof output === 'object') {\n      const record = output as Record<string, unknown>;\n\n      if (Array.isArray(record.issues)) {\n        const issues = this.normalizeIssueArray(record.issues);\n        if (!issues) {\n          return null;\n        }\n\n        const remaining = { ...record };\n        delete (remaining as { issues?: unknown }).issues;\n\n        const remainingKeys = Object.keys(remaining);\n        const remainingOutput = remainingKeys.length > 0 ? remaining : undefined;\n\n        return {\n          issues,\n          remainingOutput,\n        };\n      }\n\n      const singleIssue = this.normalizeIssue(record);\n      if (singleIssue) {\n        return { issues: [singleIssue], remainingOutput: undefined };\n      }\n    }\n\n    return null;\n  }\n\n  private shouldTreatAsTextOutput(value?: string): value is string {\n    if (!value) {\n      return false;\n    }\n\n    const trimmed = value.trim();\n    if (!trimmed) {\n      return false;\n    }\n\n    // Heuristic: consider it JSON-like if it starts with { or [ and ends with } or ]\n    const startsJson =\n      (trimmed.startsWith('{') && trimmed.endsWith('}')) ||\n      (trimmed.startsWith('[') && trimmed.endsWith(']'));\n\n    return !startsJson;\n  }\n\n  private normalizeIssueArray(values: unknown[]): ReviewIssue[] | null {\n    const normalized: ReviewIssue[] = [];\n\n    for (const value of values) {\n      const issue = this.normalizeIssue(value);\n      if (!issue) {\n        return null;\n      }\n      normalized.push(issue);\n    }\n\n    return normalized;\n  }\n\n  private normalizeIssue(raw: unknown): ReviewIssue | null {\n    if (!raw || typeof raw !== 'object') {\n      return null;\n    }\n\n    const data = raw as Record<string, unknown>;\n\n    const message = this.toTrimmedString(\n      data.message || data.text || data.description || data.summary\n    );\n    if (!message) {\n      return null;\n    }\n\n    const allowedSeverities = new Set(['info', 'warning', 'error', 'critical']);\n    const severityRaw = this.toTrimmedString(data.severity || data.level || data.priority);\n    let severity: ReviewIssue['severity'] = 'warning';\n    if (severityRaw) {\n      const lower = severityRaw.toLowerCase();\n      if (allowedSeverities.has(lower)) {\n        severity = lower as ReviewIssue['severity'];\n      } else if (['fatal', 'high'].includes(lower)) {\n        severity = 'error';\n      } else if (['medium', 'moderate'].includes(lower)) {\n        severity = 'warning';\n      } else if (['low', 'minor'].includes(lower)) {\n        severity = 'info';\n      }\n    }\n\n    const allowedCategories = new Set([\n      'security',\n      'performance',\n      'style',\n      'logic',\n      'documentation',\n    ]);\n    const categoryRaw = this.toTrimmedString(data.category || data.type || data.group);\n    let category: ReviewIssue['category'] = 'logic';\n    if (categoryRaw && allowedCategories.has(categoryRaw.toLowerCase())) {\n      category = categoryRaw.toLowerCase() as ReviewIssue['category'];\n    }\n\n    const file = this.toTrimmedString(data.file || data.path || data.filename) || 'system';\n\n    const line = this.toNumber(data.line || data.startLine || data.lineNumber) ?? 0;\n    const endLine = this.toNumber(data.endLine || data.end_line || data.stopLine);\n\n    const suggestion = this.toTrimmedString(data.suggestion);\n    const replacement = this.toTrimmedString(data.replacement);\n\n    const ruleId =\n      this.toTrimmedString(data.ruleId || data.rule || data.id || data.check) || 'command';\n\n    return {\n      file,\n      line,\n      endLine: endLine ?? undefined,\n      ruleId,\n      message,\n      severity,\n      category,\n      suggestion: suggestion || undefined,\n      replacement: replacement || undefined,\n    };\n  }\n\n  private toTrimmedString(value: unknown): string | null {\n    if (typeof value === 'string') {\n      const trimmed = value.trim();\n      return trimmed.length > 0 ? trimmed : null;\n    }\n    if (value !== null && value !== undefined && typeof value.toString === 'function') {\n      const converted = String(value).trim();\n      return converted.length > 0 ? converted : null;\n    }\n    return null;\n  }\n\n  private toNumber(value: unknown): number | null {\n    if (value === null || value === undefined) {\n      return null;\n    }\n    const num = Number(value);\n    if (Number.isFinite(num)) {\n      return Math.trunc(num);\n    }\n    return null;\n  }\n\n  private async renderCommandTemplate(\n    template: string,\n    context: {\n      pr: Record<string, unknown>;\n      files: unknown[];\n      outputs: Record<string, unknown>;\n      env: Record<string, string>;\n    }\n  ): Promise<string> {\n    try {\n      // Best-effort compatibility: allow double-quoted bracket keys inside Liquid tags.\n      // e.g., {{ outputs[\"fetch-tickets\"].key }} → {{ outputs['fetch-tickets'].key }}\n      let tpl = template;\n      if (tpl.includes('{{')) {\n        tpl = tpl.replace(/\\{\\{([\\s\\S]*?)\\}\\}/g, (_m, inner) => {\n          const fixed = String(inner).replace(/\\[\\\"/g, \"['\").replace(/\\\"\\]/g, \"']\");\n          return `{{ ${fixed} }}`;\n        });\n      }\n      let rendered = await this.liquid.parseAndRender(tpl, context);\n      // If Liquid left unresolved tags (common when users write JS expressions inside {{ }}),\n      // fall back to a safe JS-expression renderer for the remaining tags.\n      if (/\\{\\{[\\s\\S]*?\\}\\}/.test(rendered)) {\n        try {\n          rendered = this.renderWithJsExpressions(rendered, context);\n        } catch {\n          // keep Liquid-rendered result as-is\n        }\n      }\n      return rendered;\n    } catch (error) {\n      logger.debug(`🔧 Debug: Liquid templating failed, trying JS-expression fallback: ${error}`);\n      try {\n        return this.renderWithJsExpressions(template, context);\n      } catch {\n        return template;\n      }\n    }\n  }\n\n  private renderWithJsExpressions(\n    template: string,\n    context: {\n      pr: Record<string, unknown>;\n      files: unknown[];\n      outputs: Record<string, unknown>;\n      env: Record<string, string>;\n    }\n  ): string {\n    const scope = {\n      pr: context.pr,\n      files: context.files,\n      outputs: context.outputs,\n      env: context.env,\n    };\n\n    const expressionRegex = /\\{\\{\\s*([^{}]+?)\\s*\\}\\}/g;\n    return template.replace(expressionRegex, (_match, expr) => {\n      const expression = String(expr).trim();\n      if (!expression) return '';\n      try {\n        const evalCode = `\n          const pr = scope.pr;\n          const files = scope.files;\n          const outputs = scope.outputs;\n          const env = scope.env;\n          return (${expression});\n        `;\n        if (!this.sandbox) this.sandbox = this.createSecureSandbox();\n        const evaluator = this.sandbox.compile(evalCode);\n        const result = evaluator({ scope }).run();\n        return result === undefined || result === null ? '' : String(result);\n      } catch {\n        return '';\n      }\n    });\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { MemoryStore } from '../memory-store';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { logger } from '../logger';\nimport Sandbox from '@nyariv/sandboxjs';\nimport { createSecureSandbox, compileAndRun } from '../utils/sandbox';\n\n/**\n * Memory operation types\n */\nexport type MemoryOperation =\n  | 'get'\n  | 'set'\n  | 'append'\n  | 'increment'\n  | 'delete'\n  | 'clear'\n  | 'list'\n  | 'exec_js';\n\n/**\n * Check provider for memory/state management\n * Supports in-memory and persistent storage with namespace isolation\n */\nexport class MemoryCheckProvider extends CheckProvider {\n  private liquid: Liquid;\n  private sandbox?: Sandbox;\n\n  constructor() {\n    super();\n    this.liquid = createExtendedLiquid({\n      strictVariables: false,\n      strictFilters: false,\n    });\n  }\n\n  /**\n   * Create a secure sandbox for JavaScript execution\n   */\n  private createSecureSandbox(): Sandbox {\n    return createSecureSandbox();\n  }\n\n  getName(): string {\n    return 'memory';\n  }\n\n  getDescription(): string {\n    return 'Memory/state management provider for persistent key-value storage across checks';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'memory'\n    if (cfg.type !== 'memory') {\n      return false;\n    }\n\n    // Operation is required\n    if (!cfg.operation || typeof cfg.operation !== 'string') {\n      return false;\n    }\n\n    const operation = cfg.operation as string;\n    const validOps = ['get', 'set', 'append', 'increment', 'delete', 'clear', 'list', 'exec_js'];\n    if (!validOps.includes(operation)) {\n      return false;\n    }\n\n    // Key is required for get, set, append, increment, delete\n    if (['get', 'set', 'append', 'increment', 'delete'].includes(operation)) {\n      if (!cfg.key || typeof cfg.key !== 'string') {\n        return false;\n      }\n    }\n\n    // Value or value_js is required for set and append\n    if (['set', 'append'].includes(operation)) {\n      if (cfg.value === undefined && !cfg.value_js) {\n        return false;\n      }\n    }\n\n    // exec_js requires memory_js\n    if (operation === 'exec_js') {\n      if (!cfg.memory_js || typeof cfg.memory_js !== 'string') {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>,\n    _sessionInfo?: { parentSessionId?: string; reuseSession?: boolean }\n  ): Promise<ReviewSummary> {\n    const operation = config.operation as MemoryOperation;\n    const key = config.key as string | undefined;\n    const namespace = config.namespace as string | undefined;\n\n    // Get memory store instance\n    const memoryStore = MemoryStore.getInstance();\n\n    // Build template context for value computation\n    const templateContext = this.buildTemplateContext(\n      prInfo,\n      dependencyResults,\n      memoryStore,\n      config.__outputHistory as Map<string, unknown[]> | undefined\n    );\n\n    let result: unknown;\n\n    try {\n      switch (operation) {\n        case 'get':\n          result = await this.handleGet(memoryStore, key!, namespace);\n          break;\n        case 'set':\n          result = await this.handleSet(memoryStore, key!, config, namespace, templateContext);\n          break;\n        case 'append':\n          result = await this.handleAppend(memoryStore, key!, config, namespace, templateContext);\n          break;\n        case 'increment':\n          result = await this.handleIncrement(\n            memoryStore,\n            key!,\n            config,\n            namespace,\n            templateContext\n          );\n          break;\n        case 'delete':\n          result = await this.handleDelete(memoryStore, key!, namespace);\n          break;\n        case 'clear':\n          result = await this.handleClear(memoryStore, namespace);\n          break;\n        case 'list':\n          result = await this.handleList(memoryStore, namespace);\n          break;\n        case 'exec_js':\n          result = await this.handleExecJs(memoryStore, config, templateContext);\n          break;\n        default:\n          throw new Error(`Unknown memory operation: ${operation}`);\n      }\n\n      // Return result as output\n      return {\n        issues: [],\n        output: result,\n      } as ReviewSummary & { output: unknown };\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : 'Unknown error in memory operation';\n      logger.error(`Memory operation failed: ${errorMsg}`);\n\n      return {\n        issues: [],\n        output: null,\n        error: errorMsg,\n      } as ReviewSummary & { output: null; error: string };\n    }\n  }\n\n  private async handleGet(store: MemoryStore, key: string, namespace?: string): Promise<unknown> {\n    const value = store.get(key, namespace);\n    logger.debug(\n      `Memory GET: ${namespace || store.getDefaultNamespace()}.${key} = ${JSON.stringify(value)}`\n    );\n    return value;\n  }\n\n  private async handleSet(\n    store: MemoryStore,\n    key: string,\n    config: CheckProviderConfig,\n    namespace: string | undefined,\n    context: Record<string, unknown>\n  ): Promise<unknown> {\n    const value = await this.computeValue(config, context);\n    await store.set(key, value, namespace);\n    logger.debug(\n      `Memory SET: ${namespace || store.getDefaultNamespace()}.${key} = ${JSON.stringify(value)}`\n    );\n    return value;\n  }\n\n  private async handleAppend(\n    store: MemoryStore,\n    key: string,\n    config: CheckProviderConfig,\n    namespace: string | undefined,\n    context: Record<string, unknown>\n  ): Promise<unknown> {\n    const value = await this.computeValue(config, context);\n    await store.append(key, value, namespace);\n    const result = store.get(key, namespace);\n    logger.debug(\n      `Memory APPEND: ${namespace || store.getDefaultNamespace()}.${key} += ${JSON.stringify(value)} (now: ${JSON.stringify(result)})`\n    );\n    return result;\n  }\n\n  private async handleIncrement(\n    store: MemoryStore,\n    key: string,\n    config: CheckProviderConfig,\n    namespace: string | undefined,\n    context: Record<string, unknown>\n  ): Promise<number> {\n    // Compute amount - default to 1 if not specified\n    let amount = 1;\n    if (config.value !== undefined || config.value_js) {\n      const computedValue = await this.computeValue(config, context);\n      if (typeof computedValue === 'number') {\n        amount = computedValue;\n      } else {\n        throw new Error(`Increment amount must be a number, got ${typeof computedValue}`);\n      }\n    }\n\n    const result = await store.increment(key, amount, namespace);\n    logger.debug(\n      `Memory INCREMENT: ${namespace || store.getDefaultNamespace()}.${key} += ${amount} (now: ${result})`\n    );\n    return result;\n  }\n\n  private async handleDelete(\n    store: MemoryStore,\n    key: string,\n    namespace?: string\n  ): Promise<boolean> {\n    const deleted = await store.delete(key, namespace);\n    logger.debug(\n      `Memory DELETE: ${namespace || store.getDefaultNamespace()}.${key} (deleted: ${deleted})`\n    );\n    return deleted;\n  }\n\n  private async handleClear(store: MemoryStore, namespace?: string): Promise<void> {\n    await store.clear(namespace);\n    logger.debug(`Memory CLEAR: ${namespace ? `namespace ${namespace}` : 'all namespaces'}`);\n  }\n\n  private async handleList(store: MemoryStore, namespace?: string): Promise<string[]> {\n    const keys = store.list(namespace);\n    logger.debug(`Memory LIST: ${namespace || store.getDefaultNamespace()} (${keys.length} keys)`);\n    return keys;\n  }\n\n  private async handleExecJs(\n    store: MemoryStore,\n    config: CheckProviderConfig,\n    context: Record<string, unknown>\n  ): Promise<unknown> {\n    const script = config.memory_js as string;\n\n    // Track operations that need to be saved\n    const pendingOps: Array<() => Promise<void>> = [];\n\n    // Create enhanced context with memory operations\n    // Note: These operations are synchronous for simplicity in scripts\n    // The actual async save happens after script execution\n    const enhancedContext = {\n      ...context,\n      memory: {\n        get: (key: string, ns?: string) => store.get(key, ns),\n        set: (key: string, value: unknown, ns?: string) => {\n          // Store operation synchronously in memory\n          const nsName = ns || store.getDefaultNamespace();\n          if (!store['data'].has(nsName)) {\n            store['data'].set(nsName, new Map());\n          }\n          store['data'].get(nsName)!.set(key, value);\n          // Queue async save for later\n          pendingOps.push(async () => {\n            if (store.getConfig().storage === 'file' && store.getConfig().auto_save) {\n              await store.save();\n            }\n          });\n          return value;\n        },\n        append: (key: string, value: unknown, ns?: string) => {\n          const existing = store.get(key, ns);\n          let newValue: unknown[];\n          if (existing === undefined) {\n            newValue = [value];\n          } else if (Array.isArray(existing)) {\n            newValue = [...existing, value];\n          } else {\n            newValue = [existing, value];\n          }\n          // Use sync set\n          const nsName = ns || store.getDefaultNamespace();\n          if (!store['data'].has(nsName)) {\n            store['data'].set(nsName, new Map());\n          }\n          store['data'].get(nsName)!.set(key, newValue);\n          // Queue async save\n          pendingOps.push(async () => {\n            if (store.getConfig().storage === 'file' && store.getConfig().auto_save) {\n              await store.save();\n            }\n          });\n          return newValue;\n        },\n        increment: (key: string, amount = 1, ns?: string) => {\n          const existing = store.get(key, ns);\n          let newValue: number;\n          if (existing === undefined || existing === null) {\n            newValue = amount;\n          } else if (typeof existing === 'number') {\n            newValue = existing + amount;\n          } else {\n            throw new Error(\n              `Cannot increment non-numeric value at key '${key}' (type: ${typeof existing})`\n            );\n          }\n          // Use sync set\n          const nsName = ns || store.getDefaultNamespace();\n          if (!store['data'].has(nsName)) {\n            store['data'].set(nsName, new Map());\n          }\n          store['data'].get(nsName)!.set(key, newValue);\n          // Queue async save\n          pendingOps.push(async () => {\n            if (store.getConfig().storage === 'file' && store.getConfig().auto_save) {\n              await store.save();\n            }\n          });\n          return newValue;\n        },\n        delete: (key: string, ns?: string) => {\n          const nsName = ns || store.getDefaultNamespace();\n          const nsData = store['data'].get(nsName);\n          const deleted = nsData?.delete(key) || false;\n          // Queue async save\n          if (deleted) {\n            pendingOps.push(async () => {\n              if (store.getConfig().storage === 'file' && store.getConfig().auto_save) {\n                await store.save();\n              }\n            });\n          }\n          return deleted;\n        },\n        clear: (ns?: string) => {\n          if (ns) {\n            store['data'].delete(ns);\n          } else {\n            store['data'].clear();\n          }\n          // Queue async save\n          pendingOps.push(async () => {\n            if (store.getConfig().storage === 'file' && store.getConfig().auto_save) {\n              await store.save();\n            }\n          });\n        },\n        list: (ns?: string) => store.list(ns),\n        has: (key: string, ns?: string) => store.has(key, ns),\n        getAll: (ns?: string) => store.getAll(ns),\n        listNamespaces: () => store.listNamespaces(),\n      },\n    };\n\n    try {\n      if (\n        (config as any).checkName === 'aggregate-validations' ||\n        (config as any).checkName === 'aggregate' ||\n        (config as any).checkName === 'aggregate'\n      ) {\n        const hist = (enhancedContext as any)?.outputs?.history || {};\n        const keys = Object.keys(hist);\n        console.log('[MemoryProvider]', (config as any).checkName, ': history keys =', keys);\n        const vf = (hist as any)['validate-fact'];\n        console.log(\n          '[MemoryProvider]',\n          (config as any).checkName,\n          ': validate-fact history length =',\n          Array.isArray(vf) ? vf.length : 'n/a'\n        );\n      }\n    } catch {}\n\n    const result = this.evaluateJavaScriptBlock(script, enhancedContext);\n    try {\n      if ((config as any).checkName === 'aggregate-validations') {\n        const tv = store.get('total_validations', 'fact-validation');\n        const av = store.get('all_valid', 'fact-validation');\n        console.error(\n          '[MemoryProvider] post-exec',\n          (config as any).checkName,\n          'total_validations=',\n          tv,\n          'all_valid=',\n          av\n        );\n      }\n    } catch {}\n\n    // Execute pending async operations\n    if (\n      pendingOps.length > 0 &&\n      store.getConfig().storage === 'file' &&\n      store.getConfig().auto_save\n    ) {\n      // Only save once after all operations\n      await store.save();\n    }\n\n    logger.debug(`Memory EXEC_JS: Executed custom script with ${pendingOps.length} operations`);\n    return result;\n  }\n\n  /**\n   * Compute value from config using value, value_js, transform, or transform_js\n   */\n  private async computeValue(\n    config: CheckProviderConfig,\n    context: Record<string, unknown>\n  ): Promise<unknown> {\n    let value: unknown;\n\n    // Start with direct value or value_js\n    if (config.value_js && typeof config.value_js === 'string') {\n      value = this.evaluateJavaScript(config.value_js, context);\n    } else {\n      value = config.value;\n    }\n\n    // Apply transform template if provided\n    if (config.transform && typeof config.transform === 'string') {\n      const rendered = await this.liquid.parseAndRender(config.transform, {\n        ...context,\n        value,\n      });\n      value = rendered;\n    }\n\n    // Apply transform_js if provided\n    if (config.transform_js && typeof config.transform_js === 'string') {\n      value = this.evaluateJavaScript(config.transform_js, { ...context, value });\n    }\n\n    return value;\n  }\n\n  /**\n   * Evaluate JavaScript expression in context using SandboxJS for secure execution\n   */\n  private evaluateJavaScript(expression: string, context: Record<string, unknown>): unknown {\n    if (!this.sandbox) {\n      this.sandbox = this.createSecureSandbox();\n    }\n\n    try {\n      const scope: Record<string, unknown> = { ...context };\n      return compileAndRun<unknown>(this.sandbox, `return (${expression});`, scope, {\n        injectLog: true,\n        wrapFunction: false,\n        logPrefix: '[memory:value_js]',\n      });\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : 'Unknown error';\n      throw new Error(`Failed to evaluate value_js: ${errorMsg}`);\n    }\n  }\n\n  /**\n   * Evaluate JavaScript block (multi-line script) using SandboxJS for secure execution\n   * Unlike evaluateJavaScript, this supports full scripts with statements, not just expressions\n   */\n  private evaluateJavaScriptBlock(script: string, context: Record<string, unknown>): unknown {\n    if (!this.sandbox) {\n      this.sandbox = this.createSecureSandbox();\n    }\n\n    try {\n      const scope: Record<string, unknown> = { ...context };\n      return compileAndRun<unknown>(this.sandbox, script, scope, {\n        injectLog: true,\n        wrapFunction: false,\n        logPrefix: '[memory:exec_js]',\n      });\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : 'Unknown error';\n      logger.error(`[memory-js] Script execution error: ${errorMsg}`);\n      throw new Error(`Failed to execute memory_js: ${errorMsg}`);\n    }\n  }\n\n  /**\n   * Build template context for Liquid and JS evaluation\n   */\n  private buildTemplateContext(\n    prInfo: PRInfo,\n    dependencyResults?: Map<string, ReviewSummary>,\n    memoryStore?: MemoryStore,\n    outputHistory?: Map<string, unknown[]>\n  ): Record<string, unknown> {\n    const context: Record<string, unknown> = {};\n\n    // Add PR context\n    context.pr = {\n      number: prInfo.number,\n      title: prInfo.title,\n      body: prInfo.body,\n      author: prInfo.author,\n      base: prInfo.base,\n      head: prInfo.head,\n      totalAdditions: prInfo.totalAdditions,\n      totalDeletions: prInfo.totalDeletions,\n      files: prInfo.files.map(f => ({\n        filename: f.filename,\n        status: f.status,\n        additions: f.additions,\n        deletions: f.deletions,\n        changes: f.changes,\n      })),\n    };\n\n    // Add dependency outputs - always create outputs object even if no dependencies\n    const outputs: Record<string, unknown> = {};\n    const outputsRaw: Record<string, unknown> = {};\n    const history: Record<string, unknown[]> = {};\n\n    if (dependencyResults) {\n      for (const [checkName, result] of dependencyResults.entries()) {\n        // Defensive: some callers may accidentally provide non-string keys\n        if (typeof checkName !== 'string') continue;\n        const summary = result as ReviewSummary & { output?: unknown };\n        if (typeof checkName === 'string' && checkName.endsWith('-raw')) {\n          const name = checkName.slice(0, -4);\n          outputsRaw[name] = summary.output !== undefined ? summary.output : summary;\n        } else {\n          outputs[checkName] = summary.output !== undefined ? summary.output : summary;\n        }\n      }\n    }\n\n    // Add history for each check if available\n    if (outputHistory) {\n      for (const [checkName, historyArray] of outputHistory) {\n        history[checkName] = historyArray;\n      }\n    }\n\n    // Attach history to the outputs object\n    (outputs as any).history = history;\n\n    context.outputs = outputs;\n    // Alias for consistency: outputs_history mirrors outputs.history\n    (context as any).outputs_history = history;\n    // New: outputs_raw exposes aggregate values for forEach parents\n    (context as any).outputs_raw = outputsRaw;\n\n    // Add memory accessor\n    if (memoryStore) {\n      context.memory = {\n        get: (key: string, ns?: string) => memoryStore.get(key, ns),\n        has: (key: string, ns?: string) => memoryStore.has(key, ns),\n        list: (ns?: string) => memoryStore.list(ns),\n        getAll: (ns?: string) => memoryStore.getAll(ns),\n        set: (key: string, value: unknown, ns?: string) => {\n          const nsName = ns || memoryStore.getDefaultNamespace();\n          if (!(memoryStore as any)['data'].has(nsName)) {\n            (memoryStore as any)['data'].set(nsName, new Map());\n          }\n          (memoryStore as any)['data'].get(nsName)!.set(key, value);\n          return true;\n        },\n        increment: (key: string, amount: number = 1, ns?: string) => {\n          const nsName = ns || memoryStore.getDefaultNamespace();\n          const current = memoryStore.get(key, nsName);\n          const numCurrent = typeof current === 'number' ? (current as number) : 0;\n          const newValue = numCurrent + amount;\n          if (!(memoryStore as any)['data'].has(nsName)) {\n            (memoryStore as any)['data'].set(nsName, new Map());\n          }\n          (memoryStore as any)['data'].get(nsName)!.set(key, newValue);\n          return newValue;\n        },\n      } as Record<string, unknown>;\n    }\n\n    // SECURITY: Do NOT expose process.env to user-controlled scripts\n    // Removed: context.env = process.env;\n    // Environment variables, especially secrets like GITHUB_TOKEN, must not be\n    // accessible to scripts defined in .visor.yaml as this would allow credential theft\n\n    return context;\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'operation',\n      'key',\n      'value',\n      'value_js',\n      'memory_js',\n      'transform',\n      'transform_js',\n      'namespace',\n      'depends_on',\n      'group',\n      'command',\n      'on',\n      'if',\n      'fail_if',\n      'on_fail',\n      'on_success',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // Memory provider is always available\n    return true;\n  }\n\n  getRequirements(): string[] {\n    return [\n      'No external dependencies required',\n      'Used for state management and persistent storage across checks',\n    ];\n  }\n}\n","import { CheckProvider, CheckProviderConfig } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary, ReviewIssue } from '../reviewer';\nimport { logger } from '../logger';\nimport { Liquid } from 'liquidjs';\nimport { createExtendedLiquid } from '../liquid-extensions';\nimport { Client } from '@modelcontextprotocol/sdk/client/index.js';\nimport { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';\nimport { SSEClientTransport } from '@modelcontextprotocol/sdk/client/sse.js';\nimport { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js';\nimport Sandbox from '@nyariv/sandboxjs';\nimport { createSecureSandbox, compileAndRun } from '../utils/sandbox';\nimport { EnvironmentResolver } from '../utils/env-resolver';\n\n/**\n * MCP Check Provider Configuration\n */\nexport interface McpCheckConfig extends CheckProviderConfig {\n  /** Transport type: stdio (default), sse (legacy), or http (streamable HTTP) */\n  transport?: 'stdio' | 'sse' | 'http';\n  /** Command to execute (for stdio transport) */\n  command?: string;\n  /** Command arguments (for stdio transport) */\n  args?: string[];\n  /** Environment variables (for stdio transport) */\n  env?: Record<string, string>;\n  /** Working directory (for stdio transport) */\n  workingDirectory?: string;\n  /** URL for SSE/HTTP transport */\n  url?: string;\n  /** HTTP headers (for SSE/HTTP transport) */\n  headers?: Record<string, string>;\n  /** Session ID for HTTP transport (optional, server may generate one) */\n  sessionId?: string;\n  /** MCP method/tool to call */\n  method: string;\n  /** Arguments to pass to the MCP method (supports Liquid templates) */\n  methodArgs?: Record<string, unknown>;\n  /** Transform template for method arguments (Liquid) */\n  argsTransform?: string;\n  /** Transform template for output (Liquid) */\n  transform?: string;\n  /** Transform using JavaScript expressions */\n  transform_js?: string;\n  /** Timeout in seconds */\n  timeout?: number;\n}\n\n/**\n * Check provider that calls MCP tools directly\n * Supports stdio, SSE (legacy), and Streamable HTTP transports\n */\nexport class McpCheckProvider extends CheckProvider {\n  private liquid: Liquid;\n  private sandbox?: Sandbox;\n\n  constructor() {\n    super();\n    this.liquid = createExtendedLiquid({\n      cache: false,\n      strictFilters: false,\n      strictVariables: false,\n    });\n  }\n\n  /**\n   * Create a secure sandbox for JavaScript execution\n   * - Uses Sandbox.SAFE_GLOBALS which excludes: Function, eval, require, process, etc.\n   * - Only allows explicitly whitelisted prototype methods\n   * - No access to filesystem, network, or system resources\n   */\n  private createSecureSandbox(): Sandbox {\n    return createSecureSandbox();\n  }\n\n  getName(): string {\n    return 'mcp';\n  }\n\n  getDescription(): string {\n    return 'Call MCP tools directly using stdio, SSE, or Streamable HTTP transport';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as McpCheckConfig;\n\n    // Method is required\n    if (!cfg.method || typeof cfg.method !== 'string') {\n      logger.error('MCP check requires a method name');\n      return false;\n    }\n\n    const transport = cfg.transport || 'stdio';\n\n    // Validate transport-specific requirements\n    if (transport === 'stdio') {\n      if (!cfg.command || typeof cfg.command !== 'string') {\n        logger.error('MCP stdio transport requires a command');\n        return false;\n      }\n\n      // Basic command injection prevention - check for shell metacharacters\n      // Allow common safe commands like 'npx', 'node', 'python', etc.\n      if (/[;&|`$(){}[\\]]/.test(cfg.command)) {\n        logger.error('MCP stdio command contains potentially unsafe characters');\n        return false;\n      }\n    } else if (transport === 'sse' || transport === 'http') {\n      if (!cfg.url || typeof cfg.url !== 'string') {\n        logger.error(`MCP ${transport} transport requires a URL`);\n        return false;\n      }\n\n      // Validate URL format\n      try {\n        const parsedUrl = new URL(cfg.url);\n        // Only allow http and https protocols\n        if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {\n          logger.error(\n            `Invalid URL protocol for MCP ${transport} transport: ${parsedUrl.protocol}. Only http: and https: are allowed.`\n          );\n          return false;\n        }\n      } catch {\n        logger.error(`Invalid URL format for MCP ${transport} transport: ${cfg.url}`);\n        return false;\n      }\n    } else {\n      logger.error(`Invalid MCP transport: ${transport}. Must be 'stdio', 'sse', or 'http'`);\n      return false;\n    }\n\n    return true;\n  }\n\n  async execute(\n    prInfo: PRInfo,\n    config: CheckProviderConfig,\n    dependencyResults?: Map<string, ReviewSummary>\n  ): Promise<ReviewSummary> {\n    const cfg = config as McpCheckConfig;\n\n    try {\n      // Prepare template context\n      const templateContext = {\n        pr: {\n          number: prInfo.number,\n          title: prInfo.title,\n          author: prInfo.author,\n          branch: prInfo.head,\n          base: prInfo.base,\n        },\n        files: prInfo.files,\n        fileCount: prInfo.files.length,\n        outputs: this.buildOutputContext(dependencyResults),\n        env: this.getSafeEnvironmentVariables(),\n      };\n\n      // Render method arguments if needed\n      let methodArgs = cfg.methodArgs || {};\n      if (cfg.argsTransform) {\n        const rendered = await this.liquid.parseAndRender(cfg.argsTransform, templateContext);\n        try {\n          methodArgs = JSON.parse(rendered);\n        } catch (error) {\n          logger.error(`Failed to parse argsTransform as JSON: ${error}`);\n          return {\n            issues: [\n              {\n                file: 'mcp',\n                line: 0,\n                ruleId: 'mcp/args_transform_error',\n                message: `Failed to parse argsTransform: ${error instanceof Error ? error.message : 'Unknown error'}`,\n                severity: 'error',\n                category: 'logic',\n              },\n            ],\n          };\n        }\n      }\n\n      // Create MCP client and execute method\n      const result = await this.executeMcpMethod(cfg, methodArgs);\n\n      // Apply transforms if specified\n      let finalOutput = result;\n\n      // Apply Liquid transform\n      if (cfg.transform) {\n        try {\n          const transformContext = {\n            ...templateContext,\n            output: result,\n          };\n          const rendered = await this.liquid.parseAndRender(cfg.transform, transformContext);\n          try {\n            finalOutput = JSON.parse(rendered.trim());\n          } catch {\n            finalOutput = rendered.trim();\n          }\n        } catch (error) {\n          logger.error(`Failed to apply Liquid transform: ${error}`);\n          return {\n            issues: [\n              {\n                file: 'mcp',\n                line: 0,\n                ruleId: 'mcp/transform_error',\n                message: `Failed to apply transform: ${error instanceof Error ? error.message : 'Unknown error'}`,\n                severity: 'error',\n                category: 'logic',\n              },\n            ],\n          };\n        }\n      }\n\n      // Apply JavaScript transform using secure sandbox\n      if (cfg.transform_js) {\n        try {\n          if (!this.sandbox) {\n            this.sandbox = this.createSecureSandbox();\n          }\n\n          // Build scope with all context variables\n          const scope = {\n            output: finalOutput,\n            pr: templateContext.pr,\n            files: templateContext.files,\n            outputs: templateContext.outputs,\n            env: templateContext.env,\n          };\n\n          // Compile and execute the transform in sandboxed environment\n          finalOutput = compileAndRun<unknown>(\n            this.sandbox,\n            `return (${cfg.transform_js});`,\n            scope,\n            { injectLog: true, wrapFunction: false, logPrefix: '[mcp:transform_js]' }\n          );\n        } catch (error) {\n          logger.error(`Failed to apply JavaScript transform: ${error}`);\n          return {\n            issues: [\n              {\n                file: 'mcp',\n                line: 0,\n                ruleId: 'mcp/transform_js_error',\n                message: `Failed to apply JavaScript transform: ${error instanceof Error ? error.message : 'Unknown error'}`,\n                severity: 'error',\n                category: 'logic',\n              },\n            ],\n          };\n        }\n      }\n\n      // Extract issues from output\n      const extracted = this.extractIssuesFromOutput(finalOutput);\n      if (extracted) {\n        return {\n          issues: extracted.issues,\n          ...(extracted.remainingOutput ? { output: extracted.remainingOutput } : {}),\n        } as ReviewSummary;\n      }\n\n      // Return output directly\n      return {\n        issues: [],\n        ...(finalOutput ? { output: finalOutput } : {}),\n      } as ReviewSummary;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      logger.error(`MCP check failed: ${errorMessage}`);\n\n      return {\n        issues: [\n          {\n            file: 'mcp',\n            line: 0,\n            ruleId: 'mcp/execution_error',\n            message: `MCP check failed: ${errorMessage}`,\n            severity: 'error',\n            category: 'logic',\n          },\n        ],\n      };\n    }\n  }\n\n  /**\n   * Execute an MCP method using the configured transport\n   */\n  private async executeMcpMethod(\n    config: McpCheckConfig,\n    methodArgs: Record<string, unknown>\n  ): Promise<unknown> {\n    const transport = config.transport || 'stdio';\n    const timeout = (config.timeout || 60) * 1000; // Convert to milliseconds\n\n    if (transport === 'stdio') {\n      return await this.executeStdioMethod(config, methodArgs, timeout);\n    } else if (transport === 'sse') {\n      return await this.executeSseMethod(config, methodArgs, timeout);\n    } else if (transport === 'http') {\n      return await this.executeHttpMethod(config, methodArgs, timeout);\n    } else {\n      throw new Error(`Unsupported transport: ${transport}`);\n    }\n  }\n\n  /**\n   * Generic method to execute MCP method with any transport\n   */\n  private async executeWithTransport(\n    transport: StdioClientTransport | SSEClientTransport | StreamableHTTPClientTransport,\n    config: McpCheckConfig,\n    methodArgs: Record<string, unknown>,\n    timeout: number,\n    transportName: string\n  ): Promise<unknown> {\n    // Create client\n    const client = new Client(\n      {\n        name: 'visor-mcp-client',\n        version: '1.0.0',\n      },\n      {\n        capabilities: {},\n      }\n    );\n\n    try {\n      // Connect with timeout\n      let timeoutId: NodeJS.Timeout | undefined;\n      try {\n        await Promise.race([\n          client.connect(transport),\n          new Promise((_, reject) => {\n            timeoutId = setTimeout(() => reject(new Error('Connection timeout')), timeout);\n          }),\n        ]);\n      } finally {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n      }\n\n      logger.debug(`Connected to MCP server via ${transportName}`);\n\n      // Log session ID for HTTP transport\n      if (transport instanceof StreamableHTTPClientTransport && transport.sessionId) {\n        logger.debug(`MCP Session ID: ${transport.sessionId}`);\n      }\n\n      // List available tools (for debugging)\n      try {\n        const toolsResult = await client.listTools();\n        logger.debug(`Available MCP tools: ${JSON.stringify(toolsResult?.tools || [])}`);\n      } catch (error) {\n        logger.debug(`Could not list MCP tools: ${error}`);\n      }\n\n      // Call the tool with timeout\n      let callTimeoutId: NodeJS.Timeout | undefined;\n      try {\n        const result = await Promise.race([\n          client.callTool({\n            name: config.method,\n            arguments: methodArgs,\n          }),\n          new Promise((_, reject) => {\n            callTimeoutId = setTimeout(() => reject(new Error('Request timeout')), timeout);\n          }),\n        ]);\n\n        logger.debug(`MCP method result: ${JSON.stringify(result)}`);\n        return result;\n      } finally {\n        if (callTimeoutId) {\n          clearTimeout(callTimeoutId);\n        }\n      }\n    } finally {\n      try {\n        await client.close();\n      } catch (error) {\n        logger.debug(`Error closing MCP client: ${error}`);\n      }\n    }\n  }\n\n  /**\n   * Execute MCP method using stdio transport\n   */\n  private async executeStdioMethod(\n    config: McpCheckConfig,\n    methodArgs: Record<string, unknown>,\n    timeout: number\n  ): Promise<unknown> {\n    const transport = new StdioClientTransport({\n      command: config.command!,\n      args: config.args,\n      env: config.env,\n      cwd: config.workingDirectory,\n    });\n\n    return this.executeWithTransport(\n      transport,\n      config,\n      methodArgs,\n      timeout,\n      `stdio: ${config.command}`\n    );\n  }\n\n  /**\n   * Execute MCP method using SSE transport\n   */\n  private async executeSseMethod(\n    config: McpCheckConfig,\n    methodArgs: Record<string, unknown>,\n    timeout: number\n  ): Promise<unknown> {\n    const requestInit: RequestInit = {};\n    if (config.headers) {\n      requestInit.headers = EnvironmentResolver.resolveHeaders(config.headers);\n    }\n\n    const transport = new SSEClientTransport(new URL(config.url!), {\n      requestInit,\n    });\n\n    return this.executeWithTransport(transport, config, methodArgs, timeout, `SSE: ${config.url}`);\n  }\n\n  /**\n   * Execute MCP method using Streamable HTTP transport\n   */\n  private async executeHttpMethod(\n    config: McpCheckConfig,\n    methodArgs: Record<string, unknown>,\n    timeout: number\n  ): Promise<unknown> {\n    const requestInit: RequestInit = {};\n    if (config.headers) {\n      requestInit.headers = EnvironmentResolver.resolveHeaders(config.headers);\n    }\n\n    const transport = new StreamableHTTPClientTransport(new URL(config.url!), {\n      requestInit,\n      sessionId: config.sessionId,\n    });\n\n    return this.executeWithTransport(\n      transport,\n      config,\n      methodArgs,\n      timeout,\n      `Streamable HTTP: ${config.url}`\n    );\n  }\n\n  /**\n   * Build output context from dependency results\n   */\n  private buildOutputContext(\n    dependencyResults?: Map<string, ReviewSummary>\n  ): Record<string, unknown> {\n    if (!dependencyResults) {\n      return {};\n    }\n\n    const outputs: Record<string, unknown> = {};\n    for (const [checkName, result] of dependencyResults) {\n      const summary = result as ReviewSummary & { output?: unknown };\n      outputs[checkName] = summary.output !== undefined ? summary.output : summary;\n    }\n\n    return outputs;\n  }\n\n  /**\n   * Get safe environment variables\n   */\n  private getSafeEnvironmentVariables(): Record<string, string> {\n    const safeVars: Record<string, string> = {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const allowedPrefixes: string[] = []; // replaced by buildSandboxEnv\n\n    const { buildSandboxEnv } = require('../utils/env-exposure');\n    const merged = buildSandboxEnv(process.env);\n    for (const [key, value] of Object.entries(merged)) {\n      safeVars[key] = String(value);\n    }\n    safeVars['PWD'] = process.cwd();\n    return safeVars;\n  }\n\n  /**\n   * Extract issues from MCP output\n   */\n  private extractIssuesFromOutput(\n    output: unknown\n  ): { issues: ReviewIssue[]; remainingOutput: unknown } | null {\n    if (output === null || output === undefined) {\n      return null;\n    }\n\n    // If output is a string, try to parse as JSON\n    if (typeof output === 'string') {\n      try {\n        const parsed = JSON.parse(output);\n        return this.extractIssuesFromOutput(parsed);\n      } catch {\n        return null;\n      }\n    }\n\n    // If output is an array of issues\n    if (Array.isArray(output)) {\n      const issues = this.normalizeIssueArray(output);\n      if (issues) {\n        return { issues, remainingOutput: undefined };\n      }\n      return null;\n    }\n\n    // If output is an object with issues property\n    if (typeof output === 'object') {\n      const record = output as Record<string, unknown>;\n\n      if (Array.isArray(record.issues)) {\n        const issues = this.normalizeIssueArray(record.issues);\n        if (!issues) {\n          return null;\n        }\n\n        const remaining = { ...record };\n        delete (remaining as { issues?: unknown }).issues;\n\n        return {\n          issues,\n          remainingOutput: Object.keys(remaining).length > 0 ? remaining : undefined,\n        };\n      }\n\n      // Check if output itself is a single issue\n      const singleIssue = this.normalizeIssue(record);\n      if (singleIssue) {\n        return { issues: [singleIssue], remainingOutput: undefined };\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Normalize an array of issues\n   */\n  private normalizeIssueArray(values: unknown[]): ReviewIssue[] | null {\n    const normalized: ReviewIssue[] = [];\n\n    for (const value of values) {\n      const issue = this.normalizeIssue(value);\n      if (!issue) {\n        return null;\n      }\n      normalized.push(issue);\n    }\n\n    return normalized;\n  }\n\n  /**\n   * Normalize a single issue\n   */\n  private normalizeIssue(raw: unknown): ReviewIssue | null {\n    if (!raw || typeof raw !== 'object') {\n      return null;\n    }\n\n    const data = raw as Record<string, unknown>;\n\n    const message = this.toTrimmedString(\n      data.message || data.text || data.description || data.summary\n    );\n    if (!message) {\n      return null;\n    }\n\n    const allowedSeverities = new Set(['info', 'warning', 'error', 'critical']);\n    const severityRaw = this.toTrimmedString(data.severity || data.level || data.priority);\n    let severity: ReviewIssue['severity'] = 'warning';\n    if (severityRaw) {\n      const lower = severityRaw.toLowerCase();\n      if (allowedSeverities.has(lower)) {\n        severity = lower as ReviewIssue['severity'];\n      }\n    }\n\n    const allowedCategories = new Set([\n      'security',\n      'performance',\n      'style',\n      'logic',\n      'documentation',\n    ]);\n    const categoryRaw = this.toTrimmedString(data.category || data.type || data.group);\n    let category: ReviewIssue['category'] = 'logic';\n    if (categoryRaw && allowedCategories.has(categoryRaw.toLowerCase())) {\n      category = categoryRaw.toLowerCase() as ReviewIssue['category'];\n    }\n\n    const file = this.toTrimmedString(data.file || data.path || data.filename) || 'system';\n    const line = this.toNumber(data.line || data.startLine || data.lineNumber) ?? 0;\n    const endLine = this.toNumber(data.endLine || data.end_line || data.stopLine);\n    const suggestion = this.toTrimmedString(data.suggestion);\n    const replacement = this.toTrimmedString(data.replacement);\n    const ruleId = this.toTrimmedString(data.ruleId || data.rule || data.id || data.check) || 'mcp';\n\n    return {\n      file,\n      line,\n      endLine: endLine ?? undefined,\n      ruleId,\n      message,\n      severity,\n      category,\n      suggestion: suggestion || undefined,\n      replacement: replacement || undefined,\n    };\n  }\n\n  private toTrimmedString(value: unknown): string | null {\n    if (typeof value === 'string') {\n      const trimmed = value.trim();\n      return trimmed.length > 0 ? trimmed : null;\n    }\n    if (value !== null && value !== undefined && typeof value.toString === 'function') {\n      const converted = String(value).trim();\n      return converted.length > 0 ? converted : null;\n    }\n    return null;\n  }\n\n  private toNumber(value: unknown): number | null {\n    if (value === null || value === undefined) {\n      return null;\n    }\n    const num = Number(value);\n    if (Number.isFinite(num)) {\n      return Math.trunc(num);\n    }\n    return null;\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'transport',\n      'command',\n      'args',\n      'env',\n      'workingDirectory',\n      'url',\n      'headers',\n      'sessionId',\n      'method',\n      'methodArgs',\n      'argsTransform',\n      'transform',\n      'transform_js',\n      'timeout',\n      'depends_on',\n      'on',\n      'if',\n      'group',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // MCP SDK is now a required dependency, so always available\n    return true;\n  }\n\n  getRequirements(): string[] {\n    return ['MCP method name specified', 'Transport configuration (stdio: command, sse/http: url)'];\n  }\n}\n","/**\n * Interactive terminal prompting with beautiful UI\n */\n\nimport * as readline from 'readline';\n\nexport interface PromptOptions {\n  /** The prompt text to display */\n  prompt: string;\n  /** Placeholder text (shown in dim color) */\n  placeholder?: string;\n  /** Allow multiline input (Ctrl+D to finish) */\n  multiline?: boolean;\n  /** Timeout in milliseconds */\n  timeout?: number;\n  /** Default value if timeout occurs */\n  defaultValue?: string;\n  /** Allow empty input */\n  allowEmpty?: boolean;\n}\n\n// ANSI color codes\nconst colors = {\n  reset: '\\x1b[0m',\n  dim: '\\x1b[2m',\n  bold: '\\x1b[1m',\n  cyan: '\\x1b[36m',\n  green: '\\x1b[32m',\n  yellow: '\\x1b[33m',\n  gray: '\\x1b[90m',\n};\n\n// Box drawing characters (with ASCII fallback)\nconst supportsUnicode = process.env.LANG?.includes('UTF-8') || process.platform === 'darwin';\n\nconst box = supportsUnicode\n  ? {\n      topLeft: '┌',\n      topRight: '┐',\n      bottomLeft: '└',\n      bottomRight: '┘',\n      horizontal: '─',\n      vertical: '│',\n      leftT: '├',\n      rightT: '┤',\n    }\n  : {\n      topLeft: '+',\n      topRight: '+',\n      bottomLeft: '+',\n      bottomRight: '+',\n      horizontal: '-',\n      vertical: '|',\n      leftT: '+',\n      rightT: '+',\n    };\n\n/**\n * Format time in mm:ss\n */\nfunction formatTime(ms: number): string {\n  const seconds = Math.ceil(ms / 1000);\n  const mins = Math.floor(seconds / 60);\n  const secs = seconds % 60;\n  return `${mins}:${secs.toString().padStart(2, '0')}`;\n}\n\n/**\n * Draw a horizontal line\n */\nfunction drawLine(char: string, width: number): string {\n  return char.repeat(width);\n}\n\n/**\n * Wrap text to fit within a given width\n */\nfunction wrapText(text: string, width: number): string[] {\n  const words = text.split(' ');\n  const lines: string[] = [];\n  let currentLine = '';\n\n  for (const word of words) {\n    if (currentLine.length + word.length + 1 <= width) {\n      currentLine += (currentLine ? ' ' : '') + word;\n    } else {\n      if (currentLine) lines.push(currentLine);\n      currentLine = word;\n    }\n  }\n  if (currentLine) lines.push(currentLine);\n\n  return lines;\n}\n\n/**\n * Display the prompt UI\n */\nfunction displayPromptUI(options: PromptOptions, remainingMs?: number): void {\n  const width = Math.min(process.stdout.columns || 80, 80) - 4;\n  const icon = supportsUnicode ? '💬' : '>';\n\n  console.log('\\n'); // Add some spacing\n\n  // Top border\n  console.log(`${box.topLeft}${drawLine(box.horizontal, width + 2)}${box.topRight}`);\n\n  // Title\n  console.log(\n    `${box.vertical} ${colors.bold}${icon} Human Input Required${colors.reset}${' '.repeat(\n      width - 22\n    )} ${box.vertical}`\n  );\n\n  // Separator\n  console.log(`${box.leftT}${drawLine(box.horizontal, width + 2)}${box.rightT}`);\n\n  // Empty line\n  console.log(`${box.vertical} ${' '.repeat(width)} ${box.vertical}`);\n\n  // Prompt text (wrapped)\n  const promptLines = wrapText(options.prompt, width - 2);\n  for (const line of promptLines) {\n    console.log(\n      `${box.vertical} ${colors.cyan}${line}${colors.reset}${' '.repeat(\n        width - line.length\n      )} ${box.vertical}`\n    );\n  }\n\n  // Empty line\n  console.log(`${box.vertical} ${' '.repeat(width)} ${box.vertical}`);\n\n  // Instructions\n  const instruction = options.multiline\n    ? '(Type your response, press Ctrl+D when done)'\n    : '(Type your response and press Enter)';\n  console.log(\n    `${box.vertical} ${colors.dim}${instruction}${colors.reset}${' '.repeat(\n      width - instruction.length\n    )} ${box.vertical}`\n  );\n\n  // Placeholder if provided\n  if (options.placeholder && !options.multiline) {\n    console.log(\n      `${box.vertical} ${colors.dim}${options.placeholder}${colors.reset}${' '.repeat(\n        width - options.placeholder.length\n      )} ${box.vertical}`\n    );\n  }\n\n  // Empty line\n  console.log(`${box.vertical} ${' '.repeat(width)} ${box.vertical}`);\n\n  // Timeout indicator\n  if (remainingMs !== undefined && options.timeout) {\n    const timeIcon = supportsUnicode ? '⏱ ' : 'Time: ';\n    const timeStr = `${timeIcon} ${formatTime(remainingMs)} remaining`;\n    console.log(\n      `${box.vertical} ${colors.yellow}${timeStr}${colors.reset}${' '.repeat(\n        width - timeStr.length\n      )} ${box.vertical}`\n    );\n  }\n\n  // Bottom border\n  console.log(`${box.bottomLeft}${drawLine(box.horizontal, width + 2)}${box.bottomRight}`);\n\n  console.log(''); // Empty line before input\n  process.stdout.write(`${colors.green}>${colors.reset} `);\n}\n\n/**\n * Prompt user for input with a beautiful interactive UI\n */\nexport async function interactivePrompt(options: PromptOptions): Promise<string> {\n  return new Promise((resolve, reject) => {\n    let input = '';\n    let timeoutId: NodeJS.Timeout | undefined;\n    let countdownInterval: NodeJS.Timeout | undefined;\n    let remainingMs = options.timeout;\n\n    const rl = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout,\n      terminal: true,\n    });\n\n    // Display initial UI\n    displayPromptUI(options, remainingMs);\n\n    const cleanup = () => {\n      if (timeoutId) clearTimeout(timeoutId);\n      if (countdownInterval) clearInterval(countdownInterval);\n      rl.close();\n    };\n\n    const finish = (value: string) => {\n      cleanup();\n      console.log(''); // New line after input\n      resolve(value);\n    };\n\n    // Setup timeout if specified\n    if (options.timeout) {\n      timeoutId = setTimeout(() => {\n        cleanup();\n        console.log(`\\n${colors.yellow}⏱  Timeout reached${colors.reset}`);\n        if (options.defaultValue !== undefined) {\n          console.log(\n            `${colors.gray}Using default value: ${options.defaultValue}${colors.reset}\\n`\n          );\n          resolve(options.defaultValue);\n        } else {\n          reject(new Error('Input timeout'));\n        }\n      }, options.timeout);\n\n      // Update countdown every second\n      if (remainingMs) {\n        countdownInterval = setInterval(() => {\n          remainingMs = remainingMs! - 1000;\n          if (remainingMs <= 0) {\n            if (countdownInterval) clearInterval(countdownInterval);\n          }\n        }, 1000);\n      }\n    }\n\n    if (options.multiline) {\n      // Multiline mode: collect lines until EOF (Ctrl+D)\n      rl.on('line', line => {\n        input += (input ? '\\n' : '') + line;\n      });\n\n      rl.on('close', () => {\n        cleanup();\n        const trimmed = input.trim();\n        if (!trimmed && !options.allowEmpty) {\n          console.log(`${colors.yellow}⚠  Empty input not allowed${colors.reset}`);\n          reject(new Error('Empty input not allowed'));\n        } else {\n          finish(trimmed);\n        }\n      });\n    } else {\n      // Single line mode\n      rl.question('', answer => {\n        const trimmed = answer.trim();\n        if (!trimmed && !options.allowEmpty && !options.defaultValue) {\n          cleanup();\n          console.log(`${colors.yellow}⚠  Empty input not allowed${colors.reset}`);\n          reject(new Error('Empty input not allowed'));\n        } else {\n          finish(trimmed || options.defaultValue || '');\n        }\n      });\n    }\n\n    // Handle Ctrl+C\n    rl.on('SIGINT', () => {\n      cleanup();\n      console.log('\\n\\n' + colors.yellow + '⚠  Cancelled by user' + colors.reset);\n      reject(new Error('Cancelled by user'));\n    });\n  });\n}\n\n/**\n * Simple prompt without fancy UI (for non-TTY environments)\n */\nexport async function simplePrompt(prompt: string): Promise<string> {\n  return new Promise(resolve => {\n    const rl = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout,\n    });\n\n    rl.question(`${prompt}\\n> `, answer => {\n      rl.close();\n      resolve(answer.trim());\n    });\n  });\n}\n","/**\n * Utilities for reading from stdin\n */\n\n/**\n * Check if stdin has data available (is being piped)\n */\nexport function isStdinAvailable(): boolean {\n  // Check if stdin is a TTY (interactive terminal)\n  // If it's not a TTY, it means data is being piped\n  return !process.stdin.isTTY;\n}\n\n/**\n * Read all data from stdin\n * @param timeout Optional timeout in milliseconds\n * @param maxSize Maximum size in bytes (default: 1MB)\n * @returns Promise that resolves with the stdin content\n */\nexport async function readStdin(timeout?: number, maxSize: number = 1024 * 1024): Promise<string> {\n  return new Promise((resolve, reject) => {\n    let data = '';\n    let timeoutId: NodeJS.Timeout | undefined;\n\n    if (timeout) {\n      timeoutId = setTimeout(() => {\n        cleanup();\n        reject(new Error(`Stdin read timeout after ${timeout}ms`));\n      }, timeout);\n    }\n\n    const cleanup = () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      process.stdin.removeListener('data', onData);\n      process.stdin.removeListener('end', onEnd);\n      process.stdin.removeListener('error', onError);\n      // Pause stdin to prevent resource leaks\n      process.stdin.pause();\n    };\n\n    const onData = (chunk: Buffer) => {\n      data += chunk.toString();\n      // Security: Prevent DoS through large input\n      if (data.length > maxSize) {\n        cleanup();\n        reject(new Error(`Input exceeds maximum size of ${maxSize} bytes`));\n      }\n    };\n\n    const onEnd = () => {\n      cleanup();\n      resolve(data.trim());\n    };\n\n    const onError = (err: Error) => {\n      cleanup();\n      reject(err);\n    };\n\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', onData);\n    process.stdin.on('end', onEnd);\n    process.stdin.on('error', onError);\n\n    // Resume stdin in case it's paused\n    process.stdin.resume();\n  });\n}\n\n/**\n * Try to read from stdin if available, otherwise return null\n * @param timeout Optional timeout in milliseconds\n * @param maxSize Maximum size in bytes (default: 1MB)\n * @returns Promise that resolves with stdin content or null if not available\n */\nexport async function tryReadStdin(\n  timeout?: number,\n  maxSize: number = 1024 * 1024\n): Promise<string | null> {\n  if (!isStdinAvailable()) {\n    return null;\n  }\n\n  try {\n    return await readStdin(timeout, maxSize);\n  } catch {\n    // If reading fails, return null\n    return null;\n  }\n}\n","import { CheckProvider, CheckProviderConfig, ExecutionContext } from './check-provider.interface';\nimport { PRInfo } from '../pr-analyzer';\nimport { ReviewSummary } from '../reviewer';\nimport { HumanInputRequest } from '../types/config';\nimport { interactivePrompt, simplePrompt } from '../utils/interactive-prompt';\nimport { tryReadStdin } from '../utils/stdin-reader';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n/**\n * Human input check provider that pauses workflow to request user input.\n *\n * Supports four modes:\n * 1. CLI with --message argument (inline or file path)\n * 2. CLI with piped stdin\n * 3. CLI interactive mode (beautiful terminal UI)\n * 4. SDK mode with onHumanInput hook\n *\n * Example config:\n * ```yaml\n * checks:\n *   approval:\n *     type: human-input\n *     prompt: \"Do you approve? (yes/no)\"\n *     allow_empty: false\n *     timeout: 300000\n * ```\n */\nexport class HumanInputCheckProvider extends CheckProvider {\n  /**\n   * @deprecated Use ExecutionContext.cliMessage instead\n   * Kept for backward compatibility\n   */\n  private static cliMessage: string | undefined;\n\n  /**\n   * @deprecated Use ExecutionContext.hooks instead\n   * Kept for backward compatibility\n   */\n  private static hooks: { onHumanInput?: (request: HumanInputRequest) => Promise<string> } = {};\n\n  /**\n   * Set the CLI message value (from --message argument)\n   * @deprecated Use ExecutionContext.cliMessage instead\n   */\n  static setCLIMessage(message: string | undefined): void {\n    HumanInputCheckProvider.cliMessage = message;\n  }\n\n  /**\n   * Get the current CLI message value\n   * @deprecated Use ExecutionContext.cliMessage instead\n   */\n  static getCLIMessage(): string | undefined {\n    return HumanInputCheckProvider.cliMessage;\n  }\n\n  /**\n   * Set hooks for SDK mode\n   * @deprecated Use ExecutionContext.hooks instead\n   */\n  static setHooks(hooks: { onHumanInput?: (request: HumanInputRequest) => Promise<string> }): void {\n    HumanInputCheckProvider.hooks = hooks;\n  }\n\n  getName(): string {\n    return 'human-input';\n  }\n\n  getDescription(): string {\n    return 'Prompts for human input during workflow execution (CLI interactive or SDK hook)';\n  }\n\n  async validateConfig(config: unknown): Promise<boolean> {\n    if (!config || typeof config !== 'object') {\n      return false;\n    }\n\n    const cfg = config as CheckProviderConfig;\n\n    // Type must be 'human-input'\n    if (cfg.type !== 'human-input') {\n      return false;\n    }\n\n    // Prompt is required\n    if (!cfg.prompt || typeof cfg.prompt !== 'string') {\n      console.error('human-input check requires a \"prompt\" field');\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Check if a string looks like a file path\n   */\n  private looksLikePath(str: string): boolean {\n    return str.includes('/') || str.includes('\\\\');\n  }\n\n  /**\n   * Sanitize user input to prevent injection attacks in dependent checks\n   * Removes potentially dangerous characters while preserving useful input\n   */\n  private sanitizeInput(input: string): string {\n    // Remove null bytes (C-string injection)\n    let sanitized = input.replace(/\\0/g, '');\n\n    // Remove control characters except newlines and tabs\n    sanitized = sanitized.replace(/[\\x00-\\x08\\x0B-\\x0C\\x0E-\\x1F\\x7F]/g, '');\n\n    // Limit length to prevent memory issues (100KB max)\n    const maxLength = 100 * 1024;\n    if (sanitized.length > maxLength) {\n      sanitized = sanitized.substring(0, maxLength);\n    }\n\n    return sanitized;\n  }\n\n  /**\n   * Try to read message from file if it exists\n   * Validates path to prevent directory traversal attacks\n   */\n  private async tryReadFile(filePath: string): Promise<string | null> {\n    try {\n      // Handle both absolute and relative paths\n      const absolutePath = path.isAbsolute(filePath)\n        ? filePath\n        : path.resolve(process.cwd(), filePath);\n\n      // Normalize path to resolve .. and . components\n      const normalizedPath = path.normalize(absolutePath);\n\n      // Security: Prevent path traversal attacks\n      // Only allow files within current working directory or its subdirectories\n      const cwd = process.cwd();\n      if (!normalizedPath.startsWith(cwd + path.sep) && normalizedPath !== cwd) {\n        // Path is outside working directory\n        return null;\n      }\n\n      // Use async file access check instead of sync existsSync\n      try {\n        await fs.promises.access(normalizedPath, fs.constants.R_OK);\n        const stats = await fs.promises.stat(normalizedPath);\n\n        // Only read regular files, not directories or special files\n        if (!stats.isFile()) {\n          return null;\n        }\n\n        const content = await fs.promises.readFile(normalizedPath, 'utf-8');\n        return content.trim();\n      } catch {\n        // File doesn't exist or isn't readable\n        return null;\n      }\n    } catch {\n      // If file read fails, treat as literal string\n    }\n    return null;\n  }\n\n  /**\n   * Get user input through various methods\n   */\n  private async getUserInput(\n    checkName: string,\n    config: CheckProviderConfig,\n    context?: ExecutionContext\n  ): Promise<string> {\n    const prompt = config.prompt || 'Please provide input:';\n    const placeholder = (config.placeholder as string | undefined) || 'Enter your response...';\n    const allowEmpty = (config.allow_empty as boolean | undefined) ?? false;\n    const multiline = (config.multiline as boolean | undefined) ?? false;\n    const timeout = config.timeout ? config.timeout * 1000 : undefined; // Convert to ms\n    const defaultValue = config.default as string | undefined;\n\n    // Get cliMessage from context (new way) or static property (backward compat)\n    const cliMessage = context?.cliMessage ?? HumanInputCheckProvider.cliMessage;\n\n    // Priority 1: Check for --message CLI argument\n    if (cliMessage !== undefined) {\n      const message = cliMessage;\n\n      // Check if it looks like a path and try to read the file\n      if (this.looksLikePath(message)) {\n        const fileContent = await this.tryReadFile(message);\n        if (fileContent !== null) {\n          return fileContent;\n        }\n      }\n\n      // Otherwise, use as literal message\n      return message;\n    }\n\n    // Priority 2: Check for piped stdin\n    const stdinInput = await tryReadStdin(timeout);\n    if (stdinInput !== null && stdinInput.length > 0) {\n      return stdinInput;\n    }\n\n    // Priority 3: SDK hook mode\n    // Get hooks from context (new way) or static property (backward compat)\n    const hooks = context?.hooks ?? HumanInputCheckProvider.hooks;\n\n    if (hooks?.onHumanInput) {\n      const request: HumanInputRequest = {\n        checkId: checkName,\n        prompt,\n        placeholder,\n        allowEmpty,\n        multiline,\n        timeout,\n        default: defaultValue,\n      };\n\n      try {\n        const result = await hooks.onHumanInput(request);\n        return result;\n      } catch (error) {\n        throw new Error(\n          `Hook onHumanInput failed: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    // Priority 4: Interactive terminal prompt (if TTY available)\n    if (process.stdin.isTTY) {\n      try {\n        const result = await interactivePrompt({\n          prompt,\n          placeholder,\n          multiline,\n          timeout,\n          defaultValue,\n          allowEmpty,\n        });\n        return result;\n      } catch (error) {\n        throw new Error(\n          `Interactive prompt failed: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    // Priority 5: Simple prompt (fallback for non-TTY)\n    try {\n      const result = await simplePrompt(prompt);\n      if (!result && !allowEmpty && !defaultValue) {\n        throw new Error('Empty input not allowed');\n      }\n      return result || defaultValue || '';\n    } catch (error) {\n      throw new Error(\n        `Simple prompt failed: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  async execute(\n    _prInfo: PRInfo,\n    config: CheckProviderConfig,\n    _dependencyResults?: Map<string, ReviewSummary>,\n    context?: ExecutionContext\n  ): Promise<ReviewSummary> {\n    const checkName = config.checkName || 'human-input';\n\n    try {\n      // Get user input (pass context for non-static state)\n      const userInput = await this.getUserInput(checkName, config, context);\n\n      // Sanitize input to prevent injection attacks in dependent checks\n      const sanitizedInput = this.sanitizeInput(userInput);\n\n      // Return the input as the check output (stored in output field for dependent checks)\n      return {\n        issues: [],\n        output: sanitizedInput,\n      } as ReviewSummary & { output: string };\n    } catch (error) {\n      // If there's an error getting input, return an error issue\n      return {\n        issues: [\n          {\n            file: '',\n            line: 0,\n            ruleId: 'human-input-error',\n            message: `Failed to get user input: ${\n              error instanceof Error ? error.message : String(error)\n            }`,\n            severity: 'error',\n            category: 'logic',\n          },\n        ],\n      };\n    }\n  }\n\n  getSupportedConfigKeys(): string[] {\n    return [\n      'type',\n      'prompt',\n      'placeholder',\n      'allow_empty',\n      'multiline',\n      'timeout',\n      'default',\n      'depends_on',\n      'on',\n      'if',\n      'group',\n    ];\n  }\n\n  async isAvailable(): Promise<boolean> {\n    // Human input provider is always available\n    // It will fall back to simple prompts if interactive mode isn't available\n    return true;\n  }\n\n  getRequirements(): string[] {\n    return [\n      'No external dependencies required',\n      'Works in CLI mode with --message argument, piped stdin, or interactive prompts',\n      'SDK mode requires onHumanInput hook to be configured',\n    ];\n  }\n}\n","import { CheckProvider } from './check-provider.interface';\nimport { AICheckProvider } from './ai-check-provider';\nimport { HttpCheckProvider } from './http-check-provider';\nimport { HttpInputProvider } from './http-input-provider';\nimport { HttpClientProvider } from './http-client-provider';\nimport { NoopCheckProvider } from './noop-check-provider';\nimport { LogCheckProvider } from './log-check-provider';\nimport { GitHubOpsProvider } from './github-ops-provider';\nimport { ClaudeCodeCheckProvider } from './claude-code-check-provider';\nimport { CommandCheckProvider } from './command-check-provider';\nimport { MemoryCheckProvider } from './memory-check-provider';\nimport { McpCheckProvider } from './mcp-check-provider';\nimport { HumanInputCheckProvider } from './human-input-check-provider';\n\n/**\n * Registry for managing check providers\n */\nexport class CheckProviderRegistry {\n  private providers: Map<string, CheckProvider> = new Map();\n  private static instance: CheckProviderRegistry;\n\n  private constructor() {\n    // Register default providers\n    this.registerDefaultProviders();\n  }\n\n  /**\n   * Get singleton instance\n   */\n  static getInstance(): CheckProviderRegistry {\n    if (!CheckProviderRegistry.instance) {\n      CheckProviderRegistry.instance = new CheckProviderRegistry();\n    }\n    return CheckProviderRegistry.instance;\n  }\n\n  /**\n   * Register default built-in providers\n   */\n  private registerDefaultProviders(): void {\n    // Register all built-in providers\n    this.register(new AICheckProvider());\n    this.register(new CommandCheckProvider());\n    this.register(new HttpCheckProvider());\n    this.register(new HttpInputProvider());\n    this.register(new HttpClientProvider());\n    this.register(new NoopCheckProvider());\n    this.register(new LogCheckProvider());\n    this.register(new MemoryCheckProvider());\n    this.register(new GitHubOpsProvider());\n    this.register(new HumanInputCheckProvider());\n\n    // Try to register ClaudeCodeCheckProvider - it may fail if dependencies are missing\n    try {\n      this.register(new ClaudeCodeCheckProvider());\n    } catch (error) {\n      console.error(\n        `Warning: Failed to register ClaudeCodeCheckProvider: ${\n          error instanceof Error ? error.message : 'Unknown error'\n        }`\n      );\n    }\n\n    // Try to register McpCheckProvider - it may fail if dependencies are missing\n    try {\n      this.register(new McpCheckProvider());\n    } catch (error) {\n      console.error(\n        `Warning: Failed to register McpCheckProvider: ${\n          error instanceof Error ? error.message : 'Unknown error'\n        }`\n      );\n    }\n  }\n\n  /**\n   * Register a check provider\n   */\n  register(provider: CheckProvider): void {\n    const name = provider.getName();\n    if (this.providers.has(name)) {\n      throw new Error(`Provider '${name}' is already registered`);\n    }\n    this.providers.set(name, provider);\n    // Only log provider registration in debug mode to avoid contaminating output\n    if (process.env.VISOR_DEBUG === 'true') {\n      console.error(`Registered check provider: ${name}`);\n    }\n  }\n\n  /**\n   * Unregister a check provider\n   */\n  unregister(name: string): void {\n    if (!this.providers.has(name)) {\n      throw new Error(`Provider '${name}' not found`);\n    }\n    this.providers.delete(name);\n    // Send provider unregistration messages to stderr to avoid contaminating JSON output\n    console.error(`Unregistered check provider: ${name}`);\n  }\n\n  /**\n   * Get a provider by name\n   */\n  getProvider(name: string): CheckProvider | undefined {\n    return this.providers.get(name);\n  }\n\n  /**\n   * Get provider or throw if not found\n   */\n  getProviderOrThrow(name: string): CheckProvider {\n    const provider = this.providers.get(name);\n    if (!provider) {\n      throw new Error(\n        `Check provider '${name}' not found. Available providers: ${this.getAvailableProviders().join(', ')}`\n      );\n    }\n    return provider;\n  }\n\n  /**\n   * Check if a provider exists\n   */\n  hasProvider(name: string): boolean {\n    return this.providers.has(name);\n  }\n\n  /**\n   * Get all registered provider names\n   */\n  getAvailableProviders(): string[] {\n    return Array.from(this.providers.keys());\n  }\n\n  /**\n   * Get all providers\n   */\n  getAllProviders(): CheckProvider[] {\n    return Array.from(this.providers.values());\n  }\n\n  /**\n   * Get providers that are currently available (have required dependencies)\n   */\n  async getActiveProviders(): Promise<CheckProvider[]> {\n    const providers = this.getAllProviders();\n    const activeProviders: CheckProvider[] = [];\n\n    for (const provider of providers) {\n      if (await provider.isAvailable()) {\n        activeProviders.push(provider);\n      }\n    }\n\n    return activeProviders;\n  }\n\n  /**\n   * List provider information\n   */\n  async listProviders(): Promise<\n    Array<{\n      name: string;\n      description: string;\n      available: boolean;\n      requirements: string[];\n    }>\n  > {\n    const providers = this.getAllProviders();\n    const info = [];\n\n    for (const provider of providers) {\n      info.push({\n        name: provider.getName(),\n        description: provider.getDescription(),\n        available: await provider.isAvailable(),\n        requirements: provider.getRequirements(),\n      });\n    }\n\n    return info;\n  }\n\n  /**\n   * Reset registry (mainly for testing)\n   */\n  reset(): void {\n    this.providers.clear();\n    this.registerDefaultProviders();\n  }\n\n  /**\n   * Clear singleton instance (for testing)\n   */\n  static clearInstance(): void {\n    CheckProviderRegistry.instance = undefined!;\n  }\n}\n","/**\n * Dependency resolution and execution ordering for checks\n */\n\nexport interface CheckNode {\n  id: string;\n  dependencies: string[];\n  dependents: string[];\n  depth: number;\n}\n\nexport interface ExecutionGroup {\n  /** Checks that can run in parallel */\n  parallel: string[];\n  /** Execution level/wave (0 = no dependencies, 1 = depends on level 0, etc.) */\n  level: number;\n}\n\nexport interface DependencyGraph {\n  nodes: Map<string, CheckNode>;\n  executionOrder: ExecutionGroup[];\n  hasCycles: boolean;\n  cycleNodes?: string[];\n}\n\nexport class DependencyResolver {\n  /**\n   * Build dependency graph from check dependencies\n   */\n  static buildDependencyGraph(checkDependencies: Record<string, string[]>): DependencyGraph {\n    const nodes = new Map<string, CheckNode>();\n\n    // Initialize all nodes\n    for (const checkId of Object.keys(checkDependencies)) {\n      nodes.set(checkId, {\n        id: checkId,\n        dependencies: checkDependencies[checkId] || [],\n        dependents: [],\n        depth: 0,\n      });\n    }\n\n    // Build bidirectional relationships\n    for (const [checkId, dependencies] of Object.entries(checkDependencies)) {\n      for (const depId of dependencies || []) {\n        if (!nodes.has(depId)) {\n          throw new Error(`Check \"${checkId}\" depends on \"${depId}\" but \"${depId}\" is not defined`);\n        }\n\n        const depNode = nodes.get(depId)!;\n        depNode.dependents.push(checkId);\n      }\n    }\n\n    // Detect cycles using DFS\n    const cycleDetection = this.detectCycles(nodes);\n    if (cycleDetection.hasCycles) {\n      return {\n        nodes,\n        executionOrder: [],\n        hasCycles: true,\n        cycleNodes: cycleDetection.cycleNodes,\n      };\n    }\n\n    // Calculate execution order using topological sort\n    const executionOrder = this.topologicalSort(nodes);\n\n    return {\n      nodes,\n      executionOrder,\n      hasCycles: false,\n    };\n  }\n\n  /**\n   * Detect cycles in the dependency graph using DFS\n   */\n  private static detectCycles(nodes: Map<string, CheckNode>): {\n    hasCycles: boolean;\n    cycleNodes?: string[];\n  } {\n    const visited = new Set<string>();\n    const recursionStack = new Set<string>();\n    const cycleNodes: string[] = [];\n\n    const dfs = (nodeId: string): boolean => {\n      if (recursionStack.has(nodeId)) {\n        cycleNodes.push(nodeId);\n        return true;\n      }\n      if (visited.has(nodeId)) {\n        return false;\n      }\n\n      visited.add(nodeId);\n      recursionStack.add(nodeId);\n\n      const node = nodes.get(nodeId);\n      if (node) {\n        for (const depId of node.dependencies) {\n          if (dfs(depId)) {\n            cycleNodes.push(nodeId);\n            return true;\n          }\n        }\n      }\n\n      recursionStack.delete(nodeId);\n      return false;\n    };\n\n    for (const nodeId of nodes.keys()) {\n      if (!visited.has(nodeId)) {\n        if (dfs(nodeId)) {\n          return { hasCycles: true, cycleNodes: [...new Set(cycleNodes)] };\n        }\n      }\n    }\n\n    return { hasCycles: false };\n  }\n\n  /**\n   * Perform topological sort to determine execution order\n   * Groups checks that can run in parallel at each level\n   */\n  private static topologicalSort(nodes: Map<string, CheckNode>): ExecutionGroup[] {\n    const remainingNodes = new Map(nodes);\n    const executionGroups: ExecutionGroup[] = [];\n    let level = 0;\n\n    while (remainingNodes.size > 0) {\n      // Find nodes with no remaining dependencies\n      const readyNodes: string[] = [];\n\n      for (const [nodeId, node] of remainingNodes.entries()) {\n        const unmetDependencies = node.dependencies.filter(depId => remainingNodes.has(depId));\n        if (unmetDependencies.length === 0) {\n          readyNodes.push(nodeId);\n        }\n      }\n\n      if (readyNodes.length === 0) {\n        // This shouldn't happen if cycle detection worked correctly\n        throw new Error('Unable to resolve dependencies - possible circular dependency detected');\n      }\n\n      // Add this group to execution order\n      executionGroups.push({\n        parallel: readyNodes,\n        level,\n      });\n\n      // Remove processed nodes\n      for (const nodeId of readyNodes) {\n        remainingNodes.delete(nodeId);\n      }\n\n      level++;\n    }\n\n    return executionGroups;\n  }\n\n  /**\n   * Validate that all dependencies exist\n   */\n  static validateDependencies(\n    checkIds: string[],\n    dependencies: Record<string, string[]>\n  ): { valid: boolean; errors: string[] } {\n    const errors: string[] = [];\n    const checkIdSet = new Set(checkIds);\n\n    for (const [checkId, deps] of Object.entries(dependencies)) {\n      if (!checkIdSet.has(checkId)) {\n        errors.push(`Check \"${checkId}\" is not in the list of available checks`);\n        continue;\n      }\n\n      for (const depId of deps || []) {\n        if (!checkIdSet.has(depId)) {\n          errors.push(`Check \"${checkId}\" depends on \"${depId}\" which is not available`);\n        }\n      }\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n    };\n  }\n\n  /**\n   * Get all transitive dependencies (ancestors) for a given check\n   * This returns all checks that must complete before the given check can run,\n   * not just the direct dependencies.\n   *\n   * For example, if A -> B -> C, then:\n   * - getAllDependencies(C) returns [A, B]\n   * - getAllDependencies(B) returns [A]\n   * - getAllDependencies(A) returns []\n   *\n   * @param checkId The check to find dependencies for\n   * @param nodes The dependency graph nodes\n   * @returns Array of all transitive dependency IDs\n   */\n  static getAllDependencies(checkId: string, nodes: Map<string, CheckNode>): string[] {\n    const allDeps = new Set<string>();\n    const visited = new Set<string>();\n\n    const collectDependencies = (currentId: string) => {\n      if (visited.has(currentId)) {\n        return;\n      }\n      visited.add(currentId);\n\n      const node = nodes.get(currentId);\n      if (!node) {\n        return;\n      }\n\n      // Add direct dependencies and recurse\n      for (const depId of node.dependencies) {\n        allDeps.add(depId);\n        collectDependencies(depId);\n      }\n    };\n\n    collectDependencies(checkId);\n    return Array.from(allDeps);\n  }\n\n  /**\n   * Get execution statistics for debugging\n   */\n  static getExecutionStats(graph: DependencyGraph): {\n    totalChecks: number;\n    parallelLevels: number;\n    maxParallelism: number;\n    averageParallelism: number;\n    checksWithDependencies: number;\n  } {\n    const totalChecks = graph.nodes.size;\n    const parallelLevels = graph.executionOrder.length;\n    const maxParallelism = Math.max(...graph.executionOrder.map(group => group.parallel.length));\n    const averageParallelism = totalChecks / parallelLevels;\n    const checksWithDependencies = Array.from(graph.nodes.values()).filter(\n      node => node.dependencies.length > 0\n    ).length;\n\n    return {\n      totalChecks,\n      parallelLevels,\n      maxParallelism,\n      averageParallelism,\n      checksWithDependencies,\n    };\n  }\n}\n","import { context as otContext, Span, SpanStatusCode, trace, Attributes } from './lazy-otel';\n\nexport function getTracer() {\n  return trace.getTracer('visor');\n}\n\nexport async function withActiveSpan<T>(\n  name: string,\n  attrs: Record<string, unknown> | undefined,\n  fn: (span: Span) => Promise<T>\n): Promise<T> {\n  const tracer = getTracer();\n  // Preserve parent context via tracer API; avoid logging parent IDs to stdout\n  // Avoid noisy stdout logs that break JSON consumers\n  return await new Promise<T>((resolve, reject) => {\n    const callback = async (span: Span) => {\n      // console.debug(`[trace] Span callback invoked for: [trace_id=${ctx.traceId} span_id=${ctx.spanId}] ${name} span: true`);\n      try {\n        const res = await fn(span);\n        // console.debug('[trace] Span execution completed for:', name);\n        resolve(res);\n      } catch (err) {\n        // console.debug('[trace] Span execution errored for:', name, err);\n        try {\n          if (err instanceof Error) span.recordException(err);\n          span.setStatus({ code: SpanStatusCode.ERROR });\n        } catch {}\n        reject(err);\n      } finally {\n        try {\n          // console.debug('[trace] Ending span:', name);\n          span.end();\n        } catch {}\n      }\n    };\n    // startActiveSpan should use the current active context to set parent automatically\n    const options = attrs ? { attributes: attrs as Attributes } : {};\n    tracer.startActiveSpan(name, options, callback);\n  });\n}\n\nexport function addEvent(name: string, attrs?: Record<string, unknown>): void {\n  const span = trace.getSpan(otContext.active());\n  if (span) {\n    try {\n      span.addEvent(name, attrs as Attributes);\n    } catch {\n      // ignore\n    }\n  }\n  // Fallback NDJSON emission for serverless/file sink when SDK may be inactive\n  try {\n    const { emitNdjsonSpanWithEvents } = require('./fallback-ndjson');\n    emitNdjsonSpanWithEvents('visor.event', {}, [{ name, attrs }]);\n    if (name === 'fail_if.triggered') {\n      emitNdjsonSpanWithEvents('visor.event', {}, [\n        { name: 'fail_if.evaluated', attrs },\n        { name: 'fail_if.triggered', attrs },\n      ]);\n    }\n  } catch {}\n}\n\nexport function setSpanAttributes(attrs: Record<string, unknown>): void {\n  const span = trace.getSpan(otContext.active());\n  if (!span) return;\n  try {\n    for (const [k, v] of Object.entries(attrs)) span.setAttribute(k, v as never);\n  } catch {\n    // ignore\n  }\n}\n\nexport function setSpanError(err: unknown): void {\n  const span = trace.getSpan(otContext.active());\n  if (!span) return;\n  try {\n    if (err instanceof Error) span.recordException(err);\n    span.setStatus({ code: SpanStatusCode.ERROR });\n  } catch {\n    // ignore\n  }\n}\n\n// Internal helper for tests: write a minimal run marker to NDJSON when using file sink\nlet __ndjsonPath: string | null = null;\nexport function __getOrCreateNdjsonPath(): string | null {\n  try {\n    // If sink is explicitly set to non-file, skip. If unset, still allow when a trace dir/file is configured.\n    if (process.env.VISOR_TELEMETRY_SINK && process.env.VISOR_TELEMETRY_SINK !== 'file')\n      return null;\n    const path = require('path');\n    const fs = require('fs');\n    // Prefer explicit fallback file path if set by the CLI\n    if (process.env.VISOR_FALLBACK_TRACE_FILE) {\n      __ndjsonPath = process.env.VISOR_FALLBACK_TRACE_FILE;\n      const dir = path.dirname(__ndjsonPath);\n      if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\n      return __ndjsonPath;\n    }\n    const outDir = process.env.VISOR_TRACE_DIR || path.join(process.cwd(), 'output', 'traces');\n    if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });\n    if (!__ndjsonPath) {\n      const ts = new Date().toISOString().replace(/[:.]/g, '-');\n      __ndjsonPath = path.join(outDir, `${ts}.ndjson`);\n    }\n    return __ndjsonPath;\n  } catch {\n    return null;\n  }\n}\nexport function _appendRunMarker(): void {\n  try {\n    const fs = require('fs');\n    const p = __getOrCreateNdjsonPath();\n    if (!p) return;\n    const line = { name: 'visor.run', attributes: { started: true } };\n    fs.appendFileSync(p, JSON.stringify(line) + '\\n', 'utf8');\n  } catch {}\n}\n","import { metrics } from './lazy-otel';\n\nlet initialized = false;\nconst meter = metrics.getMeter('visor');\n\n// Test helpers (enabled with VISOR_TEST_METRICS=true)\nconst TEST_ENABLED = process.env.VISOR_TEST_METRICS === 'true';\nconst TEST_SNAPSHOT: { [k: string]: number } = { fail_if_triggered: 0 };\n\n// Instruments (lazily created when first used)\nlet checkDurationHist: ReturnType<typeof meter.createHistogram> | undefined;\nlet providerDurationHist: ReturnType<typeof meter.createHistogram> | undefined;\nlet foreachDurationHist: ReturnType<typeof meter.createHistogram> | undefined;\nlet issuesCounter: ReturnType<typeof meter.createCounter> | undefined;\nlet activeChecks: ReturnType<typeof meter.createUpDownCounter> | undefined;\nlet failIfCounter: ReturnType<typeof meter.createCounter> | undefined;\nlet diagramBlocks: ReturnType<typeof meter.createCounter> | undefined;\n\nfunction ensureInstruments() {\n  if (initialized) return;\n  try {\n    checkDurationHist = meter.createHistogram('visor.check.duration_ms', {\n      description: 'Duration of a check execution in milliseconds',\n      unit: 'ms',\n    });\n    providerDurationHist = meter.createHistogram('visor.provider.duration_ms', {\n      description: 'Duration of provider execution in milliseconds',\n      unit: 'ms',\n    });\n    foreachDurationHist = meter.createHistogram('visor.foreach.item.duration_ms', {\n      description: 'Duration of a forEach item execution in milliseconds',\n      unit: 'ms',\n    });\n    issuesCounter = meter.createCounter('visor.check.issues', {\n      description: 'Number of issues produced by checks',\n      unit: '1',\n    });\n    activeChecks = meter.createUpDownCounter('visor.run.active_checks', {\n      description: 'Number of checks actively running',\n      unit: '1',\n    });\n    failIfCounter = meter.createCounter('visor.fail_if.triggered', {\n      description: 'Number of times fail_if condition triggered',\n      unit: '1',\n    });\n    diagramBlocks = meter.createCounter('visor.diagram.blocks', {\n      description: 'Number of Mermaid diagram blocks emitted',\n      unit: '1',\n    });\n    initialized = true;\n  } catch {\n    // Metrics may be unavailable if SDK not initialized; ignore gracefully\n  }\n}\n\nexport function recordCheckDuration(check: string, durationMs: number, group?: string) {\n  ensureInstruments();\n  try {\n    checkDurationHist?.record(durationMs, {\n      'visor.check.id': check,\n      'visor.check.group': group || 'default',\n    });\n  } catch {}\n}\n\nexport function recordProviderDuration(check: string, providerType: string, durationMs: number) {\n  ensureInstruments();\n  try {\n    providerDurationHist?.record(durationMs, {\n      'visor.check.id': check,\n      'visor.provider.type': providerType,\n    });\n  } catch {}\n}\n\nexport function recordForEachDuration(\n  check: string,\n  index: number,\n  total: number,\n  durationMs: number\n) {\n  ensureInstruments();\n  try {\n    foreachDurationHist?.record(durationMs, {\n      'visor.check.id': check,\n      'visor.foreach.index': index,\n      'visor.foreach.total': total,\n    });\n  } catch {}\n}\n\nexport function addIssues(check: string, severity: string, count = 1) {\n  ensureInstruments();\n  try {\n    issuesCounter?.add(count, {\n      'visor.check.id': check,\n      severity,\n    });\n  } catch {}\n}\n\nexport function incActiveCheck(check: string) {\n  ensureInstruments();\n  try {\n    activeChecks?.add(1, { 'visor.check.id': check });\n  } catch {}\n}\n\nexport function decActiveCheck(check: string) {\n  ensureInstruments();\n  try {\n    activeChecks?.add(-1, { 'visor.check.id': check });\n  } catch {}\n}\n\nexport function addFailIfTriggered(check: string, scope: 'global' | 'check') {\n  ensureInstruments();\n  try {\n    failIfCounter?.add(1, { 'visor.check.id': check, scope });\n  } catch {}\n  if (TEST_ENABLED) TEST_SNAPSHOT.fail_if_triggered++;\n}\n\nexport function addDiagramBlock(origin: 'content' | 'issue') {\n  ensureInstruments();\n  try {\n    diagramBlocks?.add(1, { origin });\n  } catch {}\n}\n\nexport function getTestMetricsSnapshot() {\n  return { ...TEST_SNAPSHOT };\n}\n\nexport function resetTestMetricsSnapshot() {\n  Object.keys(TEST_SNAPSHOT).forEach(k => (TEST_SNAPSHOT[k] = 0));\n}\n","/**\n * Failure condition evaluation engine using SandboxJS for secure expression evaluation\n */\n\nimport { ReviewSummary } from './reviewer';\nimport { addEvent } from './telemetry/trace-helpers';\nimport { addFailIfTriggered } from './telemetry/metrics';\nimport {\n  FailureConditions,\n  FailureCondition,\n  FailureConditionContext,\n  FailureConditionResult,\n  FailureConditionSeverity,\n} from './types/config';\nimport Sandbox from '@nyariv/sandboxjs';\nimport { createSecureSandbox } from './utils/sandbox';\nimport { createPermissionHelpers, detectLocalMode } from './utils/author-permissions';\nimport { MemoryStore } from './memory-store';\n\n/**\n * Evaluates failure conditions using SandboxJS for secure evaluation\n */\nexport class FailureConditionEvaluator {\n  private sandbox?: Sandbox;\n\n  constructor() {}\n\n  /**\n   * Create a secure sandbox with whitelisted functions and globals\n   */\n  private createSecureSandbox(): Sandbox {\n    return createSecureSandbox();\n  }\n\n  /**\n   * Evaluate simple fail_if condition\n   */\n  async evaluateSimpleCondition(\n    checkName: string,\n    checkSchema: string,\n    checkGroup: string,\n    reviewSummary: ReviewSummary,\n    expression: string,\n    previousOutputs?: Record<string, ReviewSummary>,\n    authorAssociation?: string\n  ): Promise<boolean> {\n    const context = this.buildEvaluationContext(\n      checkName,\n      checkSchema,\n      checkGroup,\n      reviewSummary,\n      previousOutputs,\n      authorAssociation\n    );\n\n    try {\n      try {\n        const isObj = context.output && typeof context.output === 'object';\n        const keys = isObj ? Object.keys(context.output as any).join(',') : typeof context.output;\n        let errorVal: unknown = undefined;\n        if (isObj && (context.output as any).error !== undefined)\n          errorVal = (context.output as any).error;\n        require('./logger').logger.debug(\n          `  fail_if: evaluating '${expression}' with output keys=${keys} error=${String(errorVal)}`\n        );\n      } catch {}\n      const res = this.evaluateExpression(expression, context);\n      if (res === true) {\n        try {\n          addEvent('fail_if.triggered', {\n            check: checkName,\n            scope: 'check',\n            name: `${checkName}_fail_if`,\n            expression,\n            severity: 'error',\n          });\n        } catch {}\n        try {\n          const { emitNdjsonSpanWithEvents } = require('./telemetry/fallback-ndjson');\n          emitNdjsonSpanWithEvents(\n            'visor.fail_if',\n            { check: checkName, scope: 'check', name: `${checkName}_fail_if` },\n            [\n              {\n                name: 'fail_if.triggered',\n                attrs: {\n                  check: checkName,\n                  scope: 'check',\n                  name: `${checkName}_fail_if`,\n                  expression,\n                  severity: 'error',\n                },\n              },\n            ]\n          );\n        } catch {}\n      }\n      return res;\n    } catch (error) {\n      console.warn(`Failed to evaluate fail_if expression: ${error}`);\n      return false; // Don't fail on evaluation errors\n    }\n  }\n\n  /**\n   * Determine if the event is related to pull requests\n   */\n  private determineIfPullRequest(eventType?: string): boolean {\n    if (!eventType) return false;\n\n    const prEvents = ['pr_opened', 'pr_updated', 'pr_closed', 'pull_request'];\n    return prEvents.includes(eventType) || eventType.startsWith('pr_');\n  }\n\n  /**\n   * Determine if the event is related to issues\n   */\n  private determineIfIssue(eventType?: string): boolean {\n    if (!eventType) return false;\n\n    const issueEvents = ['issue_opened', 'issue_comment', 'issues'];\n    return issueEvents.includes(eventType) || eventType.startsWith('issue_');\n  }\n\n  /**\n   * Evaluate if condition to determine whether a check should run\n   */\n  async evaluateIfCondition(\n    checkName: string,\n    expression: string,\n    contextData?: {\n      branch?: string;\n      baseBranch?: string;\n      filesChanged?: string[];\n      event?: string;\n      environment?: Record<string, string>;\n      previousResults?: Map<string, ReviewSummary>;\n      authorAssociation?: string;\n    }\n  ): Promise<boolean> {\n    // Build context for if evaluation\n    const context = {\n      // Check metadata\n      checkName,\n\n      // Git context\n      branch: contextData?.branch || 'unknown',\n      baseBranch: contextData?.baseBranch || 'main',\n      filesChanged: contextData?.filesChanged || [],\n      filesCount: contextData?.filesChanged?.length || 0,\n\n      // GitHub event context\n      event: {\n        event_name: contextData?.event || 'manual',\n        action: undefined, // Would be populated from actual GitHub context\n        repository: undefined, // Would be populated from actual GitHub context\n      },\n\n      // Environment variables\n      env: contextData?.environment || {},\n\n      // Previous check results (unwrap output field like templates do)\n      outputs: contextData?.previousResults\n        ? (() => {\n            const outputs: Record<string, unknown> = {};\n            for (const [checkName, result] of contextData.previousResults) {\n              // If the result has a direct output field, use it directly\n              // Otherwise, expose the entire result as-is\n              const summary = result as ReviewSummary & { output?: unknown };\n              outputs[checkName] = summary.output !== undefined ? summary.output : summary;\n            }\n            return outputs;\n          })()\n        : {},\n\n      // Required output property (empty for if conditions)\n      output: {\n        issues: [],\n      },\n      // Author association (used by permission helpers)\n      authorAssociation: contextData?.authorAssociation,\n\n      // Utility metadata\n      metadata: {\n        checkName,\n        schema: '',\n        group: '',\n        criticalIssues: 0,\n        errorIssues: 0,\n        warningIssues: 0,\n        infoIssues: 0,\n        totalIssues: 0,\n        hasChanges: (contextData?.filesChanged?.length || 0) > 0,\n        branch: contextData?.branch || 'unknown',\n        event: contextData?.event || 'manual',\n      },\n    };\n\n    try {\n      return this.evaluateExpression(expression, context);\n    } catch (error) {\n      console.warn(`Failed to evaluate if expression for check '${checkName}': ${error}`);\n      // Default to running the check if evaluation fails\n      return true;\n    }\n  }\n\n  /**\n   * Evaluate all failure conditions for a check result\n   */\n  async evaluateConditions(\n    checkName: string,\n    checkSchema: string,\n    checkGroup: string,\n    reviewSummary: ReviewSummary,\n    globalConditions?: FailureConditions,\n    checkConditions?: FailureConditions,\n    previousOutputs?: Record<string, ReviewSummary>,\n    authorAssociation?: string\n  ): Promise<FailureConditionResult[]> {\n    const context = this.buildEvaluationContext(\n      checkName,\n      checkSchema,\n      checkGroup,\n      reviewSummary,\n      previousOutputs,\n      authorAssociation\n    );\n\n    const results: FailureConditionResult[] = [];\n\n    // Evaluate global conditions first\n    if (globalConditions) {\n      const globalResults = await this.evaluateConditionSet(globalConditions, context, 'global');\n      results.push(...globalResults);\n    }\n\n    // Evaluate check-specific conditions (these override global ones with same name)\n    if (checkConditions) {\n      const checkResults = await this.evaluateConditionSet(checkConditions, context, 'check');\n\n      // Remove global conditions that are overridden by check-specific ones\n      const overriddenConditions = new Set(Object.keys(checkConditions));\n      const filteredResults = results.filter(\n        result => !overriddenConditions.has(result.conditionName)\n      );\n\n      results.length = 0;\n      results.push(...filteredResults, ...checkResults);\n    }\n\n    try {\n      if (checkName === 'B') {\n        console.error(\n          `🔧 Debug: fail_if results for ${checkName}: ${JSON.stringify(results)} context.output=${JSON.stringify(\n            context.output\n          )}`\n        );\n      }\n    } catch {}\n    return results;\n  }\n\n  /**\n   * Evaluate a set of failure conditions\n   */\n  private async evaluateConditionSet(\n    conditions: FailureConditions,\n    context: FailureConditionContext,\n    source: 'global' | 'check'\n  ): Promise<FailureConditionResult[]> {\n    const results: FailureConditionResult[] = [];\n\n    for (const [conditionName, condition] of Object.entries(conditions)) {\n      try {\n        addEvent('fail_if.evaluated', {\n          check: context.checkName,\n          scope: source,\n          name: conditionName,\n          expression: this.extractExpression(condition),\n        });\n      } catch {}\n\n      // File fallback: append an NDJSON span with the evaluation event\n      try {\n        const { emitNdjsonSpanWithEvents } = require('./telemetry/fallback-ndjson');\n        emitNdjsonSpanWithEvents(\n          'visor.fail_if',\n          { check: context.checkName || 'unknown', scope: source, name: conditionName },\n          [\n            {\n              name: 'fail_if.evaluated',\n              attrs: {\n                check: context.checkName,\n                scope: source,\n                name: conditionName,\n                expression: this.extractExpression(condition),\n              },\n            },\n          ]\n        );\n      } catch {}\n\n      try {\n        const result = await this.evaluateSingleCondition(conditionName, condition, context);\n        results.push(result);\n\n        if (result.failed) {\n          try {\n            addEvent('fail_if.triggered', {\n              check: context.checkName,\n              scope: source,\n              name: conditionName,\n              expression: result.expression,\n              severity: result.severity,\n              halt_execution: result.haltExecution,\n            });\n          } catch {}\n          try {\n            addFailIfTriggered(context.checkName || 'unknown', source);\n          } catch {}\n        }\n      } catch (error) {\n        // If evaluation fails, create an error result\n        results.push({\n          conditionName,\n          failed: false,\n          expression: this.extractExpression(condition),\n          severity: 'error',\n          haltExecution: false,\n          error: `Failed to evaluate ${source} condition '${conditionName}': ${\n            error instanceof Error ? error.message : String(error)\n          }`,\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Evaluate a single failure condition\n   */\n  private async evaluateSingleCondition(\n    conditionName: string,\n    condition: FailureCondition,\n    context: FailureConditionContext\n  ): Promise<FailureConditionResult> {\n    const expression = this.extractExpression(condition);\n    const config = this.extractConditionConfig(condition);\n\n    try {\n      const failed = this.evaluateExpression(expression, context);\n\n      return {\n        conditionName,\n        failed,\n        expression,\n        message: config.message,\n        severity: config.severity || 'error',\n        haltExecution: config.halt_execution || false,\n      };\n    } catch (error) {\n      throw new Error(\n        `Expression evaluation error: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Secure expression evaluation using SandboxJS\n   * Supports the same GitHub Actions-style functions as the previous implementation\n   */\n  private evaluateExpression(condition: string, context: FailureConditionContext): boolean {\n    try {\n      // Normalize multi-line or semicolon-separated expressions.\n      // Allows writing debug statements on separate lines, e.g.:\n      //   log(\"start\")\n      //   log(outputs)\n      //   outputs[\"fetch-tickets\"].issueType === 'Bug'\n      // We convert to a single expression using the comma operator so the\n      // final expression determines the boolean result.\n      const normalize = (expr: string): string => {\n        const trimmed = expr.trim();\n        // If it's already a single-line expression without semicolons, keep it.\n        if (!/[\\n;]/.test(trimmed)) return trimmed;\n\n        // Split on newlines/semicolons, drop empty and comment-only lines.\n        const parts = trimmed\n          .split(/[\\n;]+/)\n          .map(s => s.trim())\n          .filter(s => s.length > 0 && !s.startsWith('//'));\n\n        if (parts.length === 0) return 'true';\n\n        // Support an explicit return in the last statement.\n        const lastRaw = parts.pop() as string;\n        const last = lastRaw.replace(/^return\\s+/i, '').trim();\n\n        // Join leading statements with comma operator; last expression returns value.\n        if (parts.length === 0) return last;\n        return `(${parts.join(', ')}, ${last})`;\n      };\n\n      // note: normalization happens later only if raw compilation fails\n      // Helper functions for GitHub Actions-style expressions\n      const contains = (searchString: string, searchValue: string): boolean =>\n        String(searchString).toLowerCase().includes(String(searchValue).toLowerCase());\n\n      const startsWith = (searchString: string, searchValue: string): boolean =>\n        String(searchString).toLowerCase().startsWith(String(searchValue).toLowerCase());\n\n      const endsWith = (searchString: string, searchValue: string): boolean =>\n        String(searchString).toLowerCase().endsWith(String(searchValue).toLowerCase());\n\n      const length = (value: string | unknown[] | Record<string, unknown>): number => {\n        if (typeof value === 'string' || Array.isArray(value)) {\n          return value.length;\n        }\n        if (value && typeof value === 'object') {\n          return Object.keys(value).length;\n        }\n        return 0;\n      };\n\n      const always = (): boolean => true;\n      const success = (): boolean => true;\n      const failure = (): boolean => false;\n\n      // Debug logging function for printing to console\n      const log = (...args: unknown[]): void => {\n        console.log('🔍 Debug:', ...args);\n      };\n\n      // Helper functions for array operations\n      const hasIssue = (issues: unknown[], field: string, value: unknown): boolean => {\n        if (!Array.isArray(issues)) return false;\n        return issues.some(issue => (issue as Record<string, unknown>)[field] === value);\n      };\n\n      const countIssues = (issues: unknown[], field: string, value: unknown): number => {\n        if (!Array.isArray(issues)) return 0;\n        return issues.filter(issue => (issue as Record<string, unknown>)[field] === value).length;\n      };\n\n      const hasFileMatching = (issues: unknown[], pattern: string): boolean => {\n        if (!Array.isArray(issues)) return false;\n        return issues.some(issue => (issue as { file?: string }).file?.includes(pattern));\n      };\n\n      // Backward compatibility aliases\n      const hasIssueWith = hasIssue;\n      const hasFileWith = hasFileMatching;\n\n      // Permission helper functions\n      const permissionHelpers = createPermissionHelpers(\n        context.authorAssociation,\n        detectLocalMode()\n      );\n      const hasMinPermission = permissionHelpers.hasMinPermission;\n      const isOwner = permissionHelpers.isOwner;\n      const isMember = permissionHelpers.isMember;\n      const isCollaborator = permissionHelpers.isCollaborator;\n      const isContributor = permissionHelpers.isContributor;\n      const isFirstTimer = permissionHelpers.isFirstTimer;\n\n      // Extract context variables\n      const output = context.output || {};\n      const issues = output.issues || [];\n\n      // Backward compatibility: provide metadata for transition period\n      // TODO: Remove after all configurations are updated\n      const metadata = context.metadata || {\n        checkName: context.checkName || '',\n        schema: context.schema || '',\n        group: context.group || '',\n        criticalIssues: issues.filter((i: { severity?: string }) => i.severity === 'critical')\n          .length,\n        errorIssues: issues.filter((i: { severity?: string }) => i.severity === 'error').length,\n        warningIssues: issues.filter((i: { severity?: string }) => i.severity === 'warning').length,\n        infoIssues: issues.filter((i: { severity?: string }) => i.severity === 'info').length,\n        totalIssues: issues.length,\n        hasChanges: context.hasChanges || false,\n      };\n\n      // Legacy variables for backward compatibility\n      const criticalIssues = metadata.criticalIssues;\n      const errorIssues = metadata.errorIssues;\n      const totalIssues = metadata.totalIssues;\n      const warningIssues = metadata.warningIssues;\n      const infoIssues = metadata.infoIssues;\n\n      // Additional context for 'if' conditions and some failure conditions\n      const checkName = context.checkName || '';\n      const schema = context.schema || '';\n      const group = context.group || '';\n      const branch = context.branch || 'unknown';\n      const baseBranch = context.baseBranch || 'main';\n      const filesChanged = context.filesChanged || [];\n      const filesCount = context.filesCount || 0;\n      const event = context.event || 'manual';\n      const env = context.env || {};\n      const outputs = context.outputs || {};\n      const debugData = context.debug || null;\n\n      // Get memory store and create accessor for fail_if expressions\n      const memoryStore = MemoryStore.getInstance();\n      const memoryAccessor = {\n        get: (key: string, ns?: string) => memoryStore.get(key, ns),\n        has: (key: string, ns?: string) => memoryStore.has(key, ns),\n        list: (ns?: string) => memoryStore.list(ns),\n        getAll: (ns?: string) => memoryStore.getAll(ns),\n      };\n\n      // Create scope with all context variables and helper functions\n      const scope = {\n        // Primary context variables\n        output,\n        outputs,\n        debug: debugData,\n        // Memory accessor for fail_if expressions\n        memory: memoryAccessor,\n        // Legacy compatibility variables\n        issues,\n        metadata,\n        criticalIssues,\n        errorIssues,\n        totalIssues,\n        warningIssues,\n        infoIssues,\n        // If condition context\n        checkName,\n        schema,\n        group,\n        branch,\n        baseBranch,\n        filesChanged,\n        filesCount,\n        event,\n        env,\n        // Helper functions\n        contains,\n        startsWith,\n        endsWith,\n        length,\n        always,\n        success,\n        failure,\n        log,\n        hasIssue,\n        countIssues,\n        hasFileMatching,\n        hasIssueWith,\n        hasFileWith,\n        // Permission helpers\n        hasMinPermission,\n        isOwner,\n        isMember,\n        isCollaborator,\n        isContributor,\n        isFirstTimer,\n      };\n\n      // Compile and execute the expression in the sandbox\n      const raw = condition.trim();\n      if (!this.sandbox) {\n        this.sandbox = this.createSecureSandbox();\n      }\n      let exec: ReturnType<typeof this.sandbox.compile>;\n      try {\n        // Try compiling the raw expression as-is first (supports multi-line logical expressions)\n        exec = this.sandbox.compile(`return (${raw});`);\n      } catch {\n        // Fallback: normalize multi-line statements into a comma-chain expression\n        const normalizedExpr = normalize(condition);\n        exec = this.sandbox.compile(`return (${normalizedExpr});`);\n      }\n      const result = exec(scope).run();\n      try {\n        require('./logger').logger.debug(`  fail_if: result=${Boolean(result)}`);\n      } catch {}\n      // Ensure we return a boolean\n      return Boolean(result);\n    } catch (error) {\n      console.error('❌ Failed to evaluate expression:', condition, error);\n      // Re-throw the error so it can be caught at a higher level for error reporting\n      throw error;\n    }\n  }\n\n  /**\n   * Extract the expression from a failure condition\n   */\n  private extractExpression(condition: FailureCondition): string {\n    if (typeof condition === 'string') {\n      return condition;\n    }\n    return condition.condition;\n  }\n\n  /**\n   * Extract configuration from a failure condition\n   */\n  private extractConditionConfig(condition: FailureCondition): {\n    message?: string;\n    severity?: FailureConditionSeverity;\n    halt_execution?: boolean;\n  } {\n    if (typeof condition === 'string') {\n      return {};\n    }\n    return {\n      message: condition.message,\n      severity: condition.severity,\n      halt_execution: condition.halt_execution,\n    };\n  }\n\n  /**\n   * Build the evaluation context for expressions\n   */\n  private buildEvaluationContext(\n    checkName: string,\n    checkSchema: string,\n    checkGroup: string,\n    reviewSummary: ReviewSummary,\n    previousOutputs?: Record<string, ReviewSummary>,\n    authorAssociation?: string\n  ): FailureConditionContext {\n    const { issues, debug } = reviewSummary;\n    const reviewSummaryWithOutput = reviewSummary as ReviewSummary & { output?: unknown };\n\n    // Extract output field to avoid nesting (output.output)\n    const {\n      output: extractedOutput,\n      // Exclude issues from otherFields since we handle it separately\n      issues: _issues, // eslint-disable-line @typescript-eslint/no-unused-vars\n      ...otherFields\n    } = reviewSummaryWithOutput as any;\n\n    // Build output object with safety for array-based outputs (forEach aggregation)\n    const aggregatedOutput: Record<string, unknown> = {\n      issues: (issues || []).map(issue => ({\n        file: issue.file,\n        line: issue.line,\n        endLine: issue.endLine,\n        ruleId: issue.ruleId,\n        message: issue.message,\n        severity: issue.severity,\n        category: issue.category,\n        group: issue.group,\n        schema: issue.schema,\n        suggestion: issue.suggestion,\n        replacement: issue.replacement,\n      })),\n      // Include additional schema-specific data from reviewSummary\n      ...otherFields,\n    };\n\n    if (Array.isArray(extractedOutput)) {\n      // Preserve items array and lift common flags for convenience (e.g., output.error)\n      aggregatedOutput.items = extractedOutput;\n      const anyError = extractedOutput.find(\n        it => it && typeof it === 'object' && (it as Record<string, unknown>).error\n      ) as Record<string, unknown> | undefined;\n      if (anyError && anyError.error !== undefined) {\n        aggregatedOutput.error = anyError.error;\n      }\n    } else if (extractedOutput && typeof extractedOutput === 'object') {\n      Object.assign(aggregatedOutput, extractedOutput as Record<string, unknown>);\n    }\n\n    // If provider attached a raw transform snapshot, merge its fields generically.\n    try {\n      const raw = (reviewSummaryWithOutput as any).__raw;\n      if (raw && typeof raw === 'object') {\n        Object.assign(aggregatedOutput, raw as Record<string, unknown>);\n      }\n    } catch {}\n\n    // If output is a string, try to parse JSON (full or from end) to enrich context,\n    // and also derive common boolean flags generically (e.g., key:true/false) for fail_if usage.\n    try {\n      if (typeof extractedOutput === 'string') {\n        const parsed =\n          this.tryExtractJsonFromEnd(extractedOutput) ??\n          (() => {\n            try {\n              return JSON.parse(extractedOutput);\n            } catch {\n              return null;\n            }\n          })();\n        if (parsed !== null) {\n          if (Array.isArray(parsed)) {\n            (aggregatedOutput as any).items = parsed;\n          } else if (typeof parsed === 'object') {\n            Object.assign(aggregatedOutput, parsed as Record<string, unknown>);\n          }\n        }\n        // Generic boolean key extraction for simple text outputs (no special provider cases)\n        const lower = extractedOutput.toLowerCase();\n        const boolFrom = (key: string): boolean | null => {\n          const reTrue = new RegExp(\n            `(?:^|[^a-z0-9_])${key}[^a-z0-9_]*[:=][^a-z0-9_]*true(?:[^a-z0-9_]|$)`\n          );\n          const reFalse = new RegExp(\n            `(?:^|[^a-z0-9_])${key}[^a-z0-9_]*[:=][^a-z0-9_]*false(?:[^a-z0-9_]|$)`\n          );\n          if (reTrue.test(lower)) return true;\n          if (reFalse.test(lower)) return false;\n          return null;\n        };\n        const keys = ['error'];\n        for (const k of keys) {\n          const v = boolFrom(k);\n          if (v !== null && (aggregatedOutput as any)[k] === undefined) {\n            (aggregatedOutput as any)[k] = v;\n          }\n        }\n      }\n    } catch {}\n\n    // Try to parse JSON from content as a last resort when no structured output is present\n    try {\n      const rsAny = reviewSummaryWithOutput as any;\n      const hasStructuredOutput = extractedOutput !== undefined && extractedOutput !== null;\n      if (!hasStructuredOutput && typeof rsAny?.content === 'string') {\n        const parsedFromContent = this.tryExtractJsonFromEnd(rsAny.content);\n        if (parsedFromContent !== null && parsedFromContent !== undefined) {\n          if (Array.isArray(parsedFromContent)) {\n            (aggregatedOutput as any).items = parsedFromContent;\n          } else if (typeof parsedFromContent === 'object') {\n            Object.assign(aggregatedOutput, parsedFromContent as Record<string, unknown>);\n          }\n        }\n      }\n    } catch {}\n\n    // Get memory store instance\n    const memoryStore = MemoryStore.getInstance();\n\n    const context: FailureConditionContext = {\n      output: aggregatedOutput,\n      outputs: (() => {\n        if (!previousOutputs) return {};\n        const outputs: Record<string, unknown> = {};\n        for (const [checkName, result] of Object.entries(previousOutputs)) {\n          // If the result has a direct output field, use it directly\n          // Otherwise, expose the entire result as-is\n          const summary = result as ReviewSummary & { output?: unknown };\n          outputs[checkName] = summary.output !== undefined ? summary.output : summary;\n        }\n        return outputs;\n      })(),\n      // Add memory accessor for fail_if expressions\n      memory: {\n        get: (key: string, ns?: string) => memoryStore.get(key, ns),\n        has: (key: string, ns?: string) => memoryStore.has(key, ns),\n        list: (ns?: string) => memoryStore.list(ns),\n        getAll: (ns?: string) => memoryStore.getAll(ns),\n      } as any,\n      // Add basic context info for failure conditions\n      checkName: checkName,\n      schema: checkSchema,\n      group: checkGroup,\n      authorAssociation: authorAssociation,\n    };\n\n    // Add debug information if available\n    if (debug) {\n      context.debug = {\n        errors: debug.errors || [],\n        processingTime: debug.processingTime || 0,\n        provider: debug.provider || 'unknown',\n        model: debug.model || 'unknown',\n      };\n    }\n\n    return context;\n  }\n\n  // Minimal JSON-from-end extractor for fail_if context fallback\n  private tryExtractJsonFromEnd(text: string): unknown | null {\n    try {\n      const lines = text.split('\\n');\n      for (let i = lines.length - 1; i >= 0; i--) {\n        const t = lines[i].trim();\n        if (t.startsWith('{') || t.startsWith('[')) {\n          const candidate = lines.slice(i).join('\\n').trim();\n          if (\n            (candidate.startsWith('{') && candidate.endsWith('}')) ||\n            (candidate.startsWith('[') && candidate.endsWith(']'))\n          ) {\n            return JSON.parse(candidate);\n          }\n        }\n      }\n    } catch {}\n    return null;\n  }\n\n  /**\n   * Check if any failure condition requires halting execution\n   */\n  static shouldHaltExecution(results: FailureConditionResult[]): boolean {\n    return results.some(result => result.failed && result.haltExecution);\n  }\n\n  /**\n   * Get all failed conditions\n   */\n  static getFailedConditions(results: FailureConditionResult[]): FailureConditionResult[] {\n    return results.filter(result => result.failed);\n  }\n\n  /**\n   * Group results by severity\n   */\n  static groupResultsBySeverity(results: FailureConditionResult[]): {\n    error: FailureConditionResult[];\n    warning: FailureConditionResult[];\n    info: FailureConditionResult[];\n  } {\n    return {\n      // Only 'error' severity now (no backward compatibility needed here as this is internal)\n      error: results.filter(r => r.severity === 'error'),\n      warning: results.filter(r => r.severity === 'warning'),\n      info: results.filter(r => r.severity === 'info'),\n    };\n  }\n\n  /**\n   * Format results for display\n   */\n  static formatResults(results: FailureConditionResult[]): string {\n    const failed = FailureConditionEvaluator.getFailedConditions(results);\n\n    if (failed.length === 0) {\n      return '✅ All failure conditions passed';\n    }\n\n    const grouped = FailureConditionEvaluator.groupResultsBySeverity(failed);\n    const sections: string[] = [];\n\n    if (grouped.error.length > 0) {\n      sections.push(`❌ **Error severity conditions (${grouped.error.length}):**`);\n      grouped.error.forEach(result => {\n        sections.push(`  - ${result.conditionName}: ${result.message || result.expression}`);\n      });\n    }\n\n    if (grouped.warning.length > 0) {\n      sections.push(`⚠️ **Warning conditions (${grouped.warning.length}):**`);\n      grouped.warning.forEach(result => {\n        sections.push(`  - ${result.conditionName}: ${result.message || result.expression}`);\n      });\n    }\n\n    if (grouped.info.length > 0) {\n      sections.push(`ℹ️ **Info conditions (${grouped.info.length}):**`);\n      grouped.info.forEach(result => {\n        sections.push(`  - ${result.conditionName}: ${result.message || result.expression}`);\n      });\n    }\n\n    return sections.join('\\n');\n  }\n}\n","/**\n * GitHub Check Service for creating and managing check runs based on failure conditions\n */\n\nimport { Octokit } from '@octokit/rest';\nimport { FailureConditionResult } from './types/config';\nimport { ReviewIssue } from './reviewer';\nimport { generateFooter } from './footer';\n\nexport interface CheckRunOptions {\n  owner: string;\n  repo: string;\n  head_sha: string;\n  name: string;\n  details_url?: string;\n  external_id?: string;\n}\n\nexport interface CheckRunAnnotation {\n  path: string;\n  start_line: number;\n  end_line: number;\n  annotation_level: 'notice' | 'warning' | 'failure';\n  message: string;\n  title?: string;\n  raw_details?: string;\n}\n\nexport interface CheckRunSummary {\n  title: string;\n  summary: string;\n  text?: string;\n}\n\nexport type CheckRunStatus = 'queued' | 'in_progress' | 'completed';\nexport type CheckRunConclusion =\n  | 'success'\n  | 'failure'\n  | 'neutral'\n  | 'cancelled'\n  | 'timed_out'\n  | 'action_required';\n\n/**\n * Service for managing GitHub Check Runs based on Visor failure conditions\n */\nexport class GitHubCheckService {\n  private octokit: Octokit;\n  private maxAnnotations = 50; // GitHub API limit\n\n  constructor(octokit: Octokit) {\n    this.octokit = octokit;\n  }\n\n  /**\n   * Create a new check run in queued status\n   */\n  async createCheckRun(\n    options: CheckRunOptions,\n    summary?: CheckRunSummary\n  ): Promise<{ id: number; url: string }> {\n    try {\n      const response = await this.octokit.rest.checks.create({\n        owner: options.owner,\n        repo: options.repo,\n        name: options.name,\n        head_sha: options.head_sha,\n        status: 'queued',\n        details_url: options.details_url,\n        external_id: options.external_id,\n        output: summary\n          ? {\n              title: summary.title,\n              summary: summary.summary,\n              text: summary.text,\n            }\n          : undefined,\n      });\n\n      return {\n        id: response.data.id,\n        url: response.data.html_url || '',\n      };\n    } catch (error) {\n      throw new Error(\n        `Failed to create check run: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Update check run to in_progress status\n   */\n  async updateCheckRunInProgress(\n    owner: string,\n    repo: string,\n    check_run_id: number,\n    summary?: CheckRunSummary\n  ): Promise<void> {\n    try {\n      await this.octokit.rest.checks.update({\n        owner,\n        repo,\n        check_run_id,\n        status: 'in_progress',\n        output: summary\n          ? {\n              title: summary.title,\n              summary: summary.summary,\n              text: summary.text,\n            }\n          : undefined,\n      });\n    } catch (error) {\n      throw new Error(\n        `Failed to update check run to in_progress: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Complete a check run with results based on failure conditions\n   */\n  async completeCheckRun(\n    owner: string,\n    repo: string,\n    check_run_id: number,\n    checkName: string,\n    failureResults: FailureConditionResult[],\n    reviewIssues: ReviewIssue[] = [],\n    executionError?: string,\n    filesChangedInCommit?: string[],\n    prNumber?: number,\n    currentCommitSha?: string\n  ): Promise<void> {\n    try {\n      // Clear old annotations from ALL previous check runs (including older runs on the same commit)\n      // This prevents annotation accumulation when a check runs multiple times\n      if (prNumber && currentCommitSha) {\n        await this.clearOldAnnotations(\n          owner,\n          repo,\n          prNumber,\n          checkName,\n          currentCommitSha,\n          check_run_id\n        );\n      }\n\n      const { conclusion, summary } = this.determineCheckRunConclusion(\n        checkName,\n        failureResults,\n        reviewIssues,\n        executionError\n      );\n\n      // Filter out system-level issues (fail_if conditions, internal errors)\n      // These should not appear as annotations but affect the check conclusion\n      let filteredIssues = reviewIssues.filter(\n        issue => !(issue.file === 'system' && issue.line === 0)\n      );\n\n      // Filter annotations to only include files changed in this commit\n      // This prevents old annotations from previous commits showing up in the Files tab\n      if (filesChangedInCommit && filesChangedInCommit.length > 0) {\n        filteredIssues = filteredIssues.filter(issue =>\n          filesChangedInCommit.some(changedFile => issue.file === changedFile)\n        );\n      }\n\n      const annotations = this.convertIssuesToAnnotations(filteredIssues);\n\n      await this.octokit.rest.checks.update({\n        owner,\n        repo,\n        check_run_id,\n        status: 'completed',\n        conclusion,\n        completed_at: new Date().toISOString(),\n        output: {\n          title: summary.title,\n          summary: summary.summary,\n          text: summary.text,\n          annotations: annotations.slice(0, this.maxAnnotations), // GitHub limit\n        },\n      });\n    } catch (error) {\n      throw new Error(\n        `Failed to complete check run: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Determine check run conclusion based on failure conditions and issues\n   */\n  private determineCheckRunConclusion(\n    checkName: string,\n    failureResults: FailureConditionResult[],\n    reviewIssues: ReviewIssue[],\n    executionError?: string\n  ): { conclusion: CheckRunConclusion; summary: CheckRunSummary } {\n    // Handle execution errors first\n    if (executionError) {\n      return {\n        conclusion: 'failure',\n        summary: {\n          title: '❌ Check Execution Failed',\n          summary: `The ${checkName} check failed to execute properly.`,\n          text: `**Error:** ${executionError}\\n\\nPlease check your configuration and try again.`,\n        },\n      };\n    }\n\n    // Check if any fail_if conditions were met\n    const failedConditions = failureResults.filter(result => result.failed);\n\n    // Count issues by severity (for informational display only)\n    const criticalIssues = reviewIssues.filter(issue => issue.severity === 'critical').length;\n    const errorIssues = reviewIssues.filter(issue => issue.severity === 'error').length;\n    const warningIssues = reviewIssues.filter(issue => issue.severity === 'warning').length;\n    const totalIssues = reviewIssues.length;\n\n    // Determine conclusion ONLY based on fail_if evaluation results\n    // The presence of issues (critical, error, warning) does NOT affect the conclusion\n    // Only the fail_if condition determines pass/fail status\n    let conclusion: CheckRunConclusion;\n    let title: string;\n    let summaryText: string;\n    let details: string;\n\n    if (failedConditions.length > 0) {\n      // Check fails if fail_if condition is met\n      conclusion = 'failure';\n      title = '🚨 Check Failed';\n      summaryText = `${checkName} check failed because fail_if condition was met.`;\n\n      details = this.formatCheckDetails(failureResults, reviewIssues, {\n        failedConditions: failedConditions.length,\n        warningConditions: 0,\n        criticalIssues,\n        errorIssues,\n        warningIssues,\n        totalIssues,\n      });\n    } else {\n      // No fail_if conditions met - check passes regardless of issues found\n      conclusion = 'success';\n\n      // Adjust the title and summary based on issues found, but conclusion remains success\n      if (criticalIssues > 0 || errorIssues > 0) {\n        title = '✅ Check Passed (Issues Found)';\n        summaryText = `${checkName} check passed. Found ${criticalIssues} critical and ${errorIssues} error issues, but fail_if condition was not met.`;\n      } else if (warningIssues > 0) {\n        title = '✅ Check Passed (Warnings Found)';\n        summaryText = `${checkName} check passed. Found ${warningIssues} warning${warningIssues === 1 ? '' : 's'}, but fail_if condition was not met.`;\n      } else {\n        title = '✅ Check Passed';\n        summaryText = `${checkName} check completed successfully with no issues found.`;\n      }\n\n      details = this.formatCheckDetails(failureResults, reviewIssues, {\n        failedConditions: 0,\n        warningConditions: 0,\n        criticalIssues,\n        errorIssues,\n        warningIssues,\n        totalIssues,\n      });\n    }\n\n    return {\n      conclusion,\n      summary: {\n        title,\n        summary: summaryText,\n        text: details,\n      },\n    };\n  }\n\n  /**\n   * Format detailed check results for the check run summary\n   */\n  private formatCheckDetails(\n    failureResults: FailureConditionResult[],\n    reviewIssues: ReviewIssue[],\n    counts: {\n      failedConditions: number;\n      warningConditions: number;\n      criticalIssues: number;\n      errorIssues: number;\n      warningIssues: number;\n      totalIssues: number;\n    }\n  ): string {\n    const sections: string[] = [];\n\n    // Summary section\n    sections.push('## 📊 Summary');\n    sections.push(`- **Total Issues:** ${counts.totalIssues}`);\n    if (counts.criticalIssues > 0) {\n      sections.push(`- **Critical Issues:** ${counts.criticalIssues}`);\n    }\n    if (counts.errorIssues > 0) {\n      sections.push(`- **Error Issues:** ${counts.errorIssues}`);\n    }\n    if (counts.warningIssues > 0) {\n      sections.push(`- **Warning Issues:** ${counts.warningIssues}`);\n    }\n    sections.push('');\n\n    // Failure conditions section\n    if (failureResults.length > 0) {\n      sections.push('## 🔍 Failure Condition Results');\n\n      const failedConditions = failureResults.filter(result => result.failed);\n      const passedConditions = failureResults.filter(result => !result.failed);\n\n      if (failedConditions.length > 0) {\n        sections.push('### ❌ Failed Conditions');\n        failedConditions.forEach(condition => {\n          sections.push(\n            `- **${condition.conditionName}**: ${condition.message || condition.expression}`\n          );\n          if (condition.severity === 'error') {\n            sections.push(`  - ⚠️ **Severity:** Error`);\n          }\n        });\n        sections.push('');\n      }\n\n      if (passedConditions.length > 0) {\n        sections.push('### ✅ Passed Conditions');\n        passedConditions.forEach(condition => {\n          sections.push(\n            `- **${condition.conditionName}**: ${condition.message || 'Condition passed'}`\n          );\n        });\n        sections.push('');\n      }\n    }\n\n    // Issues by category section\n    if (reviewIssues.length > 0) {\n      const issuesByCategory = this.groupIssuesByCategory(reviewIssues);\n      sections.push('## 🐛 Issues by Category');\n\n      Object.entries(issuesByCategory).forEach(([category, issues]) => {\n        if (issues.length > 0) {\n          sections.push(\n            `### ${this.getCategoryEmoji(category)} ${category.charAt(0).toUpperCase() + category.slice(1)} (${issues.length})`\n          );\n\n          // Show only first 5 issues per category to keep the summary concise\n          const displayIssues = issues.slice(0, 5);\n          displayIssues.forEach(issue => {\n            const severityIcon = this.getSeverityIcon(issue.severity);\n            sections.push(`- ${severityIcon} **${issue.file}:${issue.line}** - ${issue.message}`);\n          });\n\n          if (issues.length > 5) {\n            sections.push(`- *...and ${issues.length - 5} more ${category} issues*`);\n          }\n          sections.push('');\n        }\n      });\n    }\n\n    // Footer\n    sections.push('');\n    sections.push(generateFooter());\n\n    return sections.join('\\n');\n  }\n\n  /**\n   * Convert review issues to GitHub check run annotations\n   */\n  private convertIssuesToAnnotations(reviewIssues: ReviewIssue[]): CheckRunAnnotation[] {\n    return reviewIssues\n      .slice(0, this.maxAnnotations) // Respect GitHub's annotation limit\n      .map(issue => ({\n        path: issue.file,\n        start_line: issue.line,\n        end_line: issue.endLine || issue.line,\n        annotation_level: this.mapSeverityToAnnotationLevel(issue.severity),\n        message: issue.message,\n        title: `${issue.category} Issue`,\n        raw_details: issue.suggestion || undefined,\n      }));\n  }\n\n  /**\n   * Map Visor issue severity to GitHub annotation level\n   */\n  private mapSeverityToAnnotationLevel(severity: string): 'notice' | 'warning' | 'failure' {\n    switch (severity) {\n      case 'critical':\n      case 'error':\n        return 'failure';\n      case 'warning':\n        return 'warning';\n      case 'info':\n      default:\n        return 'notice';\n    }\n  }\n\n  /**\n   * Group issues by category\n   */\n  private groupIssuesByCategory(issues: ReviewIssue[]): Record<string, ReviewIssue[]> {\n    const grouped: Record<string, ReviewIssue[]> = {};\n\n    issues.forEach(issue => {\n      const category = issue.category || 'general';\n      if (!grouped[category]) {\n        grouped[category] = [];\n      }\n      grouped[category].push(issue);\n    });\n\n    return grouped;\n  }\n\n  /**\n   * Get emoji for issue category\n   */\n  private getCategoryEmoji(category: string): string {\n    const emojiMap: Record<string, string> = {\n      security: '🔐',\n      performance: '⚡',\n      style: '🎨',\n      logic: '🧠',\n      architecture: '🏗️',\n      documentation: '📚',\n      general: '📝',\n    };\n    return emojiMap[category.toLowerCase()] || '📝';\n  }\n\n  /**\n   * Get icon for issue severity\n   */\n  private getSeverityIcon(severity: string): string {\n    const iconMap: Record<string, string> = {\n      critical: '🚨',\n      error: '❌',\n      warning: '⚠️',\n      info: 'ℹ️',\n    };\n    return iconMap[severity.toLowerCase()] || 'ℹ️';\n  }\n\n  /**\n   * Create multiple check runs for different checks with failure condition support\n   */\n  async createMultipleCheckRuns(\n    options: CheckRunOptions,\n    checkResults: Array<{\n      checkName: string;\n      failureResults: FailureConditionResult[];\n      reviewIssues: ReviewIssue[];\n      executionError?: string;\n    }>\n  ): Promise<Array<{ checkName: string; id: number; url: string }>> {\n    const results: Array<{ checkName: string; id: number; url: string }> = [];\n\n    for (const checkResult of checkResults) {\n      try {\n        // Create check run\n        const checkRun = await this.createCheckRun({\n          ...options,\n          name: `Visor: ${checkResult.checkName}`,\n          external_id: `visor-${checkResult.checkName}-${options.head_sha.substring(0, 7)}`,\n        });\n\n        // Update to in progress\n        await this.updateCheckRunInProgress(options.owner, options.repo, checkRun.id, {\n          title: `Running ${checkResult.checkName} check...`,\n          summary: `Analyzing code with ${checkResult.checkName} check using AI.`,\n        });\n\n        // Complete with results\n        await this.completeCheckRun(\n          options.owner,\n          options.repo,\n          checkRun.id,\n          checkResult.checkName,\n          checkResult.failureResults,\n          checkResult.reviewIssues,\n          checkResult.executionError\n        );\n\n        results.push({\n          checkName: checkResult.checkName,\n          id: checkRun.id,\n          url: checkRun.url,\n        });\n      } catch (error) {\n        console.error(`Failed to create check run for ${checkResult.checkName}:`, error);\n        // Continue with other checks even if one fails\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Get check runs for a specific commit\n   */\n  async getCheckRuns(\n    owner: string,\n    repo: string,\n    ref: string\n  ): Promise<Array<{ id: number; name: string; status: string; conclusion: string | null }>> {\n    try {\n      const response = await this.octokit.rest.checks.listForRef({\n        owner,\n        repo,\n        ref,\n        filter: 'all',\n      });\n\n      return response.data.check_runs\n        .filter(check => check.name.startsWith('Visor:'))\n        .map(check => ({\n          id: check.id,\n          name: check.name,\n          status: check.status,\n          conclusion: check.conclusion,\n        }));\n    } catch (error) {\n      throw new Error(\n        `Failed to get check runs: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Get check runs for a specific commit SHA\n   * Returns all check runs with the given name on this commit\n   */\n  async getCheckRunsForCommit(\n    owner: string,\n    repo: string,\n    commitSha: string,\n    checkName: string\n  ): Promise<Array<{ id: number; head_sha: string }>> {\n    try {\n      const checksResponse = await this.octokit.rest.checks.listForRef({\n        owner,\n        repo,\n        ref: commitSha,\n        check_name: `Visor: ${checkName}`,\n      });\n\n      return checksResponse.data.check_runs.map(check => ({\n        id: check.id,\n        head_sha: commitSha,\n      }));\n    } catch (error) {\n      throw new Error(\n        `Failed to get check runs for commit ${commitSha}: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Clear annotations from old check runs on the current commit\n   * This prevents annotation accumulation when a check runs multiple times on the same commit\n   * (e.g., force push, re-running checks)\n   */\n  async clearOldAnnotations(\n    owner: string,\n    repo: string,\n    prNumber: number, // Not used, kept for backward compatibility\n    checkName: string,\n    currentCommitSha: string,\n    currentCheckRunId: number\n  ): Promise<void> {\n    try {\n      // Get all check runs for this check name on the current commit\n      const allCheckRuns = await this.getCheckRunsForCommit(\n        owner,\n        repo,\n        currentCommitSha,\n        checkName\n      );\n\n      // Filter out the CURRENT check run (by ID)\n      // This handles the case where Visor runs multiple times on the same commit\n      const oldRuns = allCheckRuns.filter(run => run.id !== currentCheckRunId);\n\n      if (oldRuns.length === 0) {\n        console.debug(`No old check runs to clear for ${checkName} on commit ${currentCommitSha}`);\n        return;\n      }\n\n      console.debug(\n        `Clearing ${oldRuns.length} old check run(s) for ${checkName} on commit ${currentCommitSha.substring(0, 7)} (keeping current run ${currentCheckRunId})`\n      );\n\n      // Update each old check run to have empty annotations\n      for (const run of oldRuns) {\n        try {\n          await this.octokit.rest.checks.update({\n            owner,\n            repo,\n            check_run_id: run.id,\n            output: {\n              title: 'Outdated',\n              summary: 'This check has been superseded by a newer run.',\n              annotations: [], // Clear annotations\n            },\n          });\n          console.debug(`✓ Cleared annotations from check run ${run.id}`);\n        } catch (error) {\n          console.debug(`Could not clear annotations for check run ${run.id}:`, error);\n        }\n      }\n    } catch (error) {\n      // Don't fail the whole check if we can't clear old annotations\n      console.warn('Failed to clear old annotations:', error);\n    }\n  }\n}\n","/*\n * Internal snapshot store for incremental adoption of snapshot+scope execution.\n * Phase 0: journal only — no behavior change, used for future visibility work.\n */\n\nimport type { ReviewSummary } from './reviewer';\nimport type { EventTrigger } from './types/config';\n\nexport type ScopePath = Array<{ check: string; index: number }>;\n\nexport interface JournalEntry {\n  commitId: number;\n  sessionId: string;\n  scope: ScopePath;\n  checkId: string;\n  event: EventTrigger | undefined;\n  result: ReviewSummary & { output?: unknown; content?: string };\n}\n\nexport class ExecutionJournal {\n  private commit = 0;\n  private entries: JournalEntry[] = [];\n\n  beginSnapshot(): number {\n    return this.commit;\n  }\n\n  commitEntry(entry: {\n    sessionId: string;\n    scope: ScopePath;\n    checkId: string;\n    result: ReviewSummary & { output?: unknown; content?: string };\n    event?: EventTrigger;\n  }): JournalEntry {\n    const committed: JournalEntry = {\n      sessionId: entry.sessionId,\n      scope: entry.scope,\n      checkId: entry.checkId,\n      result: entry.result,\n      event: entry.event,\n      commitId: ++this.commit,\n    };\n    this.entries.push(committed);\n    return committed;\n  }\n\n  readVisible(sessionId: string, commitMax: number, event?: EventTrigger): JournalEntry[] {\n    return this.entries.filter(\n      e =>\n        e.sessionId === sessionId && e.commitId <= commitMax && (event ? e.event === event : true)\n    );\n  }\n\n  // Lightweight helpers for debugging/metrics\n  size(): number {\n    return this.entries.length;\n  }\n}\n\nexport class ContextView {\n  constructor(\n    private journal: ExecutionJournal,\n    private sessionId: string,\n    private snapshotId: number,\n    private scope: ScopePath,\n    private event?: EventTrigger\n  ) {}\n\n  /** Return the nearest result for a check in this scope (exact item → ancestor → latest). */\n  get(checkId: string): (ReviewSummary & { output?: unknown; content?: string }) | undefined {\n    const visible = this.journal\n      .readVisible(this.sessionId, this.snapshotId, this.event)\n      .filter(e => e.checkId === checkId);\n    if (visible.length === 0) return undefined;\n\n    // exact scope match\n    const exact = visible.find(e => this.sameScope(e.scope, this.scope));\n    if (exact) return exact.result;\n\n    // nearest ancestor (shortest distance)\n    let best: { entry: JournalEntry; dist: number } | undefined;\n    for (const e of visible) {\n      const dist = this.ancestorDistance(e.scope, this.scope);\n      if (dist >= 0 && (best === undefined || dist < best.dist)) {\n        best = { entry: e, dist };\n      }\n    }\n    if (best) return best.entry.result;\n\n    // fallback to latest committed result\n    return visible[visible.length - 1]?.result;\n  }\n\n  /** Return an aggregate (raw) result – the shallowest scope for this check. */\n  getRaw(checkId: string): (ReviewSummary & { output?: unknown; content?: string }) | undefined {\n    const visible = this.journal\n      .readVisible(this.sessionId, this.snapshotId, this.event)\n      .filter(e => e.checkId === checkId);\n    if (visible.length === 0) return undefined;\n    let shallow = visible[0];\n    for (const e of visible) {\n      if (e.scope.length < shallow.scope.length) shallow = e;\n    }\n    return shallow.result;\n  }\n\n  /** All results for a check up to this snapshot. */\n  getHistory(checkId: string): Array<ReviewSummary & { output?: unknown; content?: string }> {\n    return this.journal\n      .readVisible(this.sessionId, this.snapshotId, this.event)\n      .filter(e => e.checkId === checkId)\n      .map(e => e.result);\n  }\n\n  private sameScope(a: ScopePath, b: ScopePath): boolean {\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (a[i].check !== b[i].check || a[i].index !== b[i].index) return false;\n    }\n    return true;\n  }\n\n  // distance from ancestor to current; -1 if not ancestor\n  private ancestorDistance(ancestor: ScopePath, current: ScopePath): number {\n    if (ancestor.length > current.length) return -1;\n    // Treat root scope ([]) as non-ancestor for unrelated branches\n    if (ancestor.length === 0 && current.length > 0) return -1;\n    for (let i = 0; i < ancestor.length; i++) {\n      if (ancestor[i].check !== current[i].check || ancestor[i].index !== current[i].index)\n        return -1;\n    }\n    return current.length - ancestor.length;\n  }\n}\n","import { addEvent } from '../telemetry/trace-helpers';\nimport { addDiagramBlock } from '../telemetry/metrics';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nconst MERMAID_RE = /```mermaid\\s*\\n([\\s\\S]*?)\\n```/gi;\n\nexport type DiagramOrigin = 'content' | 'issue';\n\nexport function emitMermaidFromMarkdown(\n  checkName: string,\n  markdown: string,\n  origin: DiagramOrigin\n): number {\n  if (!markdown || typeof markdown !== 'string') return 0;\n  let m: RegExpExecArray | null;\n  let count = 0;\n  MERMAID_RE.lastIndex = 0;\n  while ((m = MERMAID_RE.exec(markdown)) != null) {\n    const code = (m[1] || '').trim();\n    if (code) {\n      try {\n        addEvent('diagram.block', { check: checkName, origin, code });\n        addDiagramBlock(origin);\n        // Fallback writer for environments where OTel SDK isn't active\n        if (process.env.VISOR_TRACE_REPORT === 'true') {\n          const outDir =\n            process.env.VISOR_TRACE_DIR || path.join(process.cwd(), 'output', 'traces');\n          try {\n            if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });\n            const ts = new Date().toISOString().replace(/[:.]/g, '-');\n            const jsonPath = path.join(outDir, `${ts}.trace.json`);\n            const htmlPath = path.join(outDir, `${ts}.report.html`);\n            // Append or create minimal trace JSON\n            let data: {\n              spans: Array<{ events: Array<{ name: string; attrs: Record<string, unknown> }> }>;\n            } = { spans: [] };\n            if (fs.existsSync(jsonPath)) {\n              try {\n                data = JSON.parse(fs.readFileSync(jsonPath, 'utf8'));\n              } catch {\n                data = { spans: [] };\n              }\n            }\n            data.spans.push({\n              events: [{ name: 'diagram.block', attrs: { check: checkName, origin, code } }],\n            });\n            fs.writeFileSync(jsonPath, JSON.stringify(data, null, 2), 'utf8');\n            // Ensure minimal HTML report exists\n            if (!fs.existsSync(htmlPath)) {\n              fs.writeFileSync(\n                htmlPath,\n                '<!doctype html><html><head><meta charset=\"utf-8\"/><title>Visor Trace Report</title></head><body><h2>Visor Trace Report</h2></body></html>',\n                'utf8'\n              );\n            }\n          } catch {}\n        }\n        count++;\n      } catch {\n        // ignore telemetry failures\n      }\n    }\n  }\n  return count;\n}\n","import {\n  PRReviewer,\n  ReviewSummary,\n  ReviewOptions,\n  GroupedCheckResults,\n  CheckResult,\n  ReviewIssue,\n} from './reviewer';\nimport { GitRepositoryAnalyzer, GitRepositoryInfo } from './git-repository-analyzer';\nimport { AnalysisResult } from './output-formatters';\nimport { PRInfo } from './pr-analyzer';\nimport { PRAnalyzer } from './pr-analyzer';\nimport { CheckProviderRegistry } from './providers/check-provider-registry';\nimport { CheckProviderConfig } from './providers/check-provider.interface';\nimport { DependencyResolver, DependencyGraph } from './dependency-resolver';\nimport { FailureConditionEvaluator } from './failure-condition-evaluator';\nimport { FailureConditionResult, CheckConfig } from './types/config';\nimport { GitHubCheckService, CheckRunOptions } from './github-check-service';\nimport { IssueFilter } from './issue-filter';\nimport { logger } from './logger';\nimport Sandbox from '@nyariv/sandboxjs';\nimport { ExecutionJournal, ScopePath, ContextView } from './snapshot-store';\nimport { createSecureSandbox, compileAndRun } from './utils/sandbox';\nimport { VisorConfig, OnFailConfig, OnSuccessConfig, OnFinishConfig } from './types/config';\nimport {\n  createPermissionHelpers,\n  detectLocalMode,\n  resolveAssociationFromEvent,\n} from './utils/author-permissions';\nimport { MemoryStore } from './memory-store';\nimport { emitNdjsonSpanWithEvents, emitNdjsonFallback } from './telemetry/fallback-ndjson';\nimport { addEvent, withActiveSpan } from './telemetry/trace-helpers';\nimport { addFailIfTriggered } from './telemetry/metrics';\n\ntype ExtendedReviewSummary = ReviewSummary & {\n  output?: unknown;\n  content?: string;\n  isForEach?: boolean;\n  forEachItems?: unknown[];\n  // Preserve per-item results for forEach-dependent checks so children can gate per item\n  forEachItemResults?: ReviewSummary[];\n  // Per-item fatal mask: true means this item is fatal/should gate descendants\n  forEachFatalMask?: boolean[];\n};\n\n/**\n * Statistics for a single check execution\n */\nexport interface CheckExecutionStats {\n  checkName: string;\n  totalRuns: number; // How many times the check executed (1 or forEach iterations)\n  successfulRuns: number;\n  failedRuns: number;\n  skipped: boolean;\n  skipReason?: 'if_condition' | 'fail_fast' | 'dependency_failed';\n  skipCondition?: string; // The actual if condition text\n  totalDuration: number; // Total duration in milliseconds\n  // Provider/self time (excludes time spent running routed children/descendants)\n  providerDurationMs?: number;\n  perIterationDuration?: number[]; // Duration for each iteration (if forEach)\n  issuesFound: number;\n  issuesBySeverity: {\n    critical: number;\n    error: number;\n    warning: number;\n    info: number;\n  };\n  outputsProduced?: number; // Number of outputs for forEach checks\n  errorMessage?: string; // Error message if failed\n  forEachPreview?: string[]; // Preview of forEach items processed (first few)\n}\n\n/**\n * Overall execution statistics for all checks\n */\nexport interface ExecutionStatistics {\n  totalChecksConfigured: number;\n  totalExecutions: number; // Sum of all runs including forEach iterations\n  successfulExecutions: number;\n  failedExecutions: number;\n  skippedChecks: number;\n  totalDuration: number;\n  checks: CheckExecutionStats[];\n}\n\n/**\n * Result of executing checks, including both the grouped results and execution statistics\n */\nexport interface ExecutionResult {\n  results: GroupedCheckResults;\n  statistics: ExecutionStatistics;\n}\n\n/**\n * Filter environment variables to only include safe ones for sandbox evaluation\n */\nfunction getSafeEnvironmentVariables(): Record<string, string> {\n  const { buildSandboxEnv } = require('./utils/env-exposure');\n  return buildSandboxEnv(process.env);\n}\n\nexport interface MockOctokit {\n  rest: {\n    pulls: {\n      get: () => Promise<{ data: Record<string, unknown> }>;\n      listFiles: () => Promise<{ data: Record<string, unknown>[] }>;\n    };\n    issues: {\n      listComments: () => Promise<{ data: Record<string, unknown>[] }>;\n      createComment: () => Promise<{ data: Record<string, unknown> }>;\n    };\n  };\n  request: () => Promise<{ data: Record<string, unknown> }>;\n  graphql: () => Promise<Record<string, unknown>>;\n  log: {\n    debug: (...args: unknown[]) => void;\n    info: (...args: unknown[]) => void;\n    warn: (...args: unknown[]) => void;\n    error: (...args: unknown[]) => void;\n  };\n  hook: {\n    before: (...args: unknown[]) => void;\n    after: (...args: unknown[]) => void;\n    error: (...args: unknown[]) => void;\n    wrap: (...args: unknown[]) => void;\n  };\n  auth: () => Promise<{ token: string }>;\n}\n\nexport interface CheckExecutionOptions {\n  checks: string[];\n  workingDirectory?: string;\n  showDetails?: boolean;\n  timeout?: number;\n  maxParallelism?: number; // Maximum number of checks to run in parallel (default: 3)\n  failFast?: boolean; // Stop execution when any check fails (default: false)\n  outputFormat?: string;\n  config?: import('./types/config').VisorConfig;\n  debug?: boolean; // Enable debug mode to collect AI execution details\n  // Tag filter for selective check execution\n  tagFilter?: import('./types/config').TagFilter;\n  // Webhook context for passing webhook data to http_input providers\n  webhookContext?: {\n    webhookData: Map<string, unknown>;\n  };\n  // GitHub Check integration options\n  githubChecks?: {\n    enabled: boolean;\n    octokit?: import('@octokit/rest').Octokit;\n    owner?: string;\n    repo?: string;\n    headSha?: string;\n    prNumber?: number;\n  };\n}\n\nexport class CheckExecutionEngine {\n  private gitAnalyzer: GitRepositoryAnalyzer;\n  private mockOctokit: MockOctokit;\n  private reviewer: PRReviewer;\n  private providerRegistry: CheckProviderRegistry;\n  private failureEvaluator: FailureConditionEvaluator;\n  private githubCheckService?: GitHubCheckService;\n  private checkRunMap?: Map<string, { id: number; url: string }>;\n  private githubContext?: { owner: string; repo: string };\n  private workingDirectory: string;\n  private config?: import('./types/config').VisorConfig;\n  private webhookContext?: { webhookData: Map<string, unknown> };\n  private routingSandbox?: Sandbox;\n  private executionStats: Map<string, CheckExecutionStats> = new Map();\n  // Track history of all outputs for each check (useful for loops and goto)\n  private outputHistory: Map<string, unknown[]> = new Map();\n  // Track on_finish loop counts per forEach parent during a single execution run\n  private onFinishLoopCounts: Map<string, number> = new Map();\n  // Track how many times a forEach parent check has produced an array during this run (\"waves\")\n  private forEachWaveCounts: Map<string, number> = new Map();\n  // Snapshot+Scope journal (Phase 0: commit only, no behavior changes yet)\n  private journal: ExecutionJournal = new ExecutionJournal();\n  private sessionId: string = `sess-${Date.now().toString(36)}-${Math.random()\n    .toString(36)\n    .slice(2, 8)}`;\n  // Event override to simulate alternate event (used during routing goto)\n  private routingEventOverride?: import('./types/config').EventTrigger;\n  // Execution context for providers (CLI message, hooks, etc.)\n  private executionContext?: import('./providers/check-provider.interface').ExecutionContext;\n  // Cached GitHub context for context elevation when running in Actions\n  private actionContext?: {\n    owner: string;\n    repo: string;\n    octokit?: import('@octokit/rest').Octokit;\n  };\n\n  constructor(workingDirectory?: string, octokit?: import('@octokit/rest').Octokit) {\n    this.workingDirectory = workingDirectory || process.cwd();\n    this.gitAnalyzer = new GitRepositoryAnalyzer(this.workingDirectory);\n    this.providerRegistry = CheckProviderRegistry.getInstance();\n    this.failureEvaluator = new FailureConditionEvaluator();\n\n    // If authenticated octokit is provided, cache it for provider use\n    if (octokit) {\n      const repoEnv = process.env.GITHUB_REPOSITORY || '';\n      const [owner, repo] = repoEnv.split('/') as [string, string];\n      if (owner && repo) {\n        this.actionContext = { owner, repo, octokit };\n      }\n    }\n\n    // Create a mock Octokit instance for local analysis\n    // This allows us to reuse the existing PRReviewer logic without network calls\n    this.mockOctokit = this.createMockOctokit();\n    this.reviewer = new PRReviewer(this.mockOctokit as unknown as import('@octokit/rest').Octokit);\n  }\n\n  private sessionUUID(): string {\n    return this.sessionId;\n  }\n\n  private commitJournal(\n    checkId: string,\n    result: ExtendedReviewSummary,\n    event?: import('./types/config').EventTrigger,\n    scopeOverride?: ScopePath\n  ): void {\n    try {\n      const scope: ScopePath = scopeOverride || [];\n      this.journal.commitEntry({\n        sessionId: this.sessionUUID(),\n        scope,\n        checkId,\n        event,\n        result,\n      });\n    } catch {\n      // best effort; never throw\n    }\n  }\n\n  /** Build dependencyResults from a snapshot of all committed results, optionally overlaying provided results. */\n  private buildSnapshotDependencyResults(\n    scope: ScopePath,\n    overlay: Map<string, ReviewSummary> | undefined,\n    event: import('./types/config').EventTrigger | undefined\n  ): Map<string, ReviewSummary> {\n    const snap = this.journal.beginSnapshot();\n    const view = new ContextView(this.journal, this.sessionUUID(), snap, scope, event);\n    const visible = new Map<string, ReviewSummary>();\n    try {\n      const entries = this.journal.readVisible(this.sessionUUID(), snap, event);\n      const ids = Array.from(new Set(entries.map(e => e.checkId)));\n      for (const id of ids) {\n        const v = view.get(id);\n        if (v) visible.set(id, v);\n        const raw = view.getRaw(id);\n        if (raw) visible.set(`${id}-raw`, raw);\n      }\n      // Overlay any provided results (e.g., per-item context) on top.\n      // Root-cause hardening: ignore non-string keys and log once.\n      if (overlay) {\n        for (const [k, v] of overlay.entries()) {\n          if (typeof k === 'string' && k) {\n            visible.set(k, v);\n          } else {\n            try {\n              require('./logger').logger.warn(\n                `sanitize: dropping non-string overlay key type=${typeof k}`\n              );\n            } catch {}\n          }\n        }\n      }\n    } catch {}\n    return visible;\n  }\n\n  /** Drop any non-string keys from a results-like map (root-cause guard). */\n  private sanitizeResultMapKeys(\n    m: Map<unknown, ReviewSummary> | undefined\n  ): Map<string, ReviewSummary> {\n    const out = new Map<string, ReviewSummary>();\n    if (!m) return out;\n    for (const [k, v] of m.entries()) {\n      if (typeof k === 'string' && k) out.set(k, v);\n      else {\n        try {\n          require('./logger').logger.warn(\n            `sanitize: dropping non-string results key type=${typeof k}`\n          );\n        } catch {}\n      }\n    }\n    return out;\n  }\n\n  /**\n   * Enrich event context with authenticated octokit instance\n   * @param eventContext - The event context to enrich\n   * @returns Enriched event context with octokit if available\n   */\n  private enrichEventContext(eventContext?: Record<string, unknown>): Record<string, unknown> {\n    const baseContext = eventContext || {};\n    if (this.actionContext?.octokit) {\n      return { ...baseContext, octokit: this.actionContext.octokit };\n    }\n    return baseContext;\n  }\n\n  /**\n   * Set execution context for providers (CLI message, hooks, etc.)\n   * This allows passing state without using static properties\n   */\n  setExecutionContext(\n    context: import('./providers/check-provider.interface').ExecutionContext\n  ): void {\n    this.executionContext = context;\n  }\n\n  /**\n   * Lazily create a secure sandbox for routing JS (goto_js, run_js)\n   */\n  private getRoutingSandbox(): Sandbox {\n    if (this.routingSandbox) return this.routingSandbox;\n    this.routingSandbox = createSecureSandbox();\n    return this.routingSandbox;\n  }\n\n  private redact(str: unknown, limit = 200): string {\n    try {\n      const s = typeof str === 'string' ? str : JSON.stringify(str);\n      return s.length > limit ? s.slice(0, limit) + '…' : s;\n    } catch {\n      return String(str).slice(0, limit);\n    }\n  }\n\n  private async sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  private deterministicJitter(baseMs: number, seedStr: string): number {\n    let h = 2166136261;\n    for (let i = 0; i < seedStr.length; i++) h = (h ^ seedStr.charCodeAt(i)) * 16777619;\n    const frac = ((h >>> 0) % 1000) / 1000; // 0..1\n    return Math.floor(baseMs * 0.15 * frac); // up to 15% jitter\n  }\n\n  private computeBackoffDelay(\n    attempt: number,\n    mode: 'fixed' | 'exponential',\n    baseMs: number,\n    seed: string\n  ): number {\n    const jitter = this.deterministicJitter(baseMs, seed);\n    if (mode === 'exponential') {\n      return baseMs * Math.pow(2, Math.max(0, attempt - 1)) + jitter;\n    }\n    return baseMs + jitter;\n  }\n\n  /**\n   * Execute a single named check inline (used by routing logic and on_finish)\n   * This is extracted from executeWithRouting to be reusable\n   */\n  private async executeCheckInline(\n    checkId: string,\n    event: import('./types/config').EventTrigger,\n    context: {\n      config: VisorConfig;\n      dependencyGraph: DependencyGraph;\n      prInfo: PRInfo;\n      resultsMap: Map<string, ReviewSummary>;\n      dependencyResults: Map<string, ReviewSummary>;\n      sessionInfo?: { parentSessionId?: string; reuseSession?: boolean };\n      debug: boolean;\n      eventOverride?: import('./types/config').EventTrigger;\n      scope?: ScopePath;\n      origin?: 'on_finish' | 'on_success' | 'on_fail' | 'foreach' | 'initial' | 'inline';\n    }\n  ): Promise<ReviewSummary> {\n    const {\n      config,\n      prInfo,\n      resultsMap,\n      dependencyResults,\n      sessionInfo,\n      debug,\n      eventOverride,\n      scope,\n    } = context;\n    const log = (msg: string) => (config?.output?.pr_comment ? console.error : console.log)(msg);\n    const origin = (context as any).origin || 'inline';\n\n    // Find the check configuration\n    const checkConfig = config?.checks?.[checkId];\n    if (!checkConfig) {\n      throw new Error(`on_finish referenced unknown check '${checkId}'`);\n    }\n\n    // Helper to get all dependencies recursively from config\n    const getAllDepsFromConfig = (name: string): string[] => {\n      const visited = new Set<string>();\n      const acc: string[] = [];\n      const dfs = (n: string) => {\n        if (visited.has(n)) return;\n        visited.add(n);\n        const cfg = config?.checks?.[n];\n        const deps = cfg?.depends_on || [];\n        for (const d of deps) {\n          acc.push(d);\n          dfs(d);\n        }\n      };\n      dfs(name);\n      return Array.from(new Set(acc));\n    };\n\n    // Ensure all dependencies of target are available; execute missing ones in topological order\n    const allTargetDeps = getAllDepsFromConfig(checkId);\n    if (allTargetDeps.length > 0) {\n      // Build subgraph mapping for ordered execution\n      const subSet = new Set<string>([...allTargetDeps]);\n      const subDeps: Record<string, string[]> = {};\n      for (const id of subSet) {\n        const cfg = config?.checks?.[id];\n        subDeps[id] = (cfg?.depends_on || []).filter(d => subSet.has(d));\n      }\n      const subGraph = DependencyResolver.buildDependencyGraph(subDeps);\n      for (const group of subGraph.executionOrder) {\n        for (const depId of group.parallel) {\n          // Skip if already have results\n          if (resultsMap?.has(depId) || dependencyResults.has(depId)) continue;\n          // Execute dependency inline (recursively ensures its deps are also present)\n          await this.executeCheckInline(depId, event, context);\n        }\n      }\n    }\n\n    // Get provider for this check\n    const providerType = checkConfig.type || 'ai';\n    const provider = this.providerRegistry.getProviderOrThrow(providerType);\n    this.setProviderWebhookContext(provider);\n\n    // Build provider configuration\n    const provCfg: CheckProviderConfig = {\n      type: providerType,\n      prompt: checkConfig.prompt,\n      exec: checkConfig.exec,\n      focus: checkConfig.focus || this.mapCheckNameToFocus(checkId),\n      schema: checkConfig.schema,\n      group: checkConfig.group,\n      checkName: checkId,\n      eventContext: this.enrichEventContext(prInfo.eventContext),\n      transform: checkConfig.transform,\n      transform_js: checkConfig.transform_js,\n      env: checkConfig.env,\n      forEach: checkConfig.forEach,\n      // Pass output history for loop/goto scenarios\n      __outputHistory: this.outputHistory,\n      // Include provider-specific keys (e.g., op/values for github)\n      ...checkConfig,\n      ai: {\n        ...(checkConfig.ai || {}),\n        timeout: checkConfig.ai?.timeout || 600000,\n        debug: !!debug,\n      },\n    };\n\n    // Build dependency results for this check using snapshot-based visibility (overlay per-scope results)\n    const depResults = this.buildSnapshotDependencyResults(\n      scope || [],\n      dependencyResults,\n      eventOverride || prInfo.eventType\n    );\n\n    // Debug: log key dependent outputs for visibility\n    if (debug) {\n      try {\n        const depPreview: Record<string, unknown> = {};\n        for (const [k, v] of depResults.entries()) {\n          const out = (v as any)?.output;\n          if (out !== undefined) depPreview[k] = out;\n        }\n        log(`🔧 Debug: inline exec '${checkId}' deps output: ${JSON.stringify(depPreview)}`);\n      } catch {}\n    }\n\n    if (debug) {\n      const execStr = (provCfg as any).exec;\n      if (execStr) log(`🔧 Debug: inline exec '${checkId}' command: ${execStr}`);\n    }\n\n    // If event override provided, clone prInfo with overridden eventType\n    let prInfoForInline = prInfo;\n    const prevEventOverride = this.routingEventOverride;\n    if (eventOverride) {\n      // Try to elevate to PR context when routing to PR events from issue threads\n      const elevated = await this.elevateContextToPullRequest(\n        { ...(prInfo as any), eventType: eventOverride } as PRInfo,\n        eventOverride,\n        log,\n        debug\n      );\n      if (elevated) {\n        prInfoForInline = elevated;\n      } else {\n        prInfoForInline = { ...(prInfo as any), eventType: eventOverride } as PRInfo;\n      }\n      this.routingEventOverride = eventOverride;\n      const msg = `↪ goto_event: inline '${checkId}' with event=${eventOverride}${\n        elevated ? ' (elevated to PR context)' : ''\n      }`;\n      if (debug) log(`🔧 Debug: ${msg}`);\n      try {\n        require('./logger').logger.info(msg);\n      } catch {}\n    }\n\n    // Execute the check\n    let result: ReviewSummary;\n    try {\n      const __provStart = Date.now();\n      const inlineContext: import('./providers/check-provider.interface').ExecutionContext = {\n        ...sessionInfo,\n        ...this.executionContext,\n      } as any;\n      result = await withActiveSpan(\n        `visor.check.${checkId}`,\n        { 'visor.check.id': checkId, 'visor.check.type': provCfg.type || 'ai' },\n        async () => provider.execute(prInfoForInline, provCfg, depResults, inlineContext)\n      );\n      this.recordProviderDuration(checkId, Date.now() - __provStart);\n    } catch (error) {\n      // Restore previous override before rethrowing\n      this.routingEventOverride = prevEventOverride;\n      throw error;\n    } finally {\n      // Always restore previous override\n      this.routingEventOverride = prevEventOverride;\n    }\n\n    // Enrich issues with metadata\n    const enrichedIssues = (result.issues || []).map(issue => ({\n      ...issue,\n      checkName: checkId,\n      ruleId: `${checkId}/${issue.ruleId}`,\n      group: checkConfig.group,\n      schema: typeof checkConfig.schema === 'object' ? 'custom' : checkConfig.schema,\n      template: checkConfig.template,\n      timestamp: Date.now(),\n    }));\n    let enriched = { ...result, issues: enrichedIssues } as ReviewSummary;\n\n    // Track output history for loop/goto scenarios\n    const enrichedWithOutput = enriched as ReviewSummary & { output?: unknown };\n    if (enrichedWithOutput.output !== undefined) {\n      this.trackOutputHistory(checkId, enrichedWithOutput.output);\n    }\n\n    // Handle forEach iteration for this check if it returned an array\n    if (checkConfig.forEach && Array.isArray(enrichedWithOutput.output)) {\n      const forEachItems = enrichedWithOutput.output;\n      // Always log forEach detection (not just in debug mode) for visibility\n      const wave = (this.forEachWaveCounts.get(checkId) || 0) + 1;\n      this.forEachWaveCounts.set(checkId, wave);\n      log(\n        `🔄 forEach check '${checkId}' returned ${forEachItems.length} items - starting iteration (wave #${wave}, origin=${origin})`\n      );\n      if (debug) {\n        log(\n          `🔧 Debug: forEach item preview: ${JSON.stringify(forEachItems[0] || {}).substring(0, 200)}`\n        );\n      }\n\n      // Store the array output with forEach metadata\n      const forEachResult = {\n        ...enriched,\n        forEachItems,\n        forEachItemResults: forEachItems.map(item => ({\n          issues: [],\n          output: item,\n        })),\n      };\n      enriched = forEachResult as ReviewSummary;\n\n      // Make the parent result visible to dependency resolution BEFORE scheduling dependents\n      // so that recursive dependency checks do not re-execute this forEach parent in the same wave.\n      try {\n        resultsMap?.set(checkId, enriched);\n      } catch {}\n\n      // Phase 4: commit aggregate parent result early (root scope) so outputs_raw is visible\n      this.commitJournal(\n        checkId,\n        enriched as ExtendedReviewSummary,\n        prInfoForInline.eventType || prInfo.eventType,\n        []\n      );\n\n      // Wave guard: if waves exceed routing.max_loops, stop scheduling dependents to prevent runaway loops\n      const maxLoops = config?.routing?.max_loops ?? 10;\n      if (wave > maxLoops) {\n        try {\n          logger.warn(\n            `⛔ forEach wave guard: '${checkId}' exceeded max_loops=${maxLoops} (wave #${wave}); skipping dependents and routing`\n          );\n        } catch {}\n        // Store and return aggregated result\n        resultsMap?.set(checkId, enriched);\n        return enriched;\n      }\n\n      // Find checks that depend on this forEach check\n      const dependentChecks = Object.keys(config?.checks || {}).filter(name => {\n        const cfg = config?.checks?.[name];\n        return cfg?.depends_on?.includes(checkId);\n      });\n\n      // Always log dependents for visibility\n      try {\n        if (dependentChecks.length > 0) {\n          log(\n            `🔄 forEach check '${checkId}' has ${dependentChecks.length} dependents: ${dependentChecks.join(', ')}`\n          );\n        } else {\n          log(`⚠️  forEach check '${checkId}' has NO dependents - nothing to iterate`);\n        }\n      } catch {}\n\n      // Execute each dependent check once per forEach item (scope-based; no per-item map cloning)\n      for (const depCheckName of dependentChecks) {\n        const depCheckConfig = config?.checks?.[depCheckName];\n        if (!depCheckConfig) continue;\n\n        // Always (re)run dependents during inline reruns (on_finish.goto to parent).\n        // We intentionally do not short-circuit on existing results here so stats/history\n        // reflect multiple waves.\n        // Skip if no items to iterate over\n        if (forEachItems.length === 0) {\n          if (debug) {\n            log(`🔧 Debug: Skipping forEach dependent '${depCheckName}' - no items to iterate`);\n          }\n          // Store empty result\n          resultsMap?.set(depCheckName, { issues: [] });\n          continue;\n        }\n\n        // Always log iteration start\n        try {\n          const wave = this.forEachWaveCounts.get(checkId) || 1;\n          log(\n            `🔄 Executing forEach dependent '${depCheckName}' for ${forEachItems.length} items (wave #${wave})`\n          );\n        } catch {}\n\n        const depResults: ReviewSummary[] = [];\n\n        // Execute once per forEach item\n        for (let itemIndex = 0; itemIndex < forEachItems.length; itemIndex++) {\n          const item = forEachItems[itemIndex];\n          const wave = this.forEachWaveCounts.get(checkId) || 1;\n          log(\n            `  🔄 Iteration ${itemIndex + 1}/${forEachItems.length} f|| '${depCheckName}' (wave #${wave})`\n          );\n\n          // Phase 4: Commit per-item entry for parent in journal under item scope\n          const itemScope: ScopePath = [{ check: checkId, index: itemIndex }];\n          try {\n            this.commitJournal(\n              checkId,\n              { issues: [], output: item } as ExtendedReviewSummary,\n              prInfoForInline.eventType || prInfo.eventType,\n              itemScope\n            );\n          } catch {}\n\n          try {\n            // Build provider + config for dependent and execute with full routing semantics\n            const depProviderType = depCheckConfig.type || 'ai';\n            const depProvider = this.providerRegistry.getProviderOrThrow(depProviderType);\n            this.setProviderWebhookContext(depProvider);\n\n            // Build dependency results from snapshot at item scope (no cloning)\n            const snapshotDeps = this.buildSnapshotDependencyResults(\n              itemScope,\n              undefined,\n              prInfoForInline.eventType || prInfo.eventType\n            );\n\n            // Use unified helper to ensure stats and history are tracked for each item run\n            const res = await this.runNamedCheck(depCheckName, itemScope, {\n              origin: 'foreach',\n              config: config!,\n              dependencyGraph: context.dependencyGraph,\n              prInfo,\n              resultsMap: resultsMap || new Map(),\n              debug: !!debug,\n              eventOverride: prInfoForInline.eventType || prInfo.eventType,\n              overlay: snapshotDeps,\n            });\n            depResults.push(res);\n          } catch (error) {\n            // Store error result for this iteration\n            const errorMsg = error instanceof Error ? error.message : String(error);\n            const errorIssue: ReviewIssue = {\n              file: '',\n              line: 0,\n              ruleId: `${depCheckName}/forEach/iteration_error`,\n              message: `forEach iteration ${itemIndex + 1} failed: ${errorMsg}`,\n              severity: 'error',\n              category: 'logic',\n            };\n            depResults.push({\n              issues: [errorIssue],\n            });\n          }\n        }\n\n        // Aggregate results from all iterations\n        const aggregatedResult: ReviewSummary = {\n          issues: depResults.flatMap(r => r.issues || []),\n        };\n\n        // Store in results map\n        resultsMap?.set(depCheckName, aggregatedResult);\n\n        if (debug) {\n          log(\n            `🔧 Debug: Completed forEach dependent '${depCheckName}' with ${depResults.length} iterations`\n          );\n        }\n      }\n    }\n\n    // Store result in results map\n    resultsMap?.set(checkId, enriched);\n    // Commit to journal with provided scope (or root). Avoid double-commit if we already committed aggregate above.\n    const isForEachAggregate = checkConfig.forEach && Array.isArray(enrichedWithOutput.output);\n    if (!isForEachAggregate) {\n      this.commitJournal(\n        checkId,\n        enriched as ExtendedReviewSummary,\n        prInfoForInline.eventType || prInfo.eventType,\n        scope || []\n      );\n    }\n\n    if (debug) log(`🔧 Debug: inline executed '${checkId}', issues: ${enrichedIssues.length}`);\n\n    return enriched;\n  }\n\n  /**\n   * Phase 3: Unified scheduling helper\n   * Runs a named check in the current session/scope and records results.\n   * Used by on_success/on_fail/on_finish routing and internal inline execution.\n   */\n  private async runNamedCheck(\n    target: string,\n    scope: ScopePath,\n    opts: {\n      config: VisorConfig;\n      dependencyGraph: DependencyGraph;\n      prInfo: PRInfo;\n      resultsMap: Map<string, ReviewSummary>;\n      debug: boolean;\n      sessionInfo?: { parentSessionId?: string; reuseSession?: boolean };\n      eventOverride?: import('./types/config').EventTrigger;\n      overlay?: Map<string, ReviewSummary>;\n      origin?: 'on_finish' | 'on_success' | 'on_fail' | 'foreach' | 'initial' | 'inline';\n    }\n  ): Promise<ReviewSummary> {\n    const {\n      config,\n      dependencyGraph,\n      prInfo,\n      resultsMap,\n      debug,\n      sessionInfo,\n      eventOverride,\n      overlay,\n    } = opts;\n\n    // Build context overlay from current results; prefer snapshot visibility for scope (Phase 4)\n    const depOverlay = overlay ? new Map(overlay) : new Map(resultsMap);\n    const depOverlaySanitized = this.sanitizeResultMapKeys(depOverlay);\n    // For event overrides, avoid leaking cross-event results via overlay; rely on snapshot-only view\n    const overlayForExec =\n      eventOverride && eventOverride !== (prInfo.eventType || 'manual')\n        ? new Map<string, ReviewSummary>()\n        : depOverlaySanitized;\n    if (!this.executionStats.has(target)) this.initializeCheckStats(target);\n    const startTs = this.recordIterationStart(target);\n    try {\n      const res = await this.executeCheckInline(\n        target,\n        eventOverride || prInfo.eventType || 'manual',\n        {\n          config,\n          dependencyGraph,\n          prInfo,\n          resultsMap,\n          // Use snapshot-only deps when eventOverride is set\n          dependencyResults: overlayForExec,\n          sessionInfo,\n          debug,\n          eventOverride,\n          scope,\n          origin: opts.origin || 'inline',\n        }\n      );\n      const issues = (res.issues || []).map(i => ({ ...i }));\n      const success = !this.hasFatal(issues);\n      const out: unknown = (res as { output?: unknown }).output;\n      const isForEachParent =\n        (res as any)?.isForEach === true ||\n        Array.isArray((res as any)?.forEachItems) ||\n        Array.isArray(out);\n      this.recordIterationComplete(\n        target,\n        startTs,\n        success,\n        issues,\n        isForEachParent ? undefined : out\n      );\n      return res;\n    } catch (e) {\n      this.recordIterationComplete(target, startTs, false, [], undefined);\n      throw e;\n    }\n  }\n\n  /**\n   * Handle on_finish hooks for forEach checks after ALL dependents complete\n   */\n  private async handleOnFinishHooks(\n    config: VisorConfig,\n    dependencyGraph: DependencyGraph,\n    results: Map<string, ReviewSummary>,\n    prInfo: PRInfo,\n    debug: boolean\n  ): Promise<void> {\n    const log = (msg: string) => (config?.output?.pr_comment ? console.error : console.log)(msg);\n\n    // Find all checks with forEach: true and on_finish configured\n    const forEachChecksWithOnFinish: Array<{\n      checkName: string;\n      checkConfig: CheckConfig;\n      onFinish: OnFinishConfig;\n    }> = [];\n\n    for (const [checkName, checkConfig] of Object.entries(config.checks || {})) {\n      if (checkConfig.forEach && checkConfig.on_finish) {\n        forEachChecksWithOnFinish.push({\n          checkName,\n          checkConfig,\n          onFinish: checkConfig.on_finish,\n        });\n      }\n    }\n\n    if (forEachChecksWithOnFinish.length === 0) {\n      return; // No on_finish hooks to process\n    }\n\n    if (debug) {\n      log(`🎯 Processing on_finish hooks for ${forEachChecksWithOnFinish.length} forEach check(s)`);\n    }\n\n    // Process each forEach check's on_finish hook\n    for (const { checkName, checkConfig, onFinish } of forEachChecksWithOnFinish) {\n      try {\n        const forEachResult = results.get(checkName) as ExtendedReviewSummary | undefined;\n        if (!forEachResult) {\n          if (debug) log(`⚠️ No result found for forEach check \"${checkName}\", skipping on_finish`);\n          continue;\n        }\n\n        // Skip if the forEach check returned empty array\n        const forEachItems = forEachResult.forEachItems || [];\n        if (forEachItems.length === 0) {\n          if (debug) log(`⏭  Skipping on_finish for \"${checkName}\" - forEach returned 0 items`);\n          continue;\n        }\n\n        // Get all dependents of this forEach check\n        const node = dependencyGraph.nodes.get(checkName);\n        const dependents = node?.dependents || [];\n\n        if (debug) {\n          log(`🔍 on_finish for \"${checkName}\": ${dependents.length} dependent(s)`);\n        }\n\n        // Verify all dependents have completed\n        const allDependentsCompleted = dependents.every(dep => results.has(dep));\n        if (!allDependentsCompleted) {\n          if (debug) log(`⚠️ Not all dependents of \"${checkName}\" completed, skipping on_finish`);\n          continue;\n        }\n\n        logger.info(`▶ on_finish: processing for \"${checkName}\"`);\n\n        // Build context for on_finish evaluation\n        const outputsForContext: Record<string, unknown> = {};\n        for (const [name, result] of results.entries()) {\n          const r = result as import('./reviewer').ReviewSummary & { output?: unknown };\n          outputsForContext[name] = r.output !== undefined ? r.output : r;\n        }\n        // Also expose output history for each check (parity with docs/examples)\n        const outputsHistoryForContext: Record<string, unknown[]> = {};\n        try {\n          // this.outputHistory tracks all outputs per check across the run\n          // Convert to a plain object for sandbox consumption\n          for (const [check, history] of this.outputHistory.entries()) {\n            outputsHistoryForContext[check] = history as unknown[];\n          }\n          // Attach to outputs as a nested property for `outputs.history[...]`\n          /* outputs.history available via outputsMergedForContext */\n        } catch {}\n\n        // Create forEach stats\n        const forEachStats = {\n          total: forEachItems.length,\n          successful: forEachResult.forEachItemResults\n            ? forEachResult.forEachItemResults.filter(\n                r => r && (!r.issues || r.issues.length === 0)\n              ).length\n            : forEachItems.length,\n          failed: forEachResult.forEachItemResults\n            ? forEachResult.forEachItemResults.filter(r => r && r.issues && r.issues.length > 0)\n                .length\n            : 0,\n          items: forEachItems,\n        };\n\n        // Get memory store for context\n        const memoryStore = MemoryStore.getInstance(this.config?.memory);\n        const memoryHelpers = {\n          get: (key: string, ns?: string) => memoryStore.get(key, ns),\n          has: (key: string, ns?: string) => memoryStore.has(key, ns),\n          list: (ns?: string) => memoryStore.list(ns),\n          getAll: (ns?: string) => {\n            const keys = memoryStore.list(ns);\n            const result: Record<string, unknown> = {};\n            for (const key of keys) {\n              result[key] = memoryStore.get(key, ns);\n            }\n            return result;\n          },\n          set: (key: string, value: unknown, ns?: string) => {\n            const nsName = ns || memoryStore.getDefaultNamespace();\n            if (!memoryStore['data'].has(nsName)) {\n              memoryStore['data'].set(nsName, new Map());\n            }\n            memoryStore['data'].get(nsName)!.set(key, value);\n          },\n          increment: (key: string, amount: number, ns?: string) => {\n            const current = memoryStore.get(key, ns);\n            const numCurrent = typeof current === 'number' ? current : 0;\n            const newValue = numCurrent + amount;\n            const nsName = ns || memoryStore.getDefaultNamespace();\n            if (!memoryStore['data'].has(nsName)) {\n              memoryStore['data'].set(nsName, new Map());\n            }\n            memoryStore['data'].get(nsName)!.set(key, newValue);\n            return newValue;\n          },\n        };\n\n        // Build outputs_raw for on_finish (aggregate values)\n        const outputsRawForContext: Record<string, unknown> = {};\n        try {\n          for (const [name, val] of Object.entries(outputsForContext)) {\n            if (name === 'history') continue;\n            outputsRawForContext[name] = val;\n          }\n        } catch {}\n\n        // Build full context for on_finish evaluation\n        const outputsMergedForContext: Record<string, unknown> = {\n          ...outputsForContext,\n          history: outputsHistoryForContext,\n        };\n\n        const onFinishContext = {\n          step: { id: checkName, tags: checkConfig.tags || [], group: checkConfig.group },\n          attempt: 1,\n          loop: 0,\n          outputs: outputsMergedForContext,\n          // Provide explicit alias for templates that prefer snake_case\n          outputs_history: outputsHistoryForContext,\n          outputs_raw: outputsRawForContext,\n          forEach: forEachStats,\n          memory: memoryHelpers,\n          pr: {\n            number: prInfo.number,\n            title: prInfo.title,\n            author: prInfo.author,\n            branch: prInfo.head,\n            base: prInfo.base,\n          },\n          files: prInfo.files,\n          env: getSafeEnvironmentVariables(),\n          event: { name: prInfo.eventType || 'manual' },\n        };\n\n        // Diagnostics: log attempt, dependents, items, and current budget usage\n        try {\n          const ns = 'fact-validation';\n          const attemptNow = Number(memoryStore.get('fact_validation_attempt', ns) || 0);\n          const usedBudget = this.onFinishLoopCounts.get(checkName) || 0;\n          const maxBudget = config?.routing?.max_loops ?? 10;\n          logger.info(\n            `🧭 on_finish: check=\"${checkName}\" items=${forEachItems.length} dependents=${dependents.length} attempt=${attemptNow} budget=${usedBudget}/${maxBudget}`\n          );\n          const vfHist = (outputsHistoryForContext['validate-fact'] as unknown[]) || [];\n          if (vfHist.length) {\n            logger.debug(`🧭 on_finish: outputs.history['validate-fact'] length=${vfHist.length}`);\n          }\n        } catch {}\n\n        let lastRunOutput: unknown = undefined;\n\n        // Execute on_finish.run (static + dynamic via run_js) sequentially\n        {\n          const maxLoops = config?.routing?.max_loops ?? 10;\n          let loopCount = 0;\n\n          // Helper to evaluate run_js to string[] safely\n          const evalRunJs = async (js?: string): Promise<string[]> => {\n            if (!js) return [];\n            try {\n              const sandbox = this.getRoutingSandbox();\n              const scope = onFinishContext;\n              const code = `\n                const step = scope.step; const attempt = scope.attempt; const loop = scope.loop; const outputs = scope.outputs; const outputs_history = scope.outputs_history; const outputs_raw = scope.outputs_raw; const forEach = scope.forEach; const memory = scope.memory; const pr = scope.pr; const files = scope.files; const env = scope.env; const event = scope.event; const log = (...a)=> console.log('🔍 Debug:',...a);\n                const __fn = () => {\\n${js}\\n};\n                const __res = __fn();\n                return Array.isArray(__res) ? __res.filter(x => typeof x === 'string' && x) : [];\n              `;\n              try {\n                if (code.includes('process')) {\n                  logger.warn('⚠️ on_finish.goto_js prelude contains \"process\" token');\n                } else {\n                  logger.info('🔧 on_finish.goto_js prelude is clean (no process token)');\n                }\n              } catch {}\n              const exec = sandbox.compile(code);\n              const res = exec({ scope }).run();\n              return Array.isArray(res) ? (res as string[]) : [];\n            } catch (e) {\n              const msg = e instanceof Error ? e.message : String(e);\n              logger.error(`✗ on_finish.run_js: evaluation failed for \"${checkName}\": ${msg}`);\n              if (e instanceof Error && e.stack) logger.debug(`Stack trace: ${e.stack}`);\n              return [];\n            }\n          };\n\n          const dynamicRun = await evalRunJs(onFinish.run_js);\n          const runList = Array.from(\n            new Set([...(onFinish.run || []), ...dynamicRun].filter(Boolean))\n          );\n\n          if (runList.length > 0) {\n            logger.info(`▶ on_finish.run: executing [${runList.join(', ')}] for \"${checkName}\"`);\n          }\n\n          try {\n            for (const runCheckId of runList) {\n              if (++loopCount > maxLoops) {\n                throw new Error(\n                  `Routing loop budget exceeded (max_loops=${maxLoops}) during on_finish run`\n                );\n              }\n              if (debug) log(`🔧 Debug: on_finish.run executing check '${runCheckId}'`);\n              logger.info(`  ▶ Executing on_finish check: ${runCheckId}`);\n\n              const __onFinishRes = await this.runNamedCheck(runCheckId, [], {\n                origin: 'on_finish',\n                config,\n                dependencyGraph,\n                prInfo,\n                resultsMap: results,\n                sessionInfo: undefined,\n                debug,\n                eventOverride: onFinish.goto_event,\n                overlay: new Map(results),\n              });\n              try {\n                lastRunOutput = (__onFinishRes as any)?.output;\n              } catch {}\n              logger.info(`  ✓ Completed on_finish check: ${runCheckId}`);\n            }\n            if (runList.length > 0) {\n              logger.info(`✓ on_finish.run: completed for \"${checkName}\"`);\n            }\n          } catch (error) {\n            const errorMsg = error instanceof Error ? error.message : String(error);\n            logger.error(`✗ on_finish.run: failed for \"${checkName}\": ${errorMsg}`);\n            if (error instanceof Error && error.stack) {\n              logger.debug(`Stack trace: ${error.stack}`);\n            }\n            throw error;\n          }\n        }\n\n        // After on_finish.run completes, recompute an authoritative 'all_valid' flag from\n        // the latest validate-fact history and persist it to memory. This ensures goto_js\n        // sees a consistent value even if a prior aggregate step ran out of order.\n        try {\n          const vfNow = (this.outputHistory.get('validate-fact') || []) as unknown[];\n          if (\n            Array.isArray(vfNow) &&\n            forEachItems.length > 0 &&\n            vfNow.length >= forEachItems.length\n          ) {\n            const lastWave = vfNow.slice(-forEachItems.length);\n            const ok = lastWave.every(\n              (v: any) => v && (v.is_valid === true || (v as any).valid === true)\n            );\n            await MemoryStore.getInstance(this.config?.memory).set(\n              'all_valid',\n              ok,\n              'fact-validation'\n            );\n            try {\n              logger.info(\n                `🧮 on_finish: recomputed all_valid=${ok} from history for \"${checkName}\"`\n              );\n            } catch {}\n          }\n        } catch {}\n        // Evaluate on_finish.goto_js for routing decision\n        let gotoTarget: string | null = null;\n\n        if (onFinish.goto_js) {\n          logger.info(`▶ on_finish.goto_js: evaluating for \"${checkName}\"`);\n\n          try {\n            const sandbox = this.getRoutingSandbox();\n            const scope = onFinishContext;\n\n            const code = `\n              const step = scope.step; const attempt = scope.attempt; const loop = scope.loop; const outputs = scope.outputs; const outputs_history = scope.outputs_history; const outputs_raw = scope.outputs_raw; const forEach = scope.forEach; const memory = scope.memory; const pr = scope.pr; const files = scope.files; const env = scope.env; const event = scope.event; const log = (...a)=> console.log('🔍 Debug:',...a);\n              const __fn = () => {\\n${onFinish.goto_js}\\n};\n              const __res = __fn();\n              return (typeof __res === 'string' && __res) ? __res : null;\n            `;\n\n            const exec = sandbox.compile(code);\n            const result = exec({ scope }).run();\n            gotoTarget = typeof result === 'string' && result ? result : null;\n\n            if (debug) {\n              log(`🔧 Debug: on_finish.goto_js evaluated → ${this.redact(gotoTarget)}`);\n            }\n\n            logger.info(\n              `✓ on_finish.goto_js: evaluated to '${gotoTarget || 'null'}' for \"${checkName}\"`\n            );\n          } catch (error) {\n            const errorMsg = error instanceof Error ? error.message : String(error);\n            logger.warn(`⚠️ on_finish.goto_js: evaluation failed for \"${checkName}\": ${errorMsg}`);\n            if (error instanceof Error && error.stack) {\n              logger.debug(`Stack trace: ${error.stack}`);\n            }\n\n            // Fallback to static goto if goto_js fails\n            if (onFinish.goto) {\n              logger.info(`  ⚠ Falling back to static goto: '${onFinish.goto}'`);\n              gotoTarget = onFinish.goto;\n            }\n          }\n        } else if (onFinish.goto) {\n          // Static goto\n          gotoTarget = onFinish.goto;\n          logger.info(`▶ on_finish.goto: routing to '${gotoTarget}' for \"${checkName}\"`);\n        }\n\n        // Execute routing if we have a target\n        if (gotoTarget) {\n          // Special safety: check memory flag and last aggregator output\n\n          try {\n            const memDbg = MemoryStore.getInstance(this.config?.memory);\n            const dbgVal = memDbg.get('all_valid', 'fact-validation');\n            try {\n              logger.info(`  🧪 on_finish.goto: mem all_valid currently=${String(dbgVal)}`);\n            } catch {}\n          } catch {}\n\n          try {\n            const mem = MemoryStore.getInstance(this.config?.memory);\n            const allValidMem = mem.get('all_valid', 'fact-validation');\n            const lro =\n              lastRunOutput && typeof lastRunOutput === 'object'\n                ? (lastRunOutput as Record<string, unknown>)\n                : undefined;\n            const allValidOut = lro\n              ? lro['all_valid'] === true || (lro as Record<string, unknown>)['allValid'] === true\n              : false;\n\n            try {\n              logger.info(\n                `  🔒 on_finish.goto guard: gotoTarget=${String(gotoTarget)} allValidMem=${String(allValidMem)} allValidOut=${String(allValidOut)}`\n              );\n            } catch {}\n            if (gotoTarget === checkName && (allValidMem === true || allValidOut === true)) {\n              logger.info(`✓ on_finish.goto: skipping routing to '${gotoTarget}' (all_valid=true)`);\n              gotoTarget = null as any;\n            }\n          } catch {}\n\n          // Extra deterministic guard: if the last wave of validate-fact is all valid,\n          try {\n            const __h = this.outputHistory.get('validate-fact');\n            logger.info(\n              `  🧪 on_finish.goto: validate-fact history now len=${Array.isArray(__h) ? __h.length : 0}`\n            );\n          } catch {}\n          // skip routing back to the forEach parent even if goto_js requested it.\n          try {\n            if (gotoTarget === checkName) {\n              const vfHistNow = (this.outputHistory.get('validate-fact') || []) as unknown[];\n              if (Array.isArray(vfHistNow) && forEachItems.length > 0) {\n                const verdicts = vfHistNow\n                  .map(v => (v && typeof v === 'object' ? (v as any) : undefined))\n                  .filter(\n                    v => v && (typeof v.is_valid === 'boolean' || typeof v.valid === 'boolean')\n                  )\n                  .map(v => v.is_valid === true || v.valid === true);\n                if (verdicts.length >= forEachItems.length) {\n                  const lastVerdicts = verdicts.slice(-forEachItems.length);\n                  const allTrue = lastVerdicts.every(Boolean);\n                  if (allTrue) {\n                    try {\n                      logger.info(\n                        `✓ on_finish.goto: history verdicts all valid; skipping routing to '${gotoTarget}'`\n                      );\n                    } catch {}\n                    gotoTarget = null as any;\n                  }\n                }\n              }\n            }\n          } catch {}\n\n          // If gotoTarget was cleared (e.g., all_valid guard), skip routing\n          if (!gotoTarget) {\n            try {\n              logger.info(`✓ on_finish.goto: no routing needed for \"${checkName}\"`);\n            } catch {}\n            continue;\n          }\n\n          // Secondary guard: if the common dependent 'validate-fact' history shows all items valid,\n          // avoid routing back to the forEach parent even if goto_js asked to.\n          try {\n            if (gotoTarget === checkName) {\n              const vfHist = this.outputHistory.get('validate-fact');\n              const arr = Array.isArray(vfHist) ? (vfHist as unknown[]) : [];\n              const allOk = arr.length > 0 && arr.every((v: any) => v && v.is_valid === true);\n              if (allOk) {\n                logger.info(\n                  `✓ on_finish.goto: validate-fact history all valid; skipping routing to '${gotoTarget}'`\n                );\n                continue;\n              }\n            }\n          } catch {}\n\n          // Count toward loop budget similar to other routing paths (per-parent on_finish)\n          const maxLoops = config?.routing?.max_loops ?? 10;\n          const used = (this.onFinishLoopCounts.get(checkName) || 0) + 1;\n          if (used > maxLoops) {\n            logger.warn(\n              `⚠️ on_finish: loop budget exceeded for \"${checkName}\" (max_loops=${maxLoops}); last goto='${gotoTarget}'. Skipping further routing.`\n            );\n            continue;\n          }\n          this.onFinishLoopCounts.set(checkName, used);\n\n          logger.info(\n            `▶ on_finish: routing from \"${checkName}\" to \"${gotoTarget}\" (budget ${used}/${maxLoops})`\n          );\n\n          try {\n            const tcfg = config.checks?.[gotoTarget as string];\n            const mode =\n              tcfg?.fanout === 'map' ? 'map' : tcfg?.reduce ? 'reduce' : tcfg?.fanout || 'default';\n            const scheduleOnce = async (scopeForRun: ScopePath) =>\n              this.runNamedCheck(gotoTarget!, scopeForRun, {\n                origin: 'on_finish',\n                config,\n                dependencyGraph,\n                prInfo,\n                resultsMap: results,\n                sessionInfo: undefined,\n                debug,\n                eventOverride: onFinish.goto_event,\n                overlay: new Map(results),\n              });\n            if (mode === 'map' && forEachItems.length > 0) {\n              for (let i = 0; i < forEachItems.length; i++) {\n                const itemScope: ScopePath = [{ check: checkName, index: i }];\n                await scheduleOnce(itemScope);\n              }\n            } else {\n              await scheduleOnce([]);\n            }\n\n            logger.info(`  ✓ Routed to: ${gotoTarget}`);\n            logger.info(`  Event override: ${onFinish.goto_event || '(none)'}`);\n          } catch (error) {\n            const errorMsg = error instanceof Error ? error.message : String(error);\n            logger.error(\n              `✗ on_finish: routing failed for \"${checkName}\" → \"${gotoTarget}\": ${errorMsg}`\n            );\n            if (error instanceof Error && error.stack) {\n              logger.debug(`Stack trace: ${error.stack}`);\n            }\n            throw error;\n          }\n        }\n\n        logger.info(`✓ on_finish: completed for \"${checkName}\"`);\n      } catch (error) {\n        logger.error(`✗ on_finish: error for \"${checkName}\": ${error}`);\n      }\n    }\n  }\n\n  /**\n   * Execute a check with retry/backoff and routing semantics (on_fail/on_success)\n   */\n  private async executeWithRouting(\n    checkName: string,\n    checkConfig: CheckConfig,\n    provider: import('./providers/check-provider.interface').CheckProvider,\n    providerConfig: CheckProviderConfig,\n    prInfo: PRInfo,\n    dependencyResults: Map<string, ReviewSummary>,\n    sessionInfo: { parentSessionId?: string; reuseSession?: boolean } | undefined,\n    config: VisorConfig | undefined,\n    dependencyGraph: DependencyGraph,\n    debug?: boolean,\n    resultsMap?: Map<string, ReviewSummary>,\n    foreachContext?: { index: number; total: number; parent: string }\n  ): Promise<ReviewSummary> {\n    const log = (msg: string) =>\n      (this.config?.output?.pr_comment ? console.error : console.log)(msg);\n    const maxLoops = config?.routing?.max_loops ?? 10;\n    const defaults = config?.routing?.defaults?.on_fail || {};\n\n    const onFail: OnFailConfig | undefined = checkConfig.on_fail\n      ? { ...defaults, ...checkConfig.on_fail }\n      : Object.keys(defaults).length\n        ? defaults\n        : undefined;\n    const onSuccess: OnSuccessConfig | undefined = checkConfig.on_success;\n\n    let attempt = 1;\n    let loopCount = 0;\n    const seed = `${checkName}-${prInfo.number || 'local'}`;\n\n    const allAncestors = DependencyResolver.getAllDependencies(checkName, dependencyGraph.nodes);\n    // Expose current check's structured output to routing JS (run_js/goto_js)\n    // so templates can reference `output` similarly to `outputs` (deps).\n    let currentRouteOutput: unknown = undefined;\n\n    const evalRunJs = async (expr?: string, error?: unknown): Promise<string[]> => {\n      if (!expr) return [];\n      try {\n        const sandbox = this.getRoutingSandbox();\n        const eventObj = { name: prInfo.eventType || 'manual' } as const;\n        const outHist: Record<string, unknown[]> = {};\n        try {\n          for (const [k, v] of this.outputHistory.entries()) outHist[k] = v;\n        } catch {}\n        // Build outputs_raw object from dependencyResults (-raw aliases)\n        const outRaw: Record<string, unknown> = {};\n        try {\n          for (const [k, v] of (dependencyResults || new Map()).entries()) {\n            if (typeof k !== 'string') continue;\n            if (k.endsWith('-raw')) {\n              const name = k.slice(0, -4);\n              const val: any = (v as any)?.output !== undefined ? (v as any).output : v;\n              outRaw[name] = val;\n            }\n          }\n        } catch {}\n        const scope = {\n          step: { id: checkName, tags: checkConfig.tags || [], group: checkConfig.group },\n          attempt,\n          loop: loopCount,\n          error,\n          foreach: foreachContext\n            ? {\n                index: foreachContext.index,\n                total: foreachContext.total,\n                parent: foreachContext.parent,\n              }\n            : null,\n          outputs: Object.fromEntries((dependencyResults || new Map()).entries()),\n          outputs_history: outHist,\n          outputs_raw: outRaw,\n          output: currentRouteOutput,\n          pr: {\n            number: prInfo.number,\n            title: prInfo.title,\n            author: prInfo.author,\n            branch: prInfo.head,\n            base: prInfo.base,\n          },\n          files: prInfo.files,\n          env: getSafeEnvironmentVariables(),\n          permissions: createPermissionHelpers(\n            resolveAssociationFromEvent((prInfo as any).eventContext, prInfo.authorAssociation),\n            detectLocalMode()\n          ),\n          event: eventObj,\n        };\n        const prelude = `const step = scope.step; const attempt = scope.attempt; const loop = scope.loop; const error = scope.error; const foreach = scope.foreach; const outputs = scope.outputs; const outputs_history = scope.outputs_history; const outputs_raw = scope.outputs_raw; const output = scope.output; const pr = scope.pr; const files = scope.files; const env = scope.env; const event = scope.event; const hasMinPermission = scope.permissions.hasMinPermission; const isOwner = scope.permissions.isOwner; const isMember = scope.permissions.isMember; const isCollaborator = scope.permissions.isCollaborator; const isContributor = scope.permissions.isContributor; const isFirstTimer = scope.permissions.isFirstTimer;`;\n        const code = `${prelude}\\n${expr}`;\n        const result = compileAndRun<unknown>(\n          sandbox,\n          code,\n          { scope },\n          { injectLog: false, wrapFunction: true }\n        );\n        const res = Array.isArray(result) ? result : result ? [result] : [];\n        if (debug) {\n          log(`🔧 Debug: run_js evaluated → [${this.redact(res)}]`);\n        }\n        return Array.isArray(res) ? res.filter(x => typeof x === 'string') : [];\n      } catch (e) {\n        if (debug) {\n          log(`⚠️ Debug: run_js evaluation failed: ${e instanceof Error ? e.message : String(e)}`);\n        }\n        return [];\n      }\n    };\n\n    const evalGotoJs = async (expr?: string, error?: unknown): Promise<string | null> => {\n      if (!expr) return null;\n      try {\n        const sandbox = this.getRoutingSandbox();\n        const eventObj = { name: prInfo.eventType || 'manual' } as const;\n        const outHist: Record<string, unknown[]> = {};\n        try {\n          for (const [k, v] of this.outputHistory.entries()) outHist[k] = v;\n        } catch {}\n        // Build outputs_raw object from dependencyResults (-raw aliases)\n        const outRaw: Record<string, unknown> = {};\n        try {\n          for (const [k, v] of (dependencyResults || new Map()).entries()) {\n            if (typeof k !== 'string') continue;\n            if (k.endsWith('-raw')) {\n              const name = k.slice(0, -4);\n              const val: any = (v as any)?.output !== undefined ? (v as any).output : v;\n              outRaw[name] = val;\n            }\n          }\n        } catch {}\n        const scope = {\n          step: { id: checkName, tags: checkConfig.tags || [], group: checkConfig.group },\n          attempt,\n          loop: loopCount,\n          error,\n          foreach: foreachContext\n            ? {\n                index: foreachContext.index,\n                total: foreachContext.total,\n                parent: foreachContext.parent,\n              }\n            : null,\n          outputs: Object.fromEntries((dependencyResults || new Map()).entries()),\n          outputs_history: outHist,\n          outputs_raw: outRaw,\n          output: currentRouteOutput,\n          pr: {\n            number: prInfo.number,\n            title: prInfo.title,\n            author: prInfo.author,\n            branch: prInfo.head,\n            base: prInfo.base,\n          },\n          files: prInfo.files,\n          env: getSafeEnvironmentVariables(),\n          permissions: createPermissionHelpers(\n            resolveAssociationFromEvent((prInfo as any).eventContext, prInfo.authorAssociation),\n            detectLocalMode()\n          ),\n          event: eventObj,\n        };\n        const prelude2 = `const step = scope.step; const attempt = scope.attempt; const loop = scope.loop; const error = scope.error; const foreach = scope.foreach; const outputs = scope.outputs; const outputs_history = scope.outputs_history; const outputs_raw = scope.outputs_raw; const output = scope.output; const pr = scope.pr; const files = scope.files; const env = scope.env; const event = scope.event; const hasMinPermission = scope.permissions.hasMinPermission; const isOwner = scope.permissions.isOwner; const isMember = scope.permissions.isMember; const isCollaborator = scope.permissions.isCollaborator; const isContributor = scope.permissions.isContributor; const isFirstTimer = scope.permissions.isFirstTimer;`;\n        const code2 = `${prelude2}\\n${expr}`;\n        const res = compileAndRun<string | null>(\n          sandbox,\n          code2,\n          { scope },\n          { injectLog: false, wrapFunction: true }\n        );\n        if (debug) {\n          log(`🔧 Debug: goto_js evaluated → ${this.redact(res)}`);\n        }\n        return typeof res === 'string' && res ? res : null;\n      } catch (e) {\n        if (debug) {\n          log(`⚠️ Debug: goto_js evaluation failed: ${e instanceof Error ? e.message : String(e)}`);\n        }\n        return null;\n      }\n    };\n\n    // Phase 3: unified scheduling helper replaces inline nested executor\n\n    // Begin attempts loop\n    // We treat each retry/goto/run as consuming one loop budget entry\n    while (true) {\n      try {\n        try {\n          emitNdjsonFallback('visor.provider', {\n            'visor.check.id': checkName,\n            'visor.provider.type': providerConfig.type || 'ai',\n          });\n        } catch {}\n        const __provStart = Date.now();\n        const context: import('./providers/check-provider.interface').ExecutionContext = {\n          ...sessionInfo,\n          ...this.executionContext,\n        };\n        const res = await withActiveSpan(\n          `visor.check.${checkName}`,\n          {\n            'visor.check.id': checkName,\n            'visor.check.type': providerConfig.type || 'ai',\n            'visor.check.attempt': attempt,\n          },\n          async () => provider.execute(prInfo, providerConfig, dependencyResults, context)\n        );\n        this.recordProviderDuration(checkName, Date.now() - __provStart);\n        try {\n          currentRouteOutput = (res as any)?.output;\n        } catch {}\n        // Success path\n        // Treat result issues with severity error/critical as a soft-failure eligible for on_fail routing\n        const hasSoftFailure = (res.issues || []).some(\n          i => i.severity === 'error' || i.severity === 'critical'\n        );\n        if (hasSoftFailure && onFail) {\n          if (debug)\n            log(\n              `🔧 Debug: Soft failure detected f|| '${checkName}' with ${(res.issues || []).length} issue(s)`\n            );\n          const lastError: any = {\n            message: 'soft-failure: issues present',\n            code: 'soft_failure',\n            issues: res.issues,\n          };\n          const dynamicRun = await evalRunJs(onFail.run_js, lastError);\n          let runList = [...(onFail.run || []), ...dynamicRun].filter(Boolean);\n          runList = Array.from(new Set(runList));\n          if (debug) log(`🔧 Debug: on_fail.run (soft) list = [${runList.join(', ')}]`);\n          if (runList.length > 0) {\n            try {\n              require('./logger').logger.info(\n                `▶ on_fail.run: scheduling [${runList.join(', ')}] after '${checkName}'`\n              );\n            } catch {}\n            loopCount++;\n            if (loopCount > maxLoops) {\n              throw new Error(\n                `Routing loop budget exceeded (max_loops=${maxLoops}) during on_fail run`\n              );\n            }\n            if (debug) log(`🔧 Debug: on_fail.run (soft) executing [${runList.join(', ')}]`);\n            for (const stepId of runList) {\n              const tcfg = config!.checks?.[stepId] as\n                | import('./types/config').CheckConfig\n                | undefined;\n              const mode =\n                tcfg?.fanout === 'map'\n                  ? 'map'\n                  : tcfg?.reduce\n                    ? 'reduce'\n                    : tcfg?.fanout || 'default';\n              const inItem = !!foreachContext;\n              const items =\n                checkConfig.forEach && Array.isArray(currentRouteOutput)\n                  ? (currentRouteOutput as unknown[])\n                  : [];\n              if (!inItem && mode === 'map' && items.length > 0) {\n                for (let i = 0; i < items.length; i++) {\n                  const itemScope: ScopePath = [{ check: checkName, index: i }];\n                  await this.runNamedCheck(stepId, itemScope, {\n                    config: config!,\n                    dependencyGraph,\n                    prInfo,\n                    resultsMap: resultsMap || new Map(),\n                    debug: !!debug,\n                    overlay: dependencyResults,\n                  });\n                }\n              } else {\n                const scopeForRun: ScopePath = foreachContext\n                  ? [{ check: foreachContext.parent, index: foreachContext.index }]\n                  : [];\n                await this.runNamedCheck(stepId, scopeForRun, {\n                  config: config!,\n                  dependencyGraph,\n                  prInfo,\n                  resultsMap: resultsMap || new Map(),\n                  debug: !!debug,\n                  overlay: dependencyResults,\n                });\n              }\n            }\n          }\n          let target = await evalGotoJs(onFail.goto_js, lastError);\n          if (!target && onFail.goto) target = onFail.goto;\n          if (debug) log(`🔧 Debug: on_fail.goto (soft) target = ${target}`);\n          if (target) {\n            try {\n              require('./logger').logger.info(\n                `↪ on_fail.goto: jumping to '${target}' from '${checkName}'`\n              );\n            } catch {}\n            if (!allAncestors.includes(target)) {\n              if (debug)\n                log(\n                  `⚠️ Debug: on_fail.goto (soft) '${target}' is not an ancestor of '${checkName}' — skipping`\n                );\n            } else {\n              loopCount++;\n              if (loopCount > maxLoops) {\n                throw new Error(\n                  `Routing loop budget exceeded (max_loops=${maxLoops}) during on_fail goto`\n                );\n              }\n              {\n                const tcfg = config!.checks?.[target] as\n                  | import('./types/config').CheckConfig\n                  | undefined;\n                const mode =\n                  tcfg?.fanout === 'map'\n                    ? 'map'\n                    : tcfg?.reduce\n                      ? 'reduce'\n                      : tcfg?.fanout || 'default';\n                const inItem = !!foreachContext;\n                const items =\n                  checkConfig.forEach && Array.isArray(currentRouteOutput)\n                    ? (currentRouteOutput as unknown[])\n                    : [];\n                const scheduleOnce = async (scopeForRun: ScopePath) =>\n                  this.runNamedCheck(target, scopeForRun, {\n                    config: config!,\n                    dependencyGraph,\n                    prInfo,\n                    resultsMap: resultsMap || new Map(),\n                    debug: !!debug,\n                    eventOverride: onFail.goto_event,\n                  });\n                if (!inItem && mode === 'map' && items.length > 0) {\n                  for (let i = 0; i < items.length; i++) {\n                    const itemScope: ScopePath = [{ check: checkName, index: i }];\n                    await scheduleOnce(itemScope);\n                  }\n                } else {\n                  const scopeForRun: ScopePath = foreachContext\n                    ? [{ check: foreachContext.parent, index: foreachContext.index }]\n                    : [];\n                  await scheduleOnce(scopeForRun);\n                }\n              }\n            }\n          }\n\n          const retryMax = onFail.retry?.max ?? 0;\n          const base = onFail.retry?.backoff?.delay_ms ?? 0;\n          const mode = onFail.retry?.backoff?.mode ?? 'fixed';\n          if (attempt <= retryMax) {\n            loopCount++;\n            if (loopCount > maxLoops) {\n              throw new Error(`Routing loop budget exceeded (max_loops=${maxLoops}) during retry`);\n            }\n            const delay = base > 0 ? this.computeBackoffDelay(attempt, mode, base, seed) : 0;\n            if (debug)\n              log(\n                `🔁 Debug: retrying '${checkName}' (soft) attempt ${attempt + 1}/${retryMax + 1} after ${delay}ms`\n              );\n            if (delay > 0) await this.sleep(delay);\n            attempt++;\n            continue; // loop\n          }\n          // No retry configured: return existing result\n          return res;\n        }\n        // Note: previously we re-ran the source check after goto to \"re-validate with new state\".\n        // This caused success→goto→re-run loops for unconditional gotos. We no longer re-run the\n        // source after goto; goto only schedules the target and returns.\n        if (onSuccess) {\n          // Compute run list\n          const dynamicRun = await evalRunJs(onSuccess.run_js);\n          const runList = [...(onSuccess.run || []), ...dynamicRun].filter(Boolean);\n          if (runList.length > 0) {\n            try {\n              require('./logger').logger.info(\n                `▶ on_success.run: scheduling [${Array.from(new Set(runList)).join(', ')}] after '${checkName}'`\n              );\n            } catch {}\n            loopCount++;\n            if (loopCount > maxLoops) {\n              throw new Error(\n                `Routing loop budget exceeded (max_loops=${maxLoops}) during on_success run`\n              );\n            }\n            for (const stepId of Array.from(new Set(runList))) {\n              const tcfg = config!.checks?.[stepId] as\n                | import('./types/config').CheckConfig\n                | undefined;\n              const mode =\n                tcfg?.fanout === 'map'\n                  ? 'map'\n                  : tcfg?.reduce\n                    ? 'reduce'\n                    : tcfg?.fanout || 'default';\n              const inItem = !!foreachContext;\n              const items =\n                checkConfig.forEach && Array.isArray(currentRouteOutput)\n                  ? (currentRouteOutput as unknown[])\n                  : [];\n              if (!inItem && mode === 'map' && items.length > 0) {\n                for (let i = 0; i < items.length; i++) {\n                  const itemScope: ScopePath = [{ check: checkName, index: i }];\n                  await this.runNamedCheck(stepId, itemScope, {\n                    config: config!,\n                    dependencyGraph,\n                    prInfo,\n                    resultsMap: resultsMap || new Map(),\n                    debug: !!debug,\n                    overlay: dependencyResults,\n                  });\n                }\n              } else {\n                const scopeForRun: ScopePath = foreachContext\n                  ? [{ check: foreachContext.parent, index: foreachContext.index }]\n                  : [];\n                await this.runNamedCheck(stepId, scopeForRun, {\n                  config: config!,\n                  dependencyGraph,\n                  prInfo,\n                  resultsMap: resultsMap || new Map(),\n                  debug: !!debug,\n                  overlay: dependencyResults,\n                });\n              }\n            }\n          } else {\n            // Provide a lightweight reason when nothing is scheduled via on_success.run\n            try {\n              const assoc = resolveAssociationFromEvent(\n                (prInfo as any)?.eventContext,\n                prInfo.authorAssociation\n              );\n              const perms = createPermissionHelpers(assoc, detectLocalMode());\n              const allowedMember = perms.hasMinPermission('MEMBER');\n              let intent: string | undefined;\n              try {\n                intent = (res as any)?.output?.intent;\n              } catch {}\n              require('./logger').logger.info(\n                `⏭ on_success.run: none after '${checkName}' (event=${prInfo.eventType || 'manual'}, intent=${intent || 'n/a'}, assoc=${assoc || 'unknown'}, memberOrHigher=${allowedMember})`\n              );\n            } catch {}\n          }\n          // Optional goto\n          let target = await evalGotoJs(onSuccess.goto_js);\n          if (!target && onSuccess.goto) target = onSuccess.goto;\n          if (target) {\n            try {\n              require('./logger').logger.info(\n                `↪ on_success.goto: jumping to '${target}' from '${checkName}'`\n              );\n            } catch {}\n            if (!allAncestors.includes(target)) {\n              // Forward-run from target under goto_event: execute target and all dependents matching event\n              const prevEventOverride2 = this.routingEventOverride;\n              if (onSuccess.goto_event) {\n                this.routingEventOverride = onSuccess.goto_event;\n              }\n              try {\n                // Build forward closure (target + transitive dependents)\n                const cfgChecks = (config?.checks || {}) as Record<\n                  string,\n                  import('./types/config').CheckConfig\n                >;\n                const forwardSet = new Set<string>();\n                if (cfgChecks[target]) forwardSet.add(target);\n                const dependsOn = (name: string, root: string): boolean => {\n                  const seen = new Set<string>();\n                  const dfs = (n: string): boolean => {\n                    if (seen.has(n)) return false;\n                    seen.add(n);\n                    const deps = cfgChecks[n]?.depends_on || [];\n                    if (deps.includes(root)) return true;\n                    return deps.some(d => dfs(d));\n                  };\n                  return dfs(name);\n                };\n                const ev = onSuccess.goto_event || prInfo.eventType || 'issue_comment';\n                for (const name of Object.keys(cfgChecks)) {\n                  if (name === target) continue;\n                  const onArr = cfgChecks[name]?.on as any;\n                  const eventMatches = !onArr || (Array.isArray(onArr) && onArr.includes(ev));\n                  if (!eventMatches) continue;\n                  if (dependsOn(name, target)) forwardSet.add(name);\n                }\n                // Topologically order forwardSet based on depends_on within this subset\n                const order: string[] = [];\n                const inSet = (n: string) => forwardSet.has(n);\n                const tempMarks = new Set<string>();\n                const permMarks = new Set<string>();\n                const stack: string[] = [];\n                const visit = (n: string) => {\n                  if (permMarks.has(n)) return;\n                  if (tempMarks.has(n)) {\n                    // Cycle detected — build a readable cycle path\n                    const idx = stack.indexOf(n);\n                    const cyclePath = idx >= 0 ? [...stack.slice(idx), n] : [n];\n                    throw new Error(\n                      `Cycle detected in forward-run dependency subset: ${cyclePath.join(' -> ')}`\n                    );\n                  }\n                  tempMarks.add(n);\n                  stack.push(n);\n                  const deps = (cfgChecks[n]?.depends_on || []).filter(inSet);\n                  for (const d of deps) visit(d);\n                  stack.pop();\n                  tempMarks.delete(n);\n                  permMarks.add(n);\n                  order.push(n);\n                };\n                for (const n of forwardSet) visit(n);\n                // Execute in order with event override, updating statistics per child\n                const tcfg = cfgChecks[target];\n                const mode =\n                  tcfg?.fanout === 'map'\n                    ? 'map'\n                    : tcfg?.reduce\n                      ? 'reduce'\n                      : tcfg?.fanout || 'default';\n                const items =\n                  checkConfig.forEach && Array.isArray(currentRouteOutput)\n                    ? (currentRouteOutput as unknown[])\n                    : [];\n                const runChainOnce = async (scopeForRun: ScopePath) => {\n                  for (const stepId of order) {\n                    if (!this.executionStats.has(stepId)) this.initializeCheckStats(stepId);\n                    const childStart = this.recordIterationStart(stepId);\n                    const childRes = await this.runNamedCheck(stepId, scopeForRun, {\n                      config: config!,\n                      dependencyGraph,\n                      prInfo,\n                      resultsMap: resultsMap || new Map(),\n                      debug: !!debug,\n                      eventOverride: onSuccess.goto_event,\n                    });\n                    const childIssues = (childRes.issues || []).map(i => ({ ...i }));\n                    const childSuccess = !this.hasFatal(childIssues);\n                    const childOutput: unknown = (childRes as any)?.output;\n                    this.recordIterationComplete(\n                      stepId,\n                      childStart,\n                      childSuccess,\n                      childIssues,\n                      childOutput\n                    );\n                  }\n                };\n                if (!foreachContext && mode === 'map' && items.length > 0) {\n                  for (let i = 0; i < items.length; i++) {\n                    const itemScope: ScopePath = [{ check: checkName, index: i }];\n                    await runChainOnce(itemScope);\n                  }\n                } else {\n                  const scopeForRun: ScopePath = foreachContext\n                    ? [{ check: foreachContext.parent, index: foreachContext.index }]\n                    : [];\n                  await runChainOnce(scopeForRun);\n                }\n                // Do NOT append forward-run child issues to the current check result.\n                // Child results are recorded independently in resultsMap and statistics,\n                // and aggregators will include them without double-counting under the parent.\n              } finally {\n                this.routingEventOverride = prevEventOverride2;\n              }\n            } else {\n              loopCount++;\n              if (loopCount > maxLoops) {\n                throw new Error(\n                  `Routing loop budget exceeded (max_loops=${maxLoops}) during on_success goto`\n                );\n              }\n              {\n                const tcfg = config!.checks?.[target] as\n                  | import('./types/config').CheckConfig\n                  | undefined;\n                const mode =\n                  tcfg?.fanout === 'map'\n                    ? 'map'\n                    : tcfg?.reduce\n                      ? 'reduce'\n                      : tcfg?.fanout || 'default';\n                const items =\n                  checkConfig.forEach && Array.isArray(currentRouteOutput)\n                    ? (currentRouteOutput as unknown[])\n                    : [];\n                const scheduleOnce = async (scopeForRun: ScopePath) =>\n                  this.runNamedCheck(target, scopeForRun, {\n                    config: config!,\n                    dependencyGraph,\n                    prInfo,\n                    resultsMap: resultsMap || new Map(),\n                    debug: !!debug,\n                    eventOverride: onSuccess.goto_event,\n                    overlay: dependencyResults,\n                  });\n                if (!foreachContext && mode === 'map' && items.length > 0) {\n                  for (let i = 0; i < items.length; i++) {\n                    const itemScope: ScopePath = [{ check: checkName, index: i }];\n                    await scheduleOnce(itemScope);\n                  }\n                } else {\n                  const scopeForRun: ScopePath = foreachContext\n                    ? [{ check: foreachContext.parent, index: foreachContext.index }]\n                    : [];\n                  await scheduleOnce(scopeForRun);\n                }\n              }\n              // Do not re-run the current check after goto; target (and its dependents) will run.\n            }\n          }\n        }\n        // No re-run after goto\n        return res;\n      } catch (err) {\n        // Failure path\n        if (!onFail) {\n          throw err; // no routing policy\n        }\n\n        const lastError = err instanceof Error ? err : new Error(String(err));\n\n        // Dynamic compute run/goto\n        const dynamicRun = await evalRunJs(onFail.run_js, lastError);\n        let runList = [...(onFail.run || []), ...dynamicRun].filter(Boolean);\n        // Dedup while preserving order\n        runList = Array.from(new Set(runList));\n\n        if (runList.length > 0) {\n          try {\n            require('./logger').logger.info(\n              `▶ on_fail.run: scheduling [${runList.join(', ')}] after '${checkName}'`\n            );\n          } catch {}\n          loopCount++;\n          if (loopCount > maxLoops) {\n            throw new Error(\n              `Routing loop budget exceeded (max_loops=${maxLoops}) during on_fail run`\n            );\n          }\n          if (debug) log(`🔧 Debug: on_fail.run executing [${runList.join(', ')}]`);\n          for (const stepId of runList) {\n            await this.runNamedCheck(stepId, [], {\n              config: config!,\n              dependencyGraph,\n              prInfo,\n              resultsMap: resultsMap || new Map(),\n              debug: !!debug,\n            });\n          }\n        }\n\n        let target = await evalGotoJs(onFail.goto_js, lastError);\n        if (!target && onFail.goto) target = onFail.goto;\n        if (target) {\n          try {\n            require('./logger').logger.info(\n              `↪ on_fail.goto: jumping to '${target}' from '${checkName}'`\n            );\n          } catch {}\n          if (!allAncestors.includes(target)) {\n            if (debug)\n              log(\n                `⚠️ Debug: on_fail.goto '${target}' is not an ancestor of '${checkName}' — skipping`\n              );\n          } else {\n            loopCount++;\n            if (loopCount > maxLoops) {\n              throw new Error(\n                `Routing loop budget exceeded (max_loops=${maxLoops}) during on_fail goto`\n              );\n            }\n            await this.runNamedCheck(target, [], {\n              config: config!,\n              dependencyGraph,\n              prInfo,\n              resultsMap: resultsMap || new Map(),\n              debug: !!debug,\n              eventOverride: onFail.goto_event,\n              overlay: dependencyResults,\n            });\n          }\n        }\n\n        // Retry if allowed\n        const retryMax = onFail.retry?.max ?? 0;\n        const base = onFail.retry?.backoff?.delay_ms ?? 0;\n        const mode = onFail.retry?.backoff?.mode ?? 'fixed';\n        if (attempt <= retryMax) {\n          loopCount++;\n          if (loopCount > maxLoops) {\n            throw new Error(`Routing loop budget exceeded (max_loops=${maxLoops}) during retry`);\n          }\n          const delay = base > 0 ? this.computeBackoffDelay(attempt, mode, base, seed) : 0;\n          if (debug)\n            log(\n              `🔁 Debug: retrying '${checkName}' attempt ${attempt + 1}/${retryMax + 1} after ${delay}ms`\n            );\n          if (delay > 0) await this.sleep(delay);\n          attempt++;\n          continue; // loop\n        }\n\n        // Exhausted retry budget; rethrow\n        throw lastError;\n      }\n    }\n  }\n\n  /**\n   * Set webhook context on a provider if it supports it\n   */\n  private setProviderWebhookContext(\n    provider: import('./providers/check-provider.interface').CheckProvider\n  ): void {\n    if (this.webhookContext && provider.setWebhookContext) {\n      provider.setWebhookContext(this.webhookContext.webhookData);\n    }\n  }\n\n  /**\n   * Filter checks based on tag filter configuration\n   */\n  private filterChecksByTags(\n    checks: string[],\n    config: import('./types/config').VisorConfig | undefined,\n    tagFilter: import('./types/config').TagFilter | undefined\n  ): string[] {\n    const logFn = this.config?.output?.pr_comment ? console.error : console.log;\n\n    return checks.filter(checkName => {\n      const checkConfig = config?.checks?.[checkName];\n      if (!checkConfig) {\n        // If no config for this check, include it by default\n        return true;\n      }\n\n      const checkTags = checkConfig.tags || [];\n\n      // If check has tags but no tag filter is specified, exclude it\n      if (checkTags.length > 0 && (!tagFilter || (!tagFilter.include && !tagFilter.exclude))) {\n        logFn(`⏭️ Skipping check '${checkName}' - check has tags but no tag filter specified`);\n        return false;\n      }\n\n      // If no tag filter is specified and check has no tags, include it\n      if (!tagFilter || (!tagFilter.include && !tagFilter.exclude)) {\n        return true;\n      }\n\n      // If check has no tags and a tag filter is specified, include it (untagged checks always run)\n      if (checkTags.length === 0) {\n        return true;\n      }\n\n      // Check exclude tags first (if any exclude tag matches, skip the check)\n      if (tagFilter.exclude && tagFilter.exclude.length > 0) {\n        const hasExcludedTag = tagFilter.exclude.some(tag => checkTags.includes(tag));\n        if (hasExcludedTag) {\n          logFn(`⏭️ Skipping check '${checkName}' - has excluded tag`);\n          return false;\n        }\n      }\n\n      // Check include tags (if specified, at least one must match)\n      if (tagFilter.include && tagFilter.include.length > 0) {\n        const hasIncludedTag = tagFilter.include.some(tag => checkTags.includes(tag));\n        if (!hasIncludedTag) {\n          logFn(`⏭️ Skipping check '${checkName}' - does not have required tags`);\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n\n  /**\n   * Execute checks on the local repository\n   */\n  async executeChecks(options: CheckExecutionOptions): Promise<AnalysisResult> {\n    const startTime = Date.now();\n    const timestamp = new Date().toISOString();\n\n    try {\n      // Initialize memory store if configured\n      if (options.config?.memory) {\n        const memoryStore = MemoryStore.getInstance(options.config.memory);\n        await memoryStore.initialize();\n        logger.debug('Memory store initialized');\n      }\n\n      // Reset per-run on_finish loop counters\n      this.onFinishLoopCounts.clear();\n      // Reset per-run forEach wave counters\n      this.forEachWaveCounts.clear();\n      // Store webhook context if provided\n      this.webhookContext = options.webhookContext;\n\n      // Determine where to send log messages based on output format\n      const logFn = (msg: string) => logger.info(msg);\n\n      // Initialize GitHub checks if enabled\n      if (options.githubChecks?.enabled && options.githubChecks.octokit) {\n        await this.initializeGitHubChecks(options, logFn);\n      }\n\n      // Analyze the repository\n      logFn('🔍 Analyzing local git repository...');\n      const repositoryInfo = await this.gitAnalyzer.analyzeRepository();\n\n      if (!repositoryInfo.isGitRepository) {\n        // Complete GitHub checks with error if they were initialized\n        if (this.checkRunMap) {\n          await this.completeGitHubChecksWithError('Not a git repository or no changes found');\n        }\n\n        return this.createErrorResult(\n          repositoryInfo,\n          'Not a git repository or no changes found',\n          startTime,\n          timestamp,\n          options.checks\n        );\n      }\n\n      // Convert to PRInfo format for compatibility with existing reviewer\n      const prInfo = this.gitAnalyzer.toPRInfo(repositoryInfo);\n\n      // Apply tag filtering if specified\n      const filteredChecks = this.filterChecksByTags(\n        options.checks,\n        options.config,\n        options.tagFilter || options.config?.tag_filter\n      );\n\n      if (filteredChecks.length === 0) {\n        logger.warn('⚠️ No checks match the tag filter criteria');\n        // Complete GitHub checks with no checks message if they were initialized\n        if (this.checkRunMap) {\n          await this.completeGitHubChecksWithError('No checks match the tag filter criteria');\n        }\n        return this.createErrorResult(\n          repositoryInfo,\n          'No checks match the tag filter criteria',\n          startTime,\n          timestamp,\n          options.checks\n        );\n      }\n\n      // Update GitHub checks to in-progress status\n      if (this.checkRunMap) {\n        await this.updateGitHubChecksInProgress(options);\n      }\n\n      // Execute checks using the existing PRReviewer\n      logFn(`🤖 Executing checks: ${filteredChecks.join(', ')}`);\n      const reviewSummary = await this.executeReviewChecks(\n        prInfo,\n        filteredChecks,\n        options.timeout,\n        options.config,\n        options.outputFormat,\n        options.debug,\n        options.maxParallelism,\n        options.failFast\n      );\n\n      // Complete GitHub checks with results\n      if (this.checkRunMap) {\n        await this.completeGitHubChecksWithResults(reviewSummary, options, prInfo);\n      }\n\n      const executionTime = Date.now() - startTime;\n\n      // Collect debug information when debug mode is enabled\n      let debugInfo: import('./output-formatters').DebugInfo | undefined;\n      if (options.debug && reviewSummary.debug) {\n        debugInfo = {\n          provider: reviewSummary.debug.provider,\n          model: reviewSummary.debug.model,\n          processingTime: reviewSummary.debug.processingTime,\n          parallelExecution: options.checks.length > 1,\n          checksExecuted: options.checks,\n          totalApiCalls: reviewSummary.debug.totalApiCalls || options.checks.length,\n          apiCallDetails: reviewSummary.debug.apiCallDetails,\n        };\n      }\n\n      // Build execution statistics\n      const executionStatistics = this.buildExecutionStatistics();\n\n      return {\n        repositoryInfo,\n        reviewSummary,\n        executionTime,\n        timestamp,\n        checksExecuted: filteredChecks,\n        executionStatistics,\n        debug: debugInfo,\n      };\n    } catch (error) {\n      logger.error(\n        'Error executing checks: ' + (error instanceof Error ? error.message : String(error))\n      );\n\n      // Complete GitHub checks with error if they were initialized\n      if (this.checkRunMap) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n        await this.completeGitHubChecksWithError(errorMessage);\n      }\n\n      const fallbackRepositoryInfo: GitRepositoryInfo = {\n        title: 'Error during analysis',\n        body: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        author: 'system',\n        base: 'main',\n        head: 'HEAD',\n        files: [],\n        totalAdditions: 0,\n        totalDeletions: 0,\n        isGitRepository: false,\n        workingDirectory: options.workingDirectory || process.cwd(),\n      };\n\n      return this.createErrorResult(\n        fallbackRepositoryInfo,\n        error instanceof Error ? error.message : 'Unknown error occurred',\n        startTime,\n        timestamp,\n        options.checks\n      );\n    }\n  }\n\n  /**\n   * Execute tasks with controlled parallelism using a pool pattern\n   */\n  private async executeWithLimitedParallelism<T>(\n    tasks: (() => Promise<T>)[],\n    maxParallelism: number,\n    failFast?: boolean\n  ): Promise<PromiseSettledResult<T>[]> {\n    if (maxParallelism <= 0) {\n      throw new Error('Max parallelism must be greater than 0');\n    }\n\n    if (tasks.length === 0) {\n      return [];\n    }\n\n    const results: PromiseSettledResult<T>[] = new Array(tasks.length);\n    let currentIndex = 0;\n    let shouldStop = false;\n\n    // Worker function that processes tasks\n    const worker = async (): Promise<void> => {\n      while (currentIndex < tasks.length && !shouldStop) {\n        const taskIndex = currentIndex++;\n        if (taskIndex >= tasks.length) break;\n\n        try {\n          const result = await tasks[taskIndex]();\n          results[taskIndex] = { status: 'fulfilled', value: result };\n\n          // Check if we should stop due to fail-fast\n          if (failFast && this.shouldFailFast(result)) {\n            shouldStop = true;\n            break;\n          }\n        } catch (error) {\n          results[taskIndex] = { status: 'rejected', reason: error };\n\n          // If fail-fast is enabled and we have an error, stop execution\n          if (failFast) {\n            shouldStop = true;\n            break;\n          }\n        }\n      }\n    };\n\n    // Create workers up to the parallelism limit\n    const workers: Promise<void>[] = [];\n    const workerCount = Math.min(maxParallelism, tasks.length);\n\n    for (let i = 0; i < workerCount; i++) {\n      workers.push(worker());\n    }\n\n    // Wait for all workers to complete\n    await Promise.all(workers);\n\n    return results;\n  }\n\n  /**\n   * Execute review checks using parallel execution for multiple AI checks\n   */\n  private async executeReviewChecks(\n    prInfo: PRInfo,\n    checks: string[],\n    timeout?: number,\n    config?: import('./types/config').VisorConfig,\n    outputFormat?: string,\n    debug?: boolean,\n    maxParallelism?: number,\n    failFast?: boolean\n  ): Promise<ReviewSummary> {\n    // Store config for use in filtering\n    this.config = config;\n\n    // Determine where to send log messages based on output format\n    // Use debug logger for internal engine messages; important notices use logger.warn/info directly.\n    const logFn = (msg: string) => logger.debug(msg);\n\n    // Only output debug messages if debug mode is enabled\n    if (debug) {\n      logFn(`🔧 Debug: executeReviewChecks called with checks: ${JSON.stringify(checks)}`);\n      logFn(`🔧 Debug: Config available: ${!!config}, Config has checks: ${!!config?.checks}`);\n    }\n\n    // Filter checks based on current event type to prevent execution of checks that shouldn't run\n    const filteredChecks = this.filterChecksByEvent(checks, config, prInfo, logFn, debug);\n    if (filteredChecks.length !== checks.length && debug) {\n      logFn(\n        `🔧 Debug: Event filtering reduced checks from ${checks.length} to ${filteredChecks.length}: ${JSON.stringify(filteredChecks)}`\n      );\n    }\n\n    // Use filtered checks for execution\n    checks = filteredChecks;\n\n    // If we have a config with individual check definitions, prefer dependency-aware execution\n    // even for a single check, so provider types other than 'ai' work consistently.\n    const allConfigured = config?.checks ? checks.every(name => !!config.checks![name]) : false;\n    if (allConfigured) {\n      if (debug) {\n        logFn(\n          `🔧 Debug: Using dependency-aware execution for ${checks.length} configured check(s)`\n        );\n      }\n      return await this.executeDependencyAwareChecks(\n        prInfo,\n        checks,\n        timeout,\n        config,\n        logFn,\n        debug,\n        maxParallelism,\n        failFast,\n        config?.tag_filter\n      );\n    }\n\n    // Single check execution (existing logic)\n    if (checks.length === 1) {\n      if (debug) {\n        logFn(`🔧 Debug: Using single check execution for: ${checks[0]}`);\n      }\n\n      // If we have a config definition for this check, use it\n      if (config?.checks?.[checks[0]]) {\n        return await this.executeSingleConfiguredCheck(prInfo, checks[0], timeout, config, logFn);\n      }\n\n      // Try provider system for single checks\n      if (this.providerRegistry.hasProvider(checks[0])) {\n        const provider = this.providerRegistry.getProviderOrThrow(checks[0]);\n        this.setProviderWebhookContext(provider);\n        const providerConfig: CheckProviderConfig = {\n          type: checks[0],\n          prompt: 'all',\n          eventContext: this.enrichEventContext(prInfo.eventContext),\n          ai: timeout ? { timeout } : undefined,\n        };\n        const __provStart = Date.now();\n        const result = await provider.execute(prInfo, providerConfig);\n        this.recordProviderDuration(checks[0], Date.now() - __provStart);\n\n        // Prefix issues with check name for consistent grouping\n        const prefixedIssues = (result.issues || []).map(issue => ({\n          ...issue,\n          ruleId: `${checks[0]}/${issue.ruleId}`,\n        }));\n\n        return {\n          ...result,\n          issues: prefixedIssues,\n        };\n      }\n    }\n\n    // Check if 'ai' provider is available for focus-based checks (legacy support)\n    if (this.providerRegistry.hasProvider('ai')) {\n      if (debug) {\n        logFn(`🔧 Debug: Using AI provider with focus mapping`);\n      }\n      const provider = this.providerRegistry.getProviderOrThrow('ai');\n      this.setProviderWebhookContext(provider);\n\n      let focus = 'all';\n      let checkName = 'all';\n      if (checks.length === 1) {\n        checkName = checks[0];\n        if (checks[0] === 'security' || checks[0] === 'performance' || checks[0] === 'style') {\n          focus = checks[0];\n        }\n      } else {\n        // For multiple checks, combine them into 'all' focus\n        focus = 'all';\n      }\n\n      const providerConfig: CheckProviderConfig = {\n        type: 'ai',\n        prompt: focus,\n        focus: focus,\n        eventContext: this.enrichEventContext(prInfo.eventContext),\n        ai: timeout ? { timeout } : undefined,\n        // Inherit global AI provider and model settings if config is available\n        ai_provider: config?.ai_provider,\n        ai_model: config?.ai_model,\n      };\n\n      const __provStart2 = Date.now();\n      const result = await provider.execute(prInfo, providerConfig);\n      this.recordProviderDuration(checkName, Date.now() - __provStart2);\n\n      // Prefix issues with check name for consistent grouping\n      const prefixedIssues = (result.issues || []).map(issue => ({\n        ...issue,\n        ruleId: `${checkName}/${issue.ruleId}`,\n      }));\n\n      return {\n        ...result,\n        issues: prefixedIssues,\n      };\n    }\n\n    // Fallback to existing PRReviewer for backward compatibility\n    if (debug) {\n      logFn(`🔧 Debug: Using legacy PRReviewer fallback`);\n    }\n    const focusMap: Record<string, ReviewOptions['focus']> = {\n      security: 'security',\n      performance: 'performance',\n      style: 'style',\n      all: 'all',\n      architecture: 'all',\n    };\n\n    let focus: ReviewOptions['focus'] = 'all';\n    if (checks.length === 1 && focusMap[checks[0]]) {\n      focus = focusMap[checks[0]];\n    }\n\n    return await this.reviewer.reviewPR('local', 'repository', 0, prInfo, {\n      focus,\n      format: 'table',\n    });\n  }\n\n  /**\n   * Execute review checks and return grouped results with statistics for new architecture\n   */\n  public async executeGroupedChecks(\n    prInfo: PRInfo,\n    checks: string[],\n    timeout?: number,\n    config?: import('./types/config').VisorConfig,\n    outputFormat?: string,\n    debug?: boolean,\n    maxParallelism?: number,\n    failFast?: boolean,\n    tagFilter?: import('./types/config').TagFilter,\n    _pauseGate?: () => Promise<void>\n  ): Promise<ExecutionResult> {\n    // Determine where to send log messages based on output format\n    const logFn =\n      outputFormat === 'json' || outputFormat === 'sarif'\n        ? debug\n          ? console.error\n          : () => {}\n        : console.log;\n\n    // Only output debug messages if debug mode is enabled\n    if (debug) {\n      logger.debug(`🔧 Debug: executeGroupedChecks called with checks: ${JSON.stringify(checks)}`);\n      logger.debug(\n        `🔧 Debug: Config available: ${!!config}, Config has checks: ${!!config?.checks}`\n      );\n    }\n\n    // Filter checks based on current event type to prevent execution of checks that shouldn't run\n    const filteredChecks = this.filterChecksByEvent(checks, config, prInfo, logFn, debug);\n    if (filteredChecks.length !== checks.length && debug) {\n      logger.debug(\n        `🔧 Debug: Event filtering reduced checks from ${checks.length} to ${filteredChecks.length}: ${JSON.stringify(filteredChecks)}`\n      );\n    }\n\n    // Apply tag filtering if specified\n    const tagFilteredChecks = this.filterChecksByTags(\n      filteredChecks,\n      config,\n      tagFilter || config?.tag_filter\n    );\n\n    if (tagFilteredChecks.length !== filteredChecks.length && debug) {\n      logger.debug(\n        `🔧 Debug: Tag filtering reduced checks from ${filteredChecks.length} to ${tagFilteredChecks.length}: ${JSON.stringify(tagFilteredChecks)}`\n      );\n    }\n\n    // Use filtered checks for execution\n    checks = tagFilteredChecks;\n\n    // Capture GitHub Action context (owner/repo/octokit) if available from environment\n    // This is used for context elevation when routing via goto_event\n    // Only initialize if not already set by constructor (which has the authenticated octokit)\n    if (!this.actionContext) {\n      try {\n        const repoEnv = process.env.GITHUB_REPOSITORY || '';\n        const [owner, repo] = repoEnv.split('/') as [string, string];\n        const token = process.env['INPUT_GITHUB-TOKEN'] || process.env['GITHUB_TOKEN'];\n        if (owner && repo) {\n          this.actionContext = { owner, repo };\n          if (token) {\n            const { Octokit } = await import('@octokit/rest');\n            this.actionContext.octokit = new Octokit({ auth: token });\n          }\n        }\n      } catch {\n        // Non-fatal: context elevation will be skipped if not available\n      }\n    }\n\n    // Check if we have any checks left after filtering\n    if (checks.length === 0) {\n      logger.warn('⚠️ No checks remain after tag filtering');\n      return {\n        results: {},\n        statistics: this.buildExecutionStatistics(),\n      };\n    }\n\n    if (!config?.checks) {\n      throw new Error('Config with check definitions required for grouped execution');\n    }\n\n    // If we have a config with individual check definitions, use dependency-aware execution\n    const hasDependencies = checks.some(checkName => {\n      const checkConfig = config.checks![checkName];\n      return checkConfig?.depends_on && checkConfig.depends_on.length > 0;\n    });\n    const hasRouting = checks.some(checkName => {\n      const c = config.checks![checkName];\n      return Boolean(c?.on_success || c?.on_fail);\n    });\n\n    if (checks.length > 1 || hasDependencies || hasRouting) {\n      if (debug) {\n        logger.debug(\n          `🔧 Debug: Using grouped dependency-aware execution for ${checks.length} checks (has dependencies: ${hasDependencies}, has routing: ${hasRouting})`\n        );\n      }\n      return await this.executeGroupedDependencyAwareChecks(\n        prInfo,\n        checks,\n        timeout,\n        config,\n        logFn,\n        debug,\n        maxParallelism,\n        failFast,\n        tagFilter\n      );\n    }\n\n    // Single check execution\n    if (checks.length === 1) {\n      if (debug) {\n        logger.debug(`🔧 Debug: Using grouped single check execution for: ${checks[0]}`);\n      }\n      const checkResult = await this.executeSingleGroupedCheck(\n        prInfo,\n        checks[0],\n        timeout,\n        config,\n        logFn,\n        debug\n      );\n\n      const groupedResults: GroupedCheckResults = {};\n      groupedResults[checkResult.group] = [checkResult];\n      return {\n        results: groupedResults,\n        statistics: this.buildExecutionStatistics(),\n      };\n    }\n\n    // No checks to execute\n    return {\n      results: {},\n      statistics: this.buildExecutionStatistics(),\n    };\n  }\n\n  /**\n   * Execute single check and return grouped result\n   */\n  private async executeSingleGroupedCheck(\n    prInfo: PRInfo,\n    checkName: string,\n    timeout?: number,\n    config?: import('./types/config').VisorConfig,\n    logFn?: (message: string) => void,\n    debug?: boolean\n  ): Promise<CheckResult> {\n    if (!config?.checks?.[checkName]) {\n      throw new Error(`No configuration found for check: ${checkName}`);\n    }\n\n    const checkConfig = config.checks![checkName];\n    const providerType = checkConfig.type || 'ai';\n    const provider = this.providerRegistry.getProviderOrThrow(providerType);\n    this.setProviderWebhookContext(provider);\n\n    const providerConfig: CheckProviderConfig = {\n      type: providerType,\n      prompt: checkConfig.prompt,\n      focus: checkConfig.focus || this.mapCheckNameToFocus(checkName),\n      schema: checkConfig.schema,\n      group: checkConfig.group,\n      eventContext: this.enrichEventContext(prInfo.eventContext),\n      ai: {\n        timeout: timeout || 600000,\n        debug: debug,\n        ...(checkConfig.ai || {}),\n      },\n      ai_provider: checkConfig.ai_provider || config.ai_provider,\n      ai_model: checkConfig.ai_model || config.ai_model,\n      // Pass claude_code config if present\n      claude_code: checkConfig.claude_code,\n      // Pass output history for loop/goto scenarios\n      __outputHistory: this.outputHistory,\n      // Pass any provider-specific config\n      ...checkConfig,\n    };\n    providerConfig.forEach = checkConfig.forEach;\n\n    const __provStart = Date.now();\n    const result = await provider.execute(prInfo, providerConfig);\n    this.recordProviderDuration(checkName, Date.now() - __provStart);\n\n    // Validate forEach output (skip if there are already errors from transform_js or other sources)\n    if (checkConfig.forEach && (!result.issues || result.issues.length === 0)) {\n      const reviewSummaryWithOutput = result as ReviewSummary & { output?: unknown };\n      const validation = this.validateAndNormalizeForEachOutput(\n        checkName,\n        reviewSummaryWithOutput.output,\n        checkConfig.group\n      );\n\n      if (!validation.isValid) {\n        return validation.error;\n      }\n    }\n\n    // Evaluate fail_if conditions\n    if (config && (config.fail_if || checkConfig.fail_if)) {\n      const failureResults = await this.evaluateFailureConditions(\n        checkName,\n        result,\n        config,\n        prInfo\n      );\n\n      // Add failure condition issues to the result\n      if (failureResults.length > 0) {\n        const failureIssues = failureResults\n          .filter(f => f.failed)\n          .map(f => ({\n            file: 'system',\n            line: 0,\n            ruleId: f.conditionName,\n            message: f.message || `Failure condition met: ${f.expression}`,\n            severity: (f.severity || 'error') as 'info' | 'warning' | 'error' | 'critical',\n            category: 'logic' as const,\n          }));\n\n        result.issues = [...(result.issues || []), ...failureIssues];\n      }\n    }\n\n    // Render the check content using the appropriate template\n    const content = await this.renderCheckContent(checkName, result, checkConfig, prInfo);\n\n    // Determine the group: if group_by is 'check', use the check name; otherwise use configured group || 'default'\n    let group = checkConfig.group || 'default';\n    if (config?.output?.pr_comment?.group_by === 'check' && !checkConfig.group) {\n      group = checkName;\n    }\n\n    return {\n      checkName,\n      content,\n      group,\n      output: (result as any).output,\n      debug: result.debug,\n      issues: result.issues, // Include structured issues\n    };\n  }\n\n  /**\n   * Validate and normalize forEach output\n   * Returns normalized array or throws validation error result\n   */\n  private validateAndNormalizeForEachOutput(\n    checkName: string,\n    output: unknown,\n    checkGroup?: string\n  ):\n    | {\n        isValid: true;\n        normalizedOutput: unknown[];\n      }\n    | {\n        isValid: false;\n        error: {\n          checkName: string;\n          content: string;\n          group: string;\n          issues: Array<{\n            file: string;\n            line: number;\n            ruleId: string;\n            message: string;\n            severity: 'error';\n            category: 'logic';\n          }>;\n        };\n      } {\n    if (output === undefined) {\n      logger.error(`✗ forEach check \"${checkName}\" produced undefined output`);\n      return {\n        isValid: false,\n        error: {\n          checkName,\n          content: '',\n          group: checkGroup || 'default',\n          issues: [\n            {\n              file: 'system',\n              line: 0,\n              ruleId: 'forEach/undefined_output',\n              message: `forEach check \"${checkName}\" produced undefined output. Verify your command outputs valid data and your transform_js returns a value.`,\n              severity: 'error',\n              category: 'logic',\n            },\n          ],\n        },\n      };\n    }\n\n    // Normalize output to array\n    let normalizedOutput: unknown[];\n\n    if (Array.isArray(output)) {\n      normalizedOutput = output;\n    } else if (output && typeof output === 'object' && Array.isArray((output as any).items)) {\n      normalizedOutput = (output as any).items as unknown[];\n    } else if (typeof output === 'string') {\n      try {\n        const parsed = JSON.parse(output);\n        normalizedOutput = Array.isArray(parsed) ? parsed : [parsed];\n      } catch {\n        normalizedOutput = [output];\n      }\n    } else if (output === null) {\n      normalizedOutput = [];\n    } else {\n      normalizedOutput = [output];\n    }\n\n    // Log the result (empty arrays are valid, just result in 0 iterations)\n    logger.info(`  Found ${normalizedOutput.length} items for forEach iteration`);\n    return {\n      isValid: true,\n      normalizedOutput,\n    };\n  }\n\n  /**\n   * Execute multiple checks with dependency awareness - return grouped results with statistics\n   */\n  private async executeGroupedDependencyAwareChecks(\n    prInfo: PRInfo,\n    checks: string[],\n    timeout?: number,\n    config?: import('./types/config').VisorConfig,\n    logFn?: (message: string) => void,\n    debug?: boolean,\n    maxParallelism?: number,\n    failFast?: boolean,\n    tagFilter?: import('./types/config').TagFilter\n  ): Promise<ExecutionResult> {\n    // Use the existing dependency-aware execution logic\n    const reviewSummary = await this.executeDependencyAwareChecks(\n      prInfo,\n      checks,\n      timeout,\n      config,\n      logFn,\n      debug,\n      maxParallelism,\n      failFast,\n      tagFilter || config?.tag_filter\n    );\n\n    // Build execution statistics\n    const executionStatistics = this.buildExecutionStatistics();\n\n    // Convert the flat ReviewSummary to grouped CheckResults\n    const groupedResults = await this.convertReviewSummaryToGroupedResults(\n      reviewSummary,\n      checks,\n      config,\n      prInfo\n    );\n\n    return {\n      results: groupedResults,\n      statistics: executionStatistics,\n    };\n  }\n\n  /**\n   * Convert ReviewSummary to GroupedCheckResults\n   */\n  private async convertReviewSummaryToGroupedResults(\n    reviewSummary: ReviewSummary,\n    checks: string[],\n    config?: import('./types/config').VisorConfig,\n    prInfo?: PRInfo\n  ): Promise<GroupedCheckResults> {\n    const groupedResults: GroupedCheckResults = {};\n    const agg = reviewSummary as ReviewSummary & {\n      __contents?: Record<string, string | undefined>;\n      __outputs?: Record<string, unknown>;\n      __executed?: string[];\n    };\n    const contentMap = agg.__contents;\n    const outputMap = agg.__outputs;\n    // Build a unified list of all checks that produced results:\n    //  - originally requested checks\n    //  - any checks that produced content/output during routing (e.g., forward-run after goto)\n    //  - any checks that emitted issues with checkName set\n    const allCheckNames: string[] = [];\n    const seen = new Set<string>();\n    const pushUnique = (n?: string) => {\n      if (!n) return;\n      if (!seen.has(n)) {\n        seen.add(n);\n        allCheckNames.push(n);\n      }\n    };\n    for (const n of checks) pushUnique(n);\n    if (contentMap) for (const n of Object.keys(contentMap)) pushUnique(n);\n    if (outputMap) for (const n of Object.keys(outputMap)) pushUnique(n);\n    for (const issue of reviewSummary.issues || []) pushUnique(issue.checkName);\n    if (Array.isArray(agg.__executed)) for (const n of agg.__executed) pushUnique(n);\n\n    // Process each discovered check individually\n    for (const checkName of allCheckNames) {\n      const checkConfig = config?.checks?.[checkName];\n      if (!checkConfig) continue;\n\n      // Extract issues for this check\n      const checkIssues = (reviewSummary.issues || []).filter(\n        issue => issue.checkName === checkName\n      );\n\n      // Create a mini ReviewSummary for this check\n      const checkSummary: ReviewSummary & { output?: unknown } = {\n        issues: checkIssues,\n        debug: reviewSummary.debug,\n      };\n\n      if (contentMap?.[checkName]) {\n        (checkSummary as any).content = contentMap[checkName];\n      }\n      if (outputMap && Object.prototype.hasOwnProperty.call(outputMap, checkName)) {\n        checkSummary.output = outputMap[checkName];\n      }\n\n      // Render content for this check (never let template errors abort the whole run)\n      let content: string = '';\n      let issuesForCheck = [...checkIssues];\n      try {\n        content = await this.renderCheckContent(checkName, checkSummary, checkConfig, prInfo);\n      } catch (e) {\n        const msg = e instanceof Error ? e.message : String(e);\n        console.error(`❌ Failed to render content for check '${checkName}': ${msg}`);\n        // Add a synthetic issue so it appears in output and GitHub Checks\n        issuesForCheck = [\n          ...issuesForCheck,\n          {\n            file: 'system',\n            line: 0,\n            ruleId: `${checkName}/render-error`,\n            message: `Template rendering failed: ${msg}`,\n            severity: 'error' as const,\n            category: 'logic' as const,\n          },\n        ];\n      }\n\n      // Determine the group: if group_by is 'check', use the check name; otherwise use configured group || 'default'\n      let group = checkConfig.group || 'default';\n      if (config?.output?.pr_comment?.group_by === 'check' && !checkConfig.group) {\n        group = checkName;\n      }\n\n      const checkResult: CheckResult = {\n        checkName,\n        content,\n        group,\n        output: checkSummary.output,\n        debug: reviewSummary.debug,\n        issues: issuesForCheck, // Include structured issues + rendering error if any\n      };\n\n      // Add to appropriate group\n      if (!groupedResults[group]) {\n        groupedResults[group] = [];\n      }\n      groupedResults[group].push(checkResult);\n    }\n\n    return groupedResults;\n  }\n\n  /**\n   * Validates that a file path is safe and within the project directory\n   * Prevents path traversal attacks by:\n   * - Blocking absolute paths\n   * - Blocking paths with \"..\" segments\n   * - Ensuring resolved path is within project directory\n   * - Blocking special characters and null bytes\n   * - Enforcing .liquid file extension\n   */\n  private async validateTemplatePath(templatePath: string): Promise<string> {\n    const path = await import('path');\n\n    // Validate input\n    if (!templatePath || typeof templatePath !== 'string' || templatePath.trim() === '') {\n      throw new Error('Template path must be a non-empty string');\n    }\n\n    // Block null bytes and other dangerous characters\n    if (templatePath.includes('\\0') || templatePath.includes('\\x00')) {\n      throw new Error('Template path contains invalid characters');\n    }\n\n    // Enforce .liquid file extension\n    if (!templatePath.endsWith('.liquid')) {\n      throw new Error('Template file must have .liquid extension');\n    }\n\n    // Block absolute paths\n    if (path.isAbsolute(templatePath)) {\n      throw new Error('Template path must be relative to project directory');\n    }\n\n    // Block paths with \"..\" segments\n    if (templatePath.includes('..')) {\n      throw new Error('Template path cannot contain \"..\" segments');\n    }\n\n    // Block paths starting with ~ (home directory)\n    if (templatePath.startsWith('~')) {\n      throw new Error('Template path cannot reference home directory');\n    }\n\n    // Get the project root directory from git analyzer\n    const repositoryInfo = await this.gitAnalyzer.analyzeRepository();\n    const projectRoot = repositoryInfo.workingDirectory;\n\n    // Validate project root\n    if (!projectRoot || typeof projectRoot !== 'string') {\n      throw new Error('Unable to determine project root directory');\n    }\n\n    // Resolve the template path relative to project root\n    const resolvedPath = path.resolve(projectRoot, templatePath);\n    const resolvedProjectRoot = path.resolve(projectRoot);\n\n    // Validate resolved paths\n    if (\n      !resolvedPath ||\n      !resolvedProjectRoot ||\n      resolvedPath === '' ||\n      resolvedProjectRoot === ''\n    ) {\n      throw new Error(\n        `Unable to resolve template path: projectRoot=\"${projectRoot}\", templatePath=\"${templatePath}\", resolvedPath=\"${resolvedPath}\", resolvedProjectRoot=\"${resolvedProjectRoot}\"`\n      );\n    }\n\n    // Ensure the resolved path is still within the project directory\n    if (\n      !resolvedPath.startsWith(resolvedProjectRoot + path.sep) &&\n      resolvedPath !== resolvedProjectRoot\n    ) {\n      throw new Error('Template path escapes project directory');\n    }\n\n    return resolvedPath;\n  }\n\n  /**\n   * Evaluate `if` condition for a check\n   * @param checkName Name of the check\n   * @param condition The condition string to evaluate\n   * @param prInfo PR information\n   * @param results Current check results\n   * @param debug Whether debug mode is enabled\n   * @returns true if the check should run, false if it should be skipped\n   */\n  private async evaluateCheckCondition(\n    checkName: string,\n    condition: string,\n    prInfo: PRInfo,\n    results: Map<string, ReviewSummary>,\n    debug?: boolean\n  ): Promise<boolean> {\n    // Determine event name for condition context, honoring any routing override\n    const override = this.routingEventOverride;\n    const eventName = override\n      ? override.startsWith('pr_')\n        ? 'pull_request'\n        : override === 'issue_comment'\n          ? 'issue_comment'\n          : override.startsWith('issue_')\n            ? 'issues'\n            : 'manual'\n      : 'issue_comment';\n\n    const commenterAssoc = resolveAssociationFromEvent(\n      (prInfo as any)?.eventContext,\n      prInfo.authorAssociation\n    );\n    const shouldRun = await this.failureEvaluator.evaluateIfCondition(checkName, condition, {\n      branch: prInfo.head,\n      baseBranch: prInfo.base,\n      filesChanged: prInfo.files.map(f => f.filename),\n      event: eventName,\n      environment: getSafeEnvironmentVariables(),\n      previousResults: results,\n      authorAssociation: commenterAssoc,\n    });\n\n    if (!shouldRun && debug) {\n      logger.debug(`🔧 Debug: Skipping check '${checkName}' - if condition evaluated to false`);\n    }\n\n    return shouldRun;\n  }\n\n  /**\n   * Render check content using the appropriate template\n   */\n  private async renderCheckContent(\n    checkName: string,\n    reviewSummary: ReviewSummary,\n    checkConfig: CheckConfig,\n    _prInfo?: PRInfo\n  ): Promise<string> {\n    const directContent = (reviewSummary as ReviewSummary & { content?: string }).content;\n    if (typeof directContent === 'string' && directContent.trim()) {\n      return directContent.trim();\n    }\n\n    // Import the liquid template system\n    const { createExtendedLiquid } = await import('./liquid-extensions');\n    const fs = await import('fs/promises');\n    const path = await import('path');\n\n    const liquid = createExtendedLiquid({\n      trimTagLeft: false,\n      trimTagRight: false,\n      trimOutputLeft: false,\n      trimOutputRight: false,\n      greedy: false,\n    });\n\n    // Determine template to use\n    // If schema is an object (inline JSON schema), use 'plain' rendering\n    // If schema is a file path (legitimate path with / and ends with .json), treat as plain (schema file reference)\n    let schemaName: string;\n    if (typeof checkConfig.schema === 'object') {\n      schemaName = 'plain';\n    } else if (\n      typeof checkConfig.schema === 'string' &&\n      checkConfig.schema.includes('/') &&\n      checkConfig.schema.endsWith('.json') &&\n      !checkConfig.schema.includes('..') // Reject paths containing .. (parent directory)\n    ) {\n      // Schema is a file path reference - use plain rendering\n      // The schema file will be handled by the AI provider when making the request\n      schemaName = 'plain';\n    } else {\n      schemaName = checkConfig.schema || 'plain';\n    }\n\n    let templateContent: string;\n    let enrichAssistantContext = false;\n\n    if (checkConfig.template) {\n      // Custom template\n      if (checkConfig.template.content) {\n        templateContent = checkConfig.template.content;\n      } else if (checkConfig.template.file) {\n        // Validate the template file path to prevent path traversal attacks\n        const validatedPath = await this.validateTemplatePath(checkConfig.template.file);\n        templateContent = await fs.readFile(validatedPath, 'utf-8');\n      } else {\n        throw new Error('Custom template must specify either \"file\" or \"content\"');\n      }\n    } else if (schemaName === 'plain') {\n      // Plain schema - return raw content directly\n      return reviewSummary.issues?.[0]?.message || '';\n    } else {\n      // Use built-in schema template\n      const sanitizedSchema = schemaName.replace(/[^a-zA-Z0-9-]/g, '');\n      if (!sanitizedSchema) {\n        throw new Error('Invalid schema name');\n      }\n      const templatePath = path.join(__dirname, `output/${sanitizedSchema}/template.liquid`);\n      templateContent = await fs.readFile(templatePath, 'utf-8');\n      // Only enrich built-in issue-assistant with event/permission context\n      if (sanitizedSchema === 'issue-assistant') {\n        enrichAssistantContext = true;\n      }\n    }\n\n    // Prepare template data\n    // Filter out system-level issues (fail_if conditions, internal errors) which should not appear in output\n    const filteredIssues = (reviewSummary.issues || []).filter(\n      issue => !(issue.file === 'system' && issue.line === 0)\n    );\n\n    const templateData: Record<string, unknown> = {\n      issues: filteredIssues,\n      checkName: checkName,\n      // Expose structured output for custom schemas/templates (e.g., overview)\n      // This allows templates to render fields like output.text or output.tags\n      output: (reviewSummary as unknown as { output?: unknown }).output,\n    };\n\n    if (enrichAssistantContext) {\n      // Provide minimal event and permission context for the assistant template only\n      let authorAssociation: string | undefined;\n      let eventName = 'manual';\n      let eventAction: string | undefined;\n      try {\n        const anyInfo = _prInfo as unknown as { eventContext?: any; authorAssociation?: string };\n        authorAssociation = resolveAssociationFromEvent(\n          anyInfo?.eventContext,\n          anyInfo?.authorAssociation\n        );\n        eventName = anyInfo?.eventContext?.event_name || (anyInfo as any)?.eventType || 'manual';\n        eventAction = anyInfo?.eventContext?.action;\n      } catch {}\n      templateData.authorAssociation = authorAssociation;\n      templateData.event = { name: eventName, action: eventAction };\n    }\n\n    // Establish permissions context for filters so templates can call permission filters\n    // without passing authorAssociation explicitly.\n    const { withPermissionsContext } = (await import('./liquid-extensions')) as unknown as {\n      withPermissionsContext?: (\n        ctx: { authorAssociation?: string },\n        fn: () => Promise<string>\n      ) => Promise<string>;\n    };\n    // Try to derive author association from PR info (commenter preferred)\n    let authorAssociationForFilters: string | undefined;\n    try {\n      const anyInfo = _prInfo as unknown as { eventContext?: any; authorAssociation?: string };\n      authorAssociationForFilters = resolveAssociationFromEvent(\n        anyInfo?.eventContext,\n        anyInfo?.authorAssociation\n      );\n    } catch {}\n\n    let rendered: string;\n    if (typeof withPermissionsContext === 'function') {\n      rendered = await withPermissionsContext(\n        { authorAssociation: authorAssociationForFilters },\n        async () => await liquid.parseAndRender(templateContent, templateData)\n      );\n      if (rendered === undefined || rendered === null) {\n        // Defensive: some test environments mock the helper without implementation\n        rendered = await liquid.parseAndRender(templateContent, templateData);\n      }\n    } else {\n      rendered = await liquid.parseAndRender(templateContent, templateData);\n    }\n    const finalRendered = rendered.trim();\n    try {\n      const { emitMermaidFromMarkdown } = await import('./utils/mermaid-telemetry');\n      emitMermaidFromMarkdown(checkName, finalRendered, 'content');\n    } catch {}\n    return finalRendered;\n  }\n\n  /**\n   * Attempt to elevate an issue/issue_comment context to full PR context when routing via goto_event.\n   * Returns a new PRInfo with files/diff when possible; otherwise returns null.\n   */\n  private async elevateContextToPullRequest(\n    prInfo: PRInfo,\n    targetEvent: import('./types/config').EventTrigger,\n    log?: (msg: string) => void,\n    debug?: boolean\n  ): Promise<PRInfo | null> {\n    try {\n      // Only elevate for PR-style events\n      if (targetEvent !== 'pr_opened' && targetEvent !== 'pr_updated') return null;\n\n      // Only meaningful to elevate from issue contexts\n      const isIssueContext = (prInfo as PRInfo & { isIssue?: boolean }).isIssue === true;\n      const ctx: any = (prInfo as any).eventContext || {};\n      const isPRThread = Boolean(ctx?.issue?.pull_request);\n      if (!isIssueContext || !isPRThread) return null;\n\n      // Resolve owner/repo from cached action context or environment\n      let owner = this.actionContext?.owner;\n      let repo = this.actionContext?.repo;\n      if (!owner || !repo) {\n        const repoEnv = process.env.GITHUB_REPOSITORY || '';\n        [owner, repo] = repoEnv.split('/') as [string, string];\n      }\n      if (!owner || !repo) return null;\n\n      // Determine PR number from event context or prInfo.number\n      const prNumber = (ctx?.issue?.number as number) || prInfo.number;\n      if (!prNumber) return null;\n\n      // Build Octokit; prefer cached instance\n      let octokit = this.actionContext?.octokit;\n      if (!octokit) {\n        const token = process.env['INPUT_GITHUB-TOKEN'] || process.env['GITHUB_TOKEN'];\n        if (!token) return null;\n        const { Octokit } = await import('@octokit/rest');\n        octokit = new Octokit({ auth: token });\n      }\n\n      // Fetch full PR diff\n      const analyzer = new PRAnalyzer(octokit);\n      const elevated = await analyzer.fetchPRDiff(owner, repo, prNumber, undefined, targetEvent);\n      // Preserve event context and helpful flags\n      (elevated as any).eventContext = (prInfo as any).eventContext || ctx;\n      (elevated as any).isPRContext = true;\n      (elevated as any).includeCodeContext = true;\n      if (debug)\n        log?.(`🔧 Debug: Elevated context to PR #${prNumber} for goto_event=${targetEvent}`);\n      return elevated;\n    } catch (e) {\n      if (debug) {\n        const msg = e instanceof Error ? e.message : String(e);\n        log?.(`⚠️ Debug: Context elevation to PR failed: ${msg}`);\n      }\n      return null;\n    }\n  }\n\n  /**\n   * Execute multiple checks with dependency awareness - intelligently parallel and sequential\n   */\n  private async executeDependencyAwareChecks(\n    prInfo: PRInfo,\n    checks: string[],\n    timeout?: number,\n    config?: import('./types/config').VisorConfig,\n    logFn?: (message: string) => void,\n    debug?: boolean,\n    maxParallelism?: number,\n    failFast?: boolean,\n    tagFilter?: import('./types/config').TagFilter\n  ): Promise<ReviewSummary> {\n    const log = logFn || console.error;\n\n    if (debug) {\n      log(`🔧 Debug: Starting dependency-aware execution of ${checks.length} checks`);\n    }\n\n    if (!config?.checks) {\n      throw new Error('Config with check definitions required for dependency-aware execution');\n    }\n\n    // Determine effective max parallelism (CLI > config > default)\n    const effectiveMaxParallelism = maxParallelism ?? config.max_parallelism ?? 3;\n    // Determine effective fail-fast setting (CLI > config > default)\n    const effectiveFailFast = failFast ?? config.fail_fast ?? false;\n\n    if (debug) {\n      log(`🔧 Debug: Using max parallelism: ${effectiveMaxParallelism}`);\n      log(`🔧 Debug: Using fail-fast: ${effectiveFailFast}`);\n    }\n\n    // Build dependency graph and check for session reuse requirements\n    const dependencies: Record<string, string[]> = {};\n    const sessionReuseChecks = new Set<string>();\n    const sessionProviders = new Map<string, string>(); // checkName -> parent session provider\n\n    for (const checkName of checks) {\n      const checkConfig = config.checks![checkName];\n      if (checkConfig) {\n        dependencies[checkName] = checkConfig.depends_on || [];\n\n        // Track checks that need session reuse\n        if (checkConfig.reuse_ai_session) {\n          sessionReuseChecks.add(checkName);\n\n          // Determine the session provider check name\n          if (typeof checkConfig.reuse_ai_session === 'string') {\n            // Explicit check name provided\n            sessionProviders.set(checkName, checkConfig.reuse_ai_session);\n          } else if (checkConfig.reuse_ai_session === true) {\n            // Use first dependency as fallback\n            if (checkConfig.depends_on && checkConfig.depends_on.length > 0) {\n              sessionProviders.set(checkName, checkConfig.depends_on[0]);\n            }\n          }\n        }\n      } else {\n        dependencies[checkName] = [];\n      }\n    }\n\n    if (sessionReuseChecks.size > 0 && debug) {\n      log(\n        `🔄 Debug: Found ${sessionReuseChecks.size} checks requiring session reuse: ${Array.from(sessionReuseChecks).join(', ')}`\n      );\n    }\n\n    // (moved) dependency validation runs after we include transitive dependencies\n\n    // Expand requested checks with transitive dependencies present in config for execution\n    const expandWithTransitives = (rootChecks: string[]): string[] => {\n      if (!config?.checks) return rootChecks;\n      const set = new Set<string>(rootChecks);\n      const allowByTags = (name: string): boolean => {\n        if (!tagFilter) return true;\n        const cfg = config!.checks?.[name];\n        const tags: string[] = (cfg && (cfg as any).tags) || [];\n        if (tagFilter.exclude && tagFilter.exclude.some(t => tags.includes(t))) return false;\n        if (tagFilter.include && tagFilter.include.length > 0) {\n          return tagFilter.include.some(t => tags.includes(t));\n        }\n        return true;\n      };\n      const visit = (name: string) => {\n        const cfg = config.checks![name];\n        if (!cfg || !cfg.depends_on) return;\n        for (const dep of cfg.depends_on) {\n          if (!config.checks![dep]) continue;\n          if (!allowByTags(dep)) continue;\n          if (!set.has(dep)) {\n            set.add(dep);\n            visit(dep);\n          }\n        }\n      };\n      for (const c of rootChecks) visit(c);\n      return Array.from(set);\n    };\n\n    checks = expandWithTransitives(checks);\n\n    // Rebuild dependencies map for the expanded set\n    for (const checkName of checks) {\n      const checkConfig = config.checks![checkName];\n      dependencies[checkName] = checkConfig?.depends_on || [];\n    }\n\n    // Validate dependencies after expansion so transitive deps are considered\n    {\n      const validation2 = DependencyResolver.validateDependencies(checks, dependencies);\n      if (!validation2.valid) {\n        return {\n          issues: [\n            {\n              severity: 'error' as const,\n              message: `Dependency validation failed: ${validation2.errors.join(', ')}`,\n              file: '',\n              line: 0,\n              ruleId: 'dependency-validation-error',\n              category: 'logic' as const,\n            },\n          ],\n        };\n      }\n    }\n\n    // Build dependency graph\n    const dependencyGraph = DependencyResolver.buildDependencyGraph(dependencies);\n\n    if (dependencyGraph.hasCycles) {\n      return {\n        issues: [\n          {\n            severity: 'error' as const,\n            message: `Circular dependencies detected: ${dependencyGraph.cycleNodes?.join(' -> ')}`,\n            file: '',\n            line: 0,\n            ruleId: 'circular-dependency-error',\n            category: 'logic' as const,\n          },\n        ],\n      };\n    }\n\n    // Build children-by-parent mapping for inline branch-first execution\n    const childrenByParent = new Map<string, string[]>();\n    for (const [child, depsArr] of Object.entries(dependencies)) {\n      for (const p of depsArr || []) {\n        if (!childrenByParent.has(p)) childrenByParent.set(p, []);\n        childrenByParent.get(p)!.push(child);\n      }\n    }\n\n    // Log execution plan\n    const stats = DependencyResolver.getExecutionStats(dependencyGraph);\n    if (debug) {\n      log(\n        `🔧 Debug: Execution plan - ${stats.totalChecks} checks in ${stats.parallelLevels} levels, max parallelism: ${stats.maxParallelism}`\n      );\n    }\n\n    // Execute checks level by level\n    const results = new Map<string, ReviewSummary>();\n    const sessionRegistry = require('./session-registry').SessionRegistry.getInstance();\n    // Note: We'll get the provider dynamically per check, not a single one for all\n    const sessionIds = new Map<string, string>(); // checkName -> sessionId\n    let shouldStopExecution = false;\n    let completedChecksCount = 0;\n    const totalChecksCount = stats.totalChecks;\n\n    // Initialize execution statistics for all checks\n    for (const checkName of checks) {\n      this.initializeCheckStats(checkName);\n    }\n\n    for (\n      let levelIndex = 0;\n      levelIndex < dependencyGraph.executionOrder.length && !shouldStopExecution;\n      levelIndex++\n    ) {\n      const executionGroup = dependencyGraph.executionOrder[levelIndex];\n\n      // Check for session reuse conflicts - only force sequential execution when there are actual conflicts\n      const checksInLevel = executionGroup.parallel;\n\n      // Group checks by their session parent\n      const sessionReuseGroups = new Map<string, string[]>();\n      checksInLevel.forEach(checkName => {\n        if (sessionReuseChecks.has(checkName)) {\n          const parentCheckName = sessionProviders.get(checkName);\n          if (parentCheckName) {\n            if (!sessionReuseGroups.has(parentCheckName)) {\n              sessionReuseGroups.set(parentCheckName, []);\n            }\n            sessionReuseGroups.get(parentCheckName)!.push(checkName);\n          }\n        }\n      });\n\n      // Only force sequential execution if multiple checks share the same session parent\n      const hasConflictingSessionReuse = Array.from(sessionReuseGroups.values()).some(\n        group => group.length > 1\n      );\n\n      let actualParallelism = Math.min(effectiveMaxParallelism, executionGroup.parallel.length);\n      if (hasConflictingSessionReuse) {\n        // Force sequential execution when there are actual session conflicts\n        actualParallelism = 1;\n        if (debug) {\n          const conflictingGroups = Array.from(sessionReuseGroups.entries())\n            .filter(([_, checks]) => checks.length > 1)\n            .map(([parent, checks]) => `${parent} -> [${checks.join(', ')}]`)\n            .join('; ');\n          log(\n            `🔄 Debug: Level ${executionGroup.level} has session conflicts (${conflictingGroups}) - forcing sequential execution (parallelism: 1)`\n          );\n        }\n      } else if (sessionReuseGroups.size > 0 && debug) {\n        log(\n          `✅ Debug: Level ${executionGroup.level} has session reuse but no conflicts - allowing parallel execution`\n        );\n      }\n\n      if (debug) {\n        log(\n          `🔧 Debug: Executing level ${executionGroup.level} with ${executionGroup.parallel.length} checks (parallelism: ${actualParallelism})`\n        );\n      }\n\n      // Create task functions for checks in this level, skip those already completed inline\n      const levelChecks = executionGroup.parallel.filter(name => !results.has(name));\n      const levelTaskFunctions = levelChecks.map(checkName => async () => {\n        // Skip if this check was already completed by item-level branch scheduler\n        if (results.has(checkName)) {\n          if (debug) log(`🔧 Debug: Skipping ${checkName} (already satisfied earlier)`);\n          return { checkName, error: null, result: results.get(checkName)! };\n        }\n        const checkConfig = config.checks![checkName];\n        if (!checkConfig) {\n          return {\n            checkName,\n            error: `No configuration found for check: ${checkName}`,\n            result: null,\n          };\n        }\n\n        // (no early gating; rely on per-item scheduler after parents run)\n\n        const checkStartTime = Date.now();\n        completedChecksCount++;\n        logger.step(`Running check: ${checkName} [${completedChecksCount}/${totalChecksCount}]`);\n\n        try {\n          if (debug) {\n            log(`🔧 Debug: Starting check: ${checkName} at level ${executionGroup.level}`);\n          }\n\n          // Get the appropriate provider for this check type\n          const providerType = checkConfig.type || 'ai';\n          const provider = this.providerRegistry.getProviderOrThrow(providerType);\n          if (debug) {\n            log(`🔧 Debug: Provider f|| '${checkName}' is '${providerType}'`);\n          }\n          this.setProviderWebhookContext(provider);\n\n          // Create provider config for this specific check\n          const extendedCheckConfig = checkConfig as CheckConfig & {\n            level?: string;\n            message?: string;\n          };\n\n          const providerConfig: CheckProviderConfig = {\n            type: providerType,\n            prompt: checkConfig.prompt,\n            exec: checkConfig.exec,\n            focus: checkConfig.focus || this.mapCheckNameToFocus(checkName),\n            schema: checkConfig.schema,\n            group: checkConfig.group,\n            checkName: checkName, // Add checkName for sessionID\n            eventContext: this.enrichEventContext(prInfo.eventContext),\n            transform: checkConfig.transform,\n            transform_js: checkConfig.transform_js,\n            // Important: pass through provider-level timeout from check config\n            // (e.g., command/http_client providers expect seconds/ms here)\n            timeout: checkConfig.timeout,\n            level: extendedCheckConfig.level,\n            message: extendedCheckConfig.message,\n            env: checkConfig.env,\n            forEach: checkConfig.forEach,\n            // Pass through any provider-specific keys (e.g., op/values for github provider)\n            ...checkConfig,\n            ai: {\n              ...(checkConfig.ai || {}),\n              timeout: timeout || 600000,\n              debug: debug,\n            },\n          };\n\n          // Pass results from ALL transitive dependencies (not just direct ones)\n          // This ensures the \"outputs\" variable has access to all ancestor check results\n          const dependencyResults = new Map<string, ReviewSummary>();\n          let isForEachDependent = false;\n          let forEachItems: unknown[] = [];\n          let forEachParentName: string | undefined;\n          const forEachParents: string[] = []; // Track ALL forEach parents\n\n          // Get all transitive dependencies (ancestors) for this check\n          const allDependencies = DependencyResolver.getAllDependencies(\n            checkName,\n            dependencyGraph.nodes\n          );\n\n          // Include results from ALL dependencies (direct and transitive)\n          for (const depId of allDependencies) {\n            if (results.has(depId)) {\n              const depResult = results.get(depId)!;\n              dependencyResults.set(depId, depResult);\n            }\n          }\n\n          // If any direct dependency failed or was skipped, skip this check\n          const directDeps = checkConfig.depends_on || [];\n          const failedDeps: string[] = [];\n          for (const depId of directDeps) {\n            const depRes = results.get(depId);\n            if (!depRes) continue;\n\n            // Check if dependency was skipped\n            const wasSkipped = (depRes.issues || []).some(issue => {\n              const id = issue.ruleId || '';\n              return id.endsWith('/__skipped');\n            });\n\n            // If dependency is a forEach parent, do NOT apply global fatal gating here.\n            // We'll gate per-item inside the forEach loop to avoid stopping other branches.\n            const depExtended = depRes as ExtendedReviewSummary;\n            const isDepForEachParent = !!depExtended.isForEach;\n\n            // Treat these as fatal in direct dependencies (non-forEach only):\n            //  - command provider execution/transform failures\n            //  - forEach validation/iteration errors\n            //  - fail_if conditions (global or check-specific)\n            // For non-forEach parents, only provider-fatal or fail_if/global_fail_if should gate.\n            let hasFatalFailure = false;\n            if (!isDepForEachParent) {\n              const issues = depRes.issues || [];\n              hasFatalFailure = issues.some(issue => {\n                const id = issue.ruleId || '';\n                return (\n                  id === 'command/execution_error' ||\n                  id.endsWith('/command/execution_error') ||\n                  id === 'command/timeout' ||\n                  id.endsWith('/command/timeout') ||\n                  id === 'command/transform_js_error' ||\n                  id.endsWith('/command/transform_js_error') ||\n                  id === 'command/transform_error' ||\n                  id.endsWith('/command/transform_error') ||\n                  id === 'forEach/undefined_output' ||\n                  id.endsWith('/forEach/undefined_output') ||\n                  id.endsWith('/forEach/iteration_error') ||\n                  id.endsWith('_fail_if') ||\n                  id.endsWith('/global_fail_if')\n                );\n              });\n              // As a fallback, evaluate fail_if on the dependency result now\n              if (\n                !hasFatalFailure &&\n                config &&\n                (config.fail_if || config.checks![depId]?.fail_if)\n              ) {\n                try {\n                  hasFatalFailure = await this.failIfTriggered(depId, depRes, config, results);\n                } catch {}\n              }\n            }\n\n            if (debug) {\n              log(\n                `🔧 Debug: gating check '${checkName}' against dep '${depId}': wasSkipped=${wasSkipped} hasFatalFailure=${hasFatalFailure}`\n              );\n            }\n            if (wasSkipped || hasFatalFailure) failedDeps.push(depId);\n          }\n\n          if (failedDeps.length > 0) {\n            // Record skip and provide a concise console message\n            this.recordSkip(checkName, 'dependency_failed');\n            logger.info(`⏭  Skipped (dependency failed: ${failedDeps.join(', ')})`);\n            return {\n              checkName,\n              error: null,\n              result: { issues: [] },\n              skipped: true,\n            };\n          }\n\n          // Check direct dependencies for forEach behavior\n          for (const depId of checkConfig.depends_on || []) {\n            if (results.has(depId)) {\n              const depResult = results.get(depId)!;\n\n              // Check if this dependency has forEach enabled\n              const depForEachResult = depResult as ExtendedReviewSummary;\n\n              if (\n                depForEachResult.isForEach ||\n                Array.isArray(depForEachResult.forEachItemResults) ||\n                Array.isArray(depForEachResult.forEachItems)\n              ) {\n                if (!isForEachDependent) {\n                  // First forEach dependency found - use it as the primary\n                  isForEachDependent = true;\n                  forEachItems = Array.isArray(depForEachResult.forEachItems)\n                    ? depForEachResult.forEachItems!\n                    : new Array(\n                        Array.isArray(depForEachResult.forEachItemResults)\n                          ? depForEachResult.forEachItemResults!.length\n                          : 0\n                      ).fill(undefined);\n                  forEachParentName = depId;\n                }\n                // Track all forEach parents for unwrapping\n                forEachParents.push(depId);\n              }\n            }\n          }\n\n          // Determine if we should use session reuse\n          let sessionInfo: { parentSessionId?: string; reuseSession?: boolean } | undefined =\n            undefined;\n          if (sessionReuseChecks.has(checkName)) {\n            const parentCheckName = sessionProviders.get(checkName);\n            if (parentCheckName && sessionIds.has(parentCheckName)) {\n              const parentSessionId = sessionIds.get(parentCheckName)!;\n\n              sessionInfo = {\n                parentSessionId: parentSessionId,\n                reuseSession: true,\n              };\n\n              if (debug) {\n                log(\n                  `🔄 Debug: Check ${checkName} will reuse session from parent ${parentCheckName}: ${parentSessionId}`\n                );\n              }\n            } else {\n              if (debug) {\n                log(\n                  `⚠️ Warning: Check ${checkName} requires session reuse but parent ${parentCheckName} session not found`\n                );\n              }\n            }\n          }\n\n          // For checks that create new sessions, generate a session ID\n          let currentSessionId: string | undefined = undefined;\n          if (!sessionInfo?.reuseSession) {\n            const timestamp = new Date().toISOString();\n            currentSessionId = `visor-${timestamp.replace(/[:.]/g, '-')}-${checkName}`;\n            sessionIds.set(checkName, currentSessionId);\n            if (debug) {\n              log(`🆕 Debug: Check ${checkName} will create new session: ${currentSessionId}`);\n            }\n\n            // Add session ID to provider config\n            providerConfig.sessionId = currentSessionId;\n          }\n\n          // Handle forEach dependent execution\n          let finalResult: ReviewSummary;\n\n          if (isForEachDependent && forEachParentName) {\n            if (!Array.isArray(forEachItems)) {\n              forEachItems = [];\n            }\n            if (!Array.isArray(forEachItems)) {\n              this.recordSkip(checkName, 'dependency_failed');\n              return {\n                checkName,\n                error: null,\n                result: { issues: [] },\n                skipped: true,\n              };\n            }\n            // Record forEach preview items\n            this.recordForEachPreview(checkName, forEachItems);\n\n            // If the forEach parent returned an empty array, skip this check entirely\n            if (forEachItems.length === 0) {\n              if (debug) {\n                log(\n                  `🔄 Debug: Skipping check \"${checkName}\" - forEach check \"${forEachParentName}\" returned 0 items`\n                );\n              }\n              logger.info(`  forEach: no items from \"${forEachParentName}\", skipping check...`);\n              this.recordSkip(checkName, 'dependency_failed');\n\n              // Return a special marker result so that dependent checks can detect the skip\n              finalResult = {\n                issues: [],\n                output: [],\n              } as ReviewSummary;\n\n              // Mark this result as forEach-capable but with empty items\n              (finalResult as ExtendedReviewSummary).isForEach = true;\n              (finalResult as ExtendedReviewSummary).forEachItems = [];\n\n              // Skip to the end - don't execute this check\n            } else {\n              // Emit explicit debug to stdout so CLI e2e can assert it\n              if (\n                debug &&\n                process.env.VISOR_OUTPUT_FORMAT !== 'json' &&\n                process.env.VISOR_OUTPUT_FORMAT !== 'sarif'\n              ) {\n                console.log(\n                  `🔄 Debug: Check \"${checkName}\" depends on forEach check \"${forEachParentName}\", executing ${forEachItems.length} times`\n                );\n              }\n\n              // Log forEach processing start (non-debug)\n              const __itemCount = Array.isArray(forEachItems) ? forEachItems.length : 0;\n              logger.info(\n                `  forEach: processing ${__itemCount} items from \"${forEachParentName}\"...`\n              );\n\n              const allIssues: ReviewIssue[] = [];\n              const allOutputs: unknown[] = new Array(forEachItems.length);\n              const aggregatedContents: string[] = [];\n              const perItemResults: Array<ReviewSummary | undefined> = new Array(\n                forEachItems.length\n              );\n\n              // Aggregators for inline descendant execution (branch-first mode for simple chains)\n              const inlineAgg = new Map<\n                string,\n                {\n                  issues: ReviewIssue[];\n                  outputs: unknown[];\n                  contents: string[];\n                  perItemResults: ReviewSummary[];\n                }\n              >();\n\n              // eslint-disable-next-line @typescript-eslint/no-unused-vars\n              const execInlineDescendants = async (\n                parentName: string,\n                itemIndex: number,\n                baseDeps: Map<string, ReviewSummary>\n              ): Promise<void> => {\n                const children = (childrenByParent.get(parentName) || []).filter(child => {\n                  const deps = dependencies[child] || [];\n                  // Only handle simple chains inline: exactly one dependency which is the parent\n                  return deps.length === 1 && deps[0] === parentName;\n                });\n\n                for (const childName of children) {\n                  const childCfg = config.checks![childName];\n                  const childProviderType = childCfg.type || 'ai';\n                  const childProv = this.providerRegistry.getProviderOrThrow(childProviderType);\n                  this.setProviderWebhookContext(childProv);\n                  const childProviderConfig: CheckProviderConfig = {\n                    type: childProviderType,\n                    prompt: childCfg.prompt,\n                    exec: childCfg.exec,\n                    focus: childCfg.focus || this.mapCheckNameToFocus(childName),\n                    schema: childCfg.schema,\n                    group: childCfg.group,\n                    checkName: childName,\n                    eventContext: this.enrichEventContext(prInfo.eventContext),\n                    transform: childCfg.transform,\n                    transform_js: childCfg.transform_js,\n                    env: childCfg.env,\n                    forEach: childCfg.forEach,\n                    // Include provider-specific keys like op/values for non-AI providers\n                    ...childCfg,\n                    ai: {\n                      ...(childCfg.ai || {}),\n                      timeout: timeout || 600000,\n                      debug: debug,\n                    },\n                  };\n                  try {\n                    emitNdjsonSpanWithEvents('visor.check', { 'visor.check.id': checkName }, [\n                      { name: 'check.started' },\n                      { name: 'check.completed' },\n                    ]);\n                  } catch {}\n\n                  // If the parent item had a fatal failure per mask, skip this child for this branch\n                  const parentAgg = results.get(parentName) as ExtendedReviewSummary | undefined;\n                  const maskFatal =\n                    !!parentAgg?.forEachFatalMask &&\n                    parentAgg!.forEachFatalMask![itemIndex] === true;\n                  if (maskFatal) {\n                    continue;\n                  }\n\n                  // Evaluate per-item if condition\n                  if (childCfg.if) {\n                    const itemScope: ScopePath = [{ check: parentName, index: itemIndex }];\n                    const condResults = this.buildSnapshotDependencyResults(\n                      itemScope,\n                      undefined,\n                      prInfo.eventType\n                    );\n                    for (const [k, v] of baseDeps.entries()) condResults.set(k, v);\n                    const shouldRunChild = await this.evaluateCheckCondition(\n                      childName,\n                      childCfg.if,\n                      prInfo,\n                      condResults,\n                      debug\n                    );\n                    if (!shouldRunChild) {\n                      continue;\n                    }\n                  }\n\n                  // Execute child for this item (record stats)\n                  const childIterStart = this.recordIterationStart(childName);\n                  // Build snapshot-based dependency view for this item scope\n                  const itemScope: ScopePath = [{ check: parentName, index: itemIndex }];\n                  const snapshotDeps = this.buildSnapshotDependencyResults(\n                    itemScope,\n                    undefined,\n                    prInfo.eventType\n                  );\n                  for (const [k, v] of baseDeps.entries()) snapshotDeps.set(k, v);\n\n                  const childItemRes = await this.executeWithRouting(\n                    childName,\n                    childCfg,\n                    childProv,\n                    childProviderConfig,\n                    prInfo,\n                    snapshotDeps,\n                    sessionInfo,\n                    config,\n                    dependencyGraph,\n                    debug,\n                    results,\n                    { index: itemIndex, total: forEachItems.length, parent: parentName }\n                  );\n\n                  // Per-item fail_if\n                  if (config && (config.fail_if || childCfg.fail_if)) {\n                    const fRes = await this.evaluateFailureConditions(\n                      childName,\n                      childItemRes,\n                      config,\n                      prInfo,\n                      results\n                    );\n                    if (fRes.length > 0) {\n                      const fIssues = fRes\n                        .filter(f => f.failed)\n                        .map(f => ({\n                          file: 'system',\n                          line: 0,\n                          ruleId: f.conditionName,\n                          message: f.message || `Failure condition met: ${f.expression}`,\n                          severity: (f.severity || 'error') as\n                            | 'info'\n                            | 'warning'\n                            | 'error'\n                            | 'critical',\n                          category: 'logic' as const,\n                        }));\n                      childItemRes.issues = [...(childItemRes.issues || []), ...fIssues];\n                    }\n                  }\n\n                  if (!inlineAgg.has(childName)) {\n                    inlineAgg.set(childName, {\n                      issues: [],\n                      outputs: new Array(forEachItems.length),\n                      contents: [],\n                      perItemResults: new Array(forEachItems.length),\n                    });\n                  }\n                  const agg = inlineAgg.get(childName)!;\n                  if (childItemRes.issues) agg.issues.push(...childItemRes.issues);\n                  const out = (childItemRes as any).output;\n                  agg.outputs[itemIndex] = out;\n                  agg.perItemResults[itemIndex] = childItemRes;\n                  const c = (childItemRes as any).content;\n                  if (typeof c === 'string' && c.trim()) agg.contents.push(c.trim());\n\n                  // Record iteration completion for stats\n                  const childHadFatal = this.hasFatal(childItemRes.issues || []);\n                  this.recordIterationComplete(\n                    childName,\n                    childIterStart,\n                    !childHadFatal,\n                    childItemRes.issues || [],\n                    (childItemRes as any).output\n                  );\n\n                  // Recurse further for simple chains\n                  const nextBase = new Map(baseDeps);\n                  nextBase.set(childName, childItemRes);\n                  await execInlineDescendants(childName, itemIndex, nextBase);\n                }\n              };\n\n              // Create task functions (not executed yet) - these will be executed with controlled concurrency\n              // via executeWithLimitedParallelism to respect maxParallelism setting\n              const itemTasks = forEachItems.map((item, itemIndex) => async () => {\n                try {\n                  emitNdjsonSpanWithEvents(\n                    'visor.foreach.item',\n                    {\n                      'visor.check.id': checkName,\n                      'visor.foreach.index': itemIndex,\n                      'visor.foreach.total': forEachItems.length,\n                    },\n                    []\n                  );\n                } catch {}\n                // Build snapshot-based dependency view for this item scope (no per-item cloning)\n                const itemScope: ScopePath = [{ check: forEachParentName!, index: itemIndex }];\n                const snapshotDeps = this.buildSnapshotDependencyResults(\n                  itemScope,\n                  undefined,\n                  prInfo.eventType\n                );\n\n                // Per-item dependency gating for forEach parents: if a dependency failed for this item, skip this iteration\n                if ((checkConfig.depends_on || []).length > 0) {\n                  const directDeps = checkConfig.depends_on || [];\n                  for (const depId of directDeps) {\n                    if (!forEachParents.includes(depId)) continue;\n                    const depAgg = results.get(depId) as ExtendedReviewSummary | undefined;\n                    const maskFatal =\n                      !!depAgg?.forEachFatalMask && depAgg!.forEachFatalMask![itemIndex] === true;\n                    if (maskFatal) {\n                      if (debug) {\n                        log(\n                          `🔄 Debug: Skipping item ${itemIndex + 1}/${forEachItems.length} for check \"${checkName}\" due to failed dependency '${depId}'`\n                        );\n                      }\n                      return {\n                        index: itemIndex,\n                        itemResult: { issues: [] } as ReviewSummary,\n                        skipped: true,\n                      };\n                    }\n                  }\n                }\n\n                // Evaluate if condition for this forEach item\n                if (checkConfig.if) {\n                  const shouldRun = await this.evaluateCheckCondition(\n                    checkName,\n                    checkConfig.if,\n                    prInfo,\n                    snapshotDeps,\n                    debug\n                  );\n\n                  if (!shouldRun) {\n                    if (debug) {\n                      log(\n                        `🔄 Debug: Skipping forEach item ${itemIndex + 1} for check \"${checkName}\" (if condition evaluated to false)`\n                      );\n                    }\n                    // Return empty result for skipped items\n                    return {\n                      index: itemIndex,\n                      itemResult: { issues: [] } as ReviewSummary,\n                      skipped: true,\n                    };\n                  }\n                }\n\n                if (debug) {\n                  log(\n                    `🔄 Debug: Executing check \"${checkName}\" for item ${itemIndex + 1}/${forEachItems.length}`\n                  );\n                }\n\n                // Track iteration start\n                const iterationStart = this.recordIterationStart(checkName);\n\n                // Execute with retry/routing semantics per item\n                const itemResult = await this.executeWithRouting(\n                  checkName,\n                  checkConfig,\n                  provider,\n                  providerConfig,\n                  prInfo,\n                  snapshotDeps,\n                  sessionInfo,\n                  config,\n                  dependencyGraph,\n                  debug,\n                  results,\n                  /*foreachContext*/ {\n                    index: itemIndex,\n                    total: forEachItems.length,\n                    parent: forEachParentName,\n                  }\n                );\n                // no-op\n\n                // Evaluate fail_if per item so a single failing branch does not stop others\n                if (config && (config.fail_if || checkConfig.fail_if)) {\n                  const itemFailures = await this.evaluateFailureConditions(\n                    checkName,\n                    itemResult,\n                    config,\n                    prInfo,\n                    results\n                  );\n                  if (itemFailures.length > 0) {\n                    const failureIssues = itemFailures\n                      .filter(f => f.failed)\n                      .map(f => ({\n                        file: 'system',\n                        line: 0,\n                        ruleId: f.conditionName,\n                        message: f.message || `Failure condition met: ${f.expression}`,\n                        severity: (f.severity || 'error') as\n                          | 'info'\n                          | 'warning'\n                          | 'error'\n                          | 'critical',\n                        category: 'logic' as const,\n                      }));\n                    itemResult.issues = [...(itemResult.issues || []), ...failureIssues];\n                  }\n                }\n\n                // Record iteration completion\n                // Check if this iteration had fatal errors\n                const hadFatalError = (itemResult.issues || []).some(issue => {\n                  const id = issue.ruleId || '';\n                  return (\n                    id === 'command/execution_error' ||\n                    id.endsWith('/command/execution_error') ||\n                    id === 'command/transform_js_error' ||\n                    id.endsWith('/command/transform_js_error') ||\n                    id === 'command/transform_error' ||\n                    id.endsWith('/command/transform_error') ||\n                    id === 'forEach/undefined_output' ||\n                    id.endsWith('/forEach/undefined_output')\n                  );\n                });\n                const iterationDuration = (Date.now() - iterationStart) / 1000;\n                this.recordIterationComplete(\n                  checkName,\n                  iterationStart,\n                  !hadFatalError, // Success if no fatal errors\n                  itemResult.issues || [],\n                  (itemResult as any).output\n                );\n\n                // Track output history for forEach iterations\n                const itemOutput = (itemResult as any).output;\n                if (itemOutput !== undefined) {\n                  this.trackOutputHistory(checkName, itemOutput);\n                }\n\n                // General branch-first scheduling for this item: execute all descendants (from current node only) when ready\n                const descendantSet = (() => {\n                  const visited = new Set<string>();\n                  const stack = [checkName];\n                  while (stack.length) {\n                    const p = stack.pop()!;\n                    const kids = childrenByParent.get(p) || [];\n                    for (const k of kids) {\n                      if (!visited.has(k)) {\n                        visited.add(k);\n                        stack.push(k);\n                      }\n                    }\n                  }\n                  return visited;\n                })();\n\n                const perItemDone = new Set<string>([...forEachParents, checkName]);\n                const perItemDepMap = new Map<string, ReviewSummary>();\n                perItemDepMap.set(checkName, itemResult);\n\n                const isFatal = (r: ReviewSummary | undefined): boolean => {\n                  if (!r) return true;\n                  return this.hasFatal(r.issues || []);\n                };\n\n                while (true) {\n                  let progressed = false;\n                  for (const node of descendantSet) {\n                    if (perItemDone.has(node)) continue;\n                    const nodeCfg = config.checks![node];\n                    if (!nodeCfg) continue;\n                    const deps = dependencies[node] || [];\n\n                    // Are all deps satisfied for this item according to aggregate visibility/masks?\n                    let ready = true;\n                    for (const d of deps) {\n                      // If we have a per-item result for this dependency, honor its fatality\n                      const perItemRes = perItemDepMap.get(d);\n                      if (perItemRes) {\n                        if (isFatal(perItemRes)) {\n                          ready = false;\n                          break;\n                        }\n                        continue;\n                      }\n                      // If this dependency was executed earlier in this item's chain, it's satisfied\n                      if (perItemDone.has(d)) continue;\n                      const agg = results.get(d) as ExtendedReviewSummary | undefined;\n                      if (!agg) {\n                        ready = false;\n                        break;\n                      }\n                      if (agg.isForEach || Array.isArray(agg.forEachItemResults)) {\n                        const maskFatal =\n                          !!agg.forEachFatalMask && agg.forEachFatalMask[itemIndex] === true;\n                        if (maskFatal) {\n                          ready = false;\n                          break;\n                        }\n                      } else {\n                        if (isFatal(agg)) {\n                          ready = false;\n                          break;\n                        }\n                      }\n                    }\n                    if (!ready) continue;\n\n                    // if condition per item\n                    if (nodeCfg.if) {\n                      const itemScope: ScopePath = [{ check: forEachParentName, index: itemIndex }];\n                      const condResults = this.buildSnapshotDependencyResults(\n                        itemScope,\n                        undefined,\n                        prInfo.eventType\n                      );\n                      for (const [k, v] of perItemDepMap.entries()) condResults.set(k, v);\n                      const shouldRun = await this.evaluateCheckCondition(\n                        node,\n                        nodeCfg.if,\n                        prInfo,\n                        condResults,\n                        debug\n                      );\n                      if (!shouldRun) {\n                        perItemDone.add(node);\n                        progressed = true;\n                        continue;\n                      }\n                    }\n\n                    // Execute node for this item\n                    const nodeProvType = nodeCfg.type || 'ai';\n                    const nodeProv = this.providerRegistry.getProviderOrThrow(nodeProvType);\n                    this.setProviderWebhookContext(nodeProv);\n                    const nodeProviderConfig: CheckProviderConfig = {\n                      type: nodeProvType,\n                      prompt: nodeCfg.prompt,\n                      exec: nodeCfg.exec,\n                      focus: nodeCfg.focus || this.mapCheckNameToFocus(node),\n                      schema: nodeCfg.schema,\n                      group: nodeCfg.group,\n                      checkName: node,\n                      eventContext: this.enrichEventContext(prInfo.eventContext),\n                      transform: nodeCfg.transform,\n                      transform_js: nodeCfg.transform_js,\n                      env: nodeCfg.env,\n                      forEach: nodeCfg.forEach,\n                      ai: { timeout: timeout || 600000, debug: debug, ...(nodeCfg.ai || {}) },\n                    };\n\n                    const iterStart = this.recordIterationStart(node);\n                    // Build snapshot-based dependency map at item scope\n                    const itemScope: ScopePath = [{ check: forEachParentName, index: itemIndex }];\n                    const execDepMap = this.buildSnapshotDependencyResults(\n                      itemScope,\n                      undefined,\n                      prInfo.eventType\n                    );\n                    for (const [k, v] of perItemDepMap.entries()) execDepMap.set(k, v);\n\n                    const nodeItemRes = await this.executeWithRouting(\n                      node,\n                      nodeCfg,\n                      nodeProv,\n                      nodeProviderConfig,\n                      prInfo,\n                      execDepMap,\n                      sessionInfo,\n                      config,\n                      dependencyGraph,\n                      debug,\n                      results,\n                      { index: itemIndex, total: forEachItems.length, parent: forEachParentName }\n                    );\n\n                    if (config && (config.fail_if || nodeCfg.fail_if)) {\n                      const fRes = await this.evaluateFailureConditions(\n                        node,\n                        nodeItemRes,\n                        config,\n                        prInfo,\n                        results\n                      );\n                      if (fRes.length > 0) {\n                        const fIssues = fRes\n                          .filter(f => f.failed)\n                          .map(f => ({\n                            file: 'system',\n                            line: 0,\n                            ruleId: f.conditionName,\n                            message: f.message || `Failure condition met: ${f.expression}`,\n                            severity: (f.severity || 'error') as\n                              | 'info'\n                              | 'warning'\n                              | 'error'\n                              | 'critical',\n                            category: 'logic' as const,\n                          }));\n                        nodeItemRes.issues = [...(nodeItemRes.issues || []), ...fIssues];\n                      }\n                    }\n\n                    const hadFatal = isFatal(nodeItemRes);\n                    this.recordIterationComplete(\n                      node,\n                      iterStart,\n                      !hadFatal,\n                      nodeItemRes.issues || [],\n                      (nodeItemRes as any).output\n                    );\n\n                    // Aggregate results for this node across items\n                    if (!inlineAgg.has(node))\n                      inlineAgg.set(node, {\n                        issues: [],\n                        outputs: [],\n                        contents: [],\n                        perItemResults: [],\n                      });\n                    const agg = inlineAgg.get(node)!;\n                    if (nodeItemRes.issues) agg.issues.push(...nodeItemRes.issues);\n                    const nout = (nodeItemRes as any).output;\n                    if (nout !== undefined) agg.outputs.push(nout);\n                    agg.perItemResults.push(nodeItemRes);\n                    const ncontent = (nodeItemRes as any).content;\n                    if (typeof ncontent === 'string' && ncontent.trim())\n                      agg.contents.push(ncontent.trim());\n\n                    perItemDepMap.set(node, nodeItemRes);\n                    perItemDone.add(node);\n                    progressed = true;\n                  }\n                  if (!progressed) break;\n                }\n\n                // Log iteration progress\n                logger.info(\n                  `  ✔ ${itemIndex + 1}/${forEachItems.length} (${iterationDuration.toFixed(1)}s)`\n                );\n\n                perItemResults[itemIndex] = itemResult;\n                return { index: itemIndex, itemResult };\n              });\n\n              // Determine runnable indices by intersecting masks across all direct forEach parents\n              const directForEachParents = (checkConfig.depends_on || []).filter(dep => {\n                const r = results.get(dep) as ExtendedReviewSummary | undefined;\n                return (\n                  !!r &&\n                  (r.isForEach ||\n                    Array.isArray(r.forEachItemResults) ||\n                    Array.isArray(r.forEachItems))\n                );\n              });\n              if (directForEachParents.length > 0) {\n                logger.debug(\n                  `  forEach: direct parents for \"${checkName}\": ${directForEachParents.join(', ')}`\n                );\n              }\n\n              const isIndexFatalForParent = async (\n                parent: string,\n                idx: number\n              ): Promise<boolean> => {\n                const agg = results.get(parent) as ExtendedReviewSummary | undefined;\n                if (!agg) return false; // if missing, do not gate\n                if (agg.forEachFatalMask && agg.forEachFatalMask[idx] === true) return true;\n                const r = (agg.forEachItemResults && agg.forEachItemResults[idx]) || undefined;\n                if (!r) return false;\n                // 1) Issues-based fatality (provider/transform/timeout/fail_if markers)\n                const hadFatalByIssues = this.hasFatal(r.issues || []);\n                if (hadFatalByIssues) return true;\n                // 2) Fail_if based fatality evaluated directly on the parent per-item result\n                try {\n                  if (config && (config.fail_if || config.checks![parent]?.fail_if)) {\n                    // If output is a string, try parsing JSON (full or tail) to honor fail_if semantics\n                    let rForEval: ReviewSummary = r;\n                    const rawOut = (r as any)?.output;\n                    if (typeof rawOut === 'string') {\n                      const parseTail = (text: string): unknown | null => {\n                        try {\n                          const lines = text.split('\\n');\n                          for (let i = lines.length - 1; i >= 0; i--) {\n                            const t = lines[i].trim();\n                            if (t.startsWith('{') || t.startsWith('[')) {\n                              const candidate = lines.slice(i).join('\\n').trim();\n                              if (\n                                (candidate.startsWith('{') && candidate.endsWith('}')) ||\n                                (candidate.startsWith('[') && candidate.endsWith(']'))\n                              ) {\n                                return JSON.parse(candidate);\n                              }\n                            }\n                          }\n                        } catch {}\n                        try {\n                          return JSON.parse(text);\n                        } catch {\n                          return null;\n                        }\n                      };\n                      const parsed = parseTail(rawOut);\n                      if (parsed && typeof parsed === 'object') {\n                        rForEval = { ...r, output: parsed } as ReviewSummary & { output?: unknown };\n                      }\n                    }\n                    const failures = await this.evaluateFailureConditions(\n                      parent,\n                      rForEval,\n                      config,\n                      prInfo,\n                      results\n                    );\n                    if (failures.some(f => f.failed)) {\n                      // Temporary: surface why index is gated\n                    }\n                    if (failures.some(f => f.failed)) return true;\n                  }\n                } catch {}\n                return false;\n              };\n\n              const runnableIndices: number[] = [];\n              for (let idx = 0; idx < forEachItems.length; idx++) {\n                let ok = true;\n                for (const p of directForEachParents) {\n                  if (await isIndexFatalForParent(p, idx)) {\n                    ok = false;\n                    break;\n                  }\n                }\n                // Only schedule indices that have a corresponding task function\n                if (ok && typeof itemTasks[idx] === 'function') runnableIndices.push(idx);\n              }\n\n              // no-op\n              // Early skip if no runnable items after intersecting masks across all direct forEach parents\n              if (runnableIndices.length === 0) {\n                this.recordSkip(checkName, 'dependency_failed');\n                logger.info(`⏭  Skipped (dependency failed: no runnable items)`);\n                return {\n                  checkName,\n                  error: null,\n                  result: { issues: [] },\n                  skipped: true,\n                };\n              }\n\n              const forEachConcurrency = Math.max(\n                1,\n                Math.min(runnableIndices.length, effectiveMaxParallelism)\n              );\n\n              if (debug && forEachConcurrency > 1) {\n                log(\n                  `🔄 Debug: Limiting forEach concurrency for check \"${checkName}\" to ${forEachConcurrency}`\n                );\n              }\n\n              const scheduledTasks = runnableIndices\n                .map(i => itemTasks[i])\n                .filter(fn => typeof fn === 'function');\n              const forEachResults = await this.executeWithLimitedParallelism(\n                scheduledTasks,\n                forEachConcurrency,\n                false\n              );\n\n              let processedCount = 0;\n              for (const result of forEachResults) {\n                if (result.status === 'rejected') {\n                  // Instead of throwing, record the failure and continue with other iterations\n                  const error = result.reason;\n                  const errorMessage = error instanceof Error ? error.message : String(error);\n\n                  // Create an error issue for this failed iteration\n                  allIssues.push({\n                    ruleId: `${checkName}/forEach/iteration_error`,\n                    severity: 'error',\n                    category: 'logic',\n                    message: `forEach iteration failed: ${errorMessage}`,\n                    file: '',\n                    line: 0,\n                  });\n\n                  if (debug) {\n                    log(\n                      `🔄 Debug: forEach iteration for check \"${checkName}\" failed: ${errorMessage}`\n                    );\n                  }\n                  continue;\n                }\n\n                // Skip results from skipped items (those gated by dependencies/if)\n                if ((result.value as any).skipped) {\n                  continue;\n                }\n\n                const { index: finishedIndex, itemResult } = result.value as any;\n                processedCount++;\n\n                if (itemResult.issues) {\n                  allIssues.push(...itemResult.issues);\n                }\n\n                const resultWithOutput = itemResult as ReviewSummary & {\n                  output?: unknown;\n                  content?: string;\n                };\n\n                allOutputs[finishedIndex] = resultWithOutput.output;\n\n                const itemContent = resultWithOutput.content;\n                if (typeof itemContent === 'string' && itemContent.trim()) {\n                  aggregatedContents.push(itemContent.trim());\n                } else {\n                  const outStr =\n                    typeof resultWithOutput.output === 'string'\n                      ? (resultWithOutput.output as string).trim()\n                      : '';\n                  if (outStr) aggregatedContents.push(outStr);\n                }\n              }\n\n              // If no items were processed (all gated), mark this check as skipped for dependency_failed\n              if (processedCount === 0) {\n                this.recordSkip(checkName, 'dependency_failed');\n                logger.info(`⏭  Skipped (dependency failed for all items)`);\n                return {\n                  checkName,\n                  error: null,\n                  result: { issues: [] },\n                  skipped: true,\n                };\n              }\n\n              const finalOutput = allOutputs.length > 0 ? allOutputs : undefined;\n\n              finalResult = {\n                issues: allIssues,\n                ...(finalOutput !== undefined ? { output: finalOutput } : {}),\n              } as ExtendedReviewSummary;\n\n              // Mark this result as forEach-capable and attach per-item results for precise downstream gating\n              (finalResult as ExtendedReviewSummary).isForEach = true;\n              (finalResult as ExtendedReviewSummary).forEachItems = allOutputs;\n              (finalResult as ExtendedReviewSummary).forEachItemResults =\n                perItemResults as ReviewSummary[];\n              // Compute fatal mask\n              try {\n                const mask: boolean[] = (finalResult as ExtendedReviewSummary).forEachItemResults\n                  ? await Promise.all(\n                      Array.from({ length: forEachItems.length }, async (_, idx) => {\n                        const r = (finalResult as ExtendedReviewSummary).forEachItemResults![idx];\n                        if (!r) return false; // no result (skipped) → not fatal for descendants\n                        let hadFatal = this.hasFatal(r.issues || []);\n                        try {\n                          const ids = (r.issues || []).map(i => i.ruleId).join(',');\n                          logger.debug(\n                            `  forEach: item ${idx + 1}/${forEachItems.length} issues=${(r.issues || []).length} ids=[${ids}]`\n                          );\n                        } catch {}\n                        if (!hadFatal && config && (config.fail_if || checkConfig.fail_if)) {\n                          try {\n                            const failures = await this.evaluateFailureConditions(\n                              checkName,\n                              r,\n                              config,\n                              prInfo,\n                              results\n                            );\n                            hadFatal = failures.some(f => f.failed);\n                          } catch {}\n                        }\n                        return hadFatal;\n                      })\n                    )\n                  : [];\n                (finalResult as ExtendedReviewSummary).forEachFatalMask = mask;\n                logger.debug(\n                  `  forEach: mask for \"${checkName}\" → fatals=${mask.filter(Boolean).length}/${mask.length}`\n                );\n              } catch {}\n\n              if (aggregatedContents.length > 0) {\n                (finalResult as ReviewSummary & { content?: string }).content =\n                  aggregatedContents.join('\\n');\n              }\n\n              // Finalize inline descendant aggregations to full results, so later levels skip them\n              for (const [childName, agg] of inlineAgg.entries()) {\n                const childCfg = config.checks![childName];\n                const childEnrichedIssues = (agg.issues || []).map(issue => ({\n                  ...issue,\n                  checkName: childName,\n                  ruleId: `${childName}/${issue.ruleId}`,\n                  group: childCfg.group,\n                  schema: typeof childCfg.schema === 'object' ? 'custom' : childCfg.schema,\n                  template: childCfg.template,\n                  timestamp: Date.now(),\n                }));\n                const childFinal: ExtendedReviewSummary = {\n                  issues: childEnrichedIssues,\n                  ...(agg.outputs.length > 0 ? { output: agg.outputs } : {}),\n                  isForEach: true,\n                  forEachItems: agg.outputs,\n                  forEachItemResults: agg.perItemResults,\n                  ...(agg.contents.length > 0 ? { content: agg.contents.join('\\n') } : {}),\n                };\n                // Compute fatal mask for child aggregate\n                try {\n                  const mask: boolean[] = Array.from(\n                    { length: agg.perItemResults.length },\n                    (_, idx) => {\n                      const r = agg.perItemResults[idx];\n                      if (!r) return false; // skipped item is not fatal for descendants\n                      const hadFatal = (r.issues || []).some(issue => {\n                        const id = issue.ruleId || '';\n                        return (\n                          issue.severity === 'error' ||\n                          issue.severity === 'critical' ||\n                          id === 'command/execution_error' ||\n                          id.endsWith('/command/execution_error') ||\n                          id === 'command/timeout' ||\n                          id.endsWith('/command/timeout') ||\n                          id === 'command/transform_js_error' ||\n                          id.endsWith('/command/transform_js_error') ||\n                          id === 'command/transform_error' ||\n                          id.endsWith('/command/transform_error') ||\n                          id.endsWith('/forEach/iteration_error') ||\n                          id === 'forEach/undefined_output' ||\n                          id.endsWith('/forEach/undefined_output') ||\n                          id.endsWith('_fail_if') ||\n                          id.endsWith('/global_fail_if')\n                        );\n                      });\n                      return hadFatal;\n                    }\n                  );\n                  childFinal.forEachFatalMask = mask;\n                } catch {}\n                results.set(childName, childFinal);\n              }\n\n              if (\n                debug &&\n                process.env.VISOR_OUTPUT_FORMAT !== 'json' &&\n                process.env.VISOR_OUTPUT_FORMAT !== 'sarif'\n              ) {\n                console.log(\n                  `🔄 Debug: Completed forEach execution for check \"${checkName}\", total issues: ${allIssues.length}`\n                );\n              }\n            } // End of else block for forEachItems.length > 0\n          } else {\n            // Normal single execution\n            // Evaluate if condition for non-forEach-dependent checks\n            if (checkConfig.if) {\n              const shouldRun = await this.evaluateCheckCondition(\n                checkName,\n                checkConfig.if,\n                prInfo,\n                results,\n                debug\n              );\n\n              if (!shouldRun) {\n                // Record skip with condition\n                this.recordSkip(checkName, 'if_condition', checkConfig.if);\n                logger.info(`⏭  Skipped (if: ${this.truncate(checkConfig.if, 40)})`);\n                return {\n                  checkName,\n                  error: null,\n                  result: {\n                    issues: [],\n                  },\n                  skipped: true,\n                };\n              }\n            }\n\n            // Execute with retry/routing semantics\n            finalResult = await this.executeWithRouting(\n              checkName,\n              checkConfig,\n              provider,\n              providerConfig,\n              prInfo,\n              dependencyResults,\n              sessionInfo,\n              config,\n              dependencyGraph,\n              debug,\n              results\n            );\n            try {\n              emitNdjsonSpanWithEvents('visor.check', { 'visor.check.id': checkName }, [\n                { name: 'check.started' },\n                { name: 'check.completed' },\n              ]);\n            } catch {}\n\n            // Evaluate fail_if for normal (non-forEach) execution\n            if (config && (config.fail_if || checkConfig.fail_if)) {\n              const failureResults = await this.evaluateFailureConditions(\n                checkName,\n                finalResult,\n                config,\n                prInfo,\n                results\n              );\n              if (failureResults.length > 0) {\n                const failureIssues = failureResults\n                  .filter(f => f.failed)\n                  .map(f => ({\n                    file: 'system',\n                    line: 0,\n                    ruleId: f.conditionName,\n                    message: f.message || `Failure condition met: ${f.expression}`,\n                    severity: (f.severity || 'error') as 'info' | 'warning' | 'error' | 'critical',\n                    category: 'logic' as const,\n                  }));\n                finalResult.issues = [...(finalResult.issues || []), ...failureIssues];\n              }\n            }\n\n            // Record normal (non-forEach) execution\n            // Check if this check had fatal errors\n            const hadFatalError = (finalResult.issues || []).some(issue => {\n              const id = issue.ruleId || '';\n              return (\n                id === 'command/execution_error' ||\n                id.endsWith('/command/execution_error') ||\n                id === 'command/timeout' ||\n                id.endsWith('/command/timeout') ||\n                id === 'command/transform_js_error' ||\n                id.endsWith('/command/transform_js_error') ||\n                id === 'command/transform_error' ||\n                id.endsWith('/command/transform_error') ||\n                id === 'forEach/undefined_output' ||\n                id.endsWith('/forEach/undefined_output')\n              );\n            });\n            this.recordIterationComplete(\n              checkName,\n              checkStartTime,\n              !hadFatalError, // Success if no fatal errors\n              finalResult.issues || [],\n              (finalResult as any).output\n            );\n\n            if (checkConfig.forEach) {\n              try {\n                const finalResultWithOutput = finalResult as ExtendedReviewSummary;\n                const outputPreview =\n                  JSON.stringify(finalResultWithOutput.output)?.slice(0, 200) || '(empty)';\n                logger.debug(`🔧 Debug: Check \"${checkName}\" provider returned: ${outputPreview}`);\n              } catch {\n                // Ignore logging errors\n              }\n            }\n\n            if (debug) {\n              log(\n                `🔧 Debug: Completed check: ${checkName}, issues found: ${(finalResult.issues || []).length}`\n              );\n            }\n\n            // Track cloned session IDs for cleanup\n            if (finalResult.sessionId) {\n              sessionIds.set(checkName, finalResult.sessionId);\n              if (debug) {\n                log(`🔧 Debug: Tracked cloned session for cleanup: ${finalResult.sessionId}`);\n              }\n            }\n          }\n\n          // Add checkName, group, schema, template info and timestamp to issues from config\n          const enrichedIssues = (finalResult.issues || []).map(issue => ({\n            ...issue,\n            checkName: checkName,\n            ruleId: `${checkName}/${issue.ruleId}`,\n            group: checkConfig.group,\n            schema: typeof checkConfig.schema === 'object' ? 'custom' : checkConfig.schema,\n            template: checkConfig.template,\n            timestamp: Date.now(),\n          }));\n\n          const enrichedResult = {\n            ...finalResult,\n            issues: enrichedIssues,\n          };\n\n          const checkDuration = ((Date.now() - checkStartTime) / 1000).toFixed(1);\n          const issueCount = enrichedIssues.length;\n          const checkStats = this.executionStats.get(checkName);\n\n          // Enhanced completion message with forEach stats\n          if (checkStats && checkStats.totalRuns > 1) {\n            if (issueCount > 0) {\n              logger.success(\n                `Check complete: ${checkName} (${checkDuration}s) - ${checkStats.totalRuns} runs, ${issueCount} issue${issueCount === 1 ? '' : 's'}`\n              );\n            } else {\n              logger.success(\n                `Check complete: ${checkName} (${checkDuration}s) - ${checkStats.totalRuns} runs`\n              );\n            }\n          } else if (checkStats && checkStats.outputsProduced && checkStats.outputsProduced > 0) {\n            logger.success(\n              `Check complete: ${checkName} (${checkDuration}s) - ${checkStats.outputsProduced} items`\n            );\n          } else if (issueCount > 0) {\n            logger.success(\n              `Check complete: ${checkName} (${checkDuration}s) - ${issueCount} issue${issueCount === 1 ? '' : 's'} found`\n            );\n          } else {\n            logger.success(`Check complete: ${checkName} (${checkDuration}s)`);\n          }\n\n          return {\n            checkName,\n            error: null,\n            result: enrichedResult,\n          };\n        } catch (error) {\n          const errorMessage =\n            error instanceof Error ? `${error.message}\\n${error.stack || ''}` : String(error);\n          const checkDuration = ((Date.now() - checkStartTime) / 1000).toFixed(1);\n\n          // Record error in stats\n          this.recordError(checkName, error instanceof Error ? error : new Error(String(error)));\n          this.recordIterationComplete(checkName, checkStartTime, false, [], undefined);\n\n          logger.error(`✖ Check failed: ${checkName} (${checkDuration}s) - ${errorMessage}`);\n\n          if (debug) {\n            log(`🔧 Debug: Error in check ${checkName}: ${errorMessage}`);\n          }\n\n          return {\n            checkName,\n            error: errorMessage,\n            result: null,\n          };\n        }\n      });\n\n      // Execute checks in this level with controlled parallelism\n      const levelResults = await this.executeWithLimitedParallelism(\n        levelTaskFunctions,\n        actualParallelism,\n        effectiveFailFast\n      );\n\n      // Process results and store them for next level\n      const levelChecksList = executionGroup.parallel.filter(name => !results.has(name));\n      for (let i = 0; i < levelResults.length; i++) {\n        const checkName = levelChecksList[i];\n        const result = levelResults[i];\n        const checkConfig = config.checks![checkName];\n\n        if (result.status === 'fulfilled' && result.value.result && !result.value.error) {\n          // For skipped checks, store a marker so dependent checks can detect the skip\n          if ((result.value as any).skipped) {\n            if (debug) {\n              log(`🔧 Debug: Storing skip marker for skipped check \"${checkName}\"`);\n            }\n            // Store a special marker result with a skip issue so dependencies can detect it\n            results.set(checkName, {\n              issues: [\n                {\n                  ruleId: `${checkName}/__skipped`,\n                  severity: 'info',\n                  category: 'logic',\n                  message: 'Check was skipped',\n                  file: '',\n                  line: 0,\n                },\n              ],\n            });\n            continue;\n          }\n\n          const reviewResult = result.value.result;\n\n          // Handle forEach logic - process array outputs\n          const reviewSummaryWithOutput = reviewResult as ExtendedReviewSummary;\n\n          if (checkConfig?.forEach && (!reviewResult.issues || reviewResult.issues.length === 0)) {\n            const validation = this.validateAndNormalizeForEachOutput(\n              checkName,\n              reviewSummaryWithOutput.output,\n              checkConfig.group\n            );\n\n            if (!validation.isValid) {\n              results.set(\n                checkName,\n                validation.error.issues ? { issues: validation.error.issues } : {}\n              );\n              continue;\n            }\n\n            const normalizedOutput = validation.normalizedOutput;\n\n            logger.debug(\n              `🔧 Debug: Raw output for forEach check ${checkName}: ${\n                Array.isArray(reviewSummaryWithOutput.output)\n                  ? `array(${reviewSummaryWithOutput.output.length})`\n                  : typeof reviewSummaryWithOutput.output\n              }`\n            );\n\n            try {\n              const preview = JSON.stringify(normalizedOutput);\n              logger.debug(\n                `🔧 Debug: Check \"${checkName}\" forEach output: ${preview?.slice(0, 200) || '(empty)'}`\n              );\n            } catch {\n              // Ignore logging errors\n            }\n\n            // Store the array for iteration by dependent checks\n            reviewSummaryWithOutput.forEachItems = normalizedOutput;\n            reviewSummaryWithOutput.isForEach = true;\n            try {\n              const st = this.executionStats.get(checkName);\n              if (st) st.outputsProduced = normalizedOutput.length;\n            } catch {}\n          }\n\n          try {\n            emitNdjsonSpanWithEvents('visor.check', { 'visor.check.id': checkName }, [\n              { name: 'check.started' },\n              { name: 'check.completed' },\n            ]);\n          } catch {}\n\n          // Track output history for loop/goto scenarios\n          const reviewResultWithOutput = reviewResult as ReviewSummary & { output?: unknown };\n          if (reviewResultWithOutput.output !== undefined) {\n            this.trackOutputHistory(checkName, reviewResultWithOutput.output);\n          }\n\n          results.set(checkName, reviewResult);\n          // Phase 4: commit aggregate and per-item entries for forEach checks; else single aggregate\n          const agg = reviewResult as ExtendedReviewSummary;\n          if (\n            checkConfig?.forEach &&\n            (Array.isArray(agg.forEachItems) || Array.isArray((agg as any).output))\n          ) {\n            // Commit aggregate at root scope\n            this.commitJournal(checkName, agg, prInfo.eventType, []);\n            const items: unknown[] = Array.isArray(agg.forEachItems)\n              ? (agg.forEachItems as unknown[])\n              : Array.isArray((agg as any).output)\n                ? ((agg as any).output as unknown[])\n                : [];\n            for (let i = 0; i < items.length; i++) {\n              const item = items[i];\n              try {\n                this.commitJournal(\n                  checkName,\n                  { issues: [], output: item } as ExtendedReviewSummary,\n                  prInfo.eventType,\n                  [{ check: checkName, index: i }]\n                );\n              } catch {}\n            }\n          } else {\n            this.commitJournal(checkName, reviewResult as ExtendedReviewSummary, prInfo.eventType);\n          }\n        } else {\n          // Store error result for dependency tracking\n          const errorSummary: ReviewSummary = {\n            issues: [\n              {\n                file: 'system',\n                line: 0,\n                endLine: undefined,\n                ruleId: `${checkName}/error`,\n                message:\n                  result.status === 'fulfilled'\n                    ? result.value.error || 'Unknown error'\n                    : result.reason instanceof Error\n                      ? result.reason.message\n                      : String(result.reason),\n                severity: 'error',\n                category: 'logic',\n                suggestion: undefined,\n                replacement: undefined,\n              },\n            ],\n          };\n          results.set(checkName, errorSummary);\n          // Phase 0: commit to journal (with event scoping)\n          this.commitJournal(checkName, errorSummary as ExtendedReviewSummary, prInfo.eventType);\n\n          // Check if we should stop execution due to fail-fast\n          if (effectiveFailFast) {\n            if (debug) {\n              log(`🛑 Check \"${checkName}\" failed and fail-fast is enabled - stopping execution`);\n            }\n            shouldStopExecution = true;\n            break;\n          }\n        }\n      }\n\n      // If fail-fast is enabled, check if any successful checks have failure conditions\n      if (effectiveFailFast && !shouldStopExecution) {\n        for (let i = 0; i < levelResults.length; i++) {\n          const checkName = executionGroup.parallel[i];\n          const result = levelResults[i];\n\n          if (result.status === 'fulfilled' && result.value.result && !result.value.error) {\n            // Check for issues that should trigger fail-fast\n            const hasFailuresToReport = (result.value.result.issues || []).some(\n              issue => issue.severity === 'error' || issue.severity === 'critical'\n            );\n\n            if (hasFailuresToReport) {\n              if (debug) {\n                log(\n                  `🛑 Check \"${checkName}\" found critical/high issues and fail-fast is enabled - stopping execution`\n                );\n              }\n              shouldStopExecution = true;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    if (debug) {\n      if (shouldStopExecution) {\n        log(\n          `🛑 Execution stopped early due to fail-fast after processing ${results.size} of ${checks.length} checks`\n        );\n      } else {\n        log(`✅ Dependency-aware execution completed successfully for all ${results.size} checks`);\n      }\n    }\n\n    // Handle on_finish hooks for forEach checks after ALL dependents complete\n    if (!shouldStopExecution) {\n      await this.handleOnFinishHooks(config, dependencyGraph, results, prInfo, debug || false);\n    }\n\n    // Cleanup sessions BEFORE printing summary to avoid mixing debug logs with table output\n    if (sessionIds.size > 0 && debug) {\n      log(`🧹 Cleaning up ${sessionIds.size} AI sessions...`);\n      for (const [checkName, sessionId] of sessionIds) {\n        try {\n          sessionRegistry.unregisterSession(sessionId);\n          log(`🗑️ Cleaned up session for check ${checkName}: ${sessionId}`);\n        } catch (error) {\n          log(`⚠️ Failed to cleanup session for check ${checkName}: ${error}`);\n        }\n      }\n    }\n\n    // Build and log final execution summary\n    const executionStatistics = this.buildExecutionStatistics();\n\n    // Show detailed summary table (only if logFn outputs to console)\n    // Skip when output format is JSON/SARIF to avoid polluting structured output\n    // Check if logFn is console.log (not a no-op or console.error)\n    if (logFn === console.log) {\n      this.logExecutionSummary(executionStatistics);\n    }\n\n    // Add warning if execution stopped early\n    if (shouldStopExecution) {\n      logger.info('');\n      logger.warn(`⚠️  Execution stopped early due to fail-fast`);\n    }\n\n    // Aggregate all results\n    return this.aggregateDependencyAwareResults(\n      results,\n      dependencyGraph,\n      debug,\n      shouldStopExecution\n    );\n  }\n\n  /**\n   * Execute multiple checks in parallel using controlled parallelism (legacy method)\n   */\n  private async executeParallelChecks(\n    prInfo: PRInfo,\n    checks: string[],\n    timeout?: number,\n    config?: import('./types/config').VisorConfig,\n    logFn?: (message: string) => void,\n    debug?: boolean,\n    maxParallelism?: number,\n    failFast?: boolean\n  ): Promise<ReviewSummary> {\n    const log = logFn || console.error;\n    log(`🔧 Debug: Starting parallel execution of ${checks.length} checks`);\n\n    if (!config?.checks) {\n      throw new Error('Config with check definitions required for parallel execution');\n    }\n\n    // Determine effective max parallelism (CLI > config > default)\n    const effectiveMaxParallelism = maxParallelism ?? config.max_parallelism ?? 3;\n    // Determine effective fail-fast setting (CLI > config > default)\n    const effectiveFailFast = failFast ?? config.fail_fast ?? false;\n    log(`🔧 Debug: Using max parallelism: ${effectiveMaxParallelism}`);\n    log(`🔧 Debug: Using fail-fast: ${effectiveFailFast}`);\n\n    const provider = this.providerRegistry.getProviderOrThrow('ai');\n    this.setProviderWebhookContext(provider);\n\n    // Create individual check task functions\n    const checkTaskFunctions = checks.map(checkName => async () => {\n      const checkConfig = config.checks![checkName];\n      if (!checkConfig) {\n        log(`🔧 Debug: No config found for check: ${checkName}`);\n        return {\n          checkName,\n          error: `No configuration found for check: ${checkName}`,\n          result: null,\n        };\n      }\n\n      try {\n        console.error(\n          `🔧 Debug: Starting check: ${checkName} with prompt type: ${typeof checkConfig.prompt}`\n        );\n\n        // Evaluate if condition to determine whether to run this check\n        if (checkConfig.if) {\n          // Evaluate if condition using any routing override event (e.g., goto_event)\n          const override = this.routingEventOverride;\n          const eventName = override\n            ? override.startsWith('pr_')\n              ? 'pull_request'\n              : override === 'issue_comment'\n                ? 'issue_comment'\n                : override.startsWith('issue_')\n                  ? 'issues'\n                  : 'manual'\n            : 'issue_comment';\n          const commenterAssoc = resolveAssociationFromEvent(\n            prInfo.eventContext,\n            prInfo.authorAssociation\n          );\n          const shouldRun = await this.failureEvaluator.evaluateIfCondition(\n            checkName,\n            checkConfig.if,\n            {\n              branch: prInfo.head,\n              baseBranch: prInfo.base,\n              filesChanged: prInfo.files.map(f => f.filename),\n              event: eventName, // honor routing override if present\n              environment: getSafeEnvironmentVariables(),\n              previousResults: new Map(), // No previous results in parallel execution\n              authorAssociation: commenterAssoc,\n            }\n          );\n\n          if (!shouldRun) {\n            console.error(\n              `🔧 Debug: Skipping check '${checkName}' - if condition evaluated to false`\n            );\n            return {\n              checkName,\n              error: null,\n              result: {\n                issues: [],\n              },\n            };\n          }\n        }\n\n        // Create provider config for this specific check\n        const providerConfig: CheckProviderConfig = {\n          type: 'ai',\n          prompt: checkConfig.prompt,\n          focus: checkConfig.focus || this.mapCheckNameToFocus(checkName),\n          schema: checkConfig.schema,\n          group: checkConfig.group,\n          eventContext: this.enrichEventContext(prInfo.eventContext),\n          ai: {\n            timeout: timeout || 600000,\n            debug: debug, // Pass debug flag to AI provider\n            ...(checkConfig.ai || {}),\n          },\n        };\n\n        const result = await provider.execute(prInfo, providerConfig);\n        console.error(\n          `🔧 Debug: Completed check: ${checkName}, issues found: ${(result.issues || []).length}`\n        );\n\n        // Add group, schema info and timestamp to issues from config\n        const enrichedIssues = (result.issues || []).map(issue => ({\n          ...issue,\n          ruleId: `${checkName}/${issue.ruleId}`,\n          group: checkConfig.group,\n          schema: typeof checkConfig.schema === 'object' ? 'custom' : checkConfig.schema,\n          template: checkConfig.template,\n          timestamp: Date.now(),\n        }));\n\n        const enrichedResult = {\n          ...result,\n          issues: enrichedIssues,\n        };\n\n        return {\n          checkName,\n          error: null,\n          result: enrichedResult,\n        };\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        log(`🔧 Debug: Error in check ${checkName}: ${errorMessage}`);\n\n        return {\n          checkName,\n          error: errorMessage,\n          result: null,\n        };\n      }\n    });\n\n    // Execute all checks with controlled parallelism\n    log(\n      `🔧 Debug: Executing ${checkTaskFunctions.length} checks with max parallelism: ${effectiveMaxParallelism}`\n    );\n    const results = await this.executeWithLimitedParallelism(\n      checkTaskFunctions,\n      effectiveMaxParallelism,\n      effectiveFailFast\n    );\n\n    // Check if execution was stopped early\n    const completedChecks = results.filter(\n      r => r.status === 'fulfilled' || r.status === 'rejected'\n    ).length;\n    const stoppedEarly = completedChecks < checks.length;\n\n    if (stoppedEarly && effectiveFailFast) {\n      log(\n        `🛑 Parallel execution stopped early due to fail-fast after processing ${completedChecks} of ${checks.length} checks`\n      );\n    } else {\n      log(`✅ Parallel execution completed for all ${completedChecks} checks`);\n    }\n\n    // Aggregate results from all checks\n    return this.aggregateParallelResults(results, checks, debug, stoppedEarly);\n  }\n\n  /**\n   * Execute a single configured check\n   */\n  private async executeSingleConfiguredCheck(\n    prInfo: PRInfo,\n    checkName: string,\n    timeout?: number,\n    config?: import('./types/config').VisorConfig,\n    _logFn?: (message: string) => void\n  ): Promise<ReviewSummary> {\n    if (!config?.checks?.[checkName]) {\n      throw new Error(`No configuration found for check: ${checkName}`);\n    }\n\n    const checkConfig = config.checks![checkName];\n    const provider = this.providerRegistry.getProviderOrThrow('ai');\n    this.setProviderWebhookContext(provider);\n\n    const providerConfig: CheckProviderConfig = {\n      type: 'ai',\n      prompt: checkConfig.prompt,\n      focus: checkConfig.focus || this.mapCheckNameToFocus(checkName),\n      schema: checkConfig.schema,\n      group: checkConfig.group,\n      eventContext: this.enrichEventContext(prInfo.eventContext),\n      ai: {\n        timeout: timeout || 600000,\n        ...(checkConfig.ai || {}),\n      },\n      // Inherit global AI provider and model settings\n      ai_provider: checkConfig.ai_provider || config.ai_provider,\n      ai_model: checkConfig.ai_model || config.ai_model,\n    };\n\n    const result = await provider.execute(prInfo, providerConfig);\n\n    // Prefix issues with check name and add group/schema info and timestamp from config\n    const prefixedIssues = (result.issues || []).map(issue => ({\n      ...issue,\n      ruleId: `${checkName}/${issue.ruleId}`,\n      group: checkConfig.group,\n      schema: typeof checkConfig.schema === 'object' ? 'custom' : checkConfig.schema,\n      timestamp: Date.now(),\n    }));\n\n    return {\n      ...result,\n      issues: prefixedIssues,\n    };\n  }\n\n  /**\n   * Map check name to focus for AI provider\n   * This is a fallback when focus is not explicitly configured\n   */\n  private mapCheckNameToFocus(checkName: string): string {\n    const focusMap: Record<string, string> = {\n      security: 'security',\n      performance: 'performance',\n      style: 'style',\n      architecture: 'architecture',\n    };\n\n    return focusMap[checkName] || 'all';\n  }\n\n  /**\n   * Aggregate results from dependency-aware check execution\n   */\n  private aggregateDependencyAwareResults(\n    results: Map<string, ReviewSummary>,\n    dependencyGraph: DependencyGraph,\n    debug?: boolean,\n    stoppedEarly?: boolean\n  ): ReviewSummary {\n    const aggregatedIssues: ReviewSummary['issues'] = [];\n    const debugInfo: string[] = [];\n    const contentMap: Record<string, string> = {};\n    const outputsMap: Record<string, unknown> = {};\n\n    // Add execution plan info\n    const stats = DependencyResolver.getExecutionStats(dependencyGraph);\n    const executionInfo = [\n      stoppedEarly\n        ? `🛑 Dependency-aware execution stopped early (fail-fast):`\n        : `🔍 Dependency-aware execution completed:`,\n      `  - ${results.size} of ${stats.totalChecks} checks processed`,\n      `  - Execution levels: ${stats.parallelLevels}`,\n      `  - Maximum parallelism: ${stats.maxParallelism}`,\n      `  - Average parallelism: ${stats.averageParallelism.toFixed(1)}`,\n      `  - Checks with dependencies: ${stats.checksWithDependencies}`,\n      stoppedEarly ? `  - Stopped early due to fail-fast behavior` : ``,\n    ].filter(Boolean);\n\n    debugInfo.push(...executionInfo);\n\n    // Track which checks we've aggregated already\n    const processed = new Set<string>();\n\n    // Process results in dependency order for better output organization\n    for (const executionGroup of dependencyGraph.executionOrder) {\n      for (const checkName of executionGroup.parallel) {\n        const result = results.get(checkName);\n\n        if (!result) {\n          debugInfo.push(`❌ Check \"${checkName}\" had no result`);\n          continue;\n        }\n\n        // Check if this was a successful result\n        const hasErrors = (result.issues || []).some(\n          issue => issue.ruleId?.includes('/error') || issue.ruleId?.includes('/promise-error')\n        );\n\n        if (hasErrors) {\n          debugInfo.push(`❌ Check \"${checkName}\" failed with errors`);\n        } else {\n          debugInfo.push(\n            `✅ Check \"${checkName}\" completed: ${(result.issues || []).length} issues found (level ${executionGroup.level})`\n          );\n        }\n\n        // Mark as processed\n        processed.add(checkName);\n\n        // Issues are already prefixed and enriched with group/schema info\n        // Filter out internal __skipped markers\n        const nonInternalIssues = (result.issues || []).filter(\n          issue => !issue.ruleId?.endsWith('/__skipped')\n        );\n        aggregatedIssues.push(...nonInternalIssues);\n\n        const resultSummary = result as ExtendedReviewSummary & { output?: unknown };\n        const resultContent = resultSummary.content;\n        if (typeof resultContent === 'string' && resultContent.trim()) {\n          contentMap[checkName] = resultContent.trim();\n        }\n        if (resultSummary.output !== undefined) {\n          outputsMap[checkName] = resultSummary.output;\n        }\n      }\n    }\n\n    // Include any additional results that were produced at runtime (e.g., forward-run via goto)\n    // but were not part of the original execution DAG for the selected checks.\n    for (const [checkName, result] of results.entries()) {\n      if (processed.has(checkName)) continue;\n      if (!result) continue;\n\n      // Issues (already enriched)\n      const nonInternalIssues = (result.issues || []).filter(\n        issue => !issue.ruleId?.endsWith('/__skipped')\n      );\n      aggregatedIssues.push(...nonInternalIssues);\n\n      const resultSummary = result as ExtendedReviewSummary & { output?: unknown };\n      const resultContent = (resultSummary as { content?: string }).content;\n      if (typeof resultContent === 'string' && resultContent.trim()) {\n        contentMap[checkName] = resultContent.trim();\n      }\n      if (resultSummary.output !== undefined) {\n        outputsMap[checkName] = resultSummary.output;\n      }\n\n      debugInfo.push(\n        `✅ (dynamic) Check \"${checkName}\" included: ${(result.issues || []).length} issues found`\n      );\n    }\n\n    if (debug) {\n      console.error(\n        `🔧 Debug: Aggregated ${aggregatedIssues.length} issues from ${results.size} dependency-aware checks`\n      );\n    }\n\n    // Apply issue suppression filtering\n    const suppressionEnabled = this.config?.output?.suppressionEnabled !== false;\n    const issueFilter = new IssueFilter(suppressionEnabled);\n    const filteredIssues = issueFilter.filterIssues(aggregatedIssues, this.workingDirectory);\n\n    // Collect debug information when debug mode is enabled\n    let aggregatedDebug: import('./ai-review-service').AIDebugInfo | undefined;\n    if (debug) {\n      const debugResults = Array.from(results.entries()).filter(([_, result]) => result.debug);\n\n      if (debugResults.length > 0) {\n        const [, firstResult] = debugResults[0];\n        const firstDebug = firstResult.debug!;\n\n        const totalProcessingTime = debugResults.reduce((sum, [_, result]) => {\n          return sum + (result.debug!.processingTime || 0);\n        }, 0);\n\n        aggregatedDebug = {\n          provider: firstDebug.provider,\n          model: firstDebug.model,\n          apiKeySource: firstDebug.apiKeySource,\n          processingTime: totalProcessingTime,\n          prompt: debugResults\n            .map(([checkName, result]) => `[${checkName}]\\n${result.debug!.prompt}`)\n            .join('\\n\\n'),\n          rawResponse: debugResults\n            .map(([checkName, result]) => `[${checkName}]\\n${result.debug!.rawResponse}`)\n            .join('\\n\\n'),\n          promptLength: debugResults.reduce(\n            (sum, [_, result]) => sum + (result.debug!.promptLength || 0),\n            0\n          ),\n          responseLength: debugResults.reduce(\n            (sum, [_, result]) => sum + (result.debug!.responseLength || 0),\n            0\n          ),\n          jsonParseSuccess: debugResults.every(([_, result]) => result.debug!.jsonParseSuccess),\n          errors: debugResults.flatMap(([checkName, result]) =>\n            (result.debug!.errors || []).map((error: string) => `[${checkName}] ${error}`)\n          ),\n          timestamp: new Date().toISOString(),\n          totalApiCalls: debugResults.length,\n          apiCallDetails: debugResults.map(([checkName, result]) => ({\n            checkName,\n            provider: result.debug!.provider,\n            model: result.debug!.model,\n            processingTime: result.debug!.processingTime,\n            success: result.debug!.jsonParseSuccess,\n          })),\n        };\n      }\n    }\n\n    const summary: ReviewSummary & {\n      __contents?: Record<string, string>;\n      __outputs?: Record<string, unknown>;\n      __executed?: string[];\n    } = {\n      issues: filteredIssues,\n      debug: aggregatedDebug,\n    };\n\n    if (Object.keys(contentMap).length > 0) {\n      summary.__contents = contentMap;\n    }\n    if (Object.keys(outputsMap).length > 0) {\n      summary.__outputs = outputsMap;\n    }\n\n    // Preserve the list of executed checks (keys in results Map) so downstream\n    // grouping/formatting can include dynamically routed children even when they\n    // produced neither issues nor output content (e.g., log-only steps).\n    summary.__executed = Array.from(results.keys());\n\n    return summary;\n  }\n\n  /**\n   * Aggregate results from parallel check execution (legacy method)\n   */\n  private aggregateParallelResults(\n    results: PromiseSettledResult<{\n      checkName: string;\n      error: string | null;\n      result: ReviewSummary | null;\n    }>[],\n    checkNames: string[],\n    debug?: boolean,\n    _stoppedEarly?: boolean\n  ): ReviewSummary {\n    const aggregatedIssues: ReviewSummary['issues'] = [];\n    const debugInfo: string[] = [];\n\n    results.forEach((result, index) => {\n      const checkName = checkNames[index];\n\n      if (result.status === 'fulfilled') {\n        const checkResult = result.value;\n\n        if (checkResult.error) {\n          logger.debug(`🔧 Debug: Check ${checkName} failed: ${checkResult.error}`);\n          debugInfo.push(`❌ Check \"${checkName}\" failed: ${checkResult.error}`);\n\n          // Check if this is a critical error\n          const isCriticalError =\n            checkResult.error.includes('API rate limit') ||\n            checkResult.error.includes('403') ||\n            checkResult.error.includes('401') ||\n            checkResult.error.includes('authentication') ||\n            checkResult.error.includes('API key');\n\n          // Add error as an issue with appropriate severity\n          aggregatedIssues.push({\n            file: 'system',\n            line: 0,\n            endLine: undefined,\n            ruleId: `${checkName}/error`,\n            message: `Check \"${checkName}\" failed: ${checkResult.error}`,\n            severity: isCriticalError ? 'critical' : 'error',\n            category: 'logic',\n            suggestion: isCriticalError\n              ? 'Please check your API credentials and rate limits'\n              : undefined,\n            replacement: undefined,\n          });\n        } else if (checkResult.result) {\n          logger.debug(\n            `🔧 Debug: Check ${checkName} succeeded with ${(checkResult.result.issues || []).length} issues`\n          );\n          debugInfo.push(\n            `✅ Check \"${checkName}\" completed: ${(checkResult.result.issues || []).length} issues found`\n          );\n\n          // Issues are already prefixed and enriched with group/schema info\n          aggregatedIssues.push(...(checkResult.result.issues || []));\n        }\n      } else {\n        const errorMessage =\n          result.reason instanceof Error ? result.reason.message : String(result.reason);\n        logger.debug(`🔧 Debug: Check ${checkName} promise rejected: ${errorMessage}`);\n        debugInfo.push(`❌ Check \"${checkName}\" promise rejected: ${errorMessage}`);\n\n        // Check if this is a critical error\n        const isCriticalError =\n          errorMessage.includes('API rate limit') ||\n          errorMessage.includes('403') ||\n          errorMessage.includes('401') ||\n          errorMessage.includes('authentication') ||\n          errorMessage.includes('API key');\n\n        aggregatedIssues.push({\n          file: 'system',\n          line: 0,\n          endLine: undefined,\n          ruleId: `${checkName}/promise-error`,\n          message: `Check \"${checkName}\" execution failed: ${errorMessage}`,\n          severity: isCriticalError ? 'critical' : 'error',\n          category: 'logic',\n          suggestion: isCriticalError\n            ? 'Please check your API credentials and rate limits'\n            : undefined,\n          replacement: undefined,\n        });\n      }\n    });\n\n    if (debug) {\n      console.error(\n        `🔧 Debug: Aggregated ${aggregatedIssues.length} issues from ${results.length} checks`\n      );\n    }\n\n    // Apply issue suppression filtering\n    const suppressionEnabled = this.config?.output?.suppressionEnabled !== false;\n    const issueFilter = new IssueFilter(suppressionEnabled);\n    const filteredIssues = issueFilter.filterIssues(aggregatedIssues, this.workingDirectory);\n\n    // Collect debug information when debug mode is enabled\n    let aggregatedDebug: import('./ai-review-service').AIDebugInfo | undefined;\n    if (debug) {\n      // Find the first successful result with debug information to use as template\n      const debugResults = results\n        .map((result, index) => ({\n          result,\n          checkName: checkNames[index],\n        }))\n        .filter(({ result }) => result.status === 'fulfilled' && result.value?.result?.debug);\n\n      if (debugResults.length > 0) {\n        const firstResult = debugResults[0].result;\n        if (firstResult.status === 'fulfilled') {\n          const firstDebug = firstResult.value!.result!.debug!;\n          const totalProcessingTime = debugResults.reduce((sum, { result }) => {\n            if (result.status === 'fulfilled') {\n              return sum + (result.value!.result!.debug!.processingTime || 0);\n            }\n            return sum;\n          }, 0);\n\n          aggregatedDebug = {\n            // Use first result as template for provider/model info\n            provider: firstDebug.provider,\n            model: firstDebug.model,\n            apiKeySource: firstDebug.apiKeySource,\n            // Aggregate processing time from all checks\n            processingTime: totalProcessingTime,\n            // Combine prompts with check names\n            prompt: debugResults\n              .map(({ checkName, result }) => {\n                if (result.status === 'fulfilled') {\n                  return `[${checkName}]\\n${result.value!.result!.debug!.prompt}`;\n                }\n                return `[${checkName}] Error: Promise was rejected`;\n              })\n              .join('\\n\\n'),\n            // Combine responses\n            rawResponse: debugResults\n              .map(({ checkName, result }) => {\n                if (result.status === 'fulfilled') {\n                  return `[${checkName}]\\n${result.value!.result!.debug!.rawResponse}`;\n                }\n                return `[${checkName}] Error: Promise was rejected`;\n              })\n              .join('\\n\\n'),\n            promptLength: debugResults.reduce((sum, { result }) => {\n              if (result.status === 'fulfilled') {\n                return sum + (result.value!.result!.debug!.promptLength || 0);\n              }\n              return sum;\n            }, 0),\n            responseLength: debugResults.reduce((sum, { result }) => {\n              if (result.status === 'fulfilled') {\n                return sum + (result.value!.result!.debug!.responseLength || 0);\n              }\n              return sum;\n            }, 0),\n            jsonParseSuccess: debugResults.every(({ result }) => {\n              if (result.status === 'fulfilled') {\n                return result.value!.result!.debug!.jsonParseSuccess;\n              }\n              return false;\n            }),\n            errors: debugResults.flatMap(({ result, checkName }) => {\n              if (result.status === 'fulfilled') {\n                return (result.value!.result!.debug!.errors || []).map(\n                  (error: string) => `[${checkName}] ${error}`\n                );\n              }\n              return [`[${checkName}] Promise was rejected`];\n            }),\n            timestamp: new Date().toISOString(),\n            // Add additional debug information for parallel execution\n            totalApiCalls: debugResults.length,\n            apiCallDetails: debugResults.map(({ checkName, result }) => {\n              if (result.status === 'fulfilled') {\n                return {\n                  checkName,\n                  provider: result.value!.result!.debug!.provider,\n                  model: result.value!.result!.debug!.model,\n                  processingTime: result.value!.result!.debug!.processingTime,\n                  success: result.value!.result!.debug!.jsonParseSuccess,\n                };\n              }\n              return {\n                checkName,\n                provider: 'unknown',\n                model: 'unknown',\n                processingTime: 0,\n                success: false,\n              };\n            }),\n          };\n        }\n      }\n    }\n\n    return {\n      issues: filteredIssues,\n      debug: aggregatedDebug,\n    };\n  }\n\n  /**\n   * Get available check types from providers\n   * Note: Check names are now config-driven. This returns provider types only.\n   */\n  static getAvailableCheckTypes(): string[] {\n    const registry = CheckProviderRegistry.getInstance();\n    return registry.getAvailableProviders();\n  }\n\n  /**\n   * Validate check types\n   */\n  static validateCheckTypes(checks: string[]): { valid: string[]; invalid: string[] } {\n    const availableChecks = CheckExecutionEngine.getAvailableCheckTypes();\n    const valid: string[] = [];\n    const invalid: string[] = [];\n\n    for (const check of checks) {\n      if (availableChecks.includes(check)) {\n        valid.push(check);\n      } else {\n        invalid.push(check);\n      }\n    }\n\n    return { valid, invalid };\n  }\n\n  /**\n   * List available providers with their status\n   */\n  async listProviders(): Promise<\n    Array<{\n      name: string;\n      description: string;\n      available: boolean;\n      requirements: string[];\n    }>\n  > {\n    return await this.providerRegistry.listProviders();\n  }\n\n  /**\n   * Create a mock Octokit instance for local analysis\n   */\n  private createMockOctokit(): MockOctokit {\n    // Create simple mock functions that return promises\n    const mockGet = async () => ({\n      data: {\n        number: 0,\n        title: 'Local Analysis',\n        body: 'Local repository analysis',\n        user: { login: 'local-user' },\n        base: { ref: 'main' },\n        head: { ref: 'HEAD' },\n      },\n    });\n\n    const mockListFiles = async () => ({\n      data: [],\n    });\n\n    const mockListComments = async () => ({\n      data: [],\n    });\n\n    const mockCreateComment = async () => ({\n      data: { id: 1 },\n    });\n\n    return {\n      rest: {\n        pulls: {\n          get: mockGet,\n          listFiles: mockListFiles,\n        },\n        issues: {\n          listComments: mockListComments,\n          createComment: mockCreateComment,\n        },\n      },\n      request: async () => ({ data: {} }),\n      graphql: async () => ({}),\n      log: {\n        debug: () => {},\n        info: () => {},\n        warn: () => {},\n        error: () => {},\n      },\n      hook: {\n        before: () => {},\n        after: () => {},\n        error: () => {},\n        wrap: () => {},\n      },\n      auth: async () => ({ token: 'mock-token' }),\n    };\n  }\n\n  /**\n   * Create an error result\n   */\n  private createErrorResult(\n    repositoryInfo: GitRepositoryInfo,\n    errorMessage: string,\n    startTime: number,\n    timestamp: string,\n    checksExecuted: string[]\n  ): AnalysisResult {\n    const executionTime = Date.now() - startTime;\n\n    return {\n      repositoryInfo,\n      reviewSummary: {\n        issues: [\n          {\n            file: 'system',\n            line: 0,\n            endLine: undefined,\n            ruleId: 'system/error',\n            message: errorMessage,\n            severity: 'error',\n            category: 'logic',\n            suggestion: undefined,\n            replacement: undefined,\n          },\n        ],\n      },\n      executionTime,\n      timestamp,\n      checksExecuted,\n    };\n  }\n\n  /**\n   * Check if a task result should trigger fail-fast behavior\n   */\n  private isFailFastCandidate(value: unknown): value is {\n    error?: string;\n    result?: { issues?: Array<{ severity?: string }> };\n  } {\n    if (typeof value !== 'object' || value === null) {\n      return false;\n    }\n\n    const candidate = value as {\n      error?: unknown;\n      result?: unknown;\n    };\n\n    if (candidate.error !== undefined && typeof candidate.error !== 'string') {\n      return false;\n    }\n\n    if (candidate.result !== undefined) {\n      if (typeof candidate.result !== 'object' || candidate.result === null) {\n        return false;\n      }\n\n      const issues = (candidate.result as { issues?: unknown }).issues;\n      if (issues !== undefined && !Array.isArray(issues)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private shouldFailFast(result: unknown): boolean {\n    if (!this.isFailFastCandidate(result)) {\n      return false;\n    }\n\n    if (result.error) {\n      return true;\n    }\n\n    // If the result has a result with critical or error issues, it should fail fast\n    const issues = result.result?.issues;\n    if (Array.isArray(issues)) {\n      return issues.some(issue => issue?.severity === 'error' || issue?.severity === 'critical');\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if the working directory is a valid git repository\n   */\n  async isGitRepository(): Promise<boolean> {\n    try {\n      const repositoryInfo = await this.gitAnalyzer.analyzeRepository();\n      return repositoryInfo.isGitRepository;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Evaluate failure conditions for a check result\n   */\n  async evaluateFailureConditions(\n    checkName: string,\n    reviewSummary: ReviewSummary,\n    config?: import('./types/config').VisorConfig,\n    prInfo?: PRInfo,\n    previousOutputs?: Record<string, ReviewSummary> | Map<string, ReviewSummary>\n  ): Promise<FailureConditionResult[]> {\n    if (!config) {\n      return [];\n    }\n\n    const checkConfig = config.checks![checkName];\n    const checkSchema =\n      typeof checkConfig?.schema === 'object' ? 'custom' : checkConfig?.schema || '';\n    const checkGroup = checkConfig?.group || '';\n\n    // Convert previousOutputs Map to Record if needed\n    const outputsRecord: Record<string, ReviewSummary> | undefined = previousOutputs\n      ? previousOutputs instanceof Map\n        ? Object.fromEntries(previousOutputs.entries())\n        : previousOutputs\n      : undefined;\n\n    // Handle new simple fail_if syntax\n    const globalFailIf = config.fail_if;\n    const checkFailIf = checkConfig?.fail_if;\n\n    // If using new fail_if syntax\n    if (globalFailIf || checkFailIf) {\n      const results: FailureConditionResult[] = [];\n\n      // Evaluate global fail_if\n      if (globalFailIf) {\n        const failed = await this.failureEvaluator.evaluateSimpleCondition(\n          checkName,\n          checkSchema,\n          checkGroup,\n          reviewSummary,\n          globalFailIf,\n          outputsRecord\n        );\n\n        try {\n          addEvent('fail_if.evaluated', {\n            check: checkName,\n            scope: 'global',\n            name: 'global_fail_if',\n            expression: globalFailIf,\n          });\n        } catch {}\n        if (failed) {\n          try {\n            addEvent('fail_if.triggered', {\n              check: checkName,\n              scope: 'global',\n              name: 'global_fail_if',\n              expression: globalFailIf,\n              severity: 'error',\n            });\n          } catch {}\n          try {\n            addFailIfTriggered(checkName, 'global');\n          } catch {}\n          try {\n            const { emitNdjsonSpanWithEvents } = require('./telemetry/fallback-ndjson');\n            emitNdjsonSpanWithEvents(\n              'visor.fail_if',\n              { check: checkName, scope: 'global', name: 'global_fail_if' },\n              [\n                {\n                  name: 'fail_if.triggered',\n                  attrs: {\n                    check: checkName,\n                    scope: 'global',\n                    name: 'global_fail_if',\n                    expression: globalFailIf,\n                    severity: 'error',\n                  },\n                },\n              ]\n            );\n          } catch {}\n          logger.warn(`⚠️  Check \"${checkName}\" - global fail_if condition met: ${globalFailIf}`);\n          results.push({\n            conditionName: 'global_fail_if',\n            expression: globalFailIf,\n            failed: true,\n            severity: 'error',\n            message: 'Global failure condition met',\n            haltExecution: false,\n          });\n        } else {\n          logger.debug(`✓ Check \"${checkName}\" - global fail_if condition passed`);\n        }\n      }\n\n      // Evaluate check-specific fail_if (overrides global if present)\n      if (checkFailIf) {\n        const failed = await this.failureEvaluator.evaluateSimpleCondition(\n          checkName,\n          checkSchema,\n          checkGroup,\n          reviewSummary,\n          checkFailIf,\n          outputsRecord\n        );\n\n        try {\n          addEvent('fail_if.evaluated', {\n            check: checkName,\n            scope: 'check',\n            name: `${checkName}_fail_if`,\n            expression: checkFailIf,\n          });\n        } catch {}\n        try {\n          const { emitNdjsonSpanWithEvents } = require('./telemetry/fallback-ndjson');\n          emitNdjsonSpanWithEvents(\n            'visor.fail_if',\n            { check: checkName, scope: 'check', name: `${checkName}_fail_if` },\n            [\n              {\n                name: 'fail_if.evaluated',\n                attrs: {\n                  check: checkName,\n                  scope: 'check',\n                  name: `${checkName}_fail_if`,\n                  expression: checkFailIf,\n                },\n              },\n            ]\n          );\n        } catch {}\n        if (failed) {\n          try {\n            addEvent('fail_if.triggered', {\n              check: checkName,\n              scope: 'check',\n              name: `${checkName}_fail_if`,\n              expression: checkFailIf,\n              severity: 'error',\n            });\n          } catch {}\n          try {\n            addEvent('fail_if.evaluated', {\n              check: checkName,\n              scope: 'check',\n              name: `${checkName}_fail_if`,\n              expression: checkFailIf,\n            });\n          } catch {}\n          try {\n            addFailIfTriggered(checkName, 'check');\n          } catch {}\n          try {\n            const { emitNdjsonSpanWithEvents } = require('./telemetry/fallback-ndjson');\n            emitNdjsonSpanWithEvents(\n              'visor.fail_if',\n              { check: checkName, scope: 'check', name: `${checkName}_fail_if` },\n              [\n                {\n                  name: 'fail_if.triggered',\n                  attrs: {\n                    check: checkName,\n                    scope: 'check',\n                    name: `${checkName}_fail_if`,\n                    expression: checkFailIf,\n                    severity: 'error',\n                  },\n                },\n              ]\n            );\n          } catch {}\n          logger.warn(`⚠️  Check \"${checkName}\" - fail_if condition met: ${checkFailIf}`);\n          results.push({\n            conditionName: `${checkName}_fail_if`,\n            expression: checkFailIf,\n            failed: true,\n            severity: 'error',\n            message: `Check ${checkName} failure condition met`,\n            haltExecution: false,\n          });\n        } else {\n          logger.debug(`✓ Check \"${checkName}\" - fail_if condition passed`);\n        }\n      }\n\n      try {\n        const { emitNdjsonSpanWithEvents } = require('./telemetry/fallback-ndjson');\n        const hadTriggered = results.some(r => r.failed === true);\n        emitNdjsonSpanWithEvents(\n          'visor.fail_if',\n          {\n            check: checkName,\n            scope: hadTriggered\n              ? checkFailIf\n                ? 'check'\n                : 'global'\n              : checkFailIf\n                ? 'check'\n                : 'global',\n          },\n          [\n            {\n              name: 'fail_if.evaluated',\n              attrs: { check: checkName, scope: checkFailIf ? 'check' : 'global' },\n            },\n          ].concat(\n            hadTriggered\n              ? [\n                  {\n                    name: 'fail_if.triggered',\n                    attrs: { check: checkName, scope: checkFailIf ? 'check' : 'global' },\n                  },\n                ]\n              : []\n          )\n        );\n      } catch {}\n      return results;\n    }\n\n    // Fall back to old failure_conditions syntax\n    const globalConditions = config.failure_conditions;\n    const checkConditions = checkConfig?.failure_conditions;\n\n    return await this.failureEvaluator.evaluateConditions(\n      checkName,\n      checkSchema,\n      checkGroup,\n      reviewSummary,\n      globalConditions,\n      checkConditions,\n      undefined, // previousOutputs\n      prInfo?.authorAssociation\n    );\n  }\n\n  /**\n   * Get repository status summary\n   */\n  async getRepositoryStatus(): Promise<{\n    isGitRepository: boolean;\n    hasChanges: boolean;\n    branch: string;\n    filesChanged: number;\n  }> {\n    try {\n      const repositoryInfo = await this.gitAnalyzer.analyzeRepository();\n      return {\n        isGitRepository: repositoryInfo.isGitRepository,\n        hasChanges: repositoryInfo.files.length > 0,\n        branch: repositoryInfo.head,\n        filesChanged: repositoryInfo.files.length,\n      };\n    } catch {\n      return {\n        isGitRepository: false,\n        hasChanges: false,\n        branch: 'unknown',\n        filesChanged: 0,\n      };\n    }\n  }\n\n  /**\n   * Initialize GitHub check runs for each configured check\n   */\n  private async initializeGitHubChecks(\n    options: CheckExecutionOptions,\n    logFn: (message: string) => void\n  ): Promise<void> {\n    if (\n      !options.githubChecks?.octokit ||\n      !options.githubChecks.owner ||\n      !options.githubChecks.repo ||\n      !options.githubChecks.headSha\n    ) {\n      logFn('⚠️ GitHub checks enabled but missing required parameters');\n      return;\n    }\n\n    try {\n      this.githubCheckService = new GitHubCheckService(options.githubChecks.octokit);\n      this.checkRunMap = new Map();\n      this.githubContext = {\n        owner: options.githubChecks.owner,\n        repo: options.githubChecks.repo,\n      };\n\n      logFn(`🔍 Creating GitHub check runs for ${options.checks.length} checks...`);\n\n      for (const checkName of options.checks) {\n        try {\n          const checkRunOptions: CheckRunOptions = {\n            owner: options.githubChecks.owner,\n            repo: options.githubChecks.repo,\n            head_sha: options.githubChecks.headSha,\n            name: `Visor: ${checkName}`,\n            external_id: `visor-${checkName}-${options.githubChecks.headSha.substring(0, 7)}`,\n          };\n\n          const checkRun = await this.githubCheckService.createCheckRun(checkRunOptions, {\n            title: `${checkName} Analysis`,\n            summary: `Running ${checkName} check using AI-powered analysis...`,\n          });\n\n          this.checkRunMap.set(checkName, checkRun);\n          logFn(`✅ Created check run for ${checkName}: ${checkRun.url}`);\n        } catch (error) {\n          logFn(`❌ Failed to create check run for ${checkName}: ${error}`);\n        }\n      }\n    } catch (error) {\n      // Check if this is a permissions error\n      if (\n        error instanceof Error &&\n        (error.message.includes('403') || error.message.includes('checks:write'))\n      ) {\n        logFn(\n          '⚠️ GitHub checks API not available - insufficient permissions. Check runs will be skipped.'\n        );\n        logFn('💡 To enable check runs, ensure your GitHub token has \"checks:write\" permission.');\n        this.githubCheckService = undefined;\n        this.checkRunMap = undefined;\n      } else {\n        logFn(`❌ Failed to initialize GitHub check runs: ${error}`);\n        this.githubCheckService = undefined;\n        this.checkRunMap = undefined;\n      }\n    }\n  }\n\n  /**\n   * Update GitHub check runs to in-progress status\n   */\n  private async updateGitHubChecksInProgress(options: CheckExecutionOptions): Promise<void> {\n    if (\n      !this.githubCheckService ||\n      !this.checkRunMap ||\n      !options.githubChecks?.owner ||\n      !options.githubChecks.repo\n    ) {\n      return;\n    }\n\n    for (const [checkName, checkRun] of this.checkRunMap) {\n      try {\n        await this.githubCheckService.updateCheckRunInProgress(\n          options.githubChecks.owner,\n          options.githubChecks.repo,\n          checkRun.id,\n          {\n            title: `Analyzing with ${checkName}...`,\n            summary: `AI-powered analysis is in progress for ${checkName} check.`,\n          }\n        );\n        console.log(`🔄 Updated ${checkName} check to in-progress status`);\n      } catch (error) {\n        console.error(`❌ Failed to update ${checkName} check to in-progress: ${error}`);\n      }\n    }\n  }\n\n  /**\n   * Complete GitHub check runs with results\n   */\n  private async completeGitHubChecksWithResults(\n    reviewSummary: ReviewSummary,\n    options: CheckExecutionOptions,\n    prInfo: import('./pr-analyzer').PRInfo\n  ): Promise<void> {\n    if (\n      !this.githubCheckService ||\n      !this.checkRunMap ||\n      !options.githubChecks?.owner ||\n      !options.githubChecks.repo\n    ) {\n      return;\n    }\n\n    // Group issues by check name\n    const issuesByCheck = new Map<string, import('./reviewer').ReviewIssue[]>();\n\n    // Initialize empty arrays for all checks\n    for (const checkName of this.checkRunMap.keys()) {\n      issuesByCheck.set(checkName, []);\n    }\n\n    // Group issues by their check name\n    for (const issue of reviewSummary.issues || []) {\n      if (issue.checkName && issuesByCheck.has(issue.checkName)) {\n        issuesByCheck.get(issue.checkName)!.push(issue);\n      }\n    }\n\n    console.log(`🏁 Completing ${this.checkRunMap.size} GitHub check runs...`);\n\n    for (const [checkName, checkRun] of this.checkRunMap) {\n      try {\n        const checkIssues = issuesByCheck.get(checkName) || [];\n\n        // Evaluate failure conditions for this specific check\n        const failureResults = await this.evaluateFailureConditions(\n          checkName,\n          { issues: checkIssues },\n          options.config\n        );\n\n        // Detect command execution failure patterns to mark check as failed without requiring fail_if\n        // We treat issues with ruleId starting with 'command/' as execution errors\n        const execErrorIssue = checkIssues.find(i => i.ruleId?.startsWith('command/'));\n\n        await this.githubCheckService.completeCheckRun(\n          options.githubChecks.owner,\n          options.githubChecks.repo,\n          checkRun.id,\n          checkName,\n          failureResults,\n          checkIssues,\n          execErrorIssue ? execErrorIssue.message : undefined, // executionError\n          prInfo.files.map((f: import('./pr-analyzer').PRFile) => f.filename), // filesChangedInCommit\n          options.githubChecks.prNumber, // prNumber\n          options.githubChecks.headSha // currentCommitSha\n        );\n\n        console.log(`✅ Completed ${checkName} check with ${checkIssues.length} issues`);\n      } catch (error) {\n        console.error(`❌ Failed to complete ${checkName} check: ${error}`);\n\n        // Try to mark the check as failed due to execution error\n        try {\n          await this.githubCheckService.completeCheckRun(\n            options.githubChecks.owner,\n            options.githubChecks.repo,\n            checkRun.id,\n            checkName,\n            [],\n            [],\n            error instanceof Error ? error.message : 'Unknown error occurred'\n          );\n        } catch (finalError) {\n          console.error(`❌ Failed to mark ${checkName} check as failed: ${finalError}`);\n        }\n      }\n    }\n  }\n\n  /**\n   * Complete GitHub check runs with error status\n   */\n  private async completeGitHubChecksWithError(errorMessage: string): Promise<void> {\n    if (!this.githubCheckService || !this.checkRunMap || !this.githubContext) {\n      return;\n    }\n\n    console.log(`❌ Completing ${this.checkRunMap.size} GitHub check runs with error...`);\n\n    for (const [checkName, checkRun] of this.checkRunMap) {\n      try {\n        await this.githubCheckService.completeCheckRun(\n          this.githubContext.owner,\n          this.githubContext.repo,\n          checkRun.id,\n          checkName,\n          [],\n          [],\n          errorMessage\n        );\n        console.log(`❌ Completed ${checkName} check with error: ${errorMessage}`);\n      } catch (error) {\n        console.error(`❌ Failed to complete ${checkName} check with error: ${error}`);\n      }\n    }\n  }\n\n  /**\n   * Filter checks based on their event triggers to prevent execution of checks\n   * that shouldn't run for the current event type\n   */\n  private filterChecksByEvent(\n    checks: string[],\n    config?: import('./types/config').VisorConfig,\n    prInfo?: PRInfo,\n    logFn?: (message: string) => void,\n    debug?: boolean\n  ): string[] {\n    if (!config?.checks) {\n      // No config available, return all checks (fallback behavior)\n      return checks;\n    }\n\n    // If we have event context from GitHub (prInfo with eventType), apply strict filtering\n    // Otherwise (CLI, tests), use conservative filtering\n    const prInfoWithEvent = prInfo as PRInfo & {\n      eventType?: import('./types/config').EventTrigger;\n    };\n    const hasEventContext =\n      prInfoWithEvent && 'eventType' in prInfoWithEvent && prInfoWithEvent.eventType;\n\n    if (hasEventContext) {\n      // GitHub Action context - apply strict event filtering\n      const currentEvent = prInfoWithEvent.eventType!;\n      if (debug) {\n        logFn?.(`🔧 Debug: GitHub Action context, current event: ${currentEvent}`);\n      }\n\n      const filteredChecks: string[] = [];\n      for (const checkName of checks) {\n        const checkConfig = config.checks![checkName];\n        if (!checkConfig) {\n          filteredChecks.push(checkName);\n          continue;\n        }\n\n        const eventTriggers = checkConfig.on || [];\n        if (eventTriggers.length === 0) {\n          // No triggers specified, include it\n          filteredChecks.push(checkName);\n          if (debug) {\n            logFn?.(`🔧 Debug: Check '${checkName}' has no event triggers, including`);\n          }\n        } else if (eventTriggers.includes(currentEvent)) {\n          // Check matches current event\n          filteredChecks.push(checkName);\n          if (debug) {\n            logFn?.(`🔧 Debug: Check '${checkName}' matches event '${currentEvent}', including`);\n          }\n        } else {\n          // Check doesn't match current event\n          if (debug) {\n            logFn?.(\n              `🔧 Debug: Check '${checkName}' does not match event '${currentEvent}' (triggers: ${JSON.stringify(eventTriggers)}), skipping`\n            );\n          }\n        }\n      }\n      return filteredChecks;\n    } else {\n      // CLI/Test context - conservative filtering (only exclude manual-only checks)\n      if (debug) {\n        logFn?.(`🔧 Debug: CLI/Test context, using conservative filtering`);\n      }\n\n      const filteredChecks: string[] = [];\n      for (const checkName of checks) {\n        const checkConfig = config.checks![checkName];\n        if (!checkConfig) {\n          filteredChecks.push(checkName);\n          continue;\n        }\n\n        const eventTriggers = checkConfig.on || [];\n\n        // Only exclude checks that are explicitly manual-only\n        if (eventTriggers.length === 1 && eventTriggers[0] === 'manual') {\n          if (debug) {\n            logFn?.(`🔧 Debug: Check '${checkName}' is manual-only, skipping`);\n          }\n        } else {\n          filteredChecks.push(checkName);\n          if (debug) {\n            logFn?.(\n              `🔧 Debug: Check '${checkName}' included (triggers: ${JSON.stringify(eventTriggers)})`\n            );\n          }\n        }\n      }\n      return filteredChecks;\n    }\n  }\n\n  /**\n   * Determine the current event type from PR info\n   */\n  private getCurrentEventType(prInfo?: PRInfo): import('./types/config').EventTrigger {\n    if (!prInfo) {\n      return 'pr_opened'; // Default fallback\n    }\n\n    // For now, assume all PR-related operations are 'pr_updated' since we don't have\n    // direct access to the original GitHub event here. This is a simplification.\n    // In the future, we could pass the actual event type through the call chain.\n\n    // The key insight is that issue-assistant should only run on issue_opened/issue_comment\n    // events, which don't generate PRInfo objects in the first place.\n    return 'pr_updated';\n  }\n\n  /**\n   * Initialize execution statistics for a check\n   */\n  private initializeCheckStats(checkName: string): void {\n    this.executionStats.set(checkName, {\n      checkName,\n      totalRuns: 0,\n      successfulRuns: 0,\n      failedRuns: 0,\n      skipped: false,\n      totalDuration: 0,\n      providerDurationMs: 0,\n      issuesFound: 0,\n      issuesBySeverity: {\n        critical: 0,\n        error: 0,\n        warning: 0,\n        info: 0,\n      },\n      perIterationDuration: [],\n    });\n  }\n\n  /**\n   * Record the start of a check iteration\n   * Returns the start timestamp for duration tracking\n   */\n  private recordIterationStart(_checkName: string): number {\n    return Date.now();\n  }\n\n  /**\n   * Record completion of a check iteration\n   */\n  private recordIterationComplete(\n    checkName: string,\n    startTime: number,\n    success: boolean,\n    issues: ReviewIssue[],\n    output?: unknown\n  ): void {\n    const stats = this.executionStats.get(checkName);\n    if (!stats) return;\n\n    const duration = Date.now() - startTime;\n    stats.totalRuns++;\n    if (success) {\n      stats.successfulRuns++;\n    } else {\n      stats.failedRuns++;\n    }\n    stats.totalDuration += duration;\n    stats.perIterationDuration!.push(duration);\n\n    // Count issues by severity\n    for (const issue of issues) {\n      stats.issuesFound++;\n      if (issue.severity === 'critical') stats.issuesBySeverity.critical++;\n      else if (issue.severity === 'error') stats.issuesBySeverity.error++;\n      else if (issue.severity === 'warning') stats.issuesBySeverity.warning++;\n      else if (issue.severity === 'info') stats.issuesBySeverity.info++;\n    }\n\n    // Track outputs produced\n    if (output !== undefined) {\n      stats.outputsProduced = (stats.outputsProduced || 0) + 1;\n    }\n  }\n\n  /**\n   * Record provider/self execution time (in milliseconds) for a check\n   */\n  private recordProviderDuration(checkName: string, ms: number): void {\n    const stats = this.executionStats.get(checkName);\n    if (!stats) return;\n    stats.providerDurationMs = (stats.providerDurationMs || 0) + Math.max(0, Math.floor(ms));\n  }\n\n  /**\n   * Track output in history for loop/goto scenarios\n   */\n  private trackOutputHistory(checkName: string, output: unknown): void {\n    if (output === undefined) return;\n\n    if (!this.outputHistory.has(checkName)) {\n      this.outputHistory.set(checkName, []);\n    }\n    this.outputHistory.get(checkName)!.push(output);\n  }\n\n  /**\n   * Record that a check was skipped\n   */\n  private recordSkip(\n    checkName: string,\n    reason: 'if_condition' | 'fail_fast' | 'dependency_failed',\n    condition?: string\n  ): void {\n    const stats = this.executionStats.get(checkName);\n    if (!stats) return;\n\n    stats.skipped = true;\n    stats.skipReason = reason;\n    if (condition) {\n      stats.skipCondition = condition;\n    }\n  }\n\n  /**\n   * Record forEach preview items\n   */\n  private recordForEachPreview(checkName: string, items: unknown[] | undefined): void {\n    const stats = this.executionStats.get(checkName);\n    if (!stats) return;\n    if (!Array.isArray(items) || items.length === 0) return;\n\n    // Store preview of first 3 items\n    const preview = items.slice(0, 3).map(item => {\n      let str: string;\n      if (typeof item === 'string') {\n        str = item;\n      } else if (item === undefined || item === null) {\n        str = '(empty)';\n      } else {\n        try {\n          const j = JSON.stringify(item);\n          str = typeof j === 'string' ? j : String(item);\n        } catch {\n          str = String(item);\n        }\n      }\n      return str.length > 50 ? str.substring(0, 47) + '...' : str;\n    });\n\n    if (items.length > 3) {\n      preview.push(`...${items.length - 3} more`);\n    }\n\n    stats.forEachPreview = preview;\n  }\n\n  /**\n   * Record an error for a check\n   */\n  private recordError(checkName: string, error: Error | string): void {\n    const stats = this.executionStats.get(checkName);\n    if (!stats) return;\n\n    stats.errorMessage = error instanceof Error ? error.message : String(error);\n  }\n\n  /**\n   * Build the final execution statistics object\n   */\n  private buildExecutionStatistics(): ExecutionStatistics {\n    const checks = Array.from(this.executionStats.values());\n    const totalExecutions = checks.reduce((sum, s) => sum + s.totalRuns, 0);\n    const successfulExecutions = checks.reduce((sum, s) => sum + s.successfulRuns, 0);\n    const failedExecutions = checks.reduce((sum, s) => sum + s.failedRuns, 0);\n    const skippedChecks = checks.filter(s => s.skipped).length;\n    const totalDuration = checks.reduce((sum, s) => sum + s.totalDuration, 0);\n\n    return {\n      totalChecksConfigured: checks.length,\n      totalExecutions,\n      successfulExecutions,\n      failedExecutions,\n      skippedChecks,\n      totalDuration,\n      checks,\n    };\n  }\n\n  // Generic fatality helpers to avoid duplication\n  private isFatalRule(id: string, severity?: string): boolean {\n    const sev = (severity || '').toLowerCase();\n    return (\n      sev === 'error' ||\n      sev === 'critical' ||\n      id === 'command/execution_error' ||\n      id.endsWith('/command/execution_error') ||\n      id === 'command/timeout' ||\n      id.endsWith('/command/timeout') ||\n      id === 'command/transform_js_error' ||\n      id.endsWith('/command/transform_js_error') ||\n      id === 'command/transform_error' ||\n      id.endsWith('/command/transform_error') ||\n      id.endsWith('/forEach/iteration_error') ||\n      id === 'forEach/undefined_output' ||\n      id.endsWith('/forEach/undefined_output') ||\n      id.endsWith('_fail_if') ||\n      id.endsWith('/global_fail_if')\n    );\n  }\n\n  private hasFatal(issues: ReviewIssue[] | undefined): boolean {\n    if (!issues || issues.length === 0) return false;\n    return issues.some(i => this.isFatalRule(i.ruleId || '', i.severity));\n  }\n\n  private async failIfTriggered(\n    checkName: string,\n    result: ReviewSummary,\n    config?: import('./types/config').VisorConfig,\n    previousOutputs?: Record<string, ReviewSummary> | Map<string, ReviewSummary>\n  ): Promise<boolean> {\n    if (!config) return false;\n    const failures = await this.evaluateFailureConditions(\n      checkName,\n      result,\n      config,\n      undefined,\n      previousOutputs\n    );\n    return failures.some(f => f.failed);\n  }\n\n  /**\n   * Truncate a string to max length with ellipsis\n   */\n  private truncate(str: string, maxLen: number): string {\n    if (str.length <= maxLen) return str;\n    return str.substring(0, maxLen - 3) + '...';\n  }\n\n  /**\n   * Format the Status column for execution summary table\n   */\n  private formatStatusColumn(stats: CheckExecutionStats): string {\n    if (stats.skipped) {\n      if (stats.skipReason === 'if_condition') return '⏭ if';\n      if (stats.skipReason === 'fail_fast') return '⏭ ff';\n      if (stats.skipReason === 'dependency_failed') return '⏭ dep';\n      return '⏭';\n    }\n\n    // Prefer history length when it indicates more actual executions than our counter\n    const historyLen = (() => {\n      try {\n        return this.outputHistory.get(stats.checkName)?.length || 0;\n      } catch {\n        return 0;\n      }\n    })();\n    const totalRuns = Math.max(stats.totalRuns || 0, historyLen);\n    if (totalRuns === 0) return '-';\n\n    const symbol = stats.failedRuns === 0 ? '✔' : stats.successfulRuns === 0 ? '✖' : '✔/✖';\n\n    // Show iteration count if > 1\n    if (totalRuns > 1) {\n      if (stats.failedRuns > 0 && stats.successfulRuns > 0) {\n        // Partial success\n        return `${symbol} ${stats.successfulRuns}/${totalRuns}`;\n      } else {\n        // All success or all failed\n        return `${symbol} ×${totalRuns}`;\n      }\n    }\n\n    return symbol;\n  }\n\n  /**\n   * Format the Details column for execution summary table\n   */\n  private formatDetailsColumn(stats: CheckExecutionStats, _isForEachParent?: boolean): string {\n    const parts: string[] = [];\n\n    // Simpler summary: do not show passes/items here to avoid confusion.\n    // Status column already shows ×N when runs > 1.\n\n    // Show self/provider time to disambiguate inclusive duration in the main column\n    if (typeof stats.providerDurationMs === 'number' && stats.providerDurationMs > 0) {\n      const selfSec = (stats.providerDurationMs / 1000).toFixed(1);\n      parts.unshift(`self:${selfSec}s`);\n    }\n\n    // Outputs produced (forEach)\n    if (stats.outputsProduced && stats.outputsProduced > 0) {\n      parts.push(`→${stats.outputsProduced}`);\n    }\n\n    // Critical issues\n    if (stats.issuesBySeverity.critical > 0) {\n      parts.push(`${stats.issuesBySeverity.critical}🔴`);\n    }\n\n    // Warnings\n    if (stats.issuesBySeverity.warning > 0) {\n      parts.push(`${stats.issuesBySeverity.warning}⚠️`);\n    }\n\n    // Info (only if no critical/warnings)\n    if (\n      stats.issuesBySeverity.info > 0 &&\n      stats.issuesBySeverity.critical === 0 &&\n      stats.issuesBySeverity.warning === 0\n    ) {\n      parts.push(`${stats.issuesBySeverity.info}💡`);\n    }\n\n    // Error message or skip condition\n    if (stats.errorMessage) {\n      parts.push(this.truncate(stats.errorMessage, 20));\n    } else if (stats.skipCondition) {\n      parts.push(this.truncate(stats.skipCondition, 20));\n    }\n\n    return parts.join(' ');\n  }\n\n  /**\n   * Log the execution summary table\n   */\n  private logExecutionSummary(stats: ExecutionStatistics): void {\n    const totalIssues = stats.checks.reduce((sum, s) => sum + s.issuesFound, 0);\n    const criticalIssues = stats.checks.reduce((sum, s) => sum + s.issuesBySeverity.critical, 0);\n    const warningIssues = stats.checks.reduce((sum, s) => sum + s.issuesBySeverity.warning, 0);\n    const durationSec = (stats.totalDuration / 1000).toFixed(1);\n\n    // Summary box\n    const summaryTable = new (require('cli-table3'))({\n      style: {\n        head: [],\n        border: [],\n      },\n      colWidths: [41],\n    });\n\n    summaryTable.push(\n      [`Checks Complete (${durationSec}s)`],\n      [`Checks: ${stats.totalChecksConfigured} configured → ${stats.totalExecutions} executions`],\n      [\n        `Status: ${stats.successfulExecutions} ✔ │ ${stats.failedExecutions} ✖ │ ${stats.skippedChecks} ⏭`,\n      ]\n    );\n\n    if (totalIssues > 0) {\n      let issuesLine = `Issues: ${totalIssues} total`;\n      if (criticalIssues > 0) issuesLine += ` (${criticalIssues} 🔴`;\n      if (warningIssues > 0) issuesLine += `${criticalIssues > 0 ? ' ' : ' ('}${warningIssues} ⚠️)`;\n      else if (criticalIssues > 0) issuesLine += ')';\n      summaryTable.push([issuesLine]);\n    }\n\n    logger.info('');\n    logger.info(summaryTable.toString());\n\n    // Details table\n    logger.info('');\n    logger.info('Check Details:');\n\n    const detailsTable = new (require('cli-table3'))({\n      head: ['Check', 'Duration', 'Status', 'Details'],\n      colWidths: [21, 18, 10, 21],\n      style: {\n        head: ['cyan'],\n        border: ['grey'],\n      },\n    });\n\n    for (const checkStats of stats.checks) {\n      const isForEachParent = !!this.config?.checks?.[checkStats.checkName]?.forEach;\n      // Show only the self/provider total time across all runs.\n      const selfMs =\n        typeof checkStats.providerDurationMs === 'number' && checkStats.providerDurationMs > 0\n          ? checkStats.providerDurationMs\n          : checkStats.totalDuration; // fallback if provider time missing\n      const duration = checkStats.skipped ? '-' : `${(selfMs / 1000).toFixed(1)}s`;\n      const status = this.formatStatusColumn(checkStats);\n      const details = this.formatDetailsColumn(checkStats, isForEachParent);\n\n      detailsTable.push([checkStats.checkName, duration, status, details]);\n    }\n\n    logger.info(detailsTable.toString());\n\n    // Clarify that we will finalize GitHub check runs after the table (if enabled)\n    try {\n      if (this.checkRunMap && this.checkRunMap.size > 0) {\n        logger.info('');\n        logger.info('⏳ Finalizing GitHub check runs...');\n      }\n    } catch {}\n\n    // Legend\n    logger.info('');\n    logger.info(\n      'Legend: ✔=success │ ✖=failed │ ⏭=skipped │ ×N=iterations │ →N=outputs │ N🔴=critical │ N⚠️=warnings'\n    );\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { VisorConfig, CheckConfig } from '../types/config';\n\n/**\n * Utility class for merging Visor configurations with proper override semantics\n */\nexport class ConfigMerger {\n  /**\n   * Merge two configurations with child overriding parent\n   * @param parent - Base configuration\n   * @param child - Configuration to merge on top\n   * @returns Merged configuration\n   */\n  public merge(parent: Partial<VisorConfig>, child: Partial<VisorConfig>): Partial<VisorConfig> {\n    // Start with a deep copy of parent\n    const result: Partial<VisorConfig> = this.deepCopy(parent);\n\n    // Merge simple properties (child overrides parent)\n    if (child.version !== undefined) result.version = child.version;\n    if (child.ai_model !== undefined) result.ai_model = child.ai_model;\n    if (child.ai_provider !== undefined) result.ai_provider = child.ai_provider;\n    if (child.max_parallelism !== undefined) result.max_parallelism = child.max_parallelism;\n    if (child.fail_fast !== undefined) result.fail_fast = child.fail_fast;\n    if (child.fail_if !== undefined) result.fail_if = child.fail_if;\n    if (child.failure_conditions !== undefined)\n      result.failure_conditions = child.failure_conditions;\n\n    // Merge environment variables (deep merge)\n    if (child.env) {\n      result.env = this.mergeObjects(parent.env || {}, child.env);\n    }\n\n    // Merge output configuration (deep merge)\n    if (child.output) {\n      result.output = this.mergeOutputConfig(parent.output, child.output);\n    }\n\n    // Merge checks (special handling)\n    if (child.checks) {\n      result.checks = this.mergeChecks(parent.checks || {}, child.checks);\n    }\n\n    // Note: extends should not be in the final merged config\n    // It's only used during the loading process\n\n    return result;\n  }\n\n  /**\n   * Deep copy an object\n   */\n  private deepCopy<T>(obj: T): T {\n    if (obj === null || obj === undefined) {\n      return obj;\n    }\n    if (obj instanceof Date) {\n      return new Date(obj.getTime()) as unknown as T;\n    }\n    if (obj instanceof Array) {\n      const copy: unknown[] = [];\n      for (const item of obj) {\n        copy.push(this.deepCopy(item));\n      }\n      return copy as unknown as T;\n    }\n    if (obj instanceof Object) {\n      const copy = {} as Record<string, unknown>;\n      for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          copy[key] = this.deepCopy((obj as any)[key]);\n        }\n      }\n      return copy as T;\n    }\n    return obj;\n  }\n\n  /**\n   * Merge two objects (child overrides parent)\n   */\n  private mergeObjects<T extends Record<string, any>>(parent: T, child: T): T {\n    const result: any = { ...parent };\n\n    for (const key in child) {\n      if (Object.prototype.hasOwnProperty.call(child, key)) {\n        const parentValue = parent[key];\n        const childValue = child[key];\n\n        if (childValue === null || childValue === undefined) {\n          // null/undefined in child removes the key\n          delete result[key];\n        } else if (\n          typeof parentValue === 'object' &&\n          typeof childValue === 'object' &&\n          !Array.isArray(parentValue) &&\n          !Array.isArray(childValue) &&\n          parentValue !== null &&\n          childValue !== null\n        ) {\n          // Deep merge objects\n          result[key] = this.mergeObjects(\n            parentValue as Record<string, any>,\n            childValue as Record<string, any>\n          );\n        } else {\n          // Child overrides parent (including arrays)\n          result[key] = this.deepCopy(childValue);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Merge output configurations\n   */\n  private mergeOutputConfig(\n    parent?: Partial<VisorConfig>['output'],\n    child?: Partial<VisorConfig>['output']\n  ): Partial<VisorConfig>['output'] {\n    if (!child) return parent;\n    if (!parent) return child;\n\n    const result: any = this.deepCopy(parent);\n\n    // Merge pr_comment\n    if (child.pr_comment) {\n      result.pr_comment = this.mergeObjects(\n        (parent.pr_comment || {}) as Record<string, any>,\n        child.pr_comment as Record<string, any>\n      ) as any;\n    }\n\n    // Merge file_comment\n    if (child.file_comment !== undefined) {\n      if (child.file_comment === null) {\n        delete result.file_comment;\n      } else {\n        result.file_comment = this.mergeObjects(\n          (parent.file_comment || {}) as Record<string, any>,\n          child.file_comment as Record<string, any>\n        ) as any;\n      }\n    }\n\n    // Merge github_checks\n    if (child.github_checks !== undefined) {\n      if (child.github_checks === null) {\n        delete result.github_checks;\n      } else {\n        result.github_checks = this.mergeObjects(\n          (parent.github_checks || {}) as Record<string, any>,\n          child.github_checks as Record<string, any>\n        ) as any;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Merge check configurations with special handling\n   */\n  private mergeChecks(\n    parent: Record<string, CheckConfig>,\n    child: Record<string, CheckConfig>\n  ): Record<string, CheckConfig> {\n    const result: Record<string, CheckConfig> = {};\n\n    // Start with all parent checks\n    for (const [checkName, checkConfig] of Object.entries(parent)) {\n      result[checkName] = this.deepCopy(checkConfig);\n    }\n\n    // Process child checks\n    for (const [checkName, childConfig] of Object.entries(child)) {\n      const parentConfig = parent[checkName];\n\n      if (!parentConfig) {\n        // New check - need to process appendPrompt even without parent\n        const copiedConfig = this.deepCopy(childConfig);\n\n        // Default to 'ai' type if not specified\n        if (!copiedConfig.type) {\n          copiedConfig.type = 'ai';\n        }\n\n        // Default 'on' to ['manual'] if not specified\n        if (!copiedConfig.on) {\n          copiedConfig.on = ['manual'];\n        }\n\n        // Handle appendPrompt for new checks (convert to prompt)\n        if (copiedConfig.appendPrompt !== undefined) {\n          // If there's no parent, appendPrompt becomes the prompt\n          if (!copiedConfig.prompt) {\n            copiedConfig.prompt = copiedConfig.appendPrompt;\n          } else {\n            // If both prompt and appendPrompt exist in child, append them\n            copiedConfig.prompt = copiedConfig.prompt + '\\n\\n' + copiedConfig.appendPrompt;\n          }\n          // Remove appendPrompt from final config\n          delete copiedConfig.appendPrompt;\n        }\n\n        result[checkName] = copiedConfig;\n      } else {\n        // Merge existing check\n        result[checkName] = this.mergeCheckConfig(parentConfig, childConfig);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Merge individual check configurations\n   */\n  private mergeCheckConfig(parent: CheckConfig, child: CheckConfig): CheckConfig {\n    const result: CheckConfig = this.deepCopy(parent);\n\n    // Simple properties (child overrides parent)\n    if (child.type !== undefined) result.type = child.type;\n\n    // Default to 'ai' type if not specified in either parent or child\n    if (!result.type) {\n      result.type = 'ai';\n    }\n    if (child.prompt !== undefined) result.prompt = child.prompt;\n\n    // Handle appendPrompt - append to existing prompt\n    if (child.appendPrompt !== undefined) {\n      if (result.prompt) {\n        // Append with a newline separator if parent has a prompt\n        result.prompt = result.prompt + '\\n\\n' + child.appendPrompt;\n      } else {\n        // If no parent prompt, appendPrompt becomes the prompt\n        result.prompt = child.appendPrompt;\n      }\n      // Don't carry forward appendPrompt to avoid re-appending\n      delete result.appendPrompt;\n    }\n\n    if (child.exec !== undefined) result.exec = child.exec;\n    if (child.stdin !== undefined) result.stdin = child.stdin;\n    if (child.url !== undefined) result.url = child.url;\n    if (child.focus !== undefined) result.focus = child.focus;\n    if (child.command !== undefined) result.command = child.command;\n    if (child.ai_model !== undefined) result.ai_model = child.ai_model;\n    if (child.ai_provider !== undefined) result.ai_provider = child.ai_provider;\n    if (child.group !== undefined) result.group = child.group;\n    if (child.schema !== undefined) result.schema = child.schema;\n    if (child.if !== undefined) result.if = child.if;\n    if (child.reuse_ai_session !== undefined) result.reuse_ai_session = child.reuse_ai_session;\n    if (child.fail_if !== undefined) result.fail_if = child.fail_if;\n    if (child.failure_conditions !== undefined)\n      result.failure_conditions = child.failure_conditions;\n\n    // Special handling for 'on' array\n    if (child.on !== undefined) {\n      if (Array.isArray(child.on) && child.on.length === 0) {\n        // Empty array disables the check\n        result.on = [];\n      } else {\n        // Replace parent's on array\n        result.on = [...child.on];\n      }\n    }\n\n    // Default 'on' to ['manual'] if still not specified\n    if (!result.on) {\n      result.on = ['manual'];\n    }\n\n    // Arrays that get replaced (not concatenated)\n    if (child.triggers !== undefined) {\n      result.triggers = child.triggers ? [...child.triggers] : undefined;\n    }\n    if (child.depends_on !== undefined) {\n      result.depends_on = child.depends_on ? [...child.depends_on] : undefined;\n    }\n\n    // Deep merge objects\n    if (child.env) {\n      result.env = this.mergeObjects(\n        (parent.env || {}) as Record<string, any>,\n        child.env as Record<string, any>\n      );\n    }\n    if (child.ai) {\n      result.ai = this.mergeObjects(\n        (parent.ai || {}) as Record<string, any>,\n        child.ai as Record<string, any>\n      );\n    }\n    if (child.template) {\n      result.template = this.mergeObjects(\n        (parent.template || {}) as Record<string, any>,\n        child.template as Record<string, any>\n      );\n    }\n\n    return result;\n  }\n\n  /**\n   * Check if a check is disabled (has empty 'on' array)\n   */\n  public isCheckDisabled(check: CheckConfig): boolean {\n    return Array.isArray(check.on) && check.on.length === 0;\n  }\n\n  /**\n   * Remove disabled checks from the configuration\n   */\n  public removeDisabledChecks(config: Partial<VisorConfig>): Partial<VisorConfig> {\n    if (!config.checks) return config;\n\n    const result = this.deepCopy(config);\n    const enabledChecks: Record<string, CheckConfig> = {};\n\n    for (const [checkName, checkConfig] of Object.entries(result.checks!)) {\n      if (!this.isCheckDisabled(checkConfig)) {\n        enabledChecks[checkName] = checkConfig;\n      } else {\n        console.log(`ℹ️  Check '${checkName}' is disabled (empty 'on' array)`);\n      }\n    }\n\n    result.checks = enabledChecks;\n    return result;\n  }\n}\n","// AUTO-GENERATED FILE. DO NOT EDIT.\n// Generated by scripts/generate-config-schema.js from src/types/config.ts\nexport const configSchema = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  $ref: '#/definitions/VisorConfig',\n  definitions: {\n    VisorConfig: {\n      type: 'object',\n      properties: {\n        version: {\n          type: 'string',\n          description: 'Configuration version',\n        },\n        extends: {\n          anyOf: [\n            {\n              type: 'string',\n            },\n            {\n              type: 'array',\n              items: {\n                type: 'string',\n              },\n            },\n          ],\n          description:\n            'Extends from other configurations - can be file path, HTTP(S) URL, or \"default\"',\n        },\n        steps: {\n          $ref: '#/definitions/Record%3Cstring%2CCheckConfig%3E',\n          description: 'Step configurations (recommended)',\n        },\n        checks: {\n          $ref: '#/definitions/Record%3Cstring%2CCheckConfig%3E',\n          description:\n            \"Check configurations (legacy, use 'steps' instead) - always populated after normalization\",\n        },\n        output: {\n          $ref: '#/definitions/OutputConfig',\n          description: 'Output configuration',\n        },\n        http_server: {\n          $ref: '#/definitions/HttpServerConfig',\n          description: 'HTTP server configuration for receiving webhooks',\n        },\n        memory: {\n          $ref: '#/definitions/MemoryConfig',\n          description: 'Memory storage configuration',\n        },\n        env: {\n          $ref: '#/definitions/EnvConfig',\n          description: 'Global environment variables',\n        },\n        ai_model: {\n          type: 'string',\n          description: 'Global AI model setting',\n        },\n        ai_provider: {\n          type: 'string',\n          description: 'Global AI provider setting',\n        },\n        ai_mcp_servers: {\n          $ref: '#/definitions/Record%3Cstring%2CMcpServerConfig%3E',\n          description: 'Global MCP servers configuration for AI checks',\n        },\n        max_parallelism: {\n          type: 'number',\n          description: 'Maximum number of checks to run in parallel (default: 3)',\n        },\n        fail_fast: {\n          type: 'boolean',\n          description: 'Stop execution when any check fails (default: false)',\n        },\n        fail_if: {\n          type: 'string',\n          description: 'Simple global fail condition - fails if expression evaluates to true',\n        },\n        failure_conditions: {\n          $ref: '#/definitions/FailureConditions',\n          description: 'Global failure conditions - optional (deprecated, use fail_if)',\n        },\n        tag_filter: {\n          $ref: '#/definitions/TagFilter',\n          description: 'Tag filter for selective check execution',\n        },\n        routing: {\n          $ref: '#/definitions/RoutingDefaults',\n          description: 'Optional routing defaults for retry/goto/run policies',\n        },\n      },\n      required: ['version', 'output'],\n      additionalProperties: false,\n      description: 'Main Visor configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    'Record<string,CheckConfig>': {\n      type: 'object',\n      additionalProperties: {\n        $ref: '#/definitions/CheckConfig',\n      },\n    },\n    CheckConfig: {\n      type: 'object',\n      properties: {\n        type: {\n          $ref: '#/definitions/ConfigCheckType',\n          description: \"Type of check to perform (defaults to 'ai' if not specified)\",\n        },\n        prompt: {\n          type: 'string',\n          description:\n            'AI prompt for the check - can be inline string or file path (auto-detected) - required for AI checks',\n        },\n        appendPrompt: {\n          type: 'string',\n          description:\n            'Additional prompt to append when extending configurations - merged with parent prompt',\n        },\n        exec: {\n          type: 'string',\n          description:\n            'Command execution with Liquid template support - required for command checks',\n        },\n        stdin: {\n          type: 'string',\n          description:\n            'Stdin input for tools with Liquid template support - optional for tool checks',\n        },\n        url: {\n          type: 'string',\n          description: 'HTTP URL - required for http output checks',\n        },\n        body: {\n          type: 'string',\n          description: 'HTTP body template (Liquid) - required for http output checks',\n        },\n        method: {\n          type: 'string',\n          description: 'HTTP method (defaults to POST)',\n        },\n        headers: {\n          $ref: '#/definitions/Record%3Cstring%2Cstring%3E',\n          description: 'HTTP headers',\n        },\n        endpoint: {\n          type: 'string',\n          description: 'HTTP endpoint path - required for http_input checks',\n        },\n        transform: {\n          type: 'string',\n          description: 'Transform template for http_input data (Liquid) - optional',\n        },\n        transform_js: {\n          type: 'string',\n          description:\n            'Transform using JavaScript expressions (evaluated in secure sandbox) - optional',\n        },\n        schedule: {\n          type: 'string',\n          description: 'Cron schedule expression (e.g., \"0 2 * * *\") - optional for any check type',\n        },\n        focus: {\n          type: 'string',\n          description:\n            'Focus area for the check (security/performance/style/architecture/all) - optional',\n        },\n        command: {\n          type: 'string',\n          description:\n            'Command that triggers this check (e.g., \"review\", \"security-scan\") - optional',\n        },\n        on: {\n          type: 'array',\n          items: {\n            $ref: '#/definitions/EventTrigger',\n          },\n          description: \"Events that trigger this check (defaults to ['manual'] if not specified)\",\n        },\n        triggers: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description: 'File patterns that trigger this check (optional)',\n        },\n        ai: {\n          $ref: '#/definitions/AIProviderConfig',\n          description: 'AI provider configuration (optional)',\n        },\n        ai_model: {\n          type: 'string',\n          description: 'AI model to use for this check - overrides global setting',\n        },\n        ai_provider: {\n          type: 'string',\n          description: 'AI provider to use for this check - overrides global setting',\n        },\n        ai_mcp_servers: {\n          $ref: '#/definitions/Record%3Cstring%2CMcpServerConfig%3E',\n          description: 'MCP servers for this AI check - overrides global setting',\n        },\n        claude_code: {\n          $ref: '#/definitions/ClaudeCodeConfig',\n          description: 'Claude Code configuration (for claude-code type checks)',\n        },\n        env: {\n          $ref: '#/definitions/EnvConfig',\n          description: 'Environment variables for this check',\n        },\n        timeout: {\n          type: 'number',\n          description: 'Timeout in seconds for command execution (default: 60)',\n        },\n        depends_on: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description: 'Check IDs that this check depends on (optional)',\n        },\n        group: {\n          type: 'string',\n          description:\n            'Group name for comment separation (e.g., \"code-review\", \"pr-overview\") - optional',\n        },\n        schema: {\n          anyOf: [\n            {\n              type: 'string',\n            },\n            {\n              $ref: '#/definitions/Record%3Cstring%2Cunknown%3E',\n            },\n          ],\n          description:\n            'Schema type for template rendering (e.g., \"code-review\", \"markdown\") or inline JSON schema object - optional',\n        },\n        template: {\n          $ref: '#/definitions/CustomTemplateConfig',\n          description: 'Custom template configuration - optional',\n        },\n        if: {\n          type: 'string',\n          description:\n            'Condition to determine if check should run - runs if expression evaluates to true',\n        },\n        reuse_ai_session: {\n          type: ['string', 'boolean'],\n          description:\n            'Check name to reuse AI session from, or true to use first dependency (only works with depends_on)',\n        },\n        session_mode: {\n          type: 'string',\n          enum: ['clone', 'append'],\n          description:\n            \"How to reuse AI session: 'clone' (default, copy history) or 'append' (share history)\",\n        },\n        fail_if: {\n          type: 'string',\n          description: 'Simple fail condition - fails check if expression evaluates to true',\n        },\n        failure_conditions: {\n          $ref: '#/definitions/FailureConditions',\n          description: 'Check-specific failure conditions - optional (deprecated, use fail_if)',\n        },\n        tags: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description:\n            'Tags for categorizing and filtering checks (e.g., [\"local\", \"fast\", \"security\"])',\n        },\n        forEach: {\n          type: 'boolean',\n          description: 'Process output as array and run dependent checks for each item',\n        },\n        fanout: {\n          type: 'string',\n          enum: ['map', 'reduce'],\n          description:\n            \"Control scheduling behavior when this check is triggered via routing (run/goto) from a forEach scope.\\n- 'map': schedule once per item (fan-out) using item scopes.\\n- 'reduce': schedule a single run at the parent scope (aggregation). If unset, the current default is a single run (reduce) for backward compatibility.\",\n        },\n        reduce: {\n          type: 'boolean',\n          description: \"Alias for fanout: 'reduce'\",\n        },\n        on_fail: {\n          $ref: '#/definitions/OnFailConfig',\n          description: 'Failure routing configuration for this check (retry/goto/run)',\n        },\n        on_success: {\n          $ref: '#/definitions/OnSuccessConfig',\n          description:\n            'Success routing configuration for this check (post-actions and optional goto)',\n        },\n        on_finish: {\n          $ref: '#/definitions/OnFinishConfig',\n          description:\n            'Finish routing configuration for forEach checks (runs after ALL iterations complete)',\n        },\n        message: {\n          type: 'string',\n          description: 'Message template for log checks',\n        },\n        level: {\n          type: 'string',\n          enum: ['debug', 'info', 'warn', 'error'],\n          description: 'Log level for log checks',\n        },\n        include_pr_context: {\n          type: 'boolean',\n          description: 'Include PR context in log output',\n        },\n        include_dependencies: {\n          type: 'boolean',\n          description: 'Include dependency summaries in log output',\n        },\n        include_metadata: {\n          type: 'boolean',\n          description: 'Include execution metadata in log output',\n        },\n        output_format: {\n          type: 'string',\n          enum: ['json', 'text'],\n          description:\n            \"Output parsing hint for command provider (optional) When set to 'json', command stdout is expected to be JSON. When 'text', treat as plain text. Note: command provider attempts JSON parsing heuristically; this flag mainly suppresses schema warnings and may be used by providers to alter parsing behavior in the future.\",\n        },\n        operation: {\n          type: 'string',\n          enum: ['get', 'set', 'append', 'increment', 'delete', 'clear', 'list', 'exec_js'],\n          description: 'Memory operation to perform',\n        },\n        key: {\n          type: 'string',\n          description: 'Key for memory operation',\n        },\n        value: {\n          description: 'Value for set/append operations',\n        },\n        value_js: {\n          type: 'string',\n          description: 'JavaScript expression to compute value dynamically',\n        },\n        memory_js: {\n          type: 'string',\n          description: 'JavaScript code for exec_js operation with full memory access',\n        },\n        namespace: {\n          type: 'string',\n          description: 'Override namespace for this check',\n        },\n        op: {\n          type: 'string',\n          description:\n            \"GitHub operation to perform (e.g., 'labels.add', 'labels.remove', 'comment.create')\",\n        },\n        values: {\n          anyOf: [\n            {\n              type: 'array',\n              items: {\n                type: 'string',\n              },\n            },\n            {\n              type: 'string',\n            },\n          ],\n          description: 'Values for GitHub operations (can be array or single value)',\n        },\n        transport: {\n          type: 'string',\n          enum: ['stdio', 'sse', 'http'],\n          description:\n            'Transport type for MCP: stdio (default), sse (legacy), or http (streamable HTTP)',\n        },\n        methodArgs: {\n          $ref: '#/definitions/Record%3Cstring%2Cunknown%3E',\n          description: 'Arguments to pass to the MCP method (supports Liquid templates)',\n        },\n        argsTransform: {\n          type: 'string',\n          description: 'Transform template for method arguments (Liquid)',\n        },\n        sessionId: {\n          type: 'string',\n          description: 'Session ID for HTTP transport (optional, server may generate one)',\n        },\n        args: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description: 'Command arguments (for stdio transport in MCP checks)',\n        },\n        workingDirectory: {\n          type: 'string',\n          description: 'Working directory (for stdio transport in MCP checks)',\n        },\n      },\n      additionalProperties: false,\n      description: 'Configuration for a single check',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    ConfigCheckType: {\n      type: 'string',\n      enum: [\n        'ai',\n        'command',\n        'http',\n        'http_input',\n        'http_client',\n        'noop',\n        'log',\n        'memory',\n        'github',\n        'claude-code',\n        'mcp',\n        'human-input',\n      ],\n      description: 'Valid check types in configuration',\n    },\n    'Record<string,string>': {\n      type: 'object',\n      additionalProperties: {\n        type: 'string',\n      },\n    },\n    EventTrigger: {\n      type: 'string',\n      enum: [\n        'pr_opened',\n        'pr_updated',\n        'pr_closed',\n        'issue_opened',\n        'issue_comment',\n        'manual',\n        'schedule',\n        'webhook_received',\n      ],\n      description: 'Valid event triggers for checks',\n    },\n    AIProviderConfig: {\n      type: 'object',\n      properties: {\n        provider: {\n          type: 'string',\n          enum: ['google', 'anthropic', 'openai', 'bedrock', 'mock'],\n          description: 'AI provider to use',\n        },\n        model: {\n          type: 'string',\n          description: 'Model name to use',\n        },\n        apiKey: {\n          type: 'string',\n          description: 'API key (usually from environment variables)',\n        },\n        timeout: {\n          type: 'number',\n          description: 'Request timeout in milliseconds',\n        },\n        debug: {\n          type: 'boolean',\n          description: 'Enable debug mode',\n        },\n        skip_code_context: {\n          type: 'boolean',\n          description: 'Skip adding code context (diffs, files, PR info) to the prompt',\n        },\n        disable_tools: {\n          type: 'boolean',\n          description: 'Disable MCP tools - AI will only have access to the prompt text',\n        },\n        mcpServers: {\n          $ref: '#/definitions/Record%3Cstring%2CMcpServerConfig%3E',\n          description: 'MCP servers configuration',\n        },\n      },\n      additionalProperties: false,\n      description: 'AI provider configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    'Record<string,McpServerConfig>': {\n      type: 'object',\n      additionalProperties: {\n        $ref: '#/definitions/McpServerConfig',\n      },\n    },\n    McpServerConfig: {\n      type: 'object',\n      properties: {\n        command: {\n          type: 'string',\n          description: 'Command to execute for the MCP server',\n        },\n        args: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description: 'Arguments to pass to the command',\n        },\n        env: {\n          $ref: '#/definitions/Record%3Cstring%2Cstring%3E',\n          description: 'Environment variables for the MCP server',\n        },\n      },\n      required: ['command'],\n      additionalProperties: false,\n      description: 'MCP Server configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    ClaudeCodeConfig: {\n      type: 'object',\n      properties: {\n        allowedTools: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description: 'List of allowed tools for Claude Code to use',\n        },\n        maxTurns: {\n          type: 'number',\n          description: 'Maximum number of turns in conversation',\n        },\n        systemPrompt: {\n          type: 'string',\n          description: 'System prompt for Claude Code',\n        },\n        mcpServers: {\n          $ref: '#/definitions/Record%3Cstring%2CMcpServerConfig%3E',\n          description: 'MCP servers configuration',\n        },\n        subagent: {\n          type: 'string',\n          description: 'Path to subagent script',\n        },\n        hooks: {\n          type: 'object',\n          properties: {\n            onStart: {\n              type: 'string',\n              description: 'Called when check starts',\n            },\n            onEnd: {\n              type: 'string',\n              description: 'Called when check ends',\n            },\n            onError: {\n              type: 'string',\n              description: 'Called when check encounters an error',\n            },\n          },\n          additionalProperties: false,\n          description: 'Event hooks for lifecycle management',\n          patternProperties: {\n            '^x-': {},\n          },\n        },\n      },\n      additionalProperties: false,\n      description: 'Claude Code configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    EnvConfig: {\n      type: 'object',\n      additionalProperties: {\n        type: ['string', 'number', 'boolean'],\n      },\n      description: 'Environment variable reference configuration',\n    },\n    'Record<string,unknown>': {\n      type: 'object',\n      additionalProperties: {},\n    },\n    CustomTemplateConfig: {\n      type: 'object',\n      properties: {\n        file: {\n          type: 'string',\n          description: 'Path to custom template file (relative to config file or absolute)',\n        },\n        content: {\n          type: 'string',\n          description: 'Raw template content as string',\n        },\n      },\n      additionalProperties: false,\n      description: 'Custom template configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    FailureConditions: {\n      type: 'object',\n      additionalProperties: {\n        $ref: '#/definitions/FailureCondition',\n      },\n      description: 'Collection of failure conditions',\n    },\n    FailureCondition: {\n      anyOf: [\n        {\n          $ref: '#/definitions/SimpleFailureCondition',\n        },\n        {\n          $ref: '#/definitions/ComplexFailureCondition',\n        },\n      ],\n      description: 'Failure condition - can be a simple expression string or complex object',\n    },\n    SimpleFailureCondition: {\n      type: 'string',\n      description: 'Simple failure condition - just an expression string',\n    },\n    ComplexFailureCondition: {\n      type: 'object',\n      properties: {\n        condition: {\n          type: 'string',\n          description: 'Expression to evaluate using Function Constructor',\n        },\n        message: {\n          type: 'string',\n          description: 'Human-readable message when condition is met',\n        },\n        severity: {\n          $ref: '#/definitions/FailureConditionSeverity',\n          description: 'Severity level of the failure',\n        },\n        halt_execution: {\n          type: 'boolean',\n          description: 'Whether this condition should halt execution',\n        },\n      },\n      required: ['condition'],\n      additionalProperties: false,\n      description: 'Complex failure condition with additional metadata',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    FailureConditionSeverity: {\n      type: 'string',\n      enum: ['error', 'warning', 'info'],\n      description: 'Failure condition severity levels',\n    },\n    OnFailConfig: {\n      type: 'object',\n      properties: {\n        retry: {\n          $ref: '#/definitions/RetryPolicy',\n          description: 'Retry policy',\n        },\n        run: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description: 'Remediation steps to run before reattempt',\n        },\n        goto: {\n          type: 'string',\n          description: 'Jump back to an ancestor step (by id)',\n        },\n        goto_event: {\n          $ref: '#/definitions/EventTrigger',\n          description: \"Simulate a different event when performing goto (e.g., 'pr_updated')\",\n        },\n        goto_js: {\n          type: 'string',\n          description: 'Dynamic goto: JS expression returning step id or null',\n        },\n        run_js: {\n          type: 'string',\n          description: 'Dynamic remediation list: JS expression returning string[]',\n        },\n      },\n      additionalProperties: false,\n      description: 'Failure routing configuration per check',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    RetryPolicy: {\n      type: 'object',\n      properties: {\n        max: {\n          type: 'number',\n          description: 'Maximum retry attempts (excluding the first attempt)',\n        },\n        backoff: {\n          $ref: '#/definitions/BackoffPolicy',\n          description: 'Backoff policy',\n        },\n      },\n      additionalProperties: false,\n      description: 'Retry policy for a step',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    BackoffPolicy: {\n      type: 'object',\n      properties: {\n        mode: {\n          type: 'string',\n          enum: ['fixed', 'exponential'],\n          description: 'Backoff mode',\n        },\n        delay_ms: {\n          type: 'number',\n          description: 'Initial delay in milliseconds',\n        },\n      },\n      additionalProperties: false,\n      description: 'Backoff policy for retries',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    OnSuccessConfig: {\n      type: 'object',\n      properties: {\n        run: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description: 'Post-success steps to run',\n        },\n        goto: {\n          type: 'string',\n          description: 'Optional jump back to ancestor step (by id)',\n        },\n        goto_event: {\n          $ref: '#/definitions/EventTrigger',\n          description: \"Simulate a different event when performing goto (e.g., 'pr_updated')\",\n        },\n        goto_js: {\n          type: 'string',\n          description: 'Dynamic goto: JS expression returning step id or null',\n        },\n        run_js: {\n          type: 'string',\n          description: 'Dynamic post-success steps: JS expression returning string[]',\n        },\n      },\n      additionalProperties: false,\n      description: 'Success routing configuration per check',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    OnFinishConfig: {\n      type: 'object',\n      properties: {\n        run: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description: 'Post-finish steps to run',\n        },\n        goto: {\n          type: 'string',\n          description: 'Optional jump back to ancestor step (by id)',\n        },\n        goto_event: {\n          $ref: '#/definitions/EventTrigger',\n          description: \"Simulate a different event when performing goto (e.g., 'pr_updated')\",\n        },\n        goto_js: {\n          type: 'string',\n          description: 'Dynamic goto: JS expression returning step id or null',\n        },\n        run_js: {\n          type: 'string',\n          description: 'Dynamic post-finish steps: JS expression returning string[]',\n        },\n      },\n      additionalProperties: false,\n      description:\n        'Finish routing configuration for forEach checks Runs once after ALL iterations of forEach and ALL dependent checks complete',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    OutputConfig: {\n      type: 'object',\n      properties: {\n        pr_comment: {\n          $ref: '#/definitions/PrCommentOutput',\n          description: 'PR comment configuration',\n        },\n        file_comment: {\n          $ref: '#/definitions/FileCommentOutput',\n          description: 'File comment configuration (optional)',\n        },\n        github_checks: {\n          $ref: '#/definitions/GitHubCheckOutput',\n          description: 'GitHub check runs configuration (optional)',\n        },\n        suppressionEnabled: {\n          type: 'boolean',\n          description:\n            'Whether to enable issue suppression via visor-disable comments (default: true)',\n        },\n      },\n      required: ['pr_comment'],\n      additionalProperties: false,\n      description: 'Output configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    PrCommentOutput: {\n      type: 'object',\n      properties: {\n        format: {\n          $ref: '#/definitions/ConfigOutputFormat',\n          description: 'Format of the output',\n        },\n        group_by: {\n          $ref: '#/definitions/GroupByOption',\n          description: 'How to group the results',\n        },\n        collapse: {\n          type: 'boolean',\n          description: 'Whether to collapse sections by default',\n        },\n        debug: {\n          $ref: '#/definitions/DebugConfig',\n          description: 'Debug mode configuration (optional)',\n        },\n      },\n      required: ['format', 'group_by', 'collapse'],\n      additionalProperties: false,\n      description: 'PR comment output configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    ConfigOutputFormat: {\n      type: 'string',\n      enum: ['table', 'json', 'markdown', 'sarif'],\n      description: 'Valid output formats',\n    },\n    GroupByOption: {\n      type: 'string',\n      enum: ['check', 'file', 'severity', 'group'],\n      description: 'Valid grouping options',\n    },\n    DebugConfig: {\n      type: 'object',\n      properties: {\n        enabled: {\n          type: 'boolean',\n          description: 'Enable debug mode',\n        },\n        includePrompts: {\n          type: 'boolean',\n          description: 'Include AI prompts in debug output',\n        },\n        includeRawResponses: {\n          type: 'boolean',\n          description: 'Include raw AI responses in debug output',\n        },\n        includeTiming: {\n          type: 'boolean',\n          description: 'Include timing information',\n        },\n        includeProviderInfo: {\n          type: 'boolean',\n          description: 'Include provider information',\n        },\n      },\n      required: [\n        'enabled',\n        'includePrompts',\n        'includeRawResponses',\n        'includeTiming',\n        'includeProviderInfo',\n      ],\n      additionalProperties: false,\n      description: 'Debug mode configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    FileCommentOutput: {\n      type: 'object',\n      properties: {\n        enabled: {\n          type: 'boolean',\n          description: 'Whether file comments are enabled',\n        },\n        inline: {\n          type: 'boolean',\n          description: 'Whether to show inline comments',\n        },\n      },\n      required: ['enabled', 'inline'],\n      additionalProperties: false,\n      description: 'File comment output configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    GitHubCheckOutput: {\n      type: 'object',\n      properties: {\n        enabled: {\n          type: 'boolean',\n          description: 'Whether GitHub check runs are enabled',\n        },\n        per_check: {\n          type: 'boolean',\n          description: 'Whether to create individual check runs per configured check',\n        },\n        name_prefix: {\n          type: 'string',\n          description: 'Custom name prefix for check runs',\n        },\n      },\n      required: ['enabled', 'per_check'],\n      additionalProperties: false,\n      description: 'GitHub Check Runs output configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    HttpServerConfig: {\n      type: 'object',\n      properties: {\n        enabled: {\n          type: 'boolean',\n          description: 'Whether HTTP server is enabled',\n        },\n        port: {\n          type: 'number',\n          description: 'Port to listen on',\n        },\n        host: {\n          type: 'string',\n          description: 'Host/IP to bind to (defaults to 0.0.0.0)',\n        },\n        tls: {\n          $ref: '#/definitions/TlsConfig',\n          description: 'TLS/SSL configuration for HTTPS',\n        },\n        auth: {\n          $ref: '#/definitions/HttpAuthConfig',\n          description: 'Authentication configuration',\n        },\n        endpoints: {\n          type: 'array',\n          items: {\n            $ref: '#/definitions/HttpEndpointConfig',\n          },\n          description: 'HTTP endpoints configuration',\n        },\n      },\n      required: ['enabled', 'port'],\n      additionalProperties: false,\n      description: 'HTTP server configuration for receiving webhooks',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    TlsConfig: {\n      type: 'object',\n      properties: {\n        enabled: {\n          type: 'boolean',\n          description: 'Enable TLS/HTTPS',\n        },\n        cert: {\n          type: 'string',\n          description: 'Path to TLS certificate file or certificate content',\n        },\n        key: {\n          type: 'string',\n          description: 'Path to TLS key file or key content',\n        },\n        ca: {\n          type: 'string',\n          description: 'Path to CA certificate file or CA content (optional)',\n        },\n        rejectUnauthorized: {\n          type: 'boolean',\n          description: 'Reject unauthorized connections (default: true)',\n        },\n      },\n      required: ['enabled'],\n      additionalProperties: false,\n      description: 'TLS/SSL configuration for HTTPS server',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    HttpAuthConfig: {\n      type: 'object',\n      properties: {\n        type: {\n          type: 'string',\n          enum: ['bearer_token', 'hmac', 'basic', 'none'],\n          description: 'Authentication type',\n        },\n        secret: {\n          type: 'string',\n          description: 'Secret or token for authentication',\n        },\n        username: {\n          type: 'string',\n          description: 'Username for basic auth',\n        },\n        password: {\n          type: 'string',\n          description: 'Password for basic auth',\n        },\n      },\n      required: ['type'],\n      additionalProperties: false,\n      description: 'HTTP server authentication configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    HttpEndpointConfig: {\n      type: 'object',\n      properties: {\n        path: {\n          type: 'string',\n          description: 'Path for the webhook endpoint',\n        },\n        transform: {\n          type: 'string',\n          description: 'Optional transform template (Liquid) for the received data',\n        },\n        name: {\n          type: 'string',\n          description: 'Optional name/ID for this endpoint',\n        },\n      },\n      required: ['path'],\n      additionalProperties: false,\n      description: 'HTTP server endpoint configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    MemoryConfig: {\n      type: 'object',\n      properties: {\n        storage: {\n          type: 'string',\n          enum: ['memory', 'file'],\n          description: 'Storage mode: \"memory\" (in-memory, default) or \"file\" (persistent)',\n        },\n        format: {\n          type: 'string',\n          enum: ['json', 'csv'],\n          description: 'Storage format (only for file storage, default: json)',\n        },\n        file: {\n          type: 'string',\n          description: 'File path (required if storage: file)',\n        },\n        namespace: {\n          type: 'string',\n          description: 'Default namespace (default: \"default\")',\n        },\n        auto_load: {\n          type: 'boolean',\n          description: 'Auto-load on startup (default: true if storage: file)',\n        },\n        auto_save: {\n          type: 'boolean',\n          description: 'Auto-save after operations (default: true if storage: file)',\n        },\n      },\n      additionalProperties: false,\n      description: 'Memory storage configuration',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    TagFilter: {\n      type: 'object',\n      properties: {\n        include: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description: 'Tags that checks must have to be included (ANY match)',\n        },\n        exclude: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          description: 'Tags that will exclude checks if present (ANY match)',\n        },\n      },\n      additionalProperties: false,\n      description: 'Tag filter configuration for selective check execution',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n    RoutingDefaults: {\n      type: 'object',\n      properties: {\n        max_loops: {\n          type: 'number',\n          description: 'Per-scope cap on routing transitions (success + failure)',\n        },\n        defaults: {\n          type: 'object',\n          properties: {\n            on_fail: {\n              $ref: '#/definitions/OnFailConfig',\n            },\n          },\n          additionalProperties: false,\n          description: 'Default policies applied to checks (step-level overrides take precedence)',\n          patternProperties: {\n            '^x-': {},\n          },\n        },\n      },\n      additionalProperties: false,\n      description: 'Global routing defaults',\n      patternProperties: {\n        '^x-': {},\n      },\n    },\n  },\n} as const;\nexport default configSchema;\n","/*\n Thin SDK façade for programmatic use of Visor.\n - No new execution logic; delegates to existing engine and config manager.\n - Dual ESM/CJS bundle via tsup.\n*/\n\nimport { CheckExecutionEngine } from './check-execution-engine';\nimport { ConfigManager } from './config';\nimport type { AnalysisResult } from './output-formatters';\nimport type { VisorConfig, TagFilter, HumanInputRequest } from './types/config';\nimport type { ExecutionContext } from './providers/check-provider.interface';\n\nexport type { VisorConfig, TagFilter, HumanInputRequest, ExecutionContext };\n\nexport interface VisorOptions {\n  cwd?: string;\n  debug?: boolean;\n  maxParallelism?: number;\n  failFast?: boolean;\n  tagFilter?: TagFilter;\n}\n\nexport interface RunOptions extends VisorOptions {\n  config?: VisorConfig;\n  configPath?: string;\n  checks?: string[]; // default: all checks from config\n  timeoutMs?: number;\n  output?: { format?: 'table' | 'json' | 'markdown' | 'sarif' };\n  /** Strict mode: treat config warnings (like unknown keys) as errors (default: false) */\n  strictValidation?: boolean;\n  /** Execution context for providers (CLI message, hooks, etc.) */\n  executionContext?: ExecutionContext;\n}\n\n/**\n * Load and validate a Visor config.\n * @param configOrPath - Config object, file path, or omit to discover defaults\n * @param options - Validation options\n * @returns Validated config with defaults applied\n */\nexport async function loadConfig(\n  configOrPath?: string | Partial<VisorConfig>,\n  options?: { strict?: boolean }\n): Promise<VisorConfig> {\n  const cm = new ConfigManager();\n\n  // If it's an object, validate and return with defaults\n  if (typeof configOrPath === 'object' && configOrPath !== null) {\n    cm.validateConfig(configOrPath, options?.strict ?? false);\n\n    // Apply lightweight defaults without expensive file system operations\n    const defaultConfig: Partial<VisorConfig> = {\n      version: '1.0',\n      checks: {},\n      max_parallelism: 3,\n      fail_fast: false,\n    };\n\n    return {\n      ...defaultConfig,\n      ...configOrPath,\n      checks: configOrPath.checks || {},\n    } as VisorConfig;\n  }\n\n  // If it's a string, load from file\n  if (typeof configOrPath === 'string') {\n    return cm.loadConfig(configOrPath);\n  }\n\n  // Otherwise discover default config file\n  return cm.findAndLoadConfig();\n}\n\n/** Expand check IDs by including their dependencies (shallow->deep). */\nexport function resolveChecks(checkIds: string[], config: VisorConfig | undefined): string[] {\n  if (!config?.checks) return Array.from(new Set(checkIds));\n  const resolved = new Set<string>();\n  const visiting = new Set<string>();\n  const result: string[] = [];\n\n  const dfs = (id: string, stack: string[] = []) => {\n    if (resolved.has(id)) return;\n    if (visiting.has(id)) {\n      const cycle = [...stack, id].join(' -> ');\n      throw new Error(`Circular dependency detected involving check: ${id} (path: ${cycle})`);\n    }\n    visiting.add(id);\n    const deps = config.checks![id]?.depends_on || [];\n    for (const d of deps) dfs(d, [...stack, id]);\n    if (!result.includes(id)) result.push(id);\n    visiting.delete(id);\n    resolved.add(id);\n  };\n\n  for (const id of checkIds) dfs(id);\n  return result;\n}\n\n/**\n * Run Visor checks programmatically. Returns the same AnalysisResult shape used by the CLI.\n * Thin wrapper around CheckExecutionEngine.executeChecks.\n */\nexport async function runChecks(opts: RunOptions = {}): Promise<AnalysisResult> {\n  const cm = new ConfigManager();\n  let config: VisorConfig;\n\n  if (opts.config) {\n    // Validate manually constructed config\n    // In strict mode, unknown keys are treated as errors\n    cm.validateConfig(opts.config, opts.strictValidation ?? false);\n    config = opts.config;\n  } else if (opts.configPath) {\n    config = await cm.loadConfig(opts.configPath);\n  } else {\n    config = await cm.findAndLoadConfig();\n  }\n\n  const checks =\n    opts.checks && opts.checks.length > 0\n      ? resolveChecks(opts.checks, config)\n      : Object.keys(config.checks || {});\n\n  const engine = new CheckExecutionEngine(opts.cwd);\n\n  // Set execution context if provided\n  if (opts.executionContext) {\n    engine.setExecutionContext(opts.executionContext);\n  }\n\n  const result = await engine.executeChecks({\n    checks,\n    workingDirectory: opts.cwd,\n    timeout: opts.timeoutMs,\n    maxParallelism: opts.maxParallelism,\n    failFast: opts.failFast,\n    outputFormat: opts.output?.format,\n    config,\n    debug: opts.debug,\n    tagFilter: opts.tagFilter,\n  });\n\n  return result;\n}\n","import * as yaml from 'js-yaml';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { logger } from './logger';\nimport simpleGit from 'simple-git';\nimport {\n  VisorConfig,\n  CheckConfig,\n  ConfigCheckType,\n  EventTrigger,\n  ConfigOutputFormat,\n  GroupByOption,\n  ConfigValidationError,\n  EnvironmentOverrides,\n  MergedConfig,\n  ConfigLoadOptions,\n} from './types/config';\nimport { CliOptions } from './types/cli';\nimport { ConfigLoader, ConfigLoaderOptions } from './utils/config-loader';\nimport { ConfigMerger } from './utils/config-merger';\nimport Ajv from 'ajv';\nimport addFormats from 'ajv-formats';\n\n/**\n * Valid event triggers for checks\n * Exported as a constant to serve as the single source of truth for event validation\n */\nexport const VALID_EVENT_TRIGGERS: readonly EventTrigger[] = [\n  'pr_opened',\n  'pr_updated',\n  'pr_closed',\n  'issue_opened',\n  'issue_comment',\n  'manual',\n  'schedule',\n  'webhook_received',\n] as const;\n\n/**\n * Configuration manager for Visor\n */\nexport class ConfigManager {\n  private validCheckTypes: ConfigCheckType[] = [\n    'ai',\n    'claude-code',\n    'mcp',\n    'command',\n    'http',\n    'http_input',\n    'http_client',\n    'memory',\n    'noop',\n    'log',\n    'github',\n    'human-input',\n  ];\n  private validEventTriggers: EventTrigger[] = [...VALID_EVENT_TRIGGERS];\n  private validOutputFormats: ConfigOutputFormat[] = ['table', 'json', 'markdown', 'sarif'];\n  private validGroupByOptions: GroupByOption[] = ['check', 'file', 'severity', 'group'];\n\n  /**\n   * Load configuration from a file\n   */\n  public async loadConfig(\n    configPath: string,\n    options: ConfigLoadOptions = {}\n  ): Promise<VisorConfig> {\n    const { validate = true, mergeDefaults = true, allowedRemotePatterns } = options;\n\n    // Resolve relative paths to absolute paths based on current working directory\n    const resolvedPath = path.isAbsolute(configPath)\n      ? configPath\n      : path.resolve(process.cwd(), configPath);\n\n    try {\n      if (!fs.existsSync(resolvedPath)) {\n        throw new Error(`Configuration file not found: ${resolvedPath}`);\n      }\n\n      const configContent = fs.readFileSync(resolvedPath, 'utf8');\n      let parsedConfig: Partial<VisorConfig>;\n\n      try {\n        parsedConfig = yaml.load(configContent) as Partial<VisorConfig>;\n      } catch (yamlError) {\n        const errorMessage = yamlError instanceof Error ? yamlError.message : String(yamlError);\n        throw new Error(`Invalid YAML syntax in ${resolvedPath}: ${errorMessage}`);\n      }\n\n      if (!parsedConfig || typeof parsedConfig !== 'object') {\n        throw new Error('Configuration file must contain a valid YAML object');\n      }\n\n      // Handle extends directive if present\n      if (parsedConfig.extends) {\n        const loaderOptions: ConfigLoaderOptions = {\n          baseDir: path.dirname(resolvedPath),\n          allowRemote: this.isRemoteExtendsAllowed(),\n          maxDepth: 10,\n          allowedRemotePatterns,\n        };\n\n        const loader = new ConfigLoader(loaderOptions);\n        const merger = new ConfigMerger();\n\n        // Process extends\n        const extends_ = Array.isArray(parsedConfig.extends)\n          ? parsedConfig.extends\n          : [parsedConfig.extends];\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { extends: _extendsField, ...configWithoutExtends } = parsedConfig;\n\n        // Load and merge all parent configurations\n        let mergedConfig: Partial<VisorConfig> = {};\n        for (const source of extends_) {\n          console.log(`📦 Extending from: ${source}`);\n          const parentConfig = await loader.fetchConfig(source);\n          mergedConfig = merger.merge(mergedConfig, parentConfig);\n        }\n\n        // Merge with current config (child overrides parent)\n        parsedConfig = merger.merge(mergedConfig, configWithoutExtends);\n\n        // Remove disabled checks (those with empty 'on' array)\n        parsedConfig = merger.removeDisabledChecks(parsedConfig);\n      }\n\n      // Normalize 'checks' and 'steps' - support both keys for backward compatibility\n      parsedConfig = this.normalizeStepsAndChecks(parsedConfig);\n\n      if (validate) {\n        this.validateConfig(parsedConfig);\n      }\n\n      let finalConfig = parsedConfig;\n      if (mergeDefaults) {\n        finalConfig = this.mergeWithDefaults(parsedConfig);\n      }\n\n      return finalConfig as VisorConfig;\n    } catch (error) {\n      if (error instanceof Error) {\n        // Pass through detailed error messages unchanged\n        if (\n          error.message.includes('not found') ||\n          error.message.includes('Invalid YAML') ||\n          error.message.includes('extends') ||\n          error.message.includes('EACCES') ||\n          error.message.includes('EISDIR')\n        ) {\n          throw error;\n        }\n        // Add more context for generic errors\n        if (error.message.includes('ENOENT')) {\n          throw new Error(`Configuration file not found: ${resolvedPath}`);\n        }\n        if (error.message.includes('EPERM')) {\n          throw new Error(`Permission denied reading configuration file: ${resolvedPath}`);\n        }\n        throw new Error(`Failed to read configuration file ${resolvedPath}: ${error.message}`);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Find and load configuration from default locations\n   */\n  public async findAndLoadConfig(options: ConfigLoadOptions = {}): Promise<VisorConfig> {\n    // Try to find the git repository root first, fall back to current directory\n    const gitRoot = await this.findGitRepositoryRoot();\n    const searchDirs = [gitRoot, process.cwd()].filter(Boolean) as string[];\n\n    for (const baseDir of searchDirs) {\n      const possiblePaths = [path.join(baseDir, '.visor.yaml'), path.join(baseDir, '.visor.yml')];\n\n      for (const configPath of possiblePaths) {\n        if (fs.existsSync(configPath)) {\n          return this.loadConfig(configPath, options);\n        }\n      }\n    }\n\n    // Try to load bundled default config\n    const bundledConfig = this.loadBundledDefaultConfig();\n    if (bundledConfig) {\n      return bundledConfig;\n    }\n\n    // Return minimal default config if no bundled config found\n    return this.getDefaultConfig();\n  }\n\n  /**\n   * Find the git repository root directory\n   */\n  private async findGitRepositoryRoot(): Promise<string | null> {\n    try {\n      const git = simpleGit();\n      const isRepo = await git.checkIsRepo();\n      if (!isRepo) {\n        return null;\n      }\n\n      // Get the repository root directory\n      const rootDir = await git.revparse(['--show-toplevel']);\n      return rootDir.trim();\n    } catch {\n      // Not in a git repository or git not available\n      return null;\n    }\n  }\n\n  /**\n   * Get default configuration\n   */\n  public async getDefaultConfig(): Promise<VisorConfig> {\n    return {\n      version: '1.0',\n      steps: {},\n      checks: {}, // Keep for backward compatibility\n      max_parallelism: 3,\n      output: {\n        pr_comment: {\n          format: 'markdown',\n          group_by: 'check',\n          collapse: true,\n        },\n      },\n    };\n  }\n\n  /**\n   * Load bundled default configuration from the package\n   */\n  public loadBundledDefaultConfig(): VisorConfig | null {\n    try {\n      // Try different paths to find the bundled default config (support CJS and ESM)\n      const possiblePaths: string[] = [];\n\n      // __dirname is available in CJS; guard for ESM builds\n      if (typeof __dirname !== 'undefined') {\n        possiblePaths.push(\n          path.join(__dirname, 'defaults', '.visor.yaml'),\n          path.join(__dirname, '..', 'defaults', '.visor.yaml')\n        );\n      }\n\n      // Try via package root\n      const pkgRoot = this.findPackageRoot();\n      if (pkgRoot) {\n        possiblePaths.push(path.join(pkgRoot, 'defaults', '.visor.yaml'));\n      }\n\n      // GitHub Action environment variable\n      if (process.env.GITHUB_ACTION_PATH) {\n        possiblePaths.push(\n          path.join(process.env.GITHUB_ACTION_PATH, 'defaults', '.visor.yaml'),\n          path.join(process.env.GITHUB_ACTION_PATH, 'dist', 'defaults', '.visor.yaml')\n        );\n      }\n\n      let bundledConfigPath: string | undefined;\n      for (const possiblePath of possiblePaths) {\n        if (fs.existsSync(possiblePath)) {\n          bundledConfigPath = possiblePath;\n          break;\n        }\n      }\n\n      if (bundledConfigPath && fs.existsSync(bundledConfigPath)) {\n        // Always log to stderr to avoid contaminating formatted output\n        console.error(`📦 Loading bundled default configuration from ${bundledConfigPath}`);\n        const configContent = fs.readFileSync(bundledConfigPath, 'utf8');\n        let parsedConfig = yaml.load(configContent) as Partial<VisorConfig>;\n\n        if (!parsedConfig || typeof parsedConfig !== 'object') {\n          return null;\n        }\n\n        // Normalize 'checks' and 'steps' for backward compatibility\n        parsedConfig = this.normalizeStepsAndChecks(parsedConfig);\n\n        // Validate and merge with defaults\n        this.validateConfig(parsedConfig);\n        return this.mergeWithDefaults(parsedConfig) as VisorConfig;\n      }\n    } catch (error) {\n      // Silently fail and return null - will fall back to minimal default\n      console.warn(\n        'Failed to load bundled default config:',\n        error instanceof Error ? error.message : String(error)\n      );\n    }\n\n    return null;\n  }\n\n  /**\n   * Find the root directory of the Visor package\n   */\n  private findPackageRoot(): string | null {\n    let currentDir = __dirname;\n\n    // Walk up the directory tree to find package.json\n    while (currentDir !== path.dirname(currentDir)) {\n      const packageJsonPath = path.join(currentDir, 'package.json');\n      if (fs.existsSync(packageJsonPath)) {\n        try {\n          const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));\n          // Check if this is the Visor package\n          if (packageJson.name === '@probelabs/visor') {\n            return currentDir;\n          }\n        } catch {\n          // Continue searching if package.json is invalid\n        }\n      }\n      currentDir = path.dirname(currentDir);\n    }\n\n    return null;\n  }\n\n  /**\n   * Normalize 'checks' and 'steps' keys for backward compatibility\n   * Ensures both keys are present and contain the same data\n   */\n  private normalizeStepsAndChecks(config: Partial<VisorConfig>): Partial<VisorConfig> {\n    // If both are present, 'steps' takes precedence\n    if (config.steps && config.checks) {\n      // Use steps as the source of truth\n      config.checks = config.steps;\n    } else if (config.steps && !config.checks) {\n      // Copy steps to checks for internal compatibility\n      config.checks = config.steps;\n    } else if (config.checks && !config.steps) {\n      // Copy checks to steps for forward compatibility\n      config.steps = config.checks;\n    }\n\n    return config;\n  }\n\n  /**\n   * Merge configuration with CLI options\n   */\n  public mergeWithCliOptions(config: Partial<VisorConfig>, cliOptions: CliOptions): MergedConfig {\n    // Apply CLI overrides to the config\n    const mergedConfig = { ...config };\n\n    // Override max_parallelism if specified in CLI\n    if (cliOptions.maxParallelism !== undefined) {\n      mergedConfig.max_parallelism = cliOptions.maxParallelism;\n    }\n\n    // Override fail_fast if specified in CLI\n    if (cliOptions.failFast !== undefined) {\n      mergedConfig.fail_fast = cliOptions.failFast;\n    }\n\n    return {\n      config: mergedConfig,\n      cliChecks: cliOptions.checks || [],\n      cliOutput: cliOptions.output || 'table',\n    };\n  }\n\n  /**\n   * Load configuration with environment variable overrides\n   */\n  public async loadConfigWithEnvOverrides(): Promise<{\n    config?: VisorConfig;\n    environmentOverrides: EnvironmentOverrides;\n  }> {\n    const environmentOverrides: EnvironmentOverrides = {};\n\n    // Check for environment variable overrides\n    if (process.env.VISOR_CONFIG_PATH) {\n      environmentOverrides.configPath = process.env.VISOR_CONFIG_PATH;\n    }\n    if (process.env.VISOR_OUTPUT_FORMAT) {\n      environmentOverrides.outputFormat = process.env.VISOR_OUTPUT_FORMAT;\n    }\n\n    let config: VisorConfig | undefined;\n\n    if (environmentOverrides.configPath) {\n      try {\n        config = await this.loadConfig(environmentOverrides.configPath);\n      } catch {\n        // If environment config fails, fall back to default discovery\n        config = await this.findAndLoadConfig();\n      }\n    } else {\n      config = await this.findAndLoadConfig();\n    }\n\n    return { config, environmentOverrides };\n  }\n\n  /**\n   * Validate configuration against schema\n   * @param config The config to validate\n   * @param strict If true, treat warnings as errors (default: false)\n   */\n  public validateConfig(config: Partial<VisorConfig>, strict = false): void {\n    const errors: ConfigValidationError[] = [];\n    const warnings: ConfigValidationError[] = [];\n\n    // First, run schema-based validation (runtime-generated).\n    // Unknown keys become schema errors (we convert additionalProperties to warnings by default).\n    this.validateWithAjvSchema(config, errors, warnings);\n\n    // Validate required fields\n    if (!config.version) {\n      errors.push({\n        field: 'version',\n        message: 'Missing required field: version',\n      });\n    }\n\n    // Unknown key warnings are produced by Ajv using the pre-generated schema.\n\n    // Validate that either 'checks' or 'steps' is present\n    if (!config.checks && !config.steps) {\n      errors.push({\n        field: 'checks/steps',\n        message:\n          'Missing required field: either \"checks\" or \"steps\" must be defined. \"steps\" is recommended for new configurations.',\n      });\n    }\n\n    // Use normalized checks for validation (both should be present after normalization)\n    const checksToValidate = config.checks || config.steps;\n    if (checksToValidate) {\n      // Validate each check configuration\n      for (const [checkName, checkConfig] of Object.entries(checksToValidate)) {\n        // Default type to 'ai' if not specified\n        if (!checkConfig.type) {\n          checkConfig.type = 'ai';\n        }\n        // 'on' field is optional - if not specified, check can run on any event\n        this.validateCheckConfig(checkName, checkConfig, errors, config);\n\n        // Unknown/typo keys at the check level are produced by Ajv.\n\n        // Validate MCP servers at check-level (basic shape only)\n        if (checkConfig.ai_mcp_servers) {\n          this.validateMcpServersObject(\n            checkConfig.ai_mcp_servers,\n            `checks.${checkName}.ai_mcp_servers`,\n            errors,\n            warnings\n          );\n        }\n        if ((checkConfig as CheckConfig).ai?.mcpServers) {\n          this.validateMcpServersObject(\n            (checkConfig as CheckConfig).ai!.mcpServers as Record<string, unknown>,\n            `checks.${checkName}.ai.mcpServers`,\n            errors,\n            warnings\n          );\n        }\n        // 3) Precedence warning if both are provided\n        if (checkConfig.ai_mcp_servers && (checkConfig as CheckConfig).ai?.mcpServers) {\n          const lower = Object.keys(checkConfig.ai_mcp_servers);\n          const higher = Object.keys((checkConfig as CheckConfig).ai!.mcpServers!);\n          const overridden = lower.filter(k => higher.includes(k));\n          warnings.push({\n            field: `checks.${checkName}.ai.mcpServers`,\n            message:\n              overridden.length > 0\n                ? `Both ai_mcp_servers and ai.mcpServers are set; ai.mcpServers overrides these servers: ${overridden.join(\n                    ', '\n                  )}`\n                : 'Both ai_mcp_servers and ai.mcpServers are set; ai.mcpServers takes precedence for this check.',\n          });\n        }\n\n        // Type-specific guidance for MCP placement to avoid silent ignores\n        try {\n          const anyCheck = checkConfig as unknown as Record<string, unknown>;\n          const aiObj = (anyCheck.ai as Record<string, unknown>) || undefined;\n          const hasBareMcpAtCheck = Object.prototype.hasOwnProperty.call(anyCheck, 'mcpServers');\n          const hasAiMcp = aiObj && Object.prototype.hasOwnProperty.call(aiObj, 'mcpServers');\n          const hasClaudeCodeMcp =\n            anyCheck.claude_code &&\n            typeof anyCheck.claude_code === 'object' &&\n            Object.prototype.hasOwnProperty.call(\n              anyCheck.claude_code as Record<string, unknown>,\n              'mcpServers'\n            );\n\n          if (checkConfig.type === 'ai') {\n            if (hasBareMcpAtCheck) {\n              warnings.push({\n                field: `checks.${checkName}.mcpServers`,\n                message:\n                  \"'mcpServers' at the check root is ignored for type 'ai'. Use 'ai.mcpServers' or 'ai_mcp_servers' instead.\",\n                value: (anyCheck as any).mcpServers,\n              });\n            }\n            if (hasClaudeCodeMcp) {\n              warnings.push({\n                field: `checks.${checkName}.claude_code.mcpServers`,\n                message:\n                  \"'claude_code.mcpServers' is ignored for type 'ai'. Use 'ai.mcpServers' or 'ai_mcp_servers' instead.\",\n              });\n            }\n          }\n\n          if (checkConfig.type === 'claude-code') {\n            if (hasAiMcp || checkConfig.ai_mcp_servers) {\n              warnings.push({\n                field: hasAiMcp\n                  ? `checks.${checkName}.ai.mcpServers`\n                  : `checks.${checkName}.ai_mcp_servers`,\n                message:\n                  \"For type 'claude-code', MCP must be configured under 'claude_code.mcpServers'. 'ai.mcpServers' and 'ai_mcp_servers' are ignored for this check.\",\n              });\n            }\n          }\n        } catch {\n          // best-effort hints; never fail validation here\n        }\n      }\n    }\n\n    // Validate global MCP servers if present\n    if (config.ai_mcp_servers) {\n      this.validateMcpServersObject(config.ai_mcp_servers, 'ai_mcp_servers', errors, warnings);\n    }\n\n    // Validate output configuration if present\n    if (config.output) {\n      this.validateOutputConfig(config.output as unknown as Record<string, unknown>, errors);\n    }\n\n    // Validate HTTP server configuration if present\n    if (config.http_server) {\n      this.validateHttpServerConfig(\n        config.http_server as unknown as Record<string, unknown>,\n        errors\n      );\n    }\n\n    // Validate max_parallelism if present\n    if (config.max_parallelism !== undefined) {\n      if (\n        typeof config.max_parallelism !== 'number' ||\n        config.max_parallelism < 1 ||\n        !Number.isInteger(config.max_parallelism)\n      ) {\n        errors.push({\n          field: 'max_parallelism',\n          message: 'max_parallelism must be a positive integer (minimum 1)',\n          value: config.max_parallelism,\n        });\n      }\n    }\n\n    // Validate tag_filter if present\n    if (config.tag_filter) {\n      this.validateTagFilter(config.tag_filter as unknown as Record<string, unknown>, errors);\n    }\n\n    // In strict mode, treat warnings as errors\n    if (strict && warnings.length > 0) {\n      errors.push(...warnings);\n    }\n\n    if (errors.length > 0) {\n      throw new Error(errors[0].message);\n    }\n\n    // Emit warnings (do not block execution) - only in non-strict mode\n    if (!strict && warnings.length > 0) {\n      for (const w of warnings) {\n        logger.warn(`⚠️  Config warning [${w.field}]: ${w.message}`);\n      }\n    }\n  }\n\n  /**\n   * Validate individual check configuration\n   */\n  private validateCheckConfig(\n    checkName: string,\n    checkConfig: CheckConfig,\n    errors: ConfigValidationError[],\n    config?: Partial<VisorConfig>\n  ): void {\n    // Default to 'ai' if no type specified\n    if (!checkConfig.type) {\n      checkConfig.type = 'ai';\n    }\n    // Backward-compat alias: accept 'logger' as 'log'\n    if ((checkConfig as any).type === 'logger') {\n      (checkConfig as any).type = 'log';\n    }\n\n    if (!this.validCheckTypes.includes(checkConfig.type)) {\n      errors.push({\n        field: `checks.${checkName}.type`,\n        message: `Invalid check type \"${checkConfig.type}\". Must be: ${this.validCheckTypes.join(', ')}`,\n        value: checkConfig.type,\n      });\n    }\n\n    // Only AI checks require prompts\n    if (checkConfig.type === 'ai' && !checkConfig.prompt) {\n      errors.push({\n        field: `checks.${checkName}.prompt`,\n        message: `Invalid check configuration for \"${checkName}\": missing prompt (required for AI checks)`,\n      });\n    }\n\n    // Command checks require exec field\n    if (checkConfig.type === 'command' && !checkConfig.exec) {\n      errors.push({\n        field: `checks.${checkName}.exec`,\n        message: `Invalid check configuration for \"${checkName}\": missing exec field (required for command checks)`,\n      });\n    }\n\n    // HTTP output checks require url and body fields\n    if (checkConfig.type === 'http') {\n      if (!checkConfig.url) {\n        errors.push({\n          field: `checks.${checkName}.url`,\n          message: `Invalid check configuration for \"${checkName}\": missing url field (required for http checks)`,\n        });\n      }\n      if (!checkConfig.body) {\n        errors.push({\n          field: `checks.${checkName}.body`,\n          message: `Invalid check configuration for \"${checkName}\": missing body field (required for http checks)`,\n        });\n      }\n    }\n\n    // Note: Do not add special-case validation for log 'message' here.\n    // Schema (Ajv) permits 'message' and related keys; provider enforces at execution time.\n\n    // HTTP input checks require endpoint field\n    if (checkConfig.type === 'http_input' && !checkConfig.endpoint) {\n      errors.push({\n        field: `checks.${checkName}.endpoint`,\n        message: `Invalid check configuration for \"${checkName}\": missing endpoint field (required for http_input checks)`,\n      });\n    }\n\n    // HTTP client checks require url field\n    if (checkConfig.type === 'http_client' && !checkConfig.url) {\n      errors.push({\n        field: `checks.${checkName}.url`,\n        message: `Invalid check configuration for \"${checkName}\": missing url field (required for http_client checks)`,\n      });\n    }\n\n    // Validate cron schedule if specified\n    if (checkConfig.schedule) {\n      // Basic cron validation - could use node-cron.validate() for better validation\n      const cronParts = checkConfig.schedule.split(' ');\n      if (cronParts.length < 5 || cronParts.length > 6) {\n        errors.push({\n          field: `checks.${checkName}.schedule`,\n          message: `Invalid cron expression for \"${checkName}\": ${checkConfig.schedule}`,\n          value: checkConfig.schedule,\n        });\n      }\n    }\n\n    // 'on' field is optional - if not specified, check can be triggered by any event\n    if (checkConfig.on) {\n      if (!Array.isArray(checkConfig.on)) {\n        errors.push({\n          field: `checks.${checkName}.on`,\n          message: `Invalid check configuration for \"${checkName}\": 'on' field must be an array`,\n        });\n      } else {\n        // Validate event triggers\n        for (const event of checkConfig.on) {\n          if (!this.validEventTriggers.includes(event)) {\n            errors.push({\n              field: `checks.${checkName}.on`,\n              message: `Invalid event \"${event}\". Must be one of: ${this.validEventTriggers.join(', ')}`,\n              value: event,\n            });\n          }\n        }\n      }\n    }\n\n    // Validate reuse_ai_session configuration\n    if (checkConfig.reuse_ai_session !== undefined) {\n      const isString = typeof checkConfig.reuse_ai_session === 'string';\n      const isBoolean = typeof checkConfig.reuse_ai_session === 'boolean';\n\n      if (!isString && !isBoolean) {\n        errors.push({\n          field: `checks.${checkName}.reuse_ai_session`,\n          message: `Invalid reuse_ai_session value for \"${checkName}\": must be string (check name) or boolean`,\n          value: checkConfig.reuse_ai_session,\n        });\n      } else if (isString) {\n        // When reuse_ai_session is a string, it must refer to a valid check\n        const targetCheckName = checkConfig.reuse_ai_session as string;\n        if (!config?.checks || !config.checks[targetCheckName]) {\n          errors.push({\n            field: `checks.${checkName}.reuse_ai_session`,\n            message: `Check \"${checkName}\" references non-existent check \"${targetCheckName}\" for session reuse`,\n            value: checkConfig.reuse_ai_session,\n          });\n        }\n      } else if (checkConfig.reuse_ai_session === true) {\n        // When reuse_ai_session is true, depends_on must be specified and non-empty\n        if (\n          !checkConfig.depends_on ||\n          !Array.isArray(checkConfig.depends_on) ||\n          checkConfig.depends_on.length === 0\n        ) {\n          errors.push({\n            field: `checks.${checkName}.reuse_ai_session`,\n            message: `Check \"${checkName}\" has reuse_ai_session=true but missing or empty depends_on. Session reuse requires dependency on another check.`,\n            value: checkConfig.reuse_ai_session,\n          });\n        }\n      }\n    }\n\n    // Validate session_mode configuration\n    if (checkConfig.session_mode !== undefined) {\n      if (checkConfig.session_mode !== 'clone' && checkConfig.session_mode !== 'append') {\n        errors.push({\n          field: `checks.${checkName}.session_mode`,\n          message: `Invalid session_mode value for \"${checkName}\": must be 'clone' or 'append'`,\n          value: checkConfig.session_mode,\n        });\n      }\n\n      // session_mode only makes sense with reuse_ai_session\n      if (!checkConfig.reuse_ai_session) {\n        errors.push({\n          field: `checks.${checkName}.session_mode`,\n          message: `Check \"${checkName}\" has session_mode but no reuse_ai_session. session_mode requires reuse_ai_session to be set.`,\n          value: checkConfig.session_mode,\n        });\n      }\n    }\n\n    // Validate tags configuration\n    if (checkConfig.tags !== undefined) {\n      if (!Array.isArray(checkConfig.tags)) {\n        errors.push({\n          field: `checks.${checkName}.tags`,\n          message: `Invalid tags value for \"${checkName}\": must be an array of strings`,\n          value: checkConfig.tags,\n        });\n      } else {\n        // Validate each tag\n        const validTagPattern = /^[a-zA-Z0-9][a-zA-Z0-9-_]*$/;\n        checkConfig.tags.forEach((tag, index) => {\n          if (typeof tag !== 'string') {\n            errors.push({\n              field: `checks.${checkName}.tags[${index}]`,\n              message: `Invalid tag at index ${index} for \"${checkName}\": must be a string`,\n              value: tag,\n            });\n          } else if (!validTagPattern.test(tag)) {\n            errors.push({\n              field: `checks.${checkName}.tags[${index}]`,\n              message: `Invalid tag \"${tag}\" for \"${checkName}\": tags must be alphanumeric with hyphens or underscores (start with alphanumeric)`,\n              value: tag,\n            });\n          }\n        });\n      }\n    }\n\n    // Validate on_finish configuration\n    if (checkConfig.on_finish !== undefined) {\n      if (!checkConfig.forEach) {\n        errors.push({\n          field: `checks.${checkName}.on_finish`,\n          message: `Check \"${checkName}\" has on_finish but forEach is not true. on_finish is only valid on forEach checks.`,\n          value: checkConfig.on_finish,\n        });\n      }\n    }\n  }\n\n  /**\n   * Validate MCP servers object shape and values (basic shape only)\n   */\n  private validateMcpServersObject(\n    mcpServers: unknown,\n    fieldPrefix: string,\n    errors: ConfigValidationError[],\n    _warnings: ConfigValidationError[]\n  ): void {\n    if (typeof mcpServers !== 'object' || mcpServers === null) {\n      errors.push({\n        field: fieldPrefix,\n        message: `${fieldPrefix} must be an object mapping server names to { command, args?, env? }`,\n        value: mcpServers,\n      });\n      return;\n    }\n\n    for (const [serverName, cfg] of Object.entries(mcpServers as Record<string, unknown>)) {\n      const pathStr = `${fieldPrefix}.${serverName}`;\n      if (!cfg || typeof cfg !== 'object') {\n        errors.push({ field: pathStr, message: `${pathStr} must be an object`, value: cfg });\n        continue;\n      }\n      const { command, args, env } = cfg as { command?: unknown; args?: unknown; env?: unknown };\n      if (typeof command !== 'string' || command.trim() === '') {\n        errors.push({\n          field: `${pathStr}.command`,\n          message: `${pathStr}.command must be a non-empty string`,\n          value: command,\n        });\n      }\n      if (args !== undefined && !Array.isArray(args)) {\n        errors.push({\n          field: `${pathStr}.args`,\n          message: `${pathStr}.args must be an array of strings`,\n          value: args,\n        });\n      }\n      if (env !== undefined) {\n        if (typeof env !== 'object' || env === null) {\n          errors.push({\n            field: `${pathStr}.env`,\n            message: `${pathStr}.env must be an object of string values`,\n            value: env,\n          });\n        } else {\n          for (const [k, v] of Object.entries(env as Record<string, unknown>)) {\n            if (typeof v !== 'string') {\n              errors.push({\n                field: `${pathStr}.env.${k}`,\n                message: `${pathStr}.env.${k} must be a string`,\n                value: v,\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Validate configuration using generated JSON Schema via Ajv, if available.\n   * Adds to errors/warnings but does not throw directly.\n   */\n  private validateWithAjvSchema(\n    config: Partial<VisorConfig>,\n    errors: ConfigValidationError[],\n    warnings: ConfigValidationError[]\n  ): void {\n    try {\n      if (!__ajvValidate) {\n        // Preferred fast path: try plain JSON in dist/generated first\n        try {\n          const jsonPath = path.resolve(__dirname, 'generated', 'config-schema.json');\n\n          const jsonSchema = require(jsonPath);\n          if (jsonSchema) {\n            const ajv = new Ajv({ allErrors: true, allowUnionTypes: true, strict: false });\n            addFormats(ajv);\n            const validate = ajv.compile(jsonSchema);\n            __ajvValidate = (data: unknown) => validate(data);\n            __ajvErrors = () => validate.errors;\n          }\n        } catch {}\n        // Fallback: use embedded TS module (bundled by ncc)\n        if (!__ajvValidate) {\n          try {\n            const mod = require('./generated/config-schema');\n            const schema = mod?.configSchema || mod?.default || mod;\n            if (schema) {\n              const ajv = new Ajv({ allErrors: true, allowUnionTypes: true, strict: false });\n              addFormats(ajv);\n              const validate = ajv.compile(schema);\n              __ajvValidate = (data: unknown) => validate(data);\n              __ajvErrors = () => validate.errors;\n            } else {\n              return;\n            }\n          } catch {\n            return;\n          }\n        }\n      }\n\n      const ok = __ajvValidate(config);\n      const errs = __ajvErrors ? __ajvErrors() : null;\n      if (!ok && Array.isArray(errs)) {\n        for (const e of errs) {\n          const pathStr = e.instancePath\n            ? e.instancePath.replace(/^\\//, '').replace(/\\//g, '.')\n            : '';\n          const msg = e.message || 'Invalid configuration';\n          if (e.keyword === 'additionalProperties') {\n            const addl = (e.params && (e.params as any).additionalProperty) || 'unknown';\n            const fullField = pathStr ? `${pathStr}.${addl}` : addl;\n            const topLevel = !pathStr;\n            warnings.push({\n              field: fullField || 'config',\n              message: topLevel\n                ? `Unknown top-level key '${addl}' will be ignored.`\n                : `Unknown key '${addl}' will be ignored`,\n            });\n          } else {\n            // Defer to our existing programmatic validators for required/type errors\n            // to preserve friendly, stable error messages and avoid duplication.\n            logger.debug(`Ajv note [${pathStr || 'config'}]: ${msg}`);\n          }\n        }\n      }\n    } catch (err) {\n      logger.debug(`Ajv validation skipped: ${err instanceof Error ? err.message : String(err)}`);\n    }\n  }\n\n  // Unknown-key warnings are fully handled by Ajv using the generated schema\n  // Unknown-key hints are produced by Ajv (additionalProperties=false)\n\n  /**\n   * Validate tag filter configuration\n   */\n  private validateTagFilter(\n    tagFilter: Record<string, unknown>,\n    errors: ConfigValidationError[]\n  ): void {\n    const validTagPattern = /^[a-zA-Z0-9][a-zA-Z0-9-_]*$/;\n\n    // Validate include tags\n    if (tagFilter.include !== undefined) {\n      if (!Array.isArray(tagFilter.include)) {\n        errors.push({\n          field: 'tag_filter.include',\n          message: 'tag_filter.include must be an array of strings',\n          value: tagFilter.include,\n        });\n      } else {\n        tagFilter.include.forEach((tag: unknown, index: number) => {\n          if (typeof tag !== 'string') {\n            errors.push({\n              field: `tag_filter.include[${index}]`,\n              message: `Invalid tag at index ${index}: must be a string`,\n              value: tag,\n            });\n          } else if (!validTagPattern.test(tag as string)) {\n            errors.push({\n              field: `tag_filter.include[${index}]`,\n              message: `Invalid tag \"${tag}\": tags must be alphanumeric with hyphens or underscores`,\n              value: tag,\n            });\n          }\n        });\n      }\n    }\n\n    // Validate exclude tags\n    if (tagFilter.exclude !== undefined) {\n      if (!Array.isArray(tagFilter.exclude)) {\n        errors.push({\n          field: 'tag_filter.exclude',\n          message: 'tag_filter.exclude must be an array of strings',\n          value: tagFilter.exclude,\n        });\n      } else {\n        tagFilter.exclude.forEach((tag: unknown, index: number) => {\n          if (typeof tag !== 'string') {\n            errors.push({\n              field: `tag_filter.exclude[${index}]`,\n              message: `Invalid tag at index ${index}: must be a string`,\n              value: tag,\n            });\n          } else if (!validTagPattern.test(tag as string)) {\n            errors.push({\n              field: `tag_filter.exclude[${index}]`,\n              message: `Invalid tag \"${tag}\": tags must be alphanumeric with hyphens or underscores`,\n              value: tag,\n            });\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * Validate HTTP server configuration\n   */\n  private validateHttpServerConfig(\n    httpServerConfig: Record<string, unknown>,\n    errors: ConfigValidationError[]\n  ): void {\n    if (typeof httpServerConfig.enabled !== 'boolean') {\n      errors.push({\n        field: 'http_server.enabled',\n        message: 'http_server.enabled must be a boolean',\n        value: httpServerConfig.enabled,\n      });\n    }\n\n    if (httpServerConfig.enabled === true) {\n      // Port is required when enabled\n      if (\n        typeof httpServerConfig.port !== 'number' ||\n        httpServerConfig.port < 1 ||\n        httpServerConfig.port > 65535\n      ) {\n        errors.push({\n          field: 'http_server.port',\n          message: 'http_server.port must be a number between 1 and 65535',\n          value: httpServerConfig.port,\n        });\n      }\n\n      // Validate auth if present\n      if (httpServerConfig.auth) {\n        const auth = httpServerConfig.auth as Record<string, unknown>;\n        const validAuthTypes = ['bearer_token', 'hmac', 'basic', 'none'];\n\n        if (!auth.type || !validAuthTypes.includes(auth.type as string)) {\n          errors.push({\n            field: 'http_server.auth.type',\n            message: `Invalid auth type. Must be one of: ${validAuthTypes.join(', ')}`,\n            value: auth.type,\n          });\n        }\n      }\n\n      // Validate TLS configuration if present\n      if (httpServerConfig.tls && typeof httpServerConfig.tls === 'object') {\n        const tls = httpServerConfig.tls as Record<string, unknown>;\n\n        if (tls.enabled === true) {\n          // Cert and key are required when TLS is enabled\n          if (!tls.cert) {\n            errors.push({\n              field: 'http_server.tls.cert',\n              message: 'TLS certificate is required when TLS is enabled',\n            });\n          }\n          if (!tls.key) {\n            errors.push({\n              field: 'http_server.tls.key',\n              message: 'TLS key is required when TLS is enabled',\n            });\n          }\n        }\n      }\n\n      // Validate endpoints if present\n      if (httpServerConfig.endpoints && Array.isArray(httpServerConfig.endpoints)) {\n        for (let i = 0; i < httpServerConfig.endpoints.length; i++) {\n          const endpoint = httpServerConfig.endpoints[i] as Record<string, unknown>;\n          if (!endpoint.path || typeof endpoint.path !== 'string') {\n            errors.push({\n              field: `http_server.endpoints[${i}].path`,\n              message: 'Endpoint path must be a string',\n              value: endpoint.path,\n            });\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Validate output configuration\n   */\n  private validateOutputConfig(\n    outputConfig: Record<string, unknown>,\n    errors: ConfigValidationError[]\n  ): void {\n    if (outputConfig.pr_comment) {\n      const prComment = outputConfig.pr_comment as Record<string, unknown>;\n\n      if (\n        typeof prComment.format === 'string' &&\n        !this.validOutputFormats.includes(prComment.format as ConfigOutputFormat)\n      ) {\n        errors.push({\n          field: 'output.pr_comment.format',\n          message: `Invalid output format \"${prComment.format}\". Must be one of: ${this.validOutputFormats.join(', ')}`,\n          value: prComment.format as string,\n        });\n      }\n\n      if (\n        typeof prComment.group_by === 'string' &&\n        !this.validGroupByOptions.includes(prComment.group_by as GroupByOption)\n      ) {\n        errors.push({\n          field: 'output.pr_comment.group_by',\n          message: `Invalid group_by option \"${prComment.group_by}\". Must be one of: ${this.validGroupByOptions.join(', ')}`,\n          value: prComment.group_by as string,\n        });\n      }\n    }\n  }\n\n  /**\n   * Check if remote extends are allowed\n   */\n  private isRemoteExtendsAllowed(): boolean {\n    // Check environment variable first\n    if (\n      process.env.VISOR_NO_REMOTE_EXTENDS === 'true' ||\n      process.env.VISOR_NO_REMOTE_EXTENDS === '1'\n    ) {\n      return false;\n    }\n    // Default to allowing remote extends\n    return true;\n  }\n\n  /**\n   * Merge configuration with default values\n   */\n  private mergeWithDefaults(config: Partial<VisorConfig>): Partial<VisorConfig> {\n    const defaultConfig = {\n      version: '1.0',\n      checks: {},\n      max_parallelism: 3,\n      output: {\n        pr_comment: {\n          format: 'markdown' as ConfigOutputFormat,\n          group_by: 'check' as GroupByOption,\n          collapse: true,\n        },\n      },\n    };\n\n    // Deep merge with defaults\n    const merged = { ...defaultConfig, ...config };\n\n    // Ensure output has default values\n    if (merged.output) {\n      merged.output.pr_comment = {\n        ...defaultConfig.output.pr_comment,\n        ...merged.output.pr_comment,\n      };\n    } else {\n      merged.output = defaultConfig.output;\n    }\n\n    return merged;\n  }\n}\n\n// Cache Ajv validator across loads to avoid repeated heavy generation\nlet __ajvValidate: ((data: unknown) => boolean) | null = null;\nlet __ajvErrors: (() => import('ajv').ErrorObject[] | null | undefined) | null = null;\n","import * as fs from 'fs';\nimport * as path from 'path';\nimport * as yaml from 'js-yaml';\nimport { VisorConfig } from '../types/config';\n\n/**\n * Configuration source types\n */\nexport enum ConfigSourceType {\n  LOCAL = 'local',\n  REMOTE = 'remote',\n  DEFAULT = 'default',\n}\n\n/**\n * Cache entry for remote configurations\n */\ninterface CacheEntry {\n  config: Partial<VisorConfig>;\n  timestamp: number;\n  ttl: number;\n}\n\n/**\n * Options for loading configurations\n */\nexport interface ConfigLoaderOptions {\n  /** Base directory for resolving relative paths */\n  baseDir?: string;\n  /** Whether to allow remote extends (default: true) */\n  allowRemote?: boolean;\n  /** Cache TTL in milliseconds (default: 5 minutes) */\n  cacheTTL?: number;\n  /** Request timeout in milliseconds (default: 30 seconds) */\n  timeout?: number;\n  /** Maximum recursion depth (default: 10) */\n  maxDepth?: number;\n  /** Allowed remote URL patterns (default: ['https://github.com/', 'https://raw.githubusercontent.com/']) */\n  allowedRemotePatterns?: string[];\n  /** Project root directory for path traversal protection */\n  projectRoot?: string;\n}\n\n/**\n * Utility class for loading configurations from various sources\n */\nexport class ConfigLoader {\n  private cache: Map<string, CacheEntry> = new Map();\n  private loadedConfigs: Set<string> = new Set();\n\n  constructor(private options: ConfigLoaderOptions = {}) {\n    this.options = {\n      allowRemote: true,\n      cacheTTL: 5 * 60 * 1000, // 5 minutes\n      timeout: 30 * 1000, // 30 seconds\n      maxDepth: 10,\n      allowedRemotePatterns: [], // Empty by default for security\n      projectRoot: this.findProjectRoot(),\n      ...options,\n    };\n  }\n\n  /**\n   * Determine the source type from a string\n   */\n  private getSourceType(source: string): ConfigSourceType {\n    if (source === 'default') {\n      return ConfigSourceType.DEFAULT;\n    }\n    if (source.startsWith('http://') || source.startsWith('https://')) {\n      return ConfigSourceType.REMOTE;\n    }\n    return ConfigSourceType.LOCAL;\n  }\n\n  /**\n   * Fetch configuration from any source\n   */\n  public async fetchConfig(\n    source: string,\n    currentDepth: number = 0\n  ): Promise<Partial<VisorConfig>> {\n    // Check recursion depth\n    if (currentDepth >= (this.options.maxDepth || 10)) {\n      throw new Error(\n        `Maximum extends depth (${this.options.maxDepth}) exceeded. Check for circular dependencies.`\n      );\n    }\n\n    // Check for circular dependencies\n    const normalizedSource = this.normalizeSource(source);\n    if (this.loadedConfigs.has(normalizedSource)) {\n      throw new Error(\n        `Circular dependency detected: ${normalizedSource} is already in the extends chain`\n      );\n    }\n\n    const sourceType = this.getSourceType(source);\n\n    try {\n      this.loadedConfigs.add(normalizedSource);\n\n      switch (sourceType) {\n        case ConfigSourceType.DEFAULT:\n          return await this.fetchDefaultConfig();\n        case ConfigSourceType.REMOTE:\n          if (!this.options.allowRemote) {\n            throw new Error(\n              'Remote extends are disabled. Enable with --allow-remote-extends or remove VISOR_NO_REMOTE_EXTENDS environment variable.'\n            );\n          }\n          return await this.fetchRemoteConfig(source);\n        case ConfigSourceType.LOCAL:\n          return await this.fetchLocalConfig(source);\n        default:\n          throw new Error(`Unknown configuration source: ${source}`);\n      }\n    } finally {\n      this.loadedConfigs.delete(normalizedSource);\n    }\n  }\n\n  /**\n   * Normalize source path/URL for comparison\n   */\n  private normalizeSource(source: string): string {\n    const sourceType = this.getSourceType(source);\n\n    switch (sourceType) {\n      case ConfigSourceType.DEFAULT:\n        return 'default';\n      case ConfigSourceType.REMOTE:\n        return source.toLowerCase();\n      case ConfigSourceType.LOCAL:\n        const basePath = this.options.baseDir || process.cwd();\n        return path.resolve(basePath, source);\n      default:\n        return source;\n    }\n  }\n\n  /**\n   * Load configuration from local file system\n   */\n  private async fetchLocalConfig(filePath: string): Promise<Partial<VisorConfig>> {\n    const basePath = this.options.baseDir || process.cwd();\n    const resolvedPath = path.resolve(basePath, filePath);\n\n    // Validate against path traversal attacks\n    this.validateLocalPath(resolvedPath);\n\n    if (!fs.existsSync(resolvedPath)) {\n      throw new Error(`Configuration file not found: ${resolvedPath}`);\n    }\n\n    try {\n      const content = fs.readFileSync(resolvedPath, 'utf8');\n      const config = yaml.load(content) as Partial<VisorConfig>;\n\n      if (!config || typeof config !== 'object') {\n        throw new Error(`Invalid YAML in configuration file: ${resolvedPath}`);\n      }\n\n      // Update base directory for nested extends\n      const previousBaseDir = this.options.baseDir;\n      this.options.baseDir = path.dirname(resolvedPath);\n\n      try {\n        // Process extends if present\n        if (config.extends) {\n          const processedConfig = await this.processExtends(config);\n          return processedConfig;\n        }\n\n        return config;\n      } finally {\n        // Restore previous base directory\n        this.options.baseDir = previousBaseDir;\n      }\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new Error(`Failed to load configuration from ${resolvedPath}: ${error.message}`);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Fetch configuration from remote URL\n   */\n  private async fetchRemoteConfig(url: string): Promise<Partial<VisorConfig>> {\n    // Validate URL protocol\n    if (!url.startsWith('http://') && !url.startsWith('https://')) {\n      throw new Error(`Invalid URL: ${url}. Only HTTP and HTTPS protocols are supported.`);\n    }\n\n    // Validate against SSRF attacks\n    this.validateRemoteURL(url);\n\n    // Check cache\n    const cacheEntry = this.cache.get(url);\n    if (cacheEntry && Date.now() - cacheEntry.timestamp < cacheEntry.ttl) {\n      // Use stderr to avoid contaminating JSON/SARIF output\n      const outputFormat = process.env.VISOR_OUTPUT_FORMAT;\n      const logFn =\n        outputFormat === 'json' || outputFormat === 'sarif' ? console.error : console.log;\n      logFn(`📦 Using cached configuration from: ${url}`);\n      return cacheEntry.config;\n    }\n\n    // Use stderr to avoid contaminating JSON/SARIF output\n    const outputFormat = process.env.VISOR_OUTPUT_FORMAT;\n    const logFn = outputFormat === 'json' || outputFormat === 'sarif' ? console.error : console.log;\n    logFn(`⬇️  Fetching remote configuration from: ${url}`);\n\n    const controller = new AbortController();\n    const timeoutMs = this.options.timeout ?? 30000;\n    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);\n\n    try {\n      const response = await fetch(url, {\n        signal: controller.signal,\n        headers: {\n          'User-Agent': 'Visor/1.0',\n        },\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to fetch config: ${response.status} ${response.statusText}`);\n      }\n\n      const content = await response.text();\n      const config = yaml.load(content) as Partial<VisorConfig>;\n\n      if (!config || typeof config !== 'object') {\n        throw new Error(`Invalid YAML in remote configuration: ${url}`);\n      }\n\n      // Cache the configuration\n      this.cache.set(url, {\n        config,\n        timestamp: Date.now(),\n        ttl: this.options.cacheTTL || 5 * 60 * 1000,\n      });\n\n      // Process extends if present\n      if (config.extends) {\n        return await this.processExtends(config);\n      }\n\n      return config;\n    } catch (error) {\n      if (error instanceof Error) {\n        if (error.name === 'AbortError') {\n          throw new Error(`Timeout fetching configuration from ${url} (${timeoutMs}ms)`);\n        }\n        throw new Error(`Failed to fetch remote configuration from ${url}: ${error.message}`);\n      }\n      throw error;\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  }\n\n  /**\n   * Load bundled default configuration\n   */\n  private async fetchDefaultConfig(): Promise<Partial<VisorConfig>> {\n    // Try different paths to find the bundled default config\n    const possiblePaths = [\n      // When running as GitHub Action (bundled in dist/)\n      path.join(__dirname, 'defaults', '.visor.yaml'),\n      // When running from source\n      path.join(__dirname, '..', '..', 'defaults', '.visor.yaml'),\n      // Try via package root\n      this.findPackageRoot() ? path.join(this.findPackageRoot()!, 'defaults', '.visor.yaml') : '',\n      // GitHub Action environment variable\n      process.env.GITHUB_ACTION_PATH\n        ? path.join(process.env.GITHUB_ACTION_PATH, 'defaults', '.visor.yaml')\n        : '',\n      process.env.GITHUB_ACTION_PATH\n        ? path.join(process.env.GITHUB_ACTION_PATH, 'dist', 'defaults', '.visor.yaml')\n        : '',\n    ].filter(p => p); // Remove empty paths\n\n    let defaultConfigPath: string | undefined;\n    for (const possiblePath of possiblePaths) {\n      if (fs.existsSync(possiblePath)) {\n        defaultConfigPath = possiblePath;\n        break;\n      }\n    }\n\n    if (defaultConfigPath && fs.existsSync(defaultConfigPath)) {\n      // Always log to stderr to avoid contaminating formatted output\n      console.error(`📦 Loading bundled default configuration from ${defaultConfigPath}`);\n      const content = fs.readFileSync(defaultConfigPath, 'utf8');\n      let config = yaml.load(content) as Partial<VisorConfig>;\n\n      if (!config || typeof config !== 'object') {\n        throw new Error('Invalid default configuration');\n      }\n\n      // Normalize 'checks' and 'steps' for backward compatibility\n      config = this.normalizeStepsAndChecks(config);\n\n      // Default configs shouldn't have extends, but handle it just in case\n      if (config.extends) {\n        return await this.processExtends(config);\n      }\n\n      return config;\n    }\n\n    // Return minimal default if bundled config not found\n    console.warn('⚠️  Bundled default configuration not found, using minimal defaults');\n    return {\n      version: '1.0',\n      checks: {},\n      output: {\n        pr_comment: {\n          format: 'markdown',\n          group_by: 'check',\n          collapse: true,\n        },\n      },\n    };\n  }\n\n  /**\n   * Process extends directive in a configuration\n   */\n  private async processExtends(config: Partial<VisorConfig>): Promise<Partial<VisorConfig>> {\n    if (!config.extends) {\n      return config;\n    }\n\n    const extends_ = Array.isArray(config.extends) ? config.extends : [config.extends];\n\n    // Remove extends from the config to avoid infinite recursion\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const { extends: _extendsField, ...configWithoutExtends } = config;\n\n    // Load all parent configurations\n    const parentConfigs: Partial<VisorConfig>[] = [];\n    for (const source of extends_) {\n      const parentConfig = await this.fetchConfig(source, this.loadedConfigs.size);\n      parentConfigs.push(parentConfig);\n    }\n\n    // Merge configurations (will be implemented in config-merger.ts)\n    // For now, we'll import it dynamically\n    const { ConfigMerger } = await import('./config-merger');\n    const merger = new ConfigMerger();\n\n    // Merge all parent configs together first\n    let mergedParents: Partial<VisorConfig> = {};\n    for (const parentConfig of parentConfigs) {\n      mergedParents = merger.merge(mergedParents, parentConfig);\n    }\n\n    // Then merge with the current config (child overrides parent)\n    return merger.merge(mergedParents, configWithoutExtends);\n  }\n\n  /**\n   * Find project root directory (for security validation)\n   */\n  private findProjectRoot(): string {\n    // Try to find git root first\n    try {\n      const { execSync } = require('child_process');\n      const gitRoot = execSync('git rev-parse --show-toplevel', { encoding: 'utf8' }).trim();\n      if (gitRoot) return gitRoot;\n    } catch {\n      // Not a git repo, continue\n    }\n\n    // Fall back to finding package.json\n    const packageRoot = this.findPackageRoot();\n    if (packageRoot) return packageRoot;\n\n    // Last resort: use current working directory\n    return process.cwd();\n  }\n\n  /**\n   * Validate remote URL against allowlist\n   */\n  private validateRemoteURL(url: string): void {\n    // If allowlist is empty, allow all URLs (backward compatibility)\n    const allowedPatterns = this.options.allowedRemotePatterns || [];\n    if (allowedPatterns.length === 0) {\n      return;\n    }\n\n    // Check if URL matches any allowed pattern\n    const isAllowed = allowedPatterns.some(pattern => url.startsWith(pattern));\n    if (!isAllowed) {\n      throw new Error(\n        `Security error: URL ${url} is not in the allowed list. Allowed patterns: ${allowedPatterns.join(', ')}`\n      );\n    }\n  }\n\n  /**\n   * Validate local path against traversal attacks\n   */\n  private validateLocalPath(resolvedPath: string): void {\n    const projectRoot = this.options.projectRoot || process.cwd();\n    const normalizedPath = path.normalize(resolvedPath);\n    const normalizedRoot = path.normalize(projectRoot);\n\n    // Check if the resolved path is within the project root\n    if (!normalizedPath.startsWith(normalizedRoot)) {\n      throw new Error(\n        `Security error: Path traversal detected. Cannot access files outside project root: ${projectRoot}`\n      );\n    }\n\n    // Additional check for sensitive system files\n    const sensitivePatterns = [\n      '/etc/passwd',\n      '/etc/shadow',\n      '/.ssh/',\n      '/.aws/',\n      '/.env',\n      '/private/',\n    ];\n\n    const lowerPath = normalizedPath.toLowerCase();\n    for (const pattern of sensitivePatterns) {\n      if (lowerPath.includes(pattern)) {\n        throw new Error(`Security error: Cannot access potentially sensitive file: ${pattern}`);\n      }\n    }\n  }\n\n  /**\n   * Find package root directory\n   */\n  private findPackageRoot(): string | null {\n    let currentDir = __dirname;\n    const root = path.parse(currentDir).root;\n\n    while (currentDir !== root) {\n      const packageJsonPath = path.join(currentDir, 'package.json');\n      if (fs.existsSync(packageJsonPath)) {\n        try {\n          const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));\n          // Check if this is the Visor package\n          if (packageJson.name === '@probelabs/visor') {\n            return currentDir;\n          }\n        } catch {\n          // Continue searching\n        }\n      }\n      currentDir = path.dirname(currentDir);\n    }\n\n    return null;\n  }\n\n  /**\n   * Clear the configuration cache\n   */\n  public clearCache(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Reset the loaded configs tracking (for testing)\n   */\n  public reset(): void {\n    this.loadedConfigs.clear();\n    this.clearCache();\n  }\n\n  /**\n   * Normalize 'checks' and 'steps' keys for backward compatibility\n   * Ensures both keys are present and contain the same data\n   */\n  private normalizeStepsAndChecks(config: Partial<VisorConfig>): Partial<VisorConfig> {\n    // If both are present, 'steps' takes precedence\n    if (config.steps && config.checks) {\n      // Use steps as the source of truth\n      config.checks = config.steps;\n    } else if (config.steps && !config.checks) {\n      // Copy steps to checks for internal compatibility\n      config.checks = config.steps;\n    } else if (config.checks && !config.steps) {\n      // Copy checks to steps for forward compatibility\n      config.steps = config.checks;\n    }\n\n    return config;\n  }\n}\n"],"mappings":"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","names":["uuidv4","resolve","initializeTracer","fs","path","import_probe","context","triggeringComment","fs","path","agentAny","result","resolve","CheckExecutionEngine","fs","path","normalize","fs","path","ignore","path","fs","status","path","resolve","fs","path","content","lines","path","fs","import_promises","import_path","path","fs","context","context","fs","path","import_promises","import_path","path","fs","emitNdjsonSpanWithEvents","context","Sandbox","import_promises","import_path","path","fs","emitNdjsonSpanWithEvents","arr","buildSandboxEnv","context","context","buildSandboxEnv","resolve","resolve","fs","path","context","resolve","emitNdjsonSpanWithEvents","context","emitNdjsonSpanWithEvents","checkName","normalize","log","issues","hasMinPermission","isOwner","isMember","isCollaborator","isContributor","isFirstTimer","fs","path","buildSandboxEnv","context","resolve","log","wave","depResults","mode","focus","path","createExtendedLiquid","fs","withPermissionsContext","emitMermaidFromMarkdown","checks","itemScope","directDeps","agg","i","emitNdjsonSpanWithEvents","yaml","fs","path","import_simple_git","fs","path","outputFormat","logFn","ConfigMerger","simpleGit","Ajv","addFormats"]}