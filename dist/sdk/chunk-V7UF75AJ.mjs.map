{"version":3,"sources":["../../src/snapshot-store.ts","../../src/state-machine/states/routing.ts"],"sourcesContent":["/*\n * Internal snapshot store for incremental adoption of snapshot+scope execution.\n * Phase 0: journal only ‚Äî no behavior change, used for future visibility work.\n */\n\nimport type { ReviewSummary } from './reviewer';\nimport type { EventTrigger } from './types/config';\n\nexport type ScopePath = Array<{ check: string; index: number }>;\n\nexport interface JournalEntry {\n  commitId: number;\n  sessionId: string;\n  scope: ScopePath;\n  checkId: string;\n  event: EventTrigger | undefined;\n  result: ReviewSummary & { output?: unknown; content?: string };\n}\n\nexport class ExecutionJournal {\n  private commit = 0;\n  private entries: JournalEntry[] = [];\n\n  beginSnapshot(): number {\n    return this.commit;\n  }\n\n  commitEntry(entry: {\n    sessionId: string;\n    scope: ScopePath;\n    checkId: string;\n    result: ReviewSummary & { output?: unknown; content?: string };\n    event?: EventTrigger;\n  }): JournalEntry {\n    const committed: JournalEntry = {\n      sessionId: entry.sessionId,\n      scope: entry.scope,\n      checkId: entry.checkId,\n      result: entry.result,\n      event: entry.event,\n      commitId: ++this.commit,\n    };\n    this.entries.push(committed);\n    return committed;\n  }\n\n  readVisible(sessionId: string, commitMax: number, event?: EventTrigger): JournalEntry[] {\n    return this.entries.filter(\n      e =>\n        e.sessionId === sessionId && e.commitId <= commitMax && (event ? e.event === event : true)\n    );\n  }\n\n  // Lightweight helpers for debugging/metrics\n  size(): number {\n    return this.entries.length;\n  }\n}\n\nexport class ContextView {\n  constructor(\n    private journal: ExecutionJournal,\n    private sessionId: string,\n    private snapshotId: number,\n    private scope: ScopePath,\n    private event?: EventTrigger\n  ) {}\n\n  /** Return the nearest result for a check in this scope (exact item ‚Üí ancestor ‚Üí latest). */\n  get(checkId: string): (ReviewSummary & { output?: unknown; content?: string }) | undefined {\n    const visible = this.journal\n      .readVisible(this.sessionId, this.snapshotId, this.event)\n      .filter(e => e.checkId === checkId);\n    if (visible.length === 0) return undefined;\n\n    // exact scope match\n    const exact = visible.find(e => this.sameScope(e.scope, this.scope));\n    if (exact) return exact.result;\n\n    // nearest ancestor (shortest distance)\n    let best: { entry: JournalEntry; dist: number } | undefined;\n    for (const e of visible) {\n      const dist = this.ancestorDistance(e.scope, this.scope);\n      if (dist >= 0 && (best === undefined || dist < best.dist)) {\n        best = { entry: e, dist };\n      }\n    }\n    if (best) return best.entry.result;\n\n    // fallback to latest committed result\n    return visible[visible.length - 1]?.result;\n  }\n\n  /** Return an aggregate (raw) result ‚Äì the shallowest scope for this check. */\n  getRaw(checkId: string): (ReviewSummary & { output?: unknown; content?: string }) | undefined {\n    const visible = this.journal\n      .readVisible(this.sessionId, this.snapshotId, this.event)\n      .filter(e => e.checkId === checkId);\n    if (visible.length === 0) return undefined;\n    let shallow = visible[0];\n    for (const e of visible) {\n      if (e.scope.length < shallow.scope.length) shallow = e;\n    }\n    return shallow.result;\n  }\n\n  /** All results for a check up to this snapshot. */\n  getHistory(checkId: string): Array<ReviewSummary & { output?: unknown; content?: string }> {\n    return this.journal\n      .readVisible(this.sessionId, this.snapshotId, this.event)\n      .filter(e => e.checkId === checkId)\n      .map(e => e.result);\n  }\n\n  private sameScope(a: ScopePath, b: ScopePath): boolean {\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (a[i].check !== b[i].check || a[i].index !== b[i].index) return false;\n    }\n    return true;\n  }\n\n  // distance from ancestor to current; -1 if not ancestor\n  private ancestorDistance(ancestor: ScopePath, current: ScopePath): number {\n    if (ancestor.length > current.length) return -1;\n    // Treat root scope ([]) as non-ancestor for unrelated branches\n    if (ancestor.length === 0 && current.length > 0) return -1;\n    for (let i = 0; i < ancestor.length; i++) {\n      if (ancestor[i].check !== current[i].check || ancestor[i].index !== current[i].index)\n        return -1;\n    }\n    return current.length - ancestor.length;\n  }\n}\n","/**\n * Routing State Handler\n *\n * Responsibilities:\n * - Evaluate fail_if conditions after check execution\n * - Process on_success, on_fail, on_finish triggers\n * - Enqueue ForwardRunRequested events for goto\n * - Enqueue WaveRetry events for routing loops\n * - Transition back to WavePlanning or Completed\n *\n * M2: Core routing logic implementation\n */\n\nimport type {\n  EngineContext,\n  RunState,\n  EngineState,\n  EngineEvent\n} from '../../types/engine';\nimport type { ReviewSummary, ReviewIssue } from '../../reviewer';\nimport type { CheckConfig, OnFailConfig } from '../../types/config';\nimport { logger } from '../../logger';\nimport { FailureConditionEvaluator } from '../../failure-condition-evaluator';\nimport { createSecureSandbox, compileAndRun } from '../../utils/sandbox';\nimport { MemoryStore } from '../../memory-store';\n\n/**\n * Check if any configured check depends (directly or via OR dependency) on the\n * given `checkId`. Used to decide whether a forEach parent has downstream\n * dependents, in which case its on_finish should defer to the LevelDispatch\n * post-children hook.\n */\nfunction hasDependents(context: EngineContext, checkId: string): boolean {\n  const checks = context.config.checks || {};\n  for (const [cid, cfg] of Object.entries(checks)) {\n    if (cid === checkId) continue;\n    const rawDeps = (cfg as any).depends_on || [];\n    const depList = Array.isArray(rawDeps) ? rawDeps : [rawDeps];\n    for (const dep of depList) {\n      if (typeof dep !== 'string') continue;\n      if (dep.includes('|')) {\n        const opts = dep.split('|').map(s => s.trim()).filter(Boolean);\n        if (opts.includes(checkId)) return true;\n      } else if (dep === checkId) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Context for a check that just completed and needs routing evaluation\n */\ninterface RoutingContext {\n  checkId: string;\n  scope: Array<{ check: string; index: number }>;\n  result: ReviewSummary;\n  checkConfig: CheckConfig;\n  success: boolean; // true if no fatal issues\n}\n\n/**\n * Create memory helpers for sandbox context\n */\nfunction createMemoryHelpers() {\n  const memoryStore = MemoryStore.getInstance();\n  return {\n    get: (key: string, ns?: string) => memoryStore.get(key, ns),\n    has: (key: string, ns?: string) => memoryStore.has(key, ns),\n    getAll: (ns?: string) => memoryStore.getAll(ns),\n    set: (key: string, value: unknown, ns?: string) => {\n      const nsName = ns || memoryStore.getDefaultNamespace();\n      const data: Map<string, Map<string, unknown>> = (memoryStore as any)['data'];\n      if (!data.has(nsName)) data.set(nsName, new Map());\n      data.get(nsName)!.set(key, value);\n    },\n    clear: (ns?: string) => {\n      const data: Map<string, Map<string, unknown>> = (memoryStore as any)['data'];\n      if (ns) data.delete(ns);\n      else data.clear();\n    },\n    increment: (key: string, amount = 1, ns?: string) => {\n      const nsName = ns || memoryStore.getDefaultNamespace();\n      const data: Map<string, Map<string, unknown>> = (memoryStore as any)['data'];\n      if (!data.has(nsName)) data.set(nsName, new Map());\n      const nsMap = data.get(nsName)!;\n      const current = nsMap.get(key);\n      const numCurrent = typeof current === 'number' ? current : 0;\n      const newValue = numCurrent + amount;\n      nsMap.set(key, newValue);\n      return newValue;\n    },\n  };\n}\n\n/**\n * Handle routing state - evaluate conditions and decide next actions\n */\nexport async function handleRouting(\n  context: EngineContext,\n  state: RunState,\n  transition: (newState: EngineState) => void,\n  emitEvent: (event: EngineEvent) => void,\n  routingContext: RoutingContext\n): Promise<void> {\n  const { checkId, scope, result, checkConfig, success } = routingContext;\n\n  if (context.debug) {\n    logger.info(`[Routing] Evaluating routing for check: ${checkId}, success: ${success}`);\n  }\n\n  // Step 1: Evaluate fail_if conditions\n  const failIfTriggered = await evaluateFailIf(\n    checkId,\n    result,\n    checkConfig,\n    context,\n    state\n  );\n\n  if (failIfTriggered) {\n    if (context.debug) {\n      logger.info(`[Routing] fail_if triggered for ${checkId}`);\n    }\n\n    // Treat as failure for routing purposes\n    await processOnFail(checkId, scope, result, checkConfig, context, state, emitEvent);\n  } else if (success) {\n    // Step 2: Process on_success routing\n    await processOnSuccess(checkId, scope, result, checkConfig, context, state, emitEvent);\n  } else {\n    // Step 3: Process on_fail routing\n    await processOnFail(checkId, scope, result, checkConfig, context, state, emitEvent);\n  }\n\n  // Step 4: on_finish\n  // Process on_finish here for non-forEach checks OR for forEach parents that\n  // have no dependents (so there will be no post-children hook to handle it).\n  if (\n    checkConfig.on_finish &&\n    (checkConfig.forEach !== true || !hasDependents(context, checkId))\n  ) {\n    await processOnFinish(checkId, scope, result, checkConfig, context, state, emitEvent);\n  }\n\n  // Transition back to WavePlanning to process queued events\n  transition('WavePlanning');\n}\n\n/**\n * Process on_finish routing\n */\nasync function processOnFinish(\n  checkId: string,\n  scope: Array<{ check: string; index: number }>,\n  result: ReviewSummary,\n  checkConfig: CheckConfig,\n  context: EngineContext,\n  state: RunState,\n  emitEvent: (event: EngineEvent) => void\n): Promise<void> {\n  const onFinish = checkConfig.on_finish;\n\n  if (!onFinish) {\n    return; // No on_finish configuration\n  }\n\n  // Log at info level so it's visible in test output\n  logger.info(`Processing on_finish for ${checkId}`);\n  let queuedForward = false;\n  // Process on_finish.run\n  if (onFinish.run && onFinish.run.length > 0) {\n    // Check if current check is a forEach parent with items\n    const currentCheckIsForEach = checkConfig.forEach === true;\n    const forEachItems = currentCheckIsForEach ? (result as any).forEachItems : undefined;\n    const hasForEachItems = Array.isArray(forEachItems) && forEachItems.length > 0;\n\n    for (const targetCheck of onFinish.run) {\n      // Check loop budget before scheduling\n      if (checkLoopBudget(context, state, 'on_finish', 'run')) {\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_finish run`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return;\n      }\n\n      // Handle fanout: check if target has fanout configuration\n      const targetConfig = context.config.checks?.[targetCheck];\n      const fanoutMode = targetConfig?.fanout || 'reduce'; // default to reduce\n\n      if (context.debug) {\n        logger.info(`[Routing] on_finish.run: scheduling ${targetCheck} with fanout=${fanoutMode}, hasForEachItems=${hasForEachItems}`);\n      }\n\n      // If current check has forEach items and target is map fanout, emit one event per item\n      if (fanoutMode === 'map' && hasForEachItems) {\n        // Map fanout: emit one ForwardRunRequested per forEach item\n        for (let itemIndex = 0; itemIndex < forEachItems!.length; itemIndex++) {\n          // Increment loop count for each item\n          state.routingLoopCount++;\n\n          const itemScope: Array<{ check: string; index: number }> = [\n            { check: checkId, index: itemIndex }\n          ];\n\n          emitEvent({\n            type: 'ForwardRunRequested',\n            target: targetCheck,\n            scope: itemScope,\n            origin: 'run',\n          });\n          queuedForward = true;\n        }\n      } else {\n        // Reduce fanout (or no forEach context): emit with empty scope once\n        // Increment loop count\n        state.routingLoopCount++;\n\n        emitEvent({\n          type: 'ForwardRunRequested',\n          target: targetCheck,\n          scope: [],\n          origin: 'run',\n        });\n        queuedForward = true;\n      }\n    }\n  }\n\n  // Process on_finish.run_js\n  if (onFinish.run_js) {\n    const dynamicTargets = await evaluateRunJs(\n      onFinish.run_js,\n      checkId,\n      checkConfig,\n      result,\n      context,\n      state\n    );\n\n    for (const targetCheck of dynamicTargets) {\n      // Check loop budget before scheduling\n      if (checkLoopBudget(context, state, 'on_finish', 'run')) {\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_finish run`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return;\n      }\n\n      if (context.debug) {\n        logger.info(`[Routing] on_finish.run_js: scheduling ${targetCheck}`);\n      }\n\n      // Increment loop count\n      state.routingLoopCount++;\n\n      emitEvent({\n        type: 'ForwardRunRequested',\n        target: targetCheck,\n        scope,\n        origin: 'run_js',\n      });\n      queuedForward = true;\n    }\n  }\n\n  // Process on_finish.goto / goto_js\n  const gotoTarget = await evaluateGoto(\n    onFinish.goto_js,\n    onFinish.goto,\n    checkId,\n    checkConfig,\n    result,\n    context,\n    state\n  );\n\n  if (gotoTarget) {\n    // Check loop budget before scheduling goto\n    if (checkLoopBudget(context, state, 'on_finish', 'goto')) {\n      const errorIssue: ReviewIssue = {\n        file: 'system',\n        line: 0,\n        ruleId: `${checkId}/routing/loop_budget_exceeded`,\n        message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_finish goto`,\n        severity: 'error',\n        category: 'logic',\n      };\n      result.issues = [...(result.issues || []), errorIssue];\n      return;\n    }\n\n    if (context.debug) {\n      logger.info(`[Routing] on_finish.goto: ${gotoTarget}`);\n    }\n\n    // Increment loop count\n    state.routingLoopCount++;\n\n    // Enqueue forward run event\n    emitEvent({\n      type: 'ForwardRunRequested',\n      target: gotoTarget,\n      scope,\n      origin: 'goto_js',\n    });\n\n    // Mark that we've seen a forward run\n    state.flags.forwardRunRequested = true;\n  }\n\n  // If we scheduled any forward-run targets via on_finish, request a wave retry so\n  // dependent checks (with if conditions) can re-evaluate after the forward-run completes.\n  // Guard: only enqueue once per originating check per wave to avoid loops.\n  if (queuedForward) {\n    const guardKey = `waveRetry:on_finish:${checkId}:wave:${state.wave}`;\n    if (!(state as any).forwardRunGuards?.has(guardKey)) {\n      (state as any).forwardRunGuards?.add(guardKey);\n      emitEvent({ type: 'WaveRetry', reason: 'on_finish' });\n    }\n  }\n}\n\n/**\n * Evaluate fail_if conditions for a check\n */\nasync function evaluateFailIf(\n  checkId: string,\n  result: ReviewSummary,\n  checkConfig: CheckConfig,\n  context: EngineContext,\n  state: RunState\n): Promise<boolean> {\n  const config = context.config;\n\n  // Check for fail_if at global or check level\n  const globalFailIf = config.fail_if;\n  const checkFailIf = checkConfig.fail_if;\n\n  if (!globalFailIf && !checkFailIf) {\n    return false; // No fail_if conditions\n  }\n\n  const evaluator = new FailureConditionEvaluator();\n\n  // Build outputs record from state\n  const outputsRecord: Record<string, ReviewSummary> = {};\n  for (const [key] of state.stats.entries()) {\n    // Try to get the actual result from context.journal if available\n    try {\n      const snapshotId = context.journal.beginSnapshot();\n      const contextView = new (require('../../snapshot-store').ContextView)(\n        context.journal,\n        context.sessionId,\n        snapshotId,\n        [],\n        context.event\n      );\n      const journalResult = contextView.get(key);\n      if (journalResult) {\n        outputsRecord[key] = journalResult as ReviewSummary;\n      }\n    } catch {\n      // Fallback to empty result\n      outputsRecord[key] = { issues: [] };\n    }\n  }\n\n  const checkSchema = typeof checkConfig.schema === 'object' ? 'custom' : checkConfig.schema || '';\n  const checkGroup = checkConfig.group || '';\n\n  // Evaluate global fail_if\n  if (globalFailIf) {\n    try {\n      const failed = await evaluator.evaluateSimpleCondition(\n        checkId,\n        checkSchema,\n        checkGroup,\n        result,\n        globalFailIf,\n        outputsRecord\n      );\n\n      if (failed) {\n        logger.warn(`[Routing] Global fail_if triggered for ${checkId}: ${globalFailIf}`);\n\n        // Add fail_if issue to result\n        const failIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: 'global_fail_if',\n          message: `Global failure condition met: ${globalFailIf}`,\n          severity: 'error',\n          category: 'logic',\n        };\n\n        result.issues = [...(result.issues || []), failIssue];\n        return true;\n      }\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : String(error);\n      logger.error(`[Routing] Error evaluating global fail_if: ${msg}`);\n    }\n  }\n\n  // Evaluate check-specific fail_if\n  if (checkFailIf) {\n    try {\n      const failed = await evaluator.evaluateSimpleCondition(\n        checkId,\n        checkSchema,\n        checkGroup,\n        result,\n        checkFailIf,\n        outputsRecord\n      );\n\n      if (failed) {\n        logger.warn(`[Routing] Check fail_if triggered for ${checkId}: ${checkFailIf}`);\n\n        // Add fail_if issue to result\n        const failIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}_fail_if`,\n          message: `Check failure condition met: ${checkFailIf}`,\n          severity: 'error',\n          category: 'logic',\n        };\n\n        result.issues = [...(result.issues || []), failIssue];\n        return true;\n      }\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : String(error);\n      logger.error(`[Routing] Error evaluating check fail_if: ${msg}`);\n    }\n  }\n\n  return false;\n}\n\n/**\n * Check if routing loop budget is exceeded\n */\nexport function checkLoopBudget(\n  context: EngineContext,\n  state: RunState,\n  origin: 'on_success' | 'on_fail' | 'on_finish',\n  action: 'run' | 'goto'\n): boolean {\n  const maxLoops = context.config.routing?.max_loops ?? 10;\n\n  if (state.routingLoopCount >= maxLoops) {\n    const msg = `Routing loop budget exceeded (max_loops=${maxLoops}) during ${origin} ${action}`;\n    logger.error(`[Routing] ${msg}`);\n    return true; // Budget exceeded\n  }\n\n  return false; // Budget OK\n}\n\n/**\n * Process on_success routing\n */\nasync function processOnSuccess(\n  checkId: string,\n  scope: Array<{ check: string; index: number }>,\n  result: ReviewSummary,\n  checkConfig: CheckConfig,\n  context: EngineContext,\n  state: RunState,\n  emitEvent: (event: EngineEvent) => void\n): Promise<void> {\n  const onSuccess = checkConfig.on_success;\n\n  if (!onSuccess) {\n    return; // No on_success configuration\n  }\n\n  if (context.debug) {\n    logger.info(`[Routing] Processing on_success for ${checkId}`);\n  }\n\n  // Process on_success.run\n  if (onSuccess.run && onSuccess.run.length > 0) {\n    // Check if current check is a forEach parent with items\n    const currentCheckIsForEach = checkConfig.forEach === true;\n    const forEachItems = currentCheckIsForEach ? (result as any).forEachItems : undefined;\n    const hasForEachItems = Array.isArray(forEachItems) && forEachItems.length > 0;\n\n    for (const targetCheck of onSuccess.run) {\n      // Check loop budget before scheduling\n      if (checkLoopBudget(context, state, 'on_success', 'run')) {\n        // Add error issue to result\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_success run`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return; // Stop processing\n      }\n\n      // Handle fanout: check if target has fanout configuration\n      const targetConfig = context.config.checks?.[targetCheck];\n      const fanoutMode = targetConfig?.fanout || 'reduce'; // default to reduce\n\n      if (context.debug) {\n        logger.info(`[Routing] on_success.run: scheduling ${targetCheck} with fanout=${fanoutMode}, hasForEachItems=${hasForEachItems}`);\n      }\n\n      // If current check has forEach items and target is map fanout, emit one event per item\n      if (fanoutMode === 'map' && hasForEachItems) {\n        // Map fanout: emit one ForwardRunRequested per forEach item\n        for (let itemIndex = 0; itemIndex < forEachItems!.length; itemIndex++) {\n          // Increment loop count for each item\n          state.routingLoopCount++;\n\n          const itemScope: Array<{ check: string; index: number }> = [\n            { check: checkId, index: itemIndex }\n          ];\n\n          emitEvent({\n            type: 'ForwardRunRequested',\n            target: targetCheck,\n            scope: itemScope,\n            origin: 'run',\n          });\n        }\n      } else {\n        // Reduce fanout (or no forEach context): emit with empty scope once\n        // Increment loop count\n        state.routingLoopCount++;\n\n        emitEvent({\n          type: 'ForwardRunRequested',\n          target: targetCheck,\n          scope: [],\n          origin: 'run',\n        });\n      }\n    }\n  }\n\n  // Process on_success.run_js\n  if (onSuccess.run_js) {\n    const dynamicTargets = await evaluateRunJs(\n      onSuccess.run_js,\n      checkId,\n      checkConfig,\n      result,\n      context,\n      state\n    );\n\n    for (const targetCheck of dynamicTargets) {\n      // Check loop budget before scheduling\n      if (checkLoopBudget(context, state, 'on_success', 'run')) {\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_success run`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return;\n      }\n\n      if (context.debug) {\n        logger.info(`[Routing] on_success.run_js: scheduling ${targetCheck}`);\n      }\n\n      // Increment loop count\n      state.routingLoopCount++;\n\n      emitEvent({\n        type: 'ForwardRunRequested',\n        target: targetCheck,\n        scope,\n        origin: 'run_js',\n      });\n    }\n  }\n\n  // Process on_success.goto / goto_js\n  const gotoTarget = await evaluateGoto(\n    onSuccess.goto_js,\n    onSuccess.goto,\n    checkId,\n    checkConfig,\n    result,\n    context,\n    state\n  );\n\n  if (gotoTarget) {\n    // Check loop budget before scheduling goto\n    if (checkLoopBudget(context, state, 'on_success', 'goto')) {\n      const errorIssue: ReviewIssue = {\n        file: 'system',\n        line: 0,\n        ruleId: `${checkId}/routing/loop_budget_exceeded`,\n        message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_success goto`,\n        severity: 'error',\n        category: 'logic',\n      };\n      result.issues = [...(result.issues || []), errorIssue];\n      return;\n    }\n\n    if (context.debug) {\n      logger.info(`[Routing] on_success.goto: ${gotoTarget}`);\n    }\n\n    // Increment loop count\n    state.routingLoopCount++;\n\n    // Enqueue forward run event with optional event override\n    emitEvent({\n      type: 'ForwardRunRequested',\n      target: gotoTarget,\n      gotoEvent: onSuccess.goto_event,\n      scope,\n      origin: 'goto_js',\n    });\n\n    // Mark that we've seen a forward run\n    state.flags.forwardRunRequested = true;\n  }\n}\n\n/**\n * Process on_fail routing\n */\nasync function processOnFail(\n  checkId: string,\n  scope: Array<{ check: string; index: number }>,\n  result: ReviewSummary,\n  checkConfig: CheckConfig,\n  context: EngineContext,\n  state: RunState,\n  emitEvent: (event: EngineEvent) => void\n): Promise<void> {\n  // Merge defaults with check-specific on_fail\n  const defaults = context.config.routing?.defaults?.on_fail || {};\n  const onFail: OnFailConfig | undefined = checkConfig.on_fail\n    ? { ...defaults, ...checkConfig.on_fail }\n    : undefined;\n\n  if (!onFail) {\n    return; // No on_fail configuration\n  }\n\n  if (context.debug) {\n    logger.info(`[Routing] Processing on_fail for ${checkId}`);\n  }\n\n  // Process on_fail.run\n  if (onFail.run && onFail.run.length > 0) {\n    // Check if current check is a forEach parent with items\n    const currentCheckIsForEach = checkConfig.forEach === true;\n    const forEachItems = currentCheckIsForEach ? (result as any).forEachItems : undefined;\n    const hasForEachItems = Array.isArray(forEachItems) && forEachItems.length > 0;\n\n    for (const targetCheck of onFail.run) {\n      // Check loop budget before scheduling\n      if (checkLoopBudget(context, state, 'on_fail', 'run')) {\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_fail run`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return;\n      }\n\n      // Handle fanout: check if target has fanout configuration\n      const targetConfig = context.config.checks?.[targetCheck];\n      const fanoutMode = targetConfig?.fanout || 'reduce'; // default to reduce\n\n      if (context.debug) {\n        logger.info(`[Routing] on_fail.run: scheduling ${targetCheck} with fanout=${fanoutMode}, hasForEachItems=${hasForEachItems}`);\n      }\n\n      // If current check has forEach items and target is map fanout, emit one event per item\n      if (fanoutMode === 'map' && hasForEachItems) {\n        // Map fanout: emit one ForwardRunRequested per forEach item\n        for (let itemIndex = 0; itemIndex < forEachItems!.length; itemIndex++) {\n          // Increment loop count for each item\n          state.routingLoopCount++;\n\n          const itemScope: Array<{ check: string; index: number }> = [\n            { check: checkId, index: itemIndex }\n          ];\n\n          emitEvent({\n            type: 'ForwardRunRequested',\n            target: targetCheck,\n            scope: itemScope,\n          });\n        }\n      } else {\n        // Reduce fanout (or no forEach context): emit with empty scope once\n        // Increment loop count\n        state.routingLoopCount++;\n\n        emitEvent({\n          type: 'ForwardRunRequested',\n          target: targetCheck,\n          scope: [],\n        });\n      }\n    }\n  }\n\n  // Process on_fail.run_js\n  if (onFail.run_js) {\n    const dynamicTargets = await evaluateRunJs(\n      onFail.run_js,\n      checkId,\n      checkConfig,\n      result,\n      context,\n      state\n    );\n\n    for (const targetCheck of dynamicTargets) {\n      // Check loop budget before scheduling\n      if (checkLoopBudget(context, state, 'on_fail', 'run')) {\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_fail run`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return;\n      }\n\n      if (context.debug) {\n        logger.info(`[Routing] on_fail.run_js: scheduling ${targetCheck}`);\n      }\n\n      // Increment loop count\n      state.routingLoopCount++;\n\n      emitEvent({\n        type: 'ForwardRunRequested',\n        target: targetCheck,\n        scope,\n        origin: 'run_js',\n      });\n    }\n  }\n\n  // Process on_fail.goto / goto_js\n  const gotoTarget = await evaluateGoto(\n    onFail.goto_js,\n    onFail.goto,\n    checkId,\n    checkConfig,\n    result,\n    context,\n    state\n  );\n\n  if (gotoTarget) {\n    // Check loop budget before scheduling goto\n    if (checkLoopBudget(context, state, 'on_fail', 'goto')) {\n      const errorIssue: ReviewIssue = {\n        file: 'system',\n        line: 0,\n        ruleId: `${checkId}/routing/loop_budget_exceeded`,\n        message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_fail goto`,\n        severity: 'error',\n        category: 'logic',\n      };\n      result.issues = [...(result.issues || []), errorIssue];\n      return;\n    }\n\n    if (context.debug) {\n      logger.info(`[Routing] on_fail.goto: ${gotoTarget}`);\n    }\n\n    // Increment loop count\n    state.routingLoopCount++;\n\n    // Enqueue forward run event with optional event override\n    emitEvent({\n      type: 'ForwardRunRequested',\n      target: gotoTarget,\n      gotoEvent: onFail.goto_event,\n      scope,\n      origin: 'goto_js',\n    });\n\n    // Mark that we've seen a forward run\n    state.flags.forwardRunRequested = true;\n  }\n}\n\n/**\n * Evaluate run_js expression to get dynamic check targets\n */\nasync function evaluateRunJs(\n  runJs: string,\n  checkId: string,\n  checkConfig: CheckConfig,\n  result: ReviewSummary,\n  context: EngineContext,\n  state: RunState\n): Promise<string[]> {\n  try {\n    const sandbox = createSecureSandbox();\n\n    // Build outputs record and outputs_history\n    const snapshotId = context.journal.beginSnapshot();\n    const contextView = new (require('../../snapshot-store').ContextView)(\n      context.journal,\n      context.sessionId,\n      snapshotId,\n      [],\n      context.event\n    );\n\n    const outputsRecord: Record<string, any> = {};\n    const outputsHistory: Record<string, any[]> = {};\n\n    // Get all visible journal entries to build complete history\n    const allEntries = context.journal.readVisible(context.sessionId, snapshotId, context.event);\n    const uniqueCheckIds = new Set(allEntries.map(e => e.checkId));\n\n    for (const checkIdFromJournal of uniqueCheckIds) {\n      try {\n        // Get current output for this check\n        const journalResult = contextView.get(checkIdFromJournal);\n        if (journalResult) {\n          // Prefer the output field if present, otherwise use the full result\n          outputsRecord[checkIdFromJournal] = journalResult.output !== undefined ? journalResult.output : journalResult;\n        }\n      } catch {\n        outputsRecord[checkIdFromJournal] = { issues: [] };\n      }\n\n      // Build history for this check\n      try {\n        const history = contextView.getHistory(checkIdFromJournal);\n        if (history && history.length > 0) {\n          // Extract outputs from history (prefer output field if available)\n          outputsHistory[checkIdFromJournal] = history.map((r: any) => r.output !== undefined ? r.output : r);\n        }\n      } catch {\n        // Ignore history errors\n      }\n    }\n\n    // Add history as a property on outputs object for convenient access\n    outputsRecord.history = outputsHistory;\n\n    const scopeObj: any = {\n      step: {\n        id: checkId,\n        tags: checkConfig.tags || [],\n        group: checkConfig.group\n      },\n      outputs: outputsRecord,\n      outputs_history: outputsHistory,\n      output: (result as any)?.output,\n      memory: createMemoryHelpers(),\n      event: {\n        name: context.event || 'manual'\n      },\n    };\n\n    const code = `\n      const step = scope.step;\n      const outputs = scope.outputs;\n      const outputs_history = scope.outputs_history;\n      const output = scope.output;\n      const memory = scope.memory;\n      const event = scope.event;\n      const log = (...args) => console.log('üîç Debug:', ...args);\n      const __fn = () => {\n        ${runJs}\n      };\n      const __res = __fn();\n      return Array.isArray(__res) ? __res.filter(x => typeof x === 'string' && x) : [];\n    `;\n\n    const evalResult = compileAndRun<string[]>(\n      sandbox,\n      code,\n      { scope: scopeObj },\n      { injectLog: false, wrapFunction: false }\n    );\n\n    return Array.isArray(evalResult) ? evalResult.filter(Boolean) : [];\n  } catch (error) {\n    const msg = error instanceof Error ? error.message : String(error);\n    logger.error(`[Routing] Error evaluating run_js: ${msg}`);\n    return [];\n  }\n}\n\n/**\n * Evaluate goto_js or return static goto target\n */\nexport async function evaluateGoto(\n  gotoJs: string | undefined,\n  gotoStatic: string | undefined,\n  checkId: string,\n  checkConfig: CheckConfig,\n  result: ReviewSummary,\n  context: EngineContext,\n  state: RunState\n): Promise<string | null> {\n  // Evaluate goto_js first\n  if (gotoJs) {\n    try {\n      const sandbox = createSecureSandbox();\n\n      // Build outputs record and outputs_history\n      const snapshotId = context.journal.beginSnapshot();\n      const contextView = new (require('../../snapshot-store').ContextView)(\n        context.journal,\n        context.sessionId,\n        snapshotId,\n        [],\n        context.event\n      );\n\n      const outputsRecord: Record<string, any> = {};\n      const outputsHistory: Record<string, any[]> = {};\n\n      // Get all visible journal entries to build complete history\n      const allEntries = context.journal.readVisible(context.sessionId, snapshotId, context.event);\n      const uniqueCheckIds = new Set(allEntries.map(e => e.checkId));\n\n      for (const checkIdFromJournal of uniqueCheckIds) {\n        try {\n          // Get current output for this check\n          const journalResult = contextView.get(checkIdFromJournal);\n          if (journalResult) {\n            // Prefer the output field if present, otherwise use the full result\n            outputsRecord[checkIdFromJournal] = journalResult.output !== undefined ? journalResult.output : journalResult;\n          }\n        } catch {\n          outputsRecord[checkIdFromJournal] = { issues: [] };\n        }\n\n        // Build history for this check\n        try {\n          const history = contextView.getHistory(checkIdFromJournal);\n          if (history && history.length > 0) {\n            // Extract outputs from history (prefer output field if available)\n            outputsHistory[checkIdFromJournal] = history.map((r: any) => r.output !== undefined ? r.output : r);\n          }\n        } catch {\n          // Ignore history errors\n        }\n      }\n\n      // Add history as a property on outputs object for convenient access\n      outputsRecord.history = outputsHistory;\n\n      const scopeObj: any = {\n        step: {\n          id: checkId,\n          tags: checkConfig.tags || [],\n          group: checkConfig.group\n        },\n        outputs: outputsRecord,\n        outputs_history: outputsHistory,\n        output: (result as any)?.output,\n        memory: createMemoryHelpers(),\n        event: {\n          name: context.event || 'manual'\n        },\n      };\n\n      // Debug: Log outputs_history\n      if (context.debug) {\n        logger.info(`[Routing] evaluateGoto: checkId=${checkId}, outputs_history keys=${Object.keys(outputsHistory).join(',')}`);\n        for (const [key, values] of Object.entries(outputsHistory)) {\n          logger.info(`[Routing]   ${key}: ${values.length} items`);\n        }\n      }\n\n      const code = `\n        const step = scope.step;\n        const outputs = scope.outputs;\n        const outputs_history = scope.outputs_history;\n        const output = scope.output;\n        const memory = scope.memory;\n        const event = scope.event;\n        const log = (...args) => console.log('üîç Debug:', ...args);\n        ${gotoJs}\n      `;\n\n      const evalResult = compileAndRun<string | null>(\n        sandbox,\n        code,\n        { scope: scopeObj },\n        { injectLog: false, wrapFunction: true }\n      );\n\n      if (context.debug) {\n        logger.info(`[Routing] evaluateGoto result: ${evalResult}`);\n      }\n\n      if (typeof evalResult === 'string' && evalResult) {\n        return evalResult;\n      }\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : String(error);\n      logger.error(`[Routing] Error evaluating goto_js: ${msg}`);\n\n      // Fall back to static goto if available\n      if (gotoStatic) {\n        logger.info(`[Routing] Falling back to static goto: ${gotoStatic}`);\n        return gotoStatic;\n      }\n    }\n  }\n\n  // Return static goto\n  return gotoStatic || null;\n}\n"],"mappings":"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","names":[]}