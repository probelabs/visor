{"version":3,"sources":["../../src/liquid-extensions.ts"],"sourcesContent":["import { Liquid, TagToken, Context, TopLevelToken, Tag, Value, Emitter } from 'liquidjs';\nimport { AsyncLocalStorage } from 'async_hooks';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport {\n  hasMinPermission,\n  isOwner,\n  isMember,\n  isCollaborator,\n  isContributor,\n  isFirstTimer,\n  detectLocalMode,\n} from './utils/author-permissions';\nimport { MemoryStore } from './memory-store';\n\n/**\n * Sanitize label strings to only allow [A-Za-z0-9:/\\- ] characters (including spaces and hyphens)\n * @param value - Label value to sanitize\n * @returns Sanitized label string\n */\nexport function sanitizeLabel(value: unknown): string {\n  if (value == null) return '';\n  const s = String(value);\n  // Keep only alphanumerics, colon, slash, hyphen, and space; collapse repeated slashes and trim\n  return s\n    .replace(/[^A-Za-z0-9:\\/\\- ]/g, '')\n    .replace(/\\/{2,}/g, '/')\n    .trim();\n}\n\n/**\n * Sanitize an array of labels\n * @param labels - Array of label values\n * @returns Array of sanitized, non-empty label strings\n */\nexport function sanitizeLabelList(labels: unknown): string[] {\n  if (!Array.isArray(labels)) return [];\n  return (labels as unknown[]).map(v => sanitizeLabel(v)).filter(s => s.length > 0);\n}\n\n/**\n * Custom ReadFile tag for Liquid templates\n * Usage: {% readfile \"path/to/file.txt\" %}\n * or with variable: {% readfile filename %}\n */\nexport class ReadFileTag extends Tag {\n  private filepath: Value;\n\n  constructor(token: TagToken, remainTokens: TopLevelToken[], liquid: Liquid) {\n    super(token, remainTokens, liquid);\n    this.filepath = new Value(token.args, liquid);\n  }\n\n  *render(ctx: Context, emitter: Emitter): Generator<unknown, void, unknown> {\n    const filePath = yield this.filepath.value(ctx, false);\n\n    // Validate the path\n    if (!filePath || typeof filePath !== 'string') {\n      emitter.write('[Error: Invalid file path]');\n      return;\n    }\n\n    // Security: Resolve path relative to project root to prevent directory traversal\n    const projectRoot = process.cwd();\n    const resolvedPath = path.resolve(projectRoot, filePath.toString());\n\n    // Ensure the resolved path is within the project directory\n    if (!resolvedPath.startsWith(projectRoot)) {\n      emitter.write('[Error: File path escapes project directory]');\n      return;\n    }\n\n    // Read the file content\n    try {\n      const content = yield fs.readFile(resolvedPath, 'utf-8');\n      emitter.write(content);\n    } catch (error) {\n      // Handle file read errors gracefully\n      const errorMessage =\n        error instanceof Error\n          ? error.message\n          : (error as NodeJS.ErrnoException)?.code || 'Unknown error';\n      emitter.write(`[Error reading file: ${errorMessage}]`);\n    }\n  }\n}\n\n// Async-local permissions context for filters (per-render)\nconst permissionsALS = new AsyncLocalStorage<{ authorAssociation?: string }>();\n\nexport async function withPermissionsContext<T>(\n  ctx: { authorAssociation?: string },\n  fn: () => Promise<T>\n): Promise<T> {\n  return await permissionsALS.run(ctx, fn as any);\n}\n\n/**\n * Configure a Liquid instance with custom extensions\n */\nexport function configureLiquidWithExtensions(liquid: Liquid): void {\n  // Register the readfile tag\n  liquid.registerTag('readfile', ReadFileTag);\n\n  // Register parse_json filter to parse JSON strings into objects\n  liquid.registerFilter('parse_json', (value: string) => {\n    if (typeof value !== 'string') {\n      return value;\n    }\n    try {\n      return JSON.parse(value);\n    } catch {\n      // Return original value if parsing fails\n      return value;\n    }\n  });\n\n  // Register to_json filter as alias for json (for consistency)\n  liquid.registerFilter('to_json', (value: unknown) => {\n    try {\n      return JSON.stringify(value);\n    } catch {\n      return '[Error: Unable to serialize to JSON]';\n    }\n  });\n\n  // Register base64 filter for encoding strings\n  // Usage: {{ \"user:password\" | base64 }}\n  liquid.registerFilter('base64', (value: unknown) => {\n    if (value == null) return '';\n    const str = String(value);\n    return Buffer.from(str).toString('base64');\n  });\n\n  // Register base64_decode filter for decoding base64 strings\n  // Usage: {{ encoded_value | base64_decode }}\n  liquid.registerFilter('base64_decode', (value: unknown) => {\n    if (value == null) return '';\n    const str = String(value);\n    try {\n      return Buffer.from(str, 'base64').toString('utf-8');\n    } catch {\n      return '[Error: Invalid base64 string]';\n    }\n  });\n\n  // Sanitize a label to allowed characters only: [A-Za-z0-9:/]\n  liquid.registerFilter('safe_label', (value: unknown) => sanitizeLabel(value));\n\n  // Sanitize an array of labels\n  liquid.registerFilter('safe_label_list', (value: unknown) => sanitizeLabelList(value));\n\n  // Convert literal escape sequences (e.g., \"\\n\") into actual newlines\n  liquid.registerFilter('unescape_newlines', (value: unknown) => {\n    if (value == null) return '';\n    const s = String(value);\n    return s.replace(/\\\\n/g, '\\n').replace(/\\\\r/g, '\\r').replace(/\\\\t/g, '\\t');\n  });\n\n  // JSON escape filter - escapes a string for use inside a JSON string value\n  // This escapes special characters like quotes, backslashes, and control characters\n  // Usage: \"jql\": \"{{ myValue | json_escape }}\"\n  liquid.registerFilter('json_escape', (value: unknown) => {\n    if (value == null) return '';\n    const s = String(value);\n    // Use JSON.stringify which handles all escaping, then strip the surrounding quotes\n    const jsonStr = JSON.stringify(s);\n    // Remove the first and last character (the quotes added by JSON.stringify)\n    return jsonStr.slice(1, -1);\n  });\n\n  // Shell escape filter - wraps value in single quotes with proper escaping\n  // Usage: {{ value | shell_escape }}\n  // Example: \"hello'world\" becomes \"'hello'\\''world'\"\n  // This is POSIX-compliant and safe for arbitrary text including mermaid diagrams\n  liquid.registerFilter('shell_escape', (value: unknown) => {\n    if (value == null) return \"''\";\n    const s = String(value);\n    // Replace single quotes with: end quote, escaped quote, start quote\n    // Then wrap the entire thing in single quotes\n    return \"'\" + s.replace(/'/g, \"'\\\\''\") + \"'\";\n  });\n\n  // Alias for shell_escape\n  liquid.registerFilter('escape_shell', (value: unknown) => {\n    if (value == null) return \"''\";\n    const s = String(value);\n    return \"'\" + s.replace(/'/g, \"'\\\\''\") + \"'\";\n  });\n\n  // Shell escape for double quotes (less safe but sometimes needed)\n  // Usage: {{ value | shell_escape_double }}\n  // Escapes: $, `, \\, \", and !\n  liquid.registerFilter('shell_escape_double', (value: unknown) => {\n    if (value == null) return '\"\"';\n    const s = String(value);\n    // Escape characters that have special meaning inside double quotes\n    const escaped = s\n      .replace(/\\\\/g, '\\\\\\\\')  // backslash first\n      .replace(/\\$/g, '\\\\$')   // dollar sign\n      .replace(/`/g, '\\\\`')    // backticks\n      .replace(/\"/g, '\\\\\"')    // double quotes\n      .replace(/!/g, '\\\\!');   // history expansion\n    return '\"' + escaped + '\"';\n  });\n\n  // Register author permission filters (from main)\n  // These filters check the author's permission level; detect local mode for tests\n  const isLocal = detectLocalMode();\n\n  const resolveAssoc = (val: unknown): string | undefined => {\n    if (typeof val === 'string' && val.length > 0) return val;\n    const store = permissionsALS.getStore();\n    return store?.authorAssociation;\n  };\n\n  liquid.registerFilter('has_min_permission', (authorAssociation: unknown, level: string) => {\n    return hasMinPermission(resolveAssoc(authorAssociation), level as any, isLocal);\n  });\n\n  liquid.registerFilter('is_owner', (authorAssociation: unknown) => {\n    return isOwner(resolveAssoc(authorAssociation), isLocal);\n  });\n\n  liquid.registerFilter('is_member', (authorAssociation: unknown) => {\n    return isMember(resolveAssoc(authorAssociation), isLocal);\n  });\n\n  liquid.registerFilter('is_collaborator', (authorAssociation: unknown) => {\n    return isCollaborator(resolveAssoc(authorAssociation), isLocal);\n  });\n\n  liquid.registerFilter('is_contributor', (authorAssociation: unknown) => {\n    return isContributor(resolveAssoc(authorAssociation), isLocal);\n  });\n\n  liquid.registerFilter('is_first_timer', (authorAssociation: unknown) => {\n    return isFirstTimer(resolveAssoc(authorAssociation), isLocal);\n  });\n\n  // Register memory filters for accessing memory store\n  const memoryStore = MemoryStore.getInstance();\n\n  liquid.registerFilter('memory_get', (key: string, namespace?: string) => {\n    if (typeof key !== 'string') {\n      return undefined;\n    }\n    return memoryStore.get(key, namespace);\n  });\n\n  liquid.registerFilter('memory_has', (key: string, namespace?: string) => {\n    if (typeof key !== 'string') {\n      return false;\n    }\n    const has = memoryStore.has(key, namespace);\n    try {\n      if (process.env.VISOR_DEBUG === 'true' && key === 'fact_validation_issues') {\n        console.error(\n          `[liquid] memory_has('${key}', ns='${namespace || memoryStore.getDefaultNamespace()}') => ${String(\n            has\n          )}`\n        );\n      }\n    } catch {}\n    return has;\n  });\n\n  liquid.registerFilter('memory_list', (namespace?: string) => {\n    return memoryStore.list(namespace);\n  });\n\n  // Generic helpers to radically simplify templates\n\n  // get: safe nested access using dot-path (e.g., obj | get: 'a.b.c')\n  liquid.registerFilter('get', (obj: any, pathExpr: unknown) => {\n    if (obj == null) return undefined;\n    const path = typeof pathExpr === 'string' ? pathExpr : String(pathExpr || '');\n    if (!path) return obj;\n    const parts = path.split('.');\n    let cur: any = obj;\n    for (const p of parts) {\n      if (cur == null) return undefined;\n      cur = cur[p as keyof typeof cur];\n    }\n    return cur;\n  });\n\n  // not_empty: true when value is a non-empty array/string/object with keys\n  liquid.registerFilter('not_empty', (v: unknown) => {\n    if (Array.isArray(v)) return v.length > 0;\n    if (typeof v === 'string') return v.length > 0;\n    if (v && typeof v === 'object') return Object.keys(v as object).length > 0;\n    return false;\n  });\n\n  // coalesce: pick first argument (value or candidates) that is a non-empty array/object/string\n  // Usage: a | coalesce: b, c, d\n  liquid.registerFilter('coalesce', (first: unknown, ...rest: unknown[]) => {\n    const all = [first, ...rest];\n    for (const v of all) {\n      if (Array.isArray(v) && v.length > 0) return v;\n      if (typeof v === 'string' && v.length > 0) return v;\n      if (v && typeof v === 'object' && Object.keys(v as object).length > 0) return v;\n    }\n    return Array.isArray(first) ? [] : (first ?? undefined);\n  });\n\n  // where_exp: generic expression-based filter (Shopify-style)\n  // Usage: array | where_exp: 'i', 'i.is_valid != true and i.confidence != \"high\"'\n  liquid.registerFilter('where_exp', (items: unknown, varName: string, expr: string) => {\n    const arr = Array.isArray(items) ? (items as any[]) : [];\n    const name = typeof varName === 'string' && varName.trim() ? varName.trim() : 'i';\n    const body = String(expr || '');\n    try {\n      // Build a tiny predicate; expose only item, idx, arr\n\n      const fn = new Function(\n        name,\n        'idx',\n        'arr',\n        `try { return (${body}); } catch { return false; }`\n      );\n      const out: any[] = [];\n      for (let idx = 0; idx < arr.length; idx++) {\n        const i = arr[idx];\n        let ok = false;\n        try {\n          ok = !!(fn as any)(i, idx, arr);\n        } catch {\n          ok = false;\n        }\n        if (ok) out.push(i);\n      }\n      return out;\n    } catch {\n      return [];\n    }\n  });\n\n  // chat_history: merge outputs_history from multiple steps into a normalized,\n  // timestamp-sorted chat transcript.\n  //\n  // Usage:\n  //   {% assign history = '' | chat_history: 'ask', 'reply' %}\n  //   {% for m in history %}\n  //     {{ m.role }}: {{ m.text }}\n  //   {% endfor %}\n  //\n  // Advanced usage with options:\n  //   '' | chat_history: 'ask', 'reply',\n  //        direction: 'desc',\n  //        limit: 50,\n  //        roles: { by_type: { 'human-input': 'user', 'ai': 'assistant' } },\n  //        text: { default_field: 'text', by_step: { reply: 'text' } }\n  liquid.registerFilter(\n    'chat_history',\n    function (this: unknown, value: unknown, ...args: unknown[]): unknown {\n      try {\n        // Access Liquid rendering context to read globals like outputs_history\n        const impl = this as { context?: { get: (key: string[] | string) => unknown } } | undefined;\n        const ctx = impl?.context;\n\n        // Parse arguments: one or more step names, optional options hash as last arg\n        const allArgs = Array.isArray(args) ? args : [];\n\n        if (allArgs.length === 0) {\n          return [];\n        }\n\n        // Liquid passes keyword arguments as trailing [\"key\", value] pairs.\n        // Split positional step names from an optional options hash built from those pairs.\n        const positional: unknown[] = [];\n        const options: any = {};\n        for (const arg of allArgs) {\n          if (\n            Array.isArray(arg) &&\n            arg.length === 2 &&\n            typeof arg[0] === 'string' &&\n            arg[0].length > 0\n          ) {\n            options[arg[0]] = arg[1];\n          } else {\n            positional.push(arg);\n          }\n        }\n        const stepArgs: unknown[] = positional;\n\n        const steps = stepArgs.map(s => String(s ?? '').trim()).filter(s => s.length > 0);\n        if (steps.length === 0) return [];\n\n        // Resolve history source: prefer outputs_history, fall back to outputs.history\n        const outputsHistoryVar = (ctx?.get(['outputs_history']) || {}) as Record<\n          string,\n          unknown[]\n        >;\n        const outputsVar = (ctx?.get(['outputs']) || {}) as { history?: Record<string, unknown[]> };\n        const outputsHistory: Record<string, unknown[]> =\n          outputsHistoryVar && Object.keys(outputsHistoryVar).length > 0\n            ? outputsHistoryVar\n            : outputsVar?.history || {};\n\n        // Optional checks metadata: used to infer roles by check type\n        const checksMeta =\n          (ctx?.get(['checks_meta']) as Record<string, { type?: string; group?: string }>) ||\n          ((ctx?.get(['event']) as any)?.payload?.__checksMeta as Record<\n            string,\n            { type?: string; group?: string }\n          >) ||\n          undefined;\n\n        // Direction and limit\n        const directionRaw =\n          typeof options.direction === 'string' ? options.direction.toLowerCase() : '';\n        const direction: 'asc' | 'desc' = directionRaw === 'desc' ? 'desc' : 'asc';\n        const limit =\n          typeof options.limit === 'number' && options.limit > 0\n            ? Math.floor(options.limit)\n            : undefined;\n\n        // Text mapping configuration\n        const textCfg = options.text && typeof options.text === 'object' ? options.text : {};\n        const defaultField =\n          typeof textCfg.default_field === 'string' && textCfg.default_field.trim()\n            ? textCfg.default_field.trim()\n            : 'text';\n        const byStepText: Record<string, string> = {};\n        if (textCfg.by_step && typeof textCfg.by_step === 'object') {\n          for (const [k, v] of Object.entries(textCfg.by_step)) {\n            if (typeof v === 'string' && v.trim()) {\n              byStepText[k] = v.trim();\n            }\n          }\n        }\n\n        // Role mapping configuration\n        const rolesCfg = options.roles && typeof options.roles === 'object' ? options.roles : {};\n        const byTypeRole: Record<string, string> = {};\n        if (rolesCfg.by_type && typeof rolesCfg.by_type === 'object') {\n          for (const [k, v] of Object.entries(rolesCfg.by_type)) {\n            if (typeof v === 'string' && v.trim()) {\n              byTypeRole[k] = v.trim();\n            }\n          }\n        }\n        const byStepRole: Record<string, string> = {};\n        if (rolesCfg.by_step && typeof rolesCfg.by_step === 'object') {\n          for (const [k, v] of Object.entries(rolesCfg.by_step)) {\n            if (typeof v === 'string' && v.trim()) {\n              byStepRole[k] = v.trim();\n            }\n          }\n        }\n        // Optional: step-level role map provided as a compact string, e.g. \"ask=user,reply=assistant\"\n        if (typeof options.role_map === 'string' && options.role_map.trim().length > 0) {\n          const parts = String(options.role_map)\n            .split(',')\n            .map(p => p.trim())\n            .filter(Boolean);\n          for (const part of parts) {\n            const eqIdx = part.indexOf('=');\n            if (eqIdx > 0) {\n              const k = part.slice(0, eqIdx).trim();\n              const v = part.slice(eqIdx + 1).trim();\n              if (k && v) {\n                byStepRole[k] = v;\n              }\n            }\n          }\n        }\n        const defaultRole =\n          typeof rolesCfg.default === 'string' && rolesCfg.default.trim()\n            ? rolesCfg.default.trim()\n            : undefined;\n\n        const getNested = (obj: any, path: string): unknown => {\n          if (!obj || !path) return undefined;\n          const parts = path.split('.');\n          let cur = obj;\n          for (const p of parts) {\n            if (cur == null) return undefined;\n            cur = cur[p];\n          }\n          return cur;\n        };\n\n        const normalizeText = (step: string, raw: any): string => {\n          try {\n            const overrideField = byStepText[step];\n            if (overrideField) {\n              const val = getNested(raw, overrideField);\n              if (val !== undefined && val !== null) {\n                const s = String(val);\n                if (s.trim().length > 0) return s;\n              }\n            }\n\n            if (raw && typeof raw === 'object') {\n              if (typeof (raw as any).text === 'string' && (raw as any).text.trim().length > 0) {\n                return (raw as any).text;\n              }\n              if (\n                typeof (raw as any).content === 'string' &&\n                (raw as any).content.trim().length > 0\n              ) {\n                return (raw as any).content;\n              }\n              const dfVal = (raw as any)[defaultField];\n              if (dfVal !== undefined && dfVal !== null) {\n                const s = String(dfVal);\n                if (s.trim().length > 0) return s;\n              }\n            }\n\n            if (typeof raw === 'string') return raw;\n            if (raw == null) return '';\n            try {\n              return JSON.stringify(raw);\n            } catch {\n              return String(raw);\n            }\n          } catch {\n            if (typeof raw === 'string') return raw;\n            return '';\n          }\n        };\n\n        const normalizeRole = (step: string): string => {\n          try {\n            if (byStepRole[step]) return byStepRole[step];\n            const meta = checksMeta ? (checksMeta as any)[step] : undefined;\n            const type = meta?.type as string | undefined;\n            if (type && byTypeRole[type]) return byTypeRole[type];\n            if (type === 'human-input') return 'user';\n            if (type === 'ai') return 'assistant';\n            if (defaultRole) return defaultRole;\n            if (type) {\n              if (type === 'human-input') return 'user';\n              if (type === 'ai') return 'assistant';\n            }\n          } catch {\n            // fall through\n          }\n          return 'assistant';\n        };\n\n        type ChatMessage = {\n          step: string;\n          role: string;\n          text: string;\n          ts: number;\n          raw: unknown;\n        };\n\n        const messages: ChatMessage[] = [];\n        const tsBase = Date.now();\n        let counter = 0;\n\n        for (const step of steps) {\n          const arr = (outputsHistory as any)?.[step] as unknown[];\n          if (!Array.isArray(arr)) continue;\n          for (const raw of arr) {\n            let ts: number | undefined;\n            if (raw && typeof raw === 'object' && typeof (raw as any).ts === 'number') {\n              ts = (raw as any).ts;\n            }\n            if (!Number.isFinite(ts as number)) {\n              ts = tsBase + counter++;\n            }\n            const text = normalizeText(step, raw);\n            const role = normalizeRole(step);\n            messages.push({ step, role, text, ts: ts as number, raw });\n          }\n        }\n\n        // Sort by timestamp and apply direction/limit\n        messages.sort((a, b) => a.ts - b.ts);\n        if (direction === 'desc') {\n          messages.reverse();\n        }\n\n        if (limit && limit > 0 && messages.length > limit) {\n          if (direction === 'asc') {\n            return messages.slice(messages.length - limit);\n          }\n          return messages.slice(0, limit);\n        }\n\n        return messages;\n      } catch {\n        return [];\n      }\n    }\n  );\n\n  // Removed: merge_sort_by filter (unused)\n}\n\n/**\n * Create a new Liquid instance with custom extensions\n */\nexport function createExtendedLiquid(options: Record<string, unknown> = {}): Liquid {\n  const liquid = new Liquid({\n    cache: false,\n    strictFilters: false,\n    strictVariables: false,\n    ...options,\n  });\n\n  configureLiquidWithExtensions(liquid);\n  return liquid;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA,SAAS,QAA0C,KAAK,aAAsB;AAC9E,SAAS,yBAAyB;AAClC,OAAO,QAAQ;AACf,OAAO,UAAU;AAiBV,SAAS,cAAc,OAAwB;AACpD,MAAI,SAAS,KAAM,QAAO;AAC1B,QAAM,IAAI,OAAO,KAAK;AAEtB,SAAO,EACJ,QAAQ,uBAAuB,EAAE,EACjC,QAAQ,WAAW,GAAG,EACtB,KAAK;AACV;AAOO,SAAS,kBAAkB,QAA2B;AAC3D,MAAI,CAAC,MAAM,QAAQ,MAAM,EAAG,QAAO,CAAC;AACpC,SAAQ,OAAqB,IAAI,OAAK,cAAc,CAAC,CAAC,EAAE,OAAO,OAAK,EAAE,SAAS,CAAC;AAClF;AAoDA,eAAsB,uBACpB,KACA,IACY;AACZ,SAAO,MAAM,eAAe,IAAI,KAAK,EAAS;AAChD;AAKO,SAAS,8BAA8B,QAAsB;AAElE,SAAO,YAAY,YAAY,WAAW;AAG1C,SAAO,eAAe,cAAc,CAAC,UAAkB;AACrD,QAAI,OAAO,UAAU,UAAU;AAC7B,aAAO;AAAA,IACT;AACA,QAAI;AACF,aAAO,KAAK,MAAM,KAAK;AAAA,IACzB,QAAQ;AAEN,aAAO;AAAA,IACT;AAAA,EACF,CAAC;AAGD,SAAO,eAAe,WAAW,CAAC,UAAmB;AACnD,QAAI;AACF,aAAO,KAAK,UAAU,KAAK;AAAA,IAC7B,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF,CAAC;AAID,SAAO,eAAe,UAAU,CAAC,UAAmB;AAClD,QAAI,SAAS,KAAM,QAAO;AAC1B,UAAM,MAAM,OAAO,KAAK;AACxB,WAAO,OAAO,KAAK,GAAG,EAAE,SAAS,QAAQ;AAAA,EAC3C,CAAC;AAID,SAAO,eAAe,iBAAiB,CAAC,UAAmB;AACzD,QAAI,SAAS,KAAM,QAAO;AAC1B,UAAM,MAAM,OAAO,KAAK;AACxB,QAAI;AACF,aAAO,OAAO,KAAK,KAAK,QAAQ,EAAE,SAAS,OAAO;AAAA,IACpD,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF,CAAC;AAGD,SAAO,eAAe,cAAc,CAAC,UAAmB,cAAc,KAAK,CAAC;AAG5E,SAAO,eAAe,mBAAmB,CAAC,UAAmB,kBAAkB,KAAK,CAAC;AAGrF,SAAO,eAAe,qBAAqB,CAAC,UAAmB;AAC7D,QAAI,SAAS,KAAM,QAAO;AAC1B,UAAM,IAAI,OAAO,KAAK;AACtB,WAAO,EAAE,QAAQ,QAAQ,IAAI,EAAE,QAAQ,QAAQ,IAAI,EAAE,QAAQ,QAAQ,GAAI;AAAA,EAC3E,CAAC;AAKD,SAAO,eAAe,eAAe,CAAC,UAAmB;AACvD,QAAI,SAAS,KAAM,QAAO;AAC1B,UAAM,IAAI,OAAO,KAAK;AAEtB,UAAM,UAAU,KAAK,UAAU,CAAC;AAEhC,WAAO,QAAQ,MAAM,GAAG,EAAE;AAAA,EAC5B,CAAC;AAMD,SAAO,eAAe,gBAAgB,CAAC,UAAmB;AACxD,QAAI,SAAS,KAAM,QAAO;AAC1B,UAAM,IAAI,OAAO,KAAK;AAGtB,WAAO,MAAM,EAAE,QAAQ,MAAM,OAAO,IAAI;AAAA,EAC1C,CAAC;AAGD,SAAO,eAAe,gBAAgB,CAAC,UAAmB;AACxD,QAAI,SAAS,KAAM,QAAO;AAC1B,UAAM,IAAI,OAAO,KAAK;AACtB,WAAO,MAAM,EAAE,QAAQ,MAAM,OAAO,IAAI;AAAA,EAC1C,CAAC;AAKD,SAAO,eAAe,uBAAuB,CAAC,UAAmB;AAC/D,QAAI,SAAS,KAAM,QAAO;AAC1B,UAAM,IAAI,OAAO,KAAK;AAEtB,UAAM,UAAU,EACb,QAAQ,OAAO,MAAM,EACrB,QAAQ,OAAO,KAAK,EACpB,QAAQ,MAAM,KAAK,EACnB,QAAQ,MAAM,KAAK,EACnB,QAAQ,MAAM,KAAK;AACtB,WAAO,MAAM,UAAU;AAAA,EACzB,CAAC;AAID,QAAM,UAAU,gBAAgB;AAEhC,QAAM,eAAe,CAAC,QAAqC;AACzD,QAAI,OAAO,QAAQ,YAAY,IAAI,SAAS,EAAG,QAAO;AACtD,UAAM,QAAQ,eAAe,SAAS;AACtC,WAAO,OAAO;AAAA,EAChB;AAEA,SAAO,eAAe,sBAAsB,CAAC,mBAA4B,UAAkB;AACzF,WAAO,iBAAiB,aAAa,iBAAiB,GAAG,OAAc,OAAO;AAAA,EAChF,CAAC;AAED,SAAO,eAAe,YAAY,CAAC,sBAA+B;AAChE,WAAO,QAAQ,aAAa,iBAAiB,GAAG,OAAO;AAAA,EACzD,CAAC;AAED,SAAO,eAAe,aAAa,CAAC,sBAA+B;AACjE,WAAO,SAAS,aAAa,iBAAiB,GAAG,OAAO;AAAA,EAC1D,CAAC;AAED,SAAO,eAAe,mBAAmB,CAAC,sBAA+B;AACvE,WAAO,eAAe,aAAa,iBAAiB,GAAG,OAAO;AAAA,EAChE,CAAC;AAED,SAAO,eAAe,kBAAkB,CAAC,sBAA+B;AACtE,WAAO,cAAc,aAAa,iBAAiB,GAAG,OAAO;AAAA,EAC/D,CAAC;AAED,SAAO,eAAe,kBAAkB,CAAC,sBAA+B;AACtE,WAAO,aAAa,aAAa,iBAAiB,GAAG,OAAO;AAAA,EAC9D,CAAC;AAGD,QAAM,cAAc,YAAY,YAAY;AAE5C,SAAO,eAAe,cAAc,CAAC,KAAa,cAAuB;AACvE,QAAI,OAAO,QAAQ,UAAU;AAC3B,aAAO;AAAA,IACT;AACA,WAAO,YAAY,IAAI,KAAK,SAAS;AAAA,EACvC,CAAC;AAED,SAAO,eAAe,cAAc,CAAC,KAAa,cAAuB;AACvE,QAAI,OAAO,QAAQ,UAAU;AAC3B,aAAO;AAAA,IACT;AACA,UAAM,MAAM,YAAY,IAAI,KAAK,SAAS;AAC1C,QAAI;AACF,UAAI,QAAQ,IAAI,gBAAgB,UAAU,QAAQ,0BAA0B;AAC1E,gBAAQ;AAAA,UACN,wBAAwB,GAAG,UAAU,aAAa,YAAY,oBAAoB,CAAC,SAAS;AAAA,YAC1F;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF,QAAQ;AAAA,IAAC;AACT,WAAO;AAAA,EACT,CAAC;AAED,SAAO,eAAe,eAAe,CAAC,cAAuB;AAC3D,WAAO,YAAY,KAAK,SAAS;AAAA,EACnC,CAAC;AAKD,SAAO,eAAe,OAAO,CAAC,KAAU,aAAsB;AAC5D,QAAI,OAAO,KAAM,QAAO;AACxB,UAAMA,QAAO,OAAO,aAAa,WAAW,WAAW,OAAO,YAAY,EAAE;AAC5E,QAAI,CAACA,MAAM,QAAO;AAClB,UAAM,QAAQA,MAAK,MAAM,GAAG;AAC5B,QAAI,MAAW;AACf,eAAW,KAAK,OAAO;AACrB,UAAI,OAAO,KAAM,QAAO;AACxB,YAAM,IAAI,CAAqB;AAAA,IACjC;AACA,WAAO;AAAA,EACT,CAAC;AAGD,SAAO,eAAe,aAAa,CAAC,MAAe;AACjD,QAAI,MAAM,QAAQ,CAAC,EAAG,QAAO,EAAE,SAAS;AACxC,QAAI,OAAO,MAAM,SAAU,QAAO,EAAE,SAAS;AAC7C,QAAI,KAAK,OAAO,MAAM,SAAU,QAAO,OAAO,KAAK,CAAW,EAAE,SAAS;AACzE,WAAO;AAAA,EACT,CAAC;AAID,SAAO,eAAe,YAAY,CAAC,UAAmB,SAAoB;AACxE,UAAM,MAAM,CAAC,OAAO,GAAG,IAAI;AAC3B,eAAW,KAAK,KAAK;AACnB,UAAI,MAAM,QAAQ,CAAC,KAAK,EAAE,SAAS,EAAG,QAAO;AAC7C,UAAI,OAAO,MAAM,YAAY,EAAE,SAAS,EAAG,QAAO;AAClD,UAAI,KAAK,OAAO,MAAM,YAAY,OAAO,KAAK,CAAW,EAAE,SAAS,EAAG,QAAO;AAAA,IAChF;AACA,WAAO,MAAM,QAAQ,KAAK,IAAI,CAAC,IAAK,SAAS;AAAA,EAC/C,CAAC;AAID,SAAO,eAAe,aAAa,CAAC,OAAgB,SAAiB,SAAiB;AACpF,UAAM,MAAM,MAAM,QAAQ,KAAK,IAAK,QAAkB,CAAC;AACvD,UAAM,OAAO,OAAO,YAAY,YAAY,QAAQ,KAAK,IAAI,QAAQ,KAAK,IAAI;AAC9E,UAAM,OAAO,OAAO,QAAQ,EAAE;AAC9B,QAAI;AAGF,YAAM,KAAK,IAAI;AAAA,QACb;AAAA,QACA;AAAA,QACA;AAAA,QACA,iBAAiB,IAAI;AAAA,MACvB;AACA,YAAM,MAAa,CAAC;AACpB,eAAS,MAAM,GAAG,MAAM,IAAI,QAAQ,OAAO;AACzC,cAAM,IAAI,IAAI,GAAG;AACjB,YAAI,KAAK;AACT,YAAI;AACF,eAAK,CAAC,CAAE,GAAW,GAAG,KAAK,GAAG;AAAA,QAChC,QAAQ;AACN,eAAK;AAAA,QACP;AACA,YAAI,GAAI,KAAI,KAAK,CAAC;AAAA,MACpB;AACA,aAAO;AAAA,IACT,QAAQ;AACN,aAAO,CAAC;AAAA,IACV;AAAA,EACF,CAAC;AAiBD,SAAO;AAAA,IACL;AAAA,IACA,SAAyB,UAAmB,MAA0B;AACpE,UAAI;AAEF,cAAM,OAAO;AACb,cAAM,MAAM,MAAM;AAGlB,cAAM,UAAU,MAAM,QAAQ,IAAI,IAAI,OAAO,CAAC;AAE9C,YAAI,QAAQ,WAAW,GAAG;AACxB,iBAAO,CAAC;AAAA,QACV;AAIA,cAAM,aAAwB,CAAC;AAC/B,cAAM,UAAe,CAAC;AACtB,mBAAW,OAAO,SAAS;AACzB,cACE,MAAM,QAAQ,GAAG,KACjB,IAAI,WAAW,KACf,OAAO,IAAI,CAAC,MAAM,YAClB,IAAI,CAAC,EAAE,SAAS,GAChB;AACA,oBAAQ,IAAI,CAAC,CAAC,IAAI,IAAI,CAAC;AAAA,UACzB,OAAO;AACL,uBAAW,KAAK,GAAG;AAAA,UACrB;AAAA,QACF;AACA,cAAM,WAAsB;AAE5B,cAAM,QAAQ,SAAS,IAAI,OAAK,OAAO,KAAK,EAAE,EAAE,KAAK,CAAC,EAAE,OAAO,OAAK,EAAE,SAAS,CAAC;AAChF,YAAI,MAAM,WAAW,EAAG,QAAO,CAAC;AAGhC,cAAM,oBAAqB,KAAK,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC;AAI7D,cAAM,aAAc,KAAK,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC;AAC9C,cAAM,iBACJ,qBAAqB,OAAO,KAAK,iBAAiB,EAAE,SAAS,IACzD,oBACA,YAAY,WAAW,CAAC;AAG9B,cAAM,aACH,KAAK,IAAI,CAAC,aAAa,CAAC,KACvB,KAAK,IAAI,CAAC,OAAO,CAAC,GAAW,SAAS,gBAIxC;AAGF,cAAM,eACJ,OAAO,QAAQ,cAAc,WAAW,QAAQ,UAAU,YAAY,IAAI;AAC5E,cAAM,YAA4B,iBAAiB,SAAS,SAAS;AACrE,cAAM,QACJ,OAAO,QAAQ,UAAU,YAAY,QAAQ,QAAQ,IACjD,KAAK,MAAM,QAAQ,KAAK,IACxB;AAGN,cAAM,UAAU,QAAQ,QAAQ,OAAO,QAAQ,SAAS,WAAW,QAAQ,OAAO,CAAC;AACnF,cAAM,eACJ,OAAO,QAAQ,kBAAkB,YAAY,QAAQ,cAAc,KAAK,IACpE,QAAQ,cAAc,KAAK,IAC3B;AACN,cAAM,aAAqC,CAAC;AAC5C,YAAI,QAAQ,WAAW,OAAO,QAAQ,YAAY,UAAU;AAC1D,qBAAW,CAAC,GAAG,CAAC,KAAK,OAAO,QAAQ,QAAQ,OAAO,GAAG;AACpD,gBAAI,OAAO,MAAM,YAAY,EAAE,KAAK,GAAG;AACrC,yBAAW,CAAC,IAAI,EAAE,KAAK;AAAA,YACzB;AAAA,UACF;AAAA,QACF;AAGA,cAAM,WAAW,QAAQ,SAAS,OAAO,QAAQ,UAAU,WAAW,QAAQ,QAAQ,CAAC;AACvF,cAAM,aAAqC,CAAC;AAC5C,YAAI,SAAS,WAAW,OAAO,SAAS,YAAY,UAAU;AAC5D,qBAAW,CAAC,GAAG,CAAC,KAAK,OAAO,QAAQ,SAAS,OAAO,GAAG;AACrD,gBAAI,OAAO,MAAM,YAAY,EAAE,KAAK,GAAG;AACrC,yBAAW,CAAC,IAAI,EAAE,KAAK;AAAA,YACzB;AAAA,UACF;AAAA,QACF;AACA,cAAM,aAAqC,CAAC;AAC5C,YAAI,SAAS,WAAW,OAAO,SAAS,YAAY,UAAU;AAC5D,qBAAW,CAAC,GAAG,CAAC,KAAK,OAAO,QAAQ,SAAS,OAAO,GAAG;AACrD,gBAAI,OAAO,MAAM,YAAY,EAAE,KAAK,GAAG;AACrC,yBAAW,CAAC,IAAI,EAAE,KAAK;AAAA,YACzB;AAAA,UACF;AAAA,QACF;AAEA,YAAI,OAAO,QAAQ,aAAa,YAAY,QAAQ,SAAS,KAAK,EAAE,SAAS,GAAG;AAC9E,gBAAM,QAAQ,OAAO,QAAQ,QAAQ,EAClC,MAAM,GAAG,EACT,IAAI,OAAK,EAAE,KAAK,CAAC,EACjB,OAAO,OAAO;AACjB,qBAAW,QAAQ,OAAO;AACxB,kBAAM,QAAQ,KAAK,QAAQ,GAAG;AAC9B,gBAAI,QAAQ,GAAG;AACb,oBAAM,IAAI,KAAK,MAAM,GAAG,KAAK,EAAE,KAAK;AACpC,oBAAM,IAAI,KAAK,MAAM,QAAQ,CAAC,EAAE,KAAK;AACrC,kBAAI,KAAK,GAAG;AACV,2BAAW,CAAC,IAAI;AAAA,cAClB;AAAA,YACF;AAAA,UACF;AAAA,QACF;AACA,cAAM,cACJ,OAAO,SAAS,YAAY,YAAY,SAAS,QAAQ,KAAK,IAC1D,SAAS,QAAQ,KAAK,IACtB;AAEN,cAAM,YAAY,CAAC,KAAUA,UAA0B;AACrD,cAAI,CAAC,OAAO,CAACA,MAAM,QAAO;AAC1B,gBAAM,QAAQA,MAAK,MAAM,GAAG;AAC5B,cAAI,MAAM;AACV,qBAAW,KAAK,OAAO;AACrB,gBAAI,OAAO,KAAM,QAAO;AACxB,kBAAM,IAAI,CAAC;AAAA,UACb;AACA,iBAAO;AAAA,QACT;AAEA,cAAM,gBAAgB,CAAC,MAAc,QAAqB;AACxD,cAAI;AACF,kBAAM,gBAAgB,WAAW,IAAI;AACrC,gBAAI,eAAe;AACjB,oBAAM,MAAM,UAAU,KAAK,aAAa;AACxC,kBAAI,QAAQ,UAAa,QAAQ,MAAM;AACrC,sBAAM,IAAI,OAAO,GAAG;AACpB,oBAAI,EAAE,KAAK,EAAE,SAAS,EAAG,QAAO;AAAA,cAClC;AAAA,YACF;AAEA,gBAAI,OAAO,OAAO,QAAQ,UAAU;AAClC,kBAAI,OAAQ,IAAY,SAAS,YAAa,IAAY,KAAK,KAAK,EAAE,SAAS,GAAG;AAChF,uBAAQ,IAAY;AAAA,cACtB;AACA,kBACE,OAAQ,IAAY,YAAY,YAC/B,IAAY,QAAQ,KAAK,EAAE,SAAS,GACrC;AACA,uBAAQ,IAAY;AAAA,cACtB;AACA,oBAAM,QAAS,IAAY,YAAY;AACvC,kBAAI,UAAU,UAAa,UAAU,MAAM;AACzC,sBAAM,IAAI,OAAO,KAAK;AACtB,oBAAI,EAAE,KAAK,EAAE,SAAS,EAAG,QAAO;AAAA,cAClC;AAAA,YACF;AAEA,gBAAI,OAAO,QAAQ,SAAU,QAAO;AACpC,gBAAI,OAAO,KAAM,QAAO;AACxB,gBAAI;AACF,qBAAO,KAAK,UAAU,GAAG;AAAA,YAC3B,QAAQ;AACN,qBAAO,OAAO,GAAG;AAAA,YACnB;AAAA,UACF,QAAQ;AACN,gBAAI,OAAO,QAAQ,SAAU,QAAO;AACpC,mBAAO;AAAA,UACT;AAAA,QACF;AAEA,cAAM,gBAAgB,CAAC,SAAyB;AAC9C,cAAI;AACF,gBAAI,WAAW,IAAI,EAAG,QAAO,WAAW,IAAI;AAC5C,kBAAM,OAAO,aAAc,WAAmB,IAAI,IAAI;AACtD,kBAAM,OAAO,MAAM;AACnB,gBAAI,QAAQ,WAAW,IAAI,EAAG,QAAO,WAAW,IAAI;AACpD,gBAAI,SAAS,cAAe,QAAO;AACnC,gBAAI,SAAS,KAAM,QAAO;AAC1B,gBAAI,YAAa,QAAO;AACxB,gBAAI,MAAM;AACR,kBAAI,SAAS,cAAe,QAAO;AACnC,kBAAI,SAAS,KAAM,QAAO;AAAA,YAC5B;AAAA,UACF,QAAQ;AAAA,UAER;AACA,iBAAO;AAAA,QACT;AAUA,cAAM,WAA0B,CAAC;AACjC,cAAM,SAAS,KAAK,IAAI;AACxB,YAAI,UAAU;AAEd,mBAAW,QAAQ,OAAO;AACxB,gBAAM,MAAO,iBAAyB,IAAI;AAC1C,cAAI,CAAC,MAAM,QAAQ,GAAG,EAAG;AACzB,qBAAW,OAAO,KAAK;AACrB,gBAAI;AACJ,gBAAI,OAAO,OAAO,QAAQ,YAAY,OAAQ,IAAY,OAAO,UAAU;AACzE,mBAAM,IAAY;AAAA,YACpB;AACA,gBAAI,CAAC,OAAO,SAAS,EAAY,GAAG;AAClC,mBAAK,SAAS;AAAA,YAChB;AACA,kBAAM,OAAO,cAAc,MAAM,GAAG;AACpC,kBAAM,OAAO,cAAc,IAAI;AAC/B,qBAAS,KAAK,EAAE,MAAM,MAAM,MAAM,IAAkB,IAAI,CAAC;AAAA,UAC3D;AAAA,QACF;AAGA,iBAAS,KAAK,CAAC,GAAG,MAAM,EAAE,KAAK,EAAE,EAAE;AACnC,YAAI,cAAc,QAAQ;AACxB,mBAAS,QAAQ;AAAA,QACnB;AAEA,YAAI,SAAS,QAAQ,KAAK,SAAS,SAAS,OAAO;AACjD,cAAI,cAAc,OAAO;AACvB,mBAAO,SAAS,MAAM,SAAS,SAAS,KAAK;AAAA,UAC/C;AACA,iBAAO,SAAS,MAAM,GAAG,KAAK;AAAA,QAChC;AAEA,eAAO;AAAA,MACT,QAAQ;AACN,eAAO,CAAC;AAAA,MACV;AAAA,IACF;AAAA,EACF;AAGF;AAKO,SAAS,qBAAqB,UAAmC,CAAC,GAAW;AAClF,QAAM,SAAS,IAAI,OAAO;AAAA,IACxB,OAAO;AAAA,IACP,eAAe;AAAA,IACf,iBAAiB;AAAA,IACjB,GAAG;AAAA,EACL,CAAC;AAED,gCAA8B,MAAM;AACpC,SAAO;AACT;AAlmBA,IA6Ca,aA2CP;AAxFN;AAAA;AAIA;AASA;AAgCO,IAAM,cAAN,cAA0B,IAAI;AAAA,MAC3B;AAAA,MAER,YAAY,OAAiB,cAA+B,QAAgB;AAC1E,cAAM,OAAO,cAAc,MAAM;AACjC,aAAK,WAAW,IAAI,MAAM,MAAM,MAAM,MAAM;AAAA,MAC9C;AAAA,MAEA,CAAC,OAAO,KAAc,SAAqD;AACzE,cAAM,WAAW,MAAM,KAAK,SAAS,MAAM,KAAK,KAAK;AAGrD,YAAI,CAAC,YAAY,OAAO,aAAa,UAAU;AAC7C,kBAAQ,MAAM,4BAA4B;AAC1C;AAAA,QACF;AAGA,cAAM,cAAc,QAAQ,IAAI;AAChC,cAAM,eAAe,KAAK,QAAQ,aAAa,SAAS,SAAS,CAAC;AAGlE,YAAI,CAAC,aAAa,WAAW,WAAW,GAAG;AACzC,kBAAQ,MAAM,8CAA8C;AAC5D;AAAA,QACF;AAGA,YAAI;AACF,gBAAM,UAAU,MAAM,GAAG,SAAS,cAAc,OAAO;AACvD,kBAAQ,MAAM,OAAO;AAAA,QACvB,SAAS,OAAO;AAEd,gBAAM,eACJ,iBAAiB,QACb,MAAM,UACL,OAAiC,QAAQ;AAChD,kBAAQ,MAAM,wBAAwB,YAAY,GAAG;AAAA,QACvD;AAAA,MACF;AAAA,IACF;AAGA,IAAM,iBAAiB,IAAI,kBAAkD;AAAA;AAAA;","names":["path"]}