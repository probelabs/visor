{"version":3,"sources":["../../src/memory-store.ts"],"sourcesContent":["import fs from 'fs/promises';\nimport path from 'path';\nimport { MemoryConfig } from './types/config';\nimport { logger } from './logger';\n\n/**\n * Memory store for persistent key-value storage across checks\n * Supports namespaces for isolation and both in-memory and file-based persistence\n */\nexport class MemoryStore {\n  private static instance: MemoryStore;\n  private data: Map<string, Map<string, unknown>>; // namespace -> key -> value\n  private config: MemoryConfig;\n  private initialized = false;\n\n  private constructor(config?: MemoryConfig) {\n    this.data = new Map();\n    this.config = this.normalizeConfig(config);\n  }\n\n  /**\n   * Get singleton instance\n   */\n  static getInstance(config?: MemoryConfig): MemoryStore {\n    if (!MemoryStore.instance) {\n      MemoryStore.instance = new MemoryStore(config);\n    } else if (config && !MemoryStore.instance.initialized) {\n      // Update config if not yet initialized\n      MemoryStore.instance.config = MemoryStore.instance.normalizeConfig(config);\n    }\n    return MemoryStore.instance;\n  }\n\n  /**\n   * Reset singleton instance (for testing)\n   */\n  static resetInstance(): void {\n    MemoryStore.instance = undefined!;\n  }\n\n  /**\n   * Initialize memory store (load from file if configured)\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      return;\n    }\n\n    // Auto-load if file storage is configured\n    if (this.config.storage === 'file' && this.config.auto_load && this.config.file) {\n      try {\n        await this.load();\n        logger.debug(`Memory store loaded from ${this.config.file}`);\n      } catch (error) {\n        // If file doesn't exist, that's ok - we'll create it on first save\n        if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {\n          logger.warn(\n            `Failed to load memory store from ${this.config.file}: ${\n              error instanceof Error ? error.message : 'Unknown error'\n            }`\n          );\n        }\n      }\n    }\n\n    this.initialized = true;\n  }\n\n  /**\n   * Normalize and apply defaults to config\n   */\n  private normalizeConfig(config?: MemoryConfig): MemoryConfig {\n    const storage = config?.storage || 'memory';\n    return {\n      storage,\n      format: config?.format || 'json',\n      file: config?.file,\n      namespace: config?.namespace || 'default',\n      auto_load: config?.auto_load !== false,\n      auto_save: config?.auto_save !== false,\n    };\n  }\n\n  /**\n   * Get the default namespace\n   */\n  getDefaultNamespace(): string {\n    return this.config.namespace || 'default';\n  }\n\n  /**\n   * Get a value from memory\n   */\n  get(key: string, namespace?: string): unknown {\n    const ns = namespace || this.getDefaultNamespace();\n    const nsData = this.data.get(ns);\n    return nsData?.get(key);\n  }\n\n  /**\n   * Check if a key exists in memory\n   */\n  has(key: string, namespace?: string): boolean {\n    const ns = namespace || this.getDefaultNamespace();\n    const nsData = this.data.get(ns);\n    return nsData?.has(key) || false;\n  }\n\n  /**\n   * Set a value in memory (override existing)\n   */\n  async set(key: string, value: unknown, namespace?: string): Promise<void> {\n    const ns = namespace || this.getDefaultNamespace();\n\n    // Ensure namespace exists\n    if (!this.data.has(ns)) {\n      this.data.set(ns, new Map());\n    }\n\n    const nsData = this.data.get(ns)!;\n    nsData.set(key, value);\n\n    try {\n      if (process.env.VISOR_DEBUG === 'true' || process.env.JEST_WORKER_ID !== undefined) {\n        if (ns === 'fact-validation' && (key === 'total_validations' || key === 'all_valid')) {\n          console.log('[MemoryStore] SET ' + ns + '.' + key + ' = ' + JSON.stringify(value));\n        }\n      }\n    } catch {}\n\n    try {\n      if (process.env.VISOR_DEBUG === 'true' || process.env.JEST_WORKER_ID !== undefined) {\n        if (ns === 'fact-validation' && (key === 'total_validations' || key === 'all_valid')) {\n          console.log();\n        }\n      }\n    } catch {}\n\n    // Auto-save if configured\n    if (this.config.storage === 'file' && this.config.auto_save) {\n      await this.save();\n    }\n  }\n\n  /**\n   * Append a value to an array in memory\n   * If key doesn't exist, creates a new array\n   * If key exists but is not an array, converts it to an array\n   */\n  async append(key: string, value: unknown, namespace?: string): Promise<void> {\n    const ns = namespace || this.getDefaultNamespace();\n    const existing = this.get(key, ns);\n\n    let newValue: unknown[];\n    if (existing === undefined) {\n      // Create new array\n      newValue = [value];\n    } else if (Array.isArray(existing)) {\n      // Append to existing array\n      newValue = [...existing, value];\n    } else {\n      // Convert single value to array with both values\n      newValue = [existing, value];\n    }\n\n    await this.set(key, newValue, ns);\n  }\n\n  /**\n   * Increment a numeric value in memory\n   * If key doesn't exist, initializes to 0 before incrementing\n   * If key exists but is not a number, throws an error\n   */\n  async increment(key: string, amount = 1, namespace?: string): Promise<number> {\n    const ns = namespace || this.getDefaultNamespace();\n    const existing = this.get(key, ns);\n\n    let newValue: number;\n    if (existing === undefined || existing === null) {\n      // Initialize to 0 and then increment\n      newValue = amount;\n    } else if (typeof existing === 'number') {\n      // Increment existing number\n      newValue = existing + amount;\n    } else {\n      throw new Error(\n        `Cannot increment non-numeric value at key '${key}' (type: ${typeof existing})`\n      );\n    }\n\n    await this.set(key, newValue, ns);\n    return newValue;\n  }\n\n  /**\n   * Delete a key from memory\n   */\n  async delete(key: string, namespace?: string): Promise<boolean> {\n    const ns = namespace || this.getDefaultNamespace();\n    const nsData = this.data.get(ns);\n\n    if (!nsData) {\n      return false;\n    }\n\n    const deleted = nsData.delete(key);\n\n    // Auto-save if configured\n    if (deleted && this.config.storage === 'file' && this.config.auto_save) {\n      await this.save();\n    }\n\n    return deleted;\n  }\n\n  /**\n   * Clear all keys in a namespace (or all namespaces if none specified)\n   */\n  async clear(namespace?: string): Promise<void> {\n    if (namespace) {\n      // Clear specific namespace\n      this.data.delete(namespace);\n    } else {\n      // Clear all namespaces\n      this.data.clear();\n    }\n\n    // Auto-save if configured\n    if (this.config.storage === 'file' && this.config.auto_save) {\n      await this.save();\n    }\n  }\n\n  /**\n   * List all keys in a namespace\n   */\n  list(namespace?: string): string[] {\n    const ns = namespace || this.getDefaultNamespace();\n    const nsData = this.data.get(ns);\n    return nsData ? Array.from(nsData.keys()) : [];\n  }\n\n  /**\n   * List all namespaces\n   */\n  listNamespaces(): string[] {\n    return Array.from(this.data.keys());\n  }\n\n  /**\n   * Get all data in a namespace\n   */\n  getAll(namespace?: string): Record<string, unknown> {\n    const ns = namespace || this.getDefaultNamespace();\n    const nsData = this.data.get(ns);\n    if (!nsData) {\n      return {};\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const [key, value] of nsData.entries()) {\n      result[key] = value;\n    }\n    return result;\n  }\n\n  /**\n   * Load data from file\n   */\n  async load(): Promise<void> {\n    if (!this.config.file) {\n      throw new Error('No file path configured for memory store');\n    }\n\n    const filePath = path.resolve(process.cwd(), this.config.file);\n    const content = await fs.readFile(filePath, 'utf-8');\n\n    if (this.config.format === 'json') {\n      await this.loadFromJson(content);\n    } else if (this.config.format === 'csv') {\n      await this.loadFromCsv(content);\n    } else {\n      throw new Error(`Unsupported format: ${this.config.format}`);\n    }\n  }\n\n  /**\n   * Save data to file\n   */\n  async save(): Promise<void> {\n    if (!this.config.file) {\n      throw new Error('No file path configured for memory store');\n    }\n\n    const filePath = path.resolve(process.cwd(), this.config.file);\n\n    // Ensure directory exists\n    const dir = path.dirname(filePath);\n    await fs.mkdir(dir, { recursive: true });\n\n    let content: string;\n    if (this.config.format === 'json') {\n      content = this.saveToJson();\n    } else if (this.config.format === 'csv') {\n      content = this.saveToCsv();\n    } else {\n      throw new Error(`Unsupported format: ${this.config.format}`);\n    }\n\n    await fs.writeFile(filePath, content, 'utf-8');\n  }\n\n  /**\n   * Load data from JSON format\n   */\n  private async loadFromJson(content: string): Promise<void> {\n    const data = JSON.parse(content);\n\n    // Clear existing data\n    this.data.clear();\n\n    // Load namespaces\n    for (const [namespace, nsData] of Object.entries(data)) {\n      if (typeof nsData === 'object' && nsData !== null && !Array.isArray(nsData)) {\n        const nsMap = new Map<string, unknown>();\n        for (const [key, value] of Object.entries(nsData)) {\n          nsMap.set(key, value);\n        }\n        this.data.set(namespace, nsMap);\n      }\n    }\n  }\n\n  /**\n   * Save data to JSON format\n   */\n  private saveToJson(): string {\n    const result: Record<string, Record<string, unknown>> = {};\n\n    for (const [namespace, nsData] of this.data.entries()) {\n      const nsObj: Record<string, unknown> = {};\n      for (const [key, value] of nsData.entries()) {\n        nsObj[key] = value;\n      }\n      result[namespace] = nsObj;\n    }\n\n    return JSON.stringify(result, null, 2);\n  }\n\n  /**\n   * Load data from CSV format\n   * CSV format: namespace,key,value,type\n   */\n  private async loadFromCsv(content: string): Promise<void> {\n    const lines = content.split('\\n').filter(line => line.trim());\n\n    // Skip header if present\n    let startIndex = 0;\n    if (lines[0]?.startsWith('namespace,')) {\n      startIndex = 1;\n    }\n\n    // Clear existing data\n    this.data.clear();\n\n    // Track arrays (keys that have multiple values)\n    const arrays = new Map<string, Map<string, unknown[]>>(); // namespace -> key -> values[]\n\n    for (let i = startIndex; i < lines.length; i++) {\n      const line = lines[i];\n      const parts = this.parseCsvLine(line);\n\n      if (parts.length < 3) {\n        logger.warn(`Invalid CSV line ${i + 1}: ${line}`);\n        continue;\n      }\n\n      const [namespace, key, valueStr, typeStr] = parts;\n      const value = this.parseCsvValue(valueStr, typeStr);\n\n      // Ensure namespace exists in data\n      if (!this.data.has(namespace)) {\n        this.data.set(namespace, new Map());\n        arrays.set(namespace, new Map());\n      }\n\n      const nsData = this.data.get(namespace)!;\n      const nsArrays = arrays.get(namespace)!;\n\n      // Check if this is a duplicate key (array)\n      if (nsData.has(key)) {\n        // Convert to array if not already\n        if (!nsArrays.has(key)) {\n          const existingValue = nsData.get(key);\n          nsArrays.set(key, [existingValue]);\n        }\n        nsArrays.get(key)!.push(value);\n        nsData.set(key, nsArrays.get(key)!);\n      } else {\n        // First occurrence\n        nsData.set(key, value);\n      }\n    }\n  }\n\n  /**\n   * Save data to CSV format\n   */\n  private saveToCsv(): string {\n    const lines: string[] = ['namespace,key,value,type'];\n\n    for (const [namespace, nsData] of this.data.entries()) {\n      for (const [key, value] of nsData.entries()) {\n        if (Array.isArray(value)) {\n          // Multiple rows for arrays\n          for (const item of value) {\n            lines.push(this.formatCsvLine(namespace, key, item));\n          }\n        } else {\n          // Single row\n          lines.push(this.formatCsvLine(namespace, key, value));\n        }\n      }\n    }\n\n    return lines.join('\\n') + '\\n';\n  }\n\n  /**\n   * Parse a CSV line, handling quoted values with commas\n   */\n  private parseCsvLine(line: string): string[] {\n    const parts: string[] = [];\n    let current = '';\n    let inQuotes = false;\n\n    for (let i = 0; i < line.length; i++) {\n      const char = line[i];\n\n      if (char === '\"') {\n        if (inQuotes && line[i + 1] === '\"') {\n          // Escaped quote\n          current += '\"';\n          i++;\n        } else {\n          // Toggle quotes\n          inQuotes = !inQuotes;\n        }\n      } else if (char === ',' && !inQuotes) {\n        // End of field\n        parts.push(current);\n        current = '';\n      } else {\n        current += char;\n      }\n    }\n\n    // Add last field\n    parts.push(current);\n\n    return parts;\n  }\n\n  /**\n   * Format a CSV line with proper escaping\n   */\n  private formatCsvLine(namespace: string, key: string, value: unknown): string {\n    const type = this.getValueType(value);\n    const valueStr = this.formatCsvValue(value);\n\n    return `${this.escapeCsv(namespace)},${this.escapeCsv(key)},${valueStr},${type}`;\n  }\n\n  /**\n   * Escape a CSV value\n   */\n  private escapeCsv(value: string): string {\n    if (value.includes(',') || value.includes('\"') || value.includes('\\n')) {\n      return `\"${value.replace(/\"/g, '\"\"')}\"`;\n    }\n    return value;\n  }\n\n  /**\n   * Format a value for CSV storage\n   */\n  private formatCsvValue(value: unknown): string {\n    if (value === null) {\n      return '\"\"';\n    }\n    if (value === undefined) {\n      return '\"\"';\n    }\n    if (typeof value === 'string') {\n      return this.escapeCsv(value);\n    }\n    if (typeof value === 'number' || typeof value === 'boolean') {\n      return this.escapeCsv(String(value));\n    }\n    // Objects and arrays are serialized as JSON\n    return this.escapeCsv(JSON.stringify(value));\n  }\n\n  /**\n   * Parse a CSV value based on its type\n   */\n  private parseCsvValue(valueStr: string, typeStr?: string): unknown {\n    if (!typeStr || typeStr === 'string') {\n      return valueStr;\n    }\n    if (typeStr === 'number') {\n      return Number(valueStr);\n    }\n    if (typeStr === 'boolean') {\n      return valueStr === 'true';\n    }\n    if (typeStr === 'object' || typeStr === 'array') {\n      try {\n        return JSON.parse(valueStr);\n      } catch {\n        return valueStr;\n      }\n    }\n    return valueStr;\n  }\n\n  /**\n   * Get the type of a value for CSV storage\n   */\n  private getValueType(value: unknown): string {\n    if (value === null || value === undefined) {\n      return 'string';\n    }\n    if (typeof value === 'number') {\n      return 'number';\n    }\n    if (typeof value === 'boolean') {\n      return 'boolean';\n    }\n    if (Array.isArray(value)) {\n      return 'array';\n    }\n    if (typeof value === 'object') {\n      return 'object';\n    }\n    return 'string';\n  }\n\n  /**\n   * Get the current configuration\n   */\n  getConfig(): MemoryConfig {\n    return { ...this.config };\n  }\n}\n"],"mappings":"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","names":[]}