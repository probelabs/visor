{"version":3,"sources":["../../src/utils/command-executor.ts"],"sourcesContent":["import { exec } from 'child_process';\nimport { promisify } from 'util';\nimport { logger } from '../logger';\n\nexport interface CommandExecutionOptions {\n  stdin?: string;\n  cwd?: string;\n  env?: Record<string, string>;\n  timeout?: number;\n}\n\nexport interface CommandExecutionResult {\n  stdout: string;\n  stderr: string;\n  exitCode: number;\n}\n\n/**\n * Shared utility for executing shell commands\n * Used by both CommandCheckProvider and CustomToolExecutor\n */\nexport class CommandExecutor {\n  private static instance: CommandExecutor;\n\n  private constructor() {}\n\n  static getInstance(): CommandExecutor {\n    if (!CommandExecutor.instance) {\n      CommandExecutor.instance = new CommandExecutor();\n    }\n    return CommandExecutor.instance;\n  }\n\n  /**\n   * Execute a shell command with optional stdin, environment, and timeout\n   */\n  async execute(\n    command: string,\n    options: CommandExecutionOptions = {}\n  ): Promise<CommandExecutionResult> {\n    const execAsync = promisify(exec);\n    const timeout = options.timeout || 30000;\n\n    // If stdin is provided, we need to handle it differently\n    if (options.stdin) {\n      return this.executeWithStdin(command, options);\n    }\n\n    // For commands without stdin, use the simpler promisified version\n    try {\n      const result = await execAsync(command, {\n        cwd: options.cwd,\n        env: options.env as NodeJS.ProcessEnv,\n        timeout,\n      });\n\n      return {\n        stdout: result.stdout || '',\n        stderr: result.stderr || '',\n        exitCode: 0,\n      };\n    } catch (error) {\n      return this.handleExecutionError(error, timeout);\n    }\n  }\n\n  /**\n   * Execute command with stdin input\n   */\n  private executeWithStdin(\n    command: string,\n    options: CommandExecutionOptions\n  ): Promise<CommandExecutionResult> {\n    return new Promise((resolve, reject) => {\n      const childProcess = exec(\n        command,\n        {\n          cwd: options.cwd,\n          env: options.env as NodeJS.ProcessEnv,\n          timeout: options.timeout || 30000,\n        },\n        (error, stdout, stderr) => {\n          // Check if the process was killed due to timeout\n          if (\n            error &&\n            error.killed &&\n            ((error as NodeJS.ErrnoException).code === 'ETIMEDOUT' || error.signal === 'SIGTERM')\n          ) {\n            reject(new Error(`Command timed out after ${options.timeout || 30000}ms`));\n          } else {\n            resolve({\n              stdout: stdout || '',\n              stderr: stderr || '',\n              exitCode: error ? error.code || 1 : 0,\n            });\n          }\n        }\n      );\n\n      // Write stdin and close\n      if (options.stdin && childProcess.stdin) {\n        childProcess.stdin.write(options.stdin);\n        childProcess.stdin.end();\n      }\n    });\n  }\n\n  /**\n   * Handle execution errors consistently\n   */\n  private handleExecutionError(error: unknown, timeout: number): CommandExecutionResult {\n    const execError = error as NodeJS.ErrnoException & {\n      stdout?: string;\n      stderr?: string;\n      killed?: boolean;\n      code?: string | number;\n      signal?: string;\n    };\n\n    // Check if the process was killed due to timeout\n    // Node.js sets killed: true and signal: 'SIGTERM' when timeout expires\n    if (execError.killed && (execError.code === 'ETIMEDOUT' || execError.signal === 'SIGTERM')) {\n      throw new Error(`Command timed out after ${timeout}ms`);\n    }\n\n    // Extract exit code - it might be a string or number\n    let exitCode = 1;\n    if (execError.code) {\n      exitCode = typeof execError.code === 'string' ? parseInt(execError.code, 10) : execError.code;\n    }\n\n    return {\n      stdout: execError.stdout || '',\n      stderr: execError.stderr || '',\n      exitCode,\n    };\n  }\n\n  /**\n   * Build safe environment variables by merging process.env with custom env\n   * Ensures all values are strings (no undefined)\n   */\n  buildEnvironment(\n    baseEnv: NodeJS.ProcessEnv = process.env,\n    ...customEnvs: Array<Record<string, string> | undefined>\n  ): Record<string, string> {\n    const result: Record<string, string> = {};\n\n    // Start with base environment, filtering out undefined values\n    for (const [key, value] of Object.entries(baseEnv)) {\n      if (value !== undefined) {\n        result[key] = value;\n      }\n    }\n\n    // Merge custom environments\n    for (const customEnv of customEnvs) {\n      if (customEnv) {\n        Object.assign(result, customEnv);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Log command execution for debugging\n   */\n  logExecution(command: string, options: CommandExecutionOptions): void {\n    const debugInfo = [\n      `Executing command: ${command}`,\n      options.cwd ? `cwd: ${options.cwd}` : null,\n      options.stdin ? 'with stdin' : null,\n      options.timeout ? `timeout: ${options.timeout}ms` : null,\n      options.env ? `env vars: ${Object.keys(options.env).length}` : null,\n    ]\n      .filter(Boolean)\n      .join(', ');\n\n    logger.debug(debugInfo);\n  }\n}\n\n// Export singleton instance for convenience\nexport const commandExecutor = CommandExecutor.getInstance();\n"],"mappings":"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","names":[]}