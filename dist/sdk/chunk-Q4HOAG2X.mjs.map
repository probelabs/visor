{"version":3,"sources":["../../src/snapshot-store.ts","../../src/state-machine/states/routing.ts"],"sourcesContent":["/*\n * Internal snapshot store for incremental adoption of snapshot+scope execution.\n * Phase 0: journal only â€” no behavior change, used for future visibility work.\n */\n\nimport type { ReviewSummary } from './reviewer';\nimport type { EventTrigger } from './types/config';\n\nexport type ScopePath = Array<{ check: string; index: number }>;\n\nexport interface JournalEntry {\n  commitId: number;\n  sessionId: string;\n  scope: ScopePath;\n  checkId: string;\n  event: EventTrigger | undefined;\n  result: ReviewSummary & { output?: unknown; content?: string };\n}\n\nexport class ExecutionJournal {\n  private commit = 0;\n  private entries: JournalEntry[] = [];\n\n  beginSnapshot(): number {\n    return this.commit;\n  }\n\n  commitEntry(entry: {\n    sessionId: string;\n    scope: ScopePath;\n    checkId: string;\n    result: ReviewSummary & { output?: unknown; content?: string };\n    event?: EventTrigger;\n  }): JournalEntry {\n    const committed: JournalEntry = {\n      sessionId: entry.sessionId,\n      scope: entry.scope,\n      checkId: entry.checkId,\n      result: entry.result,\n      event: entry.event,\n      commitId: ++this.commit,\n    };\n    this.entries.push(committed);\n    return committed;\n  }\n\n  readVisible(sessionId: string, commitMax: number, event?: EventTrigger): JournalEntry[] {\n    return this.entries.filter(\n      e =>\n        e.sessionId === sessionId && e.commitId <= commitMax && (event ? e.event === event : true)\n    );\n  }\n\n  // Lightweight helpers for debugging/metrics\n  size(): number {\n    return this.entries.length;\n  }\n}\n\nexport class ContextView {\n  constructor(\n    private journal: ExecutionJournal,\n    private sessionId: string,\n    private snapshotId: number,\n    private scope: ScopePath,\n    private event?: EventTrigger\n  ) {}\n\n  /** Return the nearest result for a check in this scope (exact item â†’ ancestor â†’ latest). */\n  get(checkId: string): (ReviewSummary & { output?: unknown; content?: string }) | undefined {\n    const visible = this.journal\n      .readVisible(this.sessionId, this.snapshotId, this.event)\n      .filter(e => e.checkId === checkId);\n    if (visible.length === 0) return undefined;\n\n    // exact scope match: prefer the most recent commit for this scope\n    const exactMatches = visible.filter(e => this.sameScope(e.scope, this.scope));\n    if (exactMatches.length > 0) {\n      return exactMatches[exactMatches.length - 1].result;\n    }\n\n    // nearest ancestor (shortest distance)\n    let best: { entry: JournalEntry; dist: number } | undefined;\n    for (const e of visible) {\n      const dist = this.ancestorDistance(e.scope, this.scope);\n      if (dist >= 0 && (best === undefined || dist < best.dist)) {\n        best = { entry: e, dist };\n      }\n    }\n    if (best) return best.entry.result;\n\n    // fallback to latest committed result\n    return visible[visible.length - 1]?.result;\n  }\n\n  /** Return an aggregate (raw) result â€“ the shallowest scope for this check. */\n  getRaw(checkId: string): (ReviewSummary & { output?: unknown; content?: string }) | undefined {\n    const visible = this.journal\n      .readVisible(this.sessionId, this.snapshotId, this.event)\n      .filter(e => e.checkId === checkId);\n    if (visible.length === 0) return undefined;\n    let shallow = visible[0];\n    for (const e of visible) {\n      if (e.scope.length < shallow.scope.length) shallow = e;\n    }\n    return shallow.result;\n  }\n\n  /** All results for a check up to this snapshot. */\n  getHistory(checkId: string): Array<ReviewSummary & { output?: unknown; content?: string }> {\n    return this.journal\n      .readVisible(this.sessionId, this.snapshotId, this.event)\n      .filter(e => e.checkId === checkId)\n      .map(e => e.result);\n  }\n\n  private sameScope(a: ScopePath, b: ScopePath): boolean {\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (a[i].check !== b[i].check || a[i].index !== b[i].index) return false;\n    }\n    return true;\n  }\n\n  // distance from ancestor to current; -1 if not ancestor\n  private ancestorDistance(ancestor: ScopePath, current: ScopePath): number {\n    if (ancestor.length > current.length) return -1;\n    // Treat root scope ([]) as non-ancestor for unrelated branches\n    if (ancestor.length === 0 && current.length > 0) return -1;\n    for (let i = 0; i < ancestor.length; i++) {\n      if (ancestor[i].check !== current[i].check || ancestor[i].index !== current[i].index)\n        return -1;\n    }\n    return current.length - ancestor.length;\n  }\n}\n","/**\n * Routing State Handler\n *\n * Responsibilities:\n * - Evaluate fail_if conditions after check execution\n * - Process on_success, on_fail, on_finish triggers\n * - Enqueue ForwardRunRequested events for goto\n * - Enqueue WaveRetry events for routing loops\n * - Transition back to WavePlanning or Completed\n *\n * M2: Core routing logic implementation\n */\n\nimport type { EngineContext, RunState, EngineState, EngineEvent } from '../../types/engine';\nimport type { ReviewSummary, ReviewIssue } from '../../reviewer';\nimport type { CheckConfig, OnFailConfig, TransitionRule } from '../../types/config';\nimport { logger } from '../../logger';\nimport { addEvent } from '../../telemetry/trace-helpers';\nimport { FailureConditionEvaluator } from '../../failure-condition-evaluator';\nimport { createSecureSandbox, compileAndRun } from '../../utils/sandbox';\nimport { MemoryStore } from '../../memory-store';\n\n/**\n * Check if any configured check depends (directly or via OR dependency) on the\n * given `checkId`. Used to decide whether a forEach parent has downstream\n * dependents, in which case its on_finish should defer to the LevelDispatch\n * post-children hook.\n */\n// hasDependents helper removed (unused)\n\n/**\n * Check if any dependent of `checkId` would execute with map fanout.\n * Used to decide whether a forEach parent's on_finish should be deferred to\n * the LevelDispatch post-children hook (only necessary when map-fanout children\n * will run per item).\n */\nfunction hasMapFanoutDependents(context: EngineContext, checkId: string): boolean {\n  const checks = context.config.checks || {};\n  const reduceProviders = new Set(['log', 'memory', 'script', 'workflow', 'noop']);\n\n  for (const [cid, cfg] of Object.entries(checks)) {\n    if (cid === checkId) continue;\n    const rawDeps = (cfg as any).depends_on || [];\n    const depList = Array.isArray(rawDeps) ? rawDeps : [rawDeps];\n    // Does this check depend on our target?\n    let depends = false;\n    for (const dep of depList) {\n      if (typeof dep !== 'string') continue;\n      if (dep.includes('|')) {\n        const opts = dep\n          .split('|')\n          .map(s => s.trim())\n          .filter(Boolean);\n        if (opts.includes(checkId)) {\n          depends = true;\n          break;\n        }\n      } else if (dep === checkId) {\n        depends = true;\n        break;\n      }\n    }\n    if (!depends) continue;\n\n    // Determine this dependent's fanout mode\n    const explicit = (cfg as any).fanout as 'map' | 'reduce' | undefined;\n    if (explicit === 'map') return true;\n    if (explicit === 'reduce') continue;\n\n    // Infer default based on provider type\n    const providerType = context.checks[cid]?.providerType || (checks as any)[cid]?.type || '';\n    const inferred: 'map' | 'reduce' = reduceProviders.has(providerType) ? 'reduce' : 'map';\n    if (inferred === 'map') return true;\n  }\n  return false;\n}\n\n/** Classify failure type to inform retry policy mapping */\nfunction classifyFailure(result: ReviewSummary): 'none' | 'logical' | 'execution' {\n  const issues = result?.issues || [];\n  if (!issues || issues.length === 0) return 'none';\n  // Heuristics:\n  // - logical: fail_if, contract/guarantee_failed, explicit ruleIds ending with _fail_if\n  // - execution: provider/command errors, forEach/execution_error, sandbox_runner_error\n  let hasLogical = false;\n  let hasExecution = false;\n  for (const iss of issues) {\n    const id = String((iss as any).ruleId || '');\n    const msg = String((iss as any).message || '');\n    if (\n      id.endsWith('_fail_if') ||\n      id.includes('contract/guarantee_failed') ||\n      id.includes('contract/schema_validation_failed')\n    )\n      hasLogical = true;\n    if (id.includes('/execution_error') || msg.includes('Command execution failed'))\n      hasExecution = true;\n    if (id.includes('forEach/execution_error') || msg.includes('sandbox_runner_error'))\n      hasExecution = true;\n  }\n  if (hasLogical && !hasExecution) return 'logical';\n  if (hasExecution && !hasLogical) return 'execution';\n  // Mixed or unknown: treat as execution to avoid suppressing retries unexpectedly\n  return hasExecution ? 'execution' : 'logical';\n}\n\nfunction getCriticality(context: EngineContext, checkId: string): CheckConfig['criticality'] {\n  const cfg = context.config.checks?.[checkId];\n  return (cfg && (cfg as any).criticality) || 'policy';\n}\n\n/**\n * Context for a check that just completed and needs routing evaluation\n */\ninterface RoutingContext {\n  checkId: string;\n  scope: Array<{ check: string; index: number }>;\n  result: ReviewSummary;\n  checkConfig: CheckConfig;\n  success: boolean; // true if no fatal issues\n}\n\n/**\n * Create memory helpers for sandbox context\n */\nfunction createMemoryHelpers() {\n  const memoryStore = MemoryStore.getInstance();\n  return {\n    get: (key: string, ns?: string) => memoryStore.get(key, ns),\n    has: (key: string, ns?: string) => memoryStore.has(key, ns),\n    getAll: (ns?: string) => memoryStore.getAll(ns),\n    set: (key: string, value: unknown, ns?: string) => {\n      const nsName = ns || memoryStore.getDefaultNamespace();\n      const data: Map<string, Map<string, unknown>> = (memoryStore as any)['data'];\n      if (!data.has(nsName)) data.set(nsName, new Map());\n      data.get(nsName)!.set(key, value);\n    },\n    clear: (ns?: string) => {\n      const data: Map<string, Map<string, unknown>> = (memoryStore as any)['data'];\n      if (ns) data.delete(ns);\n      else data.clear();\n    },\n    increment: (key: string, amount = 1, ns?: string) => {\n      const nsName = ns || memoryStore.getDefaultNamespace();\n      const data: Map<string, Map<string, unknown>> = (memoryStore as any)['data'];\n      if (!data.has(nsName)) data.set(nsName, new Map());\n      const nsMap = data.get(nsName)!;\n      const current = nsMap.get(key);\n      const numCurrent = typeof current === 'number' ? current : 0;\n      const newValue = numCurrent + amount;\n      nsMap.set(key, newValue);\n      return newValue;\n    },\n  };\n}\n\ntype RoutingTrigger = 'on_success' | 'on_fail' | 'on_finish';\ntype RoutingAction = 'run' | 'goto' | 'retry';\ntype RoutingSource = 'run' | 'run_js' | 'goto' | 'goto_js' | 'transitions' | 'retry';\n\nfunction formatScopeLabel(scope: Array<{ check: string; index: number }> | undefined): string {\n  if (!scope || scope.length === 0) return '';\n  return scope.map(item => `${item.check}:${item.index}`).join('|');\n}\n\nfunction recordRoutingEvent(args: {\n  checkId: string;\n  trigger: RoutingTrigger;\n  action: RoutingAction;\n  target?: string;\n  source?: RoutingSource;\n  scope?: Array<{ check: string; index: number }>;\n  gotoEvent?: string;\n}): void {\n  const attrs: Record<string, unknown> = {\n    check_id: args.checkId,\n    trigger: args.trigger,\n    action: args.action,\n  };\n  if (args.target) attrs.target = args.target;\n  if (args.source) attrs.source = args.source;\n  const scopeLabel = formatScopeLabel(args.scope);\n  if (scopeLabel) attrs.scope = scopeLabel;\n  if (args.gotoEvent) attrs.goto_event = args.gotoEvent;\n  addEvent('visor.routing', attrs);\n}\n\n/**\n * Handle routing state - evaluate conditions and decide next actions\n */\nexport async function handleRouting(\n  context: EngineContext,\n  state: RunState,\n  transition: (newState: EngineState) => void,\n  emitEvent: (event: EngineEvent) => void,\n  routingContext: RoutingContext\n): Promise<void> {\n  const { checkId, scope, result, checkConfig, success } = routingContext;\n\n  // Always log routing entry for debugging E2E expectations\n  logger.info(`[Routing] Evaluating routing for check: ${checkId}, success: ${success}`);\n\n  // Step 1: Evaluate fail_if conditions\n  const failIfTriggered = await evaluateFailIf(checkId, result, checkConfig, context, state);\n\n  if (failIfTriggered) {\n    if (context.debug) {\n      logger.info(`[Routing] fail_if triggered for ${checkId}`);\n    }\n\n    // Treat as failure for routing purposes\n    await processOnFail(checkId, scope, result, checkConfig, context, state, emitEvent);\n  } else if (success) {\n    // Step 2: Process on_success routing\n    await processOnSuccess(checkId, scope, result, checkConfig, context, state, emitEvent);\n  } else {\n    // Step 3: Process on_fail routing\n    await processOnFail(checkId, scope, result, checkConfig, context, state, emitEvent);\n  }\n\n  // Step 4: on_finish\n  // Process on_finish here for:\n  //  - non-forEach checks\n  //  - forEach parents that do NOT have map-fanout dependents\n  //    (reduce-only dependents don't need the post-children barrier)\n  const shouldProcessOnFinishHere =\n    !!checkConfig.on_finish &&\n    (checkConfig.forEach !== true || !hasMapFanoutDependents(context, checkId));\n  if (checkConfig.on_finish) {\n    logger.info(\n      `[Routing] on_finish decision for ${checkId}: forEach=${!!checkConfig.forEach}, processHere=${shouldProcessOnFinishHere}`\n    );\n  }\n  if (shouldProcessOnFinishHere) {\n    await processOnFinish(checkId, scope, result, checkConfig, context, state, emitEvent);\n  }\n\n  // Transition back to WavePlanning to process queued events\n  transition('WavePlanning');\n}\n\n/**\n * Process on_finish routing\n */\nasync function processOnFinish(\n  checkId: string,\n  scope: Array<{ check: string; index: number }>,\n  result: ReviewSummary,\n  checkConfig: CheckConfig,\n  context: EngineContext,\n  state: RunState,\n  emitEvent: (event: EngineEvent) => void\n): Promise<void> {\n  const onFinish = checkConfig.on_finish;\n\n  if (!onFinish) {\n    return; // No on_finish configuration\n  }\n\n  // Log at info level so it's visible in test output\n  logger.info(`Processing on_finish for ${checkId}`);\n  let queuedForward = false;\n  // Process on_finish.run\n  if (onFinish.run && onFinish.run.length > 0) {\n    // Check if current check is a forEach parent with items\n    const currentCheckIsForEach = checkConfig.forEach === true;\n    const forEachItems = currentCheckIsForEach ? (result as any).forEachItems : undefined;\n    const hasForEachItems = Array.isArray(forEachItems) && forEachItems.length > 0;\n\n    for (const targetCheck of onFinish.run) {\n      // Check loop budget before scheduling\n      if (checkLoopBudget(context, state, 'on_finish', 'run')) {\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? DEFAULT_MAX_LOOPS}) during on_finish run`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return;\n      }\n\n      // Handle fanout: check if target has fanout configuration\n      const targetConfig = context.config.checks?.[targetCheck];\n      const fanoutMode = targetConfig?.fanout || 'reduce'; // default to reduce\n\n      if (context.debug) {\n        logger.info(\n          `[Routing] on_finish.run: scheduling ${targetCheck} with fanout=${fanoutMode}, hasForEachItems=${hasForEachItems}`\n        );\n      }\n\n      // If current check has forEach items and target is map fanout, emit one event per item\n      if (fanoutMode === 'map' && hasForEachItems) {\n        // Map fanout: emit one ForwardRunRequested per forEach item\n        for (let itemIndex = 0; itemIndex < forEachItems!.length; itemIndex++) {\n          // Increment loop count for each item\n          state.routingLoopCount++;\n\n          const itemScope: Array<{ check: string; index: number }> = [\n            { check: checkId, index: itemIndex },\n          ];\n\n          recordRoutingEvent({\n            checkId,\n            trigger: 'on_finish',\n            action: 'run',\n            target: targetCheck,\n            source: 'run',\n            scope: itemScope,\n          });\n          emitEvent({\n            type: 'ForwardRunRequested',\n            target: targetCheck,\n            scope: itemScope,\n            origin: 'run',\n          });\n          queuedForward = true;\n        }\n      } else {\n        // Reduce fanout (or no forEach context): emit with empty scope once\n        // Increment loop count\n        state.routingLoopCount++;\n\n        recordRoutingEvent({\n          checkId,\n          trigger: 'on_finish',\n          action: 'run',\n          target: targetCheck,\n          source: 'run',\n          scope: [],\n        });\n        emitEvent({\n          type: 'ForwardRunRequested',\n          target: targetCheck,\n          scope: [],\n          origin: 'run',\n        });\n        queuedForward = true;\n      }\n    }\n  }\n\n  // Process on_finish.run_js\n  if (onFinish.run_js) {\n    const dynamicTargets = await evaluateRunJs(\n      onFinish.run_js,\n      checkId,\n      checkConfig,\n      result,\n      context,\n      state\n    );\n\n    for (const targetCheck of dynamicTargets) {\n      // Check loop budget before scheduling\n      if (checkLoopBudget(context, state, 'on_finish', 'run')) {\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? DEFAULT_MAX_LOOPS}) during on_finish run`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return;\n      }\n\n      if (context.debug) {\n        logger.info(`[Routing] on_finish.run_js: scheduling ${targetCheck}`);\n      }\n\n      // Increment loop count\n      state.routingLoopCount++;\n\n      recordRoutingEvent({\n        checkId,\n        trigger: 'on_finish',\n        action: 'run',\n        target: targetCheck,\n        source: 'run_js',\n        scope,\n      });\n      emitEvent({\n        type: 'ForwardRunRequested',\n        target: targetCheck,\n        scope,\n        origin: 'run_js',\n      });\n      queuedForward = true;\n    }\n  }\n\n  // Declarative transitions (override goto/goto_js when present)\n  const finishTransTarget = await evaluateTransitions(\n    onFinish.transitions,\n    checkId,\n    checkConfig,\n    result,\n    context,\n    state\n  );\n  if (finishTransTarget !== undefined) {\n    if (finishTransTarget) {\n      if (checkLoopBudget(context, state, 'on_finish', 'goto')) {\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? DEFAULT_MAX_LOOPS}) during on_finish goto`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return;\n      }\n      state.routingLoopCount++;\n      recordRoutingEvent({\n        checkId,\n        trigger: 'on_finish',\n        action: 'goto',\n        target: finishTransTarget.to,\n        source: 'transitions',\n        scope,\n        gotoEvent: finishTransTarget.goto_event,\n      });\n      emitEvent({\n        type: 'ForwardRunRequested',\n        target: finishTransTarget.to,\n        scope,\n        origin: 'goto_js',\n        gotoEvent: finishTransTarget.goto_event,\n      });\n    }\n    return; // transitions override goto/goto_js\n  }\n\n  // Process on_finish.goto / goto_js\n  const gotoTarget = await evaluateGoto(\n    onFinish.goto_js,\n    onFinish.goto,\n    checkId,\n    checkConfig,\n    result,\n    context,\n    state\n  );\n\n  if (gotoTarget) {\n    // Check loop budget before scheduling goto\n    if (checkLoopBudget(context, state, 'on_finish', 'goto')) {\n      const errorIssue: ReviewIssue = {\n        file: 'system',\n        line: 0,\n        ruleId: `${checkId}/routing/loop_budget_exceeded`,\n        message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? DEFAULT_MAX_LOOPS}) during on_finish goto`,\n        severity: 'error',\n        category: 'logic',\n      };\n      result.issues = [...(result.issues || []), errorIssue];\n      return;\n    }\n\n    if (context.debug) {\n      logger.info(`[Routing] on_finish.goto: ${gotoTarget}`);\n    }\n\n    // Increment loop count\n    state.routingLoopCount++;\n\n    recordRoutingEvent({\n      checkId,\n      trigger: 'on_finish',\n      action: 'goto',\n      target: gotoTarget,\n      source: onFinish.goto_js ? 'goto_js' : 'goto',\n      scope,\n    });\n    // Enqueue forward run event\n    emitEvent({\n      type: 'ForwardRunRequested',\n      target: gotoTarget,\n      scope,\n      origin: 'goto_js',\n    });\n\n    // Mark that we've seen a forward run\n    state.flags.forwardRunRequested = true;\n  }\n\n  // If we scheduled any forward-run targets via on_finish, request a wave retry so\n  // dependent checks (with if conditions) can re-evaluate after the forward-run completes.\n  // Guard: only enqueue once per originating check per wave to avoid loops.\n  if (queuedForward) {\n    const guardKey = `waveRetry:on_finish:${checkId}:wave:${state.wave}`;\n    if (!(state as any).forwardRunGuards?.has(guardKey)) {\n      (state as any).forwardRunGuards?.add(guardKey);\n      emitEvent({ type: 'WaveRetry', reason: 'on_finish' });\n    }\n  }\n}\n\n/**\n * Evaluate fail_if conditions for a check\n */\n// Returns true only when a check-level fail_if is triggered.\n// Global fail_if records an issue for summary/reporting but MUST NOT gate routing.\nasync function evaluateFailIf(\n  checkId: string,\n  result: ReviewSummary,\n  checkConfig: CheckConfig,\n  context: EngineContext,\n  state: RunState\n): Promise<boolean> {\n  const config = context.config;\n\n  // Check for fail_if at global or check level\n  const globalFailIf = config.fail_if;\n  const checkFailIf = checkConfig.fail_if;\n\n  if (!globalFailIf && !checkFailIf) {\n    return false; // No fail_if conditions\n  }\n\n  const evaluator = new FailureConditionEvaluator();\n\n  // Build outputs record from state\n  const outputsRecord: Record<string, ReviewSummary> = {};\n  for (const [key] of state.stats.entries()) {\n    // Try to get the actual result from context.journal if available\n    try {\n      const snapshotId = context.journal.beginSnapshot();\n      const contextView = new (require('../../snapshot-store').ContextView)(\n        context.journal,\n        context.sessionId,\n        snapshotId,\n        [],\n        context.event\n      );\n      const journalResult = contextView.get(key);\n      if (journalResult) {\n        outputsRecord[key] = journalResult as ReviewSummary;\n      }\n    } catch {\n      // Fallback to empty result\n      outputsRecord[key] = { issues: [] };\n    }\n  }\n\n  const checkSchema = typeof checkConfig.schema === 'object' ? 'custom' : checkConfig.schema || '';\n  const checkGroup = checkConfig.group || '';\n\n  // Evaluate global fail_if (non-gating)\n  if (globalFailIf) {\n    try {\n      const failed = await evaluator.evaluateSimpleCondition(\n        checkId,\n        checkSchema,\n        checkGroup,\n        result,\n        globalFailIf,\n        outputsRecord\n      );\n\n      if (failed) {\n        logger.warn(`[Routing] Global fail_if triggered for ${checkId}: ${globalFailIf}`);\n\n        // Add fail_if issue to result\n        const failIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: 'global_fail_if',\n          message: `Global failure condition met: ${globalFailIf}`,\n          severity: 'error',\n          category: 'logic',\n        };\n\n        result.issues = [...(result.issues || []), failIssue];\n        // IMPORTANT: do not gate routing on global fail_if\n        // This condition contributes to overall run status but should not\n        // block dependents from executing when the producing check succeeded.\n        // Continue evaluating check-level fail_if below.\n      }\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : String(error);\n      logger.error(`[Routing] Error evaluating global fail_if: ${msg}`);\n    }\n  }\n\n  // Evaluate check-specific fail_if\n  if (checkFailIf) {\n    try {\n      const failed = await evaluator.evaluateSimpleCondition(\n        checkId,\n        checkSchema,\n        checkGroup,\n        result,\n        checkFailIf,\n        outputsRecord\n      );\n\n      if (failed) {\n        logger.warn(`[Routing] Check fail_if triggered for ${checkId}: ${checkFailIf}`);\n\n        // Add fail_if issue to result\n        const failIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}_fail_if`,\n          message: `Check failure condition met: ${checkFailIf}`,\n          severity: 'error',\n          category: 'logic',\n        };\n\n        result.issues = [...(result.issues || []), failIssue];\n        return true;\n      }\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : String(error);\n      logger.error(`[Routing] Error evaluating check fail_if: ${msg}`);\n    }\n  }\n\n  return false;\n}\n\n/**\n * Check if routing loop budget is exceeded\n */\nexport function checkLoopBudget(\n  context: EngineContext,\n  state: RunState,\n  origin: 'on_success' | 'on_fail' | 'on_finish',\n  action: 'run' | 'goto'\n): boolean {\n  const maxLoops = context.config.routing?.max_loops ?? DEFAULT_MAX_LOOPS;\n\n  if (state.routingLoopCount >= maxLoops) {\n    const msg = `Routing loop budget exceeded (max_loops=${maxLoops}) during ${origin} ${action}`;\n    logger.error(`[Routing] ${msg}`);\n    return true; // Budget exceeded\n  }\n\n  return false; // Budget OK\n}\n\n/**\n * Process on_success routing\n */\nasync function processOnSuccess(\n  checkId: string,\n  scope: Array<{ check: string; index: number }>,\n  result: ReviewSummary,\n  checkConfig: CheckConfig,\n  context: EngineContext,\n  state: RunState,\n  emitEvent: (event: EngineEvent) => void\n): Promise<void> {\n  const onSuccess = checkConfig.on_success;\n\n  if (!onSuccess) {\n    return; // No on_success configuration\n  }\n\n  if (context.debug) {\n    logger.info(`[Routing] Processing on_success for ${checkId}`);\n  }\n\n  // Process on_success.run\n  if (onSuccess.run && onSuccess.run.length > 0) {\n    // Detect forEach context based on the actual result (aggregated map execution)\n    const resForEachItems: any[] | undefined =\n      (result && (result as any).forEachItems) || undefined;\n    const hasForEachItems = Array.isArray(resForEachItems) && resForEachItems.length > 0;\n\n    for (const targetCheck of onSuccess.run) {\n      // Check loop budget before scheduling\n      if (checkLoopBudget(context, state, 'on_success', 'run')) {\n        // Add error issue to result\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? DEFAULT_MAX_LOOPS}) during on_success run`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return; // Stop processing\n      }\n\n      // Handle fanout: check if target has fanout configuration\n      const targetConfig = context.config.checks?.[targetCheck];\n      const fanoutMode = targetConfig?.fanout || 'reduce'; // default to reduce\n\n      if (context.debug) {\n        logger.info(\n          `[Routing] on_success.run: scheduling ${targetCheck} with fanout=${fanoutMode}, hasForEachItems=${hasForEachItems}`\n        );\n      }\n\n      // If current check has forEach items and target is map fanout, emit one event per item\n      if (fanoutMode === 'map' && hasForEachItems) {\n        // Map fanout: emit one ForwardRunRequested per forEach item\n        for (let itemIndex = 0; itemIndex < resForEachItems!.length; itemIndex++) {\n          // Increment loop count for each item\n          state.routingLoopCount++;\n\n          const itemScope: Array<{ check: string; index: number }> = [\n            { check: checkId, index: itemIndex },\n          ];\n\n          recordRoutingEvent({\n            checkId,\n            trigger: 'on_success',\n            action: 'run',\n            target: targetCheck,\n            source: 'run',\n            scope: itemScope,\n          });\n          emitEvent({\n            type: 'ForwardRunRequested',\n            target: targetCheck,\n            scope: itemScope,\n            origin: 'run',\n          });\n        }\n      } else {\n        // Reduce fanout (or no forEach context): emit with empty scope once\n        // Increment loop count\n        state.routingLoopCount++;\n\n        recordRoutingEvent({\n          checkId,\n          trigger: 'on_success',\n          action: 'run',\n          target: targetCheck,\n          source: 'run',\n          scope,\n        });\n        emitEvent({\n          type: 'ForwardRunRequested',\n          target: targetCheck,\n          scope,\n          origin: 'run',\n        });\n      }\n    }\n  }\n\n  // Process on_success.run_js\n  if (onSuccess.run_js) {\n    const dynamicTargets = await evaluateRunJs(\n      onSuccess.run_js,\n      checkId,\n      checkConfig,\n      result,\n      context,\n      state\n    );\n\n    for (const targetCheck of dynamicTargets) {\n      // Check loop budget before scheduling\n      if (checkLoopBudget(context, state, 'on_success', 'run')) {\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_success run`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return;\n      }\n\n      if (context.debug) {\n        logger.info(`[Routing] on_success.run_js: scheduling ${targetCheck}`);\n      }\n\n      // Increment loop count\n      state.routingLoopCount++;\n\n      recordRoutingEvent({\n        checkId,\n        trigger: 'on_success',\n        action: 'run',\n        target: targetCheck,\n        source: 'run_js',\n        scope,\n      });\n      emitEvent({\n        type: 'ForwardRunRequested',\n        target: targetCheck,\n        scope,\n        origin: 'run_js',\n      });\n    }\n  }\n\n  // Declarative transitions for on_success (override goto/goto_js when present)\n  const successTransTarget = await evaluateTransitions(\n    onSuccess.transitions,\n    checkId,\n    checkConfig,\n    result,\n    context,\n    state\n  );\n  if (successTransTarget !== undefined) {\n    if (successTransTarget) {\n      if (checkLoopBudget(context, state, 'on_success', 'goto')) {\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? DEFAULT_MAX_LOOPS}) during on_success goto`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return;\n      }\n      state.routingLoopCount++;\n      recordRoutingEvent({\n        checkId,\n        trigger: 'on_success',\n        action: 'goto',\n        target: successTransTarget.to,\n        source: 'transitions',\n        scope,\n        gotoEvent: successTransTarget.goto_event,\n      });\n      emitEvent({\n        type: 'ForwardRunRequested',\n        target: successTransTarget.to,\n        scope,\n        origin: 'goto_js',\n        gotoEvent: successTransTarget.goto_event,\n      });\n      state.flags.forwardRunRequested = true;\n    }\n    return;\n  }\n\n  // Process on_success.goto / goto_js\n  const gotoTarget = await evaluateGoto(\n    onSuccess.goto_js,\n    onSuccess.goto,\n    checkId,\n    checkConfig,\n    result,\n    context,\n    state\n  );\n\n  if (gotoTarget) {\n    // Check loop budget before scheduling goto\n    if (checkLoopBudget(context, state, 'on_success', 'goto')) {\n      const errorIssue: ReviewIssue = {\n        file: 'system',\n        line: 0,\n        ruleId: `${checkId}/routing/loop_budget_exceeded`,\n        message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_success goto`,\n        severity: 'error',\n        category: 'logic',\n      };\n      result.issues = [...(result.issues || []), errorIssue];\n      return;\n    }\n\n    if (context.debug) {\n      logger.info(`[Routing] on_success.goto: ${gotoTarget}`);\n    }\n\n    // Increment loop count\n    state.routingLoopCount++;\n\n    recordRoutingEvent({\n      checkId,\n      trigger: 'on_success',\n      action: 'goto',\n      target: gotoTarget,\n      source: onSuccess.goto_js ? 'goto_js' : 'goto',\n      scope,\n      gotoEvent: onSuccess.goto_event,\n    });\n    // Enqueue forward run event with optional event override\n    emitEvent({\n      type: 'ForwardRunRequested',\n      target: gotoTarget,\n      gotoEvent: onSuccess.goto_event,\n      scope,\n      origin: 'goto_js',\n    });\n\n    // Mark that we've seen a forward run\n    state.flags.forwardRunRequested = true;\n  }\n}\n\n/**\n * Process on_fail routing\n */\nasync function processOnFail(\n  checkId: string,\n  scope: Array<{ check: string; index: number }>,\n  result: ReviewSummary,\n  checkConfig: CheckConfig,\n  context: EngineContext,\n  state: RunState,\n  emitEvent: (event: EngineEvent) => void\n): Promise<void> {\n  // Merge defaults with check-specific on_fail\n  const defaults = context.config.routing?.defaults?.on_fail || {};\n  const onFail: OnFailConfig | undefined = checkConfig.on_fail\n    ? { ...defaults, ...checkConfig.on_fail }\n    : undefined;\n\n  if (!onFail) {\n    return; // No on_fail configuration\n  }\n\n  if (context.debug) {\n    logger.info(`[Routing] Processing on_fail for ${checkId}`);\n  }\n\n  // Process on_fail.run\n  if (onFail.run && onFail.run.length > 0) {\n    // Detect forEach context based on the actual aggregated result\n    const resForEachItems: any[] | undefined =\n      (result && (result as any).forEachItems) || undefined;\n    const hasForEachItems = Array.isArray(resForEachItems) && resForEachItems.length > 0;\n\n    for (const targetCheck of onFail.run) {\n      // Check loop budget before scheduling\n      if (checkLoopBudget(context, state, 'on_fail', 'run')) {\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_fail run`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return;\n      }\n\n      // Handle fanout: check if target has fanout configuration\n      const targetConfig = context.config.checks?.[targetCheck];\n      const fanoutMode = targetConfig?.fanout || 'reduce'; // default to reduce\n\n      if (context.debug) {\n        logger.info(\n          `[Routing] on_fail.run: scheduling ${targetCheck} with fanout=${fanoutMode}, hasForEachItems=${hasForEachItems}`\n        );\n      }\n\n      // If current check ran in forEach context, schedule remediation per item\n      if (hasForEachItems) {\n        for (let itemIndex = 0; itemIndex < resForEachItems!.length; itemIndex++) {\n          const itemOut = resForEachItems![itemIndex] as any;\n          // Only remediate failed iterations if __failed is present; otherwise run for all\n          if (\n            itemOut &&\n            typeof itemOut === 'object' &&\n            itemOut.__failed !== true &&\n            fanoutMode !== 'map'\n          ) {\n            // For reduce targets, skip successful iterations to avoid redundant runs\n            continue;\n          }\n\n          state.routingLoopCount++;\n          const itemScope: Array<{ check: string; index: number }> = [\n            { check: checkId, index: itemIndex },\n          ];\n          recordRoutingEvent({\n            checkId,\n            trigger: 'on_fail',\n            action: 'run',\n            target: targetCheck,\n            source: 'run',\n            scope: itemScope,\n          });\n          emitEvent({\n            type: 'ForwardRunRequested',\n            target: targetCheck,\n            scope: itemScope,\n            origin: 'run',\n            sourceCheck: checkId, // The failed check that triggered on_fail.run\n          });\n        }\n      } else {\n        // No forEach context: preserve current scope (if any)\n        state.routingLoopCount++;\n        recordRoutingEvent({\n          checkId,\n          trigger: 'on_fail',\n          action: 'run',\n          target: targetCheck,\n          source: 'run',\n          scope,\n        });\n        emitEvent({\n          type: 'ForwardRunRequested',\n          target: targetCheck,\n          scope,\n          origin: 'run',\n          sourceCheck: checkId, // The failed check that triggered on_fail.run\n        });\n      }\n    }\n  }\n\n  // Process on_fail.run_js\n  if (onFail.run_js) {\n    const dynamicTargets = await evaluateRunJs(\n      onFail.run_js,\n      checkId,\n      checkConfig,\n      result,\n      context,\n      state\n    );\n\n    for (const targetCheck of dynamicTargets) {\n      // Check loop budget before scheduling\n      if (checkLoopBudget(context, state, 'on_fail', 'run')) {\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_fail run`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return;\n      }\n\n      if (context.debug) {\n        logger.info(`[Routing] on_fail.run_js: scheduling ${targetCheck}`);\n      }\n\n      // Increment loop count\n      state.routingLoopCount++;\n\n      recordRoutingEvent({\n        checkId,\n        trigger: 'on_fail',\n        action: 'run',\n        target: targetCheck,\n        source: 'run_js',\n        scope,\n      });\n      emitEvent({\n        type: 'ForwardRunRequested',\n        target: targetCheck,\n        scope,\n        origin: 'run_js',\n        sourceCheck: checkId, // The failed check that triggered on_fail.run_js\n      });\n    }\n  }\n\n  // Process on_fail.retry (schedule retry of the current check)\n  if (onFail.retry && typeof onFail.retry.max === 'number' && onFail.retry.max > 0) {\n    // Criticality mapping: for 'external' and 'internal', avoid automatic\n    // retries for logical failures (fail_if/guarantee violations).\n    const crit = getCriticality(context, checkId);\n    const failureKind = classifyFailure(result);\n    if ((crit === 'external' || crit === 'internal') && failureKind === 'logical') {\n      if (context.debug) {\n        logger.info(\n          `[Routing] on_fail.retry suppressed for ${checkId} (criticality=${crit}, failure=logical)`\n        );\n      }\n      // Skip retry scheduling\n    } else {\n      const max = Math.max(0, onFail.retry.max || 0);\n      // Initialize retry attempt map on state\n      if (!(state as any).retryAttempts) (state as any).retryAttempts = new Map<string, number>();\n      const attemptsMap: Map<string, number> = (state as any).retryAttempts;\n\n      const makeKey = (sc: Array<{ check: string; index: number }> | undefined) => {\n        const keyScope = sc && sc.length > 0 ? JSON.stringify(sc) : 'root';\n        return `${checkId}::${keyScope}`;\n      };\n\n      const scheduleRetryForScope = (sc: Array<{ check: string; index: number }> | undefined) => {\n        const key = makeKey(sc);\n        const used = attemptsMap.get(key) || 0;\n        if (used >= max) return; // budget exhausted\n        attemptsMap.set(key, used + 1);\n\n        // Increment loop count and schedule forward run for the same check\n        state.routingLoopCount++;\n        recordRoutingEvent({\n          checkId,\n          trigger: 'on_fail',\n          action: 'retry',\n          source: 'retry',\n          scope: sc || [],\n        });\n        emitEvent({\n          type: 'ForwardRunRequested',\n          target: checkId,\n          scope: sc || [],\n          origin: 'run',\n        });\n      };\n\n      const resForEachItems: any[] | undefined =\n        (result && (result as any).forEachItems) || undefined;\n      const hasForEachItems = Array.isArray(resForEachItems) && resForEachItems.length > 0;\n\n      if (hasForEachItems) {\n        for (let i = 0; i < resForEachItems!.length; i++) {\n          const itemOut = resForEachItems![i] as any;\n          // Only retry failed iterations (marked by __failed)\n          if (itemOut && typeof itemOut === 'object' && itemOut.__failed === true) {\n            const sc: Array<{ check: string; index: number }> = [{ check: checkId, index: i }];\n            scheduleRetryForScope(sc);\n          }\n        }\n      } else {\n        scheduleRetryForScope(scope);\n      }\n\n      // Note: backoff.delay_ms and mode are intentionally not awaited here; the\n      // state-machine processes retries as subsequent waves. If needed later, we\n      // can insert a timed wait in the orchestrator layer.\n    }\n  }\n\n  // Declarative transitions for on_fail (override goto/goto_js when present)\n  const failTransTarget = await evaluateTransitions(\n    onFail.transitions,\n    checkId,\n    checkConfig,\n    result,\n    context,\n    state\n  );\n  if (failTransTarget !== undefined) {\n    if (failTransTarget) {\n      if (checkLoopBudget(context, state, 'on_fail', 'goto')) {\n        const errorIssue: ReviewIssue = {\n          file: 'system',\n          line: 0,\n          ruleId: `${checkId}/routing/loop_budget_exceeded`,\n          message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? DEFAULT_MAX_LOOPS}) during on_fail goto`,\n          severity: 'error',\n          category: 'logic',\n        };\n        result.issues = [...(result.issues || []), errorIssue];\n        return;\n      }\n      state.routingLoopCount++;\n      recordRoutingEvent({\n        checkId,\n        trigger: 'on_fail',\n        action: 'goto',\n        target: failTransTarget.to,\n        source: 'transitions',\n        scope,\n        gotoEvent: failTransTarget.goto_event,\n      });\n      emitEvent({\n        type: 'ForwardRunRequested',\n        target: failTransTarget.to,\n        scope,\n        origin: 'goto_js',\n        gotoEvent: failTransTarget.goto_event,\n      });\n      state.flags.forwardRunRequested = true;\n    }\n    return;\n  }\n\n  // Process on_fail.goto / goto_js\n  const gotoTarget = await evaluateGoto(\n    onFail.goto_js,\n    onFail.goto,\n    checkId,\n    checkConfig,\n    result,\n    context,\n    state\n  );\n\n  if (gotoTarget) {\n    // Check loop budget before scheduling goto\n    if (checkLoopBudget(context, state, 'on_fail', 'goto')) {\n      const errorIssue: ReviewIssue = {\n        file: 'system',\n        line: 0,\n        ruleId: `${checkId}/routing/loop_budget_exceeded`,\n        message: `Routing loop budget exceeded (max_loops=${context.config.routing?.max_loops ?? 10}) during on_fail goto`,\n        severity: 'error',\n        category: 'logic',\n      };\n      result.issues = [...(result.issues || []), errorIssue];\n      return;\n    }\n\n    if (context.debug) {\n      logger.info(`[Routing] on_fail.goto: ${gotoTarget}`);\n    }\n\n    // Increment loop count\n    state.routingLoopCount++;\n\n    recordRoutingEvent({\n      checkId,\n      trigger: 'on_fail',\n      action: 'goto',\n      target: gotoTarget,\n      source: onFail.goto_js ? 'goto_js' : 'goto',\n      scope,\n      gotoEvent: onFail.goto_event,\n    });\n    // Enqueue forward run event with optional event override\n    emitEvent({\n      type: 'ForwardRunRequested',\n      target: gotoTarget,\n      gotoEvent: onFail.goto_event,\n      scope,\n      origin: 'goto_js',\n    });\n\n    // Mark that we've seen a forward run\n    state.flags.forwardRunRequested = true;\n  }\n}\n\n/**\n * Evaluate run_js expression to get dynamic check targets\n */\nasync function evaluateRunJs(\n  runJs: string,\n  checkId: string,\n  checkConfig: CheckConfig,\n  result: ReviewSummary,\n  context: EngineContext,\n  _state: RunState\n): Promise<string[]> {\n  try {\n    const sandbox = createSecureSandbox();\n\n    // Build outputs record and outputs_history\n    const snapshotId = context.journal.beginSnapshot();\n    const contextView = new (require('../../snapshot-store').ContextView)(\n      context.journal,\n      context.sessionId,\n      snapshotId,\n      [],\n      context.event\n    );\n\n    const outputsRecord: Record<string, any> = {};\n    const outputsHistory: Record<string, any[]> = {};\n\n    // Get all visible journal entries to build complete history\n    const allEntries = context.journal.readVisible(context.sessionId, snapshotId, context.event);\n    const uniqueCheckIds = new Set(allEntries.map(e => e.checkId));\n\n    for (const checkIdFromJournal of uniqueCheckIds) {\n      try {\n        // Get current output for this check\n        const journalResult = contextView.get(checkIdFromJournal);\n        if (journalResult) {\n          // Prefer the output field if present, otherwise use the full result\n          outputsRecord[checkIdFromJournal] =\n            journalResult.output !== undefined ? journalResult.output : journalResult;\n        }\n      } catch {\n        outputsRecord[checkIdFromJournal] = { issues: [] };\n      }\n\n      // Build history for this check\n      try {\n        const history = contextView.getHistory(checkIdFromJournal);\n        if (history && history.length > 0) {\n          // Extract outputs from history (prefer output field if available)\n          outputsHistory[checkIdFromJournal] = history.map((r: any) =>\n            r.output !== undefined ? r.output : r\n          );\n        }\n      } catch {\n        // Ignore history errors\n      }\n    }\n\n    // Add history as a property on outputs object for convenient access\n    outputsRecord.history = outputsHistory;\n\n    // Compute minimal forEach metadata for run_js parity\n    let forEachMeta: any = undefined;\n    try {\n      const hist = outputsHistory[checkId] || [];\n      const lastArr = (hist as any[])\n        .slice()\n        .reverse()\n        .find((x: any) => Array.isArray(x));\n      if (checkConfig.forEach === true && Array.isArray(lastArr)) {\n        forEachMeta = {\n          is_parent: true,\n          last_wave_size: lastArr.length,\n          last_items: lastArr,\n        };\n      }\n    } catch {}\n\n    const scopeObj: any = {\n      step: {\n        id: checkId,\n        tags: checkConfig.tags || [],\n        group: checkConfig.group,\n      },\n      outputs: outputsRecord,\n      outputs_history: outputsHistory,\n      output: (result as any)?.output,\n      memory: createMemoryHelpers(),\n      event: {\n        name: context.event || 'manual',\n      },\n      forEach: forEachMeta,\n    };\n\n    const code = `\n      const step = scope.step;\n      const outputs = scope.outputs;\n      const outputs_history = scope.outputs_history;\n      const output = scope.output;\n      const memory = scope.memory;\n      const event = scope.event;\n      const forEach = scope.forEach;\n      const log = (...args) => console.log('ðŸ” Debug:', ...args);\n      const __fn = () => {\n        ${runJs}\n      };\n      const __res = __fn();\n      return Array.isArray(__res) ? __res.filter(x => typeof x === 'string' && x) : [];\n    `;\n\n    try {\n      const evalResult = compileAndRun<string[]>(\n        sandbox,\n        code,\n        { scope: scopeObj },\n        { injectLog: false, wrapFunction: false }\n      );\n      return Array.isArray(evalResult) ? evalResult.filter(Boolean) : [];\n    } catch (_e) {\n      // Fallback to VM for modern syntax used inside run_js\n      try {\n        const vm = require('node:vm');\n        const context = vm.createContext({ scope: scopeObj, console: { log: () => {} } });\n        const src = `(() => { ${runJs}\\n })()`;\n        const val = new vm.Script(src).runInContext(context, { timeout: 100 });\n        return Array.isArray(val) ? val.filter((x: any) => typeof x === 'string' && x) : [];\n      } catch (_vmErr) {\n        return [];\n      }\n    }\n  } catch (error) {\n    const msg = error instanceof Error ? error.message : String(error);\n    logger.error(`[Routing] Error evaluating run_js: ${msg}`);\n    return [];\n  }\n}\n\n/**\n * Evaluate goto_js or return static goto target\n */\nexport async function evaluateGoto(\n  gotoJs: string | undefined,\n  gotoStatic: string | undefined,\n  checkId: string,\n  checkConfig: CheckConfig,\n  result: ReviewSummary,\n  context: EngineContext,\n  _state: RunState\n): Promise<string | null> {\n  // Evaluate goto_js first\n  if (gotoJs) {\n    try {\n      const sandbox = createSecureSandbox();\n\n      // Build outputs record and outputs_history from the full session snapshot.\n      // Do not filter by event here â€” on_finish (especially forEach post-children) may\n      // need to see results committed under different event triggers within the same run.\n      const snapshotId = context.journal.beginSnapshot();\n      const contextView = new (require('../../snapshot-store').ContextView)(\n        context.journal,\n        context.sessionId,\n        snapshotId,\n        [],\n        undefined\n      );\n\n      const outputsRecord: Record<string, any> = {};\n      const outputsHistory: Record<string, any[]> = {};\n\n      // Get all visible journal entries to build complete history\n      const allEntries = context.journal.readVisible(context.sessionId, snapshotId, undefined);\n      const uniqueCheckIds = new Set(allEntries.map(e => e.checkId));\n\n      for (const checkIdFromJournal of uniqueCheckIds) {\n        try {\n          // Get current output for this check\n          const journalResult = contextView.get(checkIdFromJournal);\n          if (journalResult) {\n            // Prefer the output field if present, otherwise use the full result\n            outputsRecord[checkIdFromJournal] =\n              journalResult.output !== undefined ? journalResult.output : journalResult;\n          }\n        } catch {\n          outputsRecord[checkIdFromJournal] = { issues: [] };\n        }\n\n        // Build history for this check\n        try {\n          const history = contextView.getHistory(checkIdFromJournal);\n          if (history && history.length > 0) {\n            // Extract outputs from history (prefer output field if available)\n            outputsHistory[checkIdFromJournal] = history.map((r: any) =>\n              r.output !== undefined ? r.output : r\n            );\n          }\n        } catch {\n          // Ignore history errors\n        }\n      }\n\n      // Add history as a property on outputs object for convenient access\n      outputsRecord.history = outputsHistory;\n\n      // Compute minimal forEach metadata for convenience in goto_js\n      // - last_wave_size: number of items in the latest root-scope array output\n      // - last_items: the latest array output itself (if available)\n      let forEachMeta: any = undefined;\n      try {\n        const hist = outputsHistory[checkId] || [];\n        const lastArr = (hist as any[])\n          .slice()\n          .reverse()\n          .find((x: any) => Array.isArray(x));\n        if (checkConfig.forEach === true && Array.isArray(lastArr)) {\n          forEachMeta = {\n            is_parent: true,\n            last_wave_size: lastArr.length,\n            last_items: lastArr,\n          };\n        }\n      } catch {}\n\n      const scopeObj: any = {\n        step: {\n          id: checkId,\n          tags: checkConfig.tags || [],\n          group: checkConfig.group,\n        },\n        outputs: outputsRecord,\n        outputs_history: outputsHistory,\n        output: (result as any)?.output,\n        memory: createMemoryHelpers(),\n        event: {\n          name: context.event || 'manual',\n        },\n        forEach: forEachMeta,\n      };\n\n      // Debug: Log outputs_history\n      if (context.debug) {\n        logger.info(\n          `[Routing] evaluateGoto: checkId=${checkId}, outputs_history keys=${Object.keys(outputsHistory).join(',')}`\n        );\n        for (const [key, values] of Object.entries(outputsHistory)) {\n          logger.info(`[Routing]   ${key}: ${values.length} items`);\n        }\n      }\n\n      const code = `\n        const step = scope.step;\n        const outputs = scope.outputs;\n        const outputs_history = scope.outputs_history;\n        const output = scope.output;\n        const memory = scope.memory;\n        const event = scope.event;\n        const forEach = scope.forEach;\n        const log = (...args) => console.log('ðŸ” Debug:', ...args);\n        ${gotoJs}\n      `;\n\n      try {\n        const evalResult = compileAndRun<string | null>(\n          sandbox,\n          code,\n          { scope: scopeObj },\n          { injectLog: false, wrapFunction: true }\n        );\n\n        if (context.debug) {\n          logger.info(`[Routing] evaluateGoto result: ${evalResult}`);\n        }\n\n        if (typeof evalResult === 'string' && evalResult) {\n          return evalResult;\n        }\n      } catch (_e) {\n        // Fallback to VM for modern syntax in goto_js\n        try {\n          const vm = require('node:vm');\n          const contextObj = {\n            step: scopeObj.step,\n            outputs: scopeObj.outputs,\n            outputs_history: scopeObj.outputs_history,\n            output: scopeObj.output,\n            memory: scopeObj.memory,\n            event: scopeObj.event,\n            forEach: (scopeObj as any).forEach,\n          };\n          const vmctx = vm.createContext(contextObj);\n          const src = `(() => { ${gotoJs}\\n })()`;\n          const res = new vm.Script(src).runInContext(vmctx, { timeout: 100 });\n          if (typeof res === 'string' && res) return res;\n        } catch (_vmErr) {\n          // ignore; fall through to static goto\n        }\n      }\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : String(error);\n      logger.error(`[Routing] Error evaluating goto_js: ${msg}`);\n\n      // Fall back to static goto if available\n      if (gotoStatic) {\n        logger.info(`[Routing] Falling back to static goto: ${gotoStatic}`);\n        return gotoStatic;\n      }\n    }\n  }\n\n  // Return static goto\n  return gotoStatic || null;\n}\n// Default values (used only when config is absent)\nconst DEFAULT_MAX_LOOPS = 10;\n\n/**\n * Evaluate declarative transitions. Returns:\n *  - { to, goto_event } when a rule matches,\n *  - null (explicit) when a rule matches with to=null,\n *  - undefined when no rule matched or transitions is empty.\n */\nexport async function evaluateTransitions(\n  transitions: TransitionRule[] | undefined,\n  checkId: string,\n  checkConfig: CheckConfig,\n  result: ReviewSummary,\n  context: EngineContext,\n  _state: RunState\n): Promise<\n  { to: string; goto_event?: import('../../types/config').EventTrigger } | null | undefined\n> {\n  if (!transitions || transitions.length === 0) return undefined;\n  try {\n    const sandbox = createSecureSandbox();\n\n    // Build outputs record and outputs_history from the full session snapshot\n    const snapshotId = context.journal.beginSnapshot();\n    const ContextView = (require('../../snapshot-store') as any).ContextView;\n    const view = new ContextView(context.journal, context.sessionId, snapshotId, [], undefined);\n\n    const outputsRecord: Record<string, any> = {};\n    const outputsHistory: Record<string, any[]> = {};\n    const allEntries = context.journal.readVisible(context.sessionId, snapshotId, undefined);\n    const uniqueCheckIds = new Set(allEntries.map((e: any) => e.checkId));\n    for (const cid of uniqueCheckIds) {\n      try {\n        const jr = view.get(cid);\n        if (jr) outputsRecord[cid] = jr.output !== undefined ? jr.output : jr;\n      } catch {}\n      try {\n        const hist = view.getHistory(cid);\n        if (hist && hist.length > 0) {\n          outputsHistory[cid] = hist.map((r: any) => (r.output !== undefined ? r.output : r));\n        }\n      } catch {}\n    }\n    outputsRecord.history = outputsHistory;\n\n    const scopeObj: any = {\n      step: { id: checkId, tags: checkConfig.tags || [], group: checkConfig.group },\n      outputs: outputsRecord,\n      outputs_history: outputsHistory,\n      output: (result as any)?.output,\n      memory: createMemoryHelpers(),\n      event: { name: context.event || 'manual' },\n    };\n\n    for (const rule of transitions) {\n      const helpers = `\n        const any = (arr, pred) => Array.isArray(arr) && arr.some(x => pred(x));\n        const all = (arr, pred) => Array.isArray(arr) && arr.every(x => pred(x));\n        const none = (arr, pred) => Array.isArray(arr) && !arr.some(x => pred(x));\n        const count = (arr, pred) => Array.isArray(arr) ? arr.filter(x => pred(x)).length : 0;\n      `;\n      // Mirror the variable exposure pattern used in goto_js/run_js so that\n      // `when:` expressions can reference `outputs`, `outputs_history`, `event`, etc.\n      const code = `\n        ${helpers}\n        const step = scope.step;\n        const outputs = scope.outputs;\n        const outputs_history = scope.outputs_history;\n        const output = scope.output;\n        const memory = scope.memory;\n        const event = scope.event;\n        const __eval = () => { return (${rule.when}); };\n        return __eval();\n      `;\n      let matched: boolean | undefined;\n      try {\n        matched = compileAndRun<boolean>(\n          sandbox,\n          code,\n          { scope: scopeObj },\n          { injectLog: false, wrapFunction: false }\n        );\n      } catch (_e) {\n        // Fallback: Node VM for modern syntax like optional chaining and ??\n        try {\n          const vm = require('node:vm');\n          const helpersFns = {\n            any: (arr: any[], pred: (x: any) => boolean) => Array.isArray(arr) && arr.some(pred),\n            all: (arr: any[], pred: (x: any) => boolean) => Array.isArray(arr) && arr.every(pred),\n            none: (arr: any[], pred: (x: any) => boolean) => Array.isArray(arr) && !arr.some(pred),\n            count: (arr: any[], pred: (x: any) => boolean) =>\n              Array.isArray(arr) ? arr.filter(pred).length : 0,\n          };\n          const context = vm.createContext({\n            step: scopeObj.step,\n            outputs: scopeObj.outputs,\n            outputs_history: scopeObj.outputs_history,\n            output: scopeObj.output,\n            memory: scopeObj.memory,\n            event: scopeObj.event,\n            ...helpersFns,\n          });\n          const res = new vm.Script(`(${rule.when})`).runInContext(context, { timeout: 50 });\n          matched = !!res;\n        } catch (_vmErr) {\n          matched = false;\n        }\n      }\n      if (matched) {\n        if (rule.to === null) return null;\n        if (typeof rule.to === 'string' && rule.to.length > 0) {\n          return { to: rule.to, goto_event: (rule as any).goto_event };\n        }\n        return null;\n      }\n    }\n    return undefined;\n  } catch (err) {\n    logger.error(\n      `[Routing] Error evaluating transitions: ${err instanceof Error ? err.message : String(err)}`\n    );\n    return undefined;\n  }\n}\n"],"mappings":"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","names":["context","ContextView"]}