{"version":3,"sources":["../../src/utils/config-merger.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { VisorConfig, CheckConfig } from '../types/config';\n\n/**\n * Utility class for merging Visor configurations with proper override semantics\n */\nexport class ConfigMerger {\n  /**\n   * Merge two configurations with child overriding parent\n   * @param parent - Base configuration\n   * @param child - Configuration to merge on top\n   * @returns Merged configuration\n   */\n  public merge(parent: Partial<VisorConfig>, child: Partial<VisorConfig>): Partial<VisorConfig> {\n    // Start with a deep copy of parent\n    const result: Partial<VisorConfig> = this.deepCopy(parent);\n\n    // Merge simple properties (child overrides parent)\n    if (child.version !== undefined) result.version = child.version;\n    if (child.ai_model !== undefined) result.ai_model = child.ai_model;\n    if (child.ai_provider !== undefined) result.ai_provider = child.ai_provider;\n    if (child.max_parallelism !== undefined) result.max_parallelism = child.max_parallelism;\n    if (child.fail_fast !== undefined) result.fail_fast = child.fail_fast;\n    if (child.fail_if !== undefined) result.fail_if = child.fail_if;\n    if (child.failure_conditions !== undefined)\n      result.failure_conditions = child.failure_conditions;\n\n    // Merge environment variables (deep merge)\n    if (child.env) {\n      result.env = this.mergeObjects(parent.env || {}, child.env);\n    }\n\n    // Merge output configuration (deep merge)\n    if (child.output) {\n      result.output = this.mergeOutputConfig(parent.output, child.output);\n    }\n\n    // Merge checks (special handling)\n    if (child.checks) {\n      result.checks = this.mergeChecks(parent.checks || {}, child.checks);\n    }\n\n    // Note: extends should not be in the final merged config\n    // It's only used during the loading process\n\n    return result;\n  }\n\n  /**\n   * Deep copy an object\n   */\n  private deepCopy<T>(obj: T): T {\n    if (obj === null || obj === undefined) {\n      return obj;\n    }\n    if (obj instanceof Date) {\n      return new Date(obj.getTime()) as unknown as T;\n    }\n    if (obj instanceof Array) {\n      const copy: unknown[] = [];\n      for (const item of obj) {\n        copy.push(this.deepCopy(item));\n      }\n      return copy as unknown as T;\n    }\n    if (obj instanceof Object) {\n      const copy = {} as Record<string, unknown>;\n      for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          copy[key] = this.deepCopy((obj as any)[key]);\n        }\n      }\n      return copy as T;\n    }\n    return obj;\n  }\n\n  /**\n   * Merge two objects (child overrides parent)\n   */\n  private mergeObjects<T extends Record<string, any>>(parent: T, child: T): T {\n    const result: any = { ...parent };\n\n    for (const key in child) {\n      if (Object.prototype.hasOwnProperty.call(child, key)) {\n        const parentValue = parent[key];\n        const childValue = child[key];\n\n        if (childValue === null || childValue === undefined) {\n          // null/undefined in child removes the key\n          delete result[key];\n        } else if (\n          typeof parentValue === 'object' &&\n          typeof childValue === 'object' &&\n          !Array.isArray(parentValue) &&\n          !Array.isArray(childValue) &&\n          parentValue !== null &&\n          childValue !== null\n        ) {\n          // Deep merge objects\n          result[key] = this.mergeObjects(\n            parentValue as Record<string, any>,\n            childValue as Record<string, any>\n          );\n        } else {\n          // Child overrides parent (including arrays)\n          result[key] = this.deepCopy(childValue);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Merge output configurations\n   */\n  private mergeOutputConfig(\n    parent?: Partial<VisorConfig>['output'],\n    child?: Partial<VisorConfig>['output']\n  ): Partial<VisorConfig>['output'] {\n    if (!child) return parent;\n    if (!parent) return child;\n\n    const result: any = this.deepCopy(parent);\n\n    // Merge pr_comment\n    if (child.pr_comment) {\n      result.pr_comment = this.mergeObjects(\n        (parent.pr_comment || {}) as Record<string, any>,\n        child.pr_comment as Record<string, any>\n      ) as any;\n    }\n\n    // Merge file_comment\n    if (child.file_comment !== undefined) {\n      if (child.file_comment === null) {\n        delete result.file_comment;\n      } else {\n        result.file_comment = this.mergeObjects(\n          (parent.file_comment || {}) as Record<string, any>,\n          child.file_comment as Record<string, any>\n        ) as any;\n      }\n    }\n\n    // Merge github_checks\n    if (child.github_checks !== undefined) {\n      if (child.github_checks === null) {\n        delete result.github_checks;\n      } else {\n        result.github_checks = this.mergeObjects(\n          (parent.github_checks || {}) as Record<string, any>,\n          child.github_checks as Record<string, any>\n        ) as any;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Merge check configurations with special handling\n   */\n  private mergeChecks(\n    parent: Record<string, CheckConfig>,\n    child: Record<string, CheckConfig>\n  ): Record<string, CheckConfig> {\n    const result: Record<string, CheckConfig> = {};\n\n    // Start with all parent checks\n    for (const [checkName, checkConfig] of Object.entries(parent)) {\n      result[checkName] = this.deepCopy(checkConfig);\n    }\n\n    // Process child checks\n    for (const [checkName, childConfig] of Object.entries(child)) {\n      const parentConfig = parent[checkName];\n\n      if (!parentConfig) {\n        // New check - need to process appendPrompt even without parent\n        const copiedConfig = this.deepCopy(childConfig);\n\n        // Default to 'ai' type if not specified\n        if (!copiedConfig.type) {\n          copiedConfig.type = 'ai';\n        }\n\n        // Default 'on' to ['manual'] if not specified\n        if (!copiedConfig.on) {\n          copiedConfig.on = ['manual'];\n        }\n\n        // Handle appendPrompt for new checks (convert to prompt)\n        if (copiedConfig.appendPrompt !== undefined) {\n          // If there's no parent, appendPrompt becomes the prompt\n          if (!copiedConfig.prompt) {\n            copiedConfig.prompt = copiedConfig.appendPrompt;\n          } else {\n            // If both prompt and appendPrompt exist in child, append them\n            copiedConfig.prompt = copiedConfig.prompt + '\\n\\n' + copiedConfig.appendPrompt;\n          }\n          // Remove appendPrompt from final config\n          delete copiedConfig.appendPrompt;\n        }\n\n        result[checkName] = copiedConfig;\n      } else {\n        // Merge existing check\n        result[checkName] = this.mergeCheckConfig(parentConfig, childConfig);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Merge individual check configurations\n   */\n  private mergeCheckConfig(parent: CheckConfig, child: CheckConfig): CheckConfig {\n    const result: CheckConfig = this.deepCopy(parent);\n\n    // Simple properties (child overrides parent)\n    if (child.type !== undefined) result.type = child.type;\n\n    // Default to 'ai' type if not specified in either parent or child\n    if (!result.type) {\n      result.type = 'ai';\n    }\n    if (child.prompt !== undefined) result.prompt = child.prompt;\n\n    // Handle appendPrompt - append to existing prompt\n    if (child.appendPrompt !== undefined) {\n      if (result.prompt) {\n        // Append with a newline separator if parent has a prompt\n        result.prompt = result.prompt + '\\n\\n' + child.appendPrompt;\n      } else {\n        // If no parent prompt, appendPrompt becomes the prompt\n        result.prompt = child.appendPrompt;\n      }\n      // Don't carry forward appendPrompt to avoid re-appending\n      delete result.appendPrompt;\n    }\n\n    if (child.exec !== undefined) result.exec = child.exec;\n    if (child.stdin !== undefined) result.stdin = child.stdin;\n    if (child.url !== undefined) result.url = child.url;\n    if (child.focus !== undefined) result.focus = child.focus;\n    if (child.command !== undefined) result.command = child.command;\n    if (child.ai_model !== undefined) result.ai_model = child.ai_model;\n    if (child.ai_provider !== undefined) result.ai_provider = child.ai_provider;\n    if (child.group !== undefined) result.group = child.group;\n    if (child.schema !== undefined) result.schema = child.schema;\n    if (child.if !== undefined) result.if = child.if;\n    if (child.reuse_ai_session !== undefined) result.reuse_ai_session = child.reuse_ai_session;\n    if (child.fail_if !== undefined) result.fail_if = child.fail_if;\n    if (child.failure_conditions !== undefined)\n      result.failure_conditions = child.failure_conditions;\n\n    // Special handling for 'on' array\n    if (child.on !== undefined) {\n      if (Array.isArray(child.on) && child.on.length === 0) {\n        // Empty array disables the check\n        result.on = [];\n      } else {\n        // Replace parent's on array\n        result.on = [...child.on];\n      }\n    }\n\n    // Default 'on' to ['manual'] if still not specified\n    if (!result.on) {\n      result.on = ['manual'];\n    }\n\n    // Arrays that get replaced (not concatenated)\n    if (child.triggers !== undefined) {\n      result.triggers = child.triggers ? [...child.triggers] : undefined;\n    }\n    if (child.depends_on !== undefined) {\n      result.depends_on = child.depends_on ? [...child.depends_on] : undefined;\n    }\n\n    // Deep merge objects\n    if (child.env) {\n      result.env = this.mergeObjects(\n        (parent.env || {}) as Record<string, any>,\n        child.env as Record<string, any>\n      );\n    }\n    if (child.ai) {\n      result.ai = this.mergeObjects(\n        (parent.ai || {}) as Record<string, any>,\n        child.ai as Record<string, any>\n      );\n    }\n    if (child.template) {\n      result.template = this.mergeObjects(\n        (parent.template || {}) as Record<string, any>,\n        child.template as Record<string, any>\n      );\n    }\n\n    return result;\n  }\n\n  /**\n   * Check if a check is disabled (has empty 'on' array)\n   */\n  public isCheckDisabled(check: CheckConfig): boolean {\n    return Array.isArray(check.on) && check.on.length === 0;\n  }\n\n  /**\n   * Remove disabled checks from the configuration\n   */\n  public removeDisabledChecks(config: Partial<VisorConfig>): Partial<VisorConfig> {\n    if (!config.checks) return config;\n\n    const result = this.deepCopy(config);\n    const enabledChecks: Record<string, CheckConfig> = {};\n\n    for (const [checkName, checkConfig] of Object.entries(result.checks!)) {\n      if (!this.isCheckDisabled(checkConfig)) {\n        enabledChecks[checkName] = checkConfig;\n      } else {\n        console.log(`ℹ️  Check '${checkName}' is disabled (empty 'on' array)`);\n      }\n    }\n\n    result.checks = enabledChecks;\n    return result;\n  }\n}\n"],"mappings":"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","names":[]}