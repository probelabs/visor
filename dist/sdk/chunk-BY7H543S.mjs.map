{"version":3,"sources":["../../src/workflow-registry.ts","../../src/dependency-resolver.ts"],"sourcesContent":["/**\n * Workflow registry for managing reusable workflow definitions\n */\n\nimport {\n  WorkflowDefinition,\n  WorkflowRegistryEntry,\n  WorkflowValidationResult,\n  WorkflowImportOptions,\n  JsonSchema,\n} from './types/workflow';\nimport { promises as fs } from 'fs';\nimport * as path from 'path';\nimport * as yaml from 'js-yaml';\nimport { logger } from './logger';\nimport { DependencyResolver } from './dependency-resolver';\nimport Ajv from 'ajv';\nimport addFormats from 'ajv-formats';\n\n/**\n * Registry for managing workflow definitions\n */\nexport class WorkflowRegistry {\n  private static instance: WorkflowRegistry;\n  private workflows: Map<string, WorkflowRegistryEntry> = new Map();\n  private ajv: Ajv;\n\n  private constructor() {\n    this.ajv = new Ajv({ allErrors: true, strict: false });\n    addFormats(this.ajv);\n  }\n\n  /**\n   * Get the singleton instance of the workflow registry\n   */\n  public static getInstance(): WorkflowRegistry {\n    if (!WorkflowRegistry.instance) {\n      WorkflowRegistry.instance = new WorkflowRegistry();\n    }\n    return WorkflowRegistry.instance;\n  }\n\n  /**\n   * Register a workflow definition\n   */\n  public register(\n    workflow: WorkflowDefinition,\n    source: string = 'inline',\n    options?: { override?: boolean }\n  ): WorkflowValidationResult {\n    // Validate the workflow\n    const validation = this.validateWorkflow(workflow);\n    if (!validation.valid) {\n      return validation;\n    }\n\n    // Check if workflow already exists\n    if (this.workflows.has(workflow.id) && !options?.override) {\n      return {\n        valid: false,\n        errors: [\n          {\n            path: 'id',\n            message: `Workflow with ID '${workflow.id}' already exists`,\n            value: workflow.id,\n          },\n        ],\n      };\n    }\n\n    // Register the workflow\n    this.workflows.set(workflow.id, {\n      definition: workflow,\n      source,\n      registeredAt: new Date(),\n      usage: {\n        count: 0,\n      },\n    });\n\n    logger.debug(`Registered workflow '${workflow.id}' from ${source}`);\n    return { valid: true };\n  }\n\n  /**\n   * Get a workflow by ID\n   */\n  public get(id: string): WorkflowDefinition | undefined {\n    const entry = this.workflows.get(id);\n    if (entry) {\n      // Update usage statistics\n      entry.usage = entry.usage || { count: 0 };\n      entry.usage.count++;\n      entry.usage.lastUsed = new Date();\n    }\n    return entry?.definition;\n  }\n\n  /**\n   * Check if a workflow exists\n   */\n  public has(id: string): boolean {\n    return this.workflows.has(id);\n  }\n\n  /**\n   * List all registered workflows\n   */\n  public list(): WorkflowDefinition[] {\n    return Array.from(this.workflows.values()).map(entry => entry.definition);\n  }\n\n  /**\n   * Get workflow metadata\n   */\n  public getMetadata(id: string): WorkflowRegistryEntry | undefined {\n    return this.workflows.get(id);\n  }\n\n  /**\n   * Remove a workflow from the registry\n   */\n  public unregister(id: string): boolean {\n    return this.workflows.delete(id);\n  }\n\n  /**\n   * Clear all workflows\n   */\n  public clear(): void {\n    this.workflows.clear();\n  }\n\n  /**\n   * Import workflows from a file or URL\n   */\n  public async import(\n    source: string,\n    options?: WorkflowImportOptions\n  ): Promise<WorkflowValidationResult[]> {\n    const results: WorkflowValidationResult[] = [];\n\n    try {\n      // Load the workflow file\n      const content = await this.loadWorkflowContent(source, options?.basePath);\n      const data = this.parseWorkflowContent(content, source);\n\n      // Handle both single workflow and multiple workflows\n      const workflows: WorkflowDefinition[] = Array.isArray(data) ? data : [data];\n\n      for (const workflow of workflows) {\n        // Validate if requested\n        if (options?.validate !== false) {\n          const validation = this.validateWorkflow(workflow);\n          if (!validation.valid) {\n            results.push(validation);\n            continue;\n          }\n\n          // Run custom validators if provided\n          if (options?.validators) {\n            for (const validator of options.validators) {\n              const customValidation = validator(workflow);\n              if (!customValidation.valid) {\n                results.push(customValidation);\n                continue;\n              }\n            }\n          }\n        }\n\n        // Strip out 'tests' field before registering - tests are only for standalone execution\n        const workflowWithoutTests = { ...workflow };\n        delete (workflowWithoutTests as any).tests;\n\n        // Register the workflow (without tests)\n        const result = this.register(workflowWithoutTests, source, { override: options?.override });\n        results.push(result);\n      }\n    } catch (error) {\n      results.push({\n        valid: false,\n        errors: [\n          {\n            path: 'source',\n            message: `Failed to import workflows from '${source}': ${error instanceof Error ? error.message : String(error)}`,\n            value: source,\n          },\n        ],\n      });\n    }\n\n    return results;\n  }\n\n  /**\n   * Import multiple workflow sources\n   */\n  public async importMany(\n    sources: string[],\n    options?: WorkflowImportOptions\n  ): Promise<Map<string, WorkflowValidationResult[]>> {\n    const results = new Map<string, WorkflowValidationResult[]>();\n\n    for (const source of sources) {\n      const importResults = await this.import(source, options);\n      results.set(source, importResults);\n    }\n\n    return results;\n  }\n\n  /**\n   * Validate a workflow definition\n   */\n  public validateWorkflow(workflow: WorkflowDefinition): WorkflowValidationResult {\n    const errors: Array<{ path: string; message: string; value?: unknown }> = [];\n    const warnings: Array<{ path: string; message: string }> = [];\n\n    // Validate required fields\n    if (!workflow.id) {\n      errors.push({ path: 'id', message: 'Workflow ID is required' });\n    }\n\n    if (!workflow.name) {\n      errors.push({ path: 'name', message: 'Workflow name is required' });\n    }\n\n    if (!workflow.steps || Object.keys(workflow.steps).length === 0) {\n      errors.push({ path: 'steps', message: 'Workflow must have at least one step' });\n    }\n\n    // Validate input parameters\n    if (workflow.inputs) {\n      for (let i = 0; i < workflow.inputs.length; i++) {\n        const input = workflow.inputs[i];\n        if (!input.name) {\n          errors.push({ path: `inputs[${i}].name`, message: 'Input parameter name is required' });\n        }\n        if (!input.schema) {\n          warnings.push({\n            path: `inputs[${i}].schema`,\n            message: 'Input parameter schema is recommended',\n          });\n        }\n      }\n    }\n\n    // Validate output parameters\n    if (workflow.outputs) {\n      for (let i = 0; i < workflow.outputs.length; i++) {\n        const output = workflow.outputs[i];\n        if (!output.name) {\n          errors.push({ path: `outputs[${i}].name`, message: 'Output parameter name is required' });\n        }\n        if (!output.value && !output.value_js) {\n          errors.push({\n            path: `outputs[${i}]`,\n            message: 'Output parameter must have either value or value_js',\n          });\n        }\n      }\n    }\n\n    // Validate steps\n    for (const [stepId, step] of Object.entries(workflow.steps || {})) {\n      // Validate step dependencies\n      if (step.depends_on) {\n        for (const dep of step.depends_on) {\n          if (!workflow.steps[dep]) {\n            errors.push({\n              path: `steps.${stepId}.depends_on`,\n              message: `Step '${stepId}' depends on non-existent step '${dep}'`,\n              value: dep,\n            });\n          }\n        }\n      }\n\n      // Validate input mappings\n      if (step.inputs) {\n        for (const [inputName, mapping] of Object.entries(step.inputs)) {\n          if (typeof mapping === 'object' && mapping !== null && 'source' in mapping) {\n            const typedMapping = mapping as any;\n            if (typedMapping.source === 'step' && !typedMapping.stepId) {\n              errors.push({\n                path: `steps.${stepId}.inputs.${inputName}`,\n                message: 'Step input mapping with source \"step\" must have stepId',\n              });\n            }\n            if (typedMapping.source === 'param') {\n              // Validate that the parameter exists\n              const paramExists = workflow.inputs?.some(p => p.name === typedMapping.value);\n              if (!paramExists) {\n                errors.push({\n                  path: `steps.${stepId}.inputs.${inputName}`,\n                  message: `Step input references non-existent parameter '${typedMapping.value}'`,\n                  value: typedMapping.value,\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Check for circular dependencies\n    const circularDeps = this.detectCircularDependencies(workflow);\n    if (circularDeps.length > 0) {\n      errors.push({\n        path: 'steps',\n        message: `Circular dependencies detected: ${circularDeps.join(' -> ')}`,\n      });\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors: errors.length > 0 ? errors : undefined,\n      warnings: warnings.length > 0 ? warnings : undefined,\n    };\n  }\n\n  /**\n   * Validate input values against workflow input schema\n   */\n  public validateInputs(\n    workflow: WorkflowDefinition,\n    inputs: Record<string, unknown>\n  ): WorkflowValidationResult {\n    const errors: Array<{ path: string; message: string; value?: unknown }> = [];\n\n    if (!workflow.inputs) {\n      return { valid: true };\n    }\n\n    // Check required inputs\n    for (const param of workflow.inputs) {\n      if (param.required !== false && !(param.name in inputs) && param.default === undefined) {\n        errors.push({\n          path: `inputs.${param.name}`,\n          message: `Required input '${param.name}' is missing`,\n        });\n      }\n    }\n\n    // Validate input schemas\n    for (const param of workflow.inputs) {\n      if (param.name in inputs && param.schema) {\n        const value = inputs[param.name];\n        const valid = this.validateAgainstSchema(value, param.schema);\n        if (!valid.valid) {\n          errors.push({\n            path: `inputs.${param.name}`,\n            message: valid.error || 'Invalid input value',\n            value,\n          });\n        }\n      }\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors: errors.length > 0 ? errors : undefined,\n    };\n  }\n\n  /**\n   * Load workflow content from file or URL\n   */\n  private async loadWorkflowContent(source: string, basePath?: string): Promise<string> {\n    // Handle URLs\n    if (source.startsWith('http://') || source.startsWith('https://')) {\n      const response = await fetch(source);\n      if (!response.ok) {\n        throw new Error(`Failed to fetch workflow from ${source}: ${response.statusText}`);\n      }\n      return await response.text();\n    }\n\n    // Handle file paths\n    const filePath = path.isAbsolute(source)\n      ? source\n      : path.resolve(basePath || process.cwd(), source);\n    return await fs.readFile(filePath, 'utf-8');\n  }\n\n  /**\n   * Parse workflow content (YAML or JSON)\n   */\n  private parseWorkflowContent(content: string, source: string): any {\n    // Try JSON first\n    try {\n      return JSON.parse(content);\n    } catch {\n      // Try YAML\n      try {\n        return yaml.load(content);\n      } catch (error) {\n        throw new Error(\n          `Failed to parse workflow file ${source}: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n  }\n\n  /**\n   * Detect circular dependencies in workflow steps using DependencyResolver\n   */\n  private detectCircularDependencies(workflow: WorkflowDefinition): string[] {\n    // Build dependency map\n    const dependencies: Record<string, string[]> = {};\n    for (const [stepId, step] of Object.entries(workflow.steps || {})) {\n      dependencies[stepId] = step.depends_on || [];\n    }\n\n    try {\n      // Use DependencyResolver to check for cycles\n      const graph = DependencyResolver.buildDependencyGraph(dependencies);\n\n      if (graph.hasCycles && graph.cycleNodes) {\n        return graph.cycleNodes;\n      }\n\n      return [];\n    } catch {\n      // DependencyResolver throws error for non-existent dependencies\n      // This should be caught by the dependency validation in validateWorkflow\n      // Return empty array here and let the validation handle it\n      return [];\n    }\n  }\n\n  /**\n   * Validate a value against a JSON schema\n   */\n  private validateAgainstSchema(\n    value: unknown,\n    schema: JsonSchema\n  ): { valid: boolean; error?: string } {\n    try {\n      const validate = this.ajv.compile(schema as any);\n      const valid = validate(value);\n      if (!valid) {\n        const errors = validate.errors\n          ?.map(e => `${e.instancePath || '/'}: ${e.message}`)\n          .join(', ');\n        return { valid: false, error: errors };\n      }\n      return { valid: true };\n    } catch (error) {\n      return { valid: false, error: error instanceof Error ? error.message : String(error) };\n    }\n  }\n}\n","/**\n * Dependency resolution and execution ordering for checks\n */\n\nexport interface CheckNode {\n  id: string;\n  dependencies: string[];\n  dependents: string[];\n  depth: number;\n}\n\nexport interface ExecutionGroup {\n  /** Checks that can run in parallel */\n  parallel: string[];\n  /** Execution level/wave (0 = no dependencies, 1 = depends on level 0, etc.) */\n  level: number;\n}\n\nexport interface DependencyGraph {\n  nodes: Map<string, CheckNode>;\n  executionOrder: ExecutionGroup[];\n  hasCycles: boolean;\n  cycleNodes?: string[];\n}\n\nexport class DependencyResolver {\n  /**\n   * Build dependency graph from check dependencies\n   */\n  static buildDependencyGraph(checkDependencies: Record<string, string[]>): DependencyGraph {\n    const nodes = new Map<string, CheckNode>();\n\n    // Initialize all nodes\n    for (const checkId of Object.keys(checkDependencies)) {\n      nodes.set(checkId, {\n        id: checkId,\n        dependencies: checkDependencies[checkId] || [],\n        dependents: [],\n        depth: 0,\n      });\n    }\n\n    // Build bidirectional relationships\n    for (const [checkId, dependencies] of Object.entries(checkDependencies)) {\n      for (const depId of dependencies || []) {\n        if (!nodes.has(depId)) {\n          throw new Error(`Check \"${checkId}\" depends on \"${depId}\" but \"${depId}\" is not defined`);\n        }\n\n        const depNode = nodes.get(depId)!;\n        depNode.dependents.push(checkId);\n      }\n    }\n\n    // Detect cycles using DFS\n    const cycleDetection = this.detectCycles(nodes);\n    if (cycleDetection.hasCycles) {\n      return {\n        nodes,\n        executionOrder: [],\n        hasCycles: true,\n        cycleNodes: cycleDetection.cycleNodes,\n      };\n    }\n\n    // Calculate execution order using topological sort\n    const executionOrder = this.topologicalSort(nodes);\n\n    return {\n      nodes,\n      executionOrder,\n      hasCycles: false,\n    };\n  }\n\n  /**\n   * Detect cycles in the dependency graph using DFS\n   */\n  private static detectCycles(nodes: Map<string, CheckNode>): {\n    hasCycles: boolean;\n    cycleNodes?: string[];\n  } {\n    const visited = new Set<string>();\n    const recursionStack = new Set<string>();\n    const cycleNodes: string[] = [];\n\n    const dfs = (nodeId: string): boolean => {\n      if (recursionStack.has(nodeId)) {\n        cycleNodes.push(nodeId);\n        return true;\n      }\n      if (visited.has(nodeId)) {\n        return false;\n      }\n\n      visited.add(nodeId);\n      recursionStack.add(nodeId);\n\n      const node = nodes.get(nodeId);\n      if (node) {\n        for (const depId of node.dependencies) {\n          if (dfs(depId)) {\n            cycleNodes.push(nodeId);\n            return true;\n          }\n        }\n      }\n\n      recursionStack.delete(nodeId);\n      return false;\n    };\n\n    for (const nodeId of nodes.keys()) {\n      if (!visited.has(nodeId)) {\n        if (dfs(nodeId)) {\n          return { hasCycles: true, cycleNodes: [...new Set(cycleNodes)] };\n        }\n      }\n    }\n\n    return { hasCycles: false };\n  }\n\n  /**\n   * Perform topological sort to determine execution order\n   * Groups checks that can run in parallel at each level\n   */\n  private static topologicalSort(nodes: Map<string, CheckNode>): ExecutionGroup[] {\n    const remainingNodes = new Map(nodes);\n    const executionGroups: ExecutionGroup[] = [];\n    let level = 0;\n\n    while (remainingNodes.size > 0) {\n      // Find nodes with no remaining dependencies\n      const readyNodes: string[] = [];\n\n      for (const [nodeId, node] of remainingNodes.entries()) {\n        const unmetDependencies = node.dependencies.filter(depId => remainingNodes.has(depId));\n        if (unmetDependencies.length === 0) {\n          readyNodes.push(nodeId);\n        }\n      }\n\n      if (readyNodes.length === 0) {\n        // This shouldn't happen if cycle detection worked correctly\n        throw new Error('Unable to resolve dependencies - possible circular dependency detected');\n      }\n\n      // Add this group to execution order\n      executionGroups.push({\n        parallel: readyNodes,\n        level,\n      });\n\n      // Remove processed nodes\n      for (const nodeId of readyNodes) {\n        remainingNodes.delete(nodeId);\n      }\n\n      level++;\n    }\n\n    return executionGroups;\n  }\n\n  /**\n   * Validate that all dependencies exist\n   */\n  static validateDependencies(\n    checkIds: string[],\n    dependencies: Record<string, string[]>\n  ): { valid: boolean; errors: string[] } {\n    const errors: string[] = [];\n    const checkIdSet = new Set(checkIds);\n\n    for (const [checkId, deps] of Object.entries(dependencies)) {\n      if (!checkIdSet.has(checkId)) {\n        errors.push(`Check \"${checkId}\" is not in the list of available checks`);\n        continue;\n      }\n\n      for (const depId of deps || []) {\n        if (!checkIdSet.has(depId)) {\n          errors.push(`Check \"${checkId}\" depends on \"${depId}\" which is not available`);\n        }\n      }\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n    };\n  }\n\n  /**\n   * Get all transitive dependencies (ancestors) for a given check\n   * This returns all checks that must complete before the given check can run,\n   * not just the direct dependencies.\n   *\n   * For example, if A -> B -> C, then:\n   * - getAllDependencies(C) returns [A, B]\n   * - getAllDependencies(B) returns [A]\n   * - getAllDependencies(A) returns []\n   *\n   * @param checkId The check to find dependencies for\n   * @param nodes The dependency graph nodes\n   * @returns Array of all transitive dependency IDs\n   */\n  static getAllDependencies(checkId: string, nodes: Map<string, CheckNode>): string[] {\n    const allDeps = new Set<string>();\n    const visited = new Set<string>();\n\n    const collectDependencies = (currentId: string) => {\n      if (visited.has(currentId)) {\n        return;\n      }\n      visited.add(currentId);\n\n      const node = nodes.get(currentId);\n      if (!node) {\n        return;\n      }\n\n      // Add direct dependencies and recurse\n      for (const depId of node.dependencies) {\n        allDeps.add(depId);\n        collectDependencies(depId);\n      }\n    };\n\n    collectDependencies(checkId);\n    return Array.from(allDeps);\n  }\n\n  /**\n   * Get execution statistics for debugging\n   */\n  static getExecutionStats(graph: DependencyGraph): {\n    totalChecks: number;\n    parallelLevels: number;\n    maxParallelism: number;\n    averageParallelism: number;\n    checksWithDependencies: number;\n  } {\n    const totalChecks = graph.nodes.size;\n    const parallelLevels = graph.executionOrder.length;\n    const maxParallelism = Math.max(...graph.executionOrder.map(group => group.parallel.length));\n    const averageParallelism = totalChecks / parallelLevels;\n    const checksWithDependencies = Array.from(graph.nodes.values()).filter(\n      node => node.dependencies.length > 0\n    ).length;\n\n    return {\n      totalChecks,\n      parallelLevels,\n      maxParallelism,\n      averageParallelism,\n      checksWithDependencies,\n    };\n  }\n}\n"],"mappings":"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","names":[]}