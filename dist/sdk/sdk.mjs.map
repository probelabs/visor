{"version":3,"sources":["../../src/state-machine/context/build-engine-context.ts","../../src/state-machine/execution/summary.ts","../../src/state-machine-execution-engine.ts","../../src/sdk.ts"],"sourcesContent":["import type { VisorConfig, EventTrigger } from '../../types/config';\nimport type { PRInfo } from '../../pr-analyzer';\nimport type { EngineContext, CheckMetadata } from '../../types/engine';\nimport { ExecutionJournal } from '../../snapshot-store';\nimport { MemoryStore } from '../../memory-store';\nimport { v4 as uuidv4 } from 'uuid';\nimport { logger } from '../../logger';\nimport type { VisorConfig as VCfg, CheckConfig as CfgCheck } from '../../types/config';\n\n/**\n * Apply minimal criticality defaults in-place.\n * This is a no-behavior-change scaffold: we only default missing\n * check.criticality to 'policy' so downstream code can rely on a value.\n * Future mapping (retries/loop budgets) can build on this without\n * changing existing behavior.\n */\nfunction applyCriticalityDefaults(cfg: VCfg): void {\n  const checks = cfg.checks || {};\n  for (const id of Object.keys(checks)) {\n    const c: CfgCheck = (checks as any)[id] as CfgCheck;\n    if (!c.criticality) (c.criticality as any) = 'policy';\n    // For 'info' checks, default continue_on_failure to true if unset.\n    if (c.criticality === 'info' && typeof c.continue_on_failure === 'undefined')\n      c.continue_on_failure = true;\n  }\n}\n\n/**\n * Pure helper to build an EngineContext for a state-machine run.\n * Extracted to reduce StateMachineExecutionEngine size; behavior unchanged.\n */\nexport function buildEngineContextForRun(\n  workingDirectory: string,\n  config: VisorConfig,\n  prInfo: PRInfo,\n  debug?: boolean,\n  maxParallelism?: number,\n  failFast?: boolean,\n  requestedChecks?: string[]\n): EngineContext {\n  // Deep clone provided config to avoid cross-run mutations between tests/runs\n  const clonedConfig: VisorConfig = JSON.parse(JSON.stringify(config));\n\n  // Build check metadata\n  const checks: Record<string, CheckMetadata> = {};\n\n  // Fill in minimal defaults derived from criticality (no behavior change)\n  applyCriticalityDefaults(clonedConfig);\n\n  // If config has checks, use them\n  for (const [checkId, checkConfig] of Object.entries(clonedConfig.checks || {})) {\n    checks[checkId] = {\n      tags: checkConfig.tags || [],\n      triggers: (Array.isArray(checkConfig.on) ? checkConfig.on : [checkConfig.on]).filter(\n        Boolean\n      ) as EventTrigger[],\n      group: checkConfig.group,\n      providerType: checkConfig.type || 'ai',\n      dependencies: checkConfig.depends_on || [],\n    };\n  }\n\n  // Backward compatibility: synthesize minimal check configs for requested checks\n  // that don't exist in the config (e.g., legacy test mode with empty config)\n  if (requestedChecks && requestedChecks.length > 0) {\n    for (const checkName of requestedChecks) {\n      if (!checks[checkName] && !clonedConfig.checks?.[checkName]) {\n        // Synthesize a minimal check config for this legacy check name\n        logger.debug(`[StateMachine] Synthesizing minimal config for legacy check: ${checkName}`);\n\n        // Add to config.checks so providers can find it\n        if (!clonedConfig.checks) {\n          clonedConfig.checks = {};\n        }\n        clonedConfig.checks[checkName] = {\n          type: 'ai',\n          prompt: `Perform ${checkName} analysis`,\n        } as any;\n\n        // Add metadata\n        checks[checkName] = {\n          tags: [],\n          triggers: [],\n          group: 'default',\n          providerType: 'ai',\n          dependencies: [],\n        };\n      }\n    }\n  }\n\n  // Initialize journal and memory\n  const journal = new ExecutionJournal();\n  const memory = MemoryStore.getInstance(clonedConfig.memory);\n\n  return {\n    mode: 'state-machine',\n    config: clonedConfig,\n    checks,\n    journal,\n    memory,\n    workingDirectory,\n    sessionId: uuidv4(),\n    event: prInfo.eventType,\n    debug,\n    maxParallelism,\n    failFast,\n    requestedChecks: requestedChecks && requestedChecks.length > 0 ? requestedChecks : undefined,\n    // Store prInfo for later access (e.g., in getOutputHistorySnapshot)\n    prInfo,\n  };\n}\n","import type { ReviewIssue, GroupedCheckResults, ReviewSummary } from '../../reviewer';\nimport type { ExecutionStatistics } from '../../types/execution';\n\n/**\n * Pure helper to convert grouped results + statistics into a flat ReviewSummary.\n * Extracted to reduce StateMachineExecutionEngine size; behavior unchanged.\n */\nexport function convertToReviewSummary(\n  groupedResults: GroupedCheckResults,\n  statistics?: ExecutionStatistics\n): ReviewSummary {\n  const allIssues: ReviewIssue[] = [];\n\n  // Aggregate issues from all check results\n  for (const checkResults of Object.values(groupedResults)) {\n    for (const checkResult of checkResults) {\n      if (checkResult.issues && checkResult.issues.length > 0) {\n        allIssues.push(...checkResult.issues);\n      }\n    }\n  }\n\n  // Convert errors from execution statistics into issues\n  if (statistics) {\n    for (const checkStats of statistics.checks) {\n      if (checkStats.errorMessage) {\n        allIssues.push({\n          file: 'system',\n          line: 0,\n          endLine: undefined,\n          ruleId: 'system/error',\n          message: checkStats.errorMessage,\n          severity: 'error',\n          category: 'logic',\n          suggestion: undefined,\n          replacement: undefined,\n        });\n      }\n    }\n  }\n\n  return {\n    issues: allIssues,\n  };\n}\n","import type { CheckExecutionOptions, ExecutionResult } from './types/execution';\nimport { AnalysisResult } from './output-formatters';\nimport type { VisorConfig } from './types/config';\nimport type { PRInfo } from './pr-analyzer';\nimport { StateMachineRunner } from './state-machine/runner';\nimport type { EngineContext } from './types/engine';\nimport { ExecutionJournal } from './snapshot-store';\nimport { logger } from './logger';\nimport type { DebugVisualizerServer } from './debug-visualizer/ws-server';\nimport * as path from 'path';\nimport * as fs from 'fs';\n\n/**\n * State machine-based execution engine\n *\n * Production-ready state machine implementation with full observability support.\n * M4: Includes OTEL telemetry and debug visualizer event streaming.\n */\nexport class StateMachineExecutionEngine {\n  private workingDirectory: string;\n  private executionContext?: import('./providers/check-provider.interface').ExecutionContext;\n  private debugServer?: DebugVisualizerServer;\n  private _lastContext?: EngineContext;\n  private _lastRunner?: StateMachineRunner;\n\n  constructor(\n    workingDirectory?: string,\n    octokit?: import('@octokit/rest').Octokit,\n    debugServer?: DebugVisualizerServer\n  ) {\n    this.workingDirectory = workingDirectory || process.cwd();\n    this.debugServer = debugServer;\n  }\n\n  /**\n   * Execute checks using the state machine engine\n   *\n   * Converts CheckExecutionOptions -> executeGroupedChecks() -> AnalysisResult\n   */\n  async executeChecks(options: CheckExecutionOptions): Promise<AnalysisResult> {\n    const startTime = Date.now();\n    const timestamp = new Date().toISOString();\n\n    try {\n      // Initialize memory store if configured\n      if (options.config?.memory) {\n        const { MemoryStore } = await import('./memory-store');\n        const memoryStore = MemoryStore.getInstance(options.config.memory);\n        await memoryStore.initialize();\n        logger.debug('Memory store initialized');\n      }\n\n      // Analyze the repository\n      const { GitRepositoryAnalyzer } = await import('./git-repository-analyzer');\n      const gitAnalyzer = new GitRepositoryAnalyzer(options.workingDirectory);\n      logger.info('Analyzing local git repository...');\n      const repositoryInfo = await gitAnalyzer.analyzeRepository();\n\n      if (!repositoryInfo.isGitRepository) {\n        return this.createErrorResult(\n          repositoryInfo,\n          'Not a git repository or no changes found',\n          startTime,\n          timestamp,\n          options.checks\n        );\n      }\n\n      // Convert to PRInfo format for compatibility\n      const prInfo = gitAnalyzer.toPRInfo(repositoryInfo);\n\n      // Propagate event type if provided\n      try {\n        const evt = (options.webhookContext as any)?.eventType;\n        if (evt) (prInfo as any).eventType = evt;\n      } catch {}\n\n      // Apply tag filtering if specified\n      const filteredChecks = this.filterChecksByTags(\n        options.checks,\n        options.config,\n        options.tagFilter || options.config?.tag_filter\n      );\n\n      if (filteredChecks.length === 0) {\n        logger.warn('No checks match the tag filter criteria');\n        return this.createErrorResult(\n          repositoryInfo,\n          'No checks match the tag filter criteria',\n          startTime,\n          timestamp,\n          options.checks\n        );\n      }\n\n      // If a webhook context is provided (from WebhookServer or Slack socket),\n      // attach it to the http_input provider so http_input checks can read data.\n      try {\n        const map = (options as any)?.webhookContext?.webhookData as\n          | Map<string, unknown>\n          | undefined;\n        if (map) {\n          const { CheckProviderRegistry } = await import('./providers/check-provider-registry');\n          const reg = CheckProviderRegistry.getInstance();\n          const p: any = reg.getProvider('http_input');\n          if (p && typeof p.setWebhookContext === 'function') p.setWebhookContext(map);\n          const prev: any = this.executionContext || {};\n          this.setExecutionContext({ ...prev, webhookContext: { webhookData: map } } as any);\n        }\n      } catch {}\n\n      // Execute checks using state machine\n      logger.info(`Executing checks: ${filteredChecks.join(', ')}`);\n      const executionResult = await this.executeGroupedChecks(\n        prInfo,\n        filteredChecks,\n        options.timeout,\n        options.config,\n        options.outputFormat,\n        options.debug,\n        options.maxParallelism,\n        options.failFast,\n        options.tagFilter\n      );\n\n      // Convert ExecutionResult to AnalysisResult format\n      const executionTime = Date.now() - startTime;\n\n      // Extract review summary from grouped results\n      const reviewSummary = this.convertGroupedResultsToReviewSummary(\n        executionResult.results,\n        executionResult.statistics\n      );\n\n      // Collect debug information when debug mode is enabled\n      let debugInfo: import('./output-formatters').DebugInfo | undefined;\n      if (options.debug && reviewSummary.debug) {\n        debugInfo = {\n          provider: reviewSummary.debug.provider,\n          model: reviewSummary.debug.model,\n          processingTime: reviewSummary.debug.processingTime,\n          parallelExecution: options.checks.length > 1,\n          checksExecuted: options.checks,\n          totalApiCalls: reviewSummary.debug.totalApiCalls || options.checks.length,\n          apiCallDetails: reviewSummary.debug.apiCallDetails,\n        };\n      }\n\n      // Expose output history snapshot\n      try {\n        const histSnap = this.getOutputHistorySnapshot();\n        (reviewSummary as any).history = histSnap;\n      } catch {}\n\n      return {\n        repositoryInfo,\n        reviewSummary,\n        executionTime,\n        timestamp,\n        checksExecuted: filteredChecks,\n        executionStatistics: executionResult.statistics,\n        debug: debugInfo,\n      };\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Unknown error occurred';\n      logger.error('Error executing checks: ' + message);\n\n      // In strict test modes, surface errors to callers\n      const strictEnv = process.env.VISOR_STRICT_ERRORS === 'true';\n      if (strictEnv) {\n        throw error;\n      }\n\n      const fallbackRepositoryInfo: import('./git-repository-analyzer').GitRepositoryInfo = {\n        title: 'Error during analysis',\n        body: `Error: ${message || 'Unknown error'}`,\n        author: 'system',\n        base: 'main',\n        head: 'HEAD',\n        files: [],\n        totalAdditions: 0,\n        totalDeletions: 0,\n        isGitRepository: false,\n        workingDirectory: options.workingDirectory || process.cwd(),\n      };\n\n      return this.createErrorResult(\n        fallbackRepositoryInfo,\n        message || 'Unknown error occurred',\n        startTime,\n        timestamp,\n        options.checks\n      );\n    }\n  }\n\n  /**\n   * Get execution context (used by state machine to propagate hooks)\n   */\n  protected getExecutionContext():\n    | import('./providers/check-provider.interface').ExecutionContext\n    | undefined {\n    return this.executionContext;\n  }\n\n  /**\n   * Set execution context for external callers\n   */\n  public setExecutionContext(\n    context: import('./providers/check-provider.interface').ExecutionContext | undefined\n  ): void {\n    this.executionContext = context;\n  }\n\n  /**\n   * Reset per-run state (no-op for state machine engine)\n   *\n   * The state machine engine is stateless per-run by design.\n   * Each execution creates a fresh journal and context.\n   * This method exists only for backward compatibility with test framework.\n   *\n   * @deprecated This is a no-op. State machine engine doesn't maintain per-run state.\n   */\n  public resetPerRunState(): void {\n    // No-op: State machine engine is stateless per-run\n    // Each execution creates a fresh journal and context\n  }\n\n  /**\n   * Execute grouped checks using the state machine engine\n   *\n   * M4: Production-ready with full telemetry and debug server support\n   */\n  async executeGroupedChecks(\n    prInfo: PRInfo,\n    checks: string[],\n    timeout?: number,\n    config?: VisorConfig,\n    outputFormat?: string,\n    debug?: boolean,\n    maxParallelism?: number,\n    failFast?: boolean,\n    tagFilter?: import('./types/config').TagFilter,\n    _pauseGate?: () => Promise<void>\n  ): Promise<ExecutionResult> {\n    if (debug) {\n      logger.info('[StateMachine] Using state machine engine');\n    }\n\n    // Create minimal default config if none provided (backward compatibility)\n    if (!config) {\n      const { ConfigManager } = await import('./config');\n      const configManager = new ConfigManager();\n      config = await configManager.getDefaultConfig();\n      logger.debug('[StateMachine] Using default configuration (no config provided)');\n    }\n\n    // Merge tagFilter into config if provided (test runner passes it separately)\n    const configWithTagFilter = tagFilter\n      ? {\n          ...config,\n          tag_filter: tagFilter,\n        }\n      : config;\n\n    // Build engine context\n    const context = this.buildEngineContext(\n      configWithTagFilter,\n      prInfo,\n      debug,\n      maxParallelism,\n      failFast,\n      checks // Pass the explicit checks list\n    );\n\n    // Copy execution context (hooks, etc.) from legacy engine\n    context.executionContext = this.getExecutionContext();\n\n    // Store context for later access (e.g., getOutputHistorySnapshot)\n    this._lastContext = context;\n\n    // Optionally enable event-driven frontends if configured\n    let frontendsHost: any | undefined;\n    if (\n      Array.isArray((configWithTagFilter as any).frontends) &&\n      (configWithTagFilter as any).frontends.length > 0\n    ) {\n      try {\n        const { EventBus } = await import('./event-bus/event-bus');\n        const { FrontendsHost } = await import('./frontends/host');\n        const bus = new EventBus();\n        (context as any).eventBus = bus;\n        frontendsHost = new FrontendsHost(bus, logger);\n        if (process.env.VISOR_DEBUG === 'true') {\n          try {\n            const fns = ((configWithTagFilter as any).frontends || []).map((f: any) => ({\n              name: f?.name,\n              hasConfig: !!f?.config,\n              cfg: f?.config || undefined,\n            }));\n            logger.info(`[Frontends] Loading specs: ${JSON.stringify(fns)}`);\n          } catch {}\n        }\n        await frontendsHost.load((configWithTagFilter as any).frontends);\n        // Derive repo/pr/headSha and octokit if available\n        let owner: string | undefined;\n        let name: string | undefined;\n        let prNum: number | undefined;\n        let headSha: string | undefined;\n        try {\n          const anyInfo: any = prInfo as any;\n          owner =\n            anyInfo?.eventContext?.repository?.owner?.login ||\n            process.env.GITHUB_REPOSITORY?.split('/')?.[0];\n          name =\n            anyInfo?.eventContext?.repository?.name ||\n            process.env.GITHUB_REPOSITORY?.split('/')?.[1];\n          prNum = typeof anyInfo?.number === 'number' ? anyInfo.number : undefined;\n          headSha = anyInfo?.eventContext?.pull_request?.head?.sha || process.env.GITHUB_SHA;\n        } catch {}\n        const repoObj = owner && name ? { owner, name } : undefined;\n        const octokit = (this.executionContext as any)?.octokit;\n        // Fallback: if headSha is missing but we have PR info and octokit, fetch it\n        if (\n          !headSha &&\n          repoObj &&\n          prNum &&\n          octokit &&\n          typeof octokit.rest?.pulls?.get === 'function'\n        ) {\n          try {\n            const { data } = await octokit.rest.pulls.get({\n              owner: repoObj.owner,\n              repo: repoObj.name,\n              pull_number: prNum,\n            });\n            headSha = (data && (data as any).head && (data as any).head.sha) || headSha;\n          } catch {\n            // ignore; headSha remains undefined\n          }\n        }\n        // Make the event bus available to providers via executionContext\n        try {\n          const prev: any = this.getExecutionContext() || {};\n          this.setExecutionContext({ ...prev, eventBus: bus });\n          // Also reflect it into the active engine context so downstream providers see it\n          try {\n            (context as any).executionContext = this.getExecutionContext();\n          } catch {}\n        } catch {}\n\n        await frontendsHost.startAll(() => ({\n          eventBus: bus,\n          logger,\n          // Provide the active (possibly tag-filtered) config so frontends can read groups, etc.\n          config: configWithTagFilter,\n          run: {\n            runId: (context as any).sessionId,\n            repo: repoObj,\n            pr: prNum,\n            headSha,\n            event: (context as any).event || (prInfo as any)?.eventType,\n            actor:\n              (prInfo as any)?.eventContext?.sender?.login ||\n              (typeof process.env.GITHUB_ACTOR === 'string' ? process.env.GITHUB_ACTOR : undefined),\n          },\n          octokit,\n          webhookContext: (this.executionContext as any)?.webhookContext,\n          // Surface any injected test doubles for Slack as well\n          slack:\n            (this.executionContext as any)?.slack || (this.executionContext as any)?.slackClient,\n        }));\n\n        // Phase 1: Snapshot on HumanInputRequested (experimental pause support)\n        try {\n          bus.on('HumanInputRequested', async (envelope: any) => {\n            try {\n              const ev = (envelope && envelope.payload) || envelope;\n              // Determine channel/thread from event or inbound payload\n              let channel: string | undefined = ev?.channel;\n              let threadTs: string | undefined = ev?.threadTs;\n              if (!channel || !threadTs) {\n                try {\n                  const anyCfg: any = configWithTagFilter || {};\n                  const slackCfg: any = anyCfg.slack || {};\n                  const endpoint: string = slackCfg.endpoint || '/bots/slack/support';\n                  const map = (this.executionContext as any)?.webhookContext?.webhookData as\n                    | Map<string, unknown>\n                    | undefined;\n                  const payload: any = map?.get(endpoint);\n                  const e: any = payload?.event;\n                  const derivedTs = String(e?.thread_ts || e?.ts || e?.event_ts || '');\n                  const derivedCh = String(e?.channel || '');\n                  if (derivedCh && derivedTs) {\n                    channel = channel || derivedCh;\n                    threadTs = threadTs || derivedTs;\n                  }\n                } catch {}\n              }\n\n              const checkId = String(ev?.checkId || 'unknown');\n              const threadKey =\n                ev?.threadKey || (channel && threadTs ? `${channel}:${threadTs}` : 'session');\n              const baseDir =\n                process.env.VISOR_SNAPSHOT_DIR ||\n                path.resolve(process.cwd(), '.visor', 'snapshots');\n              fs.mkdirSync(baseDir, { recursive: true });\n              const filePath = path.join(baseDir, `${threadKey}-${checkId}.json`);\n              await this.saveSnapshotToFile(filePath);\n              logger.info(`[Snapshot] Saved run snapshot: ${filePath}`);\n              try {\n                await bus.emit({\n                  type: 'SnapshotSaved',\n                  checkId: ev?.checkId || 'unknown',\n                  channel,\n                  threadTs,\n                  threadKey,\n                  filePath,\n                });\n              } catch {}\n            } catch (e) {\n              logger.warn(\n                `[Snapshot] Failed to save snapshot on HumanInputRequested: ${\n                  e instanceof Error ? e.message : String(e)\n                }`\n              );\n            }\n          });\n        } catch {}\n      } catch (err) {\n        logger.warn(\n          `[Frontends] Failed to initialize frontends: ${err instanceof Error ? err.message : String(err)}`\n        );\n      }\n    }\n\n    // Create and run state machine with debug server support (M4)\n    const runner = new StateMachineRunner(context, this.debugServer);\n    this._lastRunner = runner;\n    const result = await runner.run();\n\n    // Stop frontends if started\n    if (frontendsHost && typeof frontendsHost.stopAll === 'function') {\n      try {\n        await frontendsHost.stopAll();\n      } catch {}\n    }\n\n    if (debug) {\n      logger.info('[StateMachine] Execution complete');\n    }\n\n    // Post-grouped comments via legacy reviewer is removed; GitHub frontend handles comments\n\n    // Cleanup AI sessions after execution\n    try {\n      const { SessionRegistry } = await import('./session-registry');\n      const sessionRegistry = SessionRegistry.getInstance();\n      sessionRegistry.clearAllSessions();\n    } catch (error) {\n      logger.debug(`[StateMachine] Failed to cleanup sessions: ${error}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Build the engine context for state machine execution\n   */\n  private buildEngineContext(\n    config: VisorConfig,\n    prInfo: PRInfo,\n    debug?: boolean,\n    maxParallelism?: number,\n    failFast?: boolean,\n    requestedChecks?: string[]\n  ): EngineContext {\n    const { buildEngineContextForRun } = require('./state-machine/context/build-engine-context');\n    return buildEngineContextForRun(\n      this.workingDirectory,\n      config,\n      prInfo,\n      debug,\n      maxParallelism,\n      failFast,\n      requestedChecks\n    );\n  }\n\n  /**\n   * Get output history snapshot for test framework compatibility\n   * Extracts output history from the journal\n   */\n  public getOutputHistorySnapshot(): Record<string, unknown[]> {\n    // Get the journal from the last execution context\n    const journal = (this as any)._lastContext?.journal as ExecutionJournal | undefined;\n    if (!journal) {\n      logger.debug('[StateMachine][DEBUG] getOutputHistorySnapshot: No journal found');\n      return {};\n    }\n\n    const sessionId = (this as any)._lastContext?.sessionId as string | undefined;\n    if (!sessionId) {\n      logger.debug('[StateMachine][DEBUG] getOutputHistorySnapshot: No sessionId found');\n      return {};\n    }\n\n    // Read all journal entries for this session\n    const snapshot = journal.beginSnapshot();\n    const allEntries = journal.readVisible(sessionId, snapshot, undefined);\n\n    logger.debug(\n      `[StateMachine][DEBUG] getOutputHistorySnapshot: Found ${allEntries.length} journal entries`\n    );\n\n    // Group by checkId and extract outputs\n    const outputHistory: Record<string, unknown[]> = {};\n    for (const entry of allEntries) {\n      const checkId = entry.checkId;\n\n      if (!outputHistory[checkId]) {\n        outputHistory[checkId] = [];\n      }\n      // Skip journal stubs for skipped checks\n      try {\n        if (entry && typeof entry.result === 'object' && (entry.result as any).__skipped) {\n          continue;\n        }\n      } catch {}\n\n      // Prefer explicit .output; fall back to the full result (issues/content)\n      // so tests and templates can reference paths like issues[0].severity for\n      // code-review schema steps which do not set a separate output object.\n      const payload =\n        entry.result.output !== undefined ? entry.result.output : (entry.result as unknown);\n\n      // Filter out forEach aggregation metadata objects (which contain a\n      // forEachItems array) to avoid double-counting per-item executions in\n      // tests. The actual per-item outputs are committed as separate entries\n      // and should be used for history-based assertions and routing.\n      try {\n        if (\n          payload &&\n          typeof payload === 'object' &&\n          (payload as any).forEachItems &&\n          Array.isArray((payload as any).forEachItems)\n        ) {\n          continue;\n        }\n      } catch {}\n\n      if (payload !== undefined) outputHistory[checkId].push(payload);\n    }\n\n    logger.debug(\n      `[StateMachine][DEBUG] getOutputHistorySnapshot result: ${JSON.stringify(Object.keys(outputHistory))}`\n    );\n    for (const [checkId, outputs] of Object.entries(outputHistory)) {\n      logger.debug(`[StateMachine][DEBUG]   ${checkId}: ${outputs.length} outputs`);\n    }\n\n    return outputHistory;\n  }\n\n  /**\n   * Save a JSON snapshot of the last run's state and journal to a file (experimental).\n   * Does not include secrets. Intended for debugging and future resume support.\n   */\n  public async saveSnapshotToFile(filePath: string): Promise<void> {\n    const fs = await import('fs/promises');\n    const ctx = this._lastContext;\n    const runner = this._lastRunner;\n    if (!ctx || !runner) {\n      throw new Error('No prior execution context to snapshot');\n    }\n    const journal = (ctx as any).journal as ExecutionJournal;\n    const snapshotId = journal.beginSnapshot();\n    const entries = journal.readVisible(ctx.sessionId, snapshotId, undefined);\n    const state = runner.getState();\n    const serializableState = serializeRunState(state);\n    const payload = {\n      version: 1,\n      sessionId: ctx.sessionId,\n      event: ctx.event,\n      wave: state.wave,\n      state: serializableState,\n      journal: entries,\n      requestedChecks: (ctx as any).requestedChecks || [],\n    } as const;\n    await fs.writeFile(filePath, JSON.stringify(payload, null, 2), 'utf8');\n  }\n\n  /**\n   * Load a snapshot JSON from file and return it. Resume support can build on this.\n   */\n  public async loadSnapshotFromFile<T = unknown>(filePath: string): Promise<T> {\n    const fs = await import('fs/promises');\n    const raw = await fs.readFile(filePath, 'utf8');\n    return JSON.parse(raw) as T;\n  }\n\n  /**\n   * Filter checks by tag filter\n   */\n  private filterChecksByTags(\n    checks: string[],\n    config: VisorConfig | undefined,\n    tagFilter: import('./types/config').TagFilter | undefined\n  ): string[] {\n    // When no tag filter is specified, include only untagged checks by default.\n    // Tagged checks are opt-in unless tag_filter is provided.\n    return checks.filter(checkName => {\n      const checkConfig = config?.checks?.[checkName];\n      if (!checkConfig) {\n        // If no config for this check, include it by default\n        return true;\n      }\n\n      const checkTags = checkConfig.tags || [];\n\n      // If no tag filter is specified, include only untagged checks.\n      if (!tagFilter || (!tagFilter.include && !tagFilter.exclude)) {\n        return checkTags.length === 0;\n      }\n\n      // If check has no tags and a tag filter is specified, include it (untagged checks always run)\n      if (checkTags.length === 0) {\n        return true;\n      }\n\n      // Check exclude tags first (if any exclude tag matches, skip the check)\n      if (tagFilter.exclude && tagFilter.exclude.length > 0) {\n        const hasExcludedTag = tagFilter.exclude.some(tag => checkTags.includes(tag));\n        if (hasExcludedTag) return false;\n      }\n\n      // Check include tags (if specified, at least one must match)\n      if (tagFilter.include && tagFilter.include.length > 0) {\n        const hasIncludedTag = tagFilter.include.some(tag => checkTags.includes(tag));\n        if (!hasIncludedTag) return false;\n      }\n\n      return true;\n    });\n  }\n\n  /**\n   * Create an error result in AnalysisResult format\n   */\n  private createErrorResult(\n    repositoryInfo: import('./git-repository-analyzer').GitRepositoryInfo,\n    errorMessage: string,\n    startTime: number,\n    timestamp: string,\n    checksExecuted: string[]\n  ): AnalysisResult {\n    const executionTime = Date.now() - startTime;\n\n    return {\n      repositoryInfo,\n      reviewSummary: {\n        issues: [\n          {\n            file: 'system',\n            line: 0,\n            endLine: undefined,\n            ruleId: 'system/error',\n            message: errorMessage,\n            severity: 'error',\n            category: 'logic',\n            suggestion: undefined,\n            replacement: undefined,\n          },\n        ],\n      },\n      executionTime,\n      timestamp,\n      checksExecuted,\n    };\n  }\n\n  /**\n   * Convert GroupedCheckResults to ReviewSummary\n   * Aggregates all check results into a single ReviewSummary\n   */\n  private convertGroupedResultsToReviewSummary(\n    groupedResults: import('./reviewer').GroupedCheckResults,\n    statistics?: import('./types/execution').ExecutionStatistics\n  ): import('./reviewer').ReviewSummary {\n    const { convertToReviewSummary } = require('./state-machine/execution/summary');\n    return (convertToReviewSummary as any)(groupedResults as any, statistics as any) as any;\n  }\n\n  /**\n   * Evaluate failure conditions for a check result\n   *\n   * This method provides backward compatibility with the legacy engine by\n   * delegating to the FailureConditionEvaluator.\n   *\n   * @param checkName - The name of the check being evaluated\n   * @param reviewSummary - The review summary containing check results\n   * @param config - The Visor configuration containing failure conditions\n   * @param previousOutputs - Optional previous check outputs for cross-check conditions\n   * @param authorAssociation - Optional GitHub author association for permission checks\n   * @returns Array of failure condition evaluation results\n   */\n  async evaluateFailureConditions(\n    checkName: string,\n    reviewSummary: import('./reviewer').ReviewSummary,\n    config: VisorConfig,\n    previousOutputs?: Record<string, import('./reviewer').ReviewSummary>,\n    authorAssociation?: string\n  ): Promise<import('./types/config').FailureConditionResult[]> {\n    const { FailureConditionEvaluator } = await import('./failure-condition-evaluator');\n    const evaluator = new FailureConditionEvaluator();\n    const { addEvent } = await import('./telemetry/trace-helpers');\n    const { addFailIfTriggered } = await import('./telemetry/metrics');\n\n    // Extract check configuration\n    const checkConfig = config.checks?.[checkName];\n    if (!checkConfig) {\n      return [];\n    }\n\n    // Schema can be string or Record<string, unknown>, convert to string for evaluation\n    const rawSchema = checkConfig.schema || 'code-review';\n    const checkSchema = typeof rawSchema === 'string' ? rawSchema : 'code-review';\n    const checkGroup = checkConfig.group || 'default';\n\n    // Handle both fail_if (simple string) and failure_conditions (complex object)\n    const results: import('./types/config').FailureConditionResult[] = [];\n\n    // Evaluate global fail_if\n    if (config.fail_if) {\n      const failed = await evaluator.evaluateSimpleCondition(\n        checkName,\n        checkSchema,\n        checkGroup,\n        reviewSummary,\n        config.fail_if,\n        previousOutputs || {}\n      );\n\n      // Telemetry events + metric\n      try {\n        addEvent('fail_if.evaluated', {\n          'visor.check.id': checkName,\n          scope: 'global',\n          expression: String(config.fail_if),\n          result: failed ? 'triggered' : 'not_triggered',\n        });\n        if (failed) {\n          addEvent('fail_if.triggered', {\n            'visor.check.id': checkName,\n            scope: 'global',\n            expression: String(config.fail_if),\n          });\n          addFailIfTriggered(checkName, 'global');\n        }\n      } catch {}\n\n      results.push({\n        conditionName: 'global_fail_if',\n        failed,\n        expression: config.fail_if,\n        message: failed ? `Global failure condition met: ${config.fail_if}` : undefined,\n        severity: 'error',\n        haltExecution: false,\n      });\n    }\n\n    // Evaluate check-specific fail_if (overrides global if present)\n    if (checkConfig.fail_if) {\n      const failed = await evaluator.evaluateSimpleCondition(\n        checkName,\n        checkSchema,\n        checkGroup,\n        reviewSummary,\n        checkConfig.fail_if,\n        previousOutputs || {}\n      );\n\n      // Telemetry events + metric\n      try {\n        addEvent('fail_if.evaluated', {\n          'visor.check.id': checkName,\n          scope: 'check',\n          expression: String(checkConfig.fail_if),\n          result: failed ? 'triggered' : 'not_triggered',\n        });\n        if (failed) {\n          addEvent('fail_if.triggered', {\n            'visor.check.id': checkName,\n            scope: 'check',\n            expression: String(checkConfig.fail_if),\n          });\n          addFailIfTriggered(checkName, 'check');\n        }\n      } catch {}\n\n      results.push({\n        conditionName: `${checkName}_fail_if`,\n        failed,\n        expression: checkConfig.fail_if,\n        message: failed ? `Check failure condition met: ${checkConfig.fail_if}` : undefined,\n        severity: 'error',\n        haltExecution: false,\n      });\n    }\n\n    // Also evaluate legacy failure_conditions if present\n    const globalConditions = config.failure_conditions;\n    const checkConditions = checkConfig.failure_conditions;\n\n    if (globalConditions || checkConditions) {\n      const legacyResults = await evaluator.evaluateConditions(\n        checkName,\n        checkSchema,\n        checkGroup,\n        reviewSummary,\n        globalConditions,\n        checkConditions,\n        previousOutputs,\n        authorAssociation\n      );\n      results.push(...legacyResults);\n    }\n\n    return results;\n  }\n\n  /**\n   * Get repository status\n   * @returns Repository status information\n   */\n  async getRepositoryStatus(): Promise<{\n    isGitRepository: boolean;\n    branch?: string;\n    hasChanges: boolean;\n    filesChanged?: number;\n  }> {\n    try {\n      const { GitRepositoryAnalyzer } = await import('./git-repository-analyzer');\n      const analyzer = new GitRepositoryAnalyzer(this.workingDirectory);\n      const info = await analyzer.analyzeRepository();\n\n      return {\n        isGitRepository: info.isGitRepository,\n        branch: info.head, // Use head as branch name\n        hasChanges: info.isGitRepository && (info.files?.length > 0 || false),\n        filesChanged: info.isGitRepository ? info.files?.length || 0 : 0,\n      };\n    } catch {\n      return {\n        isGitRepository: false,\n        hasChanges: false,\n      };\n    }\n  }\n\n  /**\n   * Check if current directory is a git repository\n   * @returns True if git repository, false otherwise\n   */\n  async isGitRepository(): Promise<boolean> {\n    const status = await this.getRepositoryStatus();\n    return status.isGitRepository;\n  }\n\n  /**\n   * Get list of available check types\n   * @returns Array of check type names\n   */\n  static getAvailableCheckTypes(): string[] {\n    const { CheckProviderRegistry } = require('./providers/check-provider-registry');\n    const registry = CheckProviderRegistry.getInstance();\n    return registry.getAvailableProviders();\n  }\n\n  /**\n   * Validate check types and return valid/invalid lists\n   * @param checks - Array of check type names to validate\n   * @returns Object with valid and invalid check types\n   */\n  static validateCheckTypes(checks: string[]): { valid: string[]; invalid: string[] } {\n    const availableTypes = StateMachineExecutionEngine.getAvailableCheckTypes();\n    const valid: string[] = [];\n    const invalid: string[] = [];\n\n    for (const check of checks) {\n      if (availableTypes.includes(check)) {\n        valid.push(check);\n      } else {\n        invalid.push(check);\n      }\n    }\n\n    return { valid, invalid };\n  }\n\n  /**\n   * Format the status column for execution statistics\n   * Used by execution-statistics-formatting tests\n   */\n  private formatStatusColumn(stats: import('./types/execution').CheckExecutionStats): string {\n    if (stats.skipped) {\n      // Format skip reason\n      if (stats.skipReason === 'if_condition') {\n        return 'â­ if';\n      } else if (stats.skipReason === 'fail_fast') {\n        return 'â­ ff';\n      } else if (stats.skipReason === 'dependency_failed') {\n        return 'â­ dep';\n      }\n      return 'â­';\n    }\n\n    const totalRuns = stats.totalRuns;\n    const successfulRuns = stats.successfulRuns;\n    const failedRuns = stats.failedRuns;\n\n    if (failedRuns > 0 && successfulRuns > 0) {\n      // Mixed results\n      return `âœ”/âœ– ${successfulRuns}/${totalRuns}`;\n    } else if (failedRuns > 0) {\n      // All failed\n      return totalRuns === 1 ? 'âœ–' : `âœ– Ã—${totalRuns}`;\n    } else {\n      // All successful\n      return totalRuns === 1 ? 'âœ”' : `âœ” Ã—${totalRuns}`;\n    }\n  }\n\n  /**\n   * Format the details column for execution statistics\n   * Used by execution-statistics-formatting tests\n   */\n  private formatDetailsColumn(stats: import('./types/execution').CheckExecutionStats): string {\n    const parts: string[] = [];\n\n    // Add outputs produced\n    if (stats.outputsProduced !== undefined && stats.outputsProduced > 0) {\n      parts.push(`â†’${stats.outputsProduced}`);\n    }\n\n    // Add critical issues\n    if (stats.issuesBySeverity.critical > 0) {\n      parts.push(`${stats.issuesBySeverity.critical}ðŸ”´`);\n    }\n\n    // Add error issues (only if no critical)\n    if (stats.issuesBySeverity.error > 0 && stats.issuesBySeverity.critical === 0) {\n      parts.push(`${stats.issuesBySeverity.error}âŒ`);\n    }\n\n    // Add warnings\n    if (stats.issuesBySeverity.warning > 0) {\n      parts.push(`${stats.issuesBySeverity.warning}âš ï¸`);\n    }\n\n    // Add info issues (only if no critical/error/warning)\n    if (\n      stats.issuesBySeverity.info > 0 &&\n      stats.issuesBySeverity.critical === 0 &&\n      stats.issuesBySeverity.error === 0 &&\n      stats.issuesBySeverity.warning === 0\n    ) {\n      parts.push(`${stats.issuesBySeverity.info}ðŸ’¡`);\n    }\n\n    // Add error message if present\n    if (stats.errorMessage) {\n      parts.push(this.truncate(stats.errorMessage, 40));\n    }\n\n    // Add skip condition if present\n    if (stats.skipCondition) {\n      parts.push(this.truncate(stats.skipCondition, 40));\n    }\n\n    return parts.join(' ');\n  }\n\n  /**\n   * Truncate a string to a maximum length\n   * Used by formatDetailsColumn\n   */\n  private truncate(str: string, maxLength: number): string {\n    if (str.length <= maxLength) {\n      return str;\n    }\n    return str.substring(0, maxLength - 3) + '...';\n  }\n}\n\n/** Convert RunState with Maps/Sets into a JSON-safe form */\nfunction serializeRunState(state: import('./types/engine').RunState) {\n  return {\n    ...state,\n    levelQueue: state.levelQueue,\n    eventQueue: state.eventQueue,\n    activeDispatches: Array.from(state.activeDispatches.entries()),\n    completedChecks: Array.from(state.completedChecks.values()),\n    stats: Array.from(state.stats.entries()),\n    historyLog: state.historyLog,\n    forwardRunGuards: Array.from(state.forwardRunGuards.values()),\n    currentLevelChecks: Array.from(state.currentLevelChecks.values()),\n    currentWaveCompletions: Array.from(\n      ((state as any).currentWaveCompletions as Set<string> | undefined) || []\n    ),\n    // failedChecks is an internal Set added by stats/dispatch layers; keep it if present\n    failedChecks: Array.from(((state as any).failedChecks as Set<string> | undefined) || []),\n    pendingRunScopes: Array.from((state.pendingRunScopes || new Map()).entries()).map(([k, v]) => [\n      k,\n      v,\n    ]),\n  };\n}\n\nexport type SnapshotJson = {\n  version: number;\n  sessionId: string;\n  event?: import('./types/config').EventTrigger;\n  wave?: number;\n  state: any;\n  journal: import('./snapshot-store').JournalEntry[];\n  requestedChecks?: string[];\n  meta?: Record<string, unknown>;\n};\n\n/**\n * Resume execution from a previously saved snapshot (experimental).\n * Frontends are started to mirror executeGroupedChecks behavior so integrations\n * like Slack can handle CheckCompleted/HumanInputRequested events during resume.\n */\nexport async function resumeFromSnapshot(\n  engine: StateMachineExecutionEngine,\n  snapshot: SnapshotJson,\n  config: VisorConfig,\n  opts?: { debug?: boolean; maxParallelism?: number; failFast?: boolean; webhookContext?: any }\n): Promise<import('./types/execution').ExecutionResult> {\n  // Recompute PRInfo from the current repository\n  const { GitRepositoryAnalyzer } = await import('./git-repository-analyzer');\n  const analyzer = new GitRepositoryAnalyzer(process.cwd());\n  const repoInfo = await analyzer.analyzeRepository();\n  const prInfo = analyzer.toPRInfo(repoInfo);\n\n  const context = (engine as any).buildEngineContext(\n    config,\n    prInfo,\n    opts?.debug,\n    opts?.maxParallelism,\n    opts?.failFast,\n    snapshot.requestedChecks\n  ) as import('./types/engine').EngineContext;\n\n  // Propagate existing executionContext (hooks, octokit, webhookContext, slack, etc.)\n  try {\n    const prevExecCtx: any = (engine as any).getExecutionContext?.() || {};\n    (context as any).executionContext = prevExecCtx;\n  } catch {}\n\n  // Restore journal entries\n  try {\n    const journal = (context as any).journal as ExecutionJournal;\n    for (const e of snapshot.journal || []) {\n      journal.commitEntry({\n        // Re-hydrate all entries under the NEW sessionId for this resume run.\n        // This ensures helpers like output history and chat_history see both\n        // pre-snapshot and post-resume outputs as a single logical session.\n        sessionId: (context as any).sessionId,\n        scope: e.scope,\n        checkId: e.checkId,\n        result: e.result,\n        event: e.event,\n      });\n    }\n  } catch {}\n\n  // Adopt webhookContext and other execution context patches if provided\n  try {\n    const prev: any = (engine as any).getExecutionContext?.() || {};\n    (engine as any).setExecutionContext?.({ ...prev, webhookContext: opts?.webhookContext });\n    // Reflect merged executionContext into active engine context\n    try {\n      (context as any).executionContext = (engine as any).getExecutionContext?.();\n    } catch {}\n  } catch {}\n\n  // Optional frontends (Slack, GitHub, etc.) â€“ mirror executeGroupedChecks\n  let frontendsHost: any | undefined;\n  if (Array.isArray((config as any).frontends) && (config as any).frontends.length > 0) {\n    try {\n      const { EventBus } = await import('./event-bus/event-bus');\n      const { FrontendsHost } = await import('./frontends/host');\n      const bus = new EventBus();\n      (context as any).eventBus = bus;\n      frontendsHost = new FrontendsHost(bus, logger);\n\n      if (process.env.VISOR_DEBUG === 'true') {\n        try {\n          const fns = ((config as any).frontends || []).map((f: any) => ({\n            name: f?.name,\n            hasConfig: !!f?.config,\n            cfg: f?.config || undefined,\n          }));\n          logger.info(`[Frontends] Loading specs: ${JSON.stringify(fns)}`);\n        } catch {}\n      }\n\n      await frontendsHost.load((config as any).frontends);\n\n      // Derive repo/pr/headSha and octokit if available\n      let owner: string | undefined;\n      let name: string | undefined;\n      let prNum: number | undefined;\n      let headSha: string | undefined;\n      try {\n        const anyInfo: any = prInfo as any;\n        owner =\n          anyInfo?.eventContext?.repository?.owner?.login ||\n          process.env.GITHUB_REPOSITORY?.split('/')?.[0];\n        name =\n          anyInfo?.eventContext?.repository?.name || process.env.GITHUB_REPOSITORY?.split('/')?.[1];\n        prNum = typeof anyInfo?.number === 'number' ? anyInfo.number : undefined;\n        headSha = anyInfo?.eventContext?.pull_request?.head?.sha || process.env.GITHUB_SHA;\n      } catch {}\n      const repoObj = owner && name ? { owner, name } : undefined;\n      const octokit = (engine as any).getExecutionContext?.()?.octokit;\n\n      // Fallback: if headSha is missing but we have PR info and octokit, fetch it\n      if (\n        !headSha &&\n        repoObj &&\n        prNum &&\n        octokit &&\n        typeof octokit.rest?.pulls?.get === 'function'\n      ) {\n        try {\n          const { data } = await octokit.rest.pulls.get({\n            owner: repoObj.owner,\n            repo: repoObj.name,\n            pull_number: prNum,\n          });\n          headSha = (data && (data as any).head && (data as any).head.sha) || headSha;\n        } catch {\n          // ignore; headSha remains undefined\n        }\n      }\n\n      // Make the event bus available to providers via executionContext\n      try {\n        const prevExec: any = (engine as any).getExecutionContext?.() || {};\n        (engine as any).setExecutionContext?.({ ...prevExec, eventBus: bus });\n        try {\n          (context as any).executionContext = (engine as any).getExecutionContext?.();\n        } catch {}\n      } catch {}\n\n      await frontendsHost.startAll(() => ({\n        eventBus: bus,\n        logger,\n        // Provide the active config so frontends can read groups, etc.\n        config,\n        run: {\n          runId: (context as any).sessionId,\n          repo: repoObj,\n          pr: prNum,\n          headSha,\n          event: (context as any).event || (prInfo as any)?.eventType,\n          actor:\n            (prInfo as any)?.eventContext?.sender?.login ||\n            (typeof process.env.GITHUB_ACTOR === 'string' ? process.env.GITHUB_ACTOR : undefined),\n        },\n        octokit,\n        webhookContext: (engine as any).getExecutionContext?.()?.webhookContext,\n        // Surface any injected test doubles for Slack as well\n        slack:\n          (engine as any).getExecutionContext?.()?.slack ||\n          (engine as any).getExecutionContext?.()?.slackClient,\n      }));\n\n      // Snapshot-on-human-input support for resumed runs\n      try {\n        bus.on('HumanInputRequested', async (envelope: any) => {\n          try {\n            const ev = (envelope && envelope.payload) || envelope;\n            // Determine channel/thread from event or inbound payload\n            let channel: string | undefined = ev?.channel;\n            let threadTs: string | undefined = ev?.threadTs;\n            if (!channel || !threadTs) {\n              try {\n                const anyCfg: any = config || {};\n                const slackCfg: any = anyCfg.slack || {};\n                const endpoint: string = slackCfg.endpoint || '/bots/slack/support';\n                const map = (engine as any).getExecutionContext?.()?.webhookContext?.webhookData as\n                  | Map<string, unknown>\n                  | undefined;\n                const payload: any = map?.get(endpoint);\n                const e: any = payload?.event;\n                const derivedTs = String(e?.thread_ts || e?.ts || e?.event_ts || '');\n                const derivedCh = String(e?.channel || '');\n                if (derivedCh && derivedTs) {\n                  channel = channel || derivedCh;\n                  threadTs = threadTs || derivedTs;\n                }\n              } catch {}\n            }\n\n            const checkId = String(ev?.checkId || 'unknown');\n            const threadKey =\n              ev?.threadKey || (channel && threadTs ? `${channel}:${threadTs}` : 'session');\n            const baseDir =\n              process.env.VISOR_SNAPSHOT_DIR || path.resolve(process.cwd(), '.visor', 'snapshots');\n            fs.mkdirSync(baseDir, { recursive: true });\n            const filePath = path.join(baseDir, `${threadKey}-${checkId}.json`);\n            await engine.saveSnapshotToFile(filePath);\n            logger.info(`[Snapshot] Saved run snapshot: ${filePath}`);\n            try {\n              await bus.emit({\n                type: 'SnapshotSaved',\n                checkId: ev?.checkId || 'unknown',\n                channel,\n                threadTs,\n                threadKey,\n                filePath,\n              });\n            } catch {}\n          } catch (e) {\n            logger.warn(\n              `[Snapshot] Failed to save snapshot on HumanInputRequested: ${\n                e instanceof Error ? e.message : String(e)\n              }`\n            );\n          }\n        });\n      } catch {}\n    } catch (err) {\n      logger.warn(\n        `[Frontends] Failed to initialize frontends (resumeFromSnapshot): ${\n          err instanceof Error ? err.message : String(err)\n        }`\n      );\n    }\n  }\n\n  // Create runner and hydrate state\n  // For resume flows, we treat the snapshot's journal as prior history and\n  // start a fresh run from the normal Init â†’ PlanReady â†’ WavePlanning cycle.\n  // This avoids resuming mid-wave and accidentally re-running stale checks\n  // (e.g., chat replies) before new input is incorporated.\n  const runner = new (require('./state-machine/runner').StateMachineRunner)(\n    context,\n    (engine as any).debugServer\n  );\n  (engine as any)._lastContext = context;\n  (engine as any)._lastRunner = runner;\n\n  const result = await runner.run();\n\n  // Stop frontends if started\n  if (frontendsHost && typeof frontendsHost.stopAll === 'function') {\n    try {\n      await frontendsHost.stopAll();\n    } catch {}\n  }\n\n  // Cleanup AI sessions after execution\n  try {\n    const { SessionRegistry } = await import('./session-registry');\n    const sessionRegistry = SessionRegistry.getInstance();\n    sessionRegistry.clearAllSessions();\n  } catch (error) {\n    logger.debug(`[StateMachine] Failed to cleanup sessions: ${error}`);\n  }\n\n  return result;\n}\n","/*\n Thin SDK faÃ§ade for programmatic use of Visor.\n - No new execution logic; delegates to existing engine and config manager.\n - Dual ESM/CJS bundle via tsup.\n*/\n\nimport { StateMachineExecutionEngine } from './state-machine-execution-engine';\nimport { ConfigManager } from './config';\nimport type { AnalysisResult } from './output-formatters';\nimport type { VisorConfig, TagFilter, HumanInputRequest } from './types/config';\nimport type { ExecutionContext } from './providers/check-provider.interface';\n\nexport type { VisorConfig, TagFilter, HumanInputRequest, ExecutionContext };\n\nexport interface VisorOptions {\n  cwd?: string;\n  debug?: boolean;\n  maxParallelism?: number;\n  failFast?: boolean;\n  tagFilter?: TagFilter;\n}\n\nexport interface RunOptions extends VisorOptions {\n  config?: VisorConfig;\n  configPath?: string;\n  checks?: string[]; // default: all checks from config\n  timeoutMs?: number;\n  output?: { format?: 'table' | 'json' | 'markdown' | 'sarif' };\n  /** Strict mode: treat config warnings (like unknown keys) as errors (default: false) */\n  strictValidation?: boolean;\n  /** Execution context for providers (CLI message, hooks, etc.) */\n  executionContext?: ExecutionContext;\n}\n\n/**\n * Load and validate a Visor config.\n * @param configOrPath - Config object, file path, or omit to discover defaults\n * @param options - Validation options\n * @returns Validated config with defaults applied\n */\nexport async function loadConfig(\n  configOrPath?: string | Partial<VisorConfig>,\n  options?: { strict?: boolean }\n): Promise<VisorConfig> {\n  const cm = new ConfigManager();\n\n  // If it's an object, validate and return with defaults\n  if (typeof configOrPath === 'object' && configOrPath !== null) {\n    cm.validateConfig(configOrPath, options?.strict ?? false);\n\n    // Apply lightweight defaults without expensive file system operations\n    const defaultConfig: Partial<VisorConfig> = {\n      version: '1.0',\n      checks: {},\n      max_parallelism: 3,\n      fail_fast: false,\n    };\n\n    return {\n      ...defaultConfig,\n      ...configOrPath,\n      checks: configOrPath.checks || {},\n    } as VisorConfig;\n  }\n\n  // If it's a string, load from file\n  if (typeof configOrPath === 'string') {\n    return cm.loadConfig(configOrPath);\n  }\n\n  // Otherwise discover default config file\n  return cm.findAndLoadConfig();\n}\n\n/** Expand check IDs by including their dependencies (shallow->deep). */\nexport function resolveChecks(checkIds: string[], config: VisorConfig | undefined): string[] {\n  if (!config?.checks) return Array.from(new Set(checkIds));\n  const resolved = new Set<string>();\n  const visiting = new Set<string>();\n  const result: string[] = [];\n\n  const dfs = (id: string, stack: string[] = []) => {\n    if (resolved.has(id)) return;\n    if (visiting.has(id)) {\n      const cycle = [...stack, id].join(' -> ');\n      throw new Error(`Circular dependency detected involving check: ${id} (path: ${cycle})`);\n    }\n    visiting.add(id);\n    const deps = config.checks![id]?.depends_on || [];\n    for (const d of deps) dfs(d, [...stack, id]);\n    if (!result.includes(id)) result.push(id);\n    visiting.delete(id);\n    resolved.add(id);\n  };\n\n  for (const id of checkIds) dfs(id);\n  return result;\n}\n\n/**\n * Run Visor checks programmatically. Returns the same AnalysisResult shape used by the CLI.\n * Thin wrapper around CheckExecutionEngine.executeChecks.\n */\nexport async function runChecks(opts: RunOptions = {}): Promise<AnalysisResult> {\n  const cm = new ConfigManager();\n  let config: VisorConfig;\n\n  if (opts.config) {\n    // Validate manually constructed config\n    // In strict mode, unknown keys are treated as errors\n    cm.validateConfig(opts.config, opts.strictValidation ?? false);\n    config = opts.config;\n  } else if (opts.configPath) {\n    config = await cm.loadConfig(opts.configPath);\n  } else {\n    config = await cm.findAndLoadConfig();\n  }\n\n  const checks =\n    opts.checks && opts.checks.length > 0\n      ? resolveChecks(opts.checks, config)\n      : Object.keys(config.checks || {});\n\n  // Always use StateMachineExecutionEngine\n  const engine = new StateMachineExecutionEngine(opts.cwd);\n\n  // Set execution context if provided\n  if (opts.executionContext) {\n    engine.setExecutionContext(opts.executionContext);\n  }\n\n  const result = await engine.executeChecks({\n    checks,\n    workingDirectory: opts.cwd,\n    timeout: opts.timeoutMs,\n    maxParallelism: opts.maxParallelism,\n    failFast: opts.failFast,\n    outputFormat: opts.output?.format,\n    config,\n    debug: opts.debug,\n    tagFilter: opts.tagFilter,\n  });\n\n  return result;\n}\n"],"mappings":"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","names":["MemoryStore","ConfigManager","buildEngineContextForRun","fs","convertToReviewSummary"]}