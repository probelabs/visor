{"version":3,"sources":["../../src/utils/workspace-manager.ts","../../src/state-machine/context/build-engine-context.ts","../../src/state-machine/execution/summary.ts","../../src/state-machine-execution-engine.ts","../../src/sandbox/sandbox-manager.ts","../../src/sandbox/docker-image-sandbox.ts","../../src/sandbox/docker-compose-sandbox.ts","../../src/sandbox/cache-volume-manager.ts","../../src/sdk.ts"],"sourcesContent":["/**\n * Workspace Manager\n *\n * Provides full isolation between parallel visor runs with human-readable project names.\n * Each run gets its own workspace in /tmp containing worktrees for all projects.\n */\n\nimport * as fsp from 'fs/promises';\nimport * as path from 'path';\nimport { commandExecutor } from './command-executor';\nimport { logger } from '../logger';\n\n/**\n * Escape a string for safe use in shell commands.\n * Uses single quotes and escapes any embedded single quotes.\n */\nfunction shellEscape(str: string): string {\n  // Replace single quotes with '\\'' (end quote, escaped quote, start quote)\n  // Then wrap the whole thing in single quotes\n  return \"'\" + str.replace(/'/g, \"'\\\\''\") + \"'\";\n}\n\n/**\n * Sanitize a path component to prevent path traversal attacks.\n * Removes directory separators and parent directory references.\n */\nfunction sanitizePathComponent(name: string): string {\n  return (\n    name\n      .replace(/\\.\\./g, '') // Remove parent directory references\n      .replace(/[\\/\\\\]/g, '-') // Replace path separators with dashes\n      .replace(/^\\.+/, '') // Remove leading dots\n      .trim() || 'unnamed'\n  ); // Ensure non-empty result\n}\n\nexport interface WorkspaceConfig {\n  enabled: boolean;\n  basePath: string;\n  cleanupOnExit: boolean;\n  name?: string;\n  mainProjectName?: string;\n}\n\nexport interface WorkspaceInfo {\n  sessionId: string;\n  workspacePath: string;\n  mainProjectPath: string;\n  mainProjectName: string;\n  originalPath: string;\n}\n\nexport interface ProjectInfo {\n  name: string;\n  path: string;\n  worktreePath: string;\n  repository: string;\n}\n\n/**\n * WorkspaceManager creates isolated workspaces for parallel visor runs.\n * Each run gets a unique workspace directory containing worktrees for all projects.\n */\nexport class WorkspaceManager {\n  private static instances: Map<string, WorkspaceManager> = new Map();\n\n  private sessionId: string;\n  private basePath: string;\n  private workspacePath: string;\n  private originalPath: string;\n  private config: WorkspaceConfig;\n  private initialized: boolean = false;\n  private mainProjectInfo: WorkspaceInfo | null = null;\n  private projects: Map<string, ProjectInfo> = new Map();\n  private cleanupHandlersRegistered: boolean = false;\n  private usedNames: Set<string> = new Set();\n\n  // Reference counting to prevent premature cleanup\n  private activeOperations: number = 0;\n  private cleanupRequested: boolean = false;\n  private cleanupResolvers: Array<() => void> = [];\n\n  private constructor(sessionId: string, originalPath: string, config?: Partial<WorkspaceConfig>) {\n    this.sessionId = sessionId;\n    this.originalPath = originalPath;\n\n    const configuredName = config?.name || process.env.VISOR_WORKSPACE_NAME;\n    const configuredMainProjectName =\n      config?.mainProjectName || process.env.VISOR_WORKSPACE_PROJECT;\n\n    // Default configuration\n    this.config = {\n      enabled: true,\n      basePath: process.env.VISOR_WORKSPACE_PATH || '/tmp/visor-workspaces',\n      cleanupOnExit: true,\n      name: configuredName,\n      mainProjectName: configuredMainProjectName,\n      ...config,\n    };\n\n    this.basePath = this.config.basePath;\n    const workspaceDirName = sanitizePathComponent(this.config.name || this.sessionId);\n    this.workspacePath = path.join(this.basePath, workspaceDirName);\n  }\n\n  /**\n   * Get or create a WorkspaceManager instance for a session\n   */\n  static getInstance(\n    sessionId: string,\n    originalPath: string,\n    config?: Partial<WorkspaceConfig>\n  ): WorkspaceManager {\n    if (!WorkspaceManager.instances.has(sessionId)) {\n      WorkspaceManager.instances.set(\n        sessionId,\n        new WorkspaceManager(sessionId, originalPath, config)\n      );\n    }\n    return WorkspaceManager.instances.get(sessionId)!;\n  }\n\n  /**\n   * Clear all instances (for testing)\n   */\n  static clearInstances(): void {\n    WorkspaceManager.instances.clear();\n  }\n\n  /**\n   * Check if workspace isolation is enabled\n   */\n  isEnabled(): boolean {\n    return this.config.enabled;\n  }\n\n  /**\n   * Acquire a reference to the workspace (prevents cleanup while held)\n   * Call release() when done with the operation.\n   */\n  acquire(): void {\n    this.activeOperations++;\n    logger.debug(\n      `[Workspace] Acquired reference (active: ${this.activeOperations}) for ${this.workspacePath}`\n    );\n  }\n\n  /**\n   * Release a reference to the workspace.\n   * If cleanup was requested and this was the last reference, cleanup will proceed.\n   */\n  release(): void {\n    this.activeOperations = Math.max(0, this.activeOperations - 1);\n    logger.debug(\n      `[Workspace] Released reference (active: ${this.activeOperations}) for ${this.workspacePath}`\n    );\n\n    // If cleanup was requested and no more active operations, proceed with cleanup\n    if (this.cleanupRequested && this.activeOperations === 0) {\n      logger.debug(`[Workspace] All references released, proceeding with deferred cleanup`);\n      // Resolve all waiting cleanup promises\n      for (const resolve of this.cleanupResolvers) {\n        resolve();\n      }\n      this.cleanupResolvers = [];\n    }\n  }\n\n  /**\n   * Get the number of active operations\n   */\n  getActiveOperations(): number {\n    return this.activeOperations;\n  }\n\n  /**\n   * Get the workspace path\n   */\n  getWorkspacePath(): string {\n    return this.workspacePath;\n  }\n\n  /**\n   * Get the original working directory\n   */\n  getOriginalPath(): string {\n    return this.originalPath;\n  }\n\n  /**\n   * Get workspace info (only available after initialize)\n   */\n  getWorkspaceInfo(): WorkspaceInfo | null {\n    return this.mainProjectInfo;\n  }\n\n  /**\n   * Initialize the workspace - creates workspace directory and main project worktree\n   */\n  async initialize(): Promise<WorkspaceInfo> {\n    if (!this.config.enabled) {\n      throw new Error('Workspace isolation is not enabled');\n    }\n\n    if (this.initialized && this.mainProjectInfo) {\n      return this.mainProjectInfo;\n    }\n\n    logger.info(`Initializing workspace: ${this.workspacePath}`);\n\n    // Create workspace directory (mkdir with recursive handles existing dirs)\n    await fsp.mkdir(this.workspacePath, { recursive: true });\n    logger.debug(`Created workspace directory: ${this.workspacePath}`);\n\n    // Extract main project name from original path (sanitize for defense in depth)\n    const configuredMainProjectName = this.config.mainProjectName;\n    const mainProjectName = sanitizePathComponent(\n      configuredMainProjectName || this.extractProjectName(this.originalPath)\n    );\n    this.usedNames.add(mainProjectName);\n\n    // Create worktree for main project\n    const mainProjectPath = path.join(this.workspacePath, mainProjectName);\n\n    // Check if original path is a git repository\n    const isGitRepo = await this.isGitRepository(this.originalPath);\n\n    if (isGitRepo) {\n      // Create worktree for main project\n      await this.createMainProjectWorktree(mainProjectPath);\n    } else {\n      // If not a git repo, create a symlink instead\n      logger.debug(`Original path is not a git repo, creating symlink`);\n      try {\n        await fsp.symlink(this.originalPath, mainProjectPath);\n      } catch (error) {\n        throw new Error(`Failed to create symlink for main project: ${error}`);\n      }\n    }\n\n    // Register cleanup handlers\n    this.registerCleanupHandlers();\n\n    this.mainProjectInfo = {\n      sessionId: this.sessionId,\n      workspacePath: this.workspacePath,\n      mainProjectPath,\n      mainProjectName,\n      originalPath: this.originalPath,\n    };\n\n    this.initialized = true;\n    logger.info(`Workspace initialized: ${this.workspacePath}`);\n\n    return this.mainProjectInfo;\n  }\n\n  /**\n   * Add a project to the workspace (creates symlink to worktree)\n   * If the same repository + worktreePath combination already exists, returns the existing path.\n   */\n  async addProject(\n    repository: string,\n    worktreePath: string,\n    description?: string\n  ): Promise<string> {\n    if (!this.initialized) {\n      throw new Error('Workspace not initialized. Call initialize() first.');\n    }\n\n    // Check if this exact project (same repo + worktree path) is already added\n    // This prevents duplicate checkouts when tyk-code-talk is called multiple times\n    for (const [existingName, existingProject] of this.projects.entries()) {\n      if (\n        existingProject.repository === repository &&\n        existingProject.worktreePath === worktreePath\n      ) {\n        logger.debug(`Reusing existing project: ${existingName} (${repository})`);\n        return existingProject.path;\n      }\n    }\n\n    // Extract project name and sanitize to prevent path traversal\n    let projectName = sanitizePathComponent(description || this.extractRepoName(repository));\n\n    // Handle duplicate names (only if not reusing existing)\n    projectName = this.getUniqueName(projectName);\n    this.usedNames.add(projectName);\n\n    // Create symlink in workspace\n    const workspacePath = path.join(this.workspacePath, projectName);\n\n    // Remove existing symlink/directory if present (rm with force handles non-existent)\n    await fsp.rm(workspacePath, { recursive: true, force: true });\n\n    try {\n      await fsp.symlink(worktreePath, workspacePath);\n    } catch (error) {\n      throw new Error(`Failed to create symlink for project ${projectName}: ${error}`);\n    }\n\n    // Track project\n    this.projects.set(projectName, {\n      name: projectName,\n      path: workspacePath,\n      worktreePath,\n      repository,\n    });\n\n    logger.info(`Added project to workspace: ${projectName} -> ${worktreePath}`);\n\n    return workspacePath;\n  }\n\n  /**\n   * List all projects in the workspace\n   */\n  listProjects(): ProjectInfo[] {\n    return Array.from(this.projects.values());\n  }\n\n  /**\n   * Cleanup the workspace.\n   * If there are active operations, waits for them to complete before cleaning up.\n   * @param timeout Maximum time to wait for active operations (default: 60s)\n   */\n  async cleanup(timeout: number = 60000): Promise<void> {\n    logger.info(\n      `Cleaning up workspace: ${this.workspacePath} (active operations: ${this.activeOperations})`\n    );\n\n    // If there are active operations, wait for them to complete\n    if (this.activeOperations > 0) {\n      logger.info(\n        `[Workspace] Waiting for ${this.activeOperations} active operations to complete before cleanup`\n      );\n      this.cleanupRequested = true;\n\n      // Wait for all operations to complete (with timeout)\n      await Promise.race([\n        new Promise<void>(resolve => {\n          if (this.activeOperations === 0) {\n            resolve();\n          } else {\n            this.cleanupResolvers.push(resolve);\n          }\n        }),\n        new Promise<void>(resolve => {\n          setTimeout(() => {\n            logger.warn(\n              `[Workspace] Cleanup timeout after ${timeout}ms, proceeding anyway (${this.activeOperations} operations still active)`\n            );\n            resolve();\n          }, timeout);\n        }),\n      ]);\n    }\n\n    try {\n      // Remove main project worktree if it exists\n      if (this.mainProjectInfo) {\n        const mainProjectPath = this.mainProjectInfo.mainProjectPath;\n\n        // Check if path exists and if it's a worktree (not a symlink)\n        try {\n          const stats = await fsp.lstat(mainProjectPath);\n          if (!stats.isSymbolicLink()) {\n            await this.removeMainProjectWorktree(mainProjectPath);\n          }\n        } catch {\n          // Path doesn't exist, nothing to clean up\n        }\n      }\n\n      // Remove workspace directory\n      await fsp.rm(this.workspacePath, { recursive: true, force: true });\n      logger.debug(`Removed workspace directory: ${this.workspacePath}`);\n\n      // Remove from instances\n      WorkspaceManager.instances.delete(this.sessionId);\n\n      this.initialized = false;\n      this.mainProjectInfo = null;\n      this.projects.clear();\n      this.usedNames.clear();\n      this.cleanupRequested = false;\n      this.cleanupResolvers = [];\n\n      logger.info(`Workspace cleanup completed: ${this.sessionId}`);\n    } catch (error) {\n      logger.warn(`Failed to cleanup workspace: ${error}`);\n    }\n  }\n\n  /**\n   * Create worktree for the main project\n   *\n   * visor-disable: architecture - Not using WorktreeManager here because:\n   * 1. WorktreeManager expects remote URLs and clones to bare repos first\n   * 2. This operates on the LOCAL repo we're already in (no cloning needed)\n   * 3. Adding a \"local mode\" to WorktreeManager would add complexity for minimal benefit\n   * The git commands here are simpler (just rev-parse + worktree add) vs WorktreeManager's\n   * full clone/bare-repo/fetch/worktree pipeline.\n   */\n  private async createMainProjectWorktree(targetPath: string): Promise<void> {\n    logger.debug(`Creating main project worktree: ${targetPath}`);\n\n    // Get current HEAD\n    const headResult = await commandExecutor.execute(\n      `git -C ${shellEscape(this.originalPath)} rev-parse HEAD`,\n      {\n        timeout: 10000,\n      }\n    );\n\n    if (headResult.exitCode !== 0) {\n      throw new Error(`Failed to get HEAD: ${headResult.stderr}`);\n    }\n\n    const headRef = headResult.stdout.trim();\n\n    // Create worktree using detached HEAD to avoid branch conflicts\n    const createCmd = `git -C ${shellEscape(this.originalPath)} worktree add --detach ${shellEscape(targetPath)} ${shellEscape(headRef)}`;\n    const result = await commandExecutor.execute(createCmd, { timeout: 60000 });\n\n    if (result.exitCode !== 0) {\n      throw new Error(`Failed to create main project worktree: ${result.stderr}`);\n    }\n\n    logger.debug(`Created main project worktree at ${targetPath}`);\n  }\n\n  /**\n   * Remove main project worktree\n   */\n  private async removeMainProjectWorktree(worktreePath: string): Promise<void> {\n    logger.debug(`Removing main project worktree: ${worktreePath}`);\n\n    const removeCmd = `git -C ${shellEscape(this.originalPath)} worktree remove ${shellEscape(worktreePath)} --force`;\n    const result = await commandExecutor.execute(removeCmd, { timeout: 30000 });\n\n    if (result.exitCode !== 0) {\n      logger.warn(`Failed to remove worktree via git: ${result.stderr}`);\n      // Directory will be removed with the workspace anyway\n    }\n  }\n\n  /**\n   * Check if a path is a git repository\n   */\n  private async isGitRepository(dirPath: string): Promise<boolean> {\n    try {\n      const result = await commandExecutor.execute(\n        `git -C ${shellEscape(dirPath)} rev-parse --git-dir`,\n        {\n          timeout: 5000,\n        }\n      );\n      return result.exitCode === 0;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Extract project name from path\n   */\n  private extractProjectName(dirPath: string): string {\n    return path.basename(dirPath);\n  }\n\n  /**\n   * Extract repository name from owner/repo format\n   */\n  private extractRepoName(repository: string): string {\n    // Handle URLs\n    if (repository.includes('://') || repository.startsWith('git@')) {\n      // Extract from URL\n      const match = repository.match(/[/:]([^/:]+\\/[^/:]+?)(?:\\.git)?$/);\n      if (match) {\n        return match[1].split('/').pop() || repository;\n      }\n    }\n\n    // Handle owner/repo format\n    if (repository.includes('/')) {\n      return repository.split('/').pop() || repository;\n    }\n\n    return repository;\n  }\n\n  /**\n   * Get a unique name by appending a number if needed\n   */\n  private getUniqueName(baseName: string): string {\n    if (!this.usedNames.has(baseName)) {\n      return baseName;\n    }\n\n    let counter = 2;\n    let uniqueName = `${baseName}-${counter}`;\n    while (this.usedNames.has(uniqueName)) {\n      counter++;\n      uniqueName = `${baseName}-${counter}`;\n    }\n\n    return uniqueName;\n  }\n\n  /**\n   * Register cleanup handlers for process exit\n   */\n  private registerCleanupHandlers(): void {\n    if (this.cleanupHandlersRegistered || !this.config.cleanupOnExit) {\n      return;\n    }\n\n    // Note: We don't register on 'exit' as it must be synchronous\n    // SIGINT and SIGTERM handlers are already registered by WorktreeManager\n    // We rely on explicit cleanup call or process handlers from the engine\n\n    this.cleanupHandlersRegistered = true;\n  }\n}\n","import type { VisorConfig, EventTrigger } from '../../types/config';\nimport type { PRInfo } from '../../pr-analyzer';\nimport type { EngineContext, CheckMetadata } from '../../types/engine';\nimport { ExecutionJournal } from '../../snapshot-store';\nimport { MemoryStore } from '../../memory-store';\nimport { generateHumanId } from '../../utils/human-id';\nimport { logger } from '../../logger';\nimport type { VisorConfig as VCfg, CheckConfig as CfgCheck } from '../../types/config';\nimport { WorkspaceManager } from '../../utils/workspace-manager';\n\n/**\n * Apply minimal criticality defaults in-place.\n * This is a no-behavior-change scaffold: we only default missing\n * check.criticality to 'policy' so downstream code can rely on a value.\n * Future mapping (retries/loop budgets) can build on this without\n * changing existing behavior.\n */\nfunction applyCriticalityDefaults(cfg: VCfg): void {\n  const checks = cfg.checks || {};\n  for (const id of Object.keys(checks)) {\n    const c: CfgCheck = (checks as any)[id] as CfgCheck;\n    if (!c.criticality) (c.criticality as any) = 'policy';\n    // For 'info' checks, default continue_on_failure to true if unset.\n    if (c.criticality === 'info' && typeof c.continue_on_failure === 'undefined')\n      c.continue_on_failure = true;\n  }\n}\n\n/**\n * Pure helper to build an EngineContext for a state-machine run.\n * Extracted to reduce StateMachineExecutionEngine size; behavior unchanged.\n */\nexport function buildEngineContextForRun(\n  workingDirectory: string,\n  config: VisorConfig,\n  prInfo: PRInfo,\n  debug?: boolean,\n  maxParallelism?: number,\n  failFast?: boolean,\n  requestedChecks?: string[]\n): EngineContext {\n  // Deep clone provided config to avoid cross-run mutations between tests/runs\n  const clonedConfig: VisorConfig = JSON.parse(JSON.stringify(config));\n\n  // Build check metadata\n  const checks: Record<string, CheckMetadata> = {};\n\n  // Fill in minimal defaults derived from criticality (no behavior change)\n  applyCriticalityDefaults(clonedConfig);\n\n  // If config has checks, use them\n  for (const [checkId, checkConfig] of Object.entries(clonedConfig.checks || {})) {\n    checks[checkId] = {\n      tags: checkConfig.tags || [],\n      triggers: (Array.isArray(checkConfig.on) ? checkConfig.on : [checkConfig.on]).filter(\n        Boolean\n      ) as EventTrigger[],\n      group: checkConfig.group,\n      providerType: checkConfig.type || 'ai',\n      // Normalize depends_on to array (supports string | string[])\n      dependencies: Array.isArray(checkConfig.depends_on)\n        ? checkConfig.depends_on\n        : checkConfig.depends_on\n          ? [checkConfig.depends_on]\n          : [],\n    };\n  }\n\n  // Backward compatibility: synthesize minimal check configs for requested checks\n  // that don't exist in the config (e.g., legacy test mode with empty config)\n  if (requestedChecks && requestedChecks.length > 0) {\n    for (const checkName of requestedChecks) {\n      if (!checks[checkName] && !clonedConfig.checks?.[checkName]) {\n        // Synthesize a minimal check config for this legacy check name\n        logger.debug(`[StateMachine] Synthesizing minimal config for legacy check: ${checkName}`);\n\n        // Add to config.checks so providers can find it\n        if (!clonedConfig.checks) {\n          clonedConfig.checks = {};\n        }\n        clonedConfig.checks[checkName] = {\n          type: 'ai',\n          prompt: `Perform ${checkName} analysis`,\n        } as any;\n\n        // Add metadata\n        checks[checkName] = {\n          tags: [],\n          triggers: [],\n          group: 'default',\n          providerType: 'ai',\n          dependencies: [],\n        };\n      }\n    }\n  }\n\n  // Initialize journal and memory\n  const journal = new ExecutionJournal();\n  const memory = MemoryStore.getInstance(clonedConfig.memory);\n\n  return {\n    mode: 'state-machine',\n    config: clonedConfig,\n    checks,\n    journal,\n    memory,\n    workingDirectory,\n    originalWorkingDirectory: workingDirectory,\n    sessionId: generateHumanId(),\n    event: prInfo.eventType,\n    debug,\n    maxParallelism,\n    failFast,\n    requestedChecks: requestedChecks && requestedChecks.length > 0 ? requestedChecks : undefined,\n    // Store prInfo for later access (e.g., in getOutputHistorySnapshot)\n    prInfo,\n  };\n}\n\n/**\n * Initialize workspace isolation for an engine context.\n * Creates an isolated workspace with the main project worktree.\n *\n * @param context - Engine context to update with workspace\n * @returns Updated context (same object, mutated)\n */\nexport async function initializeWorkspace(context: EngineContext): Promise<EngineContext> {\n  // Check if workspace isolation is enabled via config or env\n  const workspaceConfig = (context.config as any).workspace;\n  const isEnabled =\n    workspaceConfig?.enabled !== false && process.env.VISOR_WORKSPACE_ENABLED !== 'false';\n\n  if (!isEnabled) {\n    logger.debug('[Workspace] Workspace isolation is disabled');\n    return context;\n  }\n\n  const originalPath = context.workingDirectory || process.cwd();\n\n  try {\n    // Check if workspace should be kept (for debugging)\n    const keepWorkspace = process.env.VISOR_KEEP_WORKSPACE === 'true';\n\n    // Create workspace manager\n    const workspace = WorkspaceManager.getInstance(context.sessionId, originalPath, {\n      enabled: true,\n      basePath:\n        workspaceConfig?.base_path || process.env.VISOR_WORKSPACE_PATH || '/tmp/visor-workspaces',\n      cleanupOnExit: keepWorkspace ? false : workspaceConfig?.cleanup_on_exit !== false,\n      name: workspaceConfig?.name || process.env.VISOR_WORKSPACE_NAME,\n      mainProjectName: workspaceConfig?.main_project_name || process.env.VISOR_WORKSPACE_PROJECT,\n    });\n\n    // Initialize workspace (creates main project worktree)\n    const info = await workspace.initialize();\n\n    // Update context with workspace info\n    context.workspace = workspace;\n    context.workingDirectory = info.mainProjectPath;\n    context.originalWorkingDirectory = originalPath;\n\n    // Export workspace paths for templates/commands\n    try {\n      process.env.VISOR_WORKSPACE_ROOT = info.workspacePath;\n      process.env.VISOR_WORKSPACE_MAIN_PROJECT = info.mainProjectPath;\n      process.env.VISOR_WORKSPACE_MAIN_PROJECT_NAME = info.mainProjectName;\n      process.env.VISOR_ORIGINAL_WORKDIR = originalPath;\n    } catch {}\n\n    logger.info(`[Workspace] Initialized workspace: ${info.workspacePath}`);\n    logger.debug(`[Workspace] Main project at: ${info.mainProjectPath}`);\n    if (keepWorkspace) {\n      logger.info(`[Workspace] Keeping workspace after execution (--keep-workspace)`);\n    }\n\n    return context;\n  } catch (error) {\n    // Log warning but continue without workspace isolation\n    logger.warn(`[Workspace] Failed to initialize workspace: ${error}`);\n    logger.debug('[Workspace] Continuing without workspace isolation');\n    return context;\n  }\n}\n","import type { ReviewIssue, GroupedCheckResults, ReviewSummary } from '../../reviewer';\nimport type { ExecutionStatistics } from '../../types/execution';\n\n/**\n * Pure helper to convert grouped results + statistics into a flat ReviewSummary.\n * Extracted to reduce StateMachineExecutionEngine size; behavior unchanged.\n */\nexport function convertToReviewSummary(\n  groupedResults: GroupedCheckResults,\n  statistics?: ExecutionStatistics\n): ReviewSummary {\n  const allIssues: ReviewIssue[] = [];\n\n  // Aggregate issues from all check results\n  for (const checkResults of Object.values(groupedResults)) {\n    for (const checkResult of checkResults) {\n      if (checkResult.issues && checkResult.issues.length > 0) {\n        allIssues.push(...checkResult.issues);\n      }\n    }\n  }\n\n  // Convert errors from execution statistics into issues\n  if (statistics) {\n    for (const checkStats of statistics.checks) {\n      if (checkStats.errorMessage) {\n        allIssues.push({\n          file: 'system',\n          line: 0,\n          endLine: undefined,\n          ruleId: 'system/error',\n          message: checkStats.errorMessage,\n          severity: 'error',\n          category: 'logic',\n          suggestion: undefined,\n          replacement: undefined,\n        });\n      }\n    }\n  }\n\n  return {\n    issues: allIssues,\n  };\n}\n","import type { CheckExecutionOptions, ExecutionResult } from './types/execution';\nimport { AnalysisResult } from './output-formatters';\nimport type { VisorConfig } from './types/config';\nimport type { PRInfo } from './pr-analyzer';\nimport { StateMachineRunner } from './state-machine/runner';\nimport type { EngineContext } from './types/engine';\nimport { ExecutionJournal } from './snapshot-store';\nimport { logger } from './logger';\nimport type { DebugVisualizerServer } from './debug-visualizer/ws-server';\nimport { SandboxManager } from './sandbox/sandbox-manager';\nimport * as path from 'path';\nimport * as fs from 'fs';\n\n/**\n * State machine-based execution engine\n *\n * Production-ready state machine implementation with full observability support.\n * M4: Includes OTEL telemetry and debug visualizer event streaming.\n */\nexport class StateMachineExecutionEngine {\n  private workingDirectory: string;\n  private executionContext?: import('./providers/check-provider.interface').ExecutionContext;\n  private debugServer?: DebugVisualizerServer;\n  private _lastContext?: EngineContext;\n  private _lastRunner?: StateMachineRunner;\n\n  constructor(\n    workingDirectory?: string,\n    octokit?: import('@octokit/rest').Octokit,\n    debugServer?: DebugVisualizerServer\n  ) {\n    this.workingDirectory = workingDirectory || process.cwd();\n    this.debugServer = debugServer;\n  }\n\n  /**\n   * Execute checks using the state machine engine\n   *\n   * Converts CheckExecutionOptions -> executeGroupedChecks() -> AnalysisResult\n   */\n  async executeChecks(options: CheckExecutionOptions): Promise<AnalysisResult> {\n    const startTime = Date.now();\n    const timestamp = new Date().toISOString();\n\n    try {\n      // Initialize memory store if configured\n      if (options.config?.memory) {\n        const { MemoryStore } = await import('./memory-store');\n        const memoryStore = MemoryStore.getInstance(options.config.memory);\n        await memoryStore.initialize();\n        logger.debug('Memory store initialized');\n      }\n\n      // Analyze the repository\n      const { GitRepositoryAnalyzer } = await import('./git-repository-analyzer');\n      const gitAnalyzer = new GitRepositoryAnalyzer(options.workingDirectory);\n      logger.info('Analyzing local git repository...');\n      const repositoryInfo = await gitAnalyzer.analyzeRepository();\n\n      if (!repositoryInfo.isGitRepository) {\n        return this.createErrorResult(\n          repositoryInfo,\n          'Not a git repository or no changes found',\n          startTime,\n          timestamp,\n          options.checks\n        );\n      }\n\n      // Convert to PRInfo format for compatibility\n      const prInfo = gitAnalyzer.toPRInfo(repositoryInfo);\n\n      // Propagate event type if provided\n      try {\n        const evt = (options.webhookContext as any)?.eventType;\n        if (evt) (prInfo as any).eventType = evt;\n      } catch {}\n\n      // Apply tag filtering if specified\n      const filteredChecks = this.filterChecksByTags(\n        options.checks,\n        options.config,\n        options.tagFilter || options.config?.tag_filter\n      );\n\n      if (filteredChecks.length === 0) {\n        logger.warn('No checks match the tag filter criteria');\n        return this.createErrorResult(\n          repositoryInfo,\n          'No checks match the tag filter criteria',\n          startTime,\n          timestamp,\n          options.checks\n        );\n      }\n\n      // If a webhook context is provided (from WebhookServer or Slack socket),\n      // attach it to the http_input provider so http_input checks can read data.\n      try {\n        const map = (options as any)?.webhookContext?.webhookData as\n          | Map<string, unknown>\n          | undefined;\n        if (map) {\n          const { CheckProviderRegistry } = await import('./providers/check-provider-registry');\n          const reg = CheckProviderRegistry.getInstance();\n          const p: any = reg.getProvider('http_input');\n          if (p && typeof p.setWebhookContext === 'function') p.setWebhookContext(map);\n          const prev: any = this.executionContext || {};\n          this.setExecutionContext({ ...prev, webhookContext: { webhookData: map } } as any);\n        }\n      } catch {}\n\n      // Execute checks using state machine\n      logger.info(`Executing checks: ${filteredChecks.join(', ')}`);\n      const executionResult = await this.executeGroupedChecks(\n        prInfo,\n        filteredChecks,\n        options.timeout,\n        options.config,\n        options.outputFormat,\n        options.debug,\n        options.maxParallelism,\n        options.failFast,\n        options.tagFilter\n      );\n\n      // Convert ExecutionResult to AnalysisResult format\n      const executionTime = Date.now() - startTime;\n\n      // Extract review summary from grouped results\n      const reviewSummary = this.convertGroupedResultsToReviewSummary(\n        executionResult.results,\n        executionResult.statistics\n      );\n\n      // Collect debug information when debug mode is enabled\n      let debugInfo: import('./output-formatters').DebugInfo | undefined;\n      if (options.debug && reviewSummary.debug) {\n        debugInfo = {\n          provider: reviewSummary.debug.provider,\n          model: reviewSummary.debug.model,\n          processingTime: reviewSummary.debug.processingTime,\n          parallelExecution: options.checks.length > 1,\n          checksExecuted: options.checks,\n          totalApiCalls: reviewSummary.debug.totalApiCalls || options.checks.length,\n          apiCallDetails: reviewSummary.debug.apiCallDetails,\n        };\n      }\n\n      // Expose output history snapshot\n      try {\n        const histSnap = this.getOutputHistorySnapshot();\n        (reviewSummary as any).history = histSnap;\n      } catch {}\n\n      return {\n        repositoryInfo,\n        reviewSummary,\n        executionTime,\n        timestamp,\n        checksExecuted: filteredChecks,\n        executionStatistics: executionResult.statistics,\n        debug: debugInfo,\n      };\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Unknown error occurred';\n      logger.error('Error executing checks: ' + message);\n\n      // In strict test modes, surface errors to callers\n      const strictEnv = process.env.VISOR_STRICT_ERRORS === 'true';\n      if (strictEnv) {\n        throw error;\n      }\n\n      const fallbackRepositoryInfo: import('./git-repository-analyzer').GitRepositoryInfo = {\n        title: 'Error during analysis',\n        body: `Error: ${message || 'Unknown error'}`,\n        author: 'system',\n        base: 'main',\n        head: 'HEAD',\n        files: [],\n        totalAdditions: 0,\n        totalDeletions: 0,\n        isGitRepository: false,\n        workingDirectory: options.workingDirectory || process.cwd(),\n      };\n\n      return this.createErrorResult(\n        fallbackRepositoryInfo,\n        message || 'Unknown error occurred',\n        startTime,\n        timestamp,\n        options.checks\n      );\n    }\n  }\n\n  /**\n   * Get execution context (used by state machine to propagate hooks)\n   */\n  protected getExecutionContext():\n    | import('./providers/check-provider.interface').ExecutionContext\n    | undefined {\n    return this.executionContext;\n  }\n\n  /**\n   * Set execution context for external callers\n   */\n  public setExecutionContext(\n    context: import('./providers/check-provider.interface').ExecutionContext | undefined\n  ): void {\n    this.executionContext = context;\n  }\n\n  /**\n   * Reset per-run state (no-op for state machine engine)\n   *\n   * The state machine engine is stateless per-run by design.\n   * Each execution creates a fresh journal and context.\n   * This method exists only for backward compatibility with test framework.\n   *\n   * @deprecated This is a no-op. State machine engine doesn't maintain per-run state.\n   */\n  public resetPerRunState(): void {\n    // No-op: State machine engine is stateless per-run\n    // Each execution creates a fresh journal and context\n  }\n\n  /**\n   * Execute grouped checks using the state machine engine\n   *\n   * M4: Production-ready with full telemetry and debug server support\n   */\n  async executeGroupedChecks(\n    prInfo: PRInfo,\n    checks: string[],\n    timeout?: number,\n    config?: VisorConfig,\n    outputFormat?: string,\n    debug?: boolean,\n    maxParallelism?: number,\n    failFast?: boolean,\n    tagFilter?: import('./types/config').TagFilter,\n    _pauseGate?: () => Promise<void>\n  ): Promise<ExecutionResult> {\n    if (debug) {\n      logger.info('[StateMachine] Using state machine engine');\n    }\n\n    // Create minimal default config if none provided (backward compatibility)\n    if (!config) {\n      const { ConfigManager } = await import('./config');\n      const configManager = new ConfigManager();\n      config = await configManager.getDefaultConfig();\n      logger.debug('[StateMachine] Using default configuration (no config provided)');\n    }\n\n    // Merge tagFilter into config if provided (test runner passes it separately)\n    const configWithTagFilter = tagFilter\n      ? {\n          ...config,\n          tag_filter: tagFilter,\n        }\n      : config;\n\n    // Build engine context\n    const context = this.buildEngineContext(\n      configWithTagFilter,\n      prInfo,\n      debug,\n      maxParallelism,\n      failFast,\n      checks // Pass the explicit checks list\n    );\n\n    // Create SandboxManager if sandboxes are configured\n    if (configWithTagFilter.sandboxes && Object.keys(configWithTagFilter.sandboxes).length > 0) {\n      try {\n        const { execSync } = require('child_process');\n        const gitBranch = execSync('git rev-parse --abbrev-ref HEAD', { encoding: 'utf8' }).trim();\n        context.sandboxManager = new SandboxManager(\n          configWithTagFilter.sandboxes,\n          this.workingDirectory,\n          gitBranch\n        );\n      } catch {\n        // If git branch detection fails, use 'unknown'\n        context.sandboxManager = new SandboxManager(\n          configWithTagFilter.sandboxes,\n          this.workingDirectory,\n          'unknown'\n        );\n      }\n    }\n\n    // Initialize workspace isolation (if enabled)\n    const { initializeWorkspace } = require('./state-machine/context/build-engine-context');\n    await initializeWorkspace(context);\n\n    // Copy execution context (hooks, etc.) from legacy engine\n    context.executionContext = this.getExecutionContext();\n\n    // Store context for later access (e.g., getOutputHistorySnapshot)\n    this._lastContext = context;\n\n    // Optionally enable event-driven frontends if configured\n    let frontendsHost: any | undefined;\n    if (\n      Array.isArray((configWithTagFilter as any).frontends) &&\n      (configWithTagFilter as any).frontends.length > 0\n    ) {\n      try {\n        const { EventBus } = await import('./event-bus/event-bus');\n        const { FrontendsHost } = await import('./frontends/host');\n        const bus = new EventBus();\n        (context as any).eventBus = bus;\n        frontendsHost = new FrontendsHost(bus, logger);\n        if (process.env.VISOR_DEBUG === 'true') {\n          try {\n            const fns = ((configWithTagFilter as any).frontends || []).map((f: any) => ({\n              name: f?.name,\n              hasConfig: !!f?.config,\n              cfg: f?.config || undefined,\n            }));\n            logger.info(`[Frontends] Loading specs: ${JSON.stringify(fns)}`);\n          } catch {}\n        }\n        await frontendsHost.load((configWithTagFilter as any).frontends);\n        // Derive repo/pr/headSha and octokit if available\n        let owner: string | undefined;\n        let name: string | undefined;\n        let prNum: number | undefined;\n        let headSha: string | undefined;\n        try {\n          const anyInfo: any = prInfo as any;\n          owner =\n            anyInfo?.eventContext?.repository?.owner?.login ||\n            process.env.GITHUB_REPOSITORY?.split('/')?.[0];\n          name =\n            anyInfo?.eventContext?.repository?.name ||\n            process.env.GITHUB_REPOSITORY?.split('/')?.[1];\n          prNum = typeof anyInfo?.number === 'number' ? anyInfo.number : undefined;\n          headSha = anyInfo?.eventContext?.pull_request?.head?.sha || process.env.GITHUB_SHA;\n        } catch {}\n        const repoObj = owner && name ? { owner, name } : undefined;\n        const octokit = (this.executionContext as any)?.octokit;\n        // Fallback: if headSha is missing but we have PR info and octokit, fetch it\n        if (\n          !headSha &&\n          repoObj &&\n          prNum &&\n          octokit &&\n          typeof octokit.rest?.pulls?.get === 'function'\n        ) {\n          try {\n            const { data } = await octokit.rest.pulls.get({\n              owner: repoObj.owner,\n              repo: repoObj.name,\n              pull_number: prNum,\n            });\n            headSha = (data && (data as any).head && (data as any).head.sha) || headSha;\n          } catch {\n            // ignore; headSha remains undefined\n          }\n        }\n        // Make the event bus available to providers via executionContext\n        try {\n          const prev: any = this.getExecutionContext() || {};\n          this.setExecutionContext({ ...prev, eventBus: bus });\n          // Also reflect it into the active engine context so downstream providers see it\n          try {\n            (context as any).executionContext = this.getExecutionContext();\n          } catch {}\n        } catch {}\n\n        await frontendsHost.startAll(() => ({\n          eventBus: bus,\n          logger,\n          // Provide the active (possibly tag-filtered) config so frontends can read groups, etc.\n          config: configWithTagFilter,\n          run: {\n            runId: (context as any).sessionId,\n            repo: repoObj,\n            pr: prNum,\n            headSha,\n            event: (context as any).event || (prInfo as any)?.eventType,\n            actor:\n              (prInfo as any)?.eventContext?.sender?.login ||\n              (typeof process.env.GITHUB_ACTOR === 'string' ? process.env.GITHUB_ACTOR : undefined),\n          },\n          octokit,\n          webhookContext: (this.executionContext as any)?.webhookContext,\n          // Surface any injected test doubles for Slack as well\n          slack:\n            (this.executionContext as any)?.slack || (this.executionContext as any)?.slackClient,\n        }));\n\n        // Phase 1: Snapshot on HumanInputRequested (experimental pause support)\n        try {\n          bus.on('HumanInputRequested', async (envelope: any) => {\n            try {\n              const ev = (envelope && envelope.payload) || envelope;\n              // Determine channel/thread from event or inbound payload\n              let channel: string | undefined = ev?.channel;\n              let threadTs: string | undefined = ev?.threadTs;\n              if (!channel || !threadTs) {\n                try {\n                  const anyCfg: any = configWithTagFilter || {};\n                  const slackCfg: any = anyCfg.slack || {};\n                  const endpoint: string = slackCfg.endpoint || '/bots/slack/support';\n                  const map = (this.executionContext as any)?.webhookContext?.webhookData as\n                    | Map<string, unknown>\n                    | undefined;\n                  const payload: any = map?.get(endpoint);\n                  const e: any = payload?.event;\n                  const derivedTs = String(e?.thread_ts || e?.ts || e?.event_ts || '');\n                  const derivedCh = String(e?.channel || '');\n                  if (derivedCh && derivedTs) {\n                    channel = channel || derivedCh;\n                    threadTs = threadTs || derivedTs;\n                  }\n                } catch {}\n              }\n\n              const checkId = String(ev?.checkId || 'unknown');\n              const threadKey =\n                ev?.threadKey || (channel && threadTs ? `${channel}:${threadTs}` : 'session');\n              const baseDir =\n                process.env.VISOR_SNAPSHOT_DIR ||\n                path.resolve(process.cwd(), '.visor', 'snapshots');\n              fs.mkdirSync(baseDir, { recursive: true });\n              const filePath = path.join(baseDir, `${threadKey}-${checkId}.json`);\n              await this.saveSnapshotToFile(filePath);\n              logger.info(`[Snapshot] Saved run snapshot: ${filePath}`);\n              try {\n                await bus.emit({\n                  type: 'SnapshotSaved',\n                  checkId: ev?.checkId || 'unknown',\n                  channel,\n                  threadTs,\n                  threadKey,\n                  filePath,\n                });\n              } catch {}\n            } catch (e) {\n              logger.warn(\n                `[Snapshot] Failed to save snapshot on HumanInputRequested: ${\n                  e instanceof Error ? e.message : String(e)\n                }`\n              );\n            }\n          });\n        } catch {}\n      } catch (err) {\n        logger.warn(\n          `[Frontends] Failed to initialize frontends: ${err instanceof Error ? err.message : String(err)}`\n        );\n      }\n    }\n\n    // Create and run state machine with debug server support (M4)\n    const runner = new StateMachineRunner(context, this.debugServer);\n    this._lastRunner = runner;\n\n    try {\n      const result = await runner.run();\n\n      // Stop frontends if started\n      if (frontendsHost && typeof frontendsHost.stopAll === 'function') {\n        try {\n          await frontendsHost.stopAll();\n        } catch {}\n      }\n\n      if (debug) {\n        logger.info('[StateMachine] Execution complete');\n      }\n\n      // Post-grouped comments via legacy reviewer is removed; GitHub frontend handles comments\n\n      // Cleanup AI sessions after execution\n      try {\n        const { SessionRegistry } = await import('./session-registry');\n        const sessionRegistry = SessionRegistry.getInstance();\n        sessionRegistry.clearAllSessions();\n      } catch (error) {\n        logger.debug(`[StateMachine] Failed to cleanup sessions: ${error}`);\n      }\n\n      // Cleanup workspace if enabled\n      if (context.workspace) {\n        try {\n          await context.workspace.cleanup();\n        } catch (error) {\n          logger.debug(`[StateMachine] Failed to cleanup workspace: ${error}`);\n        }\n      }\n\n      return result;\n    } finally {\n      // Cleanup sandbox containers\n      if (context.sandboxManager) {\n        await context.sandboxManager.stopAll().catch(err => {\n          logger.warn(`Failed to stop sandboxes: ${err}`);\n        });\n        context.sandboxManager = undefined;\n      }\n    }\n  }\n\n  /**\n   * Build the engine context for state machine execution\n   */\n  private buildEngineContext(\n    config: VisorConfig,\n    prInfo: PRInfo,\n    debug?: boolean,\n    maxParallelism?: number,\n    failFast?: boolean,\n    requestedChecks?: string[]\n  ): EngineContext {\n    const { buildEngineContextForRun } = require('./state-machine/context/build-engine-context');\n    return buildEngineContextForRun(\n      this.workingDirectory,\n      config,\n      prInfo,\n      debug,\n      maxParallelism,\n      failFast,\n      requestedChecks\n    );\n  }\n\n  /**\n   * Get output history snapshot for test framework compatibility\n   * Extracts output history from the journal\n   */\n  public getOutputHistorySnapshot(): Record<string, unknown[]> {\n    // Get the journal from the last execution context\n    const journal = (this as any)._lastContext?.journal as ExecutionJournal | undefined;\n    if (!journal) {\n      logger.debug('[StateMachine][DEBUG] getOutputHistorySnapshot: No journal found');\n      return {};\n    }\n\n    const sessionId = (this as any)._lastContext?.sessionId as string | undefined;\n    if (!sessionId) {\n      logger.debug('[StateMachine][DEBUG] getOutputHistorySnapshot: No sessionId found');\n      return {};\n    }\n\n    // Read all journal entries for this session\n    const snapshot = journal.beginSnapshot();\n    const allEntries = journal.readVisible(sessionId, snapshot, undefined);\n\n    logger.debug(\n      `[StateMachine][DEBUG] getOutputHistorySnapshot: Found ${allEntries.length} journal entries`\n    );\n\n    // Group by checkId and extract outputs\n    const outputHistory: Record<string, unknown[]> = {};\n    for (const entry of allEntries) {\n      const checkId = entry.checkId;\n\n      if (!outputHistory[checkId]) {\n        outputHistory[checkId] = [];\n      }\n      // Skip journal stubs for skipped checks\n      try {\n        if (entry && typeof entry.result === 'object' && (entry.result as any).__skipped) {\n          continue;\n        }\n      } catch {}\n\n      // Prefer explicit .output; fall back to the full result (issues/content)\n      // so tests and templates can reference paths like issues[0].severity for\n      // code-review schema steps which do not set a separate output object.\n      const payload =\n        entry.result.output !== undefined ? entry.result.output : (entry.result as unknown);\n\n      // Filter out forEach aggregation metadata objects (which contain a\n      // forEachItems array) to avoid double-counting per-item executions in\n      // tests. The actual per-item outputs are committed as separate entries\n      // and should be used for history-based assertions and routing.\n      try {\n        if (\n          payload &&\n          typeof payload === 'object' &&\n          (payload as any).forEachItems &&\n          Array.isArray((payload as any).forEachItems)\n        ) {\n          continue;\n        }\n      } catch {}\n\n      if (payload !== undefined) outputHistory[checkId].push(payload);\n    }\n\n    logger.debug(\n      `[StateMachine][DEBUG] getOutputHistorySnapshot result: ${JSON.stringify(Object.keys(outputHistory))}`\n    );\n    for (const [checkId, outputs] of Object.entries(outputHistory)) {\n      logger.debug(`[StateMachine][DEBUG]   ${checkId}: ${outputs.length} outputs`);\n    }\n\n    return outputHistory;\n  }\n\n  /**\n   * Save a JSON snapshot of the last run's state and journal to a file (experimental).\n   * Does not include secrets. Intended for debugging and future resume support.\n   */\n  public async saveSnapshotToFile(filePath: string): Promise<void> {\n    const fs = await import('fs/promises');\n    const ctx = this._lastContext;\n    const runner = this._lastRunner;\n    if (!ctx || !runner) {\n      throw new Error('No prior execution context to snapshot');\n    }\n    const journal = (ctx as any).journal as ExecutionJournal;\n    const snapshotId = journal.beginSnapshot();\n    const entries = journal.readVisible(ctx.sessionId, snapshotId, undefined);\n    const state = runner.getState();\n    const serializableState = serializeRunState(state);\n    const payload = {\n      version: 1,\n      sessionId: ctx.sessionId,\n      event: ctx.event,\n      wave: state.wave,\n      state: serializableState,\n      journal: entries,\n      requestedChecks: (ctx as any).requestedChecks || [],\n    } as const;\n    await fs.writeFile(filePath, JSON.stringify(payload, null, 2), 'utf8');\n  }\n\n  /**\n   * Load a snapshot JSON from file and return it. Resume support can build on this.\n   */\n  public async loadSnapshotFromFile<T = unknown>(filePath: string): Promise<T> {\n    const fs = await import('fs/promises');\n    const raw = await fs.readFile(filePath, 'utf8');\n    return JSON.parse(raw) as T;\n  }\n\n  /**\n   * Filter checks by tag filter\n   */\n  private filterChecksByTags(\n    checks: string[],\n    config: VisorConfig | undefined,\n    tagFilter: import('./types/config').TagFilter | undefined\n  ): string[] {\n    // When no tag filter is specified, include only untagged checks by default.\n    // Tagged checks are opt-in unless tag_filter is provided.\n    return checks.filter(checkName => {\n      const checkConfig = config?.checks?.[checkName];\n      if (!checkConfig) {\n        // If no config for this check, include it by default\n        return true;\n      }\n\n      const checkTags = checkConfig.tags || [];\n\n      // If no tag filter is specified, include only untagged checks.\n      if (!tagFilter || (!tagFilter.include && !tagFilter.exclude)) {\n        return checkTags.length === 0;\n      }\n\n      // If check has no tags and a tag filter is specified, include it (untagged checks always run)\n      if (checkTags.length === 0) {\n        return true;\n      }\n\n      // Check exclude tags first (if any exclude tag matches, skip the check)\n      if (tagFilter.exclude && tagFilter.exclude.length > 0) {\n        const hasExcludedTag = tagFilter.exclude.some(tag => checkTags.includes(tag));\n        if (hasExcludedTag) return false;\n      }\n\n      // Check include tags (if specified, at least one must match)\n      if (tagFilter.include && tagFilter.include.length > 0) {\n        const hasIncludedTag = tagFilter.include.some(tag => checkTags.includes(tag));\n        if (!hasIncludedTag) return false;\n      }\n\n      return true;\n    });\n  }\n\n  /**\n   * Create an error result in AnalysisResult format\n   */\n  private createErrorResult(\n    repositoryInfo: import('./git-repository-analyzer').GitRepositoryInfo,\n    errorMessage: string,\n    startTime: number,\n    timestamp: string,\n    checksExecuted: string[]\n  ): AnalysisResult {\n    const executionTime = Date.now() - startTime;\n\n    return {\n      repositoryInfo,\n      reviewSummary: {\n        issues: [\n          {\n            file: 'system',\n            line: 0,\n            endLine: undefined,\n            ruleId: 'system/error',\n            message: errorMessage,\n            severity: 'error',\n            category: 'logic',\n            suggestion: undefined,\n            replacement: undefined,\n          },\n        ],\n      },\n      executionTime,\n      timestamp,\n      checksExecuted,\n    };\n  }\n\n  /**\n   * Convert GroupedCheckResults to ReviewSummary\n   * Aggregates all check results into a single ReviewSummary\n   */\n  private convertGroupedResultsToReviewSummary(\n    groupedResults: import('./reviewer').GroupedCheckResults,\n    statistics?: import('./types/execution').ExecutionStatistics\n  ): import('./reviewer').ReviewSummary {\n    const { convertToReviewSummary } = require('./state-machine/execution/summary');\n    return (convertToReviewSummary as any)(groupedResults as any, statistics as any) as any;\n  }\n\n  /**\n   * Evaluate failure conditions for a check result\n   *\n   * This method provides backward compatibility with the legacy engine by\n   * delegating to the FailureConditionEvaluator.\n   *\n   * @param checkName - The name of the check being evaluated\n   * @param reviewSummary - The review summary containing check results\n   * @param config - The Visor configuration containing failure conditions\n   * @param previousOutputs - Optional previous check outputs for cross-check conditions\n   * @param authorAssociation - Optional GitHub author association for permission checks\n   * @returns Array of failure condition evaluation results\n   */\n  async evaluateFailureConditions(\n    checkName: string,\n    reviewSummary: import('./reviewer').ReviewSummary,\n    config: VisorConfig,\n    previousOutputs?: Record<string, import('./reviewer').ReviewSummary>,\n    authorAssociation?: string\n  ): Promise<import('./types/config').FailureConditionResult[]> {\n    const { FailureConditionEvaluator } = await import('./failure-condition-evaluator');\n    const evaluator = new FailureConditionEvaluator();\n    const { addEvent } = await import('./telemetry/trace-helpers');\n    const { addFailIfTriggered } = await import('./telemetry/metrics');\n\n    // Extract check configuration\n    const checkConfig = config.checks?.[checkName];\n    if (!checkConfig) {\n      return [];\n    }\n\n    // Schema can be string or Record<string, unknown>, convert to string for evaluation\n    const rawSchema = checkConfig.schema || 'code-review';\n    const checkSchema = typeof rawSchema === 'string' ? rawSchema : 'code-review';\n    const checkGroup = checkConfig.group || 'default';\n\n    // Handle both fail_if (simple string) and failure_conditions (complex object)\n    const results: import('./types/config').FailureConditionResult[] = [];\n\n    // Evaluate global fail_if\n    if (config.fail_if) {\n      const failed = await evaluator.evaluateSimpleCondition(\n        checkName,\n        checkSchema,\n        checkGroup,\n        reviewSummary,\n        config.fail_if,\n        previousOutputs || {}\n      );\n\n      // Telemetry events + metric\n      try {\n        addEvent('fail_if.evaluated', {\n          'visor.check.id': checkName,\n          scope: 'global',\n          expression: String(config.fail_if),\n          result: failed ? 'triggered' : 'not_triggered',\n        });\n        if (failed) {\n          addEvent('fail_if.triggered', {\n            'visor.check.id': checkName,\n            scope: 'global',\n            expression: String(config.fail_if),\n          });\n          addFailIfTriggered(checkName, 'global');\n        }\n      } catch {}\n\n      results.push({\n        conditionName: 'global_fail_if',\n        failed,\n        expression: config.fail_if,\n        message: failed ? `Global failure condition met: ${config.fail_if}` : undefined,\n        severity: 'error',\n        haltExecution: false,\n      });\n    }\n\n    // Evaluate check-specific fail_if (overrides global if present)\n    if (checkConfig.fail_if) {\n      const failed = await evaluator.evaluateSimpleCondition(\n        checkName,\n        checkSchema,\n        checkGroup,\n        reviewSummary,\n        checkConfig.fail_if,\n        previousOutputs || {}\n      );\n\n      // Telemetry events + metric\n      try {\n        addEvent('fail_if.evaluated', {\n          'visor.check.id': checkName,\n          scope: 'check',\n          expression: String(checkConfig.fail_if),\n          result: failed ? 'triggered' : 'not_triggered',\n        });\n        if (failed) {\n          addEvent('fail_if.triggered', {\n            'visor.check.id': checkName,\n            scope: 'check',\n            expression: String(checkConfig.fail_if),\n          });\n          addFailIfTriggered(checkName, 'check');\n        }\n      } catch {}\n\n      results.push({\n        conditionName: `${checkName}_fail_if`,\n        failed,\n        expression: checkConfig.fail_if,\n        message: failed ? `Check failure condition met: ${checkConfig.fail_if}` : undefined,\n        severity: 'error',\n        haltExecution: false,\n      });\n    }\n\n    // Also evaluate legacy failure_conditions if present\n    const globalConditions = config.failure_conditions;\n    const checkConditions = checkConfig.failure_conditions;\n\n    if (globalConditions || checkConditions) {\n      const legacyResults = await evaluator.evaluateConditions(\n        checkName,\n        checkSchema,\n        checkGroup,\n        reviewSummary,\n        globalConditions,\n        checkConditions,\n        previousOutputs,\n        authorAssociation\n      );\n      results.push(...legacyResults);\n    }\n\n    return results;\n  }\n\n  /**\n   * Get repository status\n   * @returns Repository status information\n   */\n  async getRepositoryStatus(): Promise<{\n    isGitRepository: boolean;\n    branch?: string;\n    hasChanges: boolean;\n    filesChanged?: number;\n  }> {\n    try {\n      const { GitRepositoryAnalyzer } = await import('./git-repository-analyzer');\n      const analyzer = new GitRepositoryAnalyzer(this.workingDirectory);\n      const info = await analyzer.analyzeRepository();\n\n      return {\n        isGitRepository: info.isGitRepository,\n        branch: info.head, // Use head as branch name\n        hasChanges: info.isGitRepository && (info.files?.length > 0 || false),\n        filesChanged: info.isGitRepository ? info.files?.length || 0 : 0,\n      };\n    } catch {\n      return {\n        isGitRepository: false,\n        hasChanges: false,\n      };\n    }\n  }\n\n  /**\n   * Check if current directory is a git repository\n   * @returns True if git repository, false otherwise\n   */\n  async isGitRepository(): Promise<boolean> {\n    const status = await this.getRepositoryStatus();\n    return status.isGitRepository;\n  }\n\n  /**\n   * Get list of available check types\n   * @returns Array of check type names\n   */\n  static getAvailableCheckTypes(): string[] {\n    const { CheckProviderRegistry } = require('./providers/check-provider-registry');\n    const registry = CheckProviderRegistry.getInstance();\n    return registry.getAvailableProviders();\n  }\n\n  /**\n   * Validate check types and return valid/invalid lists\n   * @param checks - Array of check type names to validate\n   * @returns Object with valid and invalid check types\n   */\n  static validateCheckTypes(checks: string[]): { valid: string[]; invalid: string[] } {\n    const availableTypes = StateMachineExecutionEngine.getAvailableCheckTypes();\n    const valid: string[] = [];\n    const invalid: string[] = [];\n\n    for (const check of checks) {\n      if (availableTypes.includes(check)) {\n        valid.push(check);\n      } else {\n        invalid.push(check);\n      }\n    }\n\n    return { valid, invalid };\n  }\n\n  /**\n   * Format the status column for execution statistics\n   * Used by execution-statistics-formatting tests\n   */\n  private formatStatusColumn(stats: import('./types/execution').CheckExecutionStats): string {\n    if (stats.skipped) {\n      // Format skip reason\n      if (stats.skipReason === 'if_condition') {\n        return ' if';\n      } else if (stats.skipReason === 'fail_fast') {\n        return ' ff';\n      } else if (stats.skipReason === 'dependency_failed') {\n        return ' dep';\n      }\n      return '';\n    }\n\n    const totalRuns = stats.totalRuns;\n    const successfulRuns = stats.successfulRuns;\n    const failedRuns = stats.failedRuns;\n\n    if (failedRuns > 0 && successfulRuns > 0) {\n      // Mixed results\n      return `/ ${successfulRuns}/${totalRuns}`;\n    } else if (failedRuns > 0) {\n      // All failed\n      return totalRuns === 1 ? '' : ` ${totalRuns}`;\n    } else {\n      // All successful\n      return totalRuns === 1 ? '' : ` ${totalRuns}`;\n    }\n  }\n\n  /**\n   * Format the details column for execution statistics\n   * Used by execution-statistics-formatting tests\n   */\n  private formatDetailsColumn(stats: import('./types/execution').CheckExecutionStats): string {\n    const parts: string[] = [];\n\n    // Add outputs produced\n    if (stats.outputsProduced !== undefined && stats.outputsProduced > 0) {\n      parts.push(`${stats.outputsProduced}`);\n    }\n\n    // Add critical issues\n    if (stats.issuesBySeverity.critical > 0) {\n      parts.push(`${stats.issuesBySeverity.critical}`);\n    }\n\n    // Add error issues (only if no critical)\n    if (stats.issuesBySeverity.error > 0 && stats.issuesBySeverity.critical === 0) {\n      parts.push(`${stats.issuesBySeverity.error}`);\n    }\n\n    // Add warnings\n    if (stats.issuesBySeverity.warning > 0) {\n      parts.push(`${stats.issuesBySeverity.warning}`);\n    }\n\n    // Add info issues (only if no critical/error/warning)\n    if (\n      stats.issuesBySeverity.info > 0 &&\n      stats.issuesBySeverity.critical === 0 &&\n      stats.issuesBySeverity.error === 0 &&\n      stats.issuesBySeverity.warning === 0\n    ) {\n      parts.push(`${stats.issuesBySeverity.info}`);\n    }\n\n    // Add error message if present\n    if (stats.errorMessage) {\n      parts.push(this.truncate(stats.errorMessage, 40));\n    }\n\n    // Add skip condition if present\n    if (stats.skipCondition) {\n      parts.push(this.truncate(stats.skipCondition, 40));\n    }\n\n    return parts.join(' ');\n  }\n\n  /**\n   * Truncate a string to a maximum length\n   * Used by formatDetailsColumn\n   */\n  private truncate(str: string, maxLength: number): string {\n    if (str.length <= maxLength) {\n      return str;\n    }\n    return str.substring(0, maxLength - 3) + '...';\n  }\n}\n\n/** Convert RunState with Maps/Sets into a JSON-safe form */\nfunction serializeRunState(state: import('./types/engine').RunState) {\n  return {\n    ...state,\n    levelQueue: state.levelQueue,\n    eventQueue: state.eventQueue,\n    activeDispatches: Array.from(state.activeDispatches.entries()),\n    completedChecks: Array.from(state.completedChecks.values()),\n    stats: Array.from(state.stats.entries()),\n    historyLog: state.historyLog,\n    forwardRunGuards: Array.from(state.forwardRunGuards.values()),\n    currentLevelChecks: Array.from(state.currentLevelChecks.values()),\n    currentWaveCompletions: Array.from(\n      ((state as any).currentWaveCompletions as Set<string> | undefined) || []\n    ),\n    // failedChecks is an internal Set added by stats/dispatch layers; keep it if present\n    failedChecks: Array.from(((state as any).failedChecks as Set<string> | undefined) || []),\n    pendingRunScopes: Array.from((state.pendingRunScopes || new Map()).entries()).map(([k, v]) => [\n      k,\n      v,\n    ]),\n  };\n}\n\nexport type SnapshotJson = {\n  version: number;\n  sessionId: string;\n  event?: import('./types/config').EventTrigger;\n  wave?: number;\n  state: any;\n  journal: import('./snapshot-store').JournalEntry[];\n  requestedChecks?: string[];\n  meta?: Record<string, unknown>;\n};\n\n/**\n * Resume execution from a previously saved snapshot (experimental).\n * Frontends are started to mirror executeGroupedChecks behavior so integrations\n * like Slack can handle CheckCompleted/HumanInputRequested events during resume.\n */\nexport async function resumeFromSnapshot(\n  engine: StateMachineExecutionEngine,\n  snapshot: SnapshotJson,\n  config: VisorConfig,\n  opts?: { debug?: boolean; maxParallelism?: number; failFast?: boolean; webhookContext?: any }\n): Promise<import('./types/execution').ExecutionResult> {\n  // Recompute PRInfo from the current repository\n  const { GitRepositoryAnalyzer } = await import('./git-repository-analyzer');\n  const analyzer = new GitRepositoryAnalyzer(process.cwd());\n  const repoInfo = await analyzer.analyzeRepository();\n  const prInfo = analyzer.toPRInfo(repoInfo);\n\n  const context = (engine as any).buildEngineContext(\n    config,\n    prInfo,\n    opts?.debug,\n    opts?.maxParallelism,\n    opts?.failFast,\n    snapshot.requestedChecks\n  ) as import('./types/engine').EngineContext;\n\n  // Initialize workspace isolation (if enabled) - same as executeGroupedChecks\n  const { initializeWorkspace } = require('./state-machine/context/build-engine-context');\n  await initializeWorkspace(context);\n\n  // Propagate existing executionContext (hooks, octokit, webhookContext, slack, etc.)\n  try {\n    const prevExecCtx: any = (engine as any).getExecutionContext?.() || {};\n    (context as any).executionContext = prevExecCtx;\n  } catch {}\n\n  // Restore journal entries\n  try {\n    const journal = (context as any).journal as ExecutionJournal;\n    for (const e of snapshot.journal || []) {\n      journal.commitEntry({\n        // Re-hydrate all entries under the NEW sessionId for this resume run.\n        // This ensures helpers like output history and chat_history see both\n        // pre-snapshot and post-resume outputs as a single logical session.\n        sessionId: (context as any).sessionId,\n        scope: e.scope,\n        checkId: e.checkId,\n        result: e.result,\n        event: e.event,\n      });\n    }\n  } catch {}\n\n  // Adopt webhookContext and other execution context patches if provided\n  try {\n    const prev: any = (engine as any).getExecutionContext?.() || {};\n    (engine as any).setExecutionContext?.({ ...prev, webhookContext: opts?.webhookContext });\n    // Reflect merged executionContext into active engine context\n    try {\n      (context as any).executionContext = (engine as any).getExecutionContext?.();\n    } catch {}\n  } catch {}\n\n  // Optional frontends (Slack, GitHub, etc.)  mirror executeGroupedChecks\n  let frontendsHost: any | undefined;\n  if (Array.isArray((config as any).frontends) && (config as any).frontends.length > 0) {\n    try {\n      const { EventBus } = await import('./event-bus/event-bus');\n      const { FrontendsHost } = await import('./frontends/host');\n      const bus = new EventBus();\n      (context as any).eventBus = bus;\n      frontendsHost = new FrontendsHost(bus, logger);\n\n      if (process.env.VISOR_DEBUG === 'true') {\n        try {\n          const fns = ((config as any).frontends || []).map((f: any) => ({\n            name: f?.name,\n            hasConfig: !!f?.config,\n            cfg: f?.config || undefined,\n          }));\n          logger.info(`[Frontends] Loading specs: ${JSON.stringify(fns)}`);\n        } catch {}\n      }\n\n      await frontendsHost.load((config as any).frontends);\n\n      // Derive repo/pr/headSha and octokit if available\n      let owner: string | undefined;\n      let name: string | undefined;\n      let prNum: number | undefined;\n      let headSha: string | undefined;\n      try {\n        const anyInfo: any = prInfo as any;\n        owner =\n          anyInfo?.eventContext?.repository?.owner?.login ||\n          process.env.GITHUB_REPOSITORY?.split('/')?.[0];\n        name =\n          anyInfo?.eventContext?.repository?.name || process.env.GITHUB_REPOSITORY?.split('/')?.[1];\n        prNum = typeof anyInfo?.number === 'number' ? anyInfo.number : undefined;\n        headSha = anyInfo?.eventContext?.pull_request?.head?.sha || process.env.GITHUB_SHA;\n      } catch {}\n      const repoObj = owner && name ? { owner, name } : undefined;\n      const octokit = (engine as any).getExecutionContext?.()?.octokit;\n\n      // Fallback: if headSha is missing but we have PR info and octokit, fetch it\n      if (\n        !headSha &&\n        repoObj &&\n        prNum &&\n        octokit &&\n        typeof octokit.rest?.pulls?.get === 'function'\n      ) {\n        try {\n          const { data } = await octokit.rest.pulls.get({\n            owner: repoObj.owner,\n            repo: repoObj.name,\n            pull_number: prNum,\n          });\n          headSha = (data && (data as any).head && (data as any).head.sha) || headSha;\n        } catch {\n          // ignore; headSha remains undefined\n        }\n      }\n\n      // Make the event bus available to providers via executionContext\n      try {\n        const prevExec: any = (engine as any).getExecutionContext?.() || {};\n        (engine as any).setExecutionContext?.({ ...prevExec, eventBus: bus });\n        try {\n          (context as any).executionContext = (engine as any).getExecutionContext?.();\n        } catch {}\n      } catch {}\n\n      await frontendsHost.startAll(() => ({\n        eventBus: bus,\n        logger,\n        // Provide the active config so frontends can read groups, etc.\n        config,\n        run: {\n          runId: (context as any).sessionId,\n          repo: repoObj,\n          pr: prNum,\n          headSha,\n          event: (context as any).event || (prInfo as any)?.eventType,\n          actor:\n            (prInfo as any)?.eventContext?.sender?.login ||\n            (typeof process.env.GITHUB_ACTOR === 'string' ? process.env.GITHUB_ACTOR : undefined),\n        },\n        octokit,\n        webhookContext: (engine as any).getExecutionContext?.()?.webhookContext,\n        // Surface any injected test doubles for Slack as well\n        slack:\n          (engine as any).getExecutionContext?.()?.slack ||\n          (engine as any).getExecutionContext?.()?.slackClient,\n      }));\n\n      // Snapshot-on-human-input support for resumed runs\n      try {\n        bus.on('HumanInputRequested', async (envelope: any) => {\n          try {\n            const ev = (envelope && envelope.payload) || envelope;\n            // Determine channel/thread from event or inbound payload\n            let channel: string | undefined = ev?.channel;\n            let threadTs: string | undefined = ev?.threadTs;\n            if (!channel || !threadTs) {\n              try {\n                const anyCfg: any = config || {};\n                const slackCfg: any = anyCfg.slack || {};\n                const endpoint: string = slackCfg.endpoint || '/bots/slack/support';\n                const map = (engine as any).getExecutionContext?.()?.webhookContext?.webhookData as\n                  | Map<string, unknown>\n                  | undefined;\n                const payload: any = map?.get(endpoint);\n                const e: any = payload?.event;\n                const derivedTs = String(e?.thread_ts || e?.ts || e?.event_ts || '');\n                const derivedCh = String(e?.channel || '');\n                if (derivedCh && derivedTs) {\n                  channel = channel || derivedCh;\n                  threadTs = threadTs || derivedTs;\n                }\n              } catch {}\n            }\n\n            const checkId = String(ev?.checkId || 'unknown');\n            const threadKey =\n              ev?.threadKey || (channel && threadTs ? `${channel}:${threadTs}` : 'session');\n            const baseDir =\n              process.env.VISOR_SNAPSHOT_DIR || path.resolve(process.cwd(), '.visor', 'snapshots');\n            fs.mkdirSync(baseDir, { recursive: true });\n            const filePath = path.join(baseDir, `${threadKey}-${checkId}.json`);\n            await engine.saveSnapshotToFile(filePath);\n            logger.info(`[Snapshot] Saved run snapshot: ${filePath}`);\n            try {\n              await bus.emit({\n                type: 'SnapshotSaved',\n                checkId: ev?.checkId || 'unknown',\n                channel,\n                threadTs,\n                threadKey,\n                filePath,\n              });\n            } catch {}\n          } catch (e) {\n            logger.warn(\n              `[Snapshot] Failed to save snapshot on HumanInputRequested: ${\n                e instanceof Error ? e.message : String(e)\n              }`\n            );\n          }\n        });\n      } catch {}\n    } catch (err) {\n      logger.warn(\n        `[Frontends] Failed to initialize frontends (resumeFromSnapshot): ${\n          err instanceof Error ? err.message : String(err)\n        }`\n      );\n    }\n  }\n\n  // Create runner and hydrate state\n  // For resume flows, we treat the snapshot's journal as prior history and\n  // start a fresh run from the normal Init  PlanReady  WavePlanning cycle.\n  // This avoids resuming mid-wave and accidentally re-running stale checks\n  // (e.g., chat replies) before new input is incorporated.\n  const runner = new (require('./state-machine/runner').StateMachineRunner)(\n    context,\n    (engine as any).debugServer\n  );\n  (engine as any)._lastContext = context;\n  (engine as any)._lastRunner = runner;\n\n  const result = await runner.run();\n\n  // Stop frontends if started\n  if (frontendsHost && typeof frontendsHost.stopAll === 'function') {\n    try {\n      await frontendsHost.stopAll();\n    } catch {}\n  }\n\n  // Cleanup AI sessions after execution\n  try {\n    const { SessionRegistry } = await import('./session-registry');\n    const sessionRegistry = SessionRegistry.getInstance();\n    sessionRegistry.clearAllSessions();\n  } catch (error) {\n    logger.debug(`[StateMachine] Failed to cleanup sessions: ${error}`);\n  }\n\n  return result;\n}\n","/**\n * SandboxManager  lifecycle management for Docker sandbox environments.\n * Handles lazy container startup, reuse, exec routing, and cleanup.\n */\n\nimport { resolve, dirname } from 'path';\nimport { SandboxConfig, SandboxInstance, SandboxExecOptions, SandboxExecResult } from './types';\nimport { DockerImageSandbox } from './docker-image-sandbox';\nimport { DockerComposeSandbox } from './docker-compose-sandbox';\nimport { CacheVolumeManager } from './cache-volume-manager';\nimport { logger } from '../logger';\nimport { withActiveSpan, addEvent } from './sandbox-telemetry';\n\nexport class SandboxManager {\n  private sandboxDefs: Record<string, SandboxConfig>;\n  private repoPath: string;\n  private gitBranch: string;\n  private instances: Map<string, SandboxInstance> = new Map();\n  private cacheManager: CacheVolumeManager;\n  private visorDistPath: string;\n\n  /** Get the resolved repository path (used by trace file relay) */\n  getRepoPath(): string {\n    return this.repoPath;\n  }\n\n  constructor(sandboxDefs: Record<string, SandboxConfig>, repoPath: string, gitBranch: string) {\n    this.sandboxDefs = sandboxDefs;\n    this.repoPath = resolve(repoPath);\n    this.gitBranch = gitBranch;\n    this.cacheManager = new CacheVolumeManager();\n\n    // Visor dist path: the directory containing this compiled JS file's parent\n    // In development: <project>/dist/sandbox/sandbox-manager.js  <project>/dist\n    // We mount the parent of 'dist' along with node_modules\n    this.visorDistPath = resolve(dirname(__dirname));\n  }\n\n  /**\n   * Resolve which sandbox a check should use.\n   * Returns null if the check should run on the host.\n   *\n   * Resolution order:\n   * 1. Check-level sandbox: (explicit override)\n   * 2. Workspace-level sandbox: (default)\n   * 3. null  run on host\n   */\n  resolveSandbox(\n    checkSandbox: string | undefined,\n    workspaceDefault: string | undefined\n  ): string | null {\n    const name = checkSandbox || workspaceDefault;\n    if (!name) return null;\n\n    if (!this.sandboxDefs[name]) {\n      throw new Error(`Sandbox '${name}' is not defined in sandboxes configuration`);\n    }\n\n    return name;\n  }\n\n  /**\n   * Get or lazily start a sandbox instance by name.\n   */\n  async getOrStart(name: string): Promise<SandboxInstance> {\n    const existing = this.instances.get(name);\n    if (existing) return existing;\n\n    const config = this.sandboxDefs[name];\n    if (!config) {\n      throw new Error(`Sandbox '${name}' is not defined`);\n    }\n\n    const mode = config.compose ? 'compose' : 'image';\n\n    return withActiveSpan(\n      'visor.sandbox.start',\n      {\n        'visor.sandbox.name': name,\n        'visor.sandbox.mode': mode,\n      },\n      async () => {\n        let instance: SandboxInstance;\n\n        if (config.compose) {\n          // Compose mode\n          const composeSandbox = new DockerComposeSandbox(name, config);\n          await composeSandbox.start();\n          instance = composeSandbox;\n        } else {\n          // Image / Dockerfile mode\n          // Resolve cache volumes\n          let cacheVolumeMounts: string[] = [];\n          if (config.cache) {\n            const volumes = await this.cacheManager.resolveVolumes(\n              name,\n              config.cache,\n              this.gitBranch\n            );\n            cacheVolumeMounts = volumes.map(v => v.mountSpec);\n          }\n\n          const imageSandbox = new DockerImageSandbox(\n            name,\n            config,\n            this.repoPath,\n            this.visorDistPath,\n            cacheVolumeMounts\n          );\n          await imageSandbox.start();\n          instance = imageSandbox;\n        }\n\n        this.instances.set(name, instance);\n        return instance;\n      }\n    );\n  }\n\n  /**\n   * Execute a command inside a named sandbox\n   */\n  async exec(name: string, options: SandboxExecOptions): Promise<SandboxExecResult> {\n    const instance = await this.getOrStart(name);\n    return withActiveSpan(\n      'visor.sandbox.exec',\n      {\n        'visor.sandbox.name': name,\n      },\n      async (span: any) => {\n        const result = await instance.exec(options);\n        try {\n          span.setAttribute('visor.sandbox.exit_code', result.exitCode);\n        } catch {}\n        return result;\n      }\n    );\n  }\n\n  /**\n   * Stop all running sandbox instances and run cache eviction\n   */\n  async stopAll(): Promise<void> {\n    return withActiveSpan('visor.sandbox.stopAll', undefined, async () => {\n      const stopPromises = Array.from(this.instances.entries()).map(async ([name, instance]) => {\n        try {\n          await instance.stop();\n          addEvent('visor.sandbox.stopped', { 'visor.sandbox.name': name });\n          logger.info(`Stopped sandbox '${name}'`);\n        } catch (err) {\n          logger.warn(`Failed to stop sandbox '${name}': ${err}`);\n        }\n\n        // Run cache eviction\n        const config = this.sandboxDefs[name];\n        if (config?.cache) {\n          try {\n            await this.cacheManager.evictExpired(name, config.cache.ttl, config.cache.max_scopes);\n          } catch {\n            // Non-fatal\n          }\n        }\n      });\n\n      await Promise.allSettled(stopPromises);\n      this.instances.clear();\n    });\n  }\n}\n","/**\n * Docker image-based sandbox implementation.\n * Supports three modes: pre-built image, Dockerfile, and inline Dockerfile.\n */\n\nimport { promisify } from 'util';\nimport { exec as execCb } from 'child_process';\nimport { writeFileSync, unlinkSync, mkdtempSync } from 'fs';\nimport { join } from 'path';\nimport { tmpdir } from 'os';\nimport { randomUUID } from 'crypto';\nimport { SandboxConfig, SandboxExecOptions, SandboxExecResult, SandboxInstance } from './types';\nimport { logger } from '../logger';\nimport { withActiveSpan, addEvent } from './sandbox-telemetry';\n\nconst execAsync = promisify(execCb);\n\nconst EXEC_MAX_BUFFER = 50 * 1024 * 1024; // 50MB\n\nexport class DockerImageSandbox implements SandboxInstance {\n  name: string;\n  config: SandboxConfig;\n  private containerId: string | null = null;\n  private containerName: string;\n  private repoPath: string;\n  private visorDistPath: string;\n  private cacheVolumeMounts: string[];\n\n  constructor(\n    name: string,\n    config: SandboxConfig,\n    repoPath: string,\n    visorDistPath: string,\n    cacheVolumeMounts: string[] = []\n  ) {\n    this.name = name;\n    this.config = config;\n    this.repoPath = repoPath;\n    this.visorDistPath = visorDistPath;\n    this.containerName = `visor-${name}-${randomUUID().slice(0, 8)}`;\n    this.cacheVolumeMounts = cacheVolumeMounts;\n  }\n\n  /**\n   * Build the Docker image if needed (dockerfile or dockerfile_inline mode)\n   */\n  private async buildImageIfNeeded(): Promise<string> {\n    if (this.config.image) {\n      return this.config.image;\n    }\n\n    const imageName = `visor-sandbox-${this.name}`;\n    const buildMode = this.config.dockerfile_inline ? 'inline' : 'dockerfile';\n\n    return withActiveSpan(\n      'visor.sandbox.build',\n      {\n        'visor.sandbox.name': this.name,\n        'visor.sandbox.build.mode': buildMode,\n      },\n      async () => {\n        if (this.config.dockerfile_inline) {\n          // Write inline Dockerfile to temp file\n          const tmpDir = mkdtempSync(join(tmpdir(), 'visor-build-'));\n          const dockerfilePath = join(tmpDir, 'Dockerfile');\n          writeFileSync(dockerfilePath, this.config.dockerfile_inline, 'utf8');\n\n          try {\n            logger.info(`Building sandbox image '${imageName}' from inline Dockerfile`);\n            await execAsync(`docker build -t ${imageName} -f ${dockerfilePath} ${this.repoPath}`, {\n              maxBuffer: EXEC_MAX_BUFFER,\n              timeout: 300000,\n            });\n          } finally {\n            try {\n              unlinkSync(dockerfilePath);\n            } catch {\n              /* ignore */\n            }\n          }\n\n          return imageName;\n        }\n\n        if (this.config.dockerfile) {\n          logger.info(`Building sandbox image '${imageName}' from ${this.config.dockerfile}`);\n          await execAsync(\n            `docker build -t ${imageName} -f ${this.config.dockerfile} ${this.repoPath}`,\n            { maxBuffer: EXEC_MAX_BUFFER, timeout: 300000 }\n          );\n          return imageName;\n        }\n\n        throw new Error(`Sandbox '${this.name}' has no image, dockerfile, or dockerfile_inline`);\n      }\n    );\n  }\n\n  /**\n   * Start the sandbox container\n   */\n  async start(): Promise<void> {\n    const image = await this.buildImageIfNeeded();\n    const workdir = this.config.workdir || '/workspace';\n    const visorPath = this.config.visor_path || '/opt/visor';\n    const readOnlySuffix = this.config.read_only ? ':ro' : '';\n\n    const args: string[] = [\n      'docker',\n      'run',\n      '-d',\n      '--name',\n      this.containerName,\n      '-v',\n      `${this.repoPath}:${workdir}${readOnlySuffix}`,\n      '-v',\n      `${this.visorDistPath}:${visorPath}:ro`,\n      '-w',\n      workdir,\n    ];\n\n    // Network isolation\n    if (this.config.network === false) {\n      args.push('--network', 'none');\n    }\n\n    // Resource limits\n    if (this.config.resources?.memory) {\n      args.push('--memory', this.config.resources.memory);\n    }\n    if (this.config.resources?.cpu) {\n      args.push('--cpus', String(this.config.resources.cpu));\n    }\n\n    // Cache volume mounts\n    for (const mount of this.cacheVolumeMounts) {\n      args.push('-v', mount);\n    }\n\n    // Image and keep-alive command\n    args.push(image, 'sleep', 'infinity');\n\n    const cmd = args.map(a => (a.includes(' ') ? `\"${a}\"` : a)).join(' ');\n    logger.info(`Starting sandbox container '${this.containerName}'`);\n\n    const { stdout } = await execAsync(cmd, { maxBuffer: EXEC_MAX_BUFFER, timeout: 60000 });\n    this.containerId = stdout.trim();\n    addEvent('visor.sandbox.container.started', {\n      container_name: this.containerName,\n      image,\n    });\n  }\n\n  /**\n   * Execute a command inside the running container\n   */\n  async exec(options: SandboxExecOptions): Promise<SandboxExecResult> {\n    if (!this.containerId) {\n      throw new Error(`Sandbox '${this.name}' is not started`);\n    }\n\n    const args: string[] = ['docker', 'exec'];\n\n    // Pass environment variables\n    for (const [key, value] of Object.entries(options.env)) {\n      args.push('-e', `${key}=${value}`);\n    }\n\n    args.push(this.containerName, 'sh', '-c', options.command);\n\n    const cmd = args\n      .map((a, i) => {\n        // Quote the last argument (the shell command) and env values\n        if (i === args.length - 1 || (i > 0 && args[i - 1] === '-e')) {\n          return `'${a.replace(/'/g, \"'\\\\''\")}'`;\n        }\n        return a.includes(' ') ? `\"${a}\"` : a;\n      })\n      .join(' ');\n\n    try {\n      const { stdout, stderr } = await execAsync(cmd, {\n        maxBuffer: options.maxBuffer || EXEC_MAX_BUFFER,\n        timeout: options.timeoutMs || 600000,\n      });\n      return { stdout, stderr, exitCode: 0 };\n    } catch (err: unknown) {\n      const execErr = err as { stdout?: string; stderr?: string; code?: number };\n      return {\n        stdout: execErr.stdout || '',\n        stderr: execErr.stderr || '',\n        exitCode: typeof execErr.code === 'number' ? execErr.code : 1,\n      };\n    }\n  }\n\n  /**\n   * Stop and remove the container\n   */\n  async stop(): Promise<void> {\n    if (this.containerName) {\n      try {\n        await execAsync(`docker rm -f ${this.containerName}`, {\n          maxBuffer: EXEC_MAX_BUFFER,\n          timeout: 30000,\n        });\n      } catch {\n        // Container may already be stopped\n      }\n      addEvent('visor.sandbox.container.stopped', {\n        container_name: this.containerName,\n      });\n      this.containerId = null;\n    }\n  }\n}\n","/**\n * Docker Compose-based sandbox implementation.\n * Supports multi-service environments (e.g., app + redis + postgres).\n */\n\nimport { promisify } from 'util';\nimport { exec as execCb } from 'child_process';\nimport { randomUUID } from 'crypto';\nimport { SandboxConfig, SandboxExecOptions, SandboxExecResult, SandboxInstance } from './types';\nimport { logger } from '../logger';\n\nconst execAsync = promisify(execCb);\n\nconst EXEC_MAX_BUFFER = 50 * 1024 * 1024; // 50MB\n\nexport class DockerComposeSandbox implements SandboxInstance {\n  name: string;\n  config: SandboxConfig;\n  private projectName: string;\n  private started = false;\n\n  constructor(name: string, config: SandboxConfig) {\n    this.name = name;\n    this.config = config;\n    this.projectName = `visor-${name}-${randomUUID().slice(0, 8)}`;\n  }\n\n  /**\n   * Start the compose services\n   */\n  async start(): Promise<void> {\n    if (!this.config.compose) {\n      throw new Error(`Sandbox '${this.name}' has no compose file specified`);\n    }\n    if (!this.config.service) {\n      throw new Error(`Sandbox '${this.name}' requires a 'service' field for compose mode`);\n    }\n\n    logger.info(`Starting compose sandbox '${this.name}' (project: ${this.projectName})`);\n\n    await execAsync(`docker compose -f ${this.config.compose} -p ${this.projectName} up -d`, {\n      maxBuffer: EXEC_MAX_BUFFER,\n      timeout: 120000,\n    });\n\n    this.started = true;\n  }\n\n  /**\n   * Execute a command inside the compose service\n   */\n  async exec(options: SandboxExecOptions): Promise<SandboxExecResult> {\n    if (!this.started) {\n      throw new Error(`Compose sandbox '${this.name}' is not started`);\n    }\n\n    const service = this.config.service!;\n    const args: string[] = [\n      'docker',\n      'compose',\n      '-f',\n      this.config.compose!,\n      '-p',\n      this.projectName,\n      'exec',\n      '-T', // non-interactive\n    ];\n\n    // Pass environment variables\n    for (const [key, value] of Object.entries(options.env)) {\n      args.push('-e', `${key}=${value}`);\n    }\n\n    // Working directory override\n    if (this.config.workdir) {\n      args.push('-w', this.config.workdir);\n    }\n\n    args.push(service, 'sh', '-c', options.command);\n\n    const cmd = args\n      .map((a, i) => {\n        if (i === args.length - 1 || (i > 0 && args[i - 1] === '-e')) {\n          return `'${a.replace(/'/g, \"'\\\\''\")}'`;\n        }\n        return a.includes(' ') ? `\"${a}\"` : a;\n      })\n      .join(' ');\n\n    try {\n      const { stdout, stderr } = await execAsync(cmd, {\n        maxBuffer: options.maxBuffer || EXEC_MAX_BUFFER,\n        timeout: options.timeoutMs || 600000,\n      });\n      return { stdout, stderr, exitCode: 0 };\n    } catch (err: unknown) {\n      const execErr = err as { stdout?: string; stderr?: string; code?: number };\n      return {\n        stdout: execErr.stdout || '',\n        stderr: execErr.stderr || '',\n        exitCode: typeof execErr.code === 'number' ? execErr.code : 1,\n      };\n    }\n  }\n\n  /**\n   * Stop and tear down the compose project\n   */\n  async stop(): Promise<void> {\n    if (this.started && this.config.compose) {\n      try {\n        await execAsync(`docker compose -f ${this.config.compose} -p ${this.projectName} down`, {\n          maxBuffer: EXEC_MAX_BUFFER,\n          timeout: 60000,\n        });\n      } catch {\n        // May already be stopped\n      }\n      this.started = false;\n    }\n  }\n}\n","/**\n * Docker named volume management for sandbox caching.\n * Creates, resolves, and evicts cache volumes based on sandbox configuration.\n */\n\nimport { promisify } from 'util';\nimport { exec as execCb } from 'child_process';\nimport { createHash } from 'crypto';\nimport { SandboxCacheConfig } from './types';\nimport { logger } from '../logger';\n\nconst execAsync = promisify(execCb);\nconst EXEC_MAX_BUFFER = 10 * 1024 * 1024;\n\n/**\n * Compute a short hash for a container path to use in volume names\n */\nfunction pathHash(containerPath: string): string {\n  return createHash('sha256').update(containerPath).digest('hex').slice(0, 8);\n}\n\n/**\n * Parse a TTL string (e.g., \"7d\", \"24h\", \"1h30m\") into milliseconds\n */\nfunction parseTtl(ttl: string): number {\n  let ms = 0;\n  const dayMatch = ttl.match(/(\\d+)d/);\n  const hourMatch = ttl.match(/(\\d+)h/);\n  const minMatch = ttl.match(/(\\d+)m/);\n\n  if (dayMatch) ms += parseInt(dayMatch[1], 10) * 86400000;\n  if (hourMatch) ms += parseInt(hourMatch[1], 10) * 3600000;\n  if (minMatch) ms += parseInt(minMatch[1], 10) * 60000;\n\n  return ms || 604800000; // default 7 days\n}\n\nexport interface ResolvedVolume {\n  /** Docker volume name */\n  volumeName: string;\n  /** Mount spec for docker run -v flag: \"volumeName:containerPath\" */\n  mountSpec: string;\n}\n\nexport class CacheVolumeManager {\n  /**\n   * Resolve cache config into Docker volume mount specs.\n   *\n   * Volume naming: visor-cache-<prefix>-<sandboxName>-<pathHash>\n   *\n   * @param sandboxName - Name of the sandbox\n   * @param cacheConfig - Cache configuration from sandbox config\n   * @param gitBranch - Current git branch (used as default prefix)\n   * @returns Array of volume mount specs for docker run -v\n   */\n  async resolveVolumes(\n    sandboxName: string,\n    cacheConfig: SandboxCacheConfig,\n    gitBranch: string\n  ): Promise<ResolvedVolume[]> {\n    const prefix = (cacheConfig.prefix || gitBranch).replace(/[^a-zA-Z0-9._-]/g, '-');\n    const volumes: ResolvedVolume[] = [];\n\n    for (const containerPath of cacheConfig.paths) {\n      const hash = pathHash(containerPath);\n      const volumeName = `visor-cache-${prefix}-${sandboxName}-${hash}`;\n\n      // Check if volume exists\n      const exists = await this.volumeExists(volumeName);\n\n      if (!exists && cacheConfig.fallback_prefix) {\n        // Try to copy from fallback prefix volume\n        const fallbackPrefix = cacheConfig.fallback_prefix.replace(/[^a-zA-Z0-9._-]/g, '-');\n        const fallbackVolume = `visor-cache-${fallbackPrefix}-${sandboxName}-${hash}`;\n        const fallbackExists = await this.volumeExists(fallbackVolume);\n\n        if (fallbackExists) {\n          logger.info(`Cache miss for '${volumeName}', copying from fallback '${fallbackVolume}'`);\n          await this.copyVolume(fallbackVolume, volumeName);\n        } else {\n          // Create empty volume\n          await this.createVolume(volumeName);\n        }\n      } else if (!exists) {\n        await this.createVolume(volumeName);\n      }\n\n      // Update last-used label\n      await this.touchVolume(volumeName);\n\n      volumes.push({\n        volumeName,\n        mountSpec: `${volumeName}:${containerPath}`,\n      });\n    }\n\n    return volumes;\n  }\n\n  /**\n   * Check if a Docker volume exists\n   */\n  private async volumeExists(name: string): Promise<boolean> {\n    try {\n      await execAsync(`docker volume inspect ${name}`, {\n        maxBuffer: EXEC_MAX_BUFFER,\n        timeout: 10000,\n      });\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Create a Docker named volume\n   */\n  private async createVolume(name: string): Promise<void> {\n    const now = new Date().toISOString();\n    await execAsync(`docker volume create --label visor.last-used=${now} ${name}`, {\n      maxBuffer: EXEC_MAX_BUFFER,\n      timeout: 10000,\n    });\n  }\n\n  /**\n   * Copy data from one volume to another using a temp container\n   */\n  private async copyVolume(source: string, target: string): Promise<void> {\n    await this.createVolume(target);\n    try {\n      await execAsync(\n        `docker run --rm -v ${source}:/src:ro -v ${target}:/dst alpine sh -c \"cp -a /src/. /dst/\"`,\n        { maxBuffer: EXEC_MAX_BUFFER, timeout: 60000 }\n      );\n    } catch (err) {\n      logger.warn(`Failed to copy cache volume ${source} -> ${target}: ${err}`);\n    }\n  }\n\n  /**\n   * Update the last-used label on a volume.\n   * Docker doesn't support updating labels in-place, so we record via a temp file approach\n   * by simply re-creating volumes with updated labels if they don't exist.\n   * For existing volumes, we track usage time via the volume name pattern.\n   */\n  private async touchVolume(_name: string): Promise<void> {\n    // Docker volume labels are immutable after creation.\n    // We track last-used via inspection of volume creation time\n    // and access patterns. This is a no-op for simplicity;\n    // eviction uses volume creation/inspection metadata instead.\n  }\n\n  /**\n   * Evict expired cache volumes for a sandbox\n   */\n  async evictExpired(sandboxName: string, ttl?: string, maxScopes?: number): Promise<void> {\n    const ttlMs = ttl ? parseTtl(ttl) : 604800000; // 7 days default\n    const maxScopesLimit = maxScopes || 10;\n\n    try {\n      // List all visor cache volumes for this sandbox\n      const { stdout } = await execAsync(\n        `docker volume ls --filter \"name=visor-cache-\" --format \"{{.Name}}\"`,\n        { maxBuffer: EXEC_MAX_BUFFER, timeout: 10000 }\n      );\n\n      const allVolumes = stdout.trim().split('\\n').filter(Boolean);\n      const sandboxVolumes = allVolumes.filter(v => v.includes(`-${sandboxName}-`));\n\n      if (sandboxVolumes.length === 0) return;\n\n      // Group by prefix (scope)\n      const scopeMap = new Map<string, string[]>();\n      for (const vol of sandboxVolumes) {\n        // visor-cache-<prefix>-<sandboxName>-<hash>\n        const match = vol.match(/^visor-cache-(.+)-\\w{8}$/);\n        if (match) {\n          const prefix = match[1].replace(`-${sandboxName}`, '');\n          if (!scopeMap.has(prefix)) scopeMap.set(prefix, []);\n          scopeMap.get(prefix)!.push(vol);\n        }\n      }\n\n      // Check each volume's creation time for TTL expiry\n      const now = Date.now();\n      for (const vol of sandboxVolumes) {\n        try {\n          const { stdout: inspectOut } = await execAsync(\n            `docker volume inspect ${vol} --format \"{{.CreatedAt}}\"`,\n            { maxBuffer: EXEC_MAX_BUFFER, timeout: 10000 }\n          );\n          const createdAt = new Date(inspectOut.trim()).getTime();\n          if (now - createdAt > ttlMs) {\n            logger.info(`Evicting expired cache volume: ${vol}`);\n            await execAsync(`docker volume rm ${vol}`, {\n              maxBuffer: EXEC_MAX_BUFFER,\n              timeout: 10000,\n            });\n          }\n        } catch {\n          // Skip volumes we can't inspect\n        }\n      }\n\n      // Enforce max_scopes by removing oldest scopes\n      if (scopeMap.size > maxScopesLimit) {\n        const scopes = Array.from(scopeMap.keys());\n        // Remove excess scopes (keep newest by alphabetical order as proxy)\n        const toRemove = scopes.slice(0, scopes.length - maxScopesLimit);\n        for (const scope of toRemove) {\n          const vols = scopeMap.get(scope) || [];\n          for (const vol of vols) {\n            try {\n              logger.info(`Evicting cache volume (max_scopes exceeded): ${vol}`);\n              await execAsync(`docker volume rm ${vol}`, {\n                maxBuffer: EXEC_MAX_BUFFER,\n                timeout: 10000,\n              });\n            } catch {\n              /* ignore */\n            }\n          }\n        }\n      }\n    } catch {\n      // Docker volume listing failed - skip eviction\n    }\n  }\n}\n","/*\n Thin SDK faade for programmatic use of Visor.\n - No new execution logic; delegates to existing engine and config manager.\n - Dual ESM/CJS bundle via tsup.\n*/\n\nimport { StateMachineExecutionEngine } from './state-machine-execution-engine';\nimport { ConfigManager } from './config';\nimport type { AnalysisResult } from './output-formatters';\nimport type { VisorConfig, TagFilter, HumanInputRequest } from './types/config';\nimport type { ExecutionContext } from './providers/check-provider.interface';\n\nexport type { VisorConfig, TagFilter, HumanInputRequest, ExecutionContext };\n\nexport interface VisorOptions {\n  cwd?: string;\n  debug?: boolean;\n  maxParallelism?: number;\n  failFast?: boolean;\n  tagFilter?: TagFilter;\n}\n\nexport interface RunOptions extends VisorOptions {\n  config?: VisorConfig;\n  configPath?: string;\n  checks?: string[]; // default: all checks from config\n  timeoutMs?: number;\n  output?: { format?: 'table' | 'json' | 'markdown' | 'sarif' };\n  /** Strict mode: treat config warnings (like unknown keys) as errors (default: false) */\n  strictValidation?: boolean;\n  /** Execution context for providers (CLI message, hooks, etc.) */\n  executionContext?: ExecutionContext;\n}\n\n/**\n * Load and validate a Visor config.\n * @param configOrPath - Config object, file path, or omit to discover defaults\n * @param options - Validation options\n * @returns Validated config with defaults applied\n */\nexport async function loadConfig(\n  configOrPath?: string | Partial<VisorConfig>,\n  options?: { strict?: boolean }\n): Promise<VisorConfig> {\n  const cm = new ConfigManager();\n\n  // If it's an object, validate and return with defaults\n  if (typeof configOrPath === 'object' && configOrPath !== null) {\n    cm.validateConfig(configOrPath, options?.strict ?? false);\n\n    // Apply lightweight defaults without expensive file system operations\n    const defaultConfig: Partial<VisorConfig> = {\n      version: '1.0',\n      checks: {},\n      max_parallelism: 3,\n      fail_fast: false,\n    };\n\n    return {\n      ...defaultConfig,\n      ...configOrPath,\n      checks: configOrPath.checks || {},\n    } as VisorConfig;\n  }\n\n  // If it's a string, load from file\n  if (typeof configOrPath === 'string') {\n    return cm.loadConfig(configOrPath);\n  }\n\n  // Otherwise discover default config file\n  return cm.findAndLoadConfig();\n}\n\n/** Expand check IDs by including their dependencies (shallow->deep). */\nexport function resolveChecks(checkIds: string[], config: VisorConfig | undefined): string[] {\n  if (!config?.checks) return Array.from(new Set(checkIds));\n  const resolved = new Set<string>();\n  const visiting = new Set<string>();\n  const result: string[] = [];\n\n  const dfs = (id: string, stack: string[] = []) => {\n    if (resolved.has(id)) return;\n    if (visiting.has(id)) {\n      const cycle = [...stack, id].join(' -> ');\n      throw new Error(`Circular dependency detected involving check: ${id} (path: ${cycle})`);\n    }\n    visiting.add(id);\n    const deps = config.checks![id]?.depends_on || [];\n    for (const d of deps) dfs(d, [...stack, id]);\n    if (!result.includes(id)) result.push(id);\n    visiting.delete(id);\n    resolved.add(id);\n  };\n\n  for (const id of checkIds) dfs(id);\n  return result;\n}\n\n/**\n * Run Visor checks programmatically. Returns the same AnalysisResult shape used by the CLI.\n * Thin wrapper around CheckExecutionEngine.executeChecks.\n */\nexport async function runChecks(opts: RunOptions = {}): Promise<AnalysisResult> {\n  const cm = new ConfigManager();\n  let config: VisorConfig;\n\n  if (opts.config) {\n    // Validate manually constructed config\n    // In strict mode, unknown keys are treated as errors\n    cm.validateConfig(opts.config, opts.strictValidation ?? false);\n    config = opts.config;\n  } else if (opts.configPath) {\n    config = await cm.loadConfig(opts.configPath);\n  } else {\n    config = await cm.findAndLoadConfig();\n  }\n\n  const checks =\n    opts.checks && opts.checks.length > 0\n      ? resolveChecks(opts.checks, config)\n      : Object.keys(config.checks || {});\n\n  // Always use StateMachineExecutionEngine\n  const engine = new StateMachineExecutionEngine(opts.cwd);\n\n  // Set execution context if provided\n  if (opts.executionContext) {\n    engine.setExecutionContext(opts.executionContext);\n  }\n\n  const result = await engine.executeChecks({\n    checks,\n    workingDirectory: opts.cwd,\n    timeout: opts.timeoutMs,\n    maxParallelism: opts.maxParallelism,\n    failFast: opts.failFast,\n    outputFormat: opts.output?.format,\n    config,\n    debug: opts.debug,\n    tagFilter: opts.tagFilter,\n  });\n\n  return result;\n}\n"],"mappings":"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","names":["resolve","promisify","execCb","randomUUID","execAsync","EXEC_MAX_BUFFER","promisify","execCb","execAsync","EXEC_MAX_BUFFER","path","MemoryStore","ConfigManager","initializeWorkspace","buildEngineContextForRun","fs","convertToReviewSummary","addEvent"]}