{"version":3,"sources":["../../src/frontends/host.ts"],"sourcesContent":["import { EventBus } from '../event-bus/event-bus';\n\nexport interface FrontendContext {\n  eventBus: EventBus;\n  logger: {\n    info: (...a: any[]) => void;\n    warn: (...a: any[]) => void;\n    error: (...a: any[]) => void;\n  };\n  config: unknown;\n  run: {\n    runId: string;\n    workflowId?: string;\n    repo?: { owner: string; name: string };\n    pr?: number;\n    headSha?: string;\n    event?: string;\n    actor?: string;\n  };\n  octokit?: any;\n  // Optional webhook context (e.g., Slack Events API payload injected by socket runner)\n  webhookContext?: { webhookData?: Map<string, unknown>; eventType?: string };\n}\n\nexport interface Frontend {\n  readonly name: string;\n  start(ctx: FrontendContext): Promise<void> | void;\n  stop(): Promise<void> | void;\n}\n\nexport interface FrontendSpec {\n  name: string; // e.g., 'ndjson-sink', 'github', 'slack'\n  package?: string; // external package name (future)\n  config?: unknown;\n}\n\nexport class FrontendsHost {\n  private bus: EventBus;\n  private log: FrontendContext['logger'];\n  private frontends: Frontend[] = [];\n\n  constructor(bus: EventBus, log: FrontendContext['logger']) {\n    this.bus = bus;\n    this.log = log;\n  }\n\n  async load(specs: FrontendSpec[]): Promise<void> {\n    this.frontends = [];\n    for (const spec of specs) {\n      if (spec.name === 'ndjson-sink') {\n        const { NdjsonSink } = await import('./ndjson-sink');\n        this.frontends.push(new NdjsonSink(spec.config));\n      } else if (spec.name === 'github') {\n        const { GitHubFrontend } = await import('./github-frontend');\n        this.frontends.push(new GitHubFrontend());\n      } else if (spec.name === 'slack') {\n        const { SlackFrontend } = await import('./slack-frontend');\n        this.frontends.push(new SlackFrontend(spec.config as any));\n      } else {\n        this.log.warn(`[FrontendsHost] Unknown frontend '${spec.name}', skipping`);\n      }\n    }\n  }\n\n  async startAll(ctxFactory: () => FrontendContext): Promise<void> {\n    for (const f of this.frontends) {\n      try {\n        await f.start(ctxFactory());\n        this.log.info(`[FrontendsHost] Started frontend '${f.name}'`);\n      } catch (err) {\n        this.log.error(`[FrontendsHost] Failed to start '${f.name}':`, err);\n      }\n    }\n  }\n\n  async stopAll(): Promise<void> {\n    for (const f of this.frontends) {\n      try {\n        await f.stop();\n      } catch (err) {\n        this.log.error(`[FrontendsHost] Failed to stop '${f.name}':`, err);\n      }\n    }\n  }\n}\n"],"mappings":";;;;;AAAA,IAoCa;AApCb;AAAA;AAoCO,IAAM,gBAAN,MAAoB;AAAA,MACjB;AAAA,MACA;AAAA,MACA,YAAwB,CAAC;AAAA,MAEjC,YAAY,KAAe,KAAgC;AACzD,aAAK,MAAM;AACX,aAAK,MAAM;AAAA,MACb;AAAA,MAEA,MAAM,KAAK,OAAsC;AAC/C,aAAK,YAAY,CAAC;AAClB,mBAAW,QAAQ,OAAO;AACxB,cAAI,KAAK,SAAS,eAAe;AAC/B,kBAAM,EAAE,WAAW,IAAI,MAAM,OAAO,4BAAe;AACnD,iBAAK,UAAU,KAAK,IAAI,WAAW,KAAK,MAAM,CAAC;AAAA,UACjD,WAAW,KAAK,SAAS,UAAU;AACjC,kBAAM,EAAE,eAAe,IAAI,MAAM,OAAO,gCAAmB;AAC3D,iBAAK,UAAU,KAAK,IAAI,eAAe,CAAC;AAAA,UAC1C,WAAW,KAAK,SAAS,SAAS;AAChC,kBAAM,EAAE,cAAc,IAAI,MAAM,OAAO,+BAAkB;AACzD,iBAAK,UAAU,KAAK,IAAI,cAAc,KAAK,MAAa,CAAC;AAAA,UAC3D,OAAO;AACL,iBAAK,IAAI,KAAK,qCAAqC,KAAK,IAAI,aAAa;AAAA,UAC3E;AAAA,QACF;AAAA,MACF;AAAA,MAEA,MAAM,SAAS,YAAkD;AAC/D,mBAAW,KAAK,KAAK,WAAW;AAC9B,cAAI;AACF,kBAAM,EAAE,MAAM,WAAW,CAAC;AAC1B,iBAAK,IAAI,KAAK,qCAAqC,EAAE,IAAI,GAAG;AAAA,UAC9D,SAAS,KAAK;AACZ,iBAAK,IAAI,MAAM,oCAAoC,EAAE,IAAI,MAAM,GAAG;AAAA,UACpE;AAAA,QACF;AAAA,MACF;AAAA,MAEA,MAAM,UAAyB;AAC7B,mBAAW,KAAK,KAAK,WAAW;AAC9B,cAAI;AACF,kBAAM,EAAE,KAAK;AAAA,UACf,SAAS,KAAK;AACZ,iBAAK,IAAI,MAAM,mCAAmC,EAAE,IAAI,MAAM,GAAG;AAAA,UACnE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA;AAAA;","names":[]}